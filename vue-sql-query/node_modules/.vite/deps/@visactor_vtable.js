import {
  AABBBounds,
  Bounds,
  Color,
  DAY,
  DEFAULT_COLORS,
  HOUR,
  LRU,
  Logger,
  MINUTE,
  MONTH,
  Matrix,
  OBBBounds,
  Point,
  PointService,
  SECOND,
  TextMeasure,
  U,
  aabbSeparation,
  abs,
  acos,
  array,
  arrayEqual,
  asin,
  atan2,
  binaryFuzzySearchInNumberRange,
  bisect,
  calculateAnchorOfBounds,
  clampAngleByRadian,
  clampRange_default,
  clamp_default,
  clamper,
  cloneDeep,
  color_exports,
  computeQuadrant,
  cos,
  crossProduct,
  debounce_default,
  degreeToRadian,
  epsilon,
  flattenArray,
  getAngleByPoint,
  getContextFont,
  getDecimalPlaces,
  getRectIntersect,
  get_default,
  halfPi,
  has_default,
  hexToRgb,
  import_eventemitter3,
  init_src,
  interpolateDate,
  interpolateNumber,
  interpolateNumberRound,
  isArray_default,
  isBase64_default,
  isBoolean_default,
  isEmpty_default,
  isEqual,
  isFunction_default,
  isGreater,
  isLess,
  isNil_default,
  isNumberClose,
  isNumber_default,
  isObject_default,
  isPlainObject_default,
  isPointInLine,
  isRectIntersect,
  isRotateAABBIntersect,
  isString_default,
  isUndefined_default,
  isValidNumber_default,
  isValidUrl_default,
  isValid_default,
  last,
  max,
  maxInArray,
  memoize,
  mercator_default,
  merge,
  min,
  minInArray,
  mixin,
  normalTransform,
  normalizeAngle,
  normalizePadding,
  obbSeparation,
  path_default,
  pi,
  pi2,
  pickWithout,
  pointAt,
  pointInRect,
  polarToCartesian,
  polygonContainPoint,
  radianToDegree,
  range,
  rectInsideAnotherRect,
  require_eventemitter3,
  require_geobuf,
  require_geojson_dissolve,
  require_lib,
  require_lottie,
  require_pbf,
  require_simplify_geojson,
  rotatePoint,
  simple_statistics_exports,
  sin,
  sqrt,
  tau,
  throttle_default,
  toNumber,
  transformBoundsWithMatrix
} from "./chunk-OFTBKGPI.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray4 = Array.isArray;
    module.exports = isArray4;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol3 = root.Symbol;
    module.exports = Symbol3;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol3 = require_Symbol();
    var objectProto4 = Object.prototype;
    var hasOwnProperty = objectProto4.hasOwnProperty;
    var nativeObjectToString = objectProto4.toString;
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result2 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result2;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto4 = Object.prototype;
    var nativeObjectToString = objectProto4.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol3 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike2;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray4 = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray4(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject4(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject4;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject4 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject4(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject4 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto4 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto4.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue2;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue2 = require_getValue();
    function getNative(object, key) {
      var value = getValue2(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result2 = this.has(key) && delete this.__data__[key];
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto4 = Object.prototype;
    var hasOwnProperty = objectProto4.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto4 = Object.prototype;
    var hasOwnProperty = objectProto4.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq2;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq2 = require_eq();
    function assocIndexOf(array4, key) {
      var length2 = array4.length;
      while (length2--) {
        if (eq2(array4[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result2 = getMapData(this, key)["delete"](key);
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize5(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result2 = func.apply(this, args);
        memoized.cache = cache.set(key, result2) || cache;
        return result2;
      };
      memoized.cache = new (memoize5.Cache || MapCache)();
      return memoized;
    }
    memoize5.Cache = MapCache;
    module.exports = memoize5;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize5 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result2 = memoize5(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result2.cache;
      return result2;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result2 = [];
      if (string.charCodeAt(0) === 46) {
        result2.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result2;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array4, iteratee) {
      var index = -1, length2 = array4 == null ? 0 : array4.length, result2 = Array(length2);
      while (++index < length2) {
        result2[index] = iteratee(array4[index], index, array4);
      }
      return result2;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol3 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray4 = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray4(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray4 = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray4(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length2 = path.length;
      while (object != null && index < length2) {
        object = object[toKey(path[index++])];
      }
      return index && index == length2 ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get6(object, path, defaultValue) {
      var result2 = object == null ? void 0 : baseGet(object, path);
      return result2 === void 0 ? defaultValue : result2;
    }
    module.exports = get6;
  }
});

// node_modules/cssfontparser/index.js
var require_cssfontparser = __commonJS({
  "node_modules/cssfontparser/index.js"(exports, module) {
    var cache = {};
    var fontRegex = new RegExp([
      "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
      "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
      "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
      "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
      `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
    ].join(""), "i");
    var mapping = [
      "style",
      "variant",
      "weight",
      "size",
      "lineHeight",
      "family"
    ];
    var unitMatch = /([\.0-9]+)(.*)/;
    var numeric = function(val, parent, dpi) {
      var matches = val.match(unitMatch);
      if (!matches) {
        return;
      }
      val = parseFloat(matches[1]);
      var units = matches[2].toLowerCase().trim();
      var v = Math.round(val);
      if (v === val) {
        val = v;
      }
      switch (units) {
        case "em":
          if (parent === null) {
            return;
          }
          return val * parent;
          break;
        case "px":
          return val;
          break;
        case "pt":
          return val / (72 / dpi);
          break;
        case "pc":
          return val / (6 / dpi);
          break;
        case "mm":
          return val * (dpi / 25.4);
          break;
        case "cm":
          return val * (dpi / 2.54);
          break;
        case "in":
          return val * dpi;
          break;
        case "%":
          if (parent === null) {
            return;
          }
          return parent * (val / 100);
          break;
      }
    };
    var op = {
      size: numeric,
      lineHeight: numeric
    };
    var generics = {
      serif: 1,
      "sans-serif": 1,
      cursive: 1,
      fantasy: 1,
      monospace: 1
    };
    var parse4 = module.exports = function(str2, existing, dpi) {
      var cacheKey = str2 + "-" + (existing || "null") + "@" + dpi;
      dpi = dpi || 96;
      if (typeof cache[cacheKey] !== "undefined") {
        return cache[cacheKey];
      }
      if (existing) {
        existing = parse4(existing, null, dpi);
      }
      if (str2 === "inherit") {
        return existing;
      }
      var matches = fontRegex.exec(str2);
      if (!matches) {
        cache[cacheKey] = null;
        return;
      }
      matches.shift();
      var collected = {};
      for (var i = 0; i < matches.length; i++) {
        var key = mapping[i];
        var val = matches[i];
        if (op[key] && val) {
          var existingVal = existing ? existing[key] || null : null;
          var v = op[key](val, existingVal, dpi);
          if (typeof v === "undefined" && key === "lineHeight" && val) {
            val = collected.size * parseFloat(val);
          } else {
            val = v;
          }
        }
        if (!val || val === "normal") {
          continue;
        } else if (val === "inherit") {
          if (!existing) {
            return;
          }
          val = existing[key];
        }
        if (val.trim) {
          val = val.trim();
        }
        collected[key] = val;
      }
      if (!Object.keys(collected).length) {
        collected = null;
      }
      cache[cacheKey] = collected;
      var out = [];
      if (collected.style) {
        out.push(collected.style);
      }
      if (collected.variant) {
        out.push(collected.variant);
      }
      if (collected.weight && collected.weight !== "400" && collected.weight !== "normal") {
        out.push(collected.weight);
      }
      out.push(collected.size + "px");
      if (collected.lineHeight) {
        out[out.length - 1] += "/" + collected.lineHeight + "px";
      }
      var family = collected.family.split(",");
      collected.family = family.map(function(a2) {
        a2 = a2.trim();
        if (generics[a2.toLowerCase()]) {
          a2 = a2.toLowerCase();
        }
        return a2;
      });
      out.push(collected.family);
      Object.defineProperty(collected, "toString", {
        value: function() {
          return out.map(function(val2) {
            if (Array.isArray(val2)) {
              return val2.map(function(a2) {
                if (a2.indexOf(" ") > -1) {
                  return '"' + a2.replace(/["']/g, "") + '"';
                } else {
                  return a2;
                }
              }).join(", ");
            } else {
              return val2;
            }
          }).join(" ");
        }
      });
      return collected;
    };
    module.exports.generics = generics;
  }
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/generator.js
var Generator = class _Generator {
  static GenAutoIncrementId() {
    return _Generator.auto_increment_id++;
  }
};
Generator.auto_increment_id = 0;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/cotainer-module.js
var ContainerModule = class {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/metadata_keys.js
var NAMED_TAG = "named";
var INJECT_TAG = "inject";
var MULTI_INJECT_TAG = "multi_inject";
var TAGGED = "inversify:tagged";
var PARAM_TYPES = "inversify:paramtypes";
function getNonCustomTagKeys() {
  return ["inject", "multi_inject", "name", "unmanaged", "named", "optional"];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/meta-data.js
var Metadata = class {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/Reflect-metadata.js
var Reflect_metadata_default = function(Reflect2) {
  var target, previous;
  return function(exporter) {
    Object.prototype.hasOwnProperty;
    const supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", functionPrototype = (supportsSymbol && void 0 !== Symbol.iterator && Symbol.iterator, Object.create, Object.getPrototypeOf(Function)), _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map), Metadata2 = (Set, /* @__PURE__ */ new WeakMap());
    function defineMetadata(metadataKey, metadataValue, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
    }
    function hasMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target2, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target2, propertyKey);
    }
    function getMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target2, propertyKey);
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      let targetMetadata = Metadata2.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map(), Metadata2.set(O, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return true;
      const parent = OrdinaryGetPrototypeOf(O);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      const parent = OrdinaryGetPrototypeOf(O);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      GetOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
    }
    function Type(x) {
      if (null === x) return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return void 0 === x;
    }
    function IsNull(x) {
      return null === x;
    }
    function IsSymbol(x) {
      return "symbol" == typeof x;
    }
    function IsObject(x) {
      return "object" == typeof x ? null !== x : "function" == typeof x;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result2 = exoticToPrim.call(input, hint);
        if (IsObject(result2)) throw new TypeError();
        return result2;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if ("string" === hint) {
        const toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          const result2 = toString_1.call(O);
          if (!IsObject(result2)) return result2;
        }
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2)) return result2;
        }
      } else {
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2)) return result2;
        }
        const toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          const result2 = toString_2.call(O);
          if (!IsObject(result2)) return result2;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V, P) {
      const func = V[P];
      if (null != func) {
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O) {
      const proto = Object.getPrototypeOf(O);
      if ("function" != typeof O || O === functionPrototype) return proto;
      if (proto !== functionPrototype) return proto;
      const prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O ? proto : constructor;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect2, function(key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: true,
      writable: true,
      value
    }), previous && previous(key, value);
  })), Reflect2;
}({});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject_base.js
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect_metadata_default.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect_metadata_default.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect_metadata_default.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return (serviceIdentifier) => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject.js
var inject = injectBase(INJECT_TAG);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/annotation/multi_inject.js
var multiInject = injectBase(MULTI_INJECT_TAG);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/annotation/injectable.js
function injectable() {
  return function(target) {
    return Reflect_metadata_default.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/annotation/named.js
function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/literal_types.js
var BindingScopeEnum = {
  Singleton: "Singleton",
  Transient: "Transient"
};
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/binding.js
var Binding = class _Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = false, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = (request) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone4 = new _Binding(this.serviceIdentifier, this.scope);
    return clone4.activated = clone4.scope === BindingScopeEnum.Singleton && this.activated, clone4.implementationType = this.implementationType, clone4.dynamicValue = this.dynamicValue, clone4.scope = this.scope, clone4.type = this.type, clone4.provider = this.provider, clone4.constraint = this.constraint, clone4.cache = this.cache, clone4;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/metadata_reader.js
var MetadataReader = class {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect_metadata_default.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect_metadata_default.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("暂未实现");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/syntax/constraint_helpers.js
var taggedConstraint = (key) => (value) => {
  const constraint = (request) => {
    if (null == request) return false;
    if (request.key === key && request.value === value) return true;
    if (null == request.constructorArgsMetadata) return false;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return true;
    return false;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
var namedConstraint = taggedConstraint(NAMED_TAG);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_in_syntax.js
var BindingInSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("暂未实现");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_to_syntax.js
var BindingToSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self2 = this._binding.serviceIdentifier;
    return this.to(self2);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue((context) => context.container.get(service));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/inversify/container.js
var Container = class {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = /* @__PURE__ */ new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named2) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named2);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope, binding = new Binding(serviceIdentifier, scope), list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
      bindingToSyntax._binding.moduleId = moduleId;
    }, getBindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.bind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    }, getUnbindFunction = () => (serviceIdentifier) => this.unbind(serviceIdentifier), getIsboundFunction = () => (serviceIdentifier) => this.isBound(serviceIdentifier), getRebindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.rebind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    };
    return (mId) => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: (serviceIdentifier) => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier
    };
  }
  _get(getArgs) {
    const result2 = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter((b) => b.constraint(getArgs)).forEach((binding) => {
      result2.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result2.length ? result2 : result2[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType, { userGeneratedMetadata } = this._metadataReader.getConstructorMetadata(constr), keys2 = Object.keys(userGeneratedMetadata), arr = [];
    for (let i = 0; i < keys2.length; i++) {
      const constructorArgsMetadata = userGeneratedMetadata[i], targetMetadataMap = {};
      constructorArgsMetadata.forEach((md) => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
        inject: targetMetadataMap[INJECT_TAG],
        multiInject: targetMetadataMap[MULTI_INJECT_TAG]
      }, injectIdentifier = metadata.inject || metadata.multiInject, target = {
        serviceIdentifier: injectIdentifier,
        constructorArgsMetadata
      }, bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter((b) => b.constraint(target));
      if (bindings.length) {
        const request = {
          injectIdentifier,
          metadata: constructorArgsMetadata,
          bindings
        };
        arr.push(request);
      }
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result2 = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result2), result2;
  }
  _getResolvedFromBinding(binding) {
    let result2;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result2 = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result2 = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result2 = binding.dynamicValue({
          container: this
        });
    }
    return result2;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated) return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map((request) => request.bindings.length > 1 ? request.bindings.map((binding) => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result2) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result2, binding.activated = true);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/contribution-provider.js
var ContributionProvider = Symbol("ContributionProvider");
var ContributionProviderCache = class {
  constructor(serviceIdentifier, container2) {
    this.serviceIdentifier = serviceIdentifier, this.container = container2, ContributionStore.setStore(this.serviceIdentifier, this);
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
  refresh() {
    this.caches && (this.caches.length = 0, this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier)));
  }
};
function bindContributionProvider(bind, id) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id, container2)).inSingletonScope().whenTargetNamed(id);
}
function bindContributionProviderNoSingletonScope(bind, id) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id, container2)).whenTargetNamed(id);
}
var ContributionStore = class {
  static getStore(id) {
    return this.store.get(id);
  }
  static setStore(id, cache) {
    this.store.set(id, cache);
  }
  static refreshAllContributions() {
    this.store.forEach((cache) => {
      cache.refresh();
    });
  }
};
ContributionStore.store = /* @__PURE__ */ new Map();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/tapable/Hook.js
var Hook = class {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter((tap) => !(tap.name === name && (!fn || tap.fn === fn))));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options) _options = {
      name: options.trim()
    };
    else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
    return _options = Object.assign({
      type,
      fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = /* @__PURE__ */ new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i = this.taps.length;
    for (; i > 0; ) {
      i--;
      const x = this.taps[i];
      this.taps[i + 1] = x;
      const xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) continue;
      }
      if (!(xStage > stage)) {
        i++;
        break;
      }
    }
    this.taps[i] = item;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/tapable/SyncHook.js
var SyncHook = class extends Hook {
  call(...args) {
    this.taps.map((t) => t.fn).forEach((cb) => cb(...args));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/constants.js
var EnvContribution = Symbol.for("EnvContribution");
var VGlobal = Symbol.for("VGlobal");
var DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/event-listener-manager.js
var EventListenerManager = class {
  constructor() {
    this._listenerMap = /* @__PURE__ */ new Map(), this._eventListenerTransformer = (event2) => event2;
  }
  setEventListenerTransformer(transformer) {
    this._eventListenerTransformer = transformer || ((event2) => event2);
  }
  addEventListener(type, listener, options) {
    if (!listener) return;
    const wrappedListener = (event2) => {
      const transformedEvent = this._eventListenerTransformer(event2);
      "function" == typeof listener ? listener(transformedEvent) : listener.handleEvent && listener.handleEvent(transformedEvent);
    };
    this._listenerMap.has(type) || this._listenerMap.set(type, /* @__PURE__ */ new Map()), this._listenerMap.get(type).set(listener, wrappedListener), this._nativeAddEventListener(type, wrappedListener, options);
  }
  removeEventListener(type, listener, options) {
    var _a;
    if (!listener) return;
    const wrappedListener = null === (_a = this._listenerMap.get(type)) || void 0 === _a ? void 0 : _a.get(listener);
    wrappedListener && (this._nativeRemoveEventListener(type, wrappedListener, options), this._listenerMap.get(type).delete(listener), 0 === this._listenerMap.get(type).size && this._listenerMap.delete(type));
  }
  dispatchEvent(event2) {
    return this._nativeDispatchEvent(event2);
  }
  clearAllEventListeners() {
    this._listenerMap.forEach((listenersMap, type) => {
      listenersMap.forEach((wrappedListener, originalListener) => {
        this._nativeRemoveEventListener(type, wrappedListener, void 0);
      });
    }), this._listenerMap.clear();
  }
  _nativeAddEventListener(type, listener, options) {
    throw new Error("_nativeAddEventListener must be implemented by derived classes");
  }
  _nativeRemoveEventListener(type, listener, options) {
    throw new Error("_nativeRemoveEventListener must be implemented by derived classes");
  }
  _nativeDispatchEvent(event2) {
    throw new Error("_nativeDispatchEvent must be implemented by derived classes");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/global.js
var __decorate = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DefaultGlobal = class extends EventListenerManager {
  get env() {
    return this._env;
  }
  get isImageAnonymous() {
    return this._isImageAnonymous;
  }
  set isImageAnonymous(isImageAnonymous) {
    this._isImageAnonymous = isImageAnonymous;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    super(), this.contributions = contributions, this._isImageAnonymous = true, this.eventListenerTransformer = (event2) => event2, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = false;
  }
  _nativeAddEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  _nativeRemoveEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  _nativeDispatchEvent(event2) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event2);
  }
  bindContribution(params2) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach((contribution) => {
      const data = contribution.configure(this, params2);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length) return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params2) {
    if (params2 && true === params2.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params2);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params2) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params2);
    if (data && data.then) return data.then(() => {
      this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
    });
    this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params2);
  }
  createOffscreenCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params2);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str2) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str2) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event2, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event2, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str2) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str2);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  loadFont(name, source, descriptors) {
    return __awaiter(this, void 0, void 0, function* () {
      return this._env || this.setEnv("browser"), this.envContribution.loadFont(name, source, descriptors);
    });
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params2);
  }
  updateDom(dom, params2) {
    return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params2);
  }
  getElementTop(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
  isMacOS() {
    return this._env || this.setEnv("browser"), this.envContribution.isMacOS();
  }
  copyToClipBoard(text2) {
    return this._env || this.setEnv("browser"), this.envContribution.copyToClipBoard(text2);
  }
};
DefaultGlobal = __decorate([injectable(), __param(0, inject(ContributionProvider)), __param(0, named(EnvContribution)), __metadata("design:paramtypes", [Object])], DefaultGlobal);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/interface/graphic/bounds.js
var params;
!function(params2) {
  params2[params2.W = 1] = "W", params2[params2.H = 2] = "H", params2[params2.WH = 3] = "WH";
}(params || (params = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/interface/graphic/text.js
var MeasureModeEnum;
!function(MeasureModeEnum2) {
  MeasureModeEnum2[MeasureModeEnum2.estimate = 0] = "estimate", MeasureModeEnum2[MeasureModeEnum2.actualBounding = 1] = "actualBounding", MeasureModeEnum2[MeasureModeEnum2.fontBounding = 2] = "fontBounding";
}(MeasureModeEnum || (MeasureModeEnum = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/bounds-context.js
var circleThreshold = tau - 1e-8;
var BoundsContext = class {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
    let s2, i, x, y, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;
    function update2(a2) {
      x = r * Math.cos(a2), y = r * Math.sin(a2), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
    }
    if (update2(sa), update2(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s2 = sa, sa = ea, ea = s2), ccw) for (ea -= tau, s2 = sa - sa % halfPi, i = 0; i < 4 && s2 > ea; ++i, s2 -= halfPi) update2(s2);
    else for (s2 = sa - sa % halfPi + halfPi, i = 0; i < 4 && s2 < ea; ++i, s2 += halfPi) update2(s2);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this.bounds.add(x1, y1);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
  }
  closePath() {
  }
  ellipse() {
    throw new Error("不支持ellipse");
  }
  lineTo(x, y) {
    this.bounds.add(x, y);
  }
  moveTo(x, y) {
    this.bounds.add(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
  }
  rect(x, y, w, h) {
    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
  }
  clear() {
    this.bounds.clear();
  }
  release(...params2) {
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/path.js
var CurvePath = class {
  constructor() {
    this._curves = [], this.bounds = new AABBBounds();
  }
  get curves() {
    return this._curves;
  }
  getCurveLengths() {
    return this._curves.map((curve) => curve.getLength());
  }
  getPointAt(t) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/path-svg.js
var rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
var commandLengths = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7,
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7
};
var enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
var currPath;
var coordsStr;
var commandChar;
var coordStr;
var coordNumber;
var standardCommandLen;
function parseSvgPath(str2) {
  if (!str2) return [];
  const paths = str2.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths) return [];
  let currCommandData, coordsStrArr;
  const result2 = [];
  for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
    for (let i2 = 0, len2 = coordsStrArr.length; i2 < len2; i2++) coordStr = coordsStrArr[i2], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
      let subCommand, bestCommandChar = commandChar;
      for (let i2 = 1, len2 = currCommandData.length; i2 < len2; i2 += standardCommandLen) {
        subCommand = [bestCommandChar];
        for (let j = i2, subLen = i2 + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
        result2.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
      }
    } else result2.push(currCommandData);
  } else result2.push(currCommandData);
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/enums.js
var UpdateTag;
!function(UpdateTag2) {
  UpdateTag2[UpdateTag2.NONE = 0] = "NONE", UpdateTag2[UpdateTag2.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag2[UpdateTag2.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag2[UpdateTag2.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag2[UpdateTag2.INIT = 179] = "INIT", UpdateTag2[UpdateTag2.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag2[UpdateTag2.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function(IContainPointMode2) {
  IContainPointMode2[IContainPointMode2.GLOBAL = 1] = "GLOBAL", IContainPointMode2[IContainPointMode2.LOCAL = 16] = "LOCAL", IContainPointMode2[IContainPointMode2.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode2[IContainPointMode2.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function(AttributeUpdateType2) {
  AttributeUpdateType2[AttributeUpdateType2.INIT = 0] = "INIT", AttributeUpdateType2[AttributeUpdateType2.DEFAULT = 1] = "DEFAULT", AttributeUpdateType2[AttributeUpdateType2.STATE = 2] = "STATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType2[AttributeUpdateType2.SCALE = 22] = "SCALE", AttributeUpdateType2[AttributeUpdateType2.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType2[AttributeUpdateType2.ROTATE = 24] = "ROTATE", AttributeUpdateType2[AttributeUpdateType2.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var AnimateStatus;
!function(AnimateStatus2) {
  AnimateStatus2[AnimateStatus2.INITIAL = 0] = "INITIAL", AnimateStatus2[AnimateStatus2.RUNNING = 1] = "RUNNING", AnimateStatus2[AnimateStatus2.PAUSED = 2] = "PAUSED", AnimateStatus2[AnimateStatus2.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));
var AnimateMode;
!function(AnimateMode2) {
  AnimateMode2[AnimateMode2.NORMAL = 0] = "NORMAL", AnimateMode2[AnimateMode2.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));
var AnimateStepType;
!function(AnimateStepType2) {
  AnimateStepType2.wait = "wait", AnimateStepType2.from = "from", AnimateStepType2.to = "to", AnimateStepType2.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var Direction;
!function(Direction4) {
  Direction4[Direction4.ROW = 1] = "ROW", Direction4[Direction4.COLUMN = 2] = "COLUMN";
}(Direction || (Direction = {}));
var CurveTypeEnum;
!function(CurveTypeEnum2) {
  CurveTypeEnum2[CurveTypeEnum2.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum2[CurveTypeEnum2.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum2[CurveTypeEnum2.ArcCurve = 2] = "ArcCurve", CurveTypeEnum2[CurveTypeEnum2.LineCurve = 3] = "LineCurve", CurveTypeEnum2[CurveTypeEnum2.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum2[CurveTypeEnum2.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function(BaseRenderContributionTime2) {
  BaseRenderContributionTime2[BaseRenderContributionTime2.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime2[BaseRenderContributionTime2.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/shape/arc.js
function segments(x, y, rx, ry, large, sweep, rotateX2, ox, oy) {
  const th = degreeToRadian(rotateX2), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5, py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x0 = a00 * ox + a01 * oy, y0 = a10 * ox + a11 * oy, x1 = a00 * x + a01 * y, y1 = a10 * x + a11 * y;
  let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - 0.25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0), yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0), th0 = Math.atan2(y0 - yc, x0 - xc);
  let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi + 1e-3))), result2 = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs, th3 = th0 + (i + 1) * th_arc / segs;
    result2[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result2;
}
function bezier(params2) {
  const cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = 0.5 * (th1 - th0), sin_th_h2 = Math.sin(0.5 * th_half), t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x1 = cx + cos_th0 - t * sin_th0, y1 = cy + sin_th0 + t * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x2 = x3 + t * sin_th1, y2 = y3 - t * cos_th1;
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
  const delta = Math.abs(endAngle - startAngle), count = delta > 0.5 * Math.PI ? Math.ceil(2 * delta / Math.PI) : 1, stepAngle = (endAngle - startAngle) / count;
  for (let i = 0; i < count; i++) {
    const sa = startAngle + stepAngle * i, ea = startAngle + stepAngle * (i + 1), len = 4 * Math.tan(Math.abs(stepAngle) / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c2 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/render-command-list.js
var commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
  for (let i = 0; i < commandList.length; i++) {
    const command = commandList[i];
    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
  }
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/base.js
var Curve = class {
  getLength(direction) {
    return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/bezier-utils.js
function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i = 0; i < count; i++) {
    const x = xArr[i], y = yArr[i], nextX = xArr[(i + 1) % count], nextY = yArr[(i + 1) % count];
    totalLength += PointService.distanceNN(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
  const one = 1 - t;
  return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t), y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
  return new Point(x, y);
}
function quadCalc(p0, p1, p2, t) {
  const one = 1 - t;
  return one * one * p0 + 2 * one * t * p1 + t * t * p2;
}
function quadPointAt(p0, p1, p2, t) {
  const x = quadCalc(p0.x, p1.x, p2.x, t), y = quadCalc(p0.y, p1.y, p2.y, t);
  return new Point(x, y);
}
function quadLength(p0, p1, p2, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/quadratic-bezier.js
var QuadraticBezierCurve = class extends Curve {
  constructor(p0, p1, p2) {
    super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
  }
  getPointAt(t) {
    if (false !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? quadLength(this.p0, this.p1, this.p2, 0) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - 0.01, 0), maxT = min(t + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);
    else if (percent > 0) {
      const [curve1] = divideQuad(this, percent);
      path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
    }
  }
  getYAt(x) {
    throw new Error("QuadraticBezierCurve暂不支持getYAt");
  }
  includeX(x) {
    throw new Error("QuadraticBezierCurve暂不支持includeX");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/cubic-bezier.js
function divideCubic(curve, t) {
  const { p0, p1, p2, p3 } = curve, pt = cubicPointAt(p0, p1, p2, p3, t), c1 = PointService.pointAtPP(p0, p1, t), c2 = PointService.pointAtPP(p1, p2, t), c3 = PointService.pointAtPP(p2, p3, t), c12 = PointService.pointAtPP(c1, c2, t), c23 = PointService.pointAtPP(c2, c3, t);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
}
function divideQuad(curve, t) {
  const { p0, p1, p2 } = curve, pt = quadPointAt(p0, p1, p2, t), c1 = PointService.pointAtPP(p0, p1, t), c2 = PointService.pointAtPP(p1, p2, t);
  return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c2, p2)];
}
var CubicBezierCurve = class extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t) {
    if (false !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3, 0) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - 0.01, 0), maxT = min(t + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);
    else if (percent > 0) {
      const [curve1] = divideCubic(this, percent);
      path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
    }
  }
  includeX(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x), maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
    return x >= minX && x <= maxX;
  }
  getYAt(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x), t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
    return this.getPointAt(t).y;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/line.js
function divideLinear(curve, t) {
  const { p0, p1 } = curve, c1 = PointService.pointAtPP(p0, p1, t);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
var LineCurve = class extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t) {
    if (false !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  getAngleAt(t) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);
    else if (percent > 0) {
      const p = this.getPointAt(percent);
      path.lineTo(p.x * sx + x, p.y * sy + y);
    }
  }
  includeX(x) {
    return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
  }
  getYAt(x) {
    if (this.includeX(x)) {
      let minP = this.p0, maxP = this.p1;
      this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
      const percent = (x - minP.x) / (maxP.x - minP.x);
      return minP.y + percent * (maxP.y - minP.y);
    }
    return 1 / 0;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/seg-context.js
var SegContext = class {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction) {
    this.init(curveType, direction);
  }
  init(curveType, direction) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  closePath() {
    if (this.curves.length < 2) return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext不支持调用ellipse");
  }
  lineTo(x, y, defined, p) {
    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  moveTo(x, y, p) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    throw new Error("SegContext不支持调用quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction) {
    return this.getLength(direction);
  }
  addLinearCurve(x, y, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t) {
    throw new Error("暂未实现");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction) {
    var _a, _b;
    if (direction === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction === Direction.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c2) => l + c2.getLength(), 0)), this.length;
  }
};
var ReflectSegContext = class extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
  }
  lineTo(x, y, defined, p) {
    return super.lineTo(y, x, defined, p);
  }
  moveTo(x, y, p) {
    return super.moveTo(y, x, p);
  }
  clear() {
    return super.clear();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/common.js
function genCurveSegments(path, points, step = 1) {
  let defined0 = false;
  for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
}
function genSegContext(curveType, direction, points) {
  const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/linear.js
var Linear = class {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
    }
    this._lastDefined = p.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genLinearSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/basis.js
function point(curveClass, x, y, defined, p) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
var Basis = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point) point(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("basis", direction, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/monotone.js
function sign(x) {
  return x < 0 ? -1 : 1;
}
function slope3(curveClass, x2, y2) {
  const h0 = curveClass._x1 - curveClass._x0, h1 = x2 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
  const h = curveClass._x1 - curveClass._x0;
  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}
function point2(curveClass, t0, t1, defined, p) {
  const x0 = curveClass._x0, y0 = curveClass._y0, x1 = curveClass._x1, y1 = curveClass._y1, dx = (x1 - x0) / 3;
  curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
}
var MonotoneX = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point2(this, this._t0, slope2(this, this._t0), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    let t1 = NaN;
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point2(this, slope2(this, t1 = slope3(this, x, y)), t1, false !== this._lastDefined1 && false !== this._lastDefined2, p);
        break;
      default:
        point2(this, this._t0, t1 = slope3(this, x, y), false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = false !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var MonotoneY = class extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p) {
    return super.point({
      y: p.x,
      x: p.y,
      defined: p.defined
    });
  }
};
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneX", direction, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneY", direction, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/step.js
var Step = class {
  constructor(context, t = 0.5, startPoint) {
    this.context = context, this._t = t, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, false !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0) this.context.lineTo(this._x, y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
        else {
          const x1 = this._x * (1 - this._t) + x * this._t;
          0.5 === this._t ? this.context.lineTo(x1, this._y, false !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x1, y, false !== this._lastDefined && false !== p.defined, p);
        }
    }
    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var StepClosed = class extends Step {
  lineEnd() {
    this.context.closePath();
  }
};
function genStepSegments(points, t, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}
function genStepClosedSegments(points, t, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/linear-closed.js
var LinearClosed = class extends Linear {
  lineEnd() {
    this.context.closePath();
  }
};
function genLinearClosedSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/catmull-rom.js
function point3(curveClass, x, y, defined, p) {
  let x1 = curveClass._x1, y1 = curveClass._y1, x2 = curveClass._x2, y2 = curveClass._y2;
  if (curveClass._l01_a > epsilon) {
    const a2 = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a, n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
    x1 = (x1 * a2 - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a2 - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
  }
  if (curveClass._l23_a > epsilon) {
    const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a, m3 = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
    x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m3, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m3;
  }
  curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
}
var CatmullRom = class {
  constructor(context, alpha = 0.5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x2, this._y2, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2
        });
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const { x, y } = p;
    if (this._point) {
      const x23 = this._x2 - x, y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2) : this.context.moveTo(x, y);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function commonGenCatmullRomSegments(type, cons) {
  return function(points, alpha, params2 = {}) {
    const { direction, startPoint } = params2;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
    const segContext = genSegContext(type, direction, points), gatmullRom = new cons(segContext, alpha, startPoint);
    return genCurveSegments(gatmullRom, points, 2), segContext;
  };
}
var genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/catmull-rom-close.js
var CatmullRomClosed = class {
  constructor(context, alpha = 0.5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
        break;
      case 2:
        this.context.lineTo(this._x3, this._y3, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1), this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3
        }), this.point({
          x: this._x4,
          y: this._y4
        }), this.point({
          x: this._x5,
          y: this._y5
        });
    }
  }
  point(p) {
    const { x, y } = p;
    if (this._point) {
      const x23 = this._x2 - x, y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = x, this._y3 = y;
        break;
      case 1:
        this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
        break;
      case 2:
        this._point = 3, this._x5 = x, this._y5 = y;
        break;
      default:
        point3(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/curve/curve-context.js
var CurveContext = class {
  constructor(path) {
    this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
  }
  moveTo(x, y) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
  }
  lineTo(x, y) {
    const curve = this.addLinearCurve(x, y);
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  addLinearCurve(x, y) {
    return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
    this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    throw new Error("CurveContext不支持调用arcTo");
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    throw new Error("CurveContext不支持调用ellipse");
  }
  rect(x, y, w, h) {
    throw new Error("CurveContext不支持调用rect");
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    throw new Error("CurveContext不支持调用arc");
  }
  closePath() {
    this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/segment/index.js
function calcLineCache(points, curveType, params2) {
  var _a, _b;
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepClosed":
      return genStepClosedSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "catmullRom":
      return genCatmullRomSegments(points, null !== (_a = null == params2 ? void 0 : params2.curveTension) && void 0 !== _a ? _a : 0.5, params2);
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(points, null !== (_b = null == params2 ? void 0 : params2.curveTension) && void 0 !== _b ? _b : 0.5, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/custom-path2d.js
var CustomPath2D = class extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  get curves() {
    return this.tryBuildCurves();
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x, y) {
    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
  }
  lineTo(x, y) {
    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x, y, w, h) {
    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this._curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
  }
  beginPath() {
    this.clear();
  }
  tryBuildCurves() {
    if (!this._curves || !this._curves.length) {
      const curveContext = new CurveContext(this);
      renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
    }
    return this._curves;
  }
  toString() {
    if (!this.toStringCbList) {
      const list2 = [];
      list2[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list2[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list2[enumCommandMap.A] = (cmd) => {
        const bezierPathList = [];
        addArcToBezierPath(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
        let path2 = "";
        for (let i = 0; i < bezierPathList.length; i += 6) path2 += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
        return path2;
      }, list2[enumCommandMap.R] = (cmd) => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list2[enumCommandMap.Z] = (cmd) => "Z", this.toStringCbList = list2;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach((c2) => {
      path += list[c2[0]](c2);
    }), path;
  }
  fromString(str2, x, y, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str2);
    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
  }
  fromLine(line) {
    const { points, curveType, clipRangeByDimension } = line.attribute;
    if (!points) return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
  }
  fromCustomPath2D(path, x, y, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
  }
  transform(x, y, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach((cmd) => {
      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  lineToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  quadraticCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
  }
  bezierCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
  }
  arcToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {
  }
  _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
    let current, tempX, tempY, tempControlX, tempControlY, previous = null, x = 0, y = 0, controlX = 0, controlY = 0;
    for (let i = 0, len = commandStrList.length; i < len; ++i) {
      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), current[0]) {
        case "l":
          x += current[1], y += current[2], this.lineTo(x + l, y + t);
          break;
        case "L":
          x = current[1], y = current[2], this.lineTo(x + l, y + t);
          break;
        case "h":
          x += current[1], this.lineTo(x + l, y + t);
          break;
        case "H":
          x = current[1], this.lineTo(x + l, y + t);
          break;
        case "v":
          y += current[1], this.lineTo(x + l, y + t);
          break;
        case "V":
          y = current[1], this.lineTo(x + l, y + t);
          break;
        case "m":
          x += current[1], y += current[2], this.moveTo(x + l, y + t);
          break;
        case "M":
          x = current[1], y = current[2], this.moveTo(x + l, y + t);
          break;
        case "c":
          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "C":
          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
          break;
        case "s":
          tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "q":
          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "a":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
          break;
        case "A":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
      const current = commandList[i].slice();
      switch (current[0]) {
        case enumCommandMap.L:
          this.lineToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.M:
          this.moveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.C:
          this.bezierCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Q:
          this.quadraticCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.A:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.E:
          this.ellipseTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.R:
          this.rectTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.AT:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Z:
          this.closePath();
      }
    }
    else this.commandList = commandList.map((entry) => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0], ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0], ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this._curves.reduce((l, c2) => l + c2.getLength(), 0);
  }
  getYAt(x) {
    if (!this.curves) return 1 / 0;
    for (let i = 0; i < this.curves.length; i++) {
      const curve = this.curves[i];
      if (curve.includeX(x)) return curve.getYAt(x);
    }
    return 1 / 0;
  }
  getAttrAt(distance) {
    if (!this._curves) return {
      pos: {
        x: 0,
        y: 0
      },
      angle: 0
    };
    let curve, _dis = 0;
    for (let i = 0; i < this._curves.length; i++) {
      curve = this._curves[i];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance) break;
      _dis += cl;
    }
    const t = (distance - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t),
      angle: curve.getAngleAt(t)
    };
  }
  drawWithClipRange(ctx, size, x, y, clipRange) {
    this.tryBuildCurves();
    const totalLen = this.getLength() * clipRange;
    let currLen = 0;
    for (let i = 0; i < this._curves.length; i++) {
      const curve = this._curves[i], cl = curve.getLength(this.direction);
      if (!(currLen + cl <= totalLen)) {
        const percent = 1 - (currLen + cl - totalLen) / cl;
        curve.draw(ctx, x, y, size, size, percent);
        break;
      }
      curve.draw(ctx, x, y, size, size, 1), currLen += cl;
    }
  }
};
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale(current, sX, sY) {
  const c2 = temp[0] = current[0];
  if ("a" === c2 || "A" === c2) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];
  else if ("h" === c2 || "H" === c2) temp[1] = sX * current[1];
  else if ("v" === c2 || "V" === c2) temp[1] = sY * current[1];
  else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
  return temp;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/config.js
var DefaultLayout = {
  alignSelf: "auto"
};
var DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
var DefaultFillStyle = {
  fillOpacity: 1,
  fill: false,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: false
};
var DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
var DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  maxWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "…",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: false,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: false,
  verticalMode: 0,
  wrap: false,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  underlineDash: [],
  underlineOffset: 0,
  disableAutoClipedPoptip: void 0,
  measureMode: MeasureModeEnum.fontBounding,
  keepCenterInLine: false
};
var DefaultPickStyle = {
  pickStrokeBuffer: 0
};
var DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  forceBoundsWidth: void 0,
  forceBoundsHeight: void 0,
  opacity: 1,
  background: null,
  autoAnimateTexture: false,
  textureRatio: 1,
  textureOptions: null,
  backgroundOpacity: 1,
  backgroundCornerRadius: 0,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: true,
  backgroundKeepAspectRatio: false,
  backgroundClip: true,
  backgroundScale: 1,
  backgroundOffsetX: 0,
  backgroundOffsetY: 0,
  blur: 0,
  filter: "",
  cursor: null,
  html: null,
  react: null,
  vue: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
var DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
var DefaultDebugAttribute = {
  _debug_bounds: false
};
var DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  renderable: true,
  pickable: true,
  shadowGraphic: void 0,
  childrenPickable: true,
  fillPickable: true,
  strokePickable: true,
  visible: true,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  fillStrokeOrder: 0,
  renderStyle: "default",
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: true,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden",
  shadowPickMode: "graphic",
  keepStrokeScale: false,
  clipConfig: null
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
var DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  innerPadding: 0,
  outerPadding: 0,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: false,
  forceShowCap: false
});
var DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: false,
  curveTension: 1
});
var DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
var DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: false,
  visibleAll: true,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start",
  baseOpacity: 1,
  cornerType: "round"
});
var DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: false
});
var DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: false,
  curveTension: 1
});
var DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  fillStrokeOrder: 1,
  clipRange: 1,
  customPath: () => {
    Logger.getInstance().warn("空函数");
  }
});
var DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: true
});
var DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 100,
  height: 100,
  spikes: 5,
  thickness: 0.5
});
var DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0,
  cornerType: "round"
});
var DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
  cornerType: "round"
});
var DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: true,
  clipRange: 1
});
var DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: true
});
var DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  upgradeAttrs: null,
  editable: false,
  editOptions: null,
  ascentDescentMode: "actual",
  width: 300,
  height: 300,
  ellipsis: true,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  disableAutoWrapLine: false,
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: false
});
var DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0,
  maxWidth: 500,
  maxHeight: 500
}, DefaultAttribute), {
  fill: true,
  cornerRadius: 0,
  cornerType: "round"
});
var DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: false,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/application.js
var Application = class {
};
var application = new Application();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/color-utils.js
var parse = /* @__PURE__ */ function() {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function(pattern2, callback) {
      const captures = scan(pattern2);
      if (captures) {
        scan(tokens.startCall) || error("Missing (");
        const result2 = callback(captures);
        return scan(tokens.endCall) || error("Missing )"), result2;
      }
    }(pattern, function(captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations, lookaheadCache, radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function() {
      const circle2 = match("shape", /^(circle)/i, 0);
      circle2 && (circle2.style = matchLength() || matchExtentKeyword());
      return circle2;
    }() || function() {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType) radialType.at = matchAtPosition();
    else {
      const extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y) return {
      type: "position",
      value: location
    };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result2 = [];
    if (captures) for (result2.push(captures); scan(tokens.comma); ) captures = matcher(), captures ? result2.push(captures) : error("One extra comma");
    return result2;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) return {
      type,
      value: captures[captureIndex]
    };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    return input = code.toString(), getAST();
  };
}();
var GradientParser = class _GradientParser {
  static IsGradient(c2) {
    return !("string" == typeof c2 && !c2.includes("gradient"));
  }
  static IsGradientStr(c2) {
    return "string" == typeof c2 && c2.includes("gradient");
  }
  static Parse(c2) {
    if (_GradientParser.IsGradientStr(c2)) try {
      const datum = parse(c2)[0];
      if (datum) {
        if ("linear" === datum.type) return _GradientParser.ParseLinear(datum);
        if ("radial" === datum.type) return _GradientParser.ParseRadial(datum);
        if ("conic" === datum.type) return _GradientParser.ParseConic(datum);
      }
    } catch (err) {
      return c2;
    }
    return c2;
  }
  static ParseConic(datum) {
    const { orientation, colorStops = [] } = datum, halfPi6 = pi / 2, sa = parseFloat(orientation.value) / 180 * pi - halfPi6;
    return {
      gradient: "conical",
      x: 0.5,
      y: 0.5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseRadial(datum) {
    const { colorStops = [] } = datum;
    return {
      gradient: "radial",
      x0: 0.5,
      y0: 0.5,
      x1: 0.5,
      y1: 0.5,
      r0: 0,
      r1: 1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseLinear(datum) {
    const { orientation, colorStops = [] } = datum, halfPi6 = pi / 2;
    let angle2 = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle2 < 0; ) angle2 += pi2;
    for (; angle2 >= pi2; ) angle2 -= pi2;
    let x0 = 0, y0 = 0, x1 = 0, y1 = 0;
    return angle2 < halfPi6 ? (x0 = 0, y0 = 1, x1 = Math.sin(angle2), y1 = y0 - Math.cos(angle2)) : angle2 < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle2 - halfPi6), y1 = Math.sin(angle2 - halfPi6)) : angle2 < pi + halfPi6 ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle2 - pi), y1 = Math.cos(angle2 - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle2 - halfPi6 - pi), y1 -= Math.sin(angle2 - halfPi6 - pi)), {
      gradient: "linear",
      x0,
      y0,
      x1,
      y1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/canvas-utils.js
function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const { a: a2, b, c: c2, d } = context.currentMatrix, scaleX = Math.sign(a2) * Math.sqrt(a2 * a2 + b * b), scaleY = Math.sign(d) * Math.sqrt(c2 * c2 + d * d);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c2, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d;
  if (!c2 || true === c2) return "black";
  let result2, color;
  if (isArray_default(c2)) for (let i = 0; i < c2.length && (color = c2[i], !color); i++) ;
  else color = c2;
  if (color = GradientParser.Parse(color), "string" == typeof color) return color;
  if (params2.AABBBounds && (!params2.attribute || 0 !== params2.attribute.scaleX || 0 !== params2.attribute.scaleY)) {
    const bounds = params2.AABBBounds;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params2.attribute) {
      const { scaleX = 1, scaleY = 1, angle: angle2 = 0 } = params2.attribute;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle2 || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params2.x1WithoutTransform) && void 0 !== _a ? _a : 0, y = null !== (_b = params2.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params2.widthWithoutTransform) && void 0 !== _c ? _c : w, h = null !== (_d = params2.heightWithoutTransform) && void 0 !== _d ? _d : h);
    }
    "linear" === color.gradient ? result2 = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result2 = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result2 = createRadialGradient(context, color, x, y, w, h));
  }
  return result2 || "orange";
}
function createLinearGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d;
  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d, _e, _f;
  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0.5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0.5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : 0.5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : 0.5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : 0.5));
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, x, y, w, h) {
  var _a, _b;
  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, void 0) : canvasGradient;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/utils.js
var DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
var defaultFormatting = {
  fontSize: 16,
  fontFamily: DEFAULT_TEXT_FONT_FAMILY,
  fill: true,
  stroke: false,
  fontWeight: "normal",
  lineHeight: "normal",
  fontStyle: "normal",
  textDecoration: "none",
  textAlign: "left",
  script: "normal"
};
var nbsp = String.fromCharCode(160);
var regLetter = /\w|\(|\)|-/;
var regPunctuation = /[.?!,;:/，。？！、；：]/;
var regFirstSpace = /\S/;
var setTextStyle = (ctx, character) => {
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily
  });
};
function applyFillStyle(ctx, character, b) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle) return void (ctx.globalAlpha = 0);
  const { fillOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
    AABBBounds: b
  }) : fillStyle, setTextStyle(ctx, character);
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle) return void (ctx.globalAlpha = 0);
  const { strokeOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (desc.length <= 1) return 0;
  if (!width || width <= 0) return 0;
  const textMeasure2 = application.graphicUtil.textMeasure;
  let index = guessIndex, temp2 = desc.slice(0, index), tempWidth = Math.floor(textMeasure2.measureText(temp2, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure2.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width; ) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp2 = desc.slice(0, index), tempWidth = Math.floor(textMeasure2.measureText(temp2, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure2.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function testLetter(string, index, negativeWrongMatch = false) {
  let i = index;
  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
  return i;
}
function testLetter2(string, index) {
  let i = index;
  for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i++, i >= string.length) return i;
  return i + 1;
}
function measureTextCanvas(text2, character, mode = "actual") {
  var _a;
  if ("" === text2) return {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  };
  const measurement = application.graphicUtil.textMeasure.measureText(text2, character), result2 = {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  }, ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent, descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
  "number" != typeof ascent || "number" != typeof descent ? (result2.width = Math.floor(measurement.width), result2.height = character.fontSize || 0, result2.ascent = result2.height, result2.descent = 0) : (result2.width = Math.floor(measurement.width), result2.height = Math.floor(ascent + descent), result2.ascent = Math.floor(ascent), result2.descent = result2.height - result2.ascent);
  const space = null !== (_a = character.space) && void 0 !== _a ? _a : 0;
  return result2.width += space, result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/AtextMeasure.js
var __decorate2 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  _measureTextWithoutAlignBaseline(text2, options, compatible) {
    this.context.setTextStyleWithoutAlignBaseline(options);
    const metrics = this.context.measureText(text2);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  _measureTextWithAlignBaseline(text2, options, compatible) {
    this.context.setTextStyle(options);
    const metrics = this.context.measureText(text2);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  compatibleMetrics(metrics, options) {
    if (null == metrics.actualBoundingBoxAscent || null == metrics.actualBoundingBoxDescent || null == metrics.fontBoundingBoxAscent || null == metrics.fontBoundingBoxDescent) {
      metrics = {
        width: metrics.width
      };
      const { ascent, descent } = this.measureTextBoundADscentEstimate(options);
      metrics.actualBoundingBoxAscent = ascent, metrics.actualBoundingBoxDescent = descent, metrics.fontBoundingBoxAscent = ascent, metrics.fontBoundingBoxDescent = descent;
    }
    if (null == metrics.actualBoundingBoxLeft || null == metrics.actualBoundingBoxRight) {
      metrics = {
        width: metrics.width,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
      const { left, right } = this.measureTextBoundLeftRightEstimate(options);
      metrics.actualBoundingBoxLeft = left, metrics.actualBoundingBoxRight = right;
    }
    return metrics;
  }
  estimate(text2, { fontSize = DefaultTextAttribute.fontSize }) {
    let eCharLen = 0, cCharLen = 0;
    for (let i = 0; i < text2.length; i++) text2.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextWidth(text2, options, textMeasure2) {
    return this.context ? (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithoutAlignBaseline(text2, options)).width : this.estimate(text2, options).width;
  }
  measureTextBoundsWidth(text2, options, textMeasure2) {
    return this.context ? (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithoutAlignBaseline(text2, options)).width : this.estimate(text2, options).width;
  }
  measureTextBoundsLeftRight(text2, options, textMeasure2) {
    return this.context ? {
      left: (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithAlignBaseline(text2, options, true)).actualBoundingBoxLeft,
      right: textMeasure2.actualBoundingBoxRight
    } : this.measureTextBoundLeftRightEstimate(options);
  }
  measureTextPixelHeight(text2, options, textMeasure2) {
    var _a;
    return this.context ? (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithoutAlignBaseline(text2, options, true), Math.abs(textMeasure2.actualBoundingBoxAscent - textMeasure2.actualBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextPixelADscent(text2, options, textMeasure2) {
    return this.context ? {
      ascent: (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithAlignBaseline(text2, options, true)).actualBoundingBoxAscent,
      descent: textMeasure2.actualBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundHieght(text2, options, textMeasure2) {
    var _a;
    return this.context ? (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithoutAlignBaseline(text2, options, true), Math.abs(textMeasure2.fontBoundingBoxAscent - textMeasure2.fontBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextBoundADscent(text2, options, textMeasure2) {
    return this.context ? {
      ascent: (textMeasure2 = null != textMeasure2 ? textMeasure2 : this._measureTextWithAlignBaseline(text2, options, true)).fontBoundingBoxAscent,
      descent: textMeasure2.fontBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundADscentEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    return {
      ascent: 0.79 * fontSize,
      descent: 0.21 * fontSize
    };
  }
  measureTextBoundLeftRightEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize, { textAlign } = options;
    return "center" === textAlign ? {
      left: fontSize / 2,
      right: fontSize / 2
    } : "right" === textAlign || "end" === textAlign ? {
      left: fontSize,
      right: 0
    } : {
      left: 0,
      right: fontSize
    };
  }
  measureTextPixelADscentAndWidth(text2, options, mode) {
    if (!this.context) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: this.estimate(text2, options).width
    });
    const out = this._measureTextWithoutAlignBaseline(text2, options, true);
    if (mode === MeasureModeEnum.actualBounding) return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
    if (mode === MeasureModeEnum.estimate) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: out.width
    });
    if (mode === MeasureModeEnum.fontBounding) {
      let ascent = out.fontBoundingBoxAscent, descent = out.fontBoundingBoxDescent;
      if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
        const delta = out.actualBoundingBoxDescent - descent;
        descent += delta, ascent -= delta;
      } else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
        const delta = out.actualBoundingBoxAscent - ascent;
        ascent += delta, descent -= delta;
      }
      return {
        ascent,
        descent,
        width: out.width
      };
    }
    return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
  }
  measureText(text2, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text2)) : this.estimate(text2, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const { fontSize = 12 } = options;
    verticalList.forEach((item) => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length2 = 0, i = 0;
    for (; i < verticalList.length && length2 + verticalList[i].width < width; i++) length2 += verticalList[i].width, out.push(verticalList[i]);
    if (verticalList[i] && verticalList[i].text.length > 1) {
      const clipedData = this._clipText(verticalList[i].text, options, width - length2, 0, verticalList[i].text.length - 1, "end", false);
      if (wordBreak && clipedData.str !== verticalList[i].text) {
        let text2 = "", length3 = 0;
        for (let j = 0; j < i; j++) {
          const item = verticalList[j];
          text2 += item.text, length3 += item.text.length;
        }
        text2 += verticalList[i].text;
        const totalLength = length3 + clipedData.str.length;
        let index = testLetter(text2, totalLength);
        index -= length3, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i]), {
        text: clipedData.str,
        width: clipedData.width
      })), length2 += clipedData.width;
    }
    return {
      verticalList: out,
      width: length2
    };
  }
  clipText(text2, options, width, wordBreak, keepAllBreak) {
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    let length2 = this.measureTextWidth(text2, options);
    if (length2 <= width) return {
      str: text2,
      width: length2
    };
    if (length2 = this.measureTextWidth(text2[0], options), length2 > width) return {
      str: "",
      width: 0
    };
    const data = this._clipText(text2, options, width, 0, text2.length - 1, "end", false);
    if (wordBreak && data.str !== text2) {
      let index = testLetter(text2, data.str.length, keepAllBreak);
      index !== data.str.length && (index > data.str.length && (data.wordBreaked = index, index = data.str.length), data.str = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text2, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position) data = this._clipTextStart(text2, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);
    else if ("middle" === position) {
      const d = this._clipTextMiddle(text2, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d.width,
        result: d.left + suffix + d.right
      };
    } else data = this._clipTextEnd(text2, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text2, options, width, leftIdx, rightIdx) {
    if (leftIdx === rightIdx) {
      Logger.getInstance().warn(`【_clipTextEnd】不应该走到这里${text2}, ${leftIdx}, ${rightIdx}`);
      const subText2 = text2.substring(0, rightIdx + 1);
      return {
        str: subText2,
        width: this.measureTextWidth(subText2, options)
      };
    }
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text2.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str2 = text2.substring(0, middleIdx);
      return length2 = this.measureTextWidth(str2, options), length2 <= width ? {
        str: str2,
        width: length2
      } : this._clipTextEnd(text2, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text2.length - 1) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str2 = text2.substring(0, middleIdx + 2);
      return length2 = this.measureTextWidth(str2, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text2, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2), subText = text2.substring(middleIdx - 1, text2.length), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str2 = text2.substring(middleIdx, text2.length);
      return length2 = this.measureTextWidth(str2, options), length2 <= width ? {
        str: str2,
        width: length2
      } : this._clipTextStart(text2, options, width, middleIdx, text2.length);
    }
    if (strWidth < width) {
      if (middleIdx <= 0) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str2 = text2.substring(middleIdx - 2, text2.length);
      return length2 = this.measureTextWidth(str2, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text2, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text2, options, width, left, right, leftW, rightW, buffer) {
    const subLeftText = text2.substring(0, buffer), strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width) return {
      left,
      right,
      width: leftW + rightW
    };
    const subRightText = text2.substring(text2.length - buffer, text2.length), strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text2, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v = this.revertVerticalList(out.verticalList);
      v.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak), nextVerticalList = this.revertVerticalList(verticalList), rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach((v) => leftOut.verticalList.push(v)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
      text: suffix,
      direction: 1,
      width: suffixWidth
    });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map((l) => {
      const t = l.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l), {
        text: t
      });
    });
  }
  clipTextWithSuffix(text2, options, width, suffix, wordBreak, position, forceSuffix = false) {
    if ("" === suffix) return this.clipText(text2, options, width, wordBreak);
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    const length2 = this.measureTextWidth(text2, options);
    if (!forceSuffix && length2 <= width) return {
      str: text2,
      width: length2
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    if (forceSuffix && length2 + suffixWidth <= width) return {
      str: text2 + suffix,
      width: length2 + suffixWidth
    };
    width -= suffixWidth;
    const data = this._clipText(text2, options, width, 0, text2.length - 1, position, suffix);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.result = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    } else forceSuffix && data.str === text2 && (data.result = text2 + suffix);
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate2([injectable()], ATextMeasure);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/textMeasure-contribution.js
var __decorate3 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TextMeasureContribution = Symbol.for("TextMeasureContribution");
var DefaultTextMeasureContribution = class extends ATextMeasure {
};
DefaultTextMeasureContribution = __decorate3([injectable()], DefaultTextMeasureContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/container.js
var container = new Container();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/canvas/constants.js
var CanvasFactory = Symbol.for("CanvasFactory");
var Context2dFactory = Symbol.for("Context2dFactory");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/canvas/util.js
function wrapCanvas(params2) {
  return container.getNamed(CanvasFactory, application.global.env)(params2);
}
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = Math.sqrt(3);
var ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
var _v0 = [0, 0];
var _v1 = [0, 0];
var _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a2 = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c2 = p0 - val;
  let n = 0;
  if (isAroundZero(a2)) {
    if (isNotAroundZero(b)) {
      const t1 = -c2 / b;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a2 * c2;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a2);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a2), t2 = (-b - discSqrt) / (2 * a2);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? 0.5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  let t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d && (t = _t, d = d1);
  }
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
    const prev = t - interval, next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) t = prev, d = d1;
    else {
      _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distanceSquare(_v2, _v0);
      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5;
    }
  }
  return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  let prev, next, d1, d2, t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5);
  return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
}
function normalizeRadian(angle2) {
  return (angle2 %= pi2) < 0 && (angle2 += pi2), angle2;
}
function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return false;
  return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}
function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return false;
  return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  x -= cx, y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) return false;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return true;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle2 = Math.atan2(y, x);
  return angle2 < 0 && (angle2 += pi2), angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle;
}
function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth, _halfL = lineWidth / 2;
  let _a = 0, _b = x0;
  if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return false;
  if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
  _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  const tmp = _a * x - y + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
var EPSILON = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a2 = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c2 = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a2 * c2, B = b * c2 - 9 * a2 * d, C = c2 * c2 - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) if (isAroundZero(b)) roots2[0] = 0;
  else {
    const t1 = -c2 / b;
    t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
  }
  else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A, t1 = -b / a2 + K, t2 = -K / 2;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y1 = A * b + 1.5 * a2 * (-B + discSqrt), Y2 = A * b + 1.5 * a2 * (-B - discSqrt);
      Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
      const t1 = (-b - (Y1 + Y2)) / (3 * a2);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else {
      const T = (2 * A * b - 3 * a2 * B) / (2 * Math.sqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = Math.sqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a2), t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a2), t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a2);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2), t3 >= 0 && t3 <= 1 && (roots2[n++] = t3);
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b = 6 * p2 - 12 * p1 + 6 * p0, a2 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c2 = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a2)) {
    if (isNotAroundZero(b)) {
      const t1 = -c2 / b;
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a2 * c2;
    if (isAroundZero(disc)) extrema2[0] = -b / (2 * a2);
    else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a2), t2 = (-b - discSqrt) / (2 * a2);
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema2[n++] = t2);
    }
  }
  return n;
}
function isAroundEqual(a2, b) {
  return Math.abs(a2 - b) < EPSILON;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (0 === nRoots) return 0;
  let w = 0, nExtrema = -1, y0_ = 0, y1_ = 0;
  for (let i = 0; i < nRoots; i++) {
    const t = roots[i], unit = 0 === t || 1 === t ? 0.5 : 1;
    cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
  }
  return w;
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (0 === nRoots) return 0;
  const t = quadraticExtremum(y0, y1, y2);
  if (t >= 0 && t <= 1) {
    let w = 0;
    const y_ = quadraticAt(y0, y1, y2, t);
    for (let i = 0; i < nRoots; i++) {
      const unit2 = 0 === roots[i] || 1 === roots[i] ? 0.5 : 1;
      quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit2 : -unit2 : w += y2 < y_ ? unit2 : -unit2);
    }
    return w;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? 0.5 : 1;
  return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  if ((y -= cy) > r || y < -r) return 0;
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle, endAngle = tmp2;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle2 = Math.atan2(y, x_), dir = anticlockwise ? 1 : -1;
      angle2 < 0 && (angle2 = pi2 + angle2), (angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle) && (angle2 > pi / 2 && angle2 < 1.5 * pi && (dir = -dir), w += dir);
    }
  }
  return w;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modpi2(angles[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
}
var tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
  const data = commands, len = commands.length;
  let x1, y1, w = 0, xi = 0, yi = 0, x0 = 0, y0 = 0;
  for (let i = 0; i < len; i++) {
    const command = data[i], isFirst = 0 === i;
    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += isPointInLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
    const c0 = command[0], c1 = command[1], c2 = command[2], c3 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];
    let startAngle = c4, endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x - c1) * c3 / c3 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x0 = c1, y0 = c2, xi = x0, yi = y0;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return true;
        } else w += isPointInLine(xi, yi, c1, c2, x, y) || 0;
        xi = c1, yi = c2;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return true;
        } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return true;
        } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
        xi = c3, yi = c4;
        break;
      case enumCommandMap.A:
        if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, y0 = y1) : w += isPointInLine(xi, yi, x1, y1, x, y), isStroke) {
          if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return true;
        } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
        break;
      case enumCommandMap.R:
        if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
          if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return true;
        } else w += isPointInLine(x1, y0, x1, y1, x, y), w += isPointInLine(x0, y1, x0, y0, x, y);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return true;
        } else w += isPointInLine(xi, yi, x0, y0, x, y);
        xi = x0, yi = y0;
    }
  }
  return isStroke || isAroundEqual(yi, y0) || (w += isPointInLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
}
function contain(commands, x, y) {
  return containPath(commands, 0, false, x, y);
}
function containStroke(commands, lineWidth, x, y) {
  return containPath(commands, lineWidth, true, x, y);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/allocator/canvas-allocate.js
var DefaultCanvasAllocate = class {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c2 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c2), c2;
    }
    const m3 = this.pools.pop();
    return m3.resize(data.width, data.height), m3.dpr = data.dpr, m3;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
        width: canvas.width / canvas.dpr,
        height: canvas.height / canvas.dpr,
        dpr: canvas.dpr
      }, c2 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c2), c2;
    }
    const m3 = this.pools.pop();
    return m3.width = canvas.width, m3.height = canvas.height, m3;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var canvasAllocate = new DefaultCanvasAllocate();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/window.js
var __decorate4 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata2 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var VWindow = Symbol.for("VWindow");
var WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
var DefaultWindow = class extends EventListenerManager {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    super(), this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this.active = () => {
      const global2 = this.global;
      if (!global2.env || this.actived) return;
      container.getNamed(WindowHandlerContribution, global2.env).configure(this, global2), this.actived = true;
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  _nativeAddEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  _nativeRemoveEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  _nativeDispatchEvent(event2) {
    return this._handler.dispatchEvent(event2);
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var _a;
    return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
  }
  set style(style2) {
    this._handler.setStyle(style2);
  }
  create(params2) {
    var _a, _b;
    this._handler.createWindow(params2);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, params2.viewBox ? this.setViewBox(params2.viewBox) : false !== params2.canvasControled ? this.setViewBox({
      x1: 0,
      y1: 0,
      x2: this._width,
      y2: this._height
    }) : this.setViewBox({
      x1: 0,
      y1: 0,
      x2: null !== (_a = params2.width) && void 0 !== _a ? _a : this._width,
      y2: null !== (_b = params2.height) && void 0 !== _b ? _b : this._height
    }), this.title = this._handler.getTitle(), this.resizable = true;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w, h) {
    return this._handler.resizeWindow(w, h);
  }
  configure() {
    throw new Error("暂不支持");
  }
  release() {
    return this.global.hooks.onSetEnv.unTap("window", this.active), this.clearAllEventListeners(), this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(color) {
    this._handler.clearViewBox(color);
  }
  setViewBox(viewBox) {
    this._handler.setViewBox(viewBox);
  }
  setViewBoxTransform(a2, b, c2, d, e, f) {
    this._handler.setViewBoxTransform(a2, b, c2, d, e, f);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(x, y) {
    const vb = this._handler.getViewBox(), nextP = {
      x,
      y
    };
    return this._handler.getViewBoxTransform().transformPoint({
      x,
      y
    }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
  }
  hasSubView() {
    const viewBox = this._handler.getViewBox();
    return !(0 === viewBox.x1 && 0 === viewBox.y1 && isNumberClose(this.width, viewBox.width()) && isNumberClose(this.height, viewBox.height()));
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate4([injectable(), __metadata2("design:paramtypes", [])], DefaultWindow);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/graphic-utils.js
var __decorate5 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata3 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = false, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global2) => {
      this.configured = false, this.configure(global2, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global2, env) {
    this.configured || (this.contributions.getContributions().forEach((contribution) => {
      contribution.configure(this, env);
    }), this.configured = true);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text2, tc, method = "native") {
    var _a;
    this.configure(this.global, this.global.env);
    const m3 = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text2, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m3, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer) return null;
    const window2 = container.get(VWindow), bounds = graphic.AABBBounds, width = bounds.width(), height = bounds.height(), x1 = -bounds.x1, y1 = -bounds.y1;
    window2.create({
      viewBox: {
        x1,
        y1,
        x2: bounds.x2,
        y2: bounds.y2
      },
      width,
      height,
      canvas,
      dpr: stage.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    });
    const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = true, stage.defaultLayer.getNativeHandler().drawTo(window2, [graphic], {
      transMatrix: window2.getViewBoxTransform(),
      viewBox: window2.getViewBox(),
      stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: true,
      updateBounds: false
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c2 = window2.getNativeHandler();
    return c2.nativeCanvas ? c2.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate5([injectable(), __param2(0, inject(ContributionProvider)), __param2(0, named(TextMeasureContribution)), __metadata3("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function(TransformMode2) {
  TransformMode2[TransformMode2.transform = 0] = "transform", TransformMode2[TransformMode2.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
var _matrix = new Matrix();
var DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const { x, y } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle2, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const { x, y } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle2), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.rotate(angle2);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
  }
  rotate(angle2, center) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle2, center) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate5([injectable(), __metadata3("design:paramtypes", [])], DefaultTransformUtil);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/theme.js
var defaultThemeObj = {
  arc: DefaultArcAttribute,
  area: DefaultAreaAttribute,
  circle: DefaultCircleAttribute,
  line: DefaultLineAttribute,
  path: DefaultPathAttribute,
  symbol: DefaultSymbolAttribute,
  text: DefaultTextAttribute,
  rect: DefaultRectAttribute,
  polygon: DefaultPolygonAttribute,
  star: DefaultStarAttribute,
  richtext: DefaultRichTextAttribute,
  richtextIcon: DefaultRichTextIconAttribute,
  image: DefaultImageAttribute,
  group: DefaultGroupAttribute,
  glyph: DefaultGlyphAttribute
};
var themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    star: Object.assign({}, defaultThemeObj.star),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t) {
  Object.keys(t).forEach((k2) => {
    out[k2] = t[k2];
  });
}
var globalThemeObj = newThemeObj();
var Theme = class {
  constructor() {
    this.initTheme(), this.dirty = false;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach((key) => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent; ) if ((group = group.parent).theme) return group;
    return null;
  }
  applyTheme(group, pt, force = false) {
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, true);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = false);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme, combinedTheme = this.combinedTheme;
    themeKeys.forEach((k2) => {
      const obj2 = Object.create(globalThemeObj[k2]);
      parentCombinedTheme && parentCombinedTheme[k2] && combine(obj2, parentCombinedTheme[k2]), combinedTheme[k2] && combine(obj2, combinedTheme[k2]), userTheme[k2] && combine(obj2, userTheme[k2]), this.combinedTheme[k2] = obj2;
    }), userTheme.common && themeKeys.forEach((k2) => {
      combine(this.combinedTheme[k2], userTheme.common);
    }), this.dirty = false;
  }
  setTheme(t, g) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t).forEach((k2) => {
      userTheme[k2] ? Object.assign(userTheme[k2], t[k2]) : userTheme[k2] = Object.assign({}, t[k2]);
    }) : userTheme = t, this.userTheme = userTheme, this.dirty = true, this.dirtyChildren(g);
  }
  resetTheme(t, g) {
    this.userTheme = t, this.dirty = true, this.dirtyChildren(g);
  }
  dirtyChildren(g) {
    g.forEachChildren((item) => {
      item.isContainer && (item.theme && (item.theme.dirty = true), this.dirtyChildren(item));
    });
  }
};
var globalTheme = new Theme();
function getTheme(graphic, theme4) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme4 ? (graphic.isContainer, theme4) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g;
  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
    for (; g && !g.theme; ) g = g.parent;
    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
  }
  return null;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/node-tree.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Node = class extends import_eventemitter3.default {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb, reverse = false) {
    if (reverse) {
      let child = this._lastChild, i = 0;
      for (; child; ) {
        if (cb(child, i++)) return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild, i = 0;
      for (; child; ) {
        if (cb(child, i++)) return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb, reverse = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (reverse) {
        let child = this._lastChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node, highPerformance = true) {
    if (this._uid === node._uid) return null;
    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = true, node;
  }
  appendChildArrHighPerformance(nodes, replace = false) {
    return console.error("暂不支持该函数"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
    if (this === newNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;
    else {
      let child = this._firstChild;
      for (let i = 0; i < idx; i++) {
        if (!child) return null;
        i > 0 && (child = child._next);
      }
      if (!child) return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
      const node2 = this._nodeList[idx];
      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node2);
    }
    let node;
    this._nodeList[idx] = newNode;
    for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--) ;
    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = true;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = false, data;
  }
  removeChild(child) {
    if (!this._idMap) return null;
    if (!this._idMap.has(child._uid)) return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx = this._nodeList.findIndex((n) => n === child);
      idx >= 0 && this._nodeList.splice(idx, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = true, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(deep) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let child = this._firstChild;
    for (; child; ) {
      const next = child._next;
      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
    }
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = true, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("暂不支持");
  }
  find(callback, deep = false) {
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, true)), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const node = child.find(callback, true);
        if (node) return target = node, true;
      }
      return false;
    }), target;
  }
  findAll(callback, deep = false) {
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const targets = child.findAll(callback, true);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id) {
    return this.find((node) => node.id === id, true);
  }
  findChildById(id) {
    return this.getElementById(id);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll((node) => node.name === name, true);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll((node) => node.type === type, true);
  }
  getChildByName(name, deep = false) {
    return this.find((node) => node.name === name, deep);
  }
  getChildAt(idx) {
    let c2 = this._firstChild;
    if (!c2) return null;
    for (let i = 0; i < idx; i++) {
      if (!c2._next) return null;
      c2 = c2._next;
    }
    return c2;
  }
  at(idx) {
    return this.getChildAt(idx);
  }
  containNode(node) {
    if (!this._idMap) return false;
    if (this._idMap.has(node._uid)) return true;
    let child = this._firstChild;
    for (; child; ) {
      if (child.containNode(node)) return true;
      child = child._next;
    }
    return false;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent; ) parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child; ) nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent) return false;
    do {
      if (parent._uid === node._uid) return true;
      parent = parent.parent;
    } while (null !== parent);
    return false;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx) {
    throw new Error("暂不支持");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent) do {
      parent._count += deltaCount, parent = parent.parent;
    } while (null !== parent);
  }
  clone() {
    throw new Error("暂不支持");
  }
  cloneTo(node) {
    throw new Error("暂不支持");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, once = isObject_default(options) && options.once, context = isFunction_default(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, context = isFunction_default(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent;
    const once = isObject_default(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject_default(options) ? (options.once = true, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: true
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event2, ...args) {
    return super.emit(event2.type, event2, ...args), !event2.defaultPrevented;
  }
  emit(event2, data) {
    return this.dispatchEvent(event2, data);
  }
  release() {
    this.removeAllListeners();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/federated-event/base-event.js
var FederatedEvent = class _FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = _FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
  }
  composedDetailPath() {
    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
  }
  _composedDetailPath(params2) {
    if (params2 && params2.graphic) {
      const g = params2.graphic;
      if (g.stage) {
        const path = g.stage.eventSystem.manager.propagationPath(g);
        this.detailPath.push(path), this._composedDetailPath(params2.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
    } catch (err) {
      this.nativeEvent.preventDefault && isFunction_default(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
    } catch (err) {
      this.nativeEvent.stopPropagation && isFunction_default(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = true;
  }
  initEvent() {
  }
  initUIEvent() {
  }
  clone() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/federated-event/mouse-event.js
var FederatedMouseEvent = class extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = {
      x: 0,
      y: 0
    }, this.movement = {
      x: 0,
      y: 0
    }, this.offset = {
      x: 0,
      y: 0
    }, this.global = {
      x: 0,
      y: 0
    }, this.screen = {
      x: 0,
      y: 0
    };
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/federated-event/pointer-event.js
var FederatedPointerEvent = class _FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
  }
  getCoalescedEvents() {
    return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
  clone() {
    var _a, _b, _c;
    const event2 = new _FederatedPointerEvent(this.manager);
    event2.eventPhase = event2.NONE, event2.currentTarget = null, event2.path = [], event2.detailPath = [], event2.target = null, event2.nativeEvent = this.nativeEvent, event2.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event2), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event2), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event2), event2.target = this.target, event2.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event2.detailPath = p && p.slice(), event2.type = this.type, event2;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/federated-event/wheel-event.js
var FederatedWheelEvent = class _FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
  clone() {
    var _a, _b, _c;
    const event2 = new _FederatedWheelEvent(this.manager);
    event2.eventPhase = event2.NONE, event2.currentTarget = null, event2.path = [], event2.detailPath = [], event2.target = null, event2.nativeEvent = this.nativeEvent, event2.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event2), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event2), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event2), event2.target = this.target, event2.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event2.detailPath = p && p.slice(), event2.type = this.type, event2;
  }
};
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/federated-event/custom-event.js
var CustomEvent = class extends FederatedEvent {
  constructor(eventName, object) {
    super(), this.type = eventName, this.detail = object;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/constant.js
var WILDCARD = "*";

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/util.js
var clock = "object" == typeof performance && performance.now ? performance : Date;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/event-manager.js
function isMouseLike(pointerType) {
  return "mouse" === pointerType || "pen" === pointerType;
}
var EventManager = class {
  constructor(root, config) {
    this.dispatch = new import_eventemitter3.default(), this.cursorTarget = null, this.pauseNotify = false, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this.onPointerDown = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) this.dispatchEvent(e, "touchstart");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
    }, this.onPointerMove = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
        const outType = "mousemove" === from.type ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
        if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        const overType = "mousemove" === from.type ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);
        this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
        for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; ) overTargetAncestor = overTargetAncestor.parent;
        if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          let currentTarget = enterEvent.target;
          const outTargetAncestors = /* @__PURE__ */ new Set();
          let ancestor = outTarget;
          for (; ancestor && ancestor !== this.rootTarget; ) outTargetAncestors.add(ancestor), ancestor = ancestor.parent;
          for (; currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent; ) outTargetAncestors.has(currentTarget) || (enterEvent.currentTarget = currentTarget, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter")), currentTarget = currentTarget.parent;
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), isMouse && (this.dispatchEvent(e, "mousemove"), this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), this.freeEvent(e);
    }, this.onPointerOver = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType);
      this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
      const enterEvent = this.clonePointerEvent(e, "pointerenter");
      for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
      trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
    }, this.onPointerOut = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
        this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
      }
      this.cursorTarget = null, this.cursor = "";
    }, this.onPointerUp = (from, target) => {
      var _a;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const now = clock.now(), e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        for (; currentTarget && !e.composedPath().includes(currentTarget); ) {
          if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside");
          else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget, clickEvent.path = [], clickEvent.detailPath = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        });
        const clickHistory = trackingData.clicksByButton[from.button];
        clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && this._config.supportsTouchEvents && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
      }
      this.freeEvent(e);
    }, this.onPointerUpOutside = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from, from.type, target);
      if (pressTarget) {
        let currentTarget = pressTarget;
        for (; currentTarget; ) e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e);
    }, this.onWheel = (from, target) => {
      if (!(from instanceof FederatedWheelEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
      const wheelEvent = this.createWheelEvent(from, target);
      this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
    }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
      clickInterval: 200
    }, config), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
  }
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn,
      priority: 0
    }), this.mappingTable[type].sort((a2, b) => a2.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false, e.propagationImmediatelyStopped = false, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.rootTarget) return;
    const mappers = this.mappingTable[e.type];
    let target;
    const cacheKey = `${e.canvasX}-${e.canvasY}`;
    if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = {
      [cacheKey]: target,
      stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
    })), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target);
    else Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
  }
  propagate(e, type) {
    if (!e.target) return;
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
      if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  notifyTarget(e, type) {
    if (this.pauseNotify) return;
    type = null != type ? type : e.type;
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) return null;
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    var _a, _b;
    const event2 = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from, event2), this.copyMouseData(from, event2), this.copyData(from, event2), event2.nativeEvent = from.nativeEvent, event2.originalEvent = from, event2.target = target || this.pickTarget(null !== (_a = event2.viewX) && void 0 !== _a ? _a : event2.global.x, null !== (_b = event2.viewY) && void 0 !== _b ? _b : event2.global.y, event2), "string" == typeof type && (event2.type = type), event2;
  }
  createWheelEvent(from, target) {
    var _a, _b;
    const event2 = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from, event2), this.copyMouseData(from, event2), this.copyData(from, event2), event2.nativeEvent = from.nativeEvent, event2.originalEvent = from, event2.target = target || this.pickTarget(null !== (_a = event2.viewX) && void 0 !== _a ? _a : event2.global.x, null !== (_b = event2.viewY) && void 0 !== _b ? _b : event2.global.y, event2), event2;
  }
  clonePointerEvent(from, type) {
    const event2 = this.allocateEvent(FederatedPointerEvent);
    event2.nativeEvent = from.nativeEvent, event2.originalEvent = from.originalEvent, this.copyPointerData(from, event2), this.copyMouseData(from, event2), this.copyData(from, event2), event2.target = from.target, event2.path = from.composedPath().slice();
    const p = from.composedDetailPath();
    return event2.detailPath = p && p.slice(), event2.type = null != type ? type : event2.type, event2;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach((key) => {
      to[key].x = from[key].x, to[key].y = from[key].y;
    }));
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
  }
  trackingData(id) {
    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    var _a;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event2 = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
    return event2.eventPhase = event2.NONE, event2.currentTarget = null, event2.path = [], event2.detailPath = [], event2.target = null, event2;
  }
  freeEvent(event2) {
    var _a;
    if (event2.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
    const constructor = event2.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event2);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
      once: true
    }), listeners.fn.call(listeners.context, e);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
      once: true
    }), listeners[i].fn.call(listeners[i].context, e);
    this.emitDelegation(e, type);
  }
  emitDelegation(e, type) {
    const listeners = e.currentTarget._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
  }
  pickTarget(x, y, e) {
    let target;
    const pickResult = this.rootTarget.pick(x, y);
    return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
  }
  release() {
    this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/event-target.js
var EventTarget2 = {
  dispatchEvent(e) {
    var _a;
    if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = false, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
  },
  emit(eventName, object) {
    return this.dispatchEvent(new CustomEvent(eventName, object));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/event/event-system.js
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var EventSystem = class {
  constructor(params2) {
    this.resolution = 1, this.onPointerDown = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
      }
      for (let i = 0, j = events.length; i < j; i++) {
        const nativeEvent2 = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
        this.manager.mapEvent(federatedEvent);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerMove = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event2 = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event2);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerUp = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event2 = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        event2.type += outside, this.manager.mapEvent(event2);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerOverOut = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event2 = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event2);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onWheel = (nativeEvent) => {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.manager.mapEvent(wheelEvent);
    };
    const { targetElement, resolution, rootNode, global: global2, autoPreventDefault = false, clickInterval, supportsTouchEvents = global2.supportsTouchEvents, supportsPointerEvents = global2.supportsPointerEvents } = params2;
    this.manager = new EventManager(rootNode, {
      clickInterval,
      supportsTouchEvents
    }), this.globalObj = global2, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global2.supportsMouseEvents, this.applyStyles = global2.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = false, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.resolution = resolution, this.setTargetElement(targetElement);
  }
  release() {
    this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
  }
  setCursor(mode, target) {
    if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
    mode || (mode = "default");
    const { applyStyles, domElement } = this;
    if (this.currentCursor === mode) return;
    this.currentCursor = mode;
    const style2 = this.cursorStyles[mode];
    style2 ? "string" == typeof style2 && applyStyles ? domElement.style.cursor = style2 : "function" == typeof style2 ? style2(mode) : "object" == typeof style2 && applyStyles && Object.assign(domElement.style, style2) : applyStyles && isString_default(mode) && !has_default(this.cursorStyles, mode) && (domElement.style.cursor = mode);
  }
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.addEventListener("pointermove", this.onPointerMove, true), globalObj.addEventListener("pointerup", this.onPointerUp, true)) : (domElement.addEventListener("pointermove", this.onPointerMove, true), domElement.addEventListener("pointerup", this.onPointerUp, true)), domElement.addEventListener("pointerdown", this.onPointerDown, true), domElement.addEventListener("pointerleave", this.onPointerOverOut, true), domElement.addEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.addEventListener("mousemove", this.onPointerMove, true), globalObj.addEventListener("mouseup", this.onPointerUp, true)) : (domElement.addEventListener("mousemove", this.onPointerMove, true), domElement.addEventListener("mouseup", this.onPointerUp, true)), domElement.addEventListener("mousedown", this.onPointerDown, true), domElement.addEventListener("mouseout", this.onPointerOverOut, true), domElement.addEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, true), domElement.addEventListener("touchend", this.onPointerUp, true), domElement.addEventListener("touchmove", this.onPointerMove, true)), domElement.addEventListener("wheel", this.onWheel, {
      capture: true
    }), this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.removeEventListener("pointermove", this.onPointerMove, true), globalObj.removeEventListener("pointerup", this.onPointerUp, true)) : (domElement.removeEventListener("pointermove", this.onPointerMove, true), domElement.removeEventListener("pointerup", this.onPointerUp, true)), domElement.removeEventListener("pointerdown", this.onPointerDown, true), domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), domElement.removeEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.removeEventListener("mousemove", this.onPointerMove, true), globalObj.removeEventListener("mouseup", this.onPointerUp, true)) : (domElement.removeEventListener("mousemove", this.onPointerMove, true), domElement.removeEventListener("mouseup", this.onPointerUp, true)), domElement.removeEventListener("mousedown", this.onPointerDown, true), domElement.removeEventListener("mouseout", this.onPointerOverOut, true), domElement.removeEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, true), domElement.removeEventListener("touchend", this.onPointerUp, true), domElement.removeEventListener("touchmove", this.onPointerMove, true)), domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
  }
  mapToViewportPoint(event2) {
    return this.domElement.pointTransform ? this.domElement.pointTransform(event2.x, event2.y) : event2;
  }
  mapToCanvasPoint(nativeEvent) {
    var _a, _b;
    const point5 = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
    if (point5) return point5;
    let x = 0, y = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
      x = data.clientX || 0, y = data.clientY || 0;
    } else x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: x - rect.left,
      y: y - rect.top
    };
  }
  normalizeToPointerData(event2) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event2.changedTouches && event2.changedTouches.length) for (let i = 0, li = event2.changedTouches.length; i < li; i++) {
      const touch = event2.changedTouches[i];
      isUndefined_default(touch.button) && (touch.button = 0), isUndefined_default(touch.buttons) && (touch.buttons = 1), isUndefined_default(touch.isPrimary) && (touch.isPrimary = 1 === event2.touches.length && "touchstart" === event2.type), isUndefined_default(touch.width) && (touch.width = touch.radiusX || 1), isUndefined_default(touch.height) && (touch.height = touch.radiusY || 1), isUndefined_default(touch.tiltX) && (touch.tiltX = 0), isUndefined_default(touch.tiltY) && (touch.tiltY = 0), isUndefined_default(touch.pointerType) && (touch.pointerType = "touch"), isUndefined_default(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined_default(touch.pressure) && (touch.pressure = touch.force || 0.5), isUndefined_default(touch.twist) && (touch.twist = 0), isUndefined_default(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined_default(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined_default(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = true, touch.type = event2.type, normalizedEvents.push(touch);
    }
    else if (this.globalObj.supportsMouseEvents && (!(event2 instanceof MouseEvent) || this.supportsPointerEvents && event2 instanceof PointerEvent)) normalizedEvents.push(event2);
    else {
      const tempEvent = event2;
      isUndefined_default(tempEvent.isPrimary) && (tempEvent.isPrimary = true), isUndefined_default(tempEvent.width) && (tempEvent.width = 1), isUndefined_default(tempEvent.height) && (tempEvent.height = 1), isUndefined_default(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined_default(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined_default(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined_default(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined_default(tempEvent.pressure) && (tempEvent.pressure = 0.5), isUndefined_default(tempEvent.twist) && (tempEvent.twist = 0), isUndefined_default(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event2 = this.rootWheelEvent;
    this.transferMouseData(event2, nativeEvent), event2.deltaMode = nativeEvent.deltaMode, event2.deltaX = nativeEvent.deltaX, event2.deltaY = nativeEvent.deltaY, event2.deltaZ = nativeEvent.deltaZ;
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event2.canvas.x = canvasX, event2.canvas.y = canvasY, event2.global.x = canvasX, event2.global.y = canvasY, event2.offset.x = canvasX, event2.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event2);
    return event2.viewport.x = viewX, event2.viewport.y = viewY, event2.nativeEvent = nativeEvent, event2.type = nativeEvent.type, event2;
  }
  bootstrapEvent(event2, nativeEvent) {
    event2.originalEvent = null, event2.nativeEvent = nativeEvent, event2.pointerId = nativeEvent.pointerId, event2.width = nativeEvent.width, event2.height = nativeEvent.height, event2.isPrimary = nativeEvent.isPrimary, event2.pointerType = nativeEvent.pointerType, event2.pressure = nativeEvent.pressure, event2.tangentialPressure = nativeEvent.tangentialPressure, event2.tiltX = nativeEvent.tiltX, event2.tiltY = nativeEvent.tiltY, event2.twist = nativeEvent.twist, this.transferMouseData(event2, nativeEvent);
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event2.canvas.x = canvasX, event2.canvas.y = canvasY, event2.global.x = canvasX, event2.global.y = canvasY, event2.offset.x = canvasX, event2.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event2);
    return event2.viewport.x = viewX, event2.viewport.y = viewY, event2.isTrusted = nativeEvent.isTrusted, "pointerleave" === event2.type && (event2.type = "pointerout"), event2.type.startsWith("mouse") && (event2.type = event2.type.replace("mouse", "pointer")), event2.type.startsWith("touch") && (event2.type = TOUCH_TO_POINTER[event2.type] || event2.type), event2;
  }
  transferMouseData(event2, nativeEvent) {
    event2.isTrusted = nativeEvent.isTrusted, event2.srcElement = nativeEvent.srcElement, event2.timeStamp = clock.now(), event2.type = nativeEvent.type, event2.altKey = nativeEvent.altKey, event2.button = nativeEvent.button, event2.buttons = nativeEvent.buttons, event2.client.x = nativeEvent.clientX, event2.client.y = nativeEvent.clientY, event2.ctrlKey = nativeEvent.ctrlKey, event2.shiftKey = nativeEvent.shiftKey, event2.metaKey = nativeEvent.metaKey, event2.movement.x = nativeEvent.movementX, event2.movement.y = nativeEvent.movementY, event2.page.x = nativeEvent.pageX, event2.page.y = nativeEvent.pageY, event2.relatedTarget = null;
  }
  isEventOutsideOfTargetViewPort(nativeEvent) {
    if (this.isEventOutsideOfTargetElement(nativeEvent)) return true;
    if (this.domElement.getViewBox) {
      const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)), b = this.domElement.getViewBox(), w = b.width(), h = b.height();
      return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
    }
    return false;
  }
  isEventOutsideOfTargetElement(nativeEvent) {
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
  }
  pauseTriggerEvent() {
    this.manager.pauseNotify = true;
  }
  resumeTriggerEvent() {
    this.manager.pauseNotify = false;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/Ticker/type.js
var STATUS;
!function(STATUS3) {
  STATUS3[STATUS3.INITIAL = 0] = "INITIAL", STATUS3[STATUS3.RUNNING = 1] = "RUNNING", STATUS3[STATUS3.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/Ticker/raf-tick-handler.js
var RAFTickHandler = class _RAFTickHandler {
  static Avaliable() {
    return !!application.global.getRequestAnimationFrame();
  }
  avaliable() {
    return _RAFTickHandler.Avaliable();
  }
  tick(interval, cb) {
    application.global.getRequestAnimationFrame()(() => {
      this.released || cb(this);
    });
  }
  release() {
    this.released = true;
  }
  getTime() {
    return Date.now();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/Ticker/timeout-tick-handler.js
var TimeOutTickHandler = class _TimeOutTickHandler {
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _TimeOutTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.timerId = setTimeout(() => {
      cb(this);
    }, interval);
  }
  release() {
    this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
  }
  getTime() {
    return Date.now();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/Ticker/default-ticker.js
var DefaultTicker = class extends import_eventemitter3.default {
  set mode(m3) {
    this._mode !== m3 && (this._mode = m3, this.setupTickHandler());
  }
  get mode() {
    return this._mode;
  }
  constructor(timelines = []) {
    super(), this.handleTick = (handler, params2) => {
      const { once = false } = null != params2 ? params2 : {};
      this.ifCanStop() ? this.stop() : (this._handlerTick(), once || handler.tick(this.interval, this.handleTick));
    }, this._handlerTick = () => {
      const time = this.tickerHandler.getTime();
      let delta = 0;
      this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t) => {
        t.tick(delta);
      }), this.emit("tick"));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = true;
  }
  init() {
    this.interval = NaN, this.status = STATUS.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
      this.initHandler();
    }), application.global.env && this.initHandler();
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter((t) => t !== timeline);
  }
  getTimelines() {
    return this.timelines;
  }
  initHandler() {
    if (this._mode) return null;
    const ticks6 = [{
      mode: "raf",
      cons: RAFTickHandler
    }, {
      mode: "timeout",
      cons: TimeOutTickHandler
    }];
    for (let i = 0; i < ticks6.length; i++) if (ticks6[i].cons.Avaliable()) {
      this.mode = ticks6[i].mode;
      break;
    }
    return null;
  }
  setupTickHandler() {
    let handler;
    switch (this._mode) {
      case "raf":
        handler = new RAFTickHandler();
        break;
      case "timeout":
        handler = new TimeOutTickHandler();
        break;
      default:
        Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
    }
    return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, true);
  }
  setInterval(interval) {
    this.interval = interval;
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(1e3 / fps);
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  tickTo(t) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  pause() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, true);
  }
  resume() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, true);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length) return true;
      if (0 === this.timelines.reduce((a2, b) => a2 + b.animateCount, 0)) return true;
    }
    return false;
  }
  start(force = false) {
    if (this.status === STATUS.RUNNING) return false;
    if (!this.tickerHandler) return false;
    if (!force) {
      if (this.status === STATUS.PAUSE) return false;
      if (!this.timelines.length) return false;
      if (0 === this.timelines.reduce((a2, b) => a2 + b.animateCount, 0)) return false;
    }
    return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), true;
  }
  stop() {
    this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
  }
  release() {
    this.stop(), this.timelines = [], this.tickerHandler.release(), this.emit("afterTick");
  }
  trySyncTickStatus() {
    this.status === STATUS.RUNNING && this._handlerTick();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/easing.js
var Easing = class _Easing {
  constructor() {
  }
  static linear(t) {
    return t;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t) {
      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
    };
  }
  static getPowIn(pow4) {
    return function(t) {
      return Math.pow(t, pow4);
    };
  }
  static getPowOut(pow4) {
    return function(t) {
      return 1 - Math.pow(1 - t, pow4);
    };
  }
  static getPowInOut(pow4) {
    return function(t) {
      return (t *= 2) < 1 ? 0.5 * Math.pow(t, pow4) : 1 - 0.5 * Math.abs(Math.pow(2 - t, pow4));
    };
  }
  static getBackIn(amount) {
    return function(t) {
      return t * t * ((amount + 1) * t - amount);
    };
  }
  static getBackOut(amount) {
    return function(t) {
      return --t * t * ((amount + 1) * t + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function(t) {
      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * 0.5 : 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
    };
  }
  static sineIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static sineOut(t) {
    return Math.sin(t * Math.PI / 2);
  }
  static sineInOut(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }
  static expoIn(t) {
    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
  }
  static expoOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }
  static expoInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  }
  static circIn(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  }
  static circOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  static circInOut(t) {
    return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }
  static bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  }
  static bounceIn(t) {
    return 1 - _Easing.bounceOut(1 - t);
  }
  static bounceInOut(t) {
    return t < 0.5 ? 0.5 * _Easing.bounceIn(2 * t) : 0.5 * _Easing.bounceOut(2 * t - 1) + 0.5;
  }
  static getElasticIn(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t) return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t) return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s2) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function(t) {
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * -0.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * 0.5 + 1;
    };
  }
  static registerFunc(name, func) {
    _Easing[name] = func;
  }
};
function flicker(t, n) {
  const step = 1 / n;
  let flag = 1;
  for (; t > step; ) t -= step, flag *= -1;
  const v = flag * t / step;
  return v > 0 ? v : 1 + v;
}
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, 0.3), Easing.elasticOut = Easing.getElasticOut(1, 0.3), Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5), Easing.easeInOutQuad = (t) => (t /= 0.5) < 1 ? 0.5 * Math.pow(t, 2) : -0.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = (x) => {
  const c4 = 2 * Math.PI / 3;
  return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - 0.75) * c4) + 1;
}, Easing.easeInOutElastic = (x) => {
  const c5 = 2 * Math.PI / 4.5;
  return 0 === x ? 0 : 1 === x ? 1 : x < 0.5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
};
for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = (t) => flicker(t, i);
for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = (t) => i * t * t + (1 - i) * t;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/timeline.js
var DefaultTimeline = class {
  constructor() {
    this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = false;
  }
  addAnimate(animate) {
    this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  tick(delta) {
    if (this.paused) return;
    let animate = this.animateHead;
    for (this.animateCount = 0; animate; ) animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
  }
  clear() {
    let animate = this.animateHead;
    for (; animate; ) animate.release(), animate = animate.nextAnimate;
    this.animateHead = null, this.animateTail = null, this.animateCount = 0;
  }
  removeAnimate(animate, release = true) {
    animate._onRemove && animate._onRemove.forEach((cb) => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
  }
};
var defaultTimeline = new DefaultTimeline();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/animate.js
var ACustomAnimate = class {
  constructor(from, to, duration, easing, params2) {
    this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params2, this.updateCount = 0;
  }
  bind(target, subAni) {
    this.target = target, this.subAnimate = subAni, this.onBind();
  }
  onBind() {
  }
  onFirstRun() {
  }
  onStart() {
  }
  onEnd() {
  }
  getEndProps() {
    return this.to;
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var _a;
    const thisEndProps = this.getEndProps();
    return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
  }
  update(end, ratio, out) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const props = this.step.getLastProps();
      Object.keys(props).forEach((k2) => {
        this.subAnimate.animate.validAttr(k2) && (out[k2] = props[k2]);
      });
    }
    this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
  }
};
var CbAnimate = class extends ACustomAnimate {
  constructor(cb) {
    super(null, null, 0, "linear"), this.cb = cb;
  }
  onUpdate(end, ratio, out) {
  }
  onStart() {
    this.cb();
  }
};
var Animate = class _Animate {
  constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline, slience) {
    this.id = id, this.timeline = timeline || defaultTimeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this), this.slience = slience;
  }
  setTimeline(timeline) {
    timeline !== this.timeline && (this.timeline.removeAnimate(this, false), timeline.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
  }
  after(animate) {
    const t = animate.getDuration();
    return this._startTime = t, this;
  }
  afterAll(list) {
    let maxT = -1 / 0;
    return list.forEach((a2) => {
      maxT = max(a2.getDuration(), maxT);
    }), this._startTime = maxT, this;
  }
  parallel(animate) {
    return this._startTime = animate.getStartTime(), this;
  }
  static AddInterpolate(name, cb) {
    _Animate.interpolateMap.set(name, cb);
  }
  play(customAnimate) {
    if (this.tailAnimate.play(customAnimate), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return 1 === this.subAnimates.length && this.tailAnimate.totalDuration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
  }
  trySetAttribute(attr, mode = _Animate.mode) {
    attr && mode & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, false, {
      type: AttributeUpdateType.ANIMATE_PLAY
    });
  }
  runCb(cb) {
    const customAnimate = new CbAnimate(() => {
      cb(this, customAnimate.step.prev);
    });
    return this.tailAnimate.play(customAnimate), this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    const func = _Animate.interpolateMap.get(key) || _Animate.interpolateMap.get("");
    return !!func && func(key, ratio, from, to, target, ret);
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  to(props, duration, easing, params2) {
    if (this.tailAnimate.to(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  from(props, duration, easing, params2) {
    if (this.tailAnimate.from(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  wait(duration) {
    if (this.tailAnimate.wait(duration), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  startAt(t) {
    if (this.tailAnimate.startAt(t), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  loop(l) {
    if (this.tailAnimate.loop = l, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  reversed(r) {
    if (this.tailAnimate.reversed = r, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  bounce(b) {
    if (this.tailAnimate.bounce = b, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const sa = new SubAnimate(this, this.tailAnimate);
    return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(key) {
    this._preventAttrs && this._preventAttrs.delete(key);
  }
  preventAttr(key) {
    this._preventAttrs || (this._preventAttrs = /* @__PURE__ */ new Set()), this._preventAttrs.add(key);
  }
  preventAttrs(keys2) {
    keys2.forEach((key) => this.preventAttr(key));
  }
  validAttr(key) {
    return !this._preventAttrs || !this._preventAttrs.has(key);
  }
  bind(target) {
    return this.target = target, this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.subAnimates.forEach((sa) => {
      sa.bind(target);
    }), this;
  }
  advance(delta) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
      delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
    }
    this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach((cb) => cb()));
    this.setPosition(Math.max(this.rawPosition, 0) + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach((cb) => cb()));
  }
  setPosition(rawPosition) {
    let sa, d = 0;
    const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce((a2, b) => a2 + b.totalDuration, 0);
    rawPosition < 0 && (rawPosition = 0);
    const end = rawPosition >= maxRawPos;
    if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
    for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, sa = void 0;
    return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
  }
  onStart(cb) {
    this._onStart || (this._onStart = []), this._onStart.push(cb);
  }
  onEnd(cb) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
  }
  onRemove(cb) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
  }
  onFrame(cb) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(nextVal) {
    nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
  }
};
Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = /* @__PURE__ */ new Map();
var SubAnimate = class {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(animate, lastSubAnimate) {
    this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step2(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = true, this._startAt = 0;
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(target) {
    return this.target = target, this;
  }
  play(customAnimate) {
    let duration = customAnimate.duration;
    (null == duration || duration < 0) && (duration = 0);
    const easing = customAnimate.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, false), this._appendCustomAnimate(customAnimate, step), this;
  }
  to(props, duration, easing, params2) {
    (null == duration || duration < 0) && (duration = 0);
    const easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.to, this._appendProps(props, step, !!params2 && params2.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params2 && params2.noPreventAttrs || this.target.animates && this.target.animates.forEach((a2) => {
      a2.id !== this.animate.id && a2.preventAttrs(step.propKeys);
    }), this;
  }
  from(props, duration, easing, params2) {
    this.to(props, 0, easing, params2);
    const toProps = {};
    this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach((k2) => {
      toProps[k2] = this.getLastPropByName(k2, this.stepTail);
    }), this.to(toProps, duration, easing, params2), this.stepTail.type = AnimateStepType.from;
  }
  startAt(t) {
    return t < 0 && (t = 0), this._startAt = t, this;
  }
  getStartProps() {
    var _a;
    return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(duration) {
    if (duration > 0) {
      const step = this._addStep(+duration, null);
      step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
    }
    return this;
  }
  _addStep(duration, props, easingFunc) {
    const step = new Step2(this.duration, duration, props, easingFunc);
    return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
  }
  _appendProps(props, step, tempProps) {
    step.props = tempProps ? props : Object.assign({}, props);
    let lastStep = step.prev;
    const _props = step.props;
    for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k2) => {
      void 0 === step.props[k2] && (step.props[k2] = this.target.getDefaultAttribute(k2));
    }); lastStep.prev; ) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach((key) => {
      void 0 === _props[key] && (_props[key] = lastStep.props[key]);
    })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
    const initProps = this.stepHead.props;
    step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key) => {
      if (void 0 === initProps[key]) {
        const parentAnimateInitProps = this.animate.getStartProps();
        initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
      }
    }), this.target.onAddStep && this.target.onAddStep(step);
  }
  _appendCustomAnimate(customAnimate, step) {
    step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
  }
  setPosition(rawPosition) {
    var _a;
    const d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
    let loop, position, end = false;
    const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
    if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, false;
    if (rawPosition -= startAt, d <= 0 && (end = true, d < 0)) return end;
    if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
    const rev = !this.reversed != !(this.bounce && loop % 2);
    return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
  }
  updatePosition(end, rev) {
    if (!this.stepHead) return;
    let step = this.stepHead.next;
    const position = this.position, duration = this.duration;
    if (this.target && step) {
      let stepNext = step.next;
      for (; stepNext && stepNext.position <= position; ) step = stepNext, stepNext = step.next;
      let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
      step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb) => cb(step, ratio));
    }
  }
  tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
    if (step !== lastStep) if (rev) {
      let _step = lastStep.prev;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    } else {
      let _step = lastStep.next;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    }
  }
  getLastPropByName(name, step) {
    let lastStep = step.prev;
    for (; lastStep; ) {
      if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
      if (lastStep.customAnimate) {
        const val = lastStep.customAnimate.getEndProps()[name];
        if (void 0 !== val) return val;
      }
      lastStep = lastStep.prev;
    }
    return Logger.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
  }
  updateTarget(step, ratio, end) {
    null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
  }
};
var Step2 = class {
  constructor(position, duration, props, easing) {
    this.duration = duration, this.position = position, this.props = props, this.easing = easing;
  }
  append(step) {
    step.prev = this, step.next = this.next, this.next = step;
  }
  getLastProps() {
    let step = this.prev;
    for (; step; ) {
      if (step.props) return step.props;
      if (step.customAnimate) return step.customAnimate.getMergedEndProps();
      step = step.prev;
    }
    return null;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/config.js
var DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/utils.js
var Edge;
!function(Edge3) {
  Edge3[Edge3.Top = 1] = "Top", Edge3[Edge3.Right = 2] = "Right", Edge3[Edge3.Bottom = 4] = "Bottom", Edge3[Edge3.Left = 8] = "Left", Edge3[Edge3.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
var _strokeVec4 = [false, false, false, false];
var parseStroke = (stroke2) => {
  var _a;
  let isFullStroke = true;
  if (isBoolean_default(stroke2, true)) {
    for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke2, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
    isFullStroke = stroke2;
  } else if (Array.isArray(stroke2)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke2[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);
  else _strokeVec4[0] = false, _strokeVec4[1] = false, _strokeVec4[2] = false, _strokeVec4[3] = false;
  return {
    isFullStroke,
    stroke: _strokeVec4
  };
};
var _paddingVec4 = [0, 0, 0, 0];
var parsePadding = (padding) => padding ? isArray_default(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
var _coords = [{
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}];
var indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2; ) startAngle -= pi2;
  for (; startAngle < 0; ) startAngle += pi2;
  for (; startAngle > endAngle; ) endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi) % 4, endIdx = Math.ceil(endAngle / halfPi) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = false;
    for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
      if (match && endIdx === indexList[i]) break;
      if (match) {
        const p = _coords[indexList[i]];
        bounds.add(p.x, p.y);
      }
    } else {
      match = true;
      const p = _coords[startIdx];
      bounds.add(p.x, p.y);
    }
  }
}
function pointInterpolation(pointA, pointB, ratio) {
  const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point5 = new Point(x, y, x1, y1);
  return point5.defined = pointB.defined, point5;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB) return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map((point5) => {
      const p = new Point(point5.x, point5.y, point5.x1, point5.y1);
      return p.defined = point5.defined, p;
    });
    for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  } else {
    points = pointsB.map((point5) => {
      const p = new Point(point5.x, point5.y, point5.x1, point5.y1);
      return p.defined = point5.defined, p;
    });
    for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  }
  return points;
}
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray_default(attr)) {
    let val;
    for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
    return val;
  }
  return attr[key];
}
var RafBasedSTO = class _RafBasedSTO {
  constructor(timeout = _RafBasedSTO.TimeOut) {
    this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
  }
  call(cb) {
    return this.lastDate = Date.now(), setTimeout(() => {
      this.appendDuration(Date.now() - this.lastDate), cb(0);
    }, this.timeout, true);
  }
  clear(h) {
    clearTimeout(h);
  }
  appendDuration(d) {
    this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a2, b) => a2 + b, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
  }
};
RafBasedSTO.TimeOut = 1e3 / 60;
var rafBasedSto = new RafBasedSTO();
var _calculateLineHeight = (lineHeight, fontSize) => {
  if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};
var calculateLineHeight = (lineHeight, fontSize) => {
  const _lh = _calculateLineHeight(lineHeight, fontSize);
  return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/custom-animate.js
var IncreaseCount = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2);
  }
  getEndProps() {
    return false === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.fromNumber = isNumber_default(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), this.toNumber = isNumber_default(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = false), false !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    var _a;
    false !== this.valid && (out.text = end ? null === (_a = this.to) || void 0 === _a ? void 0 : _a.text : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
  }
};
var Direction2;
!function(Direction4) {
  Direction4[Direction4.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction4[Direction4.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction4[Direction4.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction4[Direction4.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction4[Direction4.STROKE = 4] = "STROKE";
}(Direction2 || (Direction2 = {}));
var InputText = class extends ACustomAnimate {
  constructor() {
    super(...arguments), this.fromText = "", this.toText = "";
  }
  getEndProps() {
    return false === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c;
    this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", this.toText = (null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) || "", (!this.toText || isArray_default(this.toText) && 0 === this.toText.length) && (this.valid = false), isArray_default(this.toText) && (this.toText = this.toText.map((item) => (item || "").toString()));
  }
  onEnd() {
    this.target.detachShadow();
  }
  onUpdate(end, ratio, out) {
    if (false === this.valid) return;
    const fromCount = this.fromText.length, toTextIsArray = isArray_default(this.toText), toCount = toTextIsArray ? this.toText.reduce((c2, t) => c2 + (t || "").length, 0) : this.toText.length, count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
    if (toTextIsArray) {
      out.text = [];
      let len = 0;
      this.toText.forEach((t) => {
        len + t.length > count ? (out.text.push(t.substr(0, count - len)), len = count) : (out.text.push(t), len += t.length);
      });
    } else out.text = this.toText.substr(0, count);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/rect-utils.js
var normalizeRectAttributes = (attribute) => {
  if (!attribute) return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  let width = isNil_default(attribute.width) ? attribute.x1 - attribute.x : attribute.width, height = isNil_default(attribute.height) ? attribute.y1 - attribute.y : attribute.height, x = 0, y = 0;
  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x,
    y,
    width,
    height
  };
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/color-string/store.js
var ColorType;
!function(ColorType2) {
  ColorType2[ColorType2.Color255 = 0] = "Color255", ColorType2[ColorType2.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
var ColorStore = class _ColorStore {
  static Get(str2, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
    if (size === ColorType.Color1) {
      const color2 = _ColorStore.store1[str2];
      if (color2) return arr[0] = color2[0], arr[1] = color2[1], arr[2] = color2[2], arr[3] = color2[3], arr;
      const c3 = Color.parseColorString(str2);
      if (c3) {
        const data = [c3.r / 255, c3.g / 255, c3.b / 255, c3.opacity];
        _ColorStore.store1[str2] = data, _ColorStore.store255[str2] = [c3.r, c3.g, c3.b, c3.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = _ColorStore.store255[str2];
    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c2 = Color.parseColorString(str2);
    return c2 && (_ColorStore.store1[str2] = [c2.r / 255, c2.g / 255, c2.b / 255, c2.opacity], _ColorStore.store255[str2] = [c2.r, c2.g, c2.b, c2.opacity], arr[0] = c2.r, arr[1] = c2.g, arr[2] = c2.b, arr[3] = c2.opacity), arr;
  }
  static Set(str2, size, arr) {
    if (size === ColorType.Color1) {
      if (_ColorStore.store1[str2]) return;
      _ColorStore.store1[str2] = arr, _ColorStore.store255[str2] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (_ColorStore.store255[str2]) return;
      _ColorStore.store255[str2] = arr, _ColorStore.store1[str2] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
};
ColorStore.store255 = {}, ColorStore.store1 = {};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/color-string/interpolate.js
function colorArrayToString(color, alphaChannel = false) {
  return Array.isArray(color) && isNumber_default(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (Array.isArray(from) && !isNumber_default(from[0]) || Array.isArray(to) && !isNumber_default(to[0])) {
    return new Array(4).fill(0).map((_, index) => _interpolateColor(isArray_default(from) ? from[index] : from, isArray_default(to) ? to[index] : to, ratio, alphaChannel));
  }
  return _interpolateColor(from, to, ratio, alphaChannel, cb);
}
function _interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || false;
  let fromArray, toArray, fromGradient = false, toGradient = false;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = true, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = true, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
      stops: gradient.stops.map((v) => Object.assign(Object.assign({}, v), {
        color: colorArrayToString(pure)
      }))
    });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
      if (fromStops.length !== toStops.length) return false;
      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return false;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
var _fromColorRGB = [0, 0, 0, 0];
var _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/color-string/colorName.js
var parsedColors = {};
Object.keys(DEFAULT_COLORS).forEach((k2) => {
  const c2 = DEFAULT_COLORS[k2];
  parsedColors[k2] = [c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2];
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/resource-loader/loader.js
var ResourceLoader = class _ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    const data = _ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : _ResourceLoader.loadImage(url, mark);
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = _ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, _ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then((res) => {
      var _a2;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a2 = data.waitingMark) || void 0 === _a2 || _a2.map((mark2, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark2.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark2.imageLoadFail(svgStr));
      }), data.waitingMark && (data.waitingMark = []);
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = _ResourceLoader.cache.get(url);
    return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then((data2) => data2.data) : Promise.resolve(data.data) : (data = {
      type,
      loadState: "init"
    }, _ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then((data2) => data2.data));
  }
  static loading() {
    setTimeout(() => {
      if (!_ResourceLoader.isLoading && _ResourceLoader.toLoadAueue.length) {
        _ResourceLoader.isLoading = true;
        const tasks = _ResourceLoader.toLoadAueue.splice(0, 10), promises = [];
        tasks.forEach((task) => {
          const { url, marks } = task, data = {
            type: "image",
            loadState: "init"
          };
          if (_ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
            data.waitingMark = marks;
            const end = data.dataPromise.then((res) => {
              var _a;
              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
              }), data.waitingMark && (data.waitingMark = []);
            });
            promises.push(end);
          } else data.loadState = "fail", marks.forEach((mark) => mark.imageLoadFail(url));
        }), Promise.all(promises).then(() => {
          _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        }).catch((error) => {
          console.error(error), _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        });
      }
    }, 0);
  }
  static loadImage(url, mark) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index) return _ResourceLoader.toLoadAueue[index].marks.push(mark), void _ResourceLoader.loading();
    _ResourceLoader.toLoadAueue.push({
      url,
      marks: [mark]
    }), _ResourceLoader.loading();
  }
  static improveImageLoading(url) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index) {
      const elememt = _ResourceLoader.toLoadAueue.splice(index, 1);
      _ResourceLoader.toLoadAueue.unshift(elememt[0]);
    }
  }
  static onLoadSuccess(cb) {
    this.onLoadSuccessCb.push(cb);
  }
};
function getIndex(url, arr) {
  for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
  return -1;
}
ResourceLoader.cache = /* @__PURE__ */ new Map(), ResourceLoader.isLoading = false, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/base.js
var BaseSymbol = class {
  bounds(size, bounds) {
    if (isNumber_default(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
  parseSize(size) {
    return isNumber_default(size) ? size : Math.min(size[0], size[1]);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/circle.js
function circle(ctx, r, x, y, z) {
  return z ? ctx.arc(x, y, r, 0, tau, false, z) : ctx.arc(x, y, r, 0, tau), false;
}
var CircleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return circle(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return circle(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
  }
};
var circle_default = new CircleSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/cross.js
function cross(ctx, r, x, y, z) {
  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), true;
}
function crossOffset(ctx, r, x, y, offset, z) {
  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), true;
}
var CrossSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x, y, z) {
    return cross(ctx, this.parseSize(size) / 6, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
  }
};
var cross_default = new CrossSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/diamond.js
function diamond(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), true;
}
var DiamondSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawFitDir(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return diamond(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
};
var diamond_default = new DiamondSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/square.js
function square(ctx, r, x, y) {
  const wh = 2 * r;
  return ctx.rect(x - r, y - r, wh, wh), false;
}
var SquareSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x, y) {
    return square(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return square(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
};
var square_default = new SquareSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-up.js
function trianglUpOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleUpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_up_default = new TriangleUpSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle.js
var TriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
};
var triangle_default = new TriangleSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/star.js
var kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
  const x = kx * r, y = ky * r;
  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
  for (let i = 1; i < 5; ++i) {
    const a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
    ctx.lineTo(s2 * r + transX, -c2 * r + transY), ctx.lineTo(c2 * x - s2 * y + transX, s2 * x + c2 * y + transY);
  }
  return ctx.closePath(), true;
}
var StarSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var star_default = new StarSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow.js
var sqrt3 = sqrt(3);
function arrow(ctx, r, transX, transY) {
  const triangleH = r, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), true;
}
var ArrowSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var arrow_default = new ArrowSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wedge.js
function wedge(ctx, r, transX, transY) {
  const h = 2 * r;
  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), true;
}
var WedgeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var wedge_default = new WedgeSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/stroke.js
function stroke(ctx, r, transX, transY) {
  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), false;
}
var StrokeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var stroke_default = new StrokeSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wye.js
var c = -0.5;
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = 3 * (k / 2 + 1);
function wye(ctx, r, transX, transY) {
  const x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
  return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), false;
}
var WyeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var wye_default = new WyeSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-left.js
function trianglLeftOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleLeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_left_default = new TriangleLeftSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-right.js
function trianglRightOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleRightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_right_default = new TriangleRightSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-down.js
function trianglDownOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), true;
}
var TriangleDownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_down_default = new TriangleDownSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/thin-triangle.js
var sqrt32 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
  const h = r * sqrt32;
  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), true;
}
var ThinTriangleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x, y) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt32, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt32 + offset, x, y);
  }
};
var thin_triangle_default = new ThinTriangleSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-left.js
function arrow2Left(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), true;
}
var Arrow2LeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_left_default = new Arrow2LeftSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-right.js
function arrow2Right(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), true;
}
var Arrow2RightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_right_default = new Arrow2RightSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-up.js
function arrow2Up(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), true;
}
var Arrow2UpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_up_default = new Arrow2UpSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-down.js
function arrow2Down(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), true;
}
var Arrow2DownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_down_default = new Arrow2DownSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-v.js
function lineV(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), true;
}
var LineVSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x, y, z) {
    return lineV(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineV(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x}, ${y - r} L ${x},${y + r}`;
  }
};
var line_v_default = new LineVSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-h.js
function lineH(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), true;
}
var LineHSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return lineH(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineH(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} L ${x + r},${y}`;
  }
};
var line_h_default = new LineHSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/close.js
function close(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), true;
}
var CloseSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x, y, z) {
    return close(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return close(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
  }
};
var close_default = new CloseSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/rect.js
function rectSizeArray(ctx, size, x, y) {
  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), false;
}
function rectSize(ctx, size, x, y) {
  const w = size, h = size / 2;
  return ctx.rect(x - w / 2, y - h / 2, w, h), false;
}
var RectSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x, y) {
    return isNumber_default(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    isNumber_default(size) && (size = [size, size / 2]);
    const drawLength = 2 * (size[0] + size[1]) * clipRange, points = [{
      x: x + size[0] / 2,
      y: y - size[1] / 2
    }, {
      x: x + size[0] / 2,
      y: y + size[1] / 2
    }, {
      x: x - size[0] / 2,
      y: y + size[1] / 2
    }, {
      x: x - size[0] / 2,
      y: y - size[1] / 2
    }];
    let currLength = 0, lastP = points[3];
    ctx.moveTo(lastP.x, lastP.y);
    for (let i = 0; i < points.length; i++) {
      const p = points[i], len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
      if (currLength + len > drawLength) {
        const dx = (p.x - lastP.x) * (drawLength - currLength) / len, dy = (p.y - lastP.y) * (drawLength - currLength) / len;
        ctx.lineTo(lastP.x + dx, lastP.y + dy);
        break;
      }
      ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
    }
    return false;
  }
  drawOffset(ctx, size, x, y, offset) {
    return isNumber_default(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
  }
};
var rect_default = new RectSymbol();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/utils.js
var tempBounds = new AABBBounds();
var CustomSymbolClass = class {
  constructor(type, path, isSvg2 = false) {
    this.pathStr = "", this.type = type, isArray_default(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg2;
  }
  drawOffset(ctx, size, x, y, offset, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), false);
  }
  draw(ctx, size, x, y, z, cb) {
    return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
  }
  parseSize(size) {
    return isNumber_default(size) ? size : Math.min(size[0], size[1]);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
    }), false) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), false);
  }
  bounds(size, bounds) {
    if (size = this.parseSize(size), this.isSvg) {
      if (!this.svgCache) return;
      return bounds.clear(), void this.svgCache.forEach(({ path }) => {
        tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, bounds.union(tempBounds);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/index.js
var builtinSymbols = [circle_default, cross_default, diamond_default, square_default, thin_triangle_default, triangle_default, star_default, arrow_default, wedge_default, stroke_default, wye_default, triangle_left_default, triangle_right_default, triangle_up_default, triangle_down_default, arrow2_left_default, arrow2_right_default, arrow2_up_default, arrow2_down_default, rect_default, line_v_default, line_h_default, close_default];
var builtinSymbolsMap = {};
builtinSymbols.forEach((symbol) => {
  builtinSymbolsMap[symbol.type] = symbol;
});
var builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/xml/utils.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match; ) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/xml/OrderedObjParser.js
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
};
function findClosingIndex(xmlData, str2, i, errMsg) {
  const closingIndex = xmlData.indexOf(str2, i);
  if (-1 === closingIndex) throw new Error(errMsg);
  return closingIndex + str2.length - 1;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary, tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");
    else if ('"' === ch || "'" === ch) attrBoundary = ch;
    else if (ch === closingChar[0]) {
      if (!closingChar[1]) return {
        data: tagExp,
        index
      };
      if (xmlData[index + 1] === closingChar[1]) return {
        data: tagExp,
        index
      };
    } else "	" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result2 = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result2) return;
  let tagExp = result2.data;
  const closeIndex = result2.index, separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp, attrExpPresent = true;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result2.data.substr(colonIndex + 1));
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
var OrderedObjParser = class {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result2 = childNode.tagname;
    "string" == typeof result2 ? (childNode.tagname = result2, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr) return;
    const matches = getAllMatches(attrStr, attrsRegx), len = matches.length;
    for (let i = 0; i < len; i++) {
      const attrName = matches[i][1], oldVal = matches[i][4], aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj, textData = "", jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      if ("<" === xmlData[i]) if ("/" === xmlData[i + 1]) {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."), propIndex = jPath.lastIndexOf(".");
        jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
      } else if ("?" === xmlData[i + 1]) {
        i = readTagExp(xmlData, i, false, "?>").closeIndex + 1;
      } else if ("!--" === xmlData.substr(i + 1, 3)) {
        i = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
      } else {
        const result2 = readTagExp(xmlData, i, false);
        let tagName = result2.tagName, tagExp = result2.tagExp;
        const attrExpPresent = result2.attrExpPresent, closeIndex = result2.closeIndex;
        if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
          "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
          const childNode = new XmlNode(tagName);
          tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
        } else {
          const childNode = new XmlNode(tagName);
          this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
        }
        textData = "", i = closeIndex;
      }
      else textData += xmlData[i];
    }
    return xmlObj.child;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/xml/node2json.js
function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i], property = propName(tagObj);
    let newJpath = "";
    if (newJpath = void 0 === jPath ? property : jPath + "." + property, void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property], newJpath);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"], newJpath), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj2) {
  const keys2 = Object.keys(obj2);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (":@" !== key) return key;
  }
}
function assignAttributes(obj2, attrMap, jpath) {
  if (attrMap) {
    const keys2 = Object.keys(attrMap), len = keys2.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys2[i];
      obj2[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj2) {
  return 0 === Object.keys(obj2).length;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/xml/parser.js
var XMLParser = class _XMLParser {
  constructor(options) {
    this.options = Object.assign({}, _XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid) return false;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
};
XMLParser.defaultOptions = {};
function isSvg(str2) {
  return str2.startsWith("<svg") || str2.startsWith("<?xml");
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/tools.js
function boundStroke(bounds, halfW, miter, pad2 = 0) {
  return bounds.expand(halfW + (pad2 / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
var NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function(TextDirection2) {
  TextDirection2[TextDirection2.HORIZONTAL = 0] = "HORIZONTAL", TextDirection2[TextDirection2.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text2) {
  const nextCharacter = [];
  let flag = 0, currStr = "";
  for (let i = 0; i < text2.length; i++) rotateText(text2[i]) ? flag ? currStr += text2[i] : (flag = 1, currStr = text2[i]) : (flag && (nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), currStr = "", flag = 0), nextCharacter.push({
    text: text2[i],
    direction: TextDirection.HORIZONTAL
  }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
var rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"];
var rotateCharMap = /* @__PURE__ */ new Map();
rotateCharList.forEach((c2) => rotateCharMap.set(c2, true));
var noRotateCharList = [""];
var noRotateCharMap = /* @__PURE__ */ new Map();
function rotateText(c2) {
  if (rotateCharMap.has(c2)) return true;
  if (noRotateCharMap.has(c2)) return false;
  let rotate = false;
  return c2.codePointAt(0) < 256 && (rotate = true), rotate;
}
noRotateCharList.forEach((c2) => noRotateCharMap.set(c2, true));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/constants.js
var ARC_NUMBER_TYPE = genNumberType();
var ARC3D_NUMBER_TYPE = genNumberType();
var AREA_NUMBER_TYPE = genNumberType();
var CIRCLE_NUMBER_TYPE = genNumberType();
var GLYPH_NUMBER_TYPE = genNumberType();
var GROUP_NUMBER_TYPE = genNumberType();
var IMAGE_NUMBER_TYPE = genNumberType();
var LINE_NUMBER_TYPE = genNumberType();
var PATH_NUMBER_TYPE = genNumberType();
var POLYGON_NUMBER_TYPE = genNumberType();
var PYRAMID3D_NUMBER_TYPE = genNumberType();
var RECT_NUMBER_TYPE = genNumberType();
var RECT3D_NUMBER_TYPE = genNumberType();
var RICHTEXT_NUMBER_TYPE = genNumberType();
var STAR_NUMBER_TYPE = genNumberType();
var SYMBOL_NUMBER_TYPE = genNumberType();
var TEXT_NUMBER_TYPE = genNumberType();
var GraphicService = Symbol.for("GraphicService");
var GraphicCreator = Symbol.for("GraphicCreator");
var SVG_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity"
};
var SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
var SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
var SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic.js
var _tempBounds = new AABBBounds();
var tempMatrix = new Matrix();
var tempBounds2 = new AABBBounds();
var GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
var tempConstantXYKey = ["x", "y"];
var tempConstantScaleXYKey = ["scaleX", "scaleY"];
var tempConstantAngleKey = ["angle"];
var point4 = new Point();
var NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  globalZIndex: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
var Graphic = class _Graphic extends Node {
  static mixin(source) {
    const keys2 = Object.keys(source);
    for (let i = 0; i < keys2.length; ++i) {
      const propertyName = keys2[i];
      Object.defineProperty(_Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds();
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(true);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(true);
  }
  constructor(params2 = {}) {
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params2, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params2.background ? this.loadImage(null !== (_a = params2.background.background) && void 0 !== _a ? _a : params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic);
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  getOffsetXY(attr, includeScroll = false) {
    var _a, _b;
    const { dx = attr.dx, dy = attr.dy } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point4.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point4.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else point4.x = dx, point4.y = dy;
    return point4;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds() {
    const full = "imprecise" === this.attribute.boundsMode;
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  tryUpdateOBBBounds() {
    if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
    if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
    return this.doUpdateOBBBounds();
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b = this.shadowRoot.AABBBounds.clone();
      bounds.union(b);
    }
  }
  doUpdateOBBBounds() {
    return this._OBBBounds;
  }
  getClipPath() {
    const { clipConfig } = this.attribute;
    if (!clipConfig) return null;
    this.clipPathMap || (this.clipPathMap = /* @__PURE__ */ new Map());
    const { shape } = clipConfig;
    let path = this.clipPathMap.get(shape) || null;
    return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
  }
  parsePath(symbolType) {
    if (!symbolType) return null;
    let path = builtinSymbolsMap[symbolType];
    if (path) return path;
    if (path = _Graphic.userSymbolMap[symbolType], path) return path;
    const _symbolType = builtInSymbolStrMap[symbolType];
    if (true === isSvg(symbolType = _symbolType || symbolType)) {
      const parser = new XMLParser(), { svg } = parser.parse(symbolType);
      if (!svg) return null;
      const path2 = isArray_default(svg.path) ? svg.path : [svg.path];
      _tempBounds.clear();
      const cacheList = [];
      path2.forEach((item) => {
        const cache2 = new CustomPath2D().fromString(item.d), attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((k2) => {
          item[k2] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k2]] = item[k2]);
        }), cacheList.push({
          path: cache2,
          attribute
        }), _tempBounds.union(cache2.bounds);
      });
      const width2 = _tempBounds.width(), height2 = _tempBounds.height(), scale7 = 1 / max(width2, height2);
      cacheList.forEach((cache2) => cache2.path.transform(0, 0, scale7, scale7));
      const _parsedPath2 = new CustomSymbolClass(symbolType, cacheList, true);
      return _Graphic.userSymbolMap[symbolType] = _parsedPath2, _parsedPath2;
    }
    const cache = new CustomPath2D().fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale6 = 1 / max(width, height);
    cache.transform(0, 0, scale6, scale6);
    const _parsedPath = new CustomSymbolClass(symbolType, cache);
    return _Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
  }
  doUpdateAABBBounds(full) {
    this.updateAABBBoundsStamp++;
    const graphicTheme = this.getGraphicTheme();
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full), { boundsPadding = graphicTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updatePathProxyAABBBounds(aabbBounds) {
    const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
    if (!path) return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  tryUpdateGlobalAABBBounds() {
    const b = this.AABBBounds;
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m3 = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
      }
    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return true;
  }
  tryUpdateLocalTransMatrix(clearTag = true) {
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x, y, mode, picker) {
    if (!picker) return false;
    if (mode === IContainPointMode.GLOBAL) {
      const point5 = new Point(x, y);
      this.parent && this.parent.globalTransMatrix.transformPoint(point5, point5), x = point5.x, y = point5.y;
    }
    return picker.containsPoint(this, {
      x,
      y
    });
  }
  setWidthHeightWithoutTransform(aabbBounds) {
    this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    (params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2).background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._setAttributes(params2, forceUpdateTag, context);
  }
  _setAttributes(params2, forceUpdateTag = false, context) {
    const keys2 = Object.keys(params2);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      this.attribute[key] = params2[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params2 ? this._setAttributes(params2, forceUpdateTag, context) : isNil_default(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, true) : "shadowGraphic" === key && this.setShadowGraphic(value);
  }
  needUpdateTags(keys2, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      const attrKey = k2[i];
      if (-1 !== keys2.indexOf(attrKey)) return true;
    }
    return false;
  }
  needUpdateTag(key, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      if (key === k2[i]) return true;
    }
    return false;
  }
  initAttributes(params2) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this.attribute = params2, params2.background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x, y) {
    var _a, _b;
    if (0 === x && 0 === y) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    params2 && (x = params2.x, y = params2.y, delete params2.x, delete params2.y, this._setAttributes(params2));
    const attribute = this.attribute, postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x, y) {
    const attribute = this.attribute;
    if (attribute.x === x && attribute.y === y) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY,
      scaleCenter
    }, this.attribute, tempConstantScaleXYKey, context);
    params2 && (scaleX = params2.scaleX, scaleY = params2.scaleY, delete params2.scaleX, delete params2.scaleY, this._setAttributes(params2));
    const attribute = this.attribute;
    if (scaleCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY
    }, this.attribute, tempConstantScaleXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle2, rotateCenter) {
    var _a;
    if (0 === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      angle: angle2,
      rotateCenter
    }, this.attribute, tempConstantAngleKey, context);
    params2 && (delete params2.angle, this._setAttributes(params2, false, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle2, rotateCenter);
    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle2;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle2) {
    const attribute = this.attribute;
    if (attribute.angle === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle2, this.attribute, tempConstantAngleKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.angle = angle2, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b, c2) {
    return this;
  }
  animate(params2) {
    var _a;
    this.animates || (this.animates = /* @__PURE__ */ new Map());
    const animate = new Animate(null == params2 ? void 0 : params2.id, null !== (_a = null == params2 ? void 0 : params2.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline(), null == params2 ? void 0 : params2.slience);
    if (animate.bind(this), params2) {
      const { onStart, onFrame, onEnd, onRemove } = params2;
      null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params2.interpolate;
    }
    return this.animates.set(animate.id, animate), animate.onRemove(() => {
      animate.stop(), this.animates.delete(animate.id);
    }), animate;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d) {
    d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil_default(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b, _c, _d;
    if (hasAnimation) {
      const keys2 = Object.keys(attrs), noWorkAttrs = this.getNoWorkAnimateAttr(), animateAttrs = {};
      let noAnimateAttrs;
      keys2.forEach((key) => {
        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      });
      const animate = this.animate({
        slience: true
      });
      animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, false, {
        type: AttributeUpdateType.STATE
      });
    } else this.stopStateAnimates(), this.setAttributes(attrs, false, {
      type: AttributeUpdateType.STATE
    });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach((key) => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach((key) => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach((key) => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  stopStateAnimates(type = "end") {
    this.animates && this.animates.forEach((animate) => {
      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
    });
  }
  getNormalAttribute(key) {
    let value = this.attribute[key];
    return this.animates && this.animates.forEach((animate) => {
      if (animate.stateNames) {
        const endProps = animate.getEndProps();
        has_default(endProps, key) && (value = endProps[key]);
      }
    }), value;
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if (this.currentStates) {
      const filter2 = isArray_default(stateName) ? (s2) => !stateName.includes(s2) : (s2) => s2 !== stateName, newStates = this.currentStates.filter(filter2);
      newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);
    else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {};
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a2 = this.states) || void 0 === _a2 ? void 0 : _a2[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params2, resetScale) {
    const _anchor = [0, 0], getBounds = () => {
      if (params2.b) return params2.b;
      const graphic = this.clone();
      return graphic.attribute.angle = 0, graphic.attribute.scaleCenter = null, resetScale && (graphic.attribute.scaleX = 1, graphic.attribute.scaleY = 1), params2.b = graphic.AABBBounds, params2.b;
    };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100, bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100, bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, scaleCenter, anchor, postMatrix } = this.attribute;
    let _anchor = [0, 0];
    const params2 = {};
    if (anchor && angle2 && (_anchor = this.getAnchor(anchor, params2)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle2, anchor && _anchor);
    else {
      const m3 = this._transMatrix;
      m3.reset(), m3.translate(_anchor[0], _anchor[1]), m3.rotate(angle2), m3.translate(-_anchor[0], -_anchor[1]), m3.translate(x, y), _anchor = this.getAnchor(scaleCenter, params2, true), application.transformUtil.fromMatrix(m3, m3).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m22 = this._transMatrix;
      m1.multiply(m22.a, m22.b, m22.c, m22.d, m22.e, m22.f), m22.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach((a2) => {
          a2.timeline === defaultTimeline && a2.setTimeline(timeline);
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {
  }
  onStop(props) {
    props && this.setAttributes(props, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onStep(subAnimate, animate, step, ratio, end) {
    const nextAttributes = {};
    if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);
    else {
      const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;
      this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
    }
    this.setAttributes(nextAttributes, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end,
        step,
        isFirstFrameOfStep: subAnimate.getLastStep() !== step
      }
    }), this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
    propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key) => {
      animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
    }) : propKeys.forEach((key) => {
      var _a;
      if (!animate.validAttr(key)) return;
      const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
      if (null == nextStepVal || null == lastStepVal || nextStepVal === lastStepVal) return void (nextAttributes[key] = nextStepVal);
      let match;
      match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
    }), step.parsedProps = nextParsedProps;
  }
  defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
    if (Number.isFinite(nextStepVal) && Number.isFinite(lastStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, true;
    if ("fill" === key) {
      nextParsedProps || (nextParsedProps = {});
      const fillColorArray = nextParsedProps.fillColorArray, color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.fillColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("stroke" === key) {
      nextParsedProps || (nextParsedProps = {});
      const strokeColorArray = nextParsedProps.strokeColorArray, color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.strokeColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("shadowColor" === key) {
      nextParsedProps || (nextParsedProps = {});
      const shadowColorArray = nextParsedProps.shadowColorArray, color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, true, (fArray, tArray) => {
        nextParsedProps.shadowColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if (Array.isArray(nextStepVal) && nextStepVal.length === lastStepVal.length) {
      const nextList = [];
      let valid = true;
      for (let i = 0; i < nextStepVal.length; i++) {
        const v = lastStepVal[i], val = v + (nextStepVal[i] - v) * ratio;
        if (!Number.isFinite(val)) {
          valid = false;
          break;
        }
        nextList.push(val);
      }
      valid && (nextAttributes[key] = nextList);
    }
    return false;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
  }
  getDefaultAttribute(name) {
    return this.getGraphicTheme()[name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb, immediate = false) {
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(true), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((item) => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString_default(path, true) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image, background = false) {
    if (!image || background && backgroundNotImage(image)) return;
    const url = image;
    this.resources || (this.resources = /* @__PURE__ */ new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl_default(image) || image.includes("/") || isBase64_default(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject_default(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
  }
  setShadowGraphic(graphic) {
    if (graphic) {
      this.attachShadow().add(graphic);
    } else this.detachShadow();
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach((animate) => {
      animate.stop();
    });
  }
  stopAnimates(stopChildren = false) {
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(true), this.isContainer && stopChildren && this.forEachChildren((c2) => {
      c2.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = false, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
};
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget2);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/group.js
var GroupUpdateAABBBoundsMode;
!function(GroupUpdateAABBBoundsMode2) {
  GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
var Group = class _Group extends Graphic {
  constructor(params2) {
    super(params2), this.type = "group", this.parent = null, this.isContainer = true, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  setTheme(t) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  visibleAll(visible) {
    this.setAttribute("visible", visible), this.forEachChildren((item) => {
      item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
    });
  }
  hideAll() {
    this.visibleAll(false);
  }
  showAll() {
    this.visibleAll(true);
  }
  containsPoint(x, y, mode) {
    if (mode === IContainPointMode.GLOBAL) {
      const point5 = new Point(x, y);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point5, point5), this.AABBBounds.contains(point5.x, point5.y);
    }
    return this.AABBBounds.contains(x, y);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, dx = DefaultTransform.dx, dy = DefaultTransform.dy, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, postMatrix } = this.attribute;
    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle2 || postMatrix) return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  getGraphicTheme() {
    return getTheme(this).group;
  }
  updateAABBBounds(attribute, groupTheme, aabbBounds) {
    const originalAABBBounds = aabbBounds;
    aabbBounds = aabbBounds.clone();
    const { width, height, path, clip = groupTheme.clip } = attribute;
    if (path && path.length ? path.forEach((g) => {
      aabbBounds.union(g.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
      this.forEachChildren((node) => {
        aabbBounds.union(node.AABBBounds);
      });
      const { scrollX = 0, scrollY = 0 } = attribute;
      aabbBounds.translate(scrollX, scrollY);
    }
    return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, false, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++;
    const bounds = super.doUpdateAABBBounds();
    return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
  }
  _updateChildToStage(child) {
    return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
  }
  appendChild(node, addStage = true) {
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
  }
  insertAfter(newNode, referenceNode) {
    return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
  }
  insertInto(newNode, idx) {
    return this._updateChildToStage(super.insertInto(newNode, idx));
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
  }
  removeAllChild(deep = false) {
    this.forEachChildren((child) => {
      application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren((item) => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m3 = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find((node) => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new _Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Group.NOWORK_ANIMATE_ATTR;
  }
  release(all) {
    all && this.forEachChildren((g) => {
      g.release(all);
    }), super.release();
  }
};
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/layer.js
var Layer = class extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("暂不支持");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global2, window2, params2) {
    var _a;
    super({}), this.stage = stage, this.global = global2, this.window = window2, this.main = params2.main, this.layerHandler = params2.layerHandler, this.layerHandler.init(this, window2, {
      main: params2.main,
      canvasId: params2.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params2.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = /* @__PURE__ */ new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer(removeIncrementalKey = true) {
    const subLayers = Array.from(this.subLayers.values()).sort((a2, b) => a2.zIndex - b.zIndex);
    this.layerHandler.merge(subLayers.map((l) => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach((l) => {
      l.group && (l.group.incremental = 0);
    }), subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x, y) {
    throw new Error("暂不支持");
  }
  tryRenderSecondaryLayer(params2, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach((h) => {
      h.layer.renderCount = this.renderCount, h.layer.render(params2, userParams);
    });
  }
  render(params2, userParams) {
    var _a;
    this.layerHandler.render([this], {
      renderService: params2.renderService,
      stage: this.stage,
      layer: this,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params2.updateBounds
    }, userParams), this.afterDrawCbs.forEach((c2) => c2(this)), this.tryRenderSecondaryLayer(params2, userParams);
  }
  resize(w, h) {
    this.layerHandler.resize(w, h);
  }
  resizeView(w, h) {
    this.layerHandler.resizeView(w, h);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  prepare(dirtyBounds, params2) {
  }
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    });
  }
  drawTo(target, params2) {
    var _a;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      renderService: params2.renderService,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      stage: this.stage,
      layer: this
    }, params2)), this.afterDrawCbs.forEach((c2) => c2(this));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/constants.js
var TransformUtil = Symbol.for("TransformUtil");
var GraphicUtil = Symbol.for("GraphicUtil");
var LayerService = Symbol.for("LayerService");
var StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
var DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
var VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/layer-service.js
var DefaultLayerService_1;
var __decorate6 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata4 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = /* @__PURE__ */ new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = true);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage, options = {
    main: false
  }) {
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode), layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
      main: false
    }, options), {
      layerMode,
      canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
      layerHandler
    })), stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren((l) => {
      const handler = l.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter((l) => l !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(stage) {
    this.layerMap.delete(stage);
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate6([injectable(), __metadata4("design:paramtypes", [])], DefaultLayerService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/core-modules.js
var core_modules_default = new ContainerModule((bind) => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/utils.js
function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke2, lineWidth) {
  let s2;
  return s2 = isArray_default(stroke2) ? stroke2.some((item) => item || void 0 === item) : !!stroke2, s2 && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height) {
  return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
  let t = y32 * x10 - x32 * y10;
  return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
}
function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
  const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
  let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
  const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
  const deltaAngle = abs(endAngle - startAngle), cornerRadius = arc.getParsedCornerRadius(), cornerRadiusIsArray = isArray_default(cornerRadius), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius, outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius, innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius, innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
  let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
  const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
  let xore, yore, xirs, yirs;
  if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
    const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
    if (oc) {
      const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
    }
  }
  return {
    outerDeltaAngle,
    xors,
    yors,
    xirs,
    yirs,
    xore,
    yore,
    xire,
    yire,
    limitedOcr,
    limitedIcr,
    outerCornerRadiusStart,
    outerCornerRadiusEnd,
    maxOuterCornerRadius,
    maxInnerCornerRadius,
    outerStartAngle,
    outerEndAngle,
    innerDeltaAngle,
    innerEndAngle,
    innerStartAngle,
    innerCornerRadiusStart,
    innerCornerRadiusEnd
  };
}
function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp2 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp2;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));
  else {
    const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, outerStartAngle, outerEndAngle, limitedIcr, innerDeltaAngle, innerEndAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (outerDeltaAngle < 1e-3) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = true;
    else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/canvas/conical-gradient.js
var ConicalCanvas = class _ConicalCanvas {
  static GetCanvas() {
    try {
      return _ConicalCanvas.canvas || (_ConicalCanvas.canvas = application.global.createCanvas({})), _ConicalCanvas.canvas;
    } catch (err) {
      return null;
    }
  }
  static GetCtx() {
    if (!_ConicalCanvas.ctx) {
      const conicalCanvas = _ConicalCanvas.GetCanvas();
      _ConicalCanvas.ctx = conicalCanvas.getContext("2d");
    }
    return _ConicalCanvas.ctx;
  }
};
var ColorInterpolate = class _ColorInterpolate extends LRU {
  static getInstance() {
    return _ColorInterpolate._instance || (_ColorInterpolate._instance = new _ColorInterpolate()), _ColorInterpolate._instance;
  }
  constructor(stops = [], precision2 = 100) {
    super(), this.cacheParams = {
      CLEAN_THRESHOLD: 100,
      L_TIME: 1e3
    }, this.dataMap = /* @__PURE__ */ new Map();
    const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
    if (canvas.width = precision2, canvas.height = 1, !conicalCtx) return;
    if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
    const gradient = conicalCtx.createLinearGradient(0, 0, precision2, 0);
    stops.forEach((stop) => {
      gradient.addColorStop(stop[0], stop[1]);
    }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision2, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision2, 1).data;
  }
  getColor(offset) {
    const rgba2 = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
    return `rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, ${rgba2[3] / 255})`;
  }
  GetOrCreate(x, y, w, h, stops = [], precision2 = 100) {
    let str2 = `${x}${y}${w}${h}`;
    stops.forEach((item) => str2 += item.join()), str2 += precision2;
    let colorInter = this.dataMap.get(str2);
    if (!colorInter) {
      colorInter = {
        data: new _ColorInterpolate(stops, precision2),
        timestamp: []
      }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str2, colorInter);
    }
    return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
  }
};
var ConicalPatternStore = class _ConicalPatternStore {
  static GetSize(minSize) {
    for (let i = 0; i < _ConicalPatternStore.ImageSize.length; i++) if (_ConicalPatternStore.ImageSize[i] >= minSize) return _ConicalPatternStore.ImageSize[i];
    return minSize;
  }
  static Get(stops, x, y, startAngle, endAngle, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle), data = _ConicalPatternStore.cache[key];
    if (!data || 0 === data.length) return null;
    for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
    return null;
  }
  static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
    _ConicalPatternStore.cache[key] ? _ConicalPatternStore.cache[key].push({
      width: w,
      height: h,
      pattern
    }) : _ConicalPatternStore.cache[key] = [{
      width: w,
      height: h,
      pattern
    }];
  }
  static GenKey(stops, x, y, startAngle, endAngle) {
    return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
  }
};
ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x, y, angle2, color) {
  const { stops, startAngle, endAngle } = color;
  for (; angle2 < 0; ) angle2 += pi2;
  for (; angle2 > pi2; ) angle2 -= pi2;
  if (angle2 < startAngle) return stops[0].color;
  if (angle2 > endAngle) return stops[0].color;
  let startStop, endStop, percent = (angle2 - startAngle) / (endAngle - startAngle);
  for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
    startStop = stops[i - 1], endStop = stops[i];
    break;
  }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, false);
}
function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
  const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
  if (!conicalCtx) return null;
  const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);
  let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
  if (pattern) return pattern;
  const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum), lineWidth = 2 * Math.PI * r / 360;
  conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
  for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
    const color = colorInter.getColor(i);
    conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
  }
  const imageData = conicalCtx.getImageData(0, 0, width, height);
  return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/constants.js
var ArcRenderContribution = Symbol.for("ArcRenderContribution");
var AreaRenderContribution = Symbol.for("AreaRenderContribution");
var CircleRenderContribution = Symbol.for("CircleRenderContribution");
var GroupRenderContribution = Symbol.for("GroupRenderContribution");
var ImageRenderContribution = Symbol.for("ImageRenderContribution");
var PathRenderContribution = Symbol.for("PathRenderContribution");
var PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
var RectRenderContribution = Symbol.for("RectRenderContribution");
var SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
var TextRenderContribution = Symbol.for("TextRenderContribution");
var StarRenderContribution = Symbol.for("StarRenderContribution");
var CommonRenderContribution = Symbol.for("CommonRenderContribution");
var InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/text.js
function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - 0.79 * fontSize);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/matrix.js
function identityMat4(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a2, rad) {
  const s2 = Math.sin(rad), c2 = Math.cos(rad), a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  return a2 !== out && (out[0] = a2[0], out[1] = a2[1], out[2] = a2[2], out[3] = a2[3], out[12] = a2[12], out[13] = a2[13], out[14] = a2[14], out[15] = a2[15]), out[4] = a10 * c2 + a20 * s2, out[5] = a11 * c2 + a21 * s2, out[6] = a12 * c2 + a22 * s2, out[7] = a13 * c2 + a23 * s2, out[8] = a20 * c2 - a10 * s2, out[9] = a21 * c2 - a11 * s2, out[10] = a22 * c2 - a12 * s2, out[11] = a23 * c2 - a13 * s2, out;
}
function rotateY(out, a2, rad) {
  const s2 = Math.sin(rad), c2 = Math.cos(rad), a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  return a2 !== out && (out[4] = a2[4], out[5] = a2[5], out[6] = a2[6], out[7] = a2[7], out[12] = a2[12], out[13] = a2[13], out[14] = a2[14], out[15] = a2[15]), out[0] = a00 * c2 - a20 * s2, out[1] = a01 * c2 - a21 * s2, out[2] = a02 * c2 - a22 * s2, out[3] = a03 * c2 - a23 * s2, out[8] = a00 * s2 + a20 * c2, out[9] = a01 * s2 + a21 * c2, out[10] = a02 * s2 + a22 * c2, out[11] = a03 * s2 + a23 * c2, out;
}
function rotateZ(out, a2, rad) {
  const s2 = Math.sin(rad), c2 = Math.cos(rad), a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  return a2 !== out && (out[8] = a2[8], out[9] = a2[9], out[10] = a2[10], out[11] = a2[11], out[12] = a2[12], out[13] = a2[13], out[14] = a2[14], out[15] = a2[15]), out[0] = a00 * c2 + a10 * s2, out[1] = a01 * c2 + a11 * s2, out[2] = a02 * c2 + a12 * s2, out[3] = a03 * c2 + a13 * s2, out[4] = a10 * c2 - a00 * s2, out[5] = a11 * c2 - a01 * s2, out[6] = a12 * c2 - a02 * s2, out[7] = a13 * c2 - a03 * s2, out;
}
function translate(out, a2, v) {
  const x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a2 === out ? (out[12] = a2[0] * x + a2[4] * y + a2[8] * z + a2[12], out[13] = a2[1] * x + a2[5] * y + a2[9] * z + a2[13], out[14] = a2[2] * x + a2[6] * y + a2[10] * z + a2[14], out[15] = a2[3] * x + a2[7] * y + a2[11] * z + a2[15]) : (a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a2[12], out[13] = a01 * x + a11 * y + a21 * z + a2[13], out[14] = a02 * x + a12 * y + a22 * z + a2[14], out[15] = a03 * x + a13 * y + a23 * z + a2[15]), out;
}
function mat3Tomat4(out, b) {
  out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
}
function scaleMat4(out, a2, v) {
  const x = v[0], y = v[1], z = v[2];
  return out[0] = a2[0] * x, out[1] = a2[1] * x, out[2] = a2[2] * x, out[3] = a2[3] * x, out[4] = a2[4] * y, out[5] = a2[5] * y, out[6] = a2[6] * y, out[7] = a2[7] * y, out[8] = a2[8] * z, out[9] = a2[9] * z, out[10] = a2[10] * z, out[11] = a2[11] * z, out[12] = a2[12], out[13] = a2[13], out[14] = a2[14], out[15] = a2[15], out;
}
function multiplyMat4Mat4(out, a2, b) {
  const a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11], a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? identityMat4(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}
function ortho(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}
function transformMat4(out, a2, m3) {
  const x = a2[0], y = a2[1], z = a2[2];
  let w = m3[3] * x + m3[7] * y + m3[11] * z + m3[15];
  return w = w || 1, out[0] = (m3[0] * x + m3[4] * y + m3[8] * z + m3[12]) / w, out[1] = (m3[1] * x + m3[5] * y + m3[9] * z + m3[13]) / w, out[2] = (m3[2] * x + m3[6] * y + m3[10] * z + m3[14]) / w, out;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/allocator/matrix-allocate.js
var MatrixAllocate = Symbol.for("MatrixAllocate");
var Mat4Allocate = Symbol.for("Mat4Allocate");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
var DefaultMatrixAllocate = class {
  constructor() {
    this.pools = [];
  }
  allocate(a2, b, c2, d, e, f) {
    if (!this.pools.length) return new Matrix(a2, b, c2, d, e, f);
    const m3 = this.pools.pop();
    return m3.a = a2, m3.b = b, m3.c = c2, m3.d = d, m3.e = e, m3.f = f, m3;
  }
  allocateByObj(matrix) {
    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m3 = this.pools.pop();
    return m3.a = matrix.a, m3.b = matrix.b, m3.c = matrix.c, m3.d = matrix.d, m3.e = matrix.e, m3.f = matrix.f, m3;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultMat4Allocate = class _DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return identityMat4(out);
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const m3 = this.pools.pop();
    return _DefaultMat4Allocate.identity(m3), m3;
  }
  allocateByObj(d) {
    let m3;
    m3 = this.pools.length ? this.pools.pop() : createMat4();
    for (let i = 0; i < m3.length; i++) m3[i] = d[i];
    return m3;
  }
  free(m3) {
    m3 && this.pools.push(m3);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var matrixAllocate = new DefaultMatrixAllocate();
var mat4Allocate = new DefaultMat4Allocate();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-service.js
var __decorate7 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata5 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function getModelMatrix(out, graphic, theme4) {
  var _a;
  const { x = theme4.x, y = theme4.y, z = theme4.z, dx = theme4.dx, dy = theme4.dy, dz = theme4.dz, scaleX = theme4.scaleX, scaleY = theme4.scaleY, scaleZ = theme4.scaleZ, alpha = theme4.alpha, beta = theme4.beta, angle: angle2 = theme4.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute, _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle2) {
    const m3 = mat4Allocate.allocate(), _anchor2 = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
        _anchor2[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
        _anchor2[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[1] = anchor3d[1];
    }
    translate(m3, m3, [_anchor2[0], _anchor2[1], 0]), rotateZ(m3, m3, angle2), translate(m3, m3, [-_anchor2[0], -_anchor2[1], 0]), multiplyMat4Mat4(out, out, m3);
  }
}
function shouldUseMat4(graphic) {
  const { alpha, beta } = graphic.attribute;
  return alpha || beta;
}
var DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
      clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds();
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params2, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params2, selfChange);
  }
  clearAABBBounds(graphic, stage, b) {
    this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path) return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    const { textAlign, textBaseline } = attribute;
    if (null != attribute.forceBoundsHeight) {
      const h = isNumber_default(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(), dy = textLayoutOffsetY(textBaseline, h, h);
      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
    }
    if (null != attribute.forceBoundsWidth) {
      const w = isNumber_default(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(), dx = textDrawOffsetX(textAlign, w);
      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
    }
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b = graphic.shadowRoot.AABBBounds;
      bounds.union(b);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme4, miter, graphic) {
    if (!aabbBounds.empty()) {
      const { scaleX = theme4.scaleX, scaleY = theme4.scaleY, stroke: stroke2 = theme4.stroke, shadowBlur = theme4.shadowBlur, lineWidth = theme4.lineWidth, pickStrokeBuffer = theme4.pickStrokeBuffer, strokeBoundsBuffer = theme4.strokeBoundsBuffer } = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
      if (stroke2 && lineWidth) {
        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
      }
      if (shadowBlur) {
        const { shadowOffsetX = theme4.shadowOffsetX, shadowOffsetY = theme4.shadowOffsetY } = attribute, shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
        boundStroke(tb1, shadowBlurWidth, false, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
      }
    }
    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
    let updateMatrix = true;
    const m3 = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m3.a && 0 === m3.b && 0 === m3.c && 1 === m3.d && 0 === m3.e && 0 === m3.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m3);
  }
  validCheck(attribute, theme4, aabbBounds, graphic) {
    if (!graphic) return true;
    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return true;
    if (graphic.shadowRoot || graphic.isContainer) return true;
    const { visible = theme4.visible } = attribute;
    return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), application.graphicService.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), false);
  }
  updateTempAABBBounds(aabbBounds) {
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
      tb1,
      tb2
    };
  }
};
DefaultGraphicService = __decorate7([injectable(), __param3(0, inject(GraphicCreator)), __metadata5("design:paramtypes", [Object])], DefaultGraphicService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic-service/common-outer-boder-bounds.js
var updateBoundsOfCommonOuterBorder = (attribute, theme4, aabbBounds) => {
  const { outerBorder, shadowBlur = theme4.shadowBlur } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = theme4.outerBorder, { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
    aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
  }
  return aabbBounds;
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/circle.js
var CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
var Circle = class _Circle extends Graphic {
  constructor(params2 = {
    radius: 1
  }) {
    super(params2), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, radius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  getGraphicTheme() {
    return getTheme(this).circle;
  }
  updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, false, this), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
    const { radius = circleTheme.radius } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
    const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"), path = new CustomPath2D();
    return path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new _Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Circle.NOWORK_ANIMATE_ATTR;
  }
};
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/layout.js
var CanvasTextLayout = class {
  constructor(fontFamily, options, textMeasure2) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure2;
  }
  LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
    if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;
    else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;
    else if ("alphabetic" === textBaseline) {
      let percent = 0.79;
      if (1 === linesLayout.length) {
        const lineInfo = linesLayout[0];
        percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
      }
      bbox.yOffset = bbox.height * -percent;
    } else bbox.yOffset = -bbox.height;
    return bbox;
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, params2) {
    const { lineWidth, suffixPosition = "end", measureMode = MeasureModeEnum.actualBounding, keepCenterInLine = false } = null != params2 ? params2 : {};
    lines = lines.map((l) => l.toString());
    const linesLayout = [], bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i = 0, len = lines.length; i < len; i++) {
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        let str2 = lines[i].toString();
        if (metrics.width > lineWidth) {
          const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
          str2 = data.str, width = data.width;
        } else width = metrics.width;
        linesLayout.push({
          str: str2,
          width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    } else {
      let width, text2, _lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        text2 = lines[i];
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
          str: text2,
          width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = _lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a2, b) => Math.max(a2, b.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0], totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox,
      lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight,
      textAlign,
      textBaseline
    };
  }
  lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
    if ("left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1], !line.keepCenterInLine) {
      const buf = 0, actualHeightWithBuf = line.ascent + line.descent + buf;
      if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
        const ratio = lineHeight / (line.ascent + line.descent);
        line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 * ratio + origin[1];
      }
    }
    return origin[1] += lineHeight, line;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/text.js
var TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
var Text = class _Text extends Graphic {
  get font() {
    const textTheme = this.getGraphicTheme();
    return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute, textTheme = this.getGraphicTheme(), maxWidth = this.getMaxWidth(textTheme);
    return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    var _a, _b;
    const textTheme = this.getGraphicTheme(), attribute = this.attribute, maxWidth = this.getMaxWidth(textTheme);
    if (!Number.isFinite(maxWidth)) return false;
    const { text: text2 } = this.attribute;
    if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
      let mergedText = "";
      this.cache.layoutData.lines.forEach((item) => {
        mergedText += item.str;
      });
      return (Array.isArray(text2) ? text2.join("") : text2) !== mergedText;
    }
    return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map((item) => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
  }
  get multilineLayout() {
    return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor(params2 = {
    text: "",
    fontSize: 16
  }) {
    super(params2), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t) => null == t || "" === t) : null != text2 && "" !== text2;
  }
  getGraphicTheme() {
    return getTheme(this).text;
  }
  doUpdateOBBBounds() {
    const graphicTheme = this.getGraphicTheme();
    this._OBBBounds.clear();
    const attribute = this.attribute, { angle: angle2 = graphicTheme.angle } = attribute;
    if (!angle2) {
      const b = this.AABBBounds;
      return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
    }
    this.obbText || (this.obbText = new _Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
      angle: 0
    }));
    const bounds1 = this.obbText.AABBBounds, { x, y } = attribute, boundsCenter = {
      x: (bounds1.x1 + bounds1.x2) / 2,
      y: (bounds1.y1 + bounds1.y2) / 2
    }, center = rotatePoint(boundsCenter, angle2, {
      x,
      y
    });
    return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y), this._OBBBounds.angle = angle2, this._OBBBounds;
  }
  updateAABBBounds(attribute, textTheme, aabbBounds) {
    const { text: text2 = textTheme.text } = this.attribute;
    Array.isArray(text2) ? this.updateMultilineAABBBounds(text2) : this.updateSingallineAABBBounds(text2);
    const { tb1 } = application.graphicService.updateTempAABBBounds(aabbBounds), { scaleX = textTheme.scaleX, scaleY = textTheme.scaleY, shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer = textTheme.strokeBoundsBuffer } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, true, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
  }
  updateSingallineAABBBounds(text2) {
    this.updateMultilineAABBBounds([text2]);
    const layoutData = this.cache.layoutData;
    if (layoutData && layoutData.lines && layoutData.lines.length) {
      const line = layoutData.lines[0];
      this.cache.clipedText = line.str, this.cache.clipedWidth = line.width;
    }
    return this._AABBBounds;
  }
  updateMultilineAABBBounds(text2) {
    const textTheme = this.getGraphicTheme(), { direction = textTheme.direction, underlineOffset = textTheme.underlineOffset } = this.attribute, b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text2) : this.updateVerticalMultilineAABBBounds(text2);
    return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  guessLineHeightBuf(fontSize) {
    return fontSize ? 0.1 * fontSize : 0;
  }
  updateHorizontalMultilineAABBBounds(text2) {
    var _a;
    const textTheme = this.getGraphicTheme(), attribute = this.attribute, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, wrap = textTheme.wrap, measureMode = textTheme.measureMode, lineWidth = textTheme.lineWidth, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition, ignoreBuf = textTheme.ignoreBuf, keepCenterInLine = textTheme.keepCenterInLine } = attribute, buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize), lineHeight = this.getLineHeight(attribute, textTheme, buf);
    if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text2);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure2 = application.graphicUtil.textMeasure, layoutData = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily,
      lineHeight
    }, textMeasure2).GetLayoutByLines(text2, textAlign, textBaseline, lineHeight, true === ellipsis ? textTheme.ellipsis : ellipsis || void 0, false, {
      lineWidth: maxLineWidth,
      suffixPosition,
      measureMode,
      keepCenterInLine
    }), { bbox } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateWrapAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = this.getGraphicTheme(), { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, measureMode = textTheme.measureMode, suffixPosition = textTheme.suffixPosition, heightLimit = 0, lineClamp, keepCenterInLine = textTheme.keepCenterInLine } = this.attribute, buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize), lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure2 = application.graphicUtil.textMeasure, textOptions = {
      fontSize,
      fontWeight,
      fontFamily,
      lineHeight
    }, layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure2), lines = isArray_default(text2) ? text2.map((l) => l.toString()) : [text2.toString()], linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str2 = lines[i];
        let needCut = true;
        if (i === lineCountLimit - 1) {
          const clip2 = textMeasure2.clipTextWithSuffix(str2, textOptions, maxLineWidth, ellipsis, false, suffixPosition, i !== lines.length - 1), matrics2 = textMeasure2.measureTextPixelADscentAndWidth(clip2.str, textOptions, measureMode);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width,
            ascent: matrics2.ascent,
            descent: matrics2.descent,
            keepCenterInLine
          });
          break;
        }
        const clip = textMeasure2.clipText(str2, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
        if ("" !== str2 && "" === clip.str || clip.wordBreaked) {
          if (ellipsis) {
            const clipEllipsis = textMeasure2.clipTextWithSuffix(str2, textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        const matrics = textMeasure2.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
        linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine
        });
        let cutLength = clip.str.length;
        if (!clip.wordBreaked || "" !== str2 && "" === clip.str || (needCut = true, cutLength = clip.wordBreaked), clip.str.length === str2.length) ;
        else if (needCut) {
          let newStr = str2.substring(cutLength);
          "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout) => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = textMeasure2.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, false, suffixPosition), matrics2 = textMeasure2.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics2.ascent,
            descent: matrics2.descent,
            keepCenterInLine
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i], width = textMeasure2.measureTextWidth(text3, textOptions), lineWidth2 = Math.max(lineWidth2, width);
        const matrics = textMeasure2.measureTextPixelADscentAndWidth(text3, textOptions, measureMode);
        linesLayout.push({
          str: text3,
          width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * lineHeight;
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text2) {
    var _a, _b;
    const textTheme = this.getGraphicTheme(), textMeasure2 = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = this.getLineHeight(attribute, textTheme, 0);
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_a = _Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = _Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach((item) => {
        const w = item.reduce((a2, b) => a2 + b.width, 0);
        width = max(w, width);
      });
      const dx2 = textDrawOffsetX(textAlign, width), height2 = this.cache.verticalList.length * lineHeight, dy2 = textLayoutOffsetY(textBaseline, height2, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + height2, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text2.map((str2) => verticalLayout(str2.toString()));
    verticalLists.forEach((verticalData, i) => {
      if (Number.isFinite(maxLineWidth)) if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure2.clipTextWithSuffixVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        verticalLists[i] = data.verticalList, width = data.width;
      } else {
        const data = textMeasure2.clipTextVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        verticalLists[i] = data.verticalList, width = data.width;
      }
      else width = 0, verticalData.forEach((t) => {
        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure2.measureTextWidth(t.text, {
          fontSize,
          fontWeight,
          fontFamily
        });
        width += w, t.width = w;
      });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach((item) => {
      const w = item.reduce((a2, b) => a2 + b.width, 0);
      width = max(w, width);
    });
    const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getMaxWidth(theme4) {
    var _a, _b;
    const attribute = this.attribute;
    return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme4.maxWidth;
  }
  getLineHeight(attribute, textTheme, buf) {
    var _a;
    return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
  }
  needUpdateTags(keys2, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(keys2, k2);
  }
  needUpdateTag(key, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(key, k2);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "text" === key && (nextAttributes.text = nextStepVal);
  }
  clone() {
    return new _Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Text.NOWORK_ANIMATE_ATTR;
  }
  getBaselineMapAlign() {
    return _Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return _Text.alignMapBaseline;
  }
};
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/wrap-text.js
var WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
var WrapText = class _WrapText extends Text {
  constructor(params2) {
    super(Object.assign(Object.assign({}, params2), {
      wrap: true
    }));
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t) => null == t || "" === t) : null != text2 && "" !== text2;
  }
  updateMultilineAABBBounds(text2) {
    var _a, _b, _c, _d;
    const textTheme = this.getGraphicTheme(), { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, heightLimit = 0, suffixPosition = textTheme.suffixPosition, lineClamp } = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure2 = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure2), lines = text2.map((l) => l.toString()), linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str2 = lines[i];
        let needCut = true;
        if (i === lineCountLimit - 1) {
          const clip2 = layoutObj.textMeasure.clipTextWithSuffix(str2, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: false
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str2, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str2 && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str2, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: false
        }), clip.str.length === str2.length) ;
        else if (needCut) {
          const newStr = str2.substring(clip.str.length);
          lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout) => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: false
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i], width = layoutObj.textMeasure.measureTextWidth(text3, layoutObj.textOptions, "break-word" === wordBreak), lineWidth2 = Math.max(lineWidth2, width), linesLayout.push({
          str: text3,
          width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: false
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  needUpdateTags(keys2) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
      if (-1 !== keys2.indexOf(attrKey)) return true;
    }
    return super.needUpdateTags(keys2);
  }
  needUpdateTag(key) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return true;
    }
    return super.needUpdateTag(key);
  }
  getNoWorkAnimateAttr() {
    return _WrapText.NOWORK_ANIMATE_ATTR;
  }
};
function createWrapText(attributes) {
  return new WrapText(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic-service/symbol-outer-border-bounds.js
var updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
  const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = symbolTheme.outerBorder, { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
    boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, true, strokeBoundsBuffer);
  }
  return aabbBounds;
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/symbol.js
var SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
var Symbol2 = class _Symbol extends Graphic {
  constructor(params2 = {
    symbolType: "circle"
  }) {
    super(params2), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  getParsedPath2D(x = 0, y = 0, size = 1) {
    let path = null;
    try {
      path = new Path2D();
    } catch (err) {
      return null;
    }
    const parsedPath = this.getParsedPath();
    if (!parsedPath) return null;
    parsedPath.draw(path, size, x, y);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { size } = this.attribute;
    return isArray_default(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const { symbolType = "circle" } = this.attribute;
    return super.parsePath(symbolType);
  }
  getGraphicTheme() {
    return getTheme(this).symbol;
  }
  updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, this.y1WithoutTransform = aabbBounds.y1;
    const { lineJoin = symbolTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
    const { size = symbolTheme.size } = attribute;
    if (isArray_default(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
    else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
    const { size = symbolTheme.size } = attribute;
    return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = isArray_default(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new _Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol2.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol2(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/line.js
var LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
var Line = class _Line extends Graphic {
  constructor(params2 = {}) {
    super(params2), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getGraphicTheme() {
    return getTheme(this).line;
  }
  updateAABBBounds(attribute, lineTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = lineTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const { points = lineTheme.points, connectedType } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      false === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
    }), b;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const { segments: segments2 = lineTheme.segments, connectedType } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        false === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
      });
    }), b;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, path = new CustomPath2D(), segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        points.forEach((point5) => {
          false !== point5.defined && (isFirst ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y), isFirst = false);
        });
      }
    };
    return segments2 && segments2.length ? segments2.forEach((seg) => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new _Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Line.NOWORK_ANIMATE_ATTR;
  }
};
Line.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/rect.js
var RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Rect = class _Rect extends Graphic {
  constructor(params2) {
    super(params2), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return true;
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      let { width, height } = attribute;
      const { x1, y1, x, y } = attribute;
      width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this), aabbBounds;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, { x, y, width, height } = normalizeRectAttributes(attribute), path = new CustomPath2D();
    return path.moveTo(x, y), path.rect(x, y, width, height), path;
  }
  clone() {
    return new _Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Rect.NOWORK_ANIMATE_ATTR;
  }
};
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/rect3d.js
var CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
var Rect3d = class _Rect3d extends Rect {
  constructor(params2) {
    super(params2), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  findFace() {
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    }, rectTheme = this.getGraphicTheme(), { x1, y1, x, y, length: length2 = min(rectTheme.width, rectTheme.height) } = this.attribute;
    let { width, height } = this.attribute;
    width = null != width ? width : x1 - x, height = null != height ? height : y1 - y;
    for (let i = 0; i < CUBE_VERTICES.length; i++) {
      const v = CUBE_VERTICES[i];
      faces.vertices.push([v[0] * width, v[1] * height, v[2] * length2]);
    }
    return faces.polygons.push({
      polygon: [0, 1, 5, 4],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [2, 3, 7, 6],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [4, 7, 3, 0],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 2, 6, 5],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  getNoWorkAnimateAttr() {
    return _Rect3d.NOWORK_ANIMATE_ATTR;
  }
};
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect3d(attributes) {
  return new Rect3d(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/glyph.js
var Glyph = class _Glyph extends Graphic {
  constructor(params2) {
    super(params2), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
  }
  setSubGraphic(subGraphic) {
    this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g) => {
      g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
    }), this.valid = this.isValid(), this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach((g) => {
      g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(cb) {
    this._onInit = cb;
  }
  onUpdate(cb) {
    this._onUpdate = cb;
  }
  isValid() {
    return true;
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    super.setAttributes(params2, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  translate(x, y) {
    return super.translate(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  translateTo(x, y) {
    return super.translateTo(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scale(scaleX, scaleY, scaleCenter) {
    return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scaleTo(scaleX, scaleY) {
    return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotate(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotateTo(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  getGraphicTheme() {
    return getTheme(this).glyph;
  }
  updateAABBBounds(attribute, theme4, aabbBounds) {
    return this.getSubGraphic().forEach((node) => {
      aabbBounds.union(node.AABBBounds);
    }), aabbBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++, this._AABBBounds.clear();
    const bounds = this.updateAABBBounds(this.attribute, this.getGraphicTheme(), this._AABBBounds);
    return this.clearUpdateBoundTag(), bounds;
  }
  needUpdateTags(keys2) {
    return false;
  }
  needUpdateTag(key) {
    return false;
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    this.stopStateAnimates();
    const stateAttrs = {}, subAttrs = this.subGraphic.map(() => ({}));
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
      attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a2 = attrs.subAttributes) || void 0 === _a2 ? void 0 : _a2.length) && subAttrs.forEach((subAttrs2, index) => {
        Object.assign(subAttrs2, attrs.subAttributes[index]);
      }));
    }), this.subGraphic.forEach((graphic, index) => {
      graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  clearStates(hasAnimation) {
    this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], this.subGraphic.forEach((graphic) => {
      graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, true), graphic.normalAttrs = null;
    }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  clone() {
    const glyph = new _Glyph(Object.assign({}, this.attribute));
    return glyph.setSubGraphic(this.subGraphic.map((g) => g.clone())), glyph;
  }
  getNoWorkAnimateAttr() {
    return _Glyph.NOWORK_ANIMATE_ATTR;
  }
};
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGlyph(attributes) {
  return new Glyph(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/frame.js
var Frame = class {
  constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons2) {
    this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons2 ? (icons2.clear(), this.icons = icons2) : this.icons = /* @__PURE__ */ new Map();
  }
  draw(ctx, drawIcon) {
    const { width: actualWidth, height: actualHeight } = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = false;
    if ("middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
      let lastLine = false;
      this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
    }
    else {
      const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
      "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
      for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
    }
    else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].draw(ctx, false, deltaX, y + deltaY, this.ellipsis, drawIcon);
      else {
        if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
        {
          let lastLine = false;
          this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
        }
      }
    }
    else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i = 0; i < this.lines.length; i++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
        const { top, height: height2 } = this.lines[i];
        if (0 === frameHeight) this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
        else {
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
          {
            let lastLine = false;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0, height = 0;
    for (let i = 0; i < this.lines.length; i++) {
      const line = this.lines[i];
      line.actualWidth > width && (width = line.actualWidth), height += line.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0, heightBound = 0;
    const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
    this.width;
    let height = this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
        const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
        lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
      } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
    }
    else {
      Math.floor((frameHeight - this.actualHeight) / 2);
      for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
    }
    else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      else if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;
      else {
        if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
          const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    else for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      else if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else {
        if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/paragraph.js
function getFixedLRTB(left, right, top, bottom) {
  const leftInt = Math.round(left), topInt = Math.round(top), rightInt = Math.round(right), bottomInt = Math.round(bottom);
  return {
    left: left > leftInt ? leftInt : leftInt - 0.5,
    top: top > topInt ? topInt : topInt - 0.5,
    right: rightInt > right ? rightInt : rightInt + 0.5,
    bottom: bottomInt > bottom ? bottomInt : bottomInt + 0.5
  };
}
var Paragraph = class {
  constructor(text2, newLine, character, ascentDescentMode) {
    var _a, _b;
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const { ascent, height, descent, width } = measureTextCanvas(text2, character, this.ascentDescentMode);
    let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text2.length, this.width = width || 0, this.text = text2 || "", this.newLine = newLine || false, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, this.space = character.space, this.dx = null !== (_a = character.dx) && void 0 !== _a ? _a : 0, this.dy = null !== (_b = character.dy) && void 0 !== _b ? _b : 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
  }
  updateWidth() {
    const { width } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
    let baseline = top + ascent, text2 = this.text, left = this.left + deltaLeft;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text2 = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text2 += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;
        else {
          const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left -= this.ellipsisWidth - width;
        }
      }
    }
    const lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + lineHeight);
    return Object.assign(Object.assign({}, lrtb), {
      fillStyle: this.character.background,
      globalAlpha: this.character.backgroundOpacity
    });
  }
  draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    var _a;
    let baseline = top + ascent, text2 = this.text, left = this.left + deltaLeft + (null !== (_a = this.space) && void 0 !== _a ? _a : 0) / 2;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text2 = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text2 += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;
        else {
          const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left -= this.ellipsisWidth - width;
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0);
    const { lineWidth = 1 } = this.character;
    if (this.character.stroke && lineWidth && ctx.strokeText(text2, left, baseline + this.dy), this.character.fill && ctx.fillText(text2, left, baseline + this.dy), this.character.fill) {
      if (this.character.lineThrough || this.character.underline) {
        if (this.character.underline) {
          const top2 = 1 + baseline, lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        }
        if (this.character.lineThrough) {
          const top2 = 1 + baseline - this.ascent / 2, lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        }
      } else if ("underline" === this.character.textDecoration) {
        const top2 = 1 + baseline, lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      } else if ("line-through" === this.character.textDecoration) {
        const top2 = 1 + baseline - this.ascent / 2, lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
    }
    "vertical" === direction && ctx.restore();
  }
  getWidthWithEllips(direction) {
    let text2 = this.text;
    const width = "vertical" === direction ? this.height : this.width;
    if ("hide" === this.ellipsis) return width;
    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text2, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
      text2 = text2.slice(0, index), text2 += this.ellipsisStr;
      const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
};
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, true, paragraph.character, paragraph.ascentDescentMode)];
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/image.js
var IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
var Image2 = class _Image extends Graphic {
  constructor(params2) {
    super(params2), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  getImageElement() {
    const { image } = this.attribute;
    if (!image || !this.resources) return null;
    const res = this.resources.get(image);
    return "success" !== res.state ? null : res.data;
  }
  get width() {
    return this.tryUpdateAABBBounds(), this._actualWidth;
  }
  get height() {
    return this.tryUpdateAABBBounds(), this._actualHeight;
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    }), this.addUpdateBoundTag();
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.image && this.loadImage(params2.image), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).image;
  }
  updateAABBBounds(attribute, imageTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const { maxWidth = imageTheme.maxWidth, maxHeight = imageTheme.maxHeight } = attribute;
      let { width, height } = attribute;
      if (null == width || null == height) {
        const imageElement = this.getImageElement();
        if (imageElement) {
          const imageWidth = imageElement.width, imageHeight = imageElement.height;
          if (null != width) height = width * (imageHeight / imageWidth);
          else if (null != height) width = height * (imageWidth / imageHeight);
          else {
            const imageRatio = imageWidth / imageHeight;
            imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
          }
        } else width = maxWidth, height = maxHeight;
      }
      this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, false, this), aabbBounds;
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new _Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Image.NOWORK_ANIMATE_ATTR;
  }
};
Image2.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image2(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/icon.js
var RichTextIcon = class extends Image2 {
  constructor(params2) {
    if (super(params2), this._x = 0, this._y = 0, this._hovered = false, this._marginArray = [0, 0, 0, 0], "always" === params2.backgroundShowMode && (this._hovered = true), params2.margin) {
      const marginArray = parsePadding(params2.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray_default(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
        const marginArray = parsePadding(attributes.margin);
        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute, { backgroundWidth = width, backgroundHeight = height } = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/line.js
var Line2 = class {
  constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
    this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p) => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result2 = regFirstSpace.exec(word.text);
        0 !== (null == result2 ? void 0 : result2.index) && (word.text = word.text.slice(null == result2 ? void 0 : result2.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey, maxHeight = this.height;
    let x = this.left, spacing = 0;
    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function(paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
    if (drawEllipsis && (lastLine || this.paragraphs.some((p) => p.overflow))) {
      let emptyOverflow = true, skipEllipsis = false;
      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;
        else if (emptyOverflow) {
          skipEllipsis = true;
          break;
        }
      }
      let otherParagraphWidth = 0;
      if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) {
          if ("" === paragraph.text) break;
          continue;
        }
        if (paragraph instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = true;
          break;
        }
        const ellipsis = true === drawEllipsis ? "..." : drawEllipsis || "";
        paragraph.ellipsisStr = ellipsis;
        const { width } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode), ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          lastLine && (paragraph.ellipsis = "add");
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    let fillStyle = "", globalAlpha = -1, currBgList = [];
    const bgList = [currBgList];
    this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return;
      const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
      data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
    }), bgList.forEach((bg) => {
      if (0 === bg.length) return;
      const data = bg[0], end = bg[bg.length - 1];
      ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
    }), this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
        x: x + paragraph._x,
        y: y + paragraph._y
      }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
      const b = {
        x1: this.left,
        y1: this.top,
        x2: this.left + this.actualWidth,
        y2: this.top + this.height
      };
      applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
    });
  }
  getWidthWithEllips(ellipsis) {
    let otherParagraphWidth = 0;
    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
      const paragraph = this.paragraphs[i];
      if (paragraph instanceof RichTextIcon) break;
      const { width: width2 } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode), ellipsisWidth = width2 || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.forEach((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext/wrapper.js
var Wrapper = class {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0, iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line = new Line2(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph, singleLine = false) {
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
  }
  cut(paragraph, singleLine) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), singleLine ? this.send() : this.deal(p2);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/richtext.js
var supportIntl = false;
try {
  supportIntl = Intl && "function" == typeof Intl.Segmenter;
} catch (e) {
  supportIntl = false;
}
var RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
var RichText = class _RichText extends Graphic {
  constructor(params2) {
    super(params2), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
      for (const key2 in val) if ("hoverIconId" === key2) {
        if (val[key2] === attributes[key2]) continue;
        const icon2 = this._frameCache.icons.get(val[key2]);
        this.updateHoverIconState(icon2);
      }
    };
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w) {
    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h) {
    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config) {
    this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
  }
  getGraphicTheme() {
    return getTheme(this).richtext;
  }
  static AllSingleCharacter(cache) {
    if (cache.lines) {
      return cache.lines.every((line) => line.paragraphs.every((item) => !(item.text && isString_default(item.text) && _RichText.splitText(item.text).length > 1)));
    }
    return cache.every((item) => item.isComposing || !(item.text && isString_default(item.text) && _RichText.splitText(item.text).length > 1));
  }
  static splitText(text2) {
    if (supportIntl) {
      const segmenter = new Intl.Segmenter(void 0, {
        granularity: "grapheme"
      }), segments2 = [];
      for (const { segment } of segmenter.segment(text2)) segments2.push(segment);
      return segments2;
    }
    return Array.from(text2);
  }
  static TransformTextConfig2SingleCharacter(textConfig) {
    const tc = [];
    return textConfig.forEach((item) => {
      const textList = _RichText.splitText(item.text.toString());
      if (isString_default(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
        const t = textList[i];
        tc.push(Object.assign(Object.assign({}, item), {
          text: t
        }));
      }
      else tc.push(item);
    }), tc;
  }
  updateAABBBounds(attribute, richtextTheme, aabbBounds) {
    var _a, _b, _c, _d;
    const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : "top", editOptions } = attribute;
    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);
    else {
      const frameCache = this.getFrameCache(), { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
    let deltaY = 0;
    switch (textBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    return aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  get cliped() {
    const frameCache = this.getFrameCache();
    if (frameCache.actualHeight > frameCache.height) return true;
    const { disableAutoWrapLine } = this.attribute;
    if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
      const l = frameCache.lines[i];
      for (let j = 0; j < l.paragraphs.length; j++) {
        const p = l.paragraphs[j];
        if (p.overflow && "" !== p.text) return true;
      }
    }
    return false;
  }
  combinedStyleToCharacter(config) {
    const { fill, stroke: stroke2, fontSize, fontFamily, fontStyle, fontWeight, lineWidth, opacity, fillOpacity, lineHeight, strokeOpacity, upgradeAttrs } = this.attribute, out = Object.assign({
      fill,
      stroke: stroke2,
      fontSize,
      fontFamily,
      fontStyle,
      fontWeight,
      lineWidth,
      opacity,
      fillOpacity,
      strokeOpacity
    }, config);
    return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
  }
  doUpdateFrameCache(tc) {
    var _a;
    const { maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine, disableAutoWrapLine, editable, ascentDescentMode, upgradeAttrs } = this.attribute, enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
    let { textConfig: _tc = [] } = this.attribute;
    editable && _tc.length > 0 && !_RichText.AllSingleCharacter(_tc) && (_tc = _RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
    const paragraphs = [], textConfig = null != tc ? tc : _tc;
    for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
      const config = this.combinedStyleToCharacter(textConfig[i]);
      config.lineWidth = void 0;
      const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
      if (iconCache) paragraphs.push(iconCache);
      else {
        const icon2 = new RichTextIcon(config);
        icon2.successCallback = () => {
          var _a2;
          this.addUpdateBoundTag(), null === (_a2 = this.stage) || void 0 === _a2 || _a2.renderNextFrame();
        }, icon2.richtextId = config.id, paragraphs.push(icon2);
      }
    } else {
      const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
      if (isNumber_default(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
        const textParts = richTextConfig.text.split("\n");
        for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], false, richTextConfig, ascentDescentMode));
        else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], true, richTextConfig, ascentDescentMode));
        else {
          const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
          paragraphs.push(new Paragraph(textParts[j], true, nextRichTextConfig, ascentDescentMode));
        }
      } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, false, richTextConfig, ascentDescentMode));
    }
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0, maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0, richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth), richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight), frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || false, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new Wrapper(frame);
    if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
      let lineCount = 0, skip = false;
      for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        skip ? (p.overflow = true, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, true), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = true, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = true), p.newLine && (skip = false, wrapper.lineWidth = 0), wrapper.send();
      }
    } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function(l) {
        l.calcOffset(offsetSize, false);
      });
    }
    enableMultiBreakLine && frame.lines.forEach((item) => {
      const lastParagraphs = item.paragraphs;
      item.paragraphs = item.paragraphs.filter((p) => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
    }), this._frameCache = frame;
  }
  clone() {
    return new _RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach((icon2) => {
      icon2.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", (e) => {
      const pickedIcon = this.pickIcon(e.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
    }), this.addEventListener("pointerleave", (e) => {
      this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
    });
  }
  updateHoverIconState(pickedIcon) {
    var _a, _b, _c, _d, _e;
    pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(false), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(true), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
  }
  pickIcon(point5) {
    const frameCache = this.getFrameCache(), { e: x, f: y } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon2, key) => {
      var _a, _b;
      const bounds = icon2.AABBBounds.clone();
      bounds.translate(icon2._marginArray[3], icon2._marginArray[0]), bounds.containsPoint({
        x: point5.x - x,
        y: point5.y - y
      }) && (pickIcon = icon2, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon2._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon2._marginArray[0]);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return _RichText.NOWORK_ANIMATE_ATTR;
  }
};
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/path.js
var PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
var Path = class _Path extends Graphic {
  constructor(params2) {
    super(params2), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { path } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = this.getGraphicTheme();
    if (!this.valid) return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil_default(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  getGraphicTheme() {
    return getTheme(this).path;
  }
  updateAABBBounds(attribute, pathTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const pathShape = this.getParsedPathShape();
      aabbBounds.union(pathShape.getBounds());
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = pathTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
  }
  doUpdateAABBBounds(full) {
    return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString_default(attribute.path, true) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new _Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Path.NOWORK_ANIMATE_ATTR;
  }
};
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/area.js
var AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
var Area = class _Area extends Graphic {
  constructor(params2) {
    super(params2), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && 0 !== points.length;
  }
  getGraphicTheme() {
    return getTheme(this).area;
  }
  updateAABBBounds(attribute, areaTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.setWidthHeightWithoutTransform(aabbBounds);
    const { lineJoin = areaTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const { points = areaTheme.points } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      var _a, _b;
      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }), b;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const { segments: segments2 = areaTheme.segments } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        var _a, _b;
        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      });
    }), b;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const path = new CustomPath2D(), attribute = this.attribute, segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        const basePoints = [];
        if (points.forEach((point5) => {
          var _a, _b;
          false !== point5.defined && (isFirst ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y), basePoints.push({
            x: null !== (_a = point5.x1) && void 0 !== _a ? _a : point5.x,
            y: null !== (_b = point5.y1) && void 0 !== _b ? _b : point5.y
          }), isFirst = false);
        }), basePoints.length) {
          for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
          path.closePath();
        }
      }
    };
    return attribute.points ? parsePoints(attribute.points) : segments2 && segments2.length && segments2.forEach((seg) => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new _Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Area.NOWORK_ANIMATE_ATTR;
  }
};
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/arc.js
var ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
var Arc = class _Arc extends Graphic {
  constructor(params2) {
    super(params2), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = this.getGraphicTheme(), { cornerRadius = arcTheme.cornerRadius, innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius), parseCR = (cornerRadius2) => Math.min(isNumber_default(cornerRadius2, true) ? cornerRadius2 : deltaRadius * parseFloat(cornerRadius2) / 100, deltaRadius / 2);
    if (isArray_default(cornerRadius)) {
      const crList = cornerRadius.map((cr) => parseCR(cr) || 0);
      return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
    }
    return parseCR(cornerRadius);
  }
  getParsedAngle() {
    const arcTheme = this.getGraphicTheme();
    let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
    const { cap = arcTheme.cap } = this.attribute, sign2 = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1, endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
      const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = this.attribute;
      outerRadius += outerPadding, innerRadius -= innerPadding;
      const capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon) return {
        startAngle: startAngle - sign2 * capAngle * startCap,
        endAngle: endAngle + sign2 * capAngle * endCap,
        sc: sign2 * capAngle * startCap,
        ec: sign2 * capAngle * endCap
      };
    }
    return {
      startAngle,
      endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = this.getGraphicTheme(), { innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding, padAngle = arcTheme.padAngle } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute, deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign2 = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)), p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign2, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign2, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle,
        outerEndAngle,
        innerStartAngle,
        innerEndAngle,
        innerDeltaAngle,
        outerDeltaAngle
      };
    }
    return {
      outerStartAngle,
      outerEndAngle,
      innerStartAngle,
      innerEndAngle,
      innerDeltaAngle,
      outerDeltaAngle
    };
  }
  getGraphicTheme() {
    return getTheme(this).arc;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.setWidthHeightWithoutTransform(aabbBounds);
    const { lineJoin = arcTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
    if (startAngle > endAngle) {
      const temp2 = startAngle;
      startAngle = endAngle, endAngle = temp2;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c, _d;
    const attribute = this.attribute, { startAngle, endAngle } = this.getParsedAngle();
    let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0), outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    const path = new CustomPath2D();
    if (outerRadius <= epsilon) path.moveTo(0, 0);
    else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));
    else {
      const xors = outerRadius * cos(startAngle), yors = outerRadius * sin(startAngle), xire = innerRadius * cos(endAngle), yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new _Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Arc.NOWORK_ANIMATE_ATTR;
  }
};
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/star.js
var STAR_UPDATE_TAG_KEY = ["width", "height", "spikes", "thickness", ...GRAPHIC_UPDATE_TAG_KEY];
var Star = class _Star extends Graphic {
  constructor(params2) {
    super(params2), this.type = "star", this._cachedPoints = [], this.numberType = STAR_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { width, height, spikes } = this.attribute;
    return (null == width || width > 0) && (null == height || height > 0) && (null == spikes || spikes >= 3 && Number.isInteger(spikes));
  }
  getGraphicTheme() {
    return getTheme(this).star;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const { width = 0, height = 0 } = attribute;
      (isFinite(width) || isFinite(height)) && aabbBounds.set(0, 0, width, height);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this), aabbBounds;
  }
  getCachedPoints() {
    return this.shouldUpdateShape() && (this._cachedPoints = this.getStarPoints(this.attribute, this.getGraphicTheme()), this.clearUpdateShapeTag()), this._cachedPoints;
  }
  getStarPoints(attribute, starTheme) {
    const { width = starTheme.width, height = starTheme.height, spikes = starTheme.spikes, thickness = starTheme.thickness } = attribute, validSpikes = Math.max(3, Math.floor(spikes)), validThickness = Math.max(0, Math.min(1, thickness)), points = [], outerRadius = Math.min(width, height) / 2, innerRadius = outerRadius * (1 - validThickness), centerX = width / 2, centerY = height / 2;
    for (let i = 0; i < 2 * validSpikes; i++) {
      const radius = i % 2 == 0 ? outerRadius : innerRadius, angle2 = Math.PI / validSpikes * i, scaleX = width / (2 * outerRadius), scaleY = height / (2 * outerRadius);
      points.push({
        x: centerX + Math.sin(angle2) * radius * scaleX,
        y: centerY - Math.cos(angle2) * radius * scaleY
      });
    }
    return this._cachedPoints = points, points;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "width" !== key && "height" !== key && "spikes" !== key && "thickness" !== key || (nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio);
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, STAR_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, STAR_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const starTheme = this.getGraphicTheme(), points = this.getStarPoints(this.attribute, starTheme), path = new CustomPath2D();
    return points.forEach((point5, index) => {
      0 === index ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Star(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Star.NOWORK_ANIMATE_ATTR;
  }
};
Star.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createStar(attributes) {
  return new Star(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/arc3d.js
var Arc3d = class _Arc3d extends Arc {
  constructor(params2) {
    super(params2), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute, r = outerRadius + height;
    return aabbBounds.setValue(-r, -r, r, r), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, false, this), aabbBounds;
  }
  getNoWorkAnimateAttr() {
    return _Arc3d.NOWORK_ANIMATE_ATTR;
  }
};
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc3d(attributes) {
  return new Arc3d(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/polygon.js
var POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Polygon = class _Polygon extends Graphic {
  constructor(params2) {
    super(params2), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { points } = this.attribute;
    return points && points.length >= 2;
  }
  getGraphicTheme() {
    return getTheme(this).polygon;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = polygonTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
    const { points = polygonTheme.points } = attribute;
    return points.forEach((p) => {
      aabbBounds.add(p.x, p.y);
    }), aabbBounds;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const points = this.attribute.points, path = new CustomPath2D();
    return points.forEach((point5, index) => {
      0 === index ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Polygon.NOWORK_ANIMATE_ATTR;
  }
};
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/pyramid3d.js
var Pyramid3d = class _Pyramid3d extends Polygon {
  constructor(params2) {
    super(params2), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    return this.findFace().vertices.forEach((v) => {
      const x = v[0], y = v[1];
      aabbBounds.add(x, y);
    }), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, this), aabbBounds;
  }
  findFace() {
    const { points } = this.attribute, kList = points.map((p, i) => {
      const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;
      return 0 === dx ? 0 : (p.y - p1.y) / dx;
    }), pointsMap = points.map((p) => ({
      p,
      d: 0
    }));
    let find = false, maxD = 0;
    for (let i = 0; i < kList.length - 1; i++) {
      for (let j = i + 1; j < kList.length; j++) {
        if (kList[i] === kList[j]) {
          find = true;
          const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
          pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
          const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
          pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
        }
        if (find) break;
      }
      if (find) break;
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      pointsMap.unshift({
        p,
        d: 0
      });
    }
    for (let i = 0; i < points.length; i++) {
      const delta = (maxD - pointsMap[i + points.length].d) / 2;
      pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
    }
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    };
    return pointsMap.forEach((p) => {
      faces.vertices.push([p.p.x, p.p.y, p.d]);
    }), faces.polygons.push({
      polygon: [0, 4, 5, 1],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [7, 6, 2, 3],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [0, 4, 7, 3],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 5, 6, 2],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return _Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
};
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPyramid3d(attributes) {
  return new Pyramid3d(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/shadow-root.js
var ShadowRoot = class extends Group {
  constructor(graphic) {
    super({
      x: 0,
      y: 0
    }), this.type = "shadowroot", this.shadowHost = graphic;
  }
  clearUpdateBoundTag() {
    super.clearUpdateBoundTag(), this.shadowHost && this.shadowHost.clearUpdateBoundTag();
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      const m3 = this.transMatrix;
      this._globalTransMatrix ? this._globalTransMatrix.setValue(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f) : this._globalTransMatrix = m3.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const parentMatrix = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
  }
};
function createShadowRoot(graphic) {
  return new ShadowRoot(graphic);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic-creator.js
var GraphicCreator2 = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params2) {
    const cb = this.store.get(name);
    return cb ? cb(params2) : null;
  }
};
var graphicCreator = new GraphicCreator2();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/bounds.js
var text;
function getTextBounds(params2) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params2), text.AABBBounds;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-contribution-render.js
var __decorate8 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata6 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultBaseBackgroundRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    const { background, backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity, opacity = graphicAttribute.opacity, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY, backgroundClip = graphicAttribute.backgroundClip } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
      }
      backgroundClip && context.clip();
      const b = graphic.AABBBounds;
      context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio,
        backgroundScale,
        backgroundOffsetX,
        backgroundOffsetY
      }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b, params2) {
    const { backgroundMode, backgroundFit, backgroundKeepAspectRatio, backgroundScale = 1, backgroundOffsetX = 0, backgroundOffsetY = 0 } = params2, targetW = b.width(), targetH = b.height();
    let w = targetW, h = targetH;
    if ("no-repeat" === backgroundMode) if (backgroundFit) if (backgroundKeepAspectRatio) {
      const maxScale = Math.max(targetW / data.width, targetH / data.height);
      context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
    } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
    else {
      const resW = data.width * backgroundScale, resH = data.height * backgroundScale;
      context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
    }
    else {
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width, resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w = resW * (targetH / resH), h = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h = resH * (targetW / resW), w = targetW;
        }
        const dpr2 = context.dpr, canvas = canvasAllocate.allocate({
          width: w,
          height: h,
          dpr: dpr2
        }), ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr, pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
    }
  }
};
var defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
var DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach((c2) => {
      c2.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate8([injectable(), __param4(0, inject(ContributionProvider)), __param4(0, named(InteractiveSubRenderContribution)), __metadata6("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
var DefaultBaseClipRenderBeforeContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    const { clipConfig } = graphic.attribute;
    if (!clipConfig) return;
    const clipPath = graphic.getClipPath();
    if (!clipPath) return;
    const draw = !(fillCb || strokeCb), b = graphic.AABBBounds, width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(), height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
    draw && context.save(), context.beginPath(), false === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, true), draw && context.clip();
  }
};
var defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
var DefaultBaseClipRenderAfterContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const { clipConfig } = graphic.attribute;
    if (!clipConfig) return;
    graphic.getClipPath() && (fillCb || strokeCb || context.restore());
  }
};
var defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-texture-contribution-render.js
function formatRatio(ratio) {
  return ratio <= 0.5 ? 4 * ratio - 1 : -4 * ratio + 3;
}
function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
  const { fill = "orange", percent = 0.6, frequency = 4, opacity, phi = 0 } = textureOptions;
  let { amplitude = 10 } = textureOptions;
  amplitude *= formatRatio(ratio);
  const height = boundsHeight * (1 - percent), width = boundsWidth, step = Math.max(Math.round(width / 70), 2);
  ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
  const delta = width / frequency * ratio, c2 = width / Math.PI / (2 * frequency);
  for (let i = 0; i < width; i += step) {
    const y = amplitude * Math.sin((i + delta + phi) / c2 + phi);
    ctx.lineTo(i + offsetX, height + y + offsetY);
  }
  ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
}
var DefaultBaseTextureRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 10, this._tempSymbolGraphic = null;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r = (size - 2 * padding) / 2, dpr = targetContext.dpr, canvas = canvasAllocate.allocate({
      width: size,
      height: size,
      dpr
    }), ctx = canvas.getContext("2d");
    if (!ctx) return null;
    ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, size, size), cb(r, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = size / 2, y = x;
      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding;
      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const y = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2, dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2, dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = /* @__PURE__ */ new Map();
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
    var _a;
    const { textureRatio = graphicAttribute.textureRatio, textureOptions = null } = graphic.attribute;
    let pattern = this.textureMap.get(texture);
    if (!pattern) switch (texture) {
      case "circle":
        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "diamond":
        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "rect":
        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "vertical-line":
        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "horizontal-line":
        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-lr":
        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-rl":
        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "grid":
        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
    }
    if (textureOptions && textureOptions.dynamicTexture) {
      const { gridConfig = {}, useNewCanvas } = textureOptions, b = graphic.AABBBounds;
      x = b.x1, y = b.y1;
      const originalContext = context;
      let newCanvas;
      if (useNewCanvas) {
        newCanvas = canvasAllocate.allocate({
          width: b.width(),
          height: b.height(),
          dpr: context.dpr
        });
        const ctx = newCanvas.getContext("2d");
        ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
      }
      if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
        originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, true);
      }
      originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
      const width = b.width(), height = b.height(), padding = texturePadding, cellSize = textureSize, gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize), gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize), gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding, gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
      this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
      const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize, sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
      this._tempSymbolGraphic.setAttributes({
        size: [sizeW - gutterColumn, sizeH - gutterRow],
        symbolType: texture
      });
      const parsedPath = this._tempSymbolGraphic.getParsedPath();
      for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
        const _x = x + cellSize / 2 + j * cellSize, _y = y + cellSize / 2 + i * cellSize;
        null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), false === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
      }
      useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
    } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();
    else if ("wave" === texture) {
      context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
      const b = graphic.AABBBounds;
      drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
        fill: textureColor
      }), x + b.x1 - x, y + b.y1 - y), context.restore();
    }
  }
};
var defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/arc-contribution-render.js
var DefaultArcRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = arc.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { innerPadding = arcAttribute.innerPadding, outerPadding = arcAttribute.outerPadding, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, x: originX = arcAttribute.x, y: originY = arcAttribute.y, scaleX = arcAttribute.scaleX, scaleY = arcAttribute.scaleY, keepStrokeScale = arcAttribute.keepStrokeScale } = arc.attribute;
    let { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance = arcAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr), deltaAngle = distance / outerRadius, sign2 = "outerBorder" === key ? 1 : -1;
      if (arc.setAttributes({
        outerRadius: outerRadius + sign2 * d,
        innerRadius: innerRadius - sign2 * d,
        startAngle: startAngle - sign2 * deltaAngle,
        endAngle: endAngle + sign2 * deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius + sign2 * d, innerRadius - sign2 * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = arcAttribute[key].opacity;
        arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
      outerRadius,
      innerRadius,
      startAngle,
      endAngle
    });
  }
};
var defaultArcRenderContribution = new DefaultArcRenderContribution();
var defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/circle-contribution-render.js
var DefaultCircleRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(circle2, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = circle2.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, x: originX = circleAttribute.x, y: originY = circleAttribute.y, scaleX = circleAttribute.scaleX, scaleY = circleAttribute.scaleY, keepStrokeScale = circleAttribute.keepStrokeScale } = circle2.attribute, renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance = circleAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr), sign2 = "outerBorder" === key ? 1 : -1;
      if (context.beginPath(), context.arc(x, y, radius + sign2 * d, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle2, circle2.attribute, circleAttribute), strokeCb) strokeCb(context, borderStyle, circleAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = circleAttribute[key].opacity;
        circleAttribute[key].opacity = opacity, context.setStrokeStyle(circle2, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]), circleAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var defaultCircleRenderContribution = new DefaultCircleRenderContribution();
var defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/group-contribution-render.js
var DefaultGroupBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
      const b = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio,
        backgroundScale,
        backgroundOffsetX,
        backgroundOffsetY
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
};
var defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/shape/rect.js
var halfPi2 = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius, roundCorner = true, edgeCb) {
  let cornerRadius;
  if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = true), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber_default(rectCornerRadius, true)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];
  else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])], leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]], leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]], rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]], rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]], rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]], rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]], leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]], leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
    if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
      edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
      const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];
      path.arc(centerX, centerY, _cornerRadius[1], -halfPi2, 0, false);
    }
    if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
      const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];
      edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi2, false);
    }
    if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
      const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];
      edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi2, pi, false);
    }
    if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
      const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];
      edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi2, false);
    }
  } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
  return !edgeCb && path.closePath(), path;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/rect-contribution-render.js
var __decorate9 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultRectRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = rect.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, x: originX = rectAttribute.x, y: originY = rectAttribute.y, scaleX = rectAttribute.scaleX, scaleY = rectAttribute.scaleY, x1, y1, keepStrokeScale = rectAttribute.keepStrokeScale } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
    const renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), sign2 = "outerBorder" === key ? -1 : 1, { distance = rectAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr), nextX = x + sign2 * d, nextY = y + sign2 * d, dw = 2 * d;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign2 * dw, height - sign2 * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign2 * dw, height - sign2 * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = rectAttribute[key].opacity;
        rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = groupAttribute.stroke } = group.attribute;
    Array.isArray(stroke2) && stroke2.some((s2) => false === s2) && (doFillOrStroke.doStroke = false);
  }
};
SplitRectBeforeRenderContribution = __decorate9([injectable()], SplitRectBeforeRenderContribution);
var SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const { x1, y1, x: originX = groupAttribute.x, y: originY = groupAttribute.y, stroke: stroke2 = groupAttribute.stroke, cornerRadius = groupAttribute.cornerRadius, cornerType = groupAttribute.cornerType } = rect.attribute;
    let { width, height } = rect.attribute;
    if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke2) && stroke2.some((s2) => false === s2)) {
      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num))) {
        let lastStroke, lastStrokeI = 0;
        return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x12, y12, x2, y2) => {
          stroke2[i] && (lastStrokeI === i - 1 && stroke2[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
            stroke: stroke2[i]
          }), x, y, groupAttribute), context.beginPath(), context.moveTo(x12, y12), lastStroke = stroke2[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
        })), void context.stroke();
      }
      if (context.beginPath(), context.moveTo(x, y), stroke2[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke2[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke2[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke2[3]) {
        const adjustY = stroke2[0] ? y - context.lineWidth / 2 : y;
        context.lineTo(x, adjustY);
      } else context.moveTo(x, y);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate9([injectable()], SplitRectAfterRenderContribution);
var defaultRectRenderContribution = new DefaultRectRenderContribution();
var defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/image-contribution-render.js
var DefaultImageRenderContribution = class extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
};
var defaultImageRenderContribution = new DefaultImageRenderContribution();
var defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/symbol-contribution-render.js
var DefaultSymbolRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { outerBorder, innerBorder } = symbol.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, keepStrokeScale = symbolAttribute.keepStrokeScale } = symbol.attribute, renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance = symbolAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr), sign2 = "outerBorder" === key ? 1 : -1;
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x, y, sign2 * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = symbolAttribute[key].opacity;
        symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var DefaultSymbolClipRangeStrokeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const { clipRange = graphicAttribute.clipRange, x: originX = graphicAttribute.x, y: originY = graphicAttribute.y, z = graphicAttribute.z, size = graphicAttribute.size, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY } = graphic.attribute, parsedPath = graphic.getParsedPath();
    if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
    context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a2) => {
      var _a, _b, _c, _d;
      if (graphic._parsedPath.svgCache) {
        const obj2 = Object.assign({}, a2);
        obj2.fill = null !== (_a = a2.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj2.opacity = null !== (_b = a2.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj2.fillOpacity = graphic.attribute.fillOpacity, obj2.stroke = null !== (_c = a2.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj2.lineWidth = null !== (_d = a2.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a2 = obj2;
      }
      a2.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a2, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
    }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
  }
};
var defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
var defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
var defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/star-contribution-render.js
var defaultStarTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultStarBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-texture-contribution-render.js
var DefaultAreaTextureRenderContribution = class extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { attribute = graphic.attribute } = options || {}, { texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"), textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"), textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"), texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding") } = attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/base-render.js
var result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
var BaseRender = class {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach((item) => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a2, b) => b.order - a2.order), this._beforeRenderContribitions = this._renderContribitions.filter((c2) => c2.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter((c2) => c2.time === BaseRenderContributionTime.afterFillStroke));
  }
  reInit() {
    this.init(this.graphicRenderContributions);
  }
  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach((c2) => {
      if (c2.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c2.supportedAppName) ? c2.supportedAppName : [c2.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c2.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach((c2) => {
      if (c2.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c2.supportedAppName) ? c2.supportedAppName : [c2.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c2.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  drawPathProxy(graphic, context, x, y, drawContext, params2, fillCb, strokeCb) {
    if (!graphic.pathProxy) return false;
    const themeAttributes = getTheme(graphic, null == params2 ? void 0 : params2.theme)[graphic.type.replace("3d", "")], { fill = themeAttributes.fill, stroke: stroke2 = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible, x: originX = themeAttributes.x, y: originY = themeAttributes.y } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!visible) return true;
    if (!doFill && !doStroke) return true;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return true;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), true;
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const { fill = defaultAttribute.fill, background, stroke: stroke2 = defaultAttribute.stroke, opacity = defaultAttribute.opacity, fillOpacity = defaultAttribute.fillOpacity, lineWidth = defaultAttribute.lineWidth, strokeOpacity = defaultAttribute.strokeOpacity, visible = defaultAttribute.visible } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    return !(!graphic.valid || !visible) && (!(!doFill && !doStroke) && (!!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible,
      sVisible,
      doFill,
      doStroke
    }));
  }
  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
    const { x = graphicAttribute.x, y = graphicAttribute.y, z = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle: angle2 = graphicAttribute.angle, postMatrix } = graphic.attribute, lastModelMatrix = context.modelMatrix, camera = context.camera;
    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)), onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle2 && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, true), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point5 = graphic.getOffsetXY(graphicAttribute);
      result.x += point5.x, result.y += point5.y, result.z = z, context.setTransformForCurrent();
    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, true);
    else if (camera && context.project) {
      const point5 = graphic.getOffsetXY(graphicAttribute);
      result.x += point5.x, result.y += point5.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle2);
    } else context.transformFromMatrix(graphic.transMatrix, true), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z), p2 = context.project(width, 0, z), p3 = context.project(width, height, z), _p1 = {
        x: 0,
        y: 0
      }, _p2 = {
        x: width,
        y: 0
      }, _p3 = {
        x: width,
        y: height
      };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, true);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle2) {
    const p = context.project(x, y, z);
    context.translate(p.x, p.y, false), context.scale(scaleX, scaleY, false), context.rotate(angle2, false), context.translate(-p.x, -p.y, false), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const { renderable } = graphic.attribute;
    if (false === renderable) return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params2) || (this.drawShape(graphic, context, x, y, drawContext, params2), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/arc-render.js
var __decorate10 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata7 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, limitedIcr, innerDeltaAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
      else {
        const a1 = endAngle - capAngle - 0.03, a2 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) context.lineTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11), a2 = endAngle - capAngle - 0.03;
        context.arc(cx, cy, innerRadius, a1, a2, clockwise);
      }
    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, x: originX = arcAttribute.x, y: originY = arcAttribute.y, fillStrokeOrder = arcAttribute.fillStrokeOrder } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean_default(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const { sc, startAngle, endAngle } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = false;
    const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke2);
    if (doFill || isFullStroke) {
      context.beginPath(), drawArcPath(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = true, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
      const _runFill = () => {
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
      }, _runStroke = () => {
        doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()));
      };
      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
    }
    if (!isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
    }
    if ((isBoolean_default(cap) && cap || cap[1]) && forceShowCap) {
      const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, { endAngle = arcAttribute.endAngle, fill: fill2 = arcAttribute.fill } = arc.attribute, startAngle = endAngle;
        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
          if (doFill) {
            const color = fill2;
            if ("conical" === color.gradient) {
              const lastColor = getConicGradientAt(0, 0, endAngle, color);
              fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
            }
          }
        }, _runStroke = () => {
          doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
        };
        _runFill(), _runStroke();
      }
    }
    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArcRender = __decorate10([injectable(), __param5(0, inject(ContributionProvider)), __param5(0, named(ArcRenderContribution)), __metadata7("design:paramtypes", [Object])], DefaultCanvasArcRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/circle-render.js
var __decorate11 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata8 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCircleRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(circle2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle2, null == params2 ? void 0 : params2.theme).circle, { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, x: originX = circleAttribute.x, y: originY = circleAttribute.y, fillStrokeOrder = circleAttribute.fillStrokeOrder } = circle2.attribute, data = this.valid(circle2, circleAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle2, circle2.attribute, circleAttribute), this.beforeRenderStep(circle2, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, circle2.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle2, circle2.attribute, originX - x, originY - y, circleAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, circle2.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle2, circle2.attribute, originX - x, originY - y, circleAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(circle2, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle2, renderService, drawContext, params2) {
    const circleAttribute = getTheme(circle2, null == params2 ? void 0 : params2.theme).circle;
    this._draw(circle2, circleAttribute, false, drawContext, params2);
  }
};
DefaultCanvasCircleRender = __decorate11([injectable(), __param6(0, inject(ContributionProvider)), __param6(0, named(CircleRenderContribution)), __metadata8("design:paramtypes", [Object])], DefaultCanvasCircleRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/render-utils.js
function drawSegItem(ctx, curve, endPercent, params2) {
  if (!curve.p1) return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
  else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
  }
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/render-curve.js
function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
  var _a;
  let p0 = curve.p0, newDefined0 = defined0;
  if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);
  else {
    const { originP1, originP2 } = curve;
    let validP;
    if (originP1 && false !== originP1.defined && !lastCurve ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
      newDefined0 = !defined0;
      const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
      path.moveTo(x + offsetX, y + offsetY, offsetZ);
    } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
  }
  return newDefined0;
}
function drawSegments(path, segPath, percent, clipRangeByDimension, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode = "none", drawConnect = false } = params2 || {};
  if (drawConnect && "none" === mode) return;
  if (!segPath) return;
  let needMoveTo = true;
  const { curves } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve2, defined02 = true;
      curves.forEach((curve, i) => {
        curve.originP1 !== curve.originP2 ? (defined02 = drawEachCurve(path, curve, lastCurve2, defined02, offsetX, offsetY, offsetZ), lastCurve2 = curve) : lastCurve2 = curve;
      });
    } else curves.forEach((curve) => {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
    });
    return;
  }
  if (percent <= 0) return;
  let direction;
  "x" === clipRangeByDimension ? direction = Direction.ROW : "y" === clipRangeByDimension ? direction = Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction);
  let drawedLengthUntilLast = 0, defined0 = true, lastCurve = null;
  for (let i = 0, n = curves.length; i < n; i++) {
    const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
    if (drawConnect) {
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = true;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params2), needMoveTo = false;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments2.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments2.points.forEach((p) => {
    false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, { points } = segments2, definedPointsList = [];
  let lastIdx = 0;
  for (let i = 0; i < points.length; i++) false === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), lastIdx = i);
  definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach((points2, i) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points2[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points2.forEach((p) => {
      false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
    for (let i2 = points2.length - 1; i2 >= 0; i2--) {
      const p = points2[i2];
      path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/line-render.js
var __decorate12 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line, renderService, drawContext, params2) {
    const lineAttribute = getTheme(line, null == params2 ? void 0 : params2.theme).line;
    this._draw(line, lineAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
    var _a;
    if (!cache) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY,
      offsetZ: z
    }), line.cache && !isArray_default(line.cache) && line.cache.curves.every((c2) => c2.defined) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    return false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), false;
  }
  drawLinearLineHighPerformance(line, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { points } = line.attribute, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
    const { x: originX = 0, x: originY = 0 } = line.attribute;
    false !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const lineAttribute = getTheme(line, null == params2 ? void 0 : params2.theme).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, segments: segments2, points, closePath, curveTension = lineAttribute.curveTension, connectedType = lineAttribute.connectedType } = line.attribute;
    if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
    let { curveType = lineAttribute.curveType } = line.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line.attribute;
    if (1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke2, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params2, fillCb, strokeCb);
    function parsePoint(points2, connectedType2) {
      return "none" === connectedType2 ? points2 : points2.filter((p) => false !== p.defined);
    }
    if (line.shouldUpdateShape()) {
      const { points: points2, segments: segments3 } = line.attribute, _points = points2;
      if (segments3 && segments3.length) {
        let startPoint, lastSeg;
        if (line.cache = segments3.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y,
            curves: [{
              defined: false !== seg.points[0].defined
            }]
          }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint,
            curveTension
          });
          return lastSeg = data, data;
        }).filter((item) => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i = 0; i < line.cache.length; i++) {
            const cacheItem = line.cache[i];
            for (let i2 = 0; i2 < cacheItem.curves.length; i2++) if (cacheItem.curves[i2].defined) {
              startP = cacheItem.curves[i2].p0;
              break;
            }
            if (startP) break;
          }
          line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, true);
        }
      } else {
        if (!points2 || !points2.length) return line.cache = null, void line.clearUpdateShapeTag();
        line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
          curveTension
        });
      }
      line.clearUpdateShapeTag();
    }
    if (Array.isArray(line.cache)) {
      const segments3 = line.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        line.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      } else {
        const totalLength = line.cache.reduce((l, c2) => l + c2.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        line.cache.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate12([injectable()], DefaultCanvasLineRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/render-area.js
function drawAreaSegments(path, segPath, percent, params2) {
  var _a;
  const { top, bottom } = segPath;
  if (top.curves.length !== bottom.curves.length) return;
  if (percent >= 1) {
    const topList2 = [], bottomList2 = [];
    let lastDefined2 = true;
    for (let i = 0, n = top.curves.length; i < n; i++) {
      const topCurve = top.curves[i];
      lastDefined2 !== topCurve.defined ? (lastDefined2 ? (drawAreaBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0) : (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1])), lastDefined2 = !lastDefined2) : lastDefined2 && (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1]));
    }
    return void drawAreaBlock(path, topList2, bottomList2, params2);
  }
  if (percent <= 0) return;
  let { direction } = params2 || {};
  const { curves: topCurves } = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = abs(endP.x - topCurves[0].p0.x), yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction = null != direction ? direction : xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN, Number.isFinite(xTotalLength) || (direction = Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = Direction.ROW);
  const totalDrawLength = percent * (direction === Direction.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0, lastDefined = true;
  const topList = [], bottomList = [];
  for (let i = 0, n = top.curves.length; i < n; i++) {
    const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction), percent2 = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent2 < 0) break;
    drawedLengthUntilLast += curCurveLength;
    let tc = null, bc = null;
    lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent2 < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent2)[0] : divideLinear(tc, percent2)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent2)[1] : divideLinear(bc, 1 - percent2)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
  }
  drawAreaBlock(path, topList, bottomList, params2);
}
function drawAreaBlock(path, topList, bottomList, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  let needMoveTo = true;
  topList.forEach((curve) => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }), needMoveTo = true;
  for (let i = bottomList.length - 1; i >= 0; i--) {
    const curve = bottomList[i];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }
  path.closePath();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-contribution-render.js
var defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
var defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/area-render.js
var __decorate13 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata9 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawLinearAreaHighPerformance(area, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const { points } = area.attribute;
    if (points.length < 2) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    });
    const { x: originX = 0, x: originY = 0 } = area.attribute;
    false !== fill && (fillCb ? fillCb(context, area.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    }), (() => {
      var _a2, _b2;
      if (stroke2) {
        const { stroke: stroke3 = areaAttribute && areaAttribute.stroke } = area.attribute;
        if (isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1]) {
          if (context.beginPath(), stroke3[0]) {
            context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
            for (let i = 1; i < points.length; i++) {
              const p = points[i];
              context.lineTo(p.x + offsetX, p.y + offsetY, z);
            }
          } else if (stroke3[2]) {
            const endP = points[points.length - 1];
            context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
            for (let i = points.length - 2; i >= 0; i--) {
              const p = points[i];
              context.lineTo((null !== (_a2 = p.x1) && void 0 !== _a2 ? _a2 : p.x) + offsetX, (null !== (_b2 = p.y1) && void 0 !== _b2 ? _b2 : p.y) + offsetY, z);
            }
          }
        }
        strokeCb ? strokeCb(context, area.attribute, areaAttribute) : (context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
      }
    })();
  }
  drawShape(area, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area, null == params2 ? void 0 : params2.theme).area, { fill = areaAttribute.fill, stroke: stroke2 = areaAttribute.stroke, fillOpacity = areaAttribute.fillOpacity, z = areaAttribute.z, strokeOpacity = areaAttribute.strokeOpacity, curveTension = areaAttribute.curveTension, connectedType = areaAttribute.connectedType } = area.attribute, data = this.valid(area, areaAttribute, fillCb, strokeCb);
    if (!data) return;
    const { doFill } = data, doStroke = data.doStroke && data.sVisible, { clipRange = areaAttribute.clipRange, closePath, points, segments: segments2 } = area.attribute;
    let { curveType = areaAttribute.curveType } = area.attribute;
    function parsePoint(points2, connectedType2) {
      return "connect" !== connectedType2 ? points2 : points2.filter((p) => false !== p.defined);
    }
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params2, fillCb, strokeCb);
    if (area.shouldUpdateShape()) {
      if (segments2 && segments2.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments2.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y
          }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data2 = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint,
            curveTension
          });
          return lastTopSeg = data2, data2;
        }).filter((item) => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i = segments2.length - 1; i >= 0; i--) {
          const points2 = segments2[i].points, bottomPoints = [];
          for (let i2 = points2.length - 1; i2 >= 0; i2--) bottomPoints.push({
            x: null !== (_a = points2[i2].x1) && void 0 !== _a ? _a : points2[i2].x,
            y: null !== (_b = points2[i2].y1) && void 0 !== _b ? _b : points2[i2].y
          });
          if (0 !== i) {
            const lastSegmentPoints = segments2[i - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension
          }), bottomCaches.unshift(lastBottomSeg));
        }
        area.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length) return area.cacheArea = null, void area.clearUpdateShapeTag();
        {
          const topPoints = parsePoint(points, connectedType), bottomPoints = [];
          for (let i = topPoints.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_e = topPoints[i].x1) && void 0 !== _e ? _e : topPoints[i].x,
            y: null !== (_f = topPoints[i].y1) && void 0 !== _f ? _f : topPoints[i].y
          });
          const topCache = calcLineCache(topPoints, curveType, {
            curveTension
          }), bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension
          });
          area.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area.clearUpdateShapeTag();
    }
    if (Array.isArray(area.cacheArea)) {
      const segments3 = area.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        area.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area.cacheArea.reduce((l, c2) => l + c2.top.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        area.cacheArea.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
  }
  draw(area, renderService, drawContext, params2) {
    const areaAttribute = getTheme(area, null == params2 ? void 0 : params2.theme).area;
    this._draw(area, areaAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb);
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
    context.beginPath();
    const { points, segments: segments2 } = area.attribute;
    let endP, startP, direction = Direction.ROW;
    if (segments2) {
      const endSeg = segments2[segments2.length - 1];
      startP = segments2[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else startP = points[0], endP = points[points.length - 1];
    const xTotalLength = abs(endP.x - startP.x), yTotalLength = abs(endP.y - startP.y);
    direction = null == endP.x1 ? Direction.ROW : null == endP.y1 ? Direction.COLUMN : Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN : Direction.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
      offsetX,
      offsetY,
      offsetZ,
      direction
    }), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    return false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), (() => {
      if (false !== stroke2) if (strokeCb) strokeCb(context, attribute, defaultAttribute);
      else {
        const { stroke: stroke3 = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;
        isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke3[0] ? cache.top : cache.bottom, clipRange, direction === Direction.ROW ? "x" : "y", {
          offsetX,
          offsetY,
          offsetZ
        })), context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke();
      }
    })(), false;
  }
};
DefaultCanvasAreaRender = __decorate13([injectable(), __param7(0, inject(ContributionProvider)), __param7(0, named(AreaRenderContribution)), __metadata9("design:paramtypes", [Object])], DefaultCanvasAreaRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/path-contribution-render.js
var defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/path-render.js
var __decorate14 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata10 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(path, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params2 ? void 0 : params2.theme).path, { x: originX = pathAttribute.x, y: originY = pathAttribute.y, fillStrokeOrder = pathAttribute.fillStrokeOrder } = path.attribute, z = null !== (_b = this.z) && void 0 !== _b ? _b : 0, data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);
    else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
    const _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke()));
    }, _runFill = () => {
      doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params2) {
    const pathAttribute = getTheme(path, null == params2 ? void 0 : params2.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate14([injectable(), __param8(0, inject(ContributionProvider)), __param8(0, named(PathRenderContribution)), __metadata10("design:paramtypes", [Object])], DefaultCanvasPathRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/rect-render.js
var __decorate15 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata11 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, background, stroke: stroke2 = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x1, y1, x: originX = rectAttribute.x, y: originY = rectAttribute.y, fillStrokeOrder = rectAttribute.fillStrokeOrder } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    const _runFill = () => {
      doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
    }, _runStroke = () => {
      doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  draw(rect, renderService, drawContext, params2) {
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect;
    this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasRectRender = __decorate15([injectable(), __param9(0, inject(ContributionProvider)), __param9(0, named(RectRenderContribution)), __metadata11("design:paramtypes", [Object])], DefaultCanvasRectRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-render.js
var __decorate16 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata12 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(symbol, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol, { size = symbolAttribute.size, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, fillStrokeOrder = symbolAttribute.fillStrokeOrder, clipRange = symbolAttribute.clipRange } = symbol.attribute, data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    context.beginPath();
    let _size = size, _x = x, _y = y, _z = z;
    const camera = context.camera;
    if (keepDirIn3d && camera && context.project) {
      const p = context.project(x, y, z);
      context.camera = null, _size = isArray_default(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
    }
    false === parsedPath.draw(context, size, _x, _y, _z, (p, a2) => {
      var _a2, _b, _c, _d;
      if (symbol._parsedPath.svgCache) {
        const obj2 = Object.assign({}, a2);
        obj2.fill = null !== (_a2 = a2.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj2.opacity = null !== (_b = a2.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj2.fillOpacity = symbol.attribute.fillOpacity, obj2.stroke = null !== (_c = a2.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj2.lineWidth = null !== (_d = a2.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a2 = obj2;
      }
      const _runFill2 = () => {
        a2.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a2, originX - x, originY - y, symbolAttribute), context.fill()));
      }, _runStroke2 = () => {
        a2.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a2, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
      };
      fillStrokeOrder ? (_runStroke2(), _runFill2()) : (_runFill2(), _runStroke2());
    }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  draw(symbol, renderService, drawContext, params2) {
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol;
    this._draw(symbol, symbolAttribute, false, drawContext, params2);
  }
};
DefaultCanvasSymbolRender = __decorate16([injectable(), __param10(0, inject(ContributionProvider)), __param10(0, named(SymbolRenderContribution)), __metadata12("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/allocator/bounds-allocate.js
var BoundsAllocate = Symbol.for("BoundsAllocate");
var DefaultBoundsAllocate = class {
  constructor() {
    this.pools = [];
    for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds());
  }
  allocate(x1, y1, x2, y2) {
    if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
    const b = this.pools.pop();
    return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
  }
  allocateByObj(b) {
    if (!this.pools.length) return new AABBBounds(b);
    const _b = this.pools.pop();
    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
  }
  free(b) {
    this.pools.push(b);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var boundsAllocate = new DefaultBoundsAllocate();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/text-contribution-render.js
var DefaultTextBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio } = graphic.attribute;
    let matrix, { background } = graphic.attribute;
    if (!background) return;
    const restore = () => {
      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, true, 1));
    };
    let b;
    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
    const shouldReCalBounds = isObject_default(background) && background.background, onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds, x2 = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0), y2 = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0), w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(), h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b = boundsAllocate.allocate(x2, y2, x2 + w, y2 + h), background = background.background, !onlyTranslate) {
        const w2 = b.width(), h2 = b.height();
        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w2, h2);
      }
    } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
      angle: 0,
      scaleX: 1,
      scaleY: 1,
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    })).clone());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return void restore();
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else {
      const { backgroundCornerRadius } = graphic.attribute;
      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, true), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
    }
    shouldReCalBounds && boundsAllocate.free(b), restore();
  }
};
var defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/text-render.js
var __decorate17 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata13 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(text2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { text: str2, underline = textAttribute.underline, lineThrough = textAttribute.lineThrough, keepDirIn3d = textAttribute.keepDirIn3d, direction = textAttribute.direction, fontSize = textAttribute.fontSize, verticalMode = textAttribute.verticalMode, x: originX = textAttribute.x, y: originY = textAttribute.y } = text2.attribute, lineHeight = null !== (_a = calculateLineHeight(text2.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize, data = this.valid(text2, textAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, transform3dMatrixToContextMatrix = !keepDirIn3d, z = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text2, text2.attribute, textAttribute), this.beforeRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text2, textAttribute, z, context);
    const drawText = (t, offsetX, offsetY, direction2) => {
      let _x = x + offsetX;
      const _y = y + offsetY;
      if (direction2) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, true), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z))), direction2 && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute, z), "horizontal" === direction) {
      const { multilineLayout } = text2;
      if (!multilineLayout) return void context.highPerformanceRestore();
      const { xOffset, yOffset } = multilineLayout.bbox;
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach((line) => {
        context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
      }))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach((line) => {
        context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text2, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
          width: line.width
        });
      })));
    } else {
      let { textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline } = text2.attribute;
      if (!verticalMode) {
        const t = textAlign;
        textAlign = null !== (_b = text2.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text2.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
      }
      text2.tryUpdateAABBBounds();
      const cache = text2.cache, { verticalList } = cache;
      context.textAlign = "left", context.textBaseline = "top";
      const totalHeight = lineHeight * verticalList.length;
      let totalW = 0;
      verticalList.forEach((verticalData) => {
        const _w = verticalData.reduce((a2, b) => a2 + (b.width || 0), 0);
        totalW = max(_w, totalW);
      });
      let offsetY = 0, offsetX = 0;
      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
        const currentW = verticalData.reduce((a2, b) => a2 + (b.width || 0), 0), dw = totalW - currentW;
        let currentOffsetY = offsetY;
        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach((item) => {
          const { text: text3, width, direction: direction2 } = item;
          drawText(text3, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction2), currentOffsetY += width;
        });
      });
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text2, textAttribute, z, context), this.afterRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
  }
  draw(text2, renderService, drawContext, params2) {
    const textAttribute = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { keepDirIn3d = textAttribute.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d;
    this._draw(text2, textAttribute, computed3dMatrix, drawContext, params2);
  }
  drawUnderLine(underline, lineThrough, text2, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
    if (lineThrough + underline <= 0) return;
    const { textAlign = textAttribute.textAlign, fill = textAttribute.fill, opacity = textAttribute.opacity, underlineOffset = textAttribute.underlineOffset, underlineDash = textAttribute.underlineDash, fillOpacity = textAttribute.fillOpacity } = text2.attribute, isMulti = !isNil_default(multiOption), w = isMulti ? multiOption.width : text2.clipedWidth, offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, anchorX, anchorY, textAttribute), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = anchorY + offsetUnderLineY + underlineOffset;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, anchorX, anchorY, textAttribute), context.beginPath();
      const dy = anchorY + offsetThroughLineY;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate17([injectable(), __param11(0, inject(ContributionProvider)), __param11(0, named(TextRenderContribution)), __metadata13("design:paramtypes", [Object])], DefaultCanvasTextRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/graphic-render.js
var __decorate18 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AbstractGraphicRender = class {
};
AbstractGraphicRender = __decorate18([injectable()], AbstractGraphicRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/polygon.js
function drawPolygon(path, points, x, y) {
  path.moveTo(points[0].x + x, points[0].y + y);
  for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
}
function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = true) {
  var _a;
  if (points.length < 3) return void drawPolygon(path, points, x, y);
  let startI = 0, endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
  for (let i = startI; i <= endI; i++) {
    const p1 = points[0 === i ? endI : (i - 1) % points.length], angularPoint = points[i % points.length], p2 = points[(i + 1) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle2 = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan = Math.abs(Math.tan(angle2));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan;
    const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length3 = Math.min(length1, length2);
    segment > length3 && (segment = length3, radius = length3 * tan);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L = getLength(dx, dy), circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
  }
  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point5, segment, length2, dx, dy) {
  const factor = segment / length2;
  return {
    x: point5.x - dx * factor,
    y: point5.y - dy * factor
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/polygon-contribution-render.js
var defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-render.js
var __decorate19 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata14 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(polygon, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon, { points = polygonAttribute.points, cornerRadius = polygonAttribute.cornerRadius, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y, closePath = polygonAttribute.closePath, fillStrokeOrder = polygonAttribute.fillStrokeOrder } = polygon.attribute, data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), cornerRadius <= 0 || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params2) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon;
    this._draw(polygon, polygonAttribute, false, drawContext, params2);
  }
};
DefaultCanvasPolygonRender = __decorate19([injectable(), __param12(0, inject(ContributionProvider)), __param12(0, named(PolygonRenderContribution)), __metadata14("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/group-render.js
var __decorate20 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata15 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  reInit() {
    this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution);
  }
  drawShape(group, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, { fill = groupAttribute.fill, background, stroke: stroke2 = groupAttribute.stroke, opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, clip = groupAttribute.clip, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible, fillStrokeOrder = groupAttribute.fillStrokeOrder, cornerType = groupAttribute.cornerType, x: originX = groupAttribute.x, y: originY = groupAttribute.y } = group.attribute, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!group.valid || !visible) return;
    if (!clip) {
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;
      context.disableFill = true, context.disableStroke = true, context.disableBeginPath = true, path.forEach((g) => {
        drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params2);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else 0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), this._groupRenderContribitions.forEach((c2) => {
      c2.time === BaseRenderContributionTime.beforeFillStroke && c2.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip();
    const _runFill = () => {
      doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.fill()));
    }, _runStroke = () => {
      doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this._groupRenderContribitions.forEach((c2) => {
      c2.time === BaseRenderContributionTime.afterFillStroke && c2.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const { clip, baseOpacity = 1, drawMode, x, y, width, height } = group.attribute, lastNativeContext = context.nativeContext, lastNativeCanvas = context.canvas.nativeCanvas;
    if (drawMode > 0) {
      const canvas = context.canvas, newCanvas = vglobal.createCanvas({
        width: canvas.width,
        height: canvas.height,
        dpr: 1
      }), newContext = newCanvas.getContext("2d"), transform = context.nativeContext.getTransform();
      newContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), 1 === drawMode && (newContext.save(), newContext.clearRect(0, 0, canvas.width, canvas.height), newContext.beginPath(), newContext.rect(x, y, width, height), newContext.clip(), newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight), newContext.restore()), context.nativeContext = newContext, canvas.nativeCanvas = newCanvas;
    }
    clip ? context.save() : context.highPerformanceSave();
    const baseGlobalAlpha = context.baseGlobalAlpha;
    context.baseGlobalAlpha *= baseOpacity;
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, true);
    } else context.transformFromMatrix(group.transMatrix, true);
    context.beginPath(), params2.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params2, () => false, () => false) : this.drawShape(group, context, 0, 0, drawContext);
    const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = group.attribute;
    let p;
    if ((scrollX || scrollY) && context.translate(scrollX, scrollY), params2 && params2.drawingCb && (p = params2.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha = baseGlobalAlpha, drawMode > 0) {
      const newContext = context.nativeContext, newCanvas = context.canvas.nativeCanvas;
      lastNativeContext.save(), lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, true), 1 === drawMode && newContext.rect(x, y, width, height), lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
      const transform = newContext.getTransform();
      lastNativeContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), context.nativeContext = lastNativeContext, context.canvas.nativeCanvas = lastNativeCanvas, lastNativeContext.restore();
    }
    p && p.then ? p.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate20([injectable(), __param13(0, inject(ContributionProvider)), __param13(0, named(GroupRenderContribution)), __metadata15("design:paramtypes", [Object])], DefaultCanvasGroupRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/image-render.js
var __decorate21 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata16 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
var DefaultCanvasImageRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(image, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image, { repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, x: originX = imageAttribute.x, y: originY = imageAttribute.y, cornerRadius = imageAttribute.cornerRadius, fillStrokeOrder = imageAttribute.fillStrokeOrder, cornerType = imageAttribute.cornerType, image: url } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("success" !== res.state) return;
    const width = image.width, height = image.height;
    context.beginPath();
    let needRestore = false;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = true), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
    const _runFill = () => {
      if (doFill) {
        if (fillCb) fillCb(context, image.attribute, imageAttribute);
        else if (fVisible) {
          context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
          let repeat = 0;
          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
            const pattern = context.createPattern(res.data, repeatStr[repeat]);
            context.fillStyle = pattern, context.translate(x, y, true), context.fillRect(0, 0, width, height), context.translate(-x, -y, true);
          } else context.drawImage(res.data, x, y, width, height);
        }
      }
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { image: url } = image.attribute;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("loading" === res.state && isString_default(url)) return void ResourceLoader.improveImageLoading(url);
    if ("success" !== res.state) return;
    const { context } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasImageRender = __decorate21([injectable(), __param14(0, inject(ContributionProvider)), __param14(0, named(ImageRenderContribution)), __metadata16("design:paramtypes", [Object])], DefaultCanvasImageRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/symbol.js
var IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
var ArcRender = Symbol.for("ArcRender");
var Arc3dRender = Symbol.for("Arc3dRender");
var AreaRender = Symbol.for("AreaRender");
var CircleRender = Symbol.for("CircleRender");
var GraphicRender = Symbol.for("GraphicRender");
var GroupRender = Symbol.for("GroupRender");
var LineRender = Symbol.for("LineRender");
var PathRender = Symbol.for("PathRender");
var PolygonRender = Symbol.for("PolygonRender");
var RectRender = Symbol.for("RectRender");
var Rect3DRender = Symbol.for("Rect3DRender");
var SymbolRender = Symbol.for("SymbolRender");
var TextRender = Symbol.for("TextRender");
var RichTextRender = Symbol.for("RichTextRender");
var Pyramid3dRender = Symbol.for("Pyramid3dRender");
var GlyphRender = Symbol.for("GlyphRender");
var ImageRender = Symbol.for("ImageRender");
var RenderSelector = Symbol.for("RenderSelector");
var DrawContribution = Symbol.for("DrawContribution");
var StarRender = Symbol.for("StarRender");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/3d-interceptor.js
var draw3dItem = (context, graphic, callback, output) => {
  let result2, isPie = false, is3d = false;
  if (graphic.forEachChildren((c2) => (isPie = c2.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c2) => (is3d = !!c2.findFace, !is3d)), isPie) {
    const children = graphic.getChildren(), sortedChildren = [...children];
    sortedChildren.sort((a2, b) => {
      var _a, _b, _c, _d;
      let angle1 = (null !== (_b = null !== (_a = a2.attribute.startAngle) && void 0 !== _a ? _a : 0 + a2.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
      for (; angle1 < 0; ) angle1 += pi2;
      for (; angle2 < 0; ) angle2 += pi2;
      return angle2 - angle1;
    }), sortedChildren.forEach((c2) => {
      c2._next = null, c2._prev = null;
    }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c2) => {
      graphic.appendChild(c2);
    }), output.hack_pieFace = "outside", result2 = callback(isPie, is3d), result2 && result2.graphic || (output.hack_pieFace = "inside", result2 = callback(isPie, is3d)), result2 && result2.graphic || (output.hack_pieFace = "top", result2 = callback(isPie, is3d)), graphic.removeAllChild(), children.forEach((c2) => {
      c2._next = null, c2._prev = null;
    }), children.forEach((c2) => {
      graphic.appendChild(c2);
    });
  } else if (is3d) {
    const children = graphic.getChildren(), zChildren = children.map((g) => ({
      ave_z: g.findFace().vertices.map((v) => {
        var _a;
        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
      }).reduce((a2, b) => a2 + b, 0),
      g
    }));
    zChildren.sort((a2, b) => b.ave_z - a2.ave_z), graphic.removeAllChild(), zChildren.forEach((i) => {
      i.g._next = null, i.g._prev = null;
    }), graphic.update(), zChildren.forEach((i) => {
      graphic.add(i.g);
    }), result2 = callback(isPie, is3d), graphic.removeAllChild(), children.forEach((g) => {
      g._next = null, g._prev = null;
    }), graphic.update(), children.forEach((g) => {
      graphic.add(g);
    });
  } else result2 = callback(isPie, is3d);
  return result2;
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/draw-interceptor.js
var __decorate22 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata17 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
var tempDirtyBounds = new AABBBounds();
var tempBackupDirtyBounds = new AABBBounds();
var ShadowRootDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0 || (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0 || (graphic.attribute.shadowRootIdx < 0 || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.shadowRoot) return false;
    const { context } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, true), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds), tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
      const m3 = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m3), drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && (drawContribution.dirtyBounds.copy(tempDirtyBounds), drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds)), true;
  }
};
var DebugDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.attribute._debug_bounds) return false;
    const { context } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
    const b = graphic.AABBBounds;
    return true !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), true;
  }
};
var CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return false;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
};
CommonDrawItemInterceptorContribution = __decorate22([injectable(), __metadata17("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
var InteractiveDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, false, {
        skipUpdateCallback: true
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return true;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return false;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    const baseGraphic = graphic.baseGraphic;
    let intree = !!baseGraphic.stage, _g = baseGraphic.parent;
    for (; intree && _g && _g.stage !== _g; ) intree = !!_g.stage, _g = _g.parent;
    if (!intree) {
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(graphic);
      }
      return true;
    }
    if (baseGraphic) {
      this.processing = true;
      const { context } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, true), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = false, true;
    }
    return false;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
};
var Canvas3DDrawItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor) return false;
    drawContext.in3dInterceptor = true;
    const { context, stage } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m3 = context.currentMatrix;
    m3.a /= context.dpr, m3.b /= context.dpr, m3.c /= context.dpr, m3.d /= context.dpr, m3.e /= context.dpr, m3.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m3);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m4 = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m4, lastModelMatrix, matrix);
      }
    } else context.modelMatrix = matrix;
    return context.setTransform(1, 0, 0, 1, 0, 0, true), graphic.isContainer ? draw3dItem(context, graphic, (isPie, is3d) => drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d), drawContext) : drawContribution.renderItem(graphic, drawContext), context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = false, true;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/render-service.js
var __decorate23 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata18 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenderService = Symbol.for("RenderService");
var BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");
var DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach((g) => {
      this._prepare(g, updateBounds);
    });
  }
  _prepare(g, updateBounds) {
    g.forEachChildren((g2) => {
      this._prepare(g2, updateBounds);
    }), g.update({
      bounds: updateBounds,
      trans: true
    });
  }
  prepareRenderList() {
  }
  beforeDraw(params2) {
  }
  draw(params2) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params2) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  reInit() {
    this.drawContribution.reInit();
  }
  render(groups, params2) {
    this.renderTreeRoots = groups, this.drawParams = params2;
    const updateBounds = params2.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params2), this.draw(params2), this.afterDraw(params2), this.drawParams = null;
  }
};
DefaultRenderService = __decorate23([injectable(), __param15(0, inject(DrawContribution)), __metadata18("design:paramtypes", [Object])], DefaultRenderService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/render-modules.js
var render_modules_default = new ContainerModule((bind) => {
  bind(RenderService).to(DefaultRenderService);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/picker/constants.js
var GraphicPicker = Symbol.for("GraphicPicker");
var PickerService = Symbol.for("PickerService");
var BoundsPicker = Symbol.for("BoundsPicker");
var GlobalPickerService = Symbol.for("GlobalPickerService");
var PickItemInterceptor = Symbol.for("PickItemInterceptor");
var PickServiceInterceptor = Symbol.for("PickServiceInterceptor");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/picker/pick-interceptor.js
var __decorate24 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ShadowPickServiceInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(result2, pickerService, point5, pickParams, params2) {
    if (result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; ) g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
};
ShadowPickServiceInterceptorContribution = __decorate24([injectable()], ShadowPickServiceInterceptorContribution);
var ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point5, pickParams, params2) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point5, pickParams, params2) : null;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point5, pickParams, params2) : null;
  }
  _pickItem(graphic, pickerService, point5, pickParams, params2) {
    var _a;
    if (!graphic.shadowRoot) return null;
    const { parentMatrix } = params2 || {};
    if (!parentMatrix) return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const theme4 = null === (_a = getTheme(graphic)) || void 0 === _a ? void 0 : _a[graphic.type], { shadowPickMode = null == theme4 ? void 0 : theme4.shadowPickMode } = graphic.attribute, g = graphic.shadowRoot, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(currentGroupMatrix.a * point5.x + currentGroupMatrix.c * point5.y + currentGroupMatrix.e, currentGroupMatrix.b * point5.x + currentGroupMatrix.d * point5.y + currentGroupMatrix.f), result2 = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), !result2.graphic && result2.group && "full" === shadowPickMode && (result2.graphic = result2.group), result2;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate24([injectable()], ShadowRootPickItemInterceptorContribution);
var InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point5.x, point5.y), context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result2 = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result2;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate24([injectable()], InteractivePickItemInterceptorContribution);
var Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
    const context = pickerService.pickContext, stage = graphic.stage;
    if (!context || !stage) return null;
    if (pickParams.in3dInterceptor = true, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      const result2 = draw3dItem(context, graphic, () => pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams), pickParams);
      return context.camera = null, pickParams.in3dInterceptor = false, context.restore(), result2;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate24([injectable()], Canvas3DPickItemInterceptor);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/picker/pick-modules.js
var pick_modules_default = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor), bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope(), bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution), bindContributionProvider(bind, PickServiceInterceptor);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-module.js
var graphic_module_default = new ContainerModule((bind) => {
  bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator).toConstantValue(graphicCreator);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/constants.js
var AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
var PluginService = Symbol.for("PluginService");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/plugin-service.js
var __decorate25 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata19 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = false;
  }
  active(stage, params2) {
    this.stage = stage, this.actived = true;
    const { pluginList } = params2;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach((p) => {
      pluginList.includes(p.name) && this.register(p);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release(...params2) {
    this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate25([injectable(), __param16(0, inject(ContributionProvider)), __param16(0, named(AutoEnablePlugins)), __metadata19("design:paramtypes", [Object])], DefaultPluginService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/plugin-modules.js
var plugin_modules_default = new ContainerModule((bind) => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/env/modules.js
var modules_default = new ContainerModule((bind) => {
  bindContributionProvider(bind, EnvContribution);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/modules.js
var modules_default2 = new ContainerModule((bind) => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/canvas2d-contribution.js
var __decorate26 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata20 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = false, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main) this.main = true, this.context = window2.getContext(), this.canvas = this.context.getCanvas();
    else {
      let nativeCanvas;
      this.main = false, params2.canvasId && (nativeCanvas = this.global.getElementById(params2.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window2.width,
        height: window2.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window2.getContext().getCanvas().nativeCanvas, canvas = wrapCanvas({
        nativeCanvas,
        width: window2.width,
        height: window2.height,
        dpr: window2.dpr,
        id: params2.canvasId,
        canvasControled: true,
        container: window2.getContainer(),
        x: windowCanvas.offsetLeft,
        y: windowCanvas.offsetTop
      });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {
  }
  render(group, params2, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }, params2), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach((l) => {
      const canvas = l.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate26([injectable(), __metadata20("design:paramtypes", [])], CanvasLayerHandlerContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/modules.js
var modules_default3 = new ContainerModule((bind) => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/modules.js
function load(container2) {
  container2.load(modules_default), container2.load(modules_default2), container2.load(modules_default3);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/sort.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parseChildMap(graphic, defaultZIndex, reverse) {
  const childMap = {}, zIdxArray = [];
  return graphic.forEachChildren((item) => {
    const { zIndex = defaultZIndex } = item.attribute;
    childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
  }, reverse), zIdxArray.sort((a2, b) => reverse ? b - a2 : a2 - b), {
    childMap,
    zIdxArray
  };
}
function foreach(graphic, defaultZIndex, cb, reverse = false, sort3d = false) {
  let needSort = false;
  if (sort3d) needSort = true;
  else {
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
      const { zIndex = defaultZIndex } = item.attribute;
      if (0 === i) lastZIndex = zIndex;
      else if (lastZIndex !== zIndex) return needSort = true, true;
      return false;
    }, reverse);
  }
  if (needSort) {
    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      sort3d && children.sort((a2, b) => {
        var _a, _b;
        return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a2.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i2 = 0; i2 < children.length; i2++) if (cb(children[i2], i2)) {
        skip = true;
        break;
      }
    }
  } else graphic.forEachChildren(cb, reverse);
}
function foreachAsync(graphic, defaultZIndex, cb, reverse = false) {
  return __awaiter3(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse);
  });
}
function findNextGraphic(graphic, id, defaultZIndex, reverse = false) {
  let needSort = false;
  graphic.forEachChildren((item, i) => {
    const { zIndex = defaultZIndex } = item.attribute;
    if (0 === i) ;
    else if (void 0 !== zIndex) return needSort = true, true;
    return false;
  }, reverse);
  let result2 = null, next = false;
  if (needSort) {
    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      for (let i2 = 0; i2 < children.length; i2++) {
        if (next) {
          skip = true, result2 = children[i2];
          break;
        }
        children[i2]._uid !== id || (next = true);
      }
    }
  } else graphic.forEachChildren((item) => next ? (result2 = item, true) : (item._uid === id && (next = true), false), reverse);
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/draw-contribution.js
var __decorate27 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata21 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = /* @__PURE__ */ new Map(), this.defaultRenderMap = /* @__PURE__ */ new Map(), this.styleRenderMap = /* @__PURE__ */ new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, isArray_default(this.contributions) || (this.contributions = [this.contributions]), this.init();
  }
  reInit() {
    this.init(), this.contributions.forEach((item) => {
      item.reInit();
    });
  }
  init() {
    this.contributions.forEach((item) => {
      if (item.style) {
        const map2 = this.styleRenderMap.get(item.style) || /* @__PURE__ */ new Map();
        map2.set(item.numberType, item), this.styleRenderMap.set(item.style, map2);
      } else this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a2, b) => a2.order - b.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = true : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const { context, stage, viewBox, transMatrix } = drawContext;
    if (!context) return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
      dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
    }
    const d = context.dpr % 1;
    (d || 0.5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = true, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(true), context.translate(viewBox.x1, viewBox.y1, true), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a2, b) => {
      var _a, _b;
      return (null !== (_a = a2.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = false, context.draw();
  }
  doRegister() {
    throw new Error("暂不支持");
  }
  _findNextGraphic(group) {
    let parent = group.parent, id = group._uid;
    for (; parent; ) {
      const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
      if (g) return g;
      id = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || false === group.attribute.visibleAll) return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = true, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, false) && "empty" !== group.attribute.boundsMode) return;
    let tempBounds3, nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds3 = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    this.renderItem(group, drawContext, {
      drawingCb: () => {
        var _a;
        skipSort ? group.forEachChildren((item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }) : foreach(group, DefaultAttribute.zIndex, (item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }, false, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
      }
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds3), boundsAllocate.free(tempBounds3), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const { layer, stage } = drawContext, { subLayers } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: false
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);
    else {
      let afterLayer = subLayers.get(nextGraphic._uid);
      afterLayer || (afterLayer = {
        layer: this.layerService.createLayer(stage),
        zIndex: subLayers.size
      }, subLayers.set(nextGraphic._uid, afterLayer));
      const afterContext = afterLayer.layer.getNativeHandler().getContext();
      this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
        drawContribution: idc,
        clear: "transparent",
        layer: afterLayer.layer,
        context: afterContext,
        startAtId: nextGraphic._uid,
        break: false
      }));
    }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params2) {
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params2)) return;
    }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer) return;
    let tempBounds3, retrans = this.scrollMatrix && (0 !== this.scrollMatrix.e || 0 !== this.scrollMatrix.f);
    if (graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      (scrollX || scrollY) && (retrans = true, this.scrollMatrix || (this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), this.scrollMatrix.translate(-scrollX, -scrollY));
    }
    if (retrans && (tempBounds3 = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix)), this.useDirtyBounds && !graphic.isContainer && "empty" !== graphic.attribute.boundsMode && !isRectIntersect(graphic.AABBBounds, null != tempBounds3 ? tempBounds3 : this.dirtyBounds, false)) {
      if (retrans && graphic.parent) {
        const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
        this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
      }
      return;
    }
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params2 && (params2.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params2) : renderer.draw(graphic, this.currentRenderService, drawContext, params2), retrans && graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
    }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
  }
  selectRenderByNumberType(type, graphic) {
    let data;
    if (graphic.attribute.renderStyle) {
      const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
      data = currentRenderMap && currentRenderMap.get(type);
    }
    return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b;
    const { clear: clear2, viewBox } = drawContext, width = viewBox.width(), height = viewBox.height();
    if (clear2) {
      context.clearRect(0, 0, width, height);
      const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
      if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear2);
        res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
      } else context.fillStyle = createColor(context, clear2, {
        AABBBounds: {
          x1: 0,
          y1: 0,
          x2: 0 + width,
          y2: 0 + height
        }
      }, 0, 0), context.fillRect(0, 0, width, height);
    }
  }
  afterDraw(renderService, drawParams) {
  }
};
DefaultDrawContribution = __decorate27([injectable(), __param17(0, multiInject(GraphicRender)), __param17(1, inject(ContributionProvider)), __param17(1, named(DrawItemInterceptor)), __metadata21("design:paramtypes", [Array, Object])], DefaultDrawContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-line-render.js
var __decorate28 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line, context, x, y, drawContext, params2, fillCb, strokeCb) {
    if (line.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = line.attribute;
      if (startAtIdx > segments2.length) return;
      const lineAttribute = getTheme(line).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
      if (!line.valid || !visible) return;
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
      const { context: context2 } = drawContext;
      for (let i = startAtIdx; i < startAtIdx + length2; i++) this.drawIncreaseSegment(line, context2, segments2[i - 1], segments2[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
    } else super.drawShape(line, context, x, y, drawContext, params2, fillCb, strokeCb);
  }
  drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate28([injectable()], DefaultIncrementalCanvasLineRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-area-render.js
var __decorate29 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area, context, x, y, drawContext, params2, fillCb) {
    if (area.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = area.attribute;
      if (startAtIdx > segments2.length) return;
      const areaAttribute = getTheme(area).area, { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), doFill = runFill(fill);
      if (!area.valid || !visible) return;
      if (!doFill) return;
      if (!fVisible && !fillCb) return;
      for (let i = startAtIdx; i < startAtIdx + length2; i++) this.drawIncreaseSegment(area, context, segments2[i - 1], segments2[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
    } else super.drawShape(area, context, x, y, drawContext, params2, fillCb);
  }
  drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute), context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate29([injectable()], DefaultIncrementalCanvasAreaRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-draw-contribution.js
var STATUS2;
var __decorate30 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata22 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
!function(STATUS3) {
  STATUS3[STATUS3.NORMAL = 0] = "NORMAL", STATUS3[STATUS3.STOP = 1] = "STOP";
}(STATUS2 || (STATUS2 = {}));
var DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = false, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS2.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw) return;
      this.currentRenderService = renderService;
      const { context, viewBox } = drawContext;
      context && (context.inuse = true, context.clearMatrix(), context.setTransformForCurrent(true), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, true), context.save(), renderService.renderTreeRoots.sort((a2, b) => {
        var _a, _b;
        return (null !== (_a = a2.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach((group) => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = false, this.rendering = false;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering = true, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
            if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
              if (this.status === STATUS2.STOP) return true;
              if (item.isContainer) return false;
              if (i < this.currentIdx) return false;
              const frameTail = this.currFrameStartAt + group.incremental;
              return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
            }), resolve(false);
            else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {
                startAtIdx: graphic.incrementalAt,
                length: graphic.incremental
              }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();
              else this.renderItem(graphic, drawContext);
              resolve(false);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter4(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(false);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = false, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS2.STOP, yield new Promise((resolve) => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS2.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item) => "stopCb" !== item.name), resolve(false);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!drawContext.break && false !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = true)) : void (yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
            yield foreachAsync(group, DefaultAttribute.zIndex, (item) => __awaiter4(this, void 0, void 0, function* () {
              drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
            })), resolve(false);
          })
        });
      }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate30([injectable(), __param18(0, multiInject(GraphicRender)), __param18(1, inject(DefaultIncrementalCanvasLineRender)), __param18(2, inject(DefaultIncrementalCanvasAreaRender)), __param18(3, inject(ContributionProvider)), __param18(3, named(DrawItemInterceptor)), __metadata22("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/module.js
var module_default = new ContainerModule((bind) => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/modules.js
function load2(container2) {
  container2.load(module_default);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/modules.js
function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = true, container.load(core_modules_default), container.load(graphic_module_default), container.load(render_modules_default), container.load(pick_modules_default), container.load(plugin_modules_default), load(container), load2(container));
}
preLoadAllModule.__loaded = false, preLoadAllModule();
var vglobal = container.get(VGlobal);
application.global = vglobal;
var graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
var transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
var graphicService = container.get(GraphicService);
application.graphicService = graphicService;
var layerService = container.get(LayerService);
application.layerService = layerService;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/auto-render-plugin.js
var AutoRenderPlugin = class {
  constructor() {
    this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, this.handleChange), application.graphicService.hooks.onSetStage.tap(this.key, this.handleChange), application.graphicService.hooks.onRemove.tap(this.key, this.handleChange);
  }
  deactivate(context) {
    const filterByName = (taps) => taps.filter((item) => item.name !== this.key);
    application.graphicService.hooks.onAttributeUpdate.taps = filterByName(application.graphicService.hooks.onAttributeUpdate.taps), application.graphicService.hooks.onSetStage.taps = filterByName(application.graphicService.hooks.onSetStage.taps), application.graphicService.hooks.onRemove.taps = filterByName(application.graphicService.hooks.onRemove.taps);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/auto-refresh-plugin.js
var AutoRefreshPlugin = class {
  constructor() {
    this.name = "AutoRefreshPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, this.dpr = application.global.devicePixelRatio, this.refresh();
  }
  refresh() {
    this._refreshByMediaQuery() || this._refreshByRaf();
  }
  _refreshByRaf() {
    const raf = application.global.getRequestAnimationFrame();
    this.rafId = raf(() => {
      application.global.devicePixelRatio !== this.dpr && (this.dpr = application.global.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, true)), this.refresh();
    });
  }
  _refreshByMediaQuery() {
    try {
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`, updatePixelRatio = () => {
        window.devicePixelRatio !== this.dpr && (this.dpr = window.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, true));
      }, dom = matchMedia(mqString);
      dom && dom.addEventListener("change", updatePixelRatio), this.autoRefreshCbs || (this.autoRefreshCbs = []), this.autoRefreshCbs.push(() => {
        dom && dom.removeEventListener("change", updatePixelRatio);
      });
    } catch (err) {
      return false;
    }
    return true;
  }
  deactivate(context) {
    var _a;
    const craf = application.global.getCancelAnimationFrame();
    craf && this.rafId && craf(this.rafId), null === (_a = this.autoRefreshCbs) || void 0 === _a || _a.forEach((cb) => {
      cb();
    }), this.autoRefreshCbs = void 0;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/incremental-auto-render-plugin.js
var IncrementalAutoRenderPlugin = class {
  constructor() {
    this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
    }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
      group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = true, this.renderNextFrame(group));
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter((item) => item.name !== this.key);
  }
  renderNextFrame(group) {
    this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = true, application.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    const stage = this.pluginService.stage;
    this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group) => {
      const layer = group.layer;
      if (!layer || !group.layer.subLayers) return;
      const subLayer = group.layer.subLayers.get(group._uid);
      subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
        stage,
        layer,
        viewBox: stage.window.getViewBox(),
        transMatrix: stage.window.getViewBoxTransform(),
        clear: "transparent",
        renderService: stage.renderService,
        updateBounds: false,
        startAtId: group._uid,
        context: subLayer.layer.getNativeHandler().getContext()
      }, this.nextUserParams));
    }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/dirty-bounds-plugin.js
var globalBounds = new AABBBounds();
var DirtyBoundsPlugin = class {
  constructor() {
    this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params2.globalAABBBounds));
    }), application.graphicService.hooks.clearAABBBounds.tap(this.key, (graphic, stage, bounds) => {
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(bounds);
    }), application.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
      const stage = graphic.stage;
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.clearAABBBounds.taps = application.graphicService.hooks.clearAABBBounds.taps.filter((item) => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter((item) => item.name !== this.key);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/animate/default-ticker.js
var defaultTicker = new DefaultTicker();
defaultTicker.addTimeline(defaultTimeline);
defaultTicker.setFPS(60);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/env-check.js
var _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv) try {
    const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
    _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
  } catch (err) {
    _isBrowserEnv = false;
  }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}
function isNodeEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "node" === env : !_isBrowserEnv;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/factory.js
var Factory = class _Factory {
  static registerPlugin(pluginKey, pluginClass) {
    _Factory._pluginClasses[pluginKey] = pluginClass;
  }
  static getPlugin(pluginKey) {
    return _Factory._pluginClasses[pluginKey];
  }
};
Factory._pluginClasses = {};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/stage.js
var DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  X: 0,
  Y: 0,
  BACKGROUND: "white"
};
var Stage = class extends Group {
  set viewBox(b) {
    this.window.setViewBox(b);
  }
  get viewBox() {
    return this.window.getViewBox();
  }
  get x() {
    return this.window.getViewBox().x1;
  }
  set x(x) {
    const b = this.window.getViewBox();
    b.translate(x - b.x1, 0), this.window.setViewBox(b);
  }
  get y() {
    return this.window.getViewBox().y1;
  }
  set y(y) {
    const b = this.window.getViewBox();
    b.translate(0, y - b.y1), this.window.setViewBox(b);
  }
  get width() {
    return this.window.width;
  }
  set width(w) {
    this.resize(w, this.height);
  }
  get viewWidth() {
    return this.window.getViewBox().width();
  }
  set viewWidth(w) {
    this.resizeView(w, this.viewHeight);
  }
  get viewHeight() {
    return this.window.getViewBox().height();
  }
  set viewHeight(h) {
    this.resizeView(this.viewWidth, h);
  }
  get height() {
    return this.window.height;
  }
  set height(h) {
    this.resize(this.width, h);
  }
  get dpr() {
    return this.window.dpr;
  }
  set dpr(r) {
    this.setDpr(r);
  }
  get background() {
    var _a;
    return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
  }
  set background(b) {
    this._background = b;
  }
  get defaultLayer() {
    return this.at(0);
  }
  get eventSystem() {
    return this._eventSystem;
  }
  constructor(params2 = {}) {
    var _a;
    super({}), this.tickedBeforeRender = true, this._onVisibleChange = (visible) => {
      if (!(this._skipRender < 0)) if (visible) {
        if (this.dirtyBounds) {
          const b = this.window.getViewBox();
          this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
        }
        this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0;
      } else this._skipRender = 1;
    }, this.beforeRender = (stage) => {
      this._beforeRender && this._beforeRender(stage);
    }, this.afterRender = (stage) => {
      this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb) => cb(stage)), this._afterNextRenderCbs = null, this.tickedBeforeRender = false;
    }, this.afterTickCb = () => {
      var _a2;
      this.tickedBeforeRender = true, "performance" === (null === (_a2 = this.params.optimize) || void 0 === _a2 ? void 0 : _a2.tickRenderMode) || "rendering" !== this.state && this.render();
    }, this.params = params2, this.theme = new Theme(), this.hooks = {
      beforeRender: new SyncHook(["stage"]),
      afterRender: new SyncHook(["stage"])
    }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params2), this.window.create({
      width: params2.width,
      height: params2.height,
      viewBox: params2.viewBox,
      container: params2.container,
      dpr: params2.dpr || this.global.devicePixelRatio,
      canvasControled: false !== params2.canvasControled,
      title: params2.title || "",
      canvas: params2.canvas
    }), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._background = null !== (_a = params2.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
      main: true
    })), this.nextFrameRenderLayerSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.stage = this, this.renderStyle = params2.renderStyle, params2.autoRender && this.enableAutoRender(), params2.autoRefresh && this.enableAutoRefresh(), false === params2.disableDirtyBounds && this.enableDirtyBounds(), params2.enableHtmlAttribute && this.enableHtmlAttribute(params2.enableHtmlAttribute), params2.ReactDOM && this.enableReactAttribute(params2.ReactDOM), params2.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params2.beforeRender, this._afterRender = params2.afterRender, this.ticker = params2.ticker || defaultTicker, this.supportInteractiveLayer = false !== params2.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params2.optimize || (params2.optimize = {}), this.optmize(params2.optimize), params2.background && isString_default(this._background) && this._background.includes("/") && this.setAttributes({
      background: this._background
    }), this.ticker.on("afterTick", this.afterTickCb);
  }
  pauseRender(sr = -1) {
    this._skipRender = sr;
  }
  resumeRender() {
    this._skipRender = 0;
  }
  tryInitEventSystem() {
    this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
      targetElement: this.window,
      resolution: this.window.dpr || this.global.devicePixelRatio,
      rootNode: this,
      global: this.global,
      supportsPointerEvents: this.params.supportsPointerEvents,
      supportsTouchEvents: this.params.supportsTouchEvents
    }, this.params.event)));
  }
  preventRender(prevent) {
    prevent ? this._skipRender = -1 / 0 : false !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
  }
  optmize(params2) {
    this.optmizeRender(params2.skipRenderWithOutRange), this.params.optimize = params2;
  }
  optmizeRender(skipRenderWithOutRange = false) {
    skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
  }
  getTimeline() {
    return this.timeline;
  }
  get3dOptions(options) {
    const { center = {
      x: this.width / 2,
      y: this.height / 2,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0
    }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
    return Object.assign(Object.assign({}, options), {
      center,
      light,
      alpha,
      beta,
      camera,
      fieldRatio,
      fieldDepth
    });
  }
  set3dOptions(options) {
    var _a, _b, _d, _e, _f, _g;
    this.option3d = options;
    const options3d = this.get3dOptions(options), { light, center, camera, alpha, beta, fieldRatio, fieldDepth } = options3d, { dir = [1, 1, -1], color = "white", ambient } = light, centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_d = center.y) && void 0 !== _d ? _d : this.height / 2) + (null !== (_e = center.dy) && void 0 !== _e ? _e : 0), centerVec3 = [centerX, centerY, (null !== (_f = center.z) && void 0 !== _f ? _f : 0) + (null !== (_g = center.dz) && void 0 !== _g ? _g : 0)];
    let cameraX = 0, cameraY = 0, cameraZ = 0;
    camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1);
    const DirectionalLight2 = Factory.getPlugin("DirectionalLight");
    DirectionalLight2 && (this.light = new DirectionalLight2(dir, color, ambient));
    const cameraParams = {
      left: 0,
      right: this.width,
      top: 0,
      bottom: this.height,
      fieldRatio,
      fieldDepth,
      viewParams: {
        pos: [cameraX, cameraY, cameraZ],
        center: centerVec3,
        up: [0, 1, 0]
      }
    };
    if (this.camera) this.camera.params = cameraParams;
    else {
      const OrthoCamera2 = Factory.getPlugin("OrthoCamera");
      OrthoCamera2 && (this.camera = new OrthoCamera2(cameraParams));
    }
    options.enableView3dTransform && this.enableView3dTransform();
  }
  setBeforeRender(cb) {
    this._beforeRender = cb;
  }
  setAfterRender(cb) {
    this._afterRender = cb;
  }
  afterNextRender(cb) {
    this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
  }
  enableView3dTransform() {
    if (this.view3dTranform) return;
    this.view3dTranform = true;
    const ViewTransform3dPlugin = Factory.getPlugin("ViewTransform3dPlugin");
    ViewTransform3dPlugin && this.pluginService.register(new ViewTransform3dPlugin());
  }
  disableView3dTranform() {
    this.view3dTranform && (this.view3dTranform = false, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRender() {
    this.autoRender || (this.autoRender = true, this.pluginService.register(new AutoRenderPlugin()));
  }
  disableAutoRender() {
    this.autoRender && (this.autoRender = false, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRefresh() {
    this.autoRefresh || (this.autoRefresh = true, this.pluginService.register(new AutoRefreshPlugin()));
  }
  disableAutoRefresh() {
    this.autoRefresh && (this.autoRefresh = false, this.pluginService.findPluginsByName("AutoRefreshPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableIncrementalAutoRender() {
    this.increaseAutoRender || (this.increaseAutoRender = true, this.pluginService.register(new IncrementalAutoRenderPlugin()));
  }
  disableIncrementalAutoRender() {
    this.increaseAutoRender && (this.increaseAutoRender = false, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableDirtyBounds() {
    if (this.dirtyBounds) return;
    this.dirtyBounds = new Bounds();
    let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
    plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
  }
  disableDirtyBounds() {
    this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableLayout() {
    if (this._enableLayout) return;
    this._enableLayout = true;
    const FlexLayoutPlugin2 = Factory.getPlugin("FlexLayoutPlugin");
    FlexLayoutPlugin2 && this.pluginService.register(new FlexLayoutPlugin2());
  }
  disableLayout() {
    this._enableLayout && (this._enableLayout = false, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableHtmlAttribute(container2) {
    if (this.htmlAttribute) return;
    const HtmlAttributePlugin2 = Factory.getPlugin("HtmlAttributePlugin");
    HtmlAttributePlugin2 && (this.htmlAttribute = container2, this.pluginService.register(new HtmlAttributePlugin2()));
  }
  disableHtmlAttribute() {
    this.htmlAttribute && (this.htmlAttribute = false, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableReactAttribute(container2) {
    if (this.reactAttribute) return;
    const ReactAttributePlugin = Factory.getPlugin("ReactAttributePlugin");
    ReactAttributePlugin && (this.reactAttribute = container2, this.pluginService.register(new ReactAttributePlugin()));
  }
  disableReactAttribute() {
    this.reactAttribute && (this.reactAttribute = false, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  getPluginsByName(name) {
    return this.pluginService.findPluginsByName(name);
  }
  tryUpdateAABBBounds() {
    const viewBox = this.window.getViewBox();
    return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
  }
  combineLayer(ILayer1, ILayer2) {
    throw new Error("暂不支持");
  }
  createLayer(canvasId, layerMode) {
    if ("released" === this.releaseStatus) return;
    const layer = this.layerService.createLayer(this, {
      main: false,
      layerMode,
      canvasId
    });
    return this.appendChild(layer), layer;
  }
  sortLayer(cb) {
    const children = this.children;
    children.sort(cb), this.removeAllChild(), children.forEach((c2) => {
      this.appendChild(c2);
    });
  }
  removeLayer(ILayerId) {
    return this.removeChild(this.findChildByUid(ILayerId));
  }
  tryInitInteractiveLayer() {
    "released" !== this.releaseStatus && this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = false, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
  }
  clearViewBox(color) {
    this.window.clearViewBox(color);
  }
  render(layers, params2) {
    if ("released" === this.releaseStatus) return;
    this.ticker.start(), this.timeline.resume();
    const state = this.state;
    this.state = "rendering", this.tickedBeforeRender || this.ticker.trySyncTickStatus(), this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params2, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  combineLayersToWindow() {
    if ("harmony" === this.global.env) {
      const ctx = this.window.getContext().nativeContext;
      this.forEachChildren((layer, i) => {
        if (i > 0) {
          const image = layer.getNativeHandler().getContext().canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
          ctx.transferFromImageBitmap(image);
        }
      });
    }
  }
  renderNextFrame(layers, force) {
    this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer) => {
      this.nextFrameRenderLayerSet.add(layer);
    }), this.willNextFrameRender || (this.willNextFrameRender = true, this.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    if ("released" === this.releaseStatus) return;
    this.timeline.resume(), this.ticker.start();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  renderLayerList(layerList, params2) {
    const list = [];
    for (let i = 0; i < layerList.length; i++) {
      let l = layerList[i];
      "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
    }
    list.forEach((layer) => {
      layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer === this.interactiveLayer && this.dirtyBounds && this.dirtyBounds.clear(), layer.render({
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
        viewBox: this.window.getViewBox(),
        transMatrix: this.window.getViewBoxTransform()
      }, Object.assign({
        renderStyle: this.renderStyle
      }, params2)));
    }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && (this.dirtyBounds && this.dirtyBounds.clear(), this.interactiveLayer.render({
      renderService: this.renderService,
      updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
      viewBox: this.window.getViewBox(),
      transMatrix: this.window.getViewBoxTransform()
    }, Object.assign({
      renderStyle: this.renderStyle
    }, params2)));
  }
  resizeWindow(w, h, rerender = true) {
    this.window.resize(w, h), rerender && this.render();
  }
  resize(w, h, rerender = true) {
    "released" !== this.releaseStatus && (this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren((c2) => {
      c2.resize(w, h);
    }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render());
  }
  resizeView(w, h, rerender = true) {
    "released" !== this.releaseStatus && (this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren((c2) => {
      c2.resizeView(w, h);
    }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
      right: this.width,
      bottom: this.height
    })), rerender && this.render());
  }
  setViewBox(x, y, w, h, rerender) {
    let isRerender = true;
    "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), false === y && (isRerender = false)) : (this.viewBox.setValue(x, y, x + w, y + h), false === rerender && (isRerender = false)), this.forEachChildren((c2) => {
      c2.resizeView(this.viewBox.width(), this.viewBox.height());
    }), isRerender && this.render();
  }
  setDpr(dpr, rerender = true) {
    this.forEachChildren((c2) => {
      c2.setDpr(dpr);
    }), rerender && this.render();
  }
  setOrigin(x, y) {
    throw new Error("暂不支持");
  }
  export(type) {
    throw new Error("暂不支持");
  }
  pick(x, y) {
    if ("released" === this.releaseStatus) return;
    const result2 = this.getPickerService().pick(this.children, new Point(x, y), {
      bounds: this.AABBBounds
    });
    return !(!(null == result2 ? void 0 : result2.graphic) && !(null == result2 ? void 0 : result2.group)) && result2;
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  release() {
    super.release(), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach((layer) => {
      layer.release();
    }), this.interactiveLayer && (this.interactiveLayer.forEachChildren((item) => {
      item.setStage && item.setStage(null, null), this.interactiveLayer.removeChild(item);
    }), this.interactiveLayer.release()), this.window.release(), this.ticker.remTimeline(this.timeline), this.ticker.removeListener("afterTick", this.afterTickCb), this.renderService.renderTreeRoots = [];
  }
  setStage(stage) {
  }
  dirty(b, matrix) {
    "released" !== this.releaseStatus && (matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b));
  }
  getLayer(name) {
    return this.children.filter((layer) => layer.name === name)[0];
  }
  renderTo(window2) {
    "released" !== this.releaseStatus && this.forEachChildren((layer, i) => {
      layer.drawTo(window2, {
        renderService: this.renderService,
        viewBox: window2.getViewBox(),
        transMatrix: window2.getViewBoxTransform(),
        background: layer === this.defaultLayer ? this.background : void 0,
        clear: 0 === i,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      });
    });
  }
  renderToNewWindow(fullImage = true, viewBox) {
    if ("released" === this.releaseStatus) return;
    const window2 = container.get(VWindow), x1 = viewBox ? -viewBox.x1 : 0, y1 = viewBox ? -viewBox.y1 : 0, x2 = viewBox ? viewBox.x2 : this.viewWidth, y2 = viewBox ? viewBox.y2 : this.viewHeight, width = viewBox ? viewBox.width() : this.viewWidth, height = viewBox ? viewBox.height() : this.viewHeight;
    return window2.create({
      viewBox: {
        x1,
        y1,
        x2,
        y2
      },
      width,
      height,
      dpr: this.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    }), this.renderTo(window2), window2;
  }
  toCanvas(fullImage = true, viewBox) {
    if ("released" === this.releaseStatus) return;
    const c2 = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
    return c2.nativeCanvas ? c2.nativeCanvas : null;
  }
  setCursor(mode) {
    this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
  }
  getCursor() {
    return this._cursor;
  }
  eventPointTransform(e) {
    const point5 = this.global.mapToCanvasPoint(e, this.window.getContext().canvas.nativeCanvas);
    return this.stage.window.pointTransform(point5.x, point5.y);
  }
  pauseTriggerEvent() {
    this._eventSystem && this._eventSystem.pauseTriggerEvent();
  }
  resumeTriggerEvent() {
    this._eventSystem && this._eventSystem.resumeTriggerEvent();
  }
  getPickerService() {
    return this.pickerService || (this.pickerService = container.get(PickerService)), this.pickerService;
  }
  reInit() {
    this.renderService.reInit(), this.pickerService.reInit();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/create.js
function createStage(params2) {
  return new Stage(params2);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/canvas/empty-context.js
var __decorate31 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata23 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
var globalPoint = {
  x: 0,
  y: 0
};
var EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    throw new Error("不支持getCanvas");
  }
  getContext() {
    throw new Error("不支持getContext");
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m3) {
    return matrixAllocate.allocateByObj(m3);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a2, b, c2, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a2, dpr * b, dpr * c2, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a2, b, c2, d, e, f, setTransform = true) {
    this.matrix.multiply(a2, b, c2, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.path.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  }
  lineTo(x, y) {
    this.path.lineTo(x, y);
  }
  moveTo(x, y) {
    this.path.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.path.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h) {
    this.path.rect(x, y, w, h);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    throw new Error("不支持createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("不支持createPattern");
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    throw new Error("不支持createRadialGradient");
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {
  }
  fillRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
  }
  fillText(text2, x, y) {
  }
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x, y) {
    return this.matrix.transformPoint({
      x,
      y
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x, y) {
    if (!this.lineWidth) return false;
    this.matrix.transformPoint({
      x,
      y
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text2) {
    throw new Error("不支持measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("不支持measureText");
  }
  setLineDash(segments2) {
  }
  stroke(path) {
  }
  strokeRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  strokeText(text2, x, y) {
  }
  drawImage() {
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setCommonStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setStrokeStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
  }
  setTextStyle(params2, defaultParams) {
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  setClearMatrix(a2, b, c2, d, e, f) {
    this._clearMatrix.setValue(a2, b, c2, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m3) => matrixAllocate.free(m3)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate31([injectable(), __metadata23("design:paramtypes", [Object, Number])], EmptyContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/canvas/contributions/base-canvas.js
var DefaultConfig2 = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1
};
var BaseCanvas = class {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(_x) {
    this._x = _x;
  }
  get y() {
    return this._y;
  }
  set y(_y) {
    this._y = _y;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  set nativeCanvas(nativeCanvas) {
    this._nativeCanvas = nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(width) {
    this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
  }
  get height() {
    return this._pixelHeight;
  }
  set height(height) {
    this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
  }
  getContext(str2) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(visiable) {
    this._visiable = visiable, visiable ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(dpr) {
    this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(params2) {
    var _a;
    const { nativeCanvas, width = DefaultConfig2.WIDTH, height = DefaultConfig2.HEIGHT, dpr = DefaultConfig2.DPR, x, y, id, canvasControled = true } = params2;
    this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = false !== params2.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id, id && (nativeCanvas.id = id), this.init(params2);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {
  }
  show() {
  }
  applyPosition() {
  }
  resetStyle(params2) {
  }
  resize(width, height) {
  }
  toDataURL(mimeType, quality) {
    return "";
  }
  readPixels(x, y, w, h) {
    return this._context.getImageData(x, y, w, h);
  }
  convertToBlob(options) {
    throw new Error("暂未实现");
  }
  transferToImageBitmap() {
    throw new Error("暂未实现");
  }
  release(...params2) {
    this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
};
BaseCanvas.env = "browser";

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/env/base-contribution.js
var __decorate32 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BaseEnvContribution = class {
  configure(service, ...p) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(dom) {
    return new AABBBounds();
  }
  removeDom(dom) {
    return false;
  }
  createDom(params2) {
    return null;
  }
  updateDom(dom, params2) {
    return false;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(str2) {
    return document.getElementById(str2);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadBlob(url) {
    return fetch(url).then((data) => data.blob()).then((blob) => ({
      data: blob,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  getElementTop(dom, baseWindow) {
    return 0;
  }
  getElementLeft(dom, baseWindow) {
    return 0;
  }
  getElementTopLeft(dom, baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter5(this, void 0, void 0, function* () {
      return {
        loadState: "fail"
      };
    });
  }
  isMacOS() {
    return false;
  }
  copyToClipBoard(text2) {
    return Promise.resolve(null);
  }
};
BaseEnvContribution = __decorate32([injectable()], BaseEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/contributions/window/base-contribution.js
var __decorate33 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata24 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BaseWindowHandlerContribution = class {
  constructor() {
    this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  onChange(cb) {
    this._onChangeCb = cb;
  }
  configure(window2, global2) {
    global2.env === this.type && window2.setWindowHandler(this);
  }
  release(...params2) {
    this.releaseWindow();
  }
  isVisible(bbox) {
    return true;
  }
  onVisibleChange(cb) {
  }
  getTopLeft(baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  setViewBox(vb) {
    this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
  }
  getViewBox() {
    return this.viewBox;
  }
  setViewBoxTransform(a2, b, c2, d, e, f) {
    this.modelMatrix.setValue(a2, b, c2, d, e, f);
  }
  getViewBoxTransform() {
    return this.modelMatrix;
  }
};
BaseWindowHandlerContribution = __decorate33([injectable(), __metadata24("design:paramtypes", [])], BaseWindowHandlerContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/light.js
var DirectionalLight = class {
  constructor(dir, color, ambient = 0.8) {
    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
    const length2 = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    this.formatedDir = [dir[0] / length2, dir[1] / length2, dir[2] / length2];
  }
  computeColor(normal, color) {
    const lightDir = this.formatedDir, brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
    let colorArray;
    colorArray = isString_default(color) ? ColorStore.Get(color, ColorType.Color1) : color;
    const lightColorArray = this.colorRgb;
    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
  }
};
var registerDirectionalLight = () => {
  Factory.registerPlugin("DirectionalLight", DirectionalLight);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/core/camera.js
var OrthoCamera = class {
  set params(params2) {
    this._params = Object.assign({}, params2), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
  }
  get params() {
    return Object.assign({}, this._params);
  }
  constructor(params2) {
    this.params = params2;
  }
  getViewMatrix() {
    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
  }
  forceGetViewMatrix() {
    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
    const { pos, center, up } = this.params.viewParams;
    return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
  }
  getProjectionMatrix() {
    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
  }
  forceGetProjectionMatrix() {
    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
    const { left, top, right, bottom } = this._params;
    return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
  }
  getField() {
    const { fieldRatio = 0.8, fieldDepth, left, right } = this._params;
    return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
  }
  getProjectionScale(z) {
    const field = this.getField();
    return field / (field + z);
  }
  view(x, y, z) {
    const outP2 = [0, 0, 0];
    return transformMat4(outP2, [x, y, z], this._viewMatrixCached), outP2;
  }
  vp(x, y, z) {
    const outP2 = [0, 0, 0], { pos } = this._params.viewParams;
    transformMat4(outP2, [x, y, z], this._viewMatrixCached), x = outP2[0], y = outP2[1], z = outP2[2];
    const sizeProjection = this.getProjectionScale(z);
    return {
      x: x * sizeProjection + pos[0],
      y: y * sizeProjection + pos[1]
    };
  }
};
var registerOrthoCamera = () => {
  Factory.registerPlugin("OrthoCamera", OrthoCamera);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/picker/picker-service.js
var __decorate34 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata25 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPickService = class {
  constructor(pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.type = "default", this.global = application.global;
  }
  reInit() {
    this._init();
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a2, b) => a2.order - b.order), this.pickerServiceInterceptorContributions = this.pickServiceInterceptorContributions.getContributions().sort((a2, b) => a2.order - b.order);
  }
  pick(graphics, point5, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    params2.pickerService = this;
    const w = params2.bounds.width(), h = params2.bounds.height();
    if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point5)) return result2;
    this.pickContext && (this.pickContext.inuse = true), params2.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(true, 1);
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = graphics.length - 1; i >= 0 && (result2 = graphics[i].isContainer ? this.pickGroup(graphics[i], point5, parentMatrix, params2) : this.pickItem(graphics[i], point5, parentMatrix, params2), !result2.graphic); i--) group || (group = result2.group);
    if (result2.graphic || (result2.group = group), this.pickContext && (this.pickContext.inuse = false), this.pickerServiceInterceptorContributions.length) for (let i = 0; i < this.pickerServiceInterceptorContributions.length; i++) {
      const drawContribution = this.pickerServiceInterceptorContributions[i];
      drawContribution.afterPickItem && (result2 = drawContribution.afterPickItem(result2, this, point5, params2, {
        parentMatrix
      }));
    }
    return result2;
  }
  containsPoint(graphic, point5, params2) {
    var _a;
    return !!(null === (_a = this.pickItem(graphic, point5, null, null != params2 ? params2 : {
      pickContext: this.pickContext,
      pickerService: this
    })) || void 0 === _a ? void 0 : _a.graphic);
  }
  pickGroup(group, point5, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const context = params2.pickContext, lastMatrix = context.modelMatrix;
    if (context.camera) {
      const m3 = group.transMatrix, matrix = mat4Allocate.allocate();
      if (mat3Tomat4(matrix, m3), lastMatrix) {
        if (matrix) {
          const m4 = mat4Allocate.allocate();
          context.modelMatrix = multiplyMat4Mat4(m4, lastMatrix, matrix), mat4Allocate.free(matrix);
        }
      } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const result3 = drawContribution.beforePickItem(group, this, point5, params2, {
          parentMatrix
        });
        if (result3) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result3;
      }
    }
    const transMatrix = group.transMatrix, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(point5.x, point5.y);
    currentGroupMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup && !group.stage.camera) return result2;
    const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params2);
    pickedItem && pickedItem.graphic && (result2.graphic = pickedItem.graphic, result2.params = pickedItem.params);
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, (graphic) => {
      if (graphic.isContainer) {
        const newPoint2 = new Point(point5.x, point5.y), theme4 = getTheme(group).group, { scrollX = theme4.scrollX, scrollY = theme4.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY, result2 = this.pickGroup(graphic, newPoint2, currentGroupMatrix, params2);
      } else {
        const newPoint2 = new Point(point5.x, point5.y);
        currentGroupMatrix.transformPoint(newPoint2, newPoint2);
        const theme4 = getTheme(group).group, { scrollX = theme4.scrollX, scrollY = theme4.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY;
        const pickedItem2 = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        pickedItem2 && pickedItem2.graphic && (result2.graphic = pickedItem2.graphic, result2.params = pickedItem2.params);
      }
      return !!result2.graphic || !!result2.group;
    }, true, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result2.graphic || result2.group || !groupPicked || group.stage.camera || (result2.group = group), matrixAllocate.free(currentGroupMatrix), result2;
  }
  selectPicker(graphic) {
    const picker = this.pickerMap.get(graphic.numberType);
    return picker || null;
  }
};
DefaultPickService = __decorate34([injectable(), __param19(0, inject(ContributionProvider)), __param19(0, named(PickItemInterceptor)), __param19(1, inject(ContributionProvider)), __param19(1, named(PickServiceInterceptor)), __metadata25("design:paramtypes", [Object, Object])], DefaultPickService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/picker/global-picker-service.js
var __decorate35 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata26 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultGlobalPickerService = class {
  constructor() {
    this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", (lastEnv, env, global2) => {
      this.configure(global2, env);
    }), this.configure(this.global, this.global.env);
  }
  reInit() {
  }
  configure(global2, env) {
  }
  pick(graphics, point5, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = 0; i < graphics.length; i++) {
      if (graphics[i].isContainer) result2 = this.pickGroup(graphics[i], point5, parentMatrix, params2);
      else {
        const data = this.pickItem(graphics[i], point5, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      if (result2.graphic) break;
      group || (group = result2.group);
    }
    if (result2.graphic || (result2.group = group), result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; ) g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point5, params2) {
    return !!this.pickItem(graphic, point5, null, params2);
  }
  pickGroup(group, point5, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const transMatrix = group.transMatrix, newPoint = new Point(point5.x, point5.y);
    parentMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup) return result2;
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false !== group.attribute.childrenPickable && group.forEachChildren((graphic) => {
      if (graphic.isContainer) result2 = this.pickGroup(graphic, point5, parentMatrix, params2);
      else {
        const newPoint2 = new Point(point5.x, point5.y);
        parentMatrix.transformPoint(newPoint2, newPoint2);
        const data = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      return !!result2.graphic || !!result2.group;
    }), result2.graphic || result2.group || !groupPicked || (result2.group = group), result2;
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    return false === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point5) ? {
      graphic
    } : null;
  }
};
DefaultGlobalPickerService = __decorate35([injectable(), __metadata26("design:paramtypes", [])], DefaultGlobalPickerService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/common/simplify.js
function simplifyRadialDist(points, sqTolerance) {
  let deltaX, deltaY, lastX = points[0].x, lastY = points[0].y;
  const newPoints = [points[0]];
  for (let i = 1, len = points.length; i < len; i++) deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
  return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
}
function flatten_simplify(points, tolerance, highestQuality) {
  if (points.length <= 10) return points;
  return points = highestQuality ? points : simplifyRadialDist(points, void 0 !== tolerance ? tolerance * tolerance : 1);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/allocator/graphic-allocate.js
var DefaultGraphicAllocate = class {
  constructor() {
    this.pools = [];
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultRectAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.rect(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(rect) {
    if (!this.pools.length) return application.graphicService.creator.rect(rect.attribute);
    const g = this.pools.pop();
    return g.initAttributes(rect.attribute), g;
  }
};
var defaultRectAllocate = new DefaultRectAllocate();
var DefaultArcAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.arc(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(arc) {
    if (!this.pools.length) return application.graphicService.creator.arc(arc.attribute);
    const g = this.pools.pop();
    return g.initAttributes(arc.attribute), g;
  }
};
var defaultArcAllocate = new DefaultArcAllocate();
var DefaultAreaAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.area(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area) {
    if (!this.pools.length) return application.graphicService.creator.area(area.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area.attribute), g;
  }
};
var defaultAreaAllocate = new DefaultAreaAllocate();
var DefaultCircleAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.circle(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area) {
    if (!this.pools.length) return application.graphicService.creator.circle(area.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area.attribute), g;
  }
};
var defaultCircleAllocate = new DefaultCircleAllocate();
var DefaultLineAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.line(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(line) {
    if (!this.pools.length) return application.graphicService.creator.line(line.attribute);
    const g = this.pools.pop();
    return g.initAttributes(line.attribute), g;
  }
};
var defaultLineAllocate = new DefaultLineAllocate();
var DefaultPathAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.path(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(path) {
    if (!this.pools.length) return application.graphicService.creator.path(path.attribute);
    const g = this.pools.pop();
    return g.initAttributes(path.attribute), g;
  }
};
var defaultPathAllocate = new DefaultPathAllocate();
var DefaultSymbolAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.symbol(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(symbol) {
    if (!this.pools.length) return application.graphicService.creator.symbol(symbol.attribute);
    const g = this.pools.pop();
    return g.initAttributes(symbol.attribute), g;
  }
};
var defaultSymbolAllocate = new DefaultSymbolAllocate();
var DefaultTextAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.text(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(text2) {
    if (!this.pools.length) return application.graphicService.creator.text(text2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(text2.attribute), g;
  }
};
var defaultTextAllocate = new DefaultTextAllocate();
var DefaultGraphicMemoryManager = class {
  constructor() {
    this.map = {
      text: defaultTextAllocate,
      symbol: defaultSymbolAllocate
    };
  }
  gc(g) {
    g.isContainer ? g.forEachChildren((i) => this.gc(i)) : this.gcItem(g);
  }
  gcItem(g) {
    const allocate = this.map[g.type];
    allocate && allocate.free(g);
  }
};
var defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/arc-module.js
var loadArcModule = false;
var arcModule = new ContainerModule((bind) => {
  loadArcModule || (loadArcModule = true, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/rect-module.js
var loadRectModule = false;
var rectModule = new ContainerModule((bind) => {
  loadRectModule || (loadRectModule = true, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/line-module.js
var loadLineModule = false;
var lineModule = new ContainerModule((bind) => {
  loadLineModule || (loadLineModule = true, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/area-module.js
var loadAreaModule = false;
var areaModule = new ContainerModule((bind) => {
  loadAreaModule || (loadAreaModule = true, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-module.js
var loadSymbolModule = false;
var symbolModule = new ContainerModule((bind) => {
  loadSymbolModule || (loadSymbolModule = true, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/circle-module.js
var loadCircleModule = false;
var circleModule = new ContainerModule((bind) => {
  loadCircleModule || (loadCircleModule = true, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/text-module.js
var loadTextModule = false;
var textModule = new ContainerModule((bind) => {
  loadTextModule || (loadTextModule = true, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/path-module.js
var loadPathModule = false;
var pathModule = new ContainerModule((bind) => {
  loadPathModule || (loadPathModule = true, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-module.js
var loadPolygonModule = false;
var polygonModule = new ContainerModule((bind) => {
  loadPolygonModule || (loadPolygonModule = true, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/star-render.js
var __decorate36 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata27 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasStarRender = class extends BaseRender {
  constructor(starRenderContribitions) {
    super(), this.starRenderContribitions = starRenderContribitions, this.numberType = STAR_NUMBER_TYPE, this.builtinContributions = [defaultStarBackgroundRenderContribution, defaultStarTextureRenderContribution], this.init(starRenderContribitions);
  }
  drawShape(star2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const starAttribute = getTheme(star2, null == params2 ? void 0 : params2.theme).star, { x: originX = starAttribute.x, y: originY = starAttribute.y, fillStrokeOrder = starAttribute.fillStrokeOrder } = star2.attribute, data = this.valid(star2, starAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, points = star2.getCachedPoints();
    context.beginPath(), points && points.length && points.forEach((point5, index) => {
      0 === index ? context.moveTo(x + point5.x, y + point5.y) : context.lineTo(x + point5.x, y + point5.y);
    }), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(star2, star2.attribute, starAttribute), this.beforeRenderStep(star2, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, star2.attribute, starAttribute) : fVisible && (context.setCommonStyle(star2, star2.attribute, originX - x, originY - y, starAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, star2.attribute, starAttribute) : sVisible && (context.setStrokeStyle(star2, star2.attribute, originX - x, originY - y, starAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(star2, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
  }
  draw(star2, renderService, drawContext, params2) {
    const starAttribute = getTheme(star2, null == params2 ? void 0 : params2.theme).star;
    this._draw(star2, starAttribute, false, drawContext, params2);
  }
};
DefaultCanvasStarRender = __decorate36([injectable(), __param20(0, inject(ContributionProvider)), __param20(0, named(StarRenderContribution)), __metadata27("design:paramtypes", [Object])], DefaultCanvasStarRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/star-module.js
var loadStarModule = false;
var starModule = new ContainerModule((bind) => {
  loadStarModule || (loadStarModule = true, bind(StarRender).to(DefaultCanvasStarRender).inSingletonScope(), bind(GraphicRender).toService(StarRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-render.js
var __decorate37 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  reInit() {
  }
  drawShape(glyph, context, x, y, drawContext, params2, fillCb, strokeCb) {
    drawContext.drawContribution && glyph.getSubGraphic().forEach((item) => {
      const renderer = drawContext.drawContribution.getRenderContribution(item);
      renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params2, fillCb, strokeCb);
    });
  }
  draw(glyph, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    if (context.highPerformanceSave(), !drawContext.drawContribution) return;
    const glyphTheme = getTheme(glyph), subGraphic = glyph.getSubGraphic();
    subGraphic.length && subGraphic.forEach((g) => {
      drawContext.drawContribution.renderItem(g, drawContext, {
        theme: glyphTheme
      });
    }), context.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate37([injectable()], DefaultCanvasGlyphRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-module.js
var loadGlyphModule = false;
var glyphModule = new ContainerModule((bind) => {
  loadGlyphModule || (loadGlyphModule = true, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-render.js
var __decorate38 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata28 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x, y, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext, { strokeOpacity = richtextAttribute.strokeOpacity, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
    if (!richtext.valid || !visible) return;
    const fVisible = fillVisible(opacity, fillOpacity, true), sVisible = fillVisible(opacity, strokeOpacity, true);
    if (!fVisible) return;
    context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon2, context, x, y, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon2).richtextIcon, { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon2.attribute, { backgroundWidth = width, backgroundHeight = height } = icon2.attribute;
    if (margin && (x += icon2._marginArray[3], y += icon2._marginArray[0]), icon2._hovered) {
      const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, true)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon2 ? void 0 : icon2.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, false, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate38([injectable(), __metadata28("design:paramtypes", [])], DefaultCanvasRichTextRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-module.js
var loadRichtextModule = false;
var richtextModule = new ContainerModule((bind) => {
  loadRichtextModule || (loadRichtextModule = true, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/image-module.js
var loadImageModule = false;
var imageModule = new ContainerModule((bind) => {
  loadImageModule || (loadImageModule = true, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/base-3d-render.js
var Base3dRender = class extends BaseRender {
  stroke(x, y, z, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((edge) => {
      const p1 = vertices[edge[0]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, p2 = vertices[edge[1]], v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x, y, z, face3d, faces, fillColor, context, light, graphic3d, graphic3dAttribute, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v) => context.view(v[0], v[1], v[2])[2]), sortFace = [];
    face3d.polygons.forEach((p, i) => {
      if (faces && !faces[i]) return;
      sortFace.push({
        faceIdx: i,
        polygon: p
      });
      const { polygon } = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p.ave_z = z1 + z2 + z3 + z4;
    }), sortFace.sort((a2, b) => b.polygon.ave_z - a2.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      }, v3 = {
        x: x + p3[0],
        y: y + p3[1],
        z: z + p3[2]
      }, v4 = {
        x: x + p4[0],
        y: y + p4[1],
        z: z + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, graphic3d && graphic3d.attribute, graphic3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-render.js
var __decorate39 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasRect3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, x1, y1, x: originX, y: originY, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return;
    const { light } = drawContext.stage || {}, face3d = rect.findFace();
    if (false !== fill) {
      context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, null, fc, context, light, null, null, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(rect, renderService, drawContext) {
    const rectAttribute = getTheme(rect).rect;
    this._draw(rect, rectAttribute, false, drawContext);
  }
};
DefaultCanvasRect3dRender = __decorate39([injectable()], DefaultCanvasRect3dRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-module.js
var loadRect3dModule = false;
var rect3dModule = new ContainerModule((bind) => {
  loadRect3dModule || (loadRect3dModule = true, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-render.js
var __decorate40 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
function drawArcPath2(arc, context, cx, cy, z, outerRadius, innerRadius) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp2 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp2;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy, z);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));
  else {
    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    outerDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < 1e-3 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = true) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
  }
  return context.closePath(), collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (radius <= epsilon) context.moveTo(cx, cy, z1);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
  else {
    const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle), xors = radius * cos(innerouterStartAngle), yors = radius * sin(innerouterStartAngle), xore = radius * cos(innerouterEndAngle), yore = radius * sin(innerouterEndAngle);
    innerouterDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
var DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, height = 10 } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const rgbArray = ColorStore.Get(fill, ColorType.Color255), { light } = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
      top: z,
      bottom: z + height
    }, n_face = {
      top: [0, 1, 0],
      bottom: [0, -1, 0],
      outside: [1, 0, -1],
      inside: [1, 0, -1]
    };
    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath2(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, true, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
      const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
      return "outside" === face ? {
        innerouterDeltaAngle: outerDeltaAngle,
        innerouterEndAngle: outerEndAngle,
        innerouterStartAngle: outerStartAngle
      } : {
        innerouterDeltaAngle: innerDeltaAngle,
        innerouterEndAngle: innerEndAngle,
        innerouterStartAngle: innerStartAngle
      };
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArc3DRender = __decorate40([injectable()], DefaultCanvasArc3DRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-module.js
var loadArc3dModule = false;
var arc3dModule = new ContainerModule((bind) => {
  loadArc3dModule || (loadArc3dModule = true, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-render.js
var __decorate41 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasPyramid3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  drawShape(pyramid3d, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const pyramidAttribute = getTheme(pyramid3d, null == params2 ? void 0 : params2.theme).polygon, { fill = pyramidAttribute.fill, stroke: stroke2 = pyramidAttribute.stroke, face = [true, true, true, true, true, true] } = pyramid3d.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
    const { light } = drawContext.stage || {}, face3d = pyramid3d.findFace();
    if (false !== fill) {
      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, pyramid3d, pyramidAttribute, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(pyramid3d, renderService, drawContext) {
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    this._draw(pyramid3d, pyramid3dAttribute, false, drawContext);
  }
};
DefaultCanvasPyramid3dRender = __decorate41([injectable()], DefaultCanvasPyramid3dRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-module.js
var loadPyramid3dModule = false;
var pyramid3dModule = new ContainerModule((bind) => {
  loadPyramid3dModule || (loadPyramid3dModule = true, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-arc.js
function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-arc3d.js
function registerArc3dGraphic() {
  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-area.js
function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-circle.js
function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-glyph.js
function registerGlyphGraphic() {
  graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-group.js
function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-image.js
function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-line.js
function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-path.js
function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-polygon.js
function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-star.js
function registerStarGraphic() {
  graphicCreator.RegisterGraphicCreator("star", createStar);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-pyramid3d.js
function registerPyramid3dGraphic() {
  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-rect.js
function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-rect3d.js
function registerRect3dGraphic() {
  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-richtext.js
function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-symbol.js
function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-text.js
function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-shadowRoot.js
function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/register/register-wraptext.js
function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/flex-layout-plugin.js
var _tempBounds2 = new AABBBounds();
var FlexLayoutPlugin = class {
  constructor() {
    this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds();
  }
  pauseLayout(p) {
    this.pause = p;
  }
  tryLayoutChildren(graphic) {
    graphic.firstChild && this.tryLayout(graphic.firstChild);
  }
  tryLayout(graphic, force = true) {
    if (this.pause) return;
    const p = graphic.parent;
    if (!(force || p && graphic.needUpdateLayout())) return;
    const theme4 = getTheme(p).group, { display = theme4.display } = p.attribute;
    if ("flex" !== display) return;
    const { flexDirection = theme4.flexDirection, flexWrap = theme4.flexWrap, alignItems = theme4.alignItems, clip = theme4.clip } = p.attribute, { alignContent = null != alignItems ? alignItems : theme4.alignContent } = p.attribute;
    let { width, height, justifyContent = theme4.justifyContent } = p.attribute;
    const children = p.getChildren();
    if (null == width || null == height) {
      let childrenWidth = 0, childrenHeight = 0, boundsLegal = 0;
      if (children.forEach((child) => {
        const bounds = this.getAABBBounds(child);
        bounds.empty() || ("column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2);
      }), !isFinite(boundsLegal)) return;
      width = childrenWidth, height = childrenHeight;
    }
    null == p.attribute.width ? p.attribute.width = width : width = p.attribute.width, null == p.attribute.height ? p.attribute.height = height : height = p.attribute.height, this.tempBounds.copy(p._AABBBounds);
    const result2 = {
      main: {
        len: width,
        field: "x"
      },
      cross: {
        len: height,
        field: "y"
      }
    }, main = result2.main, cross2 = result2.cross;
    "column" !== flexDirection && "column-reverse" !== flexDirection || (main.len = height, cross2.len = width, main.field = "y", cross2.field = "x"), "row-reverse" !== flexDirection && "column-reverse" !== flexDirection || ("flex-start" === justifyContent ? justifyContent = "flex-end" : "flex-end" === justifyContent ? justifyContent = "flex-start" : children.reverse());
    let mainLen = 0, crossLen = 0;
    const mianLenArray = [];
    children.forEach((c2) => {
      const b2 = this.getAABBBounds(c2);
      if (b2.empty()) return;
      const ml = "x" === main.field ? b2.width() : b2.height(), cl = "x" === cross2.field ? b2.width() : b2.height();
      mianLenArray.push({
        mainLen: ml,
        crossLen: cl
      }), mainLen += ml, crossLen = Math.max(crossLen, cl);
    });
    const mainList = [];
    if (mainLen > main.len && "wrap" === flexWrap) {
      let tempMainL = 0, tempCrossL = 0;
      mianLenArray.forEach(({ mainLen: mainLen2, crossLen: crossLen2 }, i) => {
        tempMainL + mainLen2 > main.len ? 0 === tempMainL ? (mainList.push({
          idx: i,
          mainLen: tempMainL + mainLen2,
          crossLen: crossLen2
        }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
          idx: i - 1,
          mainLen: tempMainL,
          crossLen: tempCrossL
        }), tempMainL = mainLen2, tempCrossL = crossLen2) : (tempMainL += mainLen2, tempCrossL = Math.max(tempCrossL, crossLen2));
      }), mainList.push({
        idx: mianLenArray.length - 1,
        mainLen: tempMainL,
        crossLen: tempCrossL
      });
    } else mainList.push({
      idx: mianLenArray.length - 1,
      mainLen,
      crossLen
    });
    let lastIdx = 0;
    if (mainList.forEach((s2) => {
      this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s2), lastIdx = s2.idx + 1;
    }), crossLen = mainList.reduce((a2, b2) => a2 + b2.crossLen, 0), 1 === mainList.length) {
      const anchorPosMap = {
        "flex-start": 0,
        "flex-end": cross2.len,
        center: cross2.len / 2
      };
      this.layoutCross(children, alignItems, cross2, anchorPosMap, mianLenArray, mainList[0], 0);
    } else if ("flex-start" === alignContent) {
      lastIdx = 0;
      let anchorPos = 0;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen;
      });
    } else if ("center" === alignContent) {
      lastIdx = 0;
      let anchorPos = Math.max(0, (cross2.len - crossLen) / 2);
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "center", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen;
      });
    } else if ("space-around" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / mainList.length / 2);
      let anchorPos = padding;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen + 2 * padding;
      });
    } else if ("space-between" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / (2 * mainList.length - 2));
      let anchorPos = 0;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen + 2 * padding;
      });
    }
    children.forEach((child, idx) => {
      child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
    }), p.addUpdateLayoutTag();
    const b = this.getAABBBounds(p);
    clip || this.tempBounds.equals(b) || this.tryLayout(p, false);
  }
  getAABBBounds(graphic) {
    this.skipBoundsTrigger = true;
    const b = graphic.AABBBounds;
    return this.skipBoundsTrigger = false, b;
  }
  updateChildPos(posBaseLeftTop, lastP, lastBP) {
    return posBaseLeftTop + (null != lastP ? lastP : 0) - lastBP;
  }
  layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
    if ("flex-start" === justifyContent) {
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    } else if ("flex-end" === justifyContent) {
      let pos = main.len;
      for (let i = currSeg.idx; i >= lastIdx; i--) {
        pos -= mianLenArray[i].mainLen;
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
      }
    } else if ("space-around" === justifyContent) if (currSeg.mainLen >= main.len) {
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    } else {
      const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / size / 2;
      let pos = padding;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
      }
    }
    else if ("space-between" === justifyContent) if (currSeg.mainLen >= main.len) {
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    } else {
      const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / (2 * size - 2);
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
      }
    }
    else if ("center" === justifyContent) {
      let pos = (main.len - currSeg.mainLen) / 2;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    }
  }
  layoutCross(children, alignItem, cross2, anchorPosMap, lenArray, currSeg, lastIdx) {
    var _a;
    for (let i = lastIdx; i <= currSeg.idx; i++) {
      const child = children[i];
      let { alignSelf } = child.attribute;
      alignSelf && "auto" !== alignSelf || (alignSelf = alignItem);
      const b = this.getAABBBounds(child), anchorPos = null !== (_a = anchorPosMap[alignSelf]) && void 0 !== _a ? _a : anchorPosMap["flex-start"];
      "flex-end" === alignSelf ? !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`])) : "center" === alignSelf ? !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`])) : !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`]));
    }
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage && graphic.stage === this.pluginService.stage && this.tryLayout(graphic, false);
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && _tempBounds2.copy(bounds);
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && (_tempBounds2.equals(bounds) || this.tryLayout(graphic, false));
    }), application.graphicService.hooks.onSetStage.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic, false);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter((item) => item.name !== this.key);
  }
};
function getPadding(graphic, field) {
  return 0;
}
var registerFlexLayoutPlugin = () => {
  Factory.registerPlugin("FlexLayoutPlugin", FlexLayoutPlugin);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/core/base.js
var GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
var AbstractComponent = class extends Group {
  constructor(attributes, options) {
    super(attributes), this._skipRenderAttributes = GROUP_ATTRIBUTES, (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = true), this.setTheme({
      common: {
        strokeBoundsBuffer: 0
      }
    }), this.attribute = attributes, this.onSetStage(() => {
      this.render(), this.bindEvents();
    });
  }
  setAttribute(key, value, forceUpdateTag, context) {
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    if (params2) return this._setAttributes(params2, forceUpdateTag);
    isPlainObject_default(this.attribute[key]) && isPlainObject_default(value) && !isFunction_default(this.attribute[key]) && !isFunction_default(value) ? merge(this.attribute[key], value) : this.attribute[key] = value, this._skipRenderAttributes.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this._setAttributes(params2, forceUpdateTag);
  }
  _setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this._mergeAttributes(params2, keys2), keys2.every((key) => this._skipRenderAttributes.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  _mergeAttributes(params2, keys2) {
    isNil_default(keys2) && (keys2 = Object.keys(params2));
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      !isPlainObject_default(this.attribute[key]) || isFunction_default(this.attribute[key]) || isFunction_default(params2[key]) ? this.attribute[key] = params2[key] : merge(this.attribute[key], params2[key]);
    }
  }
  bindEvents() {
  }
  _getNodeId(id) {
    var _a;
    return `${null !== (_a = this.id) && void 0 !== _a ? _a : this._uid}-${this.name}-${id}`;
  }
  _dispatchEvent(eventName, details) {
    var _a;
    const changeEvent = new CustomEvent(eventName, details);
    changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/config.js
var defaultRouthThemeSpec = {
  maxRandomnessOffset: 3,
  roughness: 1,
  bowing: 1,
  curveFitting: 0.95,
  curveTightness: void 0,
  curveStepCount: 9,
  fillStyle: "hachure",
  fillWeight: void 0,
  hachureAngle: 60,
  hachureGap: 6,
  simplification: 0,
  dashOffset: void 0,
  dashGap: void 0,
  zigzagOffset: void 0,
  seed: 1,
  fillLineDash: void 0,
  fillLineDashOffset: void 0,
  disableMultiStroke: false,
  disableMultiStrokeFill: false,
  preserveVertices: true,
  fixedDecimalPlaceDigits: void 0
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/base-render.js
var RoughBaseRender = class {
  drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb);
  }
  reInit() {
    var _a;
    null === (_a = this.canvasRenderer) || void 0 === _a || _a.reInit();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-arc.js
var __decorate42 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata29 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasArcRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  draw(arc, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const arcAttribute = arc.getGraphicTheme();
    let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const { dx = arcAttribute.dx, dy = arcAttribute.dy } = arc.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, true);
    const customPath = new CustomPath2D(), { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, lineWidth = arcAttribute.lineWidth, outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = arc.attribute;
    drawArcPath(arc, customPath, x, y, outerRadius, innerRadius), rc.path(customPath.toString(), {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasArcRender = __decorate42([injectable(), __param21(0, inject(DefaultCanvasArcRender)), __metadata29("design:paramtypes", [Object])], RoughCanvasArcRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-area.js
var __decorate43 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var RoughCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb) {
    if (fillCb) return super.drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawAreaSegments(customPath, cache, clipRange, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasAreaRender = __decorate43([injectable()], RoughCanvasAreaRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-circle.js
var __decorate44 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata30 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasCircleRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  draw(circle2, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), circleAttribute = circle2.getGraphicTheme();
    let { x = circleAttribute.x, y = circleAttribute.y } = circle2.attribute;
    circle2.transMatrix.onlyTranslate() ? context.onlyTranslate() || context.clearMatrix() : (x = 0, y = 0, context.transformFromMatrix(circle2.transMatrix, true));
    const { radius = circleAttribute.radius, fill = circleAttribute.fill, stroke: stroke2 = circleAttribute.stroke, lineWidth = circleAttribute.lineWidth } = circle2.attribute;
    rc.circle(x, y, radius, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      fillStyle: "zigzag",
      roughness: 0.5
    });
  }
};
RoughCanvasCircleRender = __decorate44([injectable(), __param22(0, inject(DefaultCanvasCircleRender)), __metadata30("design:paramtypes", [Object])], RoughCanvasCircleRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-line.js
var __decorate45 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var RoughCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
    if (fillCb || strokeCb) return super.drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasLineRender = __decorate45([injectable()], RoughCanvasLineRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-path.js
var __decorate46 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata31 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasPathRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  draw(path, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {});
    context.highPerformanceSave();
    const pathAttribute = path.getGraphicTheme();
    context.transformFromMatrix(path.transMatrix, true);
    const { fill = pathAttribute.fill, stroke: stroke2 = pathAttribute.stroke, lineWidth = pathAttribute.lineWidth, path: p = pathAttribute.path, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = path.attribute;
    "string" == typeof p && rc.path(p, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasPathRender = __decorate46([injectable(), __param23(0, inject(DefaultCanvasPathRender)), __metadata31("design:paramtypes", [Object])], RoughCanvasPathRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-rect.js
var __decorate47 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata32 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasRectRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  draw(rect, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const rectAttribute = rect.getGraphicTheme();
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    if (rect.transMatrix.onlyTranslate()) {
      const { dx = rectAttribute.dx, dy = rectAttribute.dy } = rect.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, true);
    const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, fillColor = rectAttribute.fill, strokeColor = rectAttribute.stroke, x1, y1, lineWidth = rectAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = rect.attribute;
    let { width = rectAttribute.width, height = rectAttribute.height } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0, rc.rectangle(x, y, width, height, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasRectRender = __decorate47([injectable(), __param24(0, inject(DefaultCanvasRectRender)), __metadata32("design:paramtypes", [Object])], RoughCanvasRectRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-symbol.js
var __decorate48 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata33 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasSymbolRender = class extends BaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE, this.style = "rough";
  }
  draw(symbol, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(), data = this.transform(symbol, symbolAttribute, context), { x, y, z, lastModelMatrix } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { fill = symbolAttribute.fill, stroke: stroke2 = symbolAttribute.stroke, fillColor = symbolAttribute.fill, strokeColor = symbolAttribute.stroke, size = symbolAttribute.size, lineWidth = symbolAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = symbol.attribute;
    let svgPath = "";
    if (parsedPath.drawToSvgPath) svgPath = parsedPath.drawToSvgPath(size, x, y);
    else {
      const customPath = new CustomPath2D();
      parsedPath.draw(customPath, size, x, y) && customPath.closePath(), svgPath = customPath.toString();
    }
    rc.path(svgPath, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasSymbolRender = __decorate48([injectable(), __param25(0, inject(DefaultCanvasSymbolRender)), __metadata33("design:paramtypes", [Object])], RoughCanvasSymbolRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/rough/module.js
var module_default2 = new ContainerModule((bind) => {
  bind(RoughCanvasCircleRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasCircleRender), bind(RoughCanvasRectRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasRectRender), bind(RoughCanvasPathRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasPathRender), bind(RoughCanvasSymbolRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasSymbolRender), bind(RoughCanvasLineRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasLineRender), bind(RoughCanvasAreaRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasAreaRender), bind(RoughCanvasArcRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasArcRender);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/constants.js
var MathPickerContribution = Symbol.for("MathPickerContribution");
var MathArcPicker = Symbol.for("MathArcPicker");
var MathAreaPicker = Symbol.for("MathAreaPicker");
var MathCirclePicker = Symbol.for("MathCirclePicker");
var MathImagePicker = Symbol.for("MathImagePicker");
var MathLinePicker = Symbol.for("MathLinePicker");
var MathPathPicker = Symbol.for("MathPathPicker");
var MathRectPicker = Symbol.for("MathRectPicker");
var MathSymbolPicker = Symbol.for("MathSymbolPicker");
var MathTextPicker = Symbol.for("MathTextPicker");
var MathPolygonPicker = Symbol.for("MathPolygonPicker");
var MathGlyphPicker = Symbol.for("MathGlyphPicker");
var CanvasArcPicker = Symbol.for("CanvasArcPicker");
var CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
var CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
var CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
var CanvasImagePicker = Symbol.for("CanvasImagePicker");
var CanvasGifImagePicker = Symbol.for("CanvasGifImagePicker");
var CanvasLinePicker = Symbol.for("CanvasLinePicker");
var CanvasLottiePicker = Symbol.for("CanvasLottiePicker");
var CanvasPathPicker = Symbol.for("CanvasPathPicker");
var CanvasRectPicker = Symbol.for("CanvasRectPicker");
var CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
var CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
var CanvasTextPicker = Symbol.for("CanvasTextPicker");
var CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
var CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
var CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
var CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker");
var CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
var CanvasStarPicker = Symbol.for("CanvasStarPicker");
var CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/jsx/graphicType.js
var REACT_TO_CANOPUS_EVENTS = {
  onPointerDown: "pointerdown",
  onPointerUp: "pointerup",
  onPointerUpOutside: "pointerupoutside",
  onPointerTap: "pointertap",
  onPointerOver: "pointerover",
  onPointerMove: "pointermove",
  onPointerEnter: "pointerenter",
  onPointerLeave: "pointerleave",
  onPointerOut: "pointerout",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onMouseUpOutside: "mouseupoutside",
  onMouseMove: "mousemove",
  onMouseOver: "mouseover",
  onMouseOut: "mouseout",
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave",
  onPinch: "pinch",
  onPinchStart: "pinchstart",
  onPinchEnd: "pinchend",
  onPan: "pan",
  onPanStart: "panstart",
  onPanEnd: "panend",
  onDrag: "drag",
  onDragStart: "dragstart",
  onDragEnter: "dragenter",
  onDragLeave: "dragleave",
  onDragOver: "dragover",
  onDragEnd: "dragend",
  onRightDown: "rightdown",
  onRightUp: "rightup",
  onRightUpOutside: "rightupoutside",
  onTouchStart: "touchstart",
  onTouchEnd: "touchend",
  onTouchEndOutside: "touchendoutside",
  onTouchMove: "touchmove",
  onTouchCancel: "touchcancel",
  onPress: "press",
  onPressUp: "pressup",
  onPressEnd: "pressend",
  onSwipe: "swipe",
  onDrop: "drop",
  onWeel: "wheel",
  onClick: "click",
  onDblClick: "dblclick"
};
var REACT_TO_CANOPUS_EVENTS_LIST = Object.keys(REACT_TO_CANOPUS_EVENTS);
function VArc(params2) {
  return graphicCreator.arc(params2 ? params2.attribute : {});
}
function VArea(params2) {
  return graphicCreator.area(params2 ? params2.attribute : {});
}
function VCircle(params2) {
  return graphicCreator.circle(params2 ? params2.attribute : {});
}
function VGroup(params2) {
  return graphicCreator.group(params2 ? params2.attribute : {});
}
function VGlyph(params2) {
  return graphicCreator.glyph(params2 ? params2.attribute : {});
}
function VImage(params2) {
  return graphicCreator.image(params2 ? params2.attribute : {});
}
function VLine(params2) {
  return graphicCreator.line(params2 ? params2.attribute : {});
}
function VPath(params2) {
  return graphicCreator.path(params2 ? params2.attribute : {});
}
function VPolygon(params2) {
  return graphicCreator.polygon(params2 ? params2.attribute : {});
}
function VRect(params2) {
  return graphicCreator.rect(params2 ? params2.attribute : {});
}
function VSymbol(params2) {
  return graphicCreator.symbol(params2 ? params2.attribute : {});
}
function VText(params2) {
  return graphicCreator.text(params2 ? params2.attribute : {});
}
function VRichText(params2) {
  return graphicCreator.richtext(params2 ? params2.attribute : {});
}
VRichText.Text = function(params2) {
  return Object.assign({
    type: "rich/text"
  }, params2);
}, VRichText.Image = function(params2) {
  return Object.assign({
    type: "rich/image"
  }, params2);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/jsx/jsx-classic.js
var __rest = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function flatten(list, out) {
  if (isArray_default(list)) return list.forEach((i) => flatten(i, out));
  out.push(list);
}
function jsx(type, config, ...children) {
  const _a = config || {}, { key, name, id, attribute, stateProxy, animation, timeline } = _a, props = __rest(_a, ["key", "name", "id", "attribute", "stateProxy", "animation", "timeline"]);
  let c2 = type;
  isString_default(type) && (c2 = graphicCreator[type]);
  const childrenList = [];
  children.length && flatten(1 === children.length ? children[0] : children, childrenList);
  const g = "Group" === c2.name ? new c2(attribute) : c2(config);
  if (parseToGraphic(g, childrenList, props), stateProxy && (g.stateProxy = stateProxy), name && (g.name = name), isArray_default(animation)) {
    const animate = g.animate();
    timeline && animate.setTimeline(timeline), animation.forEach((item) => {
      animate[item[0]](...item.slice(1));
    });
  }
  return g;
}
function parseToGraphic(g, childrenList, props) {
  let out, isGraphic = false;
  switch (g.type) {
    case "richtext":
    case "rich/image":
      break;
    case "rich/text":
      out = g.attribute || {}, childrenList[0] && (out.text = childrenList[0]);
      break;
    default:
      isGraphic = true;
  }
  isGraphic ? (childrenList.forEach((c2) => {
    c2 && g.add(c2);
  }), Object.keys(props).forEach((k2) => {
    const en = REACT_TO_CANOPUS_EVENTS[k2];
    en && g.on(en, props[k2]);
  })) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map((item) => item.attribute).filter((item) => item));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/event/extension/gesture.js
var calcDirection = (start, end) => {
  const xDistance = end.x - start.x, yDistance = end.y - start.y;
  return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
};
var calcDistance = (point1, point22) => {
  const xDistance = Math.abs(point22.x - point1.x), yDistance = Math.abs(point22.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter = (points) => {
  const pointersLength = points.length;
  if (1 === pointersLength) return {
    x: Math.round(points[0].x),
    y: Math.round(points[0].y)
  };
  let x = 0, y = 0, i = 0;
  for (; i < pointersLength; ) x += points[i].x, y += points[i].y, i++;
  return {
    x: Math.round(x / pointersLength),
    y: Math.round(y / pointersLength)
  };
};
var Gesture = class extends import_eventemitter3.default {
  constructor(element, config = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = (ev) => {
      this.startTime = clock.now();
      const { cachedEvents, startPoints } = this;
      ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
      for (let i = 0; i < cachedEvents.length; i++) {
        const { x, y } = cachedEvents[i], point5 = {
          x,
          y
        };
        startPoints[i] = point5;
      }
      if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter([startPoints[0], startPoints[1]]);
      else {
        const event2 = cachedEvents[0];
        this.pressTimeout = setTimeout(() => {
          event2.direction = "none", event2.deltaX = 0, event2.deltaY = 0, event2.points = startPoints, this.triggerStartEvent("press", event2), this.triggerEvent("press", event2), this.eventType = "press", this.direction = "none", this.pressTimeout = null;
        }, this.config.press.time);
      }
    }, this.onMove = (ev) => {
      this.clearPressTimeout();
      const { startPoints, cachedEvents } = this;
      if (!startPoints.length) return;
      const moveEvent = ev.clone(), { x, y, pointerId } = moveEvent;
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
        cachedEvents[i] = moveEvent;
        break;
      }
      const point5 = {
        x,
        y
      }, points = cachedEvents.map((cachedEvent) => ({
        x: cachedEvent.x,
        y: cachedEvent.y
      })), now = clock.now();
      if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point5, 1 === startPoints.length) {
        const startPoint = startPoints[0], deltaX = x - startPoint.x, deltaY = y - startPoint.y, direction = this.direction || calcDirection(startPoint, point5);
        this.direction = direction;
        const eventType = this.getEventType(point5);
        return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
      }
      const { startDistance } = this, currentDistance = calcDistance(points[0], points[1]);
      moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
    }, this.onEnd = (ev) => {
      const endEvent = ev.clone(), { cachedEvents, startPoints } = this, points = cachedEvents.map((ev2) => ({
        x: ev2.x,
        y: ev2.y
      }));
      if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
        const now = clock.now(), lastMoveTime = this.lastMoveTime;
        if (now - lastMoveTime < 100) {
          const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
          if (intervalTime > 0) {
            const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance = calcDistance(prevMovePoint, lastMovePoint), velocity = distance / intervalTime;
            if (velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold) return endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent), this.cachedEvents = [], this.startPoints = [], void this.reset();
          }
        }
        now - this.startTime < this.config.press.time && (now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0));
      }
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
        cachedEvents.splice(i, 1), startPoints.splice(i, 1);
        break;
      }
      this.reset(), cachedEvents.length > 0 && this.onStart();
    }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
      press: {
        time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
        threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
      },
      swipe: {
        threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
        velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : 0.3
      },
      tap: {
        interval: null !== (_k = null === (_j = null == config ? void 0 : config.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
      }
    }, this.initEvents();
  }
  initEvents() {
    const { element } = this;
    element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerleave", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
  }
  removeEvents() {
    const { element } = this;
    element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerleave", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
  }
  release() {
    this.removeEvents(), this.element = null;
  }
  getEventType(point5) {
    const { eventType, startTime, startPoints } = this;
    if ("press" === eventType) return eventType;
    let type;
    return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point5) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
  }
  enable(eventType) {
    this.processEvent[eventType] = true;
  }
  isProcess(eventType) {
    return this.processEvent[eventType];
  }
  pushEvent(type, ev) {
    const { emitThrottles } = this, newEvent = {
      type,
      ev
    };
    for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
    emitThrottles.push(newEvent);
  }
  clearPressTimeout() {
    this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
  }
  reset() {
    this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
  }
  triggerEvent(type, ev) {
    this.pushEvent(type, ev);
    const { throttleTimer, emitThrottles } = this;
    throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
      application.global.getCancelAnimationFrame()(this.throttleTimer), this.throttleTimer = null;
      for (let i = 0, len = emitThrottles.length; i < len; i++) {
        const { type: type2, ev: ev2 } = emitThrottles[i];
        this.emitEvent(type2, ev2);
      }
      this.emitThrottles.length = 0;
    }));
  }
  triggerStartEvent(type, ev) {
    this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
  }
  triggerEndEvent(ev) {
    const processEvent = this.processEvent;
    Object.keys(processEvent).forEach((type) => {
      this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
    });
  }
  emitEvent(type, e) {
    if (!this.element) return;
    const listeners = this.element._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
    this.emit(type, e);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/context.js
var __decorate49 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata34 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var outP = [0, 0, 0];
var addArcToBezierPath2 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
  if (clockwise) for (; endAngle > startAngle; ) endAngle -= pi2;
  else for (; endAngle < startAngle; ) endAngle += pi2;
  const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
  let sa = startAngle, ea = sa;
  for (; ea !== endAngle; ) {
    ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
    const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c2 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4]), sa = ea;
  }
};
var BrowserContext2d = class {
  set fillStyle(d) {
    this.nativeContext.fillStyle = d;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(d) {
    this.nativeContext.font = d;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(d) {
    this.nativeContext.globalAlpha = d * this.baseGlobalAlpha;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(d) {
    this.nativeContext.lineCap = d;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(d) {
    this.nativeContext.lineDashOffset = d;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(d) {
    this.nativeContext.lineJoin = d;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(d) {
    this.nativeContext.lineWidth = d;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(d) {
    this.nativeContext.miterLimit = d;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(d) {
    this.nativeContext.shadowBlur = d;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(d) {
    this.nativeContext.shadowColor = d;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(d) {
    this.nativeContext.shadowOffsetX = d;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(d) {
    this.nativeContext.shadowOffsetY = d;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(d) {
    this.nativeContext.strokeStyle = d;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(d) {
    this.nativeContext.textAlign = d;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(d) {
    this.nativeContext.textBaseline = d;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(use) {
    use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
  }
  constructor(canvas, dpr) {
    this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1
    }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
      opacity: 1
    }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
      opacity: 1
    }), this._clearShadowStyle = false, this._clearFilterStyle = false, this._clearGlobalCompositeOperationStyle = false;
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.baseGlobalAlpha = 1;
  }
  reset() {
    this.stack.length && Logger.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m3) {
    return matrixAllocate.allocateByObj(m3);
  }
  clear() {
    this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
  }
  restore() {
    this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(true));
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix), this.nativeContext.save();
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a2, b, c2, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a2, dpr * b, dpr * c2, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a2, b, c2, d, e, f, setTransform = true) {
    this.matrix.multiply(a2, b, c2, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(path, fillRule) {
    path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
    if (z = z || 0, this.camera) {
      const arr = [];
      addArcToBezierPath2(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
      for (let i = 0; i < arr.length; ++i) {
        const bez = arr[i];
        this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
      }
    } else this.nativeContext.arc(x, y, Math.max(0, radius), startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
    if (z = z || 0, this.camera) {
      let cp1z = z, cp2z = z;
      this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
    }
    this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  lineTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.lineTo(x, y);
  }
  moveTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y, z) {
    if (z = z || 0, this.camera) {
      let cpz = z;
      this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
    }
    this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h, z) {
    z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
  }
  createImageData() {
    const a2 = arguments;
    return 2 === a2.length ? this.nativeContext.createImageData(a2[0], a2[1]) : 1 === a2.length ? this.nativeContext.createImageData(a2[0]) : null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    return isFinite(x0 + y0 + x1 + y1) || (x0 = 0, y0 = 0, x1 = 0, y1 = 0), this.nativeContext.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    if (this.nativeContext.createConicGradient && Math.abs(endAngle - startAngle - 2 * Math.PI) < 1e-3) return this.nativeContext.createConicGradient(startAngle, x, y);
    let pattern, edit = false;
    const ctx = this;
    return {
      stops: [],
      addColorStop(offset, color) {
        this.stops.push([offset, color]), edit = true;
      },
      GetPattern(minW, minH, deltaAngle) {
        return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = false), pattern;
      }
    };
  }
  fill(path, fillRule) {
    this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
  }
  fillRect(x, y, width, height) {
    this.nativeContext.fillRect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
    this.nativeContext.clearRect(x, y, w, h);
  }
  project(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    return {
      x,
      y
    };
  }
  view(x, y, z) {
    return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
  }
  fillText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.fillText(text2, x, y);
  }
  getImageData(sx, sy, sw, sh) {
    return this.nativeContext.getImageData(sx, sy, sw, sh);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(x, y) {
    return this.nativeContext.isPointInPath(x, y);
  }
  isPointInStroke(x, y) {
    return this.nativeContext.isPointInStroke(x, y);
  }
  measureText(text2, method = application.global.measureTextMethod) {
    var _a, _b;
    if (!method || "native" === method) return this.nativeContext.measureText(text2);
    this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
    const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily, fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
    return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text2, method);
  }
  putImageData(imagedata, dx, dy) {
    this.nativeContext.putImageData(imagedata, dx, dy);
  }
  setLineDash(segments2) {
    const a2 = arguments, _context = this.nativeContext;
    this.nativeContext.setLineDash ? a2[0] && _context.setLineDash(a2[0]) : "mozDash" in _context ? _context.mozDash = a2[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a2[0]);
  }
  stroke(path) {
    this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
  }
  strokeRect(x, y, width, height) {
    this.nativeContext.strokeRect(x, y, width, height);
  }
  strokeText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.strokeText(text2, x, y);
  }
  drawImage() {
    const _context = this.nativeContext, a2 = arguments;
    3 === a2.length ? _context.drawImage(a2[0], a2[1], a2[2]) : 5 === a2.length ? _context.drawImage(a2[0], a2[1], a2[2], a2[3], a2[4]) : 9 === a2.length && _context.drawImage(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8]);
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setCommonStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    _context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha, fillOpacity > 1e-12 && opacity > 1e-12 && (_context.fillStyle = createColor(this, fill, params2, offsetX, offsetY));
  }
  setShadowBlendStyle(params2, attribute, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setShadowBlendStyle(params2, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setShadowBlendStyle(params2, attribute, dp);
    }
    return this._setShadowBlendStyle(params2, attribute, defaultParams);
  }
  _setShadowBlendStyle(params2, attribute, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { opacity = defaultParams.opacity, shadowBlur = defaultParams.shadowBlur, shadowColor = defaultParams.shadowColor, shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY = defaultParams.shadowOffsetY, blur = defaultParams.blur, filter: filter2 = defaultParams.filter, globalCompositeOperation = defaultParams.globalCompositeOperation } = attribute;
    opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = true) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = true) : filter2 ? (_context.filter = filter2, this._clearFilterStyle = true) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = false), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = true) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = false));
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setStrokeStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (_context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineDashOffset = defaultParams.lineDashOffset, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale } = attribute;
      _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams, this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
  }
  setClearMatrix(a2, b, c2, d, e, f) {
    this._clearMatrix.setValue(a2, b, c2, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m3) => matrixAllocate.free(m3)), this.stack.length = 0;
  }
};
BrowserContext2d.env = "browser", BrowserContext2d = __decorate49([injectable(), __metadata34("design:paramtypes", [Object, Number])], BrowserContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/canvas.js
var __decorate50 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata35 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BrowserCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init(params2) {
    const { container: container2 } = params2;
    if ("string" == typeof container2) {
      const _c = application.global.getElementById(container2);
      _c && (this._container = _c);
    } else this._container = container2;
    this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
  }
  initStyle() {
    if (!this.controled) return;
    const { nativeCanvas } = this;
    nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const canvas = this._nativeCanvas;
    canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
  }
  resetStyle(params2) {
    if (!this.controled) return;
    const { width = this._displayWidth, height = this._displayHeight, dpr = this._dpr, x = this._x, y = this._y } = params2, { nativeCanvas } = this;
    nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params2.id && (nativeCanvas.id = params2.id), this.visiable || this.hide();
  }
  setCanvasStyle(canvas, x, y, w, h) {
    this.controled && (canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
  }
  toDataURL(mimeType, quality) {
    return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
  }
  resize(width, height) {
    if (!this.controled) return;
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
    this._context.dpr = this._dpr;
  }
};
BrowserCanvas.env = "browser", BrowserCanvas = __decorate50([injectable(), __metadata35("design:paramtypes", [Object])], BrowserCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/create-canvas-module.js
function createModule(CanvasConstructor, ContextConstructor) {
  return new ContainerModule((bind) => {
    bind(CanvasFactory).toDynamicValue(() => (params2) => new CanvasConstructor(params2)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params2, dpr) => new ContextConstructor(params2, dpr)).whenTargetNamed(ContextConstructor.env);
  });
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/modules.js
var browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/canvas-picker-service.js
var __decorate51 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata36 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(contributions, drawContribution, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_, env, global2) => {
      this.configure(global2, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global2, env) {
    this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const ret = drawContribution.beforePickItem(graphic, this, point5, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point5, params2), g = pd ? graphic : null, data = {
      graphic: g,
      params: pd
    };
    if (g) return data;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterPickItem) {
        const ret = drawContribution.afterPickItem(graphic, this, point5, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    return data;
  }
};
DefaultCanvasPickerService = __decorate51([injectable(), __param26(0, inject(ContributionProvider)), __param26(0, named(CanvasPickerContribution)), __param26(1, inject(DrawContribution)), __param26(2, inject(ContributionProvider)), __param26(2, named(PickItemInterceptor)), __param26(3, inject(ContributionProvider)), __param26(3, named(PickServiceInterceptor)), __metadata36("design:paramtypes", [Object, Object, Object, Object])], DefaultCanvasPickerService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/group-picker.js
var __decorate52 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGroupPicker = class {
  constructor() {
    this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
  }
  contains(group, point5, params2) {
    return false;
  }
};
DefaultCanvasGroupPicker = __decorate52([injectable()], DefaultCanvasGroupPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/module.js
var m = new ContainerModule((bind, unbind, isBound, rebind) => {
  m.__vloaded || (m.__vloaded = true, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
});
m.__vloaded = false;
var module_default3 = m;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/canvas-module.js
var canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
});
function loadCanvasPicker(c2) {
  c2.load(module_default3), c2.load(canvasPickerModule);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/browser-contribution.js
var BrowserWindowHandlerContribution_1;
var __decorate53 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata37 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
  get container() {
    return this.canvas.nativeCanvas.parentElement;
  }
  static GenerateCanvasId() {
    return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
  }
  constructor() {
    super(), this.type = "browser", this._canvasIsIntersecting = true, this.global = application.global, this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return this.canvas.nativeCanvas.getBoundingClientRect();
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2), this.postInit();
  }
  postInit() {
    if (this.global.optimizeVisible) try {
      this.observerCanvas();
    } catch (err) {
      console.error("发生错误，该环境不存在IntersectionObserver");
    }
  }
  isElementVisible(el) {
    const rect = el.getBoundingClientRect(), vWidth = window.innerWidth || document.documentElement.clientWidth, vHeight = window.innerHeight || document.documentElement.clientHeight;
    return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
  }
  observerCanvas() {
    this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
    const observer = new IntersectionObserver((entries, observer2) => {
      entries.forEach((entry) => {
        this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
      });
    });
    observer && observer.observe(this.canvas.nativeCanvas);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    });
    let container2;
    if (container2 = "string" == typeof params2.container ? this.global.getElementById(params2.container) : params2.container ? params2.container : this.global.getRootElement(), !container2) throw new Error("发生错误，containerId可能传入有误");
    params2.offscreen ? container2 = null : container2.appendChild(nativeCanvas);
    const options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      container: container2,
      id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
      canvasControled: true
    };
    this.canvas = new BrowserCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    if (!canvas) throw new Error("发生错误，传入的canvas不正确");
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    if (null == dpr) {
      dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
    }
    this.canvas = new BrowserCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
  }
  dispatchEvent(event2) {
    return this.canvas.nativeCanvas.dispatchEvent(event2);
  }
  getStyle() {
    var _a;
    return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
  }
  setStyle(style2) {
    this.canvas.nativeCanvas.style = style2;
  }
  getBoundingClientRect() {
    const c2 = this.canvas.nativeCanvas, wh = this.getWH();
    return c2.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
  isVisible(bbox) {
    return this._canvasIsIntersecting;
  }
  onVisibleChange(cb) {
    this._onVisibleChangeCb = cb;
  }
  getTopLeft(baseWindow) {
    return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
  }
};
BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate53([injectable(), __metadata37("design:paramtypes", [])], BrowserWindowHandlerContribution);
var browserWindowModule = new ContainerModule((bind) => {
  bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/browser-contribution.js
var __decorate54 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata38 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DynamicB = class {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(dom) {
    this.dom = dom;
  }
};
function createImageElement(src, isSvg2 = false) {
  const img = document.createElement("img");
  if (application.global.isImageAnonymous && (img.crossOrigin = "anonymous"), isSvg2) {
    const data = new Blob([src], {
      type: "image/svg+xml"
    });
    src = window.URL.createObjectURL(data);
  }
  if (img.src = src, img.complete) return Promise.resolve(img);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "browser", this.supportEvent = true;
    try {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsTouchEvents = false, this.supportsPointerEvents = false, this.supportsPointerEvents = false;
    }
    this.applyStyles = true;
  }
  mapToCanvasPoint(nativeEvent, domElement) {
    var _a, _b;
    let clientX = 0, clientY = 0, offsetX = 0, offsetY = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
      clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
    } else clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
    if (domElement) {
      const x = clientX, y = clientY, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
      let scaleX, scaleY;
      return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
        x: (x - rect.left) / (isValidNumber_default(scaleX) ? scaleX : 1),
        y: (y - rect.top) / (isValidNumber_default(scaleY) ? scaleY : 1)
      };
    }
    return {
      x: offsetX,
      y: offsetY
    };
  }
  getNativeAABBBounds(_dom) {
    let dom = _dom;
    if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
      const b = dom.getBoundingClientRect();
      return new DynamicB(b);
    }
    return new AABBBounds();
  }
  removeDom(dom) {
    return dom.parentElement.removeChild(dom), true;
  }
  updateDom(dom, params2) {
    const { width, height, style: style2 } = params2;
    return style2 && (isString_default(style2) ? dom.setAttribute("style", style2) : Object.keys(style2).forEach((k2) => {
      dom.style[k2] = style2[k2];
    })), null != width && (dom.style.width = `${width}px`), null != height && (dom.style.height = `${height}px`), true;
  }
  createDom(params2) {
    const { tagName = "div", parent } = params2, element = document.createElement(tagName);
    if (this.updateDom(element, params2), parent) {
      const pd = isString_default(parent) ? this.getElementById(parent) : parent;
      pd && pd.appendChild && pd.appendChild(element);
    }
    return element;
  }
  loadImage(url) {
    return createImageElement(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return createImageElement(url, true).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  createCanvas(params2) {
    var _a, _b;
    const canvas = document.createElement("canvas");
    params2.id && (canvas.id = null !== (_a = params2.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
    const dpr = null !== (_b = params2.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
    return params2.width && params2.height && (canvas.style.width = `${params2.width}px`, canvas.style.height = `${params2.height}px`, canvas.width = params2.width * dpr, canvas.height = params2.height * dpr), canvas;
  }
  createOffscreenCanvas(params2) {
    var _a;
    const dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
    return new OffscreenCanvas(params2.width * dpr, params2.height * dpr);
  }
  releaseCanvas(canvas) {
    let c2;
    c2 = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c2 && c2.parentElement && c2.parentElement.removeChild(c2);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return document.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return document.removeEventListener(type, listener, options);
  }
  dispatchEvent(event2) {
    return document.dispatchEvent(event2);
  }
  getElementById(str2) {
    return document.getElementById(str2);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release(...params2) {
  }
  getElementTop(element, baseWindow) {
    let actualTop = element.offsetTop, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, current = current.offsetParent;
    return actualTop;
  }
  getElementLeft(element, baseWindow) {
    let actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualLeft += current.offsetLeft, current = current.offsetParent;
    return actualLeft;
  }
  getElementTopLeft(element, baseWindow) {
    let actualTop = element.offsetTop, actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
    return {
      top: actualTop,
      left: actualLeft
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter6(this, void 0, void 0, function* () {
      return new FontFace(font, isString_default(source) ? `url(${source})` : source, descriptors).load().then(function(loadedFont) {
        return document.fonts.add(loadedFont), {
          loadState: "success"
        };
      }).catch(function(error) {
        return console.error("Failed to load font:", error), {
          loadState: "fail"
        };
      });
    });
  }
  isMacOS() {
    if (void 0 === this._isMacOS) try {
      this._isMacOS = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    } catch (err) {
      this._isMacOS = false;
    }
    return this._isMacOS;
  }
  copyToClipBoard(text2) {
    return navigator.clipboard.writeText(text2).then(() => {
    }).catch((err) => {
    });
  }
};
BrowserEnvContribution = __decorate54([injectable(), __metadata38("design:paramtypes", [])], BrowserEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/browser.js
var browserEnvModule = new ContainerModule((bind) => {
  browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = true, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
});
browserEnvModule.isBrowserBound = false;
function loadBrowserEnv(container2, loadPicker = true) {
  loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = true, container2.load(browserEnvModule), container2.load(browserCanvasModule), container2.load(browserWindowModule), loadPicker && loadCanvasPicker(container2));
}
loadBrowserEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/context.js
var __decorate55 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var FeishuContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  getImageData(sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      var _a;
      try {
        tt.canvasGetImageData({
          canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,
          x: sx,
          y: sy,
          width: sw,
          height: sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
  createPattern(image, repetition) {
    return null;
  }
};
FeishuContext2d.env = "feishu", FeishuContext2d = __decorate55([injectable()], FeishuContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/canvas.js
var __decorate56 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata39 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var FeishuCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new FeishuContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
FeishuCanvas.env = "feishu", FeishuCanvas = __decorate56([injectable(), __metadata39("design:paramtypes", [Object])], FeishuCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/modules.js
var feishuCanvasModule = createModule(FeishuCanvas, FeishuContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/feishu-contribution.js
var __decorate57 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata40 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var FeishuWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "feishu", this.eventManager = new MiniAppEventManager();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new FeishuCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new FeishuCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches && event2.changedTouches[0] && (event2.offsetX = event2.changedTouches[0].x, event2.changedTouches[0].offsetX = event2.changedTouches[0].x, event2.changedTouches[0].clientX = event2.changedTouches[0].x, event2.offsetY = event2.changedTouches[0].y, event2.changedTouches[0].offsetY = event2.changedTouches[0].y, event2.changedTouches[0].clientY = event2.changedTouches[0].y), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate57([injectable(), __param27(0, inject(VGlobal)), __metadata40("design:paramtypes", [Object])], FeishuWindowHandlerContribution);
var feishuWindowModule = new ContainerModule((bind) => {
  bind(FeishuWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(FeishuWindowHandlerContribution)).whenTargetNamed(FeishuWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/math-picker-service.js
var __decorate58 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata41 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPickerService = class extends DefaultPickService {
  constructor(contributions, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("math-picker-service", (lastEnv, env, global2) => {
      this.configure(global2, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global2, env) {
    this.pickContext = new EmptyContext2d(null, 1);
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point5, params2), g = pd ? graphic : null;
    return g ? {
      graphic: g,
      params: pd
    } : null;
  }
};
DefaultMathPickerService = __decorate58([injectable(), __param28(0, inject(ContributionProvider)), __param28(0, named(MathPickerContribution)), __param28(1, inject(ContributionProvider)), __param28(1, named(PickItemInterceptor)), __param28(2, inject(ContributionProvider)), __param28(2, named(PickServiceInterceptor)), __metadata41("design:paramtypes", [Object, Object, Object])], DefaultMathPickerService);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/module.js
var m2 = new ContainerModule((bind) => {
  m2.__vloaded || (m2.__vloaded = true, bindContributionProvider(bind, MathPickerContribution));
});
m2.__vloaded = false;
var module_default4 = m2;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/common/base.js
var PickerBase = class {
  contains(graphic, point5, params2) {
    if (!graphic.AABBBounds.containsPoint(point5)) return false;
    if ("imprecise" === graphic.attribute.pickMode) return true;
    if (!this.canvasRenderer) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    let { x = attribute.x, y = attribute.y } = graphic.attribute;
    if (graphic.transMatrix.onlyTranslate()) {
      const point6 = graphic.getOffsetXY(attribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, true);
    let picked = false, _final = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point5.x, point5.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
      if (picked || _final) return true;
      const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), _final = final || _final, picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-picker.js
var __decorate59 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata42 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultMathArcPicker = __decorate59([injectable(), __param29(0, inject(ArcRender)), __metadata42("design:paramtypes", [Object])], DefaultMathArcPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-module.js
var loadArcPick = false;
var arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = true, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-picker.js
var __decorate60 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata43 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultMathAreaPicker = __decorate60([injectable(), __param30(0, inject(AreaRender)), __metadata43("design:paramtypes", [Object])], DefaultMathAreaPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-module.js
var loadAreaPick = false;
var areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = true, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-picker.js
var __decorate61 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata44 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultMathCirclePicker = __decorate61([injectable(), __param31(0, inject(CircleRender)), __metadata44("design:paramtypes", [Object])], DefaultMathCirclePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-module.js
var loadCirclePick = false;
var circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = true, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/common/glyph-picker-base.js
var GlyphPickerBase = class {
  constructor() {
    this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point5, params2) {
    if (!glyph.AABBBounds.containsPoint(point5)) return false;
    if ("imprecise" === glyph.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pickerService = null == params2 ? void 0 : params2.pickerService;
    if (pickerService) {
      let picked = false;
      return glyph.getSubGraphic().forEach((g) => {
        if (picked) return;
        const data = pickerService.pickItem(g, point5, null, params2);
        picked = !(!data || !data.graphic);
      }), picked;
    }
    return false;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-picker.js
var __decorate62 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata45 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathGlyphPicker = __decorate62([injectable(), __param32(0, inject(GlyphRender)), __metadata45("design:paramtypes", [Object])], DefaultMathGlyphPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-module.js
var loadGlyphPick = false;
var glyphMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick || (loadGlyphPick = true, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-picker.js
var __decorate63 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point5);
  }
};
DefaultMathImagePicker = __decorate63([injectable()], DefaultMathImagePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-module.js
var loadImagePick = false;
var imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-picker.js
var __decorate64 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata46 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathLinePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultMathLinePicker = __decorate64([injectable(), __param33(0, inject(LineRender)), __metadata46("design:paramtypes", [Object])], DefaultMathLinePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-module.js
var loadLinePick = false;
var lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = true, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-picker.js
var __decorate65 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata47 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultMathPolygonPicker = __decorate65([injectable(), __param34(0, inject(PolygonRender)), __metadata47("design:paramtypes", [Object])], DefaultMathPolygonPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-module.js
var loadPolygonPick = false;
var polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = true, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-picker.js
var __decorate66 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata48 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPathPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultMathPathPicker = __decorate66([injectable(), __param35(0, inject(PathRender)), __metadata48("design:paramtypes", [Object])], DefaultMathPathPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-module.js
var loadPathPick = false;
var pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = true, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/common/rect-picker-base.js
var _bounds = new AABBBounds();
var RectPickerBase = class {
  constructor() {
    this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point5, params2) {
    if (!rect.AABBBounds.containsPoint(point5)) return false;
    if ("imprecise" === rect.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const rectAttribute = rect.getGraphicTheme(), { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point6 = rect.getOffsetXY(rectAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || rect.shadowRoot || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num)) picked = false, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, rectAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = rectAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
    });
    else {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill) picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point5);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-picker.js
var __decorate67 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata49 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathRectPicker = __decorate67([injectable(), __param36(0, inject(RectRender)), __metadata49("design:paramtypes", [Object])], DefaultMathRectPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-module.js
var loadRectPick = false;
var rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = true, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/richtext-module.js
var loadRichTextPick = false;
var richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-picker.js
var __decorate68 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata50 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathSymbolPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
};
DefaultMathSymbolPicker = __decorate68([injectable(), __param37(0, inject(SymbolRender)), __metadata50("design:paramtypes", [Object])], DefaultMathSymbolPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-module.js
var loadSymbolPick = false;
var symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = true, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-picker.js
var __decorate69 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point5, params2) {
    return !!text2.AABBBounds.containsPoint(point5);
  }
};
DefaultMathTextPicker = __decorate69([injectable()], DefaultMathTextPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-module.js
var loadTextPick = false;
var textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = true, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/math-module.js
var mathPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
});
function loadMathPicker(c2) {
  c2.load(module_default4), c2.load(mathPickerModule), c2.load(arcMathPickModule), c2.load(areaMathPickModule), c2.load(circleMathPickModule), c2.load(glyphMathPickModule), c2.load(imageMathPickModule), c2.load(lineMathPickModule), c2.load(polygonMathPickModule), c2.load(pathMathPickModule), c2.load(rectMathPickModule), c2.load(richTextMathPickModule), c2.load(symbolMathPickModule), c2.load(textMathPickModule);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/canvas-wrap.js
var CanvasWrapDisableWH = class {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {
  }
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {
  }
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {
  }
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {
  }
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
};
var CanvasWrapEnableWH = class {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {
    this._w = w / this.dpr, this.nativeCanvas.width = w;
  }
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {
    this._h = h / this.dpr, this.nativeCanvas.height = h;
  }
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {
    this._w = w, this.nativeCanvas.width = w * this.dpr;
  }
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {
    this._h = h, this.nativeCanvas.height = h * this.dpr;
  }
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/feishu-contribution.js
var __decorate70 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata51 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : tt.getSystemInfoSync().pixelRatio;
  canvasIdLists.forEach((id, i) => {
    const ctx = tt.createCanvasContext(id), canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
  });
}
var FeishuEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "feishu", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.pixelRatio));
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return this.canvasMap.get(str2);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
};
FeishuEnvContribution = __decorate70([injectable(), __metadata51("design:paramtypes", [])], FeishuEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/feishu.js
var feishuEnvModule = new ContainerModule((bind) => {
  feishuEnvModule.isFeishuBound || (feishuEnvModule.isFeishuBound = true, bind(FeishuEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(FeishuEnvContribution));
});
feishuEnvModule.isFeishuBound = false;
function loadFeishuEnv(container2, loadPicker = true) {
  loadFeishuEnv.__loaded || (loadFeishuEnv.__loaded = true, container2.load(feishuEnvModule), container2.load(feishuCanvasModule), container2.load(feishuWindowModule), loadPicker && loadMathPicker(container2));
}
loadFeishuEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/context.js
var __decorate71 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var LynxContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments2) {
    const a2 = arguments, _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a2[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale, lineDashOffset = defaultParams.lineDashOffset } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || !lineDash || (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text2, method = application.global.measureTextMethod) {
    this.setTransform(1, 0, 0, 1, 0, 0, true, application.global.devicePixelRatio);
    return {
      width: super.measureText(text2, method).width,
      fontBoundingBoxDescent: void 0,
      fontBoundingBoxAscent: void 0,
      actualBoundingBoxAscent: void 0,
      actualBoundingBoxDescent: void 0
    };
  }
  createPattern(image, repetition) {
    return null;
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
};
LynxContext2d.env = "lynx", LynxContext2d = __decorate71([injectable()], LynxContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/canvas.js
var __decorate72 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata52 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var LynxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new LynxContext2d(this, this._dpr);
  }
  resize(width, height) {
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight, this._nativeCanvas.nativeCanvas && (this._nativeCanvas.nativeCanvas.width = this._pixelWidth, this._nativeCanvas.nativeCanvas.height = this._pixelHeight);
    this._context.dpr = this._dpr;
  }
  release(...params2) {
  }
};
LynxCanvas.env = "lynx", LynxCanvas = __decorate72([injectable(), __metadata52("design:paramtypes", [Object])], LynxCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/lynx-contribution.js
var __decorate73 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata53 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager2 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var LynxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "lynx", this.eventManager = new MiniAppEventManager2();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new LynxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new LynxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches && event2.changedTouches[0] && (event2.offsetX = event2.changedTouches[0].x, event2.changedTouches[0].offsetX = event2.changedTouches[0].x, event2.changedTouches[0].clientX = event2.changedTouches[0].x, event2.offsetY = event2.changedTouches[0].y, event2.changedTouches[0].offsetY = event2.changedTouches[0].y, event2.changedTouches[0].clientY = event2.changedTouches[0].y), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate73([injectable(), __param38(0, inject(VGlobal)), __metadata53("design:paramtypes", [Object])], LynxWindowHandlerContribution);
var lynxWindowModule = new ContainerModule((bind) => {
  bind(LynxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(LynxWindowHandlerContribution)).whenTargetNamed(LynxWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/modules.js
var lynxCanvasModule = createModule(LynxCanvas, LynxContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/lynx-contribution.js
var __decorate74 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata54 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var ng = false;
try {
  ng = !!lynx.createCanvasNG;
} catch (err) {
}
function makeUpCanvas2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, offscreen, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : SystemInfo.pixelRatio;
  if (canvasIdLists.forEach((id, i) => {
    let _canvas;
    offscreen ? _canvas = lynx.createOffscreenCanvas() : (_canvas = ng ? lynx.createCanvasNG(id) : lynx.createCanvas(id), ng && _canvas.attachToCanvasView(id)), _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"), canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), i > freeCanvasIdx && freeCanvasList.push(canvas);
  }), !freeCanvasList.length && lynx.createOffscreenCanvas) {
    const _canvas = lynx.createOffscreenCanvas();
    _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"), id = Math.random().toString(), canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), freeCanvasList.push(canvas);
  }
}
function createImageElement2(src, isSvg2 = false) {
  if (isSvg2) return Promise.reject();
  const img = lynx.createImage(src);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var LynxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "lynx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas2(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, !!params2.offscreen, params2.pixelRatio));
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
    return createImageElement2(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return SystemInfo.pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return this.canvasMap.get(str2);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
LynxEnvContribution = __decorate74([injectable(), __metadata54("design:paramtypes", [])], LynxEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/lynx.js
var lynxEnvModule = new ContainerModule((bind) => {
  lynxEnvModule.isLynxBound || (lynxEnvModule.isLynxBound = true, bind(LynxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(LynxEnvContribution));
});
lynxEnvModule.isLynxBound = false;
function loadLynxEnv(container2, loadPicker = true) {
  loadLynxEnv.__loaded || (loadLynxEnv.__loaded = true, container2.load(lynxEnvModule), container2.load(lynxCanvasModule), container2.load(lynxWindowModule), loadPicker && loadMathPicker(container2));
}
loadLynxEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/node/context.js
var __decorate75 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata55 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var NodeContext2d = class extends BrowserContext2d {
  constructor(canvas, dpr) {
    super(canvas, dpr);
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
  }
  release(...params2) {
  }
};
NodeContext2d.env = "node", NodeContext2d = __decorate75([injectable(), __metadata55("design:paramtypes", [Object, Number])], NodeContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/node/canvas.js
var __decorate76 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata56 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var NodeCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
  }
  release(...params2) {
    this._nativeCanvas.release && isFunction_default(this._nativeCanvas.release) && this._nativeCanvas.release();
  }
};
NodeCanvas.env = "node", NodeCanvas = __decorate76([injectable(), __metadata56("design:paramtypes", [Object])], NodeCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/node/modules.js
var nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/node-contribution.js
var __decorate77 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata57 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "node";
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: true
    };
    this.canvas = new NodeCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    const canvas = params2.canvas, dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : 1;
    let width = params2.width, height = params2.height;
    null != width && null != height && params2.canvasControled || (width = canvas.width / dpr, height = canvas.height / dpr), this.canvas = new NodeCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer(type = "image/png") {
    return this.canvas.nativeCanvas.toBuffer(type);
  }
  addEventListener(type, listener, options) {
  }
  dispatchEvent(event2) {
    return true;
  }
  removeEventListener(type, listener, options) {
  }
  getStyle() {
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(color) {
  }
};
NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate77([injectable(), __param39(0, inject(VGlobal)), __metadata57("design:paramtypes", [Object])], NodeWindowHandlerContribution);
var nodeWindowModule = new ContainerModule((bind) => {
  bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/node-contribution.js
var __decorate78 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = false;
  }
  configure(service, pkg) {
    service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadImage(url) {
    const { loadImage } = this.pkg;
    return loadImage ? loadImage(url).then((image) => ({
      loadState: image ? "success" : "fail",
      data: image
    })).catch(() => ({
      loadState: "fail",
      data: null
    })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(svgStr) {
    const Resvg = this.pkg.Resvg;
    if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
    const pngData = new Resvg(svgStr).render().asPng();
    return this.loadImage(pngData);
  }
  createCanvas(params2) {
    return this.pkg.createCanvas(params2.width, params2.height);
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
  }
  removeEventListener(type, listener, options) {
  }
  getElementById(str2) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(event2) {
  }
  release(...params2) {
  }
  createOffscreenCanvas(params2) {
  }
};
NodeEnvContribution = __decorate78([injectable()], NodeEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/node.js
var nodeEnvModule = new ContainerModule((bind) => {
  nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = true, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
});
nodeEnvModule.isNodeBound = false;
function loadNodeEnv(container2, loadPicker = true) {
  loadNodeEnv.__loaded || (loadNodeEnv.__loaded = true, container2.load(nodeEnvModule), container2.load(nodeCanvasModule), container2.load(nodeWindowModule));
}
loadNodeEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/context.js
var __decorate79 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TaroContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
  }
  draw() {
    this.nativeContext.draw();
  }
  strokeText(text2, x, y) {
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), _context.setFillStyle(createColor(this, fill, params2, offsetX, offsetY)));
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineDashOffset = defaultParams.lineDashOffset, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale } = attribute;
      _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth(keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr)), _context.setStrokeStyle(createColor(this, stroke2, params2, offsetX, offsetY)), _context.setLineJoin(lineJoin), lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.setLineCap(lineCap), _context.setMiterLimit(miterLimit);
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
    var _a;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams), _context.setFontSize(null !== (_a = params2.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
  }
  setTextStyle(params2, defaultParams) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams), _context.setTextAlign(null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), _context.setTextBaseline(null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  createPattern(image, repetition) {
    return null;
  }
  getImageData(sx, sy, sw, sh) {
    const ctx = this.nativeContext, taro = ctx.taro;
    if (ctx && taro) return !ctx.getImageData && taro.canvasGetImageData ? new Promise((resolve, reject) => {
      try {
        taro.canvasGetImageData({
          canvasId: this.canvas.nativeCanvas.id,
          sx,
          sy,
          sw,
          sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    }) : void 0;
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createCircularGradient && this.nativeContext.createCircularGradient(x0, y0, r0, x1, y1, r1);
  }
};
TaroContext2d.env = "taro", TaroContext2d = __decorate79([injectable()], TaroContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/canvas.js
var __decorate80 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata58 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var TaroCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new TaroContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
TaroCanvas.env = "taro", TaroCanvas = __decorate80([injectable(), __metadata58("design:paramtypes", [Object])], TaroCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/modules.js
var taroCanvasModule = createModule(TaroCanvas, TaroContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/taro-contribution.js
var __decorate81 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata59 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager3 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var TaroWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "taro", this.eventManager = new MiniAppEventManager3();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new TaroCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TaroCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches.length > 0 && (event2.changedTouches.forEach((d, i) => {
      event2.changedTouches[i] = Object.assign(Object.assign({}, event2.changedTouches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event2.offsetX = event2.changedTouches[0].offsetX, event2.offsetY = event2.changedTouches[0].offsetY), event2.touches.length > 0 && event2.touches.forEach((d, i) => {
      event2.touches[i] = Object.assign(Object.assign({}, event2.touches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate81([injectable(), __param40(0, inject(VGlobal)), __metadata59("design:paramtypes", [Object])], TaroWindowHandlerContribution);
var taroWindowModule = new ContainerModule((bind) => {
  bind(TaroWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(TaroWindowHandlerContribution)).whenTargetNamed(TaroWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/taro-contribution.js
var __decorate82 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata60 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function makeUpCanvas3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
  canvasIdLists.forEach((id, i) => {
    const ctx = taro.createCanvasContext(id), canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    return ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), canvas;
  });
}
var TaroEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "taro", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas3(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.taro, params2.pixelRatio), this.taro = params2.taro, this.pixelRatio = params2.pixelRatio);
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(svgStr) {
    const _window = window || globalThis;
    if (_window.DOMParser) {
      const svg = new _window.DOMParser().parseFromString(svgStr, "image/svg+xml").children[0], data = new XMLSerializer().serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    if (_window.Blob) {
      const data = new _window.Blob([svgStr], {
        type: "image/svg+xml"
      }), url = _window.URL.createObjectURL(data);
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return this.pixelRatio;
  }
  getRequestAnimationFrame() {
    return requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return this.canvasMap.get(str2);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
TaroEnvContribution = __decorate82([injectable(), __metadata60("design:paramtypes", [])], TaroEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/taro.js
var taroEnvModule = new ContainerModule((bind) => {
  taroEnvModule.isTaroBound || (taroEnvModule.isTaroBound = true, bind(TaroEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TaroEnvContribution));
});
taroEnvModule.isTaroBound = false;
function loadTaroEnv(container2, loadPicker = true) {
  loadTaroEnv.__loaded || (loadTaroEnv.__loaded = true, container2.load(taroEnvModule), container2.load(taroCanvasModule), container2.load(taroWindowModule), loadPicker && loadMathPicker(container2));
}
loadTaroEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/context.js
var __decorate83 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var WxContext2d = class extends BrowserContext2d {
  draw() {
  }
  createPattern(image, repetition) {
    return null;
  }
};
WxContext2d.env = "wx", WxContext2d = __decorate83([injectable()], WxContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/canvas.js
var __decorate84 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata61 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var WxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new WxContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
WxCanvas.env = "wx", WxCanvas = __decorate84([injectable(), __metadata61("design:paramtypes", [Object])], WxCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/modules.js
var wxCanvasModule = createModule(WxCanvas, WxContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/wx-contribution.js
var __decorate85 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata62 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager4 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "wx", this.eventManager = new MiniAppEventManager4();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new WxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    var _a, _b, _c, _d;
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches && event2.changedTouches[0] && (event2.offsetX = event2.changedTouches[0].x, event2.changedTouches[0].offsetX = null !== (_a = event2.changedTouches[0].x) && void 0 !== _a ? _a : event2.changedTouches[0].pageX, event2.changedTouches[0].clientX = null !== (_b = event2.changedTouches[0].x) && void 0 !== _b ? _b : event2.changedTouches[0].pageX, event2.offsetY = event2.changedTouches[0].y, event2.changedTouches[0].offsetY = null !== (_c = event2.changedTouches[0].y) && void 0 !== _c ? _c : event2.changedTouches[0].pageY, event2.changedTouches[0].clientY = null !== (_d = event2.changedTouches[0].y) && void 0 !== _d ? _d : event2.changedTouches[0].pageY), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate85([injectable(), __param41(0, inject(VGlobal)), __metadata62("design:paramtypes", [Object])], WxWindowHandlerContribution);
var wxWindowModule = new ContainerModule((bind) => {
  bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(WxWindowHandlerContribution)).whenTargetNamed(WxWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/wx-contribution.js
var __decorate86 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata63 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas4(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component, forceUpdate) {
  return __awaiter7(this, void 0, void 0, function* () {
    const dpr = wx.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      !forceUpdate && canvasMap.has(id) || (yield new Promise((resolve) => {
        let data = wx.createSelectorQuery();
        component && (data = data.in(component)), data.select(`#${id}`).fields({
          node: true,
          size: true
        }).exec((res) => {
          if (!res[0]) return;
          const canvas = res[0].node, width = res[0].width, height = res[0].height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      }));
    }
  });
}
var WxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "wx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas4(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component, params2.forceUpdate).then(() => {
    });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return wx.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return this.canvasMap.get(str2);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
};
WxEnvContribution = __decorate86([injectable(), __metadata63("design:paramtypes", [])], WxEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/wx.js
var wxEnvModule = new ContainerModule((bind) => {
  wxEnvModule._isWxBound || (wxEnvModule._isWxBound = true, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
});
wxEnvModule._isWxBound = false;
function loadWxEnv(container2, loadPicker = true) {
  loadWxEnv.__loaded || (loadWxEnv.__loaded = true, container2.load(wxEnvModule), container2.load(wxCanvasModule), container2.load(wxWindowModule), loadPicker && loadMathPicker(container2));
}
loadWxEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/all.js
function loadAllModule(container2) {
  loadAllModule.__loaded || (loadAllModule.__loaded = true, loadBrowserEnv(container2, false), loadFeishuEnv(container2, false), loadLynxEnv(container2, false), loadNodeEnv(container2, false), loadTaroEnv(container2, false), loadWxEnv(container2, false), loadCanvasPicker(container2), vglobal.hooks.onSetEnv.tap("loadMathPicker", (lastEnv, env) => {
    "browser" !== env && loadMathPicker(container2);
  }));
}
loadAllModule.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/context.js
var __decorate87 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TTContext2d = class extends FeishuContext2d {
};
TTContext2d.env = "tt", TTContext2d = __decorate87([injectable()], TTContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/canvas.js
var __decorate88 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata64 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var TTCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new TTContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
TTCanvas.env = "tt", TTCanvas = __decorate88([injectable(), __metadata64("design:paramtypes", [Object])], TTCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/modules.js
var ttCanvasModule = createModule(TTCanvas, TTContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/tt-contribution.js
var __decorate89 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata65 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager5 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var TTWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "tt", this.eventManager = new MiniAppEventManager5();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new TTCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TTCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches && event2.changedTouches[0] && (event2.offsetX = event2.changedTouches[0].x, event2.changedTouches[0].offsetX = event2.changedTouches[0].x, event2.changedTouches[0].clientX = event2.changedTouches[0].x, event2.offsetY = event2.changedTouches[0].y, event2.changedTouches[0].offsetY = event2.changedTouches[0].y, event2.changedTouches[0].clientY = event2.changedTouches[0].y), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TTWindowHandlerContribution.env = "tt", TTWindowHandlerContribution = __decorate89([injectable(), __param42(0, inject(VGlobal)), __metadata65("design:paramtypes", [Object])], TTWindowHandlerContribution);
var ttWindowModule = new ContainerModule((bind) => {
  bind(TTWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(TTWindowHandlerContribution)).whenTargetNamed(TTWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/tt-contribution.js
var __decorate90 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata66 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas5(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component) {
  return __awaiter8(this, void 0, void 0, function* () {
    const dpr = tt.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      yield new Promise((resolve) => {
        let data = tt.createSelectorQuery();
        component && (data = data.in(component)), data.select(`#${id}`).node().exec((res) => {
          const canvas = res[0].node, width = canvas.width, height = canvas.height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      });
    }
  });
}
var TTEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "tt", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas5(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component).then(() => {
    });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return this.canvasMap.get(str2);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
};
TTEnvContribution = __decorate90([injectable(), __metadata66("design:paramtypes", [])], TTEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/tt.js
var ttEnvModule = new ContainerModule((bind) => {
  ttEnvModule.isTTBound || (ttEnvModule.isTTBound = true, bind(TTEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TTEnvContribution));
});
ttEnvModule.isTTBound = false;
function loadTTEnv(container2, loadPicker = true) {
  loadTTEnv.__loaded || (loadTTEnv.__loaded = true, container2.load(ttEnvModule), container2.load(ttCanvasModule), container2.load(ttWindowModule), loadPicker && loadMathPicker(container2));
}
loadTTEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/context.js
var __decorate91 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var HarmonyContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments2) {
    const a2 = arguments, _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a2[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale, lineDashOffset = defaultParams.lineDashOffset } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || (lineDash && _context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text2, method = application.global.measureTextMethod) {
    this.setTransform(1, 0, 0, 1, 0, 0, true, application.global.devicePixelRatio);
    return super.measureText(text2, method);
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    let font = "";
    font = params2.font ? params2.font : getContextFont(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    let font = "";
    font = params2.font ? params2.font : getContextFont(params2, defaultParams, this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  createPattern(image, repetition) {
    return null;
  }
  drawImage() {
    const _context = this.nativeContext, a2 = arguments;
    a2[0].drawImage && (a2[0] = a2[0].transferToImageBitmap()), 3 === a2.length ? _context.drawImage(a2[0], a2[1], a2[2]) : 5 === a2.length ? _context.drawImage(a2[0], a2[1], a2[2], a2[3], a2[4]) : 9 === a2.length && _context.drawImage(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8]);
  }
  draw() {
  }
};
HarmonyContext2d.env = "harmony", HarmonyContext2d = __decorate91([injectable()], HarmonyContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/canvas.js
var __decorate92 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata67 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var HarmonyCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new HarmonyContext2d(this, this._dpr);
  }
  resize(width, height) {
  }
  release(...params2) {
  }
};
HarmonyCanvas.env = "harmony", HarmonyCanvas = __decorate92([injectable(), __metadata67("design:paramtypes", [Object])], HarmonyCanvas);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/window/contributions/harmony-contribution.js
var __decorate93 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata68 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager6 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var HarmonyWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global2) {
    super(), this.global = global2, this.type = "harmony", this.eventManager = new MiniAppEventManager6();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new HarmonyCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    this.canvas = new HarmonyCanvas({
      width,
      height,
      dpr: 1,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event2) {
    const { type } = event2;
    return !!this.eventManager.cache[type] && (event2.changedTouches && event2.changedTouches[0] && (event2.offsetX = event2.changedTouches[0].x, event2.changedTouches[0].offsetX = event2.changedTouches[0].x, event2.changedTouches[0].clientX = event2.changedTouches[0].x, event2.offsetY = event2.changedTouches[0].y, event2.changedTouches[0].offsetY = event2.changedTouches[0].y, event2.changedTouches[0].clientY = event2.changedTouches[0].y), event2.preventDefault = () => {
    }, event2.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event2);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style2) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
HarmonyWindowHandlerContribution.env = "harmony", HarmonyWindowHandlerContribution = __decorate93([injectable(), __param43(0, inject(VGlobal)), __metadata68("design:paramtypes", [Object])], HarmonyWindowHandlerContribution);
var harmonyWindowModule = new ContainerModule((bind) => {
  bind(HarmonyWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(HarmonyWindowHandlerContribution)).whenTargetNamed(HarmonyWindowHandlerContribution.env);
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/modules.js
var harmonyCanvasModule = createModule(HarmonyCanvas, HarmonyContext2d);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/contributions/harmony-contribution.js
var __decorate94 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata69 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function createCanvas(width, height, id) {
  const _c = new OffscreenCanvas(width, height), context = _c.getContext("2d");
  return new CanvasWrapDisableWH({
    width,
    height,
    context,
    _c,
    getBoundingClientRect: () => ({
      width,
      height
    }),
    getContext: () => context
  }, context, 1, width, height, id);
}
var HarmonyEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "harmony", this.supportEvent = true, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true, this.rafSTO = new RafBasedSTO(0);
  }
  configure(service, params2) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getDynamicCanvasCount() {
    return 9999;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    return createCanvas(params2.width, params2.height, params2.id);
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return (callback) => this.rafSTO.call(callback);
  }
  getCancelAnimationFrame() {
    return (h) => {
      this.rafSTO.clear(h);
    };
  }
  mapToCanvasPoint(event2) {
    var _a;
    return null === (_a = null == event2 ? void 0 : event2.type) || void 0 === _a || _a.startsWith("mouse"), event2;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event2) {
    return null;
  }
  getElementById(str2) {
    return null;
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
HarmonyEnvContribution = __decorate94([injectable(), __metadata69("design:paramtypes", [])], HarmonyEnvContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/env/harmony.js
var harmonyEnvModule = new ContainerModule((bind) => {
  harmonyEnvModule.isHarmonyBound || (harmonyEnvModule.isHarmonyBound = true, bind(HarmonyEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(HarmonyEnvContribution));
});
harmonyEnvModule.isHarmonyBound = false;
function loadHarmonyEnv(container2, loadPicker = true) {
  loadHarmonyEnv.__loaded || (loadHarmonyEnv.__loaded = true, container2.load(harmonyEnvModule), container2.load(harmonyCanvasModule), container2.load(harmonyWindowModule), loadPicker && loadMathPicker(container2));
}
loadHarmonyEnv.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-picker.js
var __decorate95 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata70 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultCanvasArcPicker = __decorate95([injectable(), __param44(0, inject(ArcRender)), __metadata70("design:paramtypes", [Object])], DefaultCanvasArcPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-module.js
var loadArcPick2 = false;
var arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick2 || (loadArcPick2 = true, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-picker.js
var __decorate96 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata71 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasRectPicker = __decorate96([injectable(), __param45(0, inject(RectRender)), __metadata71("design:paramtypes", [Object])], DefaultCanvasRectPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-module.js
var loadRectPick2 = false;
var rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick2 || (loadRectPick2 = true, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/common/base-line-picker.js
var BaseLinePicker = class extends BaseRender {
  contains(graphic, point5, params2) {
    if (!graphic.AABBBounds.containsPoint(point5)) return false;
    if ("imprecise" === graphic.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    pickContext.highPerformanceSave();
    const lineAttribute = graphic.getGraphicTheme(), data = this.transform(graphic, lineAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = lineAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = lineAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = lineAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-picker.js
var __decorate97 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata72 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLinePicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultCanvasLinePicker = __decorate97([injectable(), __param46(0, inject(LineRender)), __metadata72("design:paramtypes", [Object])], DefaultCanvasLinePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-module.js
var loadLinePick2 = false;
var lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick2 || (loadLinePick2 = true, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-picker.js
var __decorate98 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata73 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultCanvasAreaPicker = __decorate98([injectable(), __param47(0, inject(AreaRender)), __metadata73("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-module.js
var loadAreaPick2 = false;
var areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick2 || (loadAreaPick2 = true, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/common/base-3d-picker.js
var Base3dPicker = class extends BaseRender {
  contains(graphic, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    const data = this.transform(graphic, attribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params2, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-picker.js
var __decorate99 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata74 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point5)) return false;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return true;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(), data = this.transform(symbol, symbolAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = symbolAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate99([injectable(), __param48(0, inject(SymbolRender)), __metadata74("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-module.js
var loadSymbolPick2 = false;
var symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick2 || (loadSymbolPick2 = true, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-picker.js
var __decorate100 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata75 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultCanvasCirclePicker = __decorate100([injectable(), __param49(0, inject(CircleRender)), __metadata75("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-module.js
var loadCirclePick2 = false;
var circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick2 || (loadCirclePick2 = true, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-picker.js
var __decorate101 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata76 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const bounds = text2.AABBBounds;
    if (!pickContext.camera) return !!bounds.containsPoint(point5);
    pickContext.highPerformanceSave();
    const textAttribute = text2.getGraphicTheme(), { keepDirIn3d = textAttribute.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text2, textAttribute, pickContext, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.canvasRenderer.z = z;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = text2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    let picked = false;
    return this.canvasRenderer.drawShape(text2, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked) return true;
      const { fontSize = textAttribute.fontSize, textBaseline = textAttribute.textBaseline, textAlign = textAttribute.textAlign } = text2.attribute, bounds2 = text2.AABBBounds, height = bounds2.height(), width = bounds2.width(), offsetY = textLayoutOffsetY(textBaseline, height, fontSize), offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate101([injectable(), __param50(0, inject(TextRender)), __metadata76("design:paramtypes", [Object])], DefaultCanvasTextPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-module.js
var loadTextPick2 = false;
var textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick2 || (loadTextPick2 = true, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-picker.js
var __decorate102 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata77 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathPicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultCanvasPathPicker = __decorate102([injectable(), __param51(0, inject(PathRender)), __metadata77("design:paramtypes", [Object])], DefaultCanvasPathPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-module.js
var loadPathPick2 = false;
var pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick2 || (loadPathPick2 = true, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-picker.js
var __decorate103 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata78 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultCanvasPolygonPicker = __decorate103([injectable(), __param52(0, inject(PolygonRender)), __metadata78("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-module.js
var loadPolygonPick2 = false;
var polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick2 || (loadPolygonPick2 = true, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-picker.js
var __decorate104 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata79 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasGlyphPicker = __decorate104([injectable(), __param53(0, inject(GlyphRender)), __metadata79("design:paramtypes", [Object])], DefaultCanvasGlyphPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-module.js
var loadGlyphPick2 = false;
var glyphCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick2 || (loadGlyphPick2 = true, bind(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGlyphPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-picker.js
var __decorate105 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata80 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point5, params2) {
    return !!richtext.AABBBounds.containsPoint(point5);
  }
};
DefaultCanvasRichTextPicker = __decorate105([injectable(), __param54(0, inject(RichTextRender)), __metadata80("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-module.js
var loadRichtextPick = false;
var richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = true, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-picker.js
var __decorate106 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata81 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param55 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasImagePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
};
DefaultCanvasImagePicker = __decorate106([injectable(), __param55(0, inject(ImageRender)), __metadata81("design:paramtypes", [Object])], DefaultCanvasImagePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-module.js
var loadImagePick2 = false;
var imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick2 || (loadImagePick2 = true, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-picker.js
var __decorate107 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata82 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param56 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRect3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE, this.themeType = "rect";
  }
};
DefaultCanvasRect3dPicker = __decorate107([injectable(), __param56(0, inject(Rect3DRender)), __metadata82("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-module.js
var loadRect3dPick = false;
var rect3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRect3dPick || (loadRect3dPick = true, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-picker.js
var __decorate108 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata83 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param57 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArc3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE, this.themeType = "arc";
  }
};
DefaultCanvasArc3dPicker = __decorate108([injectable(), __param57(0, inject(Arc3dRender)), __metadata83("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-module.js
var loadArc3dPick = false;
var arc3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArc3dPick || (loadArc3dPick = true, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-picker.js
var __decorate109 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata84 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param58 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPyramid3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE, this.themeType = "polygon";
  }
};
DefaultCanvasPyramid3dPicker = __decorate109([injectable(), __param58(0, inject(Pyramid3dRender)), __metadata84("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-module.js
var loadPyramid3dPick = false;
var pyramid3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPyramid3dPick || (loadPyramid3dPick = true, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/graphic/gif-image.js
var import_gifuct_js = __toESM(require_lib());

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/graphic/constants.js
var GIFIMAGE_NUMBER_TYPE = Generator.GenAutoIncrementId();
var LOTTIE_NUMBER_TYPE = Generator.GenAutoIncrementId();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/graphic/gif-image.js
var GifImage = class extends Image2 {
  constructor(params2) {
    super(params2), this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE, this.loadGif();
  }
  loadGif() {
    if (isString_default(this.attribute.gifImage)) ResourceLoader.GetFile(this.attribute.gifImage, "arrayBuffer").then((res) => {
      const gif = (0, import_gifuct_js.parseGIF)(res), frames = (0, import_gifuct_js.decompressFrames)(gif, true);
      this.renderGIF(frames);
    }).catch((e) => {
      console.error("Gif load error: ", e);
    });
    else if (this.attribute.gifImage instanceof ArrayBuffer) {
      const gif = (0, import_gifuct_js.parseGIF)(this.attribute.gifImage), frames = (0, import_gifuct_js.decompressFrames)(gif, true);
      this.renderGIF(frames);
    }
  }
  renderGIF(frames) {
    this.loadedFrames = frames, this.frameIndex = 0, this.tempCanvas || (this.tempCanvas = application.global.createCanvas({}), this.tempCtx = this.tempCanvas.getContext("2d")), this.gifCanvas || (this.gifCanvas = application.global.createCanvas({}), this.gifCtx = this.gifCanvas.getContext("2d")), this.gifCanvas.width = frames[0].dims.width, this.gifCanvas.height = frames[0].dims.height, this.playing = true, this.lastTime = (/* @__PURE__ */ new Date()).getTime();
    const animation = this.animate();
    this.attribute.timeline && animation.setTimeline(this.attribute.timeline), animation.to({}, 1e3, "linear").loop(1 / 0);
  }
  renderFrame(context, x, y) {
    const frame = this.loadedFrames[this.frameIndex || 0];
    2 === frame.disposalType && this.gifCtx.clearRect(0, 0, this.gifCanvas.width, this.gifCanvas.height), this.drawPatch(frame), this.manipulate(context, x, y);
    const diff = (/* @__PURE__ */ new Date()).getTime() - this.lastTime;
    frame.delay < diff && (this.frameIndex++, this.lastTime = (/* @__PURE__ */ new Date()).getTime()), this.frameIndex >= this.loadedFrames.length && (this.frameIndex = 0);
  }
  drawPatch(frame) {
    const dims = frame.dims;
    this.frameImageData && dims.width === this.frameImageData.width && dims.height === this.frameImageData.height || (this.tempCanvas.width = dims.width, this.tempCanvas.height = dims.height, this.frameImageData = this.tempCtx.createImageData(dims.width, dims.height)), this.frameImageData.data.set(frame.patch), this.tempCtx.putImageData(this.frameImageData, 0, 0), this.gifCtx.drawImage(this.tempCanvas, dims.left, dims.top);
  }
  manipulate(context, x, y) {
    context.drawImage(this.gifCanvas, 0, 0, this.gifCanvas.width, this.gifCanvas.height, x, y, this.attribute.width, this.attribute.height);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), "gifImage" === key && this.loadGif();
  }
  setAttributes(params2, forceUpdateTag, context) {
    super.setAttributes(params2, forceUpdateTag, context), params2.gifImage && this.loadGif();
  }
};
function createGifImage(attributes) {
  return new GifImage(attributes);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/gif-image-picker.js
var __decorate110 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGifImagePicker = class {
  constructor() {
    this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE;
  }
  contains(gifImage, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!gifImage.AABBBounds.containsPoint(point5);
  }
};
DefaultCanvasGifImagePicker = __decorate110([injectable()], DefaultCanvasGifImagePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/gif-image-module.js
var loadGifImagePick = false;
var gifImageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGifImagePick || (loadGifImagePick = true, bind(CanvasGifImagePicker).to(DefaultCanvasGifImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGifImagePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/canvas/gif-image-render.js
var __decorate111 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata85 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param59 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGifImageRender = class extends DefaultCanvasImageRender {
  constructor(imageRenderContribitions) {
    super(imageRenderContribitions), this.imageRenderContribitions = imageRenderContribitions, this.numberType = GIFIMAGE_NUMBER_TYPE, this._renderContribitions = void 0, this.builtinContributions = [defaultGifImageRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image, { x: originX = imageAttribute.x, y: originY = imageAttribute.y, fillStrokeOrder = imageAttribute.fillStrokeOrder } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, _runFill = () => {
      doFill && fillCb && fillCb(context, image.attribute, imageAttribute);
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), context.restore()) : (context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { context } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasGifImageRender = __decorate111([injectable(), __param59(0, inject(ContributionProvider)), __param59(0, named(ImageRenderContribution)), __metadata85("design:paramtypes", [Object])], DefaultCanvasGifImageRender);
var DefaultGifImageRenderContribution = class extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    image.renderFrame && image.playing && image.renderFrame(context, x, y);
  }
};
var defaultGifImageRenderContribution = new DefaultGifImageRenderContribution();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/canvas/gif-image-module.js
var loadGifImageModule = false;
var gifImageModule = new ContainerModule((bind) => {
  loadGifImageModule || (loadGifImageModule = true, bind(DefaultCanvasGifImageRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasGifImageRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/graphic/Lottie.js
var import_lottie_web = __toESM(require_lottie());
var Lottie = class extends Rect {
  constructor(params2) {
    super(params2), this.type = "lottie", this.renderNextFrame = () => {
      this.stage.renderNextFrame();
    }, this.numberType = LOTTIE_NUMBER_TYPE, this.initLottieWeb(this.attribute.data);
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.data && this.initLottieWeb(params2.data), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "data" === key && this.initLottieWeb(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  initLottieWeb(data) {
    if ("browser" !== vglobal.env) return;
    this.lottieInstance && this.releaseLottieInstance();
    const theme4 = this.getGraphicTheme(), { width = theme4.width, height = theme4.height } = this.attribute, canvas = vglobal.createCanvas({
      width,
      height,
      dpr: vglobal.devicePixelRatio
    }), params2 = {
      rendererSettings: {
        context: canvas.getContext("2d")
      },
      animType: "canvas",
      loop: true
    };
    "string" == typeof data ? params2.path = data : params2.animationData = data, this.lottieInstance = import_lottie_web.default.loadAnimation(params2), this.canvas = canvas, this.lottieInstance.addEventListener("drawnFrame", this.renderNextFrame);
  }
  release() {
    super.release(), this.releaseLottieInstance();
  }
  releaseLottieInstance() {
    this.lottieInstance.removeEventListener("drawnFrame", this.renderNextFrame), this.lottieInstance.destroy(), this.lottieInstance = null;
  }
};
Lottie.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/lottie-picker.js
var __decorate112 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata86 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param60 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLottiePicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasLottiePicker = __decorate112([injectable(), __param60(0, inject(RectRender)), __metadata86("design:paramtypes", [Object])], DefaultCanvasLottiePicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/lottie-module.js
var loadLottiePick = false;
var lottieCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLottiePick || (loadLottiePick = true, bind(CanvasLottiePicker).to(DefaultCanvasLottiePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLottiePicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/canvas/lottie-render.js
var __decorate113 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasLottieRender = class extends DefaultCanvasRectRender {
  constructor() {
    super(...arguments), this.numberType = LOTTIE_NUMBER_TYPE;
  }
  drawShape(lottie, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const _fillCb = fillCb || (() => this._drawShape.call(this, lottie, context, x, y, drawContext, params2));
    super.drawShape(lottie, context, x, y, drawContext, params2, _fillCb, strokeCb);
  }
  _drawShape(lottie, context, x, y, drawContext, params2) {
    var _a;
    const lottieAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(lottie, null == params2 ? void 0 : params2.theme).rect, { x: originX = lottieAttribute.x, y: originY = lottieAttribute.y } = lottie.attribute;
    context.setCommonStyle(lottie, lottie.attribute, originX - x, originY - y, lottieAttribute);
    const canvas = lottie.canvas;
    if (canvas) {
      const pattern = context.createPattern(canvas, "no-repeat"), dpr = context.dpr;
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, x, y])), context.fillStyle = pattern;
    }
    context.fill();
  }
};
DefaultCanvasLottieRender = __decorate113([injectable()], DefaultCanvasLottieRender);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/render/contributions/canvas/lottie-module.js
var loadLottieModule = false;
var lottieModule = new ContainerModule((bind) => {
  loadLottieModule || (loadLottieModule = true, bind(DefaultCanvasLottieRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasLottieRender));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/env.js
var browser = isBrowserEnv();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-arc.js
function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = true, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = false;
var registerArc = _registerArc;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-arc3d.js
function _registerArc3d() {
  _registerArc3d.__loaded || (_registerArc3d.__loaded = true, registerArc3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
}
_registerArc3d.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-area.js
function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = true, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = false;
var registerArea = _registerArea;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-circle.js
function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = true, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = false;
var registerCircle = _registerCircle;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-glyph.js
function _registerGlyph() {
  _registerGlyph.__loaded || (_registerGlyph.__loaded = true, registerGlyphGraphic(), container.load(glyphModule), container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
}
_registerGlyph.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-group.js
function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = true, registerGroupGraphic());
}
_registerGroup.__loaded = false;
var registerGroup = _registerGroup;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-image.js
function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = true, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = false;
var registerImage = _registerImage;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-line.js
function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = true, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = false;
var registerLine = _registerLine;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-path.js
function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = true, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = false;
var registerPath = _registerPath;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-polygon.js
function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = true, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = false;
var registerPolygon = _registerPolygon;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-pyramid3d.js
function _registerPyramid3d() {
  _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = true, registerPyramid3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
}
_registerPyramid3d.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-rect.js
function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = true, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = false;
var registerRect = _registerRect;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-rect3d.js
function _registerRect3d() {
  _registerRect3d.__loaded || (_registerRect3d.__loaded = true, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
}
_registerRect3d.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-richtext.js
function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = true, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = false;
var registerRichtext = _registerRichtext;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-shadowRoot.js
function _registerShadowRoot() {
  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = true, registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = false;
var registerShadowRoot = _registerShadowRoot;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-symbol.js
function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = true, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = false;
var registerSymbol = _registerSymbol;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-text.js
function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = true, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = false;
var registerText = _registerText;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/star-picker.js
var __decorate114 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata87 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param61 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasStarPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "star", this.numberType = STAR_NUMBER_TYPE;
  }
};
DefaultCanvasStarPicker = __decorate114([injectable(), __param61(0, inject(StarRender)), __metadata87("design:paramtypes", [Object])], DefaultCanvasStarPicker);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/star-module.js
var loadStarPick = false;
var starCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadStarPick || (loadStarPick = true, bind(CanvasStarPicker).to(DefaultCanvasStarPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasStarPicker));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-star.js
function _registerStar() {
  _registerStar.__loaded || (_registerStar.__loaded = true, registerStarGraphic(), container.load(starModule), container.load(starCanvasPickModule));
}
_registerStar.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-wraptext.js
function _registerWrapText() {
  _registerWrapText.__loaded || (_registerWrapText.__loaded = true, registerWrapTextGraphic());
}
_registerWrapText.__loaded = false;
var registerWrapText = _registerWrapText;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-kits/es/register/register-gif.js
function registerGifGraphic() {
  graphicCreator.RegisterGraphicCreator("gif", createGifImage);
}
function _registerGifImage() {
  _registerGifImage.__loaded || (_registerGifImage.__loaded = true, registerGifGraphic(), container.load(gifImageModule), container.load(gifImageCanvasPickModule));
}
_registerGifImage.__loaded = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/scrollbar/register.js
function loadScrollbarComponent() {
  registerGroup(), registerRect();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/constant.js
var POLAR_START_ANGLE = -0.5 * Math.PI;
var POLAR_END_ANGLE = 1.5 * Math.PI;
var DEFAULT_TEXT_FONT_FAMILY2 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";
var DEFAULT_TEXT_FONT_SIZE = 14;
var StateValue;
!function(StateValue2) {
  StateValue2.selected = "selected", StateValue2.selectedReverse = "selected_reverse", StateValue2.hover = "hover", StateValue2.hoverReverse = "hover_reverse";
}(StateValue || (StateValue = {}));
var DEFAULT_STATES = {
  [StateValue.selectedReverse]: {},
  [StateValue.selected]: {},
  [StateValue.hover]: {},
  [StateValue.hoverReverse]: {}
};
var DEFAULT_HTML_TEXT_SPEC = {
  container: "",
  width: 30,
  height: 30,
  style: {}
};
var SCROLLBAR_START_EVENT = "scrollDown";
var SCROLLBAR_EVENT = "scrollDrag";
var SCROLLBAR_END_EVENT = "scrollUp";

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/event.js
function getEndTriggersOfDrag() {
  return "browser" === vglobal.env ? ["pointerup", "pointerleave", "pointercancel"] : ["pointerup", "pointerleave", "pointerupoutside"];
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/scrollbar/scrollbar.js
var delayMap = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadScrollbarComponent();
var ScrollBar = class _ScrollBar extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ScrollBar.defaultAttributes, attributes)), this.name = "scrollbar", this._handleTouchMove = (e) => {
      isValid_default(this._prePos) && e.preventDefault();
    }, this._onRailPointerDown = (e) => {
      const { viewX, viewY } = e, { direction, width, height, range: range5 } = this.attribute, sliderSize = this._sliderSize, [min2, max2] = this._getScrollRange();
      let currentScrollValue;
      if ("vertical" === direction) {
        const relativeY = viewY - this._viewPosition.y, currentYPos = clamp_default(relativeY - sliderSize / 2, min2, max2);
        currentScrollValue = relativeY / height, this._slider.setAttribute("y", currentYPos, true);
      } else {
        const relativeX = viewX - this._viewPosition.x, currentXPos = clamp_default(relativeX - sliderSize / 2, min2, max2);
        currentScrollValue = relativeX / width, this._slider.setAttribute("x", currentXPos, true);
      }
      this.setScrollRange([currentScrollValue - (range5[1] - range5[0]) / 2, currentScrollValue + (range5[1] - range5[0]) / 2], false), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
    }, this._onSliderPointerDown = (e) => {
      this._clearDragEvents();
      const { stopSliderDownPropagation = true } = this.attribute;
      stopSliderDownPropagation && e.stopPropagation();
      const { direction } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      this._prePos = "horizontal" === direction ? x : y, this._dispatchEvent(SCROLLBAR_START_EVENT, {
        pos: this._prePos,
        event: e
      });
      const triggers = getEndTriggersOfDrag(), obj2 = "browser" === vglobal.env ? vglobal : this.stage;
      obj2.addEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj2.addEventListener(trigger, this._onSliderPointerUp);
      });
    }, this._computeScrollValue = (e) => {
      const { direction } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      let currentScrollValue, currentPos, delta = 0;
      const { width, height } = this.getSliderRenderBounds();
      return "vertical" === direction ? (currentPos = y, delta = currentPos - this._prePos, currentScrollValue = delta / height) : (currentPos = x, delta = currentPos - this._prePos, currentScrollValue = delta / width), [currentPos, currentScrollValue];
    }, this._onSliderPointerMove = (e) => {
      const { stopSliderMovePropagation = true } = this.attribute;
      stopSliderMovePropagation && e.stopPropagation();
      const preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e);
      this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this._prePos = currentPos;
    }, this._onSliderPointerMoveWithDelay = 0 === this.attribute.delayTime ? this._onSliderPointerMove : delayMap[this.attribute.delayType](this._onSliderPointerMove, this.attribute.delayTime), this._onSliderPointerUp = (e) => {
      const { range: preRange, limitRange = [0, 1] } = this.attribute, preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e), range5 = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
      this._prePos = null, this._dispatchEvent(SCROLLBAR_END_EVENT, {
        pre: preRange,
        value: clampRange_default(range5, limitRange[0], limitRange[1])
      }), this._clearDragEvents();
    };
  }
  setScrollRange(range5, render = true) {
    const { direction = "horizontal", limitRange = [0, 1], range: preRange, realTime = true } = this.attribute, currScrollRange = clampRange_default(range5, limitRange[0], limitRange[1]);
    if (render) {
      const sliderPos = this._getSliderPos(currScrollRange);
      if (this._slider) {
        const sliderSize = sliderPos[1] - sliderPos[0];
        this._sliderSize = sliderSize, "horizontal" === direction ? this._slider.setAttributes({
          x: sliderPos[0],
          width: sliderSize
        }, true) : this._slider.setAttributes({
          y: sliderPos[0],
          height: sliderSize
        }, true), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
      }
    }
    this.attribute.range = currScrollRange, realTime && this._dispatchEvent(SCROLLBAR_EVENT, {
      pre: preRange,
      value: currScrollRange
    });
  }
  getScrollRange() {
    return this.attribute.range;
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { delayType = "throttle", delayTime = 0 } = this.attribute;
    this._rail && this._rail.addEventListener("pointerdown", delayMap[delayType](this._onRailPointerDown, delayTime)), this._slider && this._slider.addEventListener("pointerdown", this._onSliderPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    });
  }
  render() {
    this._reset();
    const { direction = "horizontal", width, height, range: range5, limitRange = [0, 1], railStyle, sliderStyle, padding = 2 } = this.attribute, group = this.createOrUpdateChild("scrollbar-container", {}, "group"), rail = group.createOrUpdateChild("scrollbar-rail", Object.assign({
      x: 0,
      y: 0,
      width,
      height
    }, railStyle), "rect");
    this._rail = rail;
    const sliderRenderBounds = this.getSliderRenderBounds(), sliderPos = this._getSliderPos(clampRange_default(range5, limitRange[0], limitRange[1])), sliderSize = sliderPos[1] - sliderPos[0];
    let sliderAttribute;
    this._sliderSize = sliderSize, sliderAttribute = "horizontal" === direction ? {
      x: sliderPos[0],
      y: sliderRenderBounds.y1,
      width: sliderSize,
      height: sliderRenderBounds.height
    } : {
      x: sliderRenderBounds.x1,
      y: sliderPos[0],
      width: sliderRenderBounds.width,
      height: sliderSize
    };
    const slider = group.createOrUpdateChild("slider", Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), {
      cornerRadius: this._getDefaultSliderCornerRadius()
    }), sliderStyle), {
      boundsPadding: normalizePadding(padding),
      pickMode: "imprecise"
    }), "rect");
    this._slider = slider, this._container = group;
    const containerAABBBounds = this._container.AABBBounds;
    this._viewPosition = {
      x: containerAABBBounds.x1,
      y: containerAABBBounds.y1
    };
  }
  getSliderRenderBounds() {
    if (this._sliderRenderBounds) return this._sliderRenderBounds;
    const { width, height, padding = 2 } = this.attribute, [top, right, bottom, left] = normalizePadding(padding), renderBounds = {
      x1: left,
      y1: top,
      x2: width - right,
      y2: height - bottom,
      width: Math.max(0, width - (left + right)),
      height: Math.max(0, height - (top + bottom))
    };
    return this._sliderRenderBounds = renderBounds, renderBounds;
  }
  _getDefaultSliderCornerRadius() {
    const { direction, round } = this.attribute;
    if (round) {
      const { width, height } = this.getSliderRenderBounds();
      return "horizontal" === direction ? height : width;
    }
    return 0;
  }
  _getSliderPos(range5) {
    const { direction } = this.attribute, { width, height, x1, y1 } = this.getSliderRenderBounds();
    return "horizontal" === direction ? [width * range5[0] + x1, width * range5[1] + x1] : [height * range5[0] + y1, height * range5[1] + y1];
  }
  _getScrollRange() {
    if (this._sliderLimitRange) return this._sliderLimitRange;
    const { limitRange = [0, 1], direction } = this.attribute, [min2, max2] = clampRange_default(limitRange, 0, 1), { width, height, x1, y1 } = this.getSliderRenderBounds(), sliderSize = this._sliderSize;
    return "horizontal" === direction ? clampRange_default([x1 + min2 * width, x1 + max2 * width], x1, width - sliderSize) : clampRange_default([y1 + min2 * height, y1 + max2 * height], y1, height - sliderSize);
  }
  _clearDragEvents() {
    const triggers = getEndTriggersOfDrag(), obj2 = "browser" === vglobal.env ? vglobal : this.stage;
    obj2.removeEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj2.removeEventListener(trigger, this._onSliderPointerUp);
    });
  }
  _reset() {
    this._sliderRenderBounds = null, this._sliderLimitRange = null;
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearDragEvents();
  }
};
ScrollBar.defaultAttributes = {
  direction: "horizontal",
  round: true,
  sliderSize: 20,
  sliderStyle: {
    fill: "rgba(0, 0, 0, .5)"
  },
  railStyle: {
    fill: "rgba(0, 0, 0, .0)"
  },
  padding: 2,
  scrollRange: [0, 1],
  delayType: "throttle",
  delayTime: 0,
  realTime: true
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/scrollbar/scrollbar-plugin.js
var ScrollBarPlugin_1;
var __decorate115 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScrollBarPlugin = ScrollBarPlugin_1 = class {
  constructor() {
    this.name = "scrollbar", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.scroll = (e) => {
      var _a, _b;
      const graphic = e.target, data = this.getScrollContainer(graphic);
      if (!data && !this.scrollContainer) return;
      if (!data && this.scrollContainer) {
        if (!this.scrollContainer.g.stage || this.scrollContainer.g.stage !== graphic.stage) return;
        const newScrollContainer = this.formatScrollContainer(this.scrollContainer.g);
        if (!newScrollContainer) return void this.clearScrollbar(this.scrollContainer.g, "all");
        this.scrollContainer.showH && !newScrollContainer.showH && this.clearScrollbar(this.scrollContainer.g, "horizontal"), this.scrollContainer.showV && !newScrollContainer.showV && this.clearScrollbar(this.scrollContainer.g, "vertical"), this.scrollContainer = newScrollContainer;
      } else data && this.scrollContainer && data.g !== this.scrollContainer.g && this.clearScrollbar(this.scrollContainer.g, "all");
      if (this.scrollContainer = null != data ? data : this.scrollContainer, !data) return;
      const scrollContainer = data.g;
      if (!scrollContainer) return;
      const { width, height, scrollX = 0, scrollY = 0 } = scrollContainer.attribute;
      let newScrollX = scrollX, newScrollY = scrollY, { showH, showV } = data;
      this.scrollContainerBounds = new Bounds().set(0, 0, scrollContainer.attribute.width, scrollContainer.attribute.height), showH && showH && (abs(e.deltaX) > abs(e.deltaY) ? (showH = showH && true, showV = showV && false) : (showH = showH && false, showV = showV && true));
      const scrollWidth = this.childrenBounds.width(), scrollHeight = this.childrenBounds.height();
      showH && (newScrollX = scrollX - (null !== (_a = e.deltaX) && void 0 !== _a ? _a : 0), newScrollX > 0 ? newScrollX = 0 : newScrollX < width - scrollWidth && (newScrollX = width - scrollWidth)), showV && (newScrollY = scrollY - (null !== (_b = e.deltaY) && void 0 !== _b ? _b : 0), newScrollY > 0 ? newScrollY = 0 : newScrollY < height - scrollHeight && (newScrollY = height - scrollHeight)), scrollContainer.setAttributes({
        scrollX: newScrollX,
        scrollY: newScrollY
      }), this.addOrUpdateScroll(showH, showV, scrollContainer.parent, scrollContainer);
    }, this.handleScrollBarChange = (params2) => {
      if (!(this.scrollContainer && this.scrollContainerBounds && this.childrenBounds && params2 && params2.target && params2.detail && params2.detail.value)) return;
      const scrollbar = params2.target, newRange = params2.detail.value;
      if ("horizontal" === scrollbar.attribute.direction) {
        const scrollWidth = this.childrenBounds.width();
        this.scrollContainer.g.setAttributes({
          scrollX: -newRange[0] * scrollWidth
        });
      } else {
        const scrollHeight = this.childrenBounds.height();
        this.scrollContainer.g.setAttributes({
          scrollY: -newRange[0] * scrollHeight
        });
      }
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    this.childrenBounds = new AABBBounds(), stage.addEventListener("wheel", this.scroll), this.params = ScrollBarPlugin_1.defaultParams;
  }
  initEventOfScrollbar(scrollContainer, scrollbar, isHorozntal) {
    scrollContainer.addEventListener("pointerover", () => {
      scrollbar.setAttribute("visibleAll", true);
    }), scrollContainer.addEventListener("pointermove", () => {
      scrollbar.setAttribute("visibleAll", true);
    }), scrollContainer.addEventListener("pointerout", () => {
      scrollbar.setAttribute("visibleAll", false);
    }), scrollbar.addEventListener("pointerover", () => {
      scrollbar.setAttribute("visibleAll", true);
    }), scrollbar.addEventListener("pointerout", () => {
      scrollbar.setAttribute("visibleAll", true);
    }), scrollbar.addEventListener("scrollUp", this.handleScrollBarChange), scrollbar.addEventListener(SCROLLBAR_EVENT, this.handleScrollBarChange);
  }
  addOrUpdateScroll(showH, showV, container2, scrollContainer) {
    if (showH) {
      const { scrollBar: hScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container2, true);
      isUpdate || this.initEventOfScrollbar(scrollContainer, hScrollbar, true);
    } else this.clearScrollbar(scrollContainer, "horizontal");
    if (showV) {
      const { scrollBar: vScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container2, false);
      isUpdate || this.initEventOfScrollbar(scrollContainer, vScrollbar, false);
    } else this.clearScrollbar(scrollContainer, "vertical");
  }
  getDirection(isHorozntal) {
    return isHorozntal ? "horizontal" : "vertical";
  }
  addOrUpdateHScroll(scrollContainer, container2, isHorozntal) {
    var _a, _b;
    const direction = this.getDirection(isHorozntal), name = `${null !== (_a = scrollContainer.name) && void 0 !== _a ? _a : scrollContainer._uid}_${this.getDirection(isHorozntal)}_${this.name}`, scrollbars = container2.children.filter((g) => g.name === name);
    let isUpdate = true, scrollBar = scrollbars[0];
    const { y = 0, dy = 0, x = 0, dx = 0, height, width, zIndex = 0 } = this.scrollContainer.g.attribute, attrs = {
      x: 0,
      y: 0,
      direction,
      zIndex: zIndex + 1,
      visibleAll: true,
      padding: [2, 0],
      railStyle: {
        fill: "rgba(0, 0, 0, .1)"
      },
      range: [0, 0.05]
    };
    isHorozntal ? (attrs.width = this.scrollContainerBounds.width(), attrs.height = 12) : (attrs.height = this.scrollContainerBounds.height(), attrs.width = 12), scrollBar ? scrollbars.length > 1 && scrollbars.forEach((child, index) => {
      var _a2;
      index && (null === (_a2 = child.parent) || void 0 === _a2 || _a2.removeChild(child));
    }) : (isUpdate = false, scrollBar = new ScrollBar(attrs), scrollBar.name = name, container2.add(scrollBar), scrollBar.isScrollBar = true);
    const childrenBounds = this.childrenBounds, { scrollX, scrollY } = scrollContainer.attribute;
    if (isHorozntal) {
      const ratio = Math.min(this.scrollContainerBounds.width() / childrenBounds.width(), 1), start = Math.max(Math.min(scrollX / this.childrenBounds.width(), 0), ratio - 1);
      attrs.x = x + dx, attrs.y = y + dy + height - (null !== (_b = attrs.height) && void 0 !== _b ? _b : 0), attrs.range = [-start, -start + ratio];
    } else {
      const ratio = Math.min(this.scrollContainerBounds.height() / childrenBounds.height(), 1), start = Math.max(Math.min(scrollY / this.childrenBounds.height(), 0), ratio - 1);
      attrs.x = x + dx + width - this.scrollContainerBounds.width(), attrs.y = y + dy, attrs.range = [-start, -start + ratio];
    }
    return scrollBar.setAttributes(attrs), {
      scrollBar,
      isUpdate
    };
  }
  clearScrollbar(scrollContainer, type) {
    if (!scrollContainer.parent) return;
    scrollContainer.parent.children.filter((child) => child.isScrollBar && ("all" === type || child.attribute.direction === type)).forEach((child) => {
      child.parent.removeChild(child);
    });
  }
  formatScrollContainer(g) {
    if (!g || "group" !== g.type || !g.attribute) return null;
    const { overflow, width, height } = g.attribute;
    if (!overflow || "hidden" === overflow) return null;
    let showH = false, showV = false;
    "scroll" === overflow ? (showH = true, showV = true) : (showH = "scroll-x" === overflow, showV = !showH);
    const childrenBounds = this.childrenBounds;
    return childrenBounds.clear(), g.forEachChildren((g2) => {
      childrenBounds.union(g2.AABBBounds);
    }), g.AABBBounds.empty() || (showH && (showH = width < childrenBounds.width()), showV && (showV = height < childrenBounds.height())), showH || showV ? {
      g,
      showH,
      showV
    } : null;
  }
  getScrollContainer(graphic) {
    let g = graphic;
    for (; g; ) {
      const res = this.formatScrollContainer(g);
      if (res) return res;
      g = g.parent;
    }
    return null;
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("wheel", this.scroll);
  }
};
ScrollBarPlugin.defaultParams = {
  timeout: 500
}, ScrollBarPlugin = ScrollBarPlugin_1 = __decorate115([injectable()], ScrollBarPlugin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/scrollbar/module.js
var scrollbarModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(ScrollBarPlugin) || (bind(ScrollBarPlugin).toSelf(), bind(AutoEnablePlugins).toService(ScrollBarPlugin));
});

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/common.js
function traverseGroup(group, cb) {
  group.forEachChildren((node) => {
    const stopped = cb(node);
    node.isContainer && !stopped && traverseGroup(node, cb);
  });
}
var isVisible = (obj2) => !isNil_default(obj2) && false !== obj2.visible;
function getMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.getChildren() : [];
}
function getNoneGroupMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.findAll((node) => "group" !== node.type, true) : [];
}
function removeRepeatPoint(points) {
  const result2 = [points[0]];
  for (let i = 1; i < points.length; i++) points[i].x === points[i - 1].x && points[i].y === points[i - 1].y || result2.push(points[i]);
  return result2;
}
function isPostiveXAxis(angle2) {
  return angle2 >= 0 && angle2 < Math.PI / 2 || angle2 > 3 * Math.PI / 2 && angle2 <= 2 * Math.PI;
}
function fuzzyEqualNumber(a2, b, delta) {
  return Math.abs(a2 - b) < delta;
}
function getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) {
  return autoRotate2 ? {
    textAlign: "right",
    textBaseline: "middle"
  } : {
    textAlign: lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("top") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") ? "left" : lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("top") ? "right" : "center",
    textBaseline: lineEndAngle < Math.PI && itemPosition.includes("inside") || lineEndAngle > Math.PI && !itemPosition.includes("inside") ? "bottom" : "top"
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/label-smartInvert.js
var defaultAlternativeColors = ["#ffffff", "#000000"];
function labelSmartInvert(foregroundColorOrigin, backgroundColorOrogin, textType, contrastRatiosThreshold, alternativeColors, mode) {
  if ("string" != typeof foregroundColorOrigin || "string" != typeof backgroundColorOrogin) return foregroundColorOrigin;
  const foregroundColor = new Color(foregroundColorOrigin).toHex(), backgroundColor = new Color(backgroundColorOrogin).toHex();
  return contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) ? foregroundColor : improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode);
}
function improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode) {
  const alternativeColorPalletes = [];
  alternativeColors && (alternativeColors instanceof Array ? alternativeColorPalletes.push(...alternativeColors) : alternativeColorPalletes.push(alternativeColors)), alternativeColorPalletes.push(...defaultAlternativeColors);
  for (const alternativeColor of alternativeColorPalletes) if (foregroundColor !== alternativeColor && contrastAccessibilityChecker(alternativeColor, backgroundColor, textType, contrastRatiosThreshold, mode)) return alternativeColor;
}
function contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) {
  if ("lightness" === mode) {
    const backgroundColorLightness = Color.getColorBrightness(new Color(backgroundColor));
    return Color.getColorBrightness(new Color(foregroundColor)) < 0.5 ? backgroundColorLightness >= 0.5 : backgroundColorLightness < 0.5;
  }
  return contrastRatiosThreshold ? contrastRatios(foregroundColor, backgroundColor) > contrastRatiosThreshold : "largeText" === textType ? contrastRatios(foregroundColor, backgroundColor) > 3 : contrastRatios(foregroundColor, backgroundColor) > 4.5;
}
function contrastRatios(foregroundColor, backgroundColor) {
  const foregroundColorLuminance = getColorLuminance(foregroundColor), backgroundColorLuminance = getColorLuminance(backgroundColor);
  return ((foregroundColorLuminance > backgroundColorLuminance ? foregroundColorLuminance : backgroundColorLuminance) + 0.05) / ((foregroundColorLuminance > backgroundColorLuminance ? backgroundColorLuminance : foregroundColorLuminance) + 0.05);
}
function getColorLuminance(color) {
  const rgb8bit = hexToRgb(color), RsRGB = rgb8bit[0] / 255, GsRGB = rgb8bit[1] / 255, BsRGB = rgb8bit[2] / 255;
  let R, G, B;
  R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4), G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4), B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
function smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor) {
  let result2;
  switch (fillStrategy) {
    case "base":
      result2 = baseColor;
      break;
    case "invertBase":
      result2 = invertColor;
      break;
    case "similarBase":
      result2 = similarColor;
  }
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/matrix.js
function scale2(vector, scale6) {
  return [vector[0] * scale6, vector[1] * scale6];
}
function length(vector) {
  const [x, y] = vector;
  return Math.sqrt(x * x + y * y);
}
function normalize(vector) {
  let len = length(vector);
  return len > 0 && (len = 1 / len), [vector[0] * len, vector[1] * len];
}
function angle(vector1, vector2) {
  const [x1, y1] = vector1, [x2, y2] = vector2, mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function angleTo(v1, v2, direct) {
  const ang = angle(v1, v2), angleLargeThanPI = crossProduct(v1, v2) >= 0;
  return direct ? angleLargeThanPI ? 2 * Math.PI - ang : ang : angleLargeThanPI ? ang : 2 * Math.PI - ang;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/text.js
var initTextMeasure = (textSpec, option, useNaiveCanvas, defaultFontParams) => new TextMeasure(Object.assign({
  defaultFontParams: Object.assign({
    fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
    fontSize: DEFAULT_TEXT_FONT_SIZE
  }, defaultFontParams),
  getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
  specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
}, null != option ? option : {}), textSpec);
function measureTextSize(text2, textSpec, defaultTextTheme = {}) {
  if (!text2) return {
    width: 0,
    height: 0
  };
  const bounds = getTextBounds({
    text: text2,
    fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY2,
    fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
    fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
    textAlign: textSpec.textAlign || "center",
    textBaseline: textSpec.textBaseline,
    ellipsis: !!textSpec.ellipsis,
    maxLineWidth: textSpec.maxLineWidth || 1 / 0,
    lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
  });
  return {
    width: bounds.width(),
    height: bounds.height()
  };
}
function isRichText(attributes, typeKey = "type") {
  return "rich" === getTextType(attributes, typeKey);
}
function getTextType(attributes, typeKey = "type") {
  var _a, _b;
  return isObject_default(attributes.text) && "type" in attributes.text ? null !== (_a = attributes.text.type) && void 0 !== _a ? _a : "text" : typeKey in attributes && null !== (_b = attributes[typeKey]) && void 0 !== _b ? _b : "text";
}
function richTextAttributeTransform(attributes) {
  var _a, _b;
  return isValid_default(attributes.maxLineWidth) && (attributes.maxWidth = attributes.maxLineWidth, delete attributes.maxLineWidth), attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0, attributes.textConfig = attributes.text.text || attributes.text, attributes;
}
function htmlAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: html } = text2;
  return attributes.html = html, attributes.text = _originText, attributes.renderable = false, attributes;
}
function reactAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: react } = text2;
  return attributes.react = react, attributes.text = _originText, attributes.renderable = false, attributes;
}
function createTextGraphicByType(textAttributes, typeKey = "type") {
  const textType = getTextType(textAttributes, typeKey);
  return "rich" === textType ? graphicCreator.richtext(richTextAttributeTransform(textAttributes)) : ("html" === textType ? textAttributes = htmlAttributeTransform(textAttributes) : "react" === textType && (textAttributes = reactAttributeTransform(textAttributes)), graphicCreator.text(textAttributes));
}
function alignTextInLine(layoutAlign, graphic, textAlign, pos, textWidth) {
  "right" === layoutAlign ? "center" === textAlign ? graphic.setAttribute("x", pos - textWidth / 2) : "right" === textAlign || "end" === textAlign ? graphic.setAttribute("x", pos) : graphic.setAttribute("x", pos - textWidth) : "center" === textAlign ? graphic.setAttribute("x", pos + textWidth / 2) : "right" === textAlign || "end" === textAlign ? graphic.setAttribute("x", pos + textWidth) : graphic.setAttribute("x", pos);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/polar.js
var deltaXYToAngle = (y, x) => {
  const angle2 = Math.atan2(y, x);
  return angle2 < 0 ? angle2 + 2 * Math.PI : angle2;
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/limit-shape.js
function computeOffsetForlimit(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1, y1, x2, y2 } = shape.AABBBounds;
  let dx = 0, dy = 0;
  return x1 < regionMinX && (dx = regionMinX - x1), y1 < regionMinY && (dy = regionMinY - y1), x2 > regionMaxX && (dx = regionMaxX - x2), y2 > regionMaxY && (dy = regionMaxY - y2), {
    dx,
    dy
  };
}
function limitShapeInBounds(shape, bounds) {
  const { dx, dy } = computeOffsetForlimit(shape, bounds), { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tag/register.js
function loadTagComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tag/tag.js
var __rest2 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadTagComponent();
var Tag = class _Tag extends AbstractComponent {
  getBgRect() {
    return this._bgRect;
  }
  getTextShape() {
    return this._textShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tag.defaultAttributes, attributes)), this.name = "tag", this._tagStates = [], this._rectStates = [], this._symbolStates = [], this._textStates = [];
  }
  render() {
    var _a, _b, _c;
    this.cacheStates();
    const { text: text2 = "", textStyle = {}, shape = {}, panel = {}, space = 4, minWidth, maxWidth, padding = 4, visible, state, type, textAlwaysCenter, containerTextAlign } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("tag-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    let symbol, tagX = -parsedPadding[3], tagY = -parsedPadding[0], tagWidth = parsedPadding[1] + parsedPadding[3], tagHeight = parsedPadding[0] + parsedPadding[2], textX = 0, symbolPlaceWidth = 0;
    const { visible: shapeVisible } = shape, shapeStyle = __rest2(shape, ["visible"]);
    if (isBoolean_default(shapeVisible)) {
      const size2 = (null == shapeStyle ? void 0 : shapeStyle.size) || 10, maxSize2 = isNumber_default(size2) ? size2 : Math.max(size2[0], size2[1]);
      symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
        symbolType: "circle",
        size: size2,
        strokeBoundsBuffer: 0
      }, shapeStyle), {
        visible: shapeVisible,
        x: maxSize2 / 2,
        y: maxSize2 / 2
      }), "symbol"), isEmpty_default(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize2 + space);
    }
    let textShape, textWidth, textHeight;
    tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth;
    if (isRichText({
      text: text2
    }) || "rich" === type) {
      const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({
        type,
        text: text2
      }, textStyle))), textStyle), {
        visible: isValid_default(text2) && false !== visible,
        x: textX,
        y: 0
      });
      isNil_default(richTextAttrs.lineHeight) && (richTextAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext"), textWidth = textShape.AABBBounds.width(), textHeight = textShape.AABBBounds.height();
    } else {
      const textAttrs = Object.assign(Object.assign({
        text: isObject_default(text2) && "type" in text2 && "text" === text2.type ? text2.text : text2,
        visible: isValid_default(text2) && false !== visible,
        lineHeight: null == textStyle ? void 0 : textStyle.fontSize
      }, textStyle), {
        x: textX,
        y: 0
      });
      isNil_default(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text");
      const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text);
      textWidth = textBounds.width, textHeight = textBounds.height;
    }
    tagWidth += textWidth;
    const size = null !== (_c = shape.size) && void 0 !== _c ? _c : 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
    tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
    const { textAlign, textBaseline } = textStyle;
    (isValid_default(minWidth) || isValid_default(maxWidth)) && (isValid_default(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid_default(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2]))), tagX = 0, tagY = 0;
    let flag = 0;
    "left" === textAlign || "start" === textAlign ? flag = 1 : "right" === textAlign || "end" === textAlign ? flag = -1 : "center" === textAlign && (flag = 0), flag ? flag < 0 ? (tagX -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : flag > 0 && group.setAttribute("x", parsedPadding[3]) : (tagX -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2));
    const shouldRight = "right" === containerTextAlign || "end" === containerTextAlign, shouldLeft = "left" === containerTextAlign || "start" === containerTextAlign, updateTextAttrs = (textX2, textAlign2) => {
      "richtext" === textShape.type ? textShape.setAttributes({
        x: textX2,
        textAlign: textAlign2,
        textConfig: array(textShape.attribute.textConfig).map((t) => Object.assign(Object.assign({}, t), {
          textAlign: textAlign2
        }))
      }) : textShape.setAttributes({
        x: textX2,
        textAlign: textAlign2
      });
    };
    if ((containerTextAlign ? "center" === containerTextAlign : textAlwaysCenter) && flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], tsWidth = textWidth + symbolPlaceWidth, textX2 = 1 === flag ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2 : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
      if (updateTextAttrs(textX2, "center"), symbol) {
        const symbolX = textX2 - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    if (shouldLeft && 1 !== flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], offset = 0 === flag ? -containerWidth / 2 + symbolPlaceWidth / 2 : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth;
      if (updateTextAttrs(offset + symbolPlaceWidth, "left"), symbol) {
        const symbolX = offset + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    if (shouldRight && -1 !== flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], textX2 = 0 === flag ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
      if (updateTextAttrs(textX2, "right"), symbol) {
        const symbolX = textX2 - textWidth - symbolPlaceWidth + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    "middle" === textBaseline ? (tagY -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (tagY -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2)), isEmpty_default(null == state ? void 0 : state.text) || (textShape.states = state.text);
    const { visible: bgVisible } = panel, backgroundStyle = __rest2(panel, ["visible"]);
    if (visible && isBoolean_default(bgVisible)) {
      const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
        visible: bgVisible && !!text2,
        width: tagWidth,
        height: tagHeight,
        x: tagX,
        y: tagY
      }), "rect");
      if (isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), backgroundStyle.customShape) {
        const customShape = backgroundStyle.customShape;
        bgRect.pathProxy = (attrs) => customShape(this, attrs, new CustomPath2D());
      }
      this._bgRect = bgRect;
    }
    this._textShape = textShape, this._symbol = symbol, this.resetStates();
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Tag.defaultAttributes, params2), super.initAttributes(params2), this.render();
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    super.addState(stateName, keepCurrentStates, hasAnimation), this._textShape && this._textShape.addState(stateName, keepCurrentStates, hasAnimation), this._bgRect && this._bgRect.addState(stateName, keepCurrentStates, hasAnimation), this._symbol && this._symbol.addState(stateName, keepCurrentStates, hasAnimation);
  }
  removeState(stateName, hasAnimation) {
    super.removeState(stateName, hasAnimation), this._textShape && this._textShape.removeState(stateName, hasAnimation), this._bgRect && this._bgRect.removeState(stateName, hasAnimation), this._symbol && this._symbol.removeState(stateName, hasAnimation);
  }
  cacheStates() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    this._tagStates = null !== (_b = null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.slice()) && void 0 !== _b ? _b : [], this._rectStates = null !== (_e = null === (_d = null === (_c = this._bgRect) || void 0 === _c ? void 0 : _c.currentStates) || void 0 === _d ? void 0 : _d.slice()) && void 0 !== _e ? _e : [], this._symbolStates = null !== (_h = null === (_g = null === (_f = this._symbol) || void 0 === _f ? void 0 : _f.currentStates) || void 0 === _g ? void 0 : _g.slice()) && void 0 !== _h ? _h : [], this._textStates = null !== (_l = null === (_k = null === (_j = this._textShape) || void 0 === _j ? void 0 : _j.currentStates) || void 0 === _k ? void 0 : _k.slice()) && void 0 !== _l ? _l : [], this.clearStates(), null === (_m = this._bgRect) || void 0 === _m || _m.clearStates(), null === (_o = this._symbol) || void 0 === _o || _o.clearStates(), null === (_p = this._textShape) || void 0 === _p || _p.clearStates();
  }
  resetStates() {
    var _a, _b, _c;
    this._tagStates.length && this.useStates(this._tagStates), this._rectStates.length && (null === (_a = this._bgRect) || void 0 === _a || _a.useStates(this._rectStates)), this._symbolStates.length && (null === (_b = this._symbol) || void 0 === _b || _b.useStates(this._symbolStates)), this._textStates.length && (null === (_c = this._textShape) || void 0 === _c || _c.useStates(this._textStates));
  }
};
Tag.defaultAttributes = {
  visible: true,
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  space: 4,
  padding: 4,
  shape: {
    fill: "#000"
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/theme.js
var DEFAULT_THEME = {
  visible: true,
  position: "auto",
  titleStyle: {
    fontSize: 16,
    fill: "#08979c"
  },
  contentStyle: {
    fontSize: 12,
    fill: "green"
  },
  panel: {
    visible: true,
    fill: "#e6fffb",
    size: 12,
    space: 0,
    stroke: "#87e8de",
    lineWidth: 1,
    cornerRadius: 4
  }
};
var theme = {
  poptip: merge({}, DEFAULT_THEME)
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/register.js
function loadPoptipComponent() {
  registerGroup(), registerText(), registerSymbol(), registerRect();
}
function setPoptipTheme(defaultPoptipTheme) {
  merge(theme.poptip, DEFAULT_THEME, defaultPoptipTheme);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/poptip.js
var __rest3 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var _tBounds = new AABBBounds();
loadPoptipComponent();
var tlStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 -0.5, Z";
var blStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 0.5, Z";
var trStr = "M -0.5 -0.5, L 0.5 -0.5, L 0.5 0.5, Z";
var brStr = "M 0.5 -0.5, L 0.5 0.5, L -0.5 0.5, Z";
var conciseSymbolMap = {
  tl: tlStr,
  tr: trStr,
  bl: blStr,
  br: brStr,
  lt: tlStr,
  lb: blStr,
  rt: trStr,
  rb: brStr
};
var PopTip = class _PopTip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PopTip.defaultAttributes, attributes)), this.name = "poptip", this.positionList = ["top", "tl", "tr", "bottom", "bl", "br", "left", "lt", "lb", "right", "rt", "rb"];
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { titleStyle = {}, position, contentStyle = {}, panel, logoSymbol, poptipAnchor = "position", logoText, logoTextStyle = {}, triangleMode = "default", space = 4, minWidth = 0, maxWidth = 1 / 0, padding = 4, maxWidthPercent, visible, state, dx = 0, dy = 0, positionBounds } = this.attribute;
    let { title = "", content = "" } = this.attribute;
    title = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title) : title, content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
    const parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("poptip-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    this.group = group;
    const maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3], titleVisible = isValid_default(title) && false !== visible, titleAttrs = Object.assign(Object.assign({
      text: isArray_default(title) ? title : [title],
      visible: titleVisible,
      wrap: true
    }, titleStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0],
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), titleShape = group.createOrUpdateChild("poptip-title", titleAttrs, "text");
    isEmpty_default(null == state ? void 0 : state.title) || (titleShape.states = state.title);
    const titleBounds = titleShape.AABBBounds, titleHeight = titleBounds.height(), titleWidth = titleBounds.width();
    let height = titleHeight + space;
    titleVisible || (height = 0);
    const contentVisible = isValid_default(content) && false !== visible, contentAttrs = Object.assign(Object.assign({
      text: isArray_default(content) ? content : [content],
      visible: contentVisible,
      wrap: true
    }, contentStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0] + height,
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), contentShape = group.createOrUpdateChild("poptip-content", contentAttrs, "text");
    isEmpty_default(null == state ? void 0 : state.content) || (contentShape.states = state.content);
    const contentBounds = contentShape.AABBBounds, contentHeight = contentBounds.height(), contentWidth = contentBounds.width();
    contentVisible && (height += contentHeight), this.titleShape = titleShape, this.contentShape = contentShape;
    let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
    popTipWidth > maxWidth ? popTipWidth = maxWidth : popTipWidth < minWidth && (popTipWidth = minWidth);
    let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
    const { visible: bgVisible, square: square4 } = panel, backgroundStyle = __rest3(panel, ["visible", "square"]);
    if (square4) {
      const maxWH = max(popTipWidth, poptipHeight);
      popTipWidth = maxWH;
      const deltaH = maxWH - poptipHeight;
      poptipHeight = maxWH, titleShape.setAttributes({
        dy: deltaH / 2
      }), contentShape.setAttributes({
        dy: deltaH / 2
      });
    }
    const symbolSize = null !== (_a = backgroundStyle.size) && void 0 !== _a ? _a : 12, spaceSize = isArray_default(symbolSize) ? [symbolSize[0] + (null !== (_b = backgroundStyle.space) && void 0 !== _b ? _b : 0), symbolSize[1] + (null !== (_c = backgroundStyle.space) && void 0 !== _c ? _c : 0)] : symbolSize + (null !== (_d = backgroundStyle.space) && void 0 !== _d ? _d : 0), lineWidth = null !== (_e = backgroundStyle.lineWidth) && void 0 !== _e ? _e : 1, range5 = this.stage ? [null !== (_f = this.stage.viewWidth) && void 0 !== _f ? _f : this.stage.width, null !== (_g = this.stage.viewHeight) && void 0 !== _g ? _g : this.stage.height] : void 0;
    if (range5) {
      const b = this.AABBBounds, leftWidth = null !== (_h = this.attribute.x) && void 0 !== _h ? _h : b.x1, rightWidth = range5[0] - b.x1;
      let maxSpace = Math.max(leftWidth, rightWidth);
      const buf = (isArray_default(symbolSize) ? symbolSize[0] : 12) + 3;
      if (maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent), maxSpace < popTipWidth) {
        popTipWidth = maxSpace;
        const buf2 = parsedPadding[1] + parsedPadding[3];
        titleShape.setAttribute("maxLineWidth", maxSpace - buf2), contentShape.setAttribute("maxLineWidth", maxSpace - buf2), poptipHeight = parsedPadding[0] + parsedPadding[2], titleVisible && (poptipHeight += titleShape.AABBBounds.height() + space), poptipHeight += contentShape.AABBBounds.height();
      }
    }
    const layout = "auto" === position || isArray_default(position), positionList = isArray_default(position) ? position : this.positionList;
    let maxBBoxI, maxBBoxSize = -1 / 0;
    for (let i = 0; i < positionList.length + 1; i++) {
      const p = layout ? positionList[i === positionList.length ? maxBBoxI : i] : position;
      let symbolType = "arrow2Left", offsetX = (isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 4, offsetY = 0;
      "top" === p || "bottom" === p || "left" === p || "right" === p ? symbolType = "arrow2Left" : "concise" === triangleMode && (symbolType = conciseSymbolMap[p], offsetX = ["tl", "bl", "rt", "rb"].includes(p) ? (isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 2 : -(isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 2, offsetY = ["tl", "tr", "lb", "rb"].includes(p) ? -(isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2 : (isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2);
      const { angle: angle2, offset } = this.getAngleAndOffset(p, popTipWidth, poptipHeight, isArray_default(spaceSize) ? spaceSize : [spaceSize, spaceSize - lineWidth], symbolType);
      let bgSymbol, anchorPoint = {
        x: 0,
        y: 0
      };
      if ("bounds" === poptipAnchor && positionBounds && (anchorPoint = this.calculateAnchorPoint(p, positionBounds)), isBoolean_default(bgVisible)) {
        let bgRect;
        bgSymbol = group.createOrUpdateChild("poptip-symbol-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: offsetX,
          y: offsetY,
          strokeBoundsBuffer: -1,
          boundsPadding: -2,
          anchor: [0, 0],
          symbolType,
          angle: angle2,
          dx: offset[0],
          dy: offset[1] - (null !== (_j = backgroundStyle.space) && void 0 !== _j ? _j : 0),
          size: symbolSize,
          zIndex: 9
        }), "symbol"), isEmpty_default(null == state ? void 0 : state.panel) || (bgSymbol.states = state.panel), bgRect = panel.panelSymbolType ? group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: 0,
          y: 0,
          symbolType: "rect",
          size: [popTipWidth, poptipHeight],
          zIndex: -8
        }), "symbol") : group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: 0,
          y: 0,
          width: popTipWidth,
          height: poptipHeight,
          zIndex: -8
        }), "rect"), isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
      if (group.setAttributes({
        x: -offset[0] + dx + anchorPoint.x,
        y: -offset[1] + dy + anchorPoint.y,
        anchor: [offsetX, offsetY]
      }), logoSymbol) {
        const { size = 12 } = logoSymbol, sizeArray = isArray_default(size) ? size : [size, size];
        "auto" === sizeArray[1] && (sizeArray[1] = poptipHeight), "auto" === sizeArray[0] && (sizeArray[0] = poptipHeight);
        const sizeW = sizeArray[0];
        group.createOrUpdateChild("poptip-logo", Object.assign(Object.assign({}, logoSymbol), {
          x: 0,
          y: poptipHeight / 2,
          visible: bgVisible && (contentVisible || titleVisible),
          zIndex: 10,
          size: sizeArray
        }), "symbol"), group.setAttributes({
          x: -offset[0] + dx + sizeW / 2,
          y: -offset[1] + dy
        }), logoText && group.createOrUpdateChild("poptip-logo-text", Object.assign(Object.assign({}, logoTextStyle), {
          x: 0,
          y: poptipHeight / 2,
          visible: bgVisible && (contentVisible || titleVisible),
          text: logoText,
          textAlign: "center",
          textBaseline: "middle",
          zIndex: 10
        }), "text");
      }
      if (!range5) break;
      {
        _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
        const b = _tBounds, stageBounds = new Bounds().setValue(0, 0, range5[0], range5[1]);
        if (layout) {
          if (rectInsideAnotherRect(b, stageBounds, false)) break;
          {
            const bbox = getRectIntersect(b, stageBounds, false), size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
            size > maxBBoxSize && (maxBBoxSize = size, maxBBoxI = i);
          }
        }
        if (["top", "bottom", "left", "right"].includes(p)) {
          const isVerticalPosition = "top" === p || "bottom" === p, isHorizontalPosition = "left" === p || "right" === p;
          let mainDirectionOverlap = false;
          if (isVerticalPosition ? mainDirectionOverlap = "top" === p && b.y1 < 0 || "bottom" === p && b.y2 > stageBounds.y2 : isHorizontalPosition && (mainDirectionOverlap = "left" === p && b.x1 < 0 || "right" === p && b.x2 > stageBounds.x2), !mainDirectionOverlap) {
            let secondaryOffset = 0;
            const szNumber = (isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2;
            isVerticalPosition ? (b.x1 < 0 ? secondaryOffset = -b.x1 : b.x2 > stageBounds.x2 && (secondaryOffset = stageBounds.x2 - b.x2), group.setAttribute("x", group.attribute.x + secondaryOffset), bgSymbol.setAttribute("dx", min(max(bgSymbol.attribute.dx - secondaryOffset, szNumber), b.width() - szNumber))) : isHorizontalPosition && (b.y1 < 0 ? secondaryOffset = -b.y1 : b.y2 > stageBounds.y2 && (secondaryOffset = stageBounds.y2 - b.y2), group.setAttribute("y", group.attribute.y + secondaryOffset), bgSymbol.setAttribute("dy", min(max(bgSymbol.attribute.dy - secondaryOffset, szNumber), b.height() - szNumber)));
            break;
          }
        }
        if (!layout) break;
      }
    }
  }
  calculateAnchorPoint(position, positionBounds) {
    if (!positionBounds) return {
      x: 0,
      y: 0
    };
    const { x, y } = this.attribute, { x1, y1, x2, y2 } = positionBounds, width = x2 - x1, height = y2 - y1;
    switch (position) {
      case "top":
      case "tl":
      case "tr":
        return {
          x: x1 + width / 2 - x,
          y: y1 - y
        };
      case "bottom":
      case "bl":
      case "br":
        return {
          x: x1 + width / 2 - x,
          y: y2 - y
        };
      case "left":
      case "lt":
      case "lb":
        return {
          x: x1 - x,
          y: y1 + height / 2 - y
        };
      case "right":
      case "rt":
      case "rb":
        return {
          x: x2 - x,
          y: y1 + height / 2 - y
        };
      default:
        return {
          x: 0,
          y: 0
        };
    }
  }
  getAngleAndOffset(position, width, height, size, symbolType) {
    const sizeH = "arrow2Left" === symbolType ? size[1] / 2 : size[1];
    switch (position) {
      case "tl":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4, height + sizeH] : [0, height + sizeH]
        };
      case "top":
        return {
          angle: pi / 2 * 3,
          offset: [width / 2, height + sizeH]
        };
      case "tr":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4 * 3, height + sizeH] : [width, height + sizeH]
        };
      case "rt":
        return {
          angle: 0,
          offset: "arrow2Left" === symbolType ? [-sizeH, height / 5] : [-sizeH, 0]
        };
      case "right":
        return {
          angle: 0,
          offset: [-sizeH, height / 2]
        };
      case "rb":
        return {
          angle: 0,
          offset: "arrow2Left" === symbolType ? [-sizeH, height / 5 * 4] : [-sizeH, height]
        };
      case "bl":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4, -sizeH] : [0, -sizeH]
        };
      case "bottom":
        return {
          angle: pi / 2,
          offset: [width / 2, -sizeH]
        };
      case "br":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4 * 3, -sizeH] : [width, -sizeH]
        };
      case "lt":
        return {
          angle: "arrow2Left" === symbolType ? pi : 0,
          offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5] : [width + sizeH, 0]
        };
      case "left":
        return {
          angle: pi,
          offset: [width + sizeH, height / 2]
        };
      case "lb":
        return {
          angle: "arrow2Left" === symbolType ? pi : 0,
          offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5 * 4] : [width + sizeH, height]
        };
    }
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig;
    if (this.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this.animate().to({
      scaleX: 1,
      scaleY: 1
    }, duration / 3 * 2, easing), this.titleShape && this.titleShape.animate().play(new InputText({
      text: ""
    }, {
      text: this.titleShape.attribute.text
    }, duration, easing)), this.contentShape && this.contentShape.animate().play(new InputText({
      text: ""
    }, {
      text: this.contentShape.attribute.text
    }, duration, easing)), animateConfig.wave) {
      const dur = duration / 6;
      this.group.animate().to({
        angle: animateConfig.wave
      }, dur, easing).to({
        angle: -animateConfig.wave
      }, 2 * dur, easing).to({
        angle: animateConfig.wave
      }, 2 * dur, easing).to({
        angle: 0
      }, dur, easing);
    }
  }
  disappearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig;
    this.animate().to({
      scaleX: 0,
      scaleY: 0
    }, duration, easing);
  }
};
PopTip.defaultAttributes = {
  position: "rt",
  visible: true,
  title: null,
  content: null,
  titleStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  contentStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  panel: {},
  maxWidthPercent: 0.8,
  space: 8,
  padding: 10
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/contribution.js
var __decorate116 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
function wrapPoptip(target, source) {
  return merge(target, theme.poptip, source), target;
}
var PopTipRenderContribution = class {
  render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    if (1 === graphic._showPoptip) {
      const { visible, visibleCb } = graphic.attribute.poptip || {};
      if (false === visible || visibleCb && false === visibleCb(graphic)) return;
      const attribute = {};
      merge(attribute, PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {}), this.poptipComponent ? this.poptipComponent.initAttributes(attribute) : this.poptipComponent = new PopTip(attribute);
      let poptip = graphic.attribute.poptip || {};
      if ("text" === graphic.type && null == poptip.title && null == poptip.content) {
        const out = {};
        wrapPoptip(out, poptip), poptip = out, poptip.content = null !== (_a = poptip.content) && void 0 !== _a ? _a : graphic.attribute.text;
      }
      const matrix = graphic.globalTransMatrix;
      this.poptipComponent.setAttributes(Object.assign(Object.assign({
        visibleAll: true,
        pickable: false,
        childrenPickable: false,
        poptipAnchor: "bounds"
      }, poptip), {
        x: matrix.e,
        y: matrix.f,
        positionBounds: graphic.globalAABBBounds
      })), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      interactiveLayer && interactiveLayer.add(this.poptipComponent);
    } else 2 === graphic._showPoptip && (graphic._showPoptip = 0, this.poptipComponent && (this.poptipComponent.setAttributes({
      visibleAll: false
    }), null === (_b = this.poptipComponent.parent) || void 0 === _b || _b.removeChild(this.poptipComponent), this.poptipComponent = null));
  }
};
PopTipRenderContribution = __decorate116([injectable()], PopTipRenderContribution);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/poptip-plugin.js
var __decorate117 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var PopTipPluginBase = class {
  constructor() {
    this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.poptip = (e) => {
      const graphic = e.target;
      this.needHide(graphic) ? this.unpoptip(e) : graphic !== this.activeGraphic && (this.needShow(graphic) && (graphic.setAttributes({}), graphic._showPoptip = 1), this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2), this.setActiveGraphic(graphic, true));
    }, this.unpoptip = (e) => {
      this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2, this.setActiveGraphic(null, true));
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    stage.addEventListener("pointerover", this.poptip);
  }
  needHide(graphic) {
    return graphic.isContainer || !graphic.attribute;
  }
  needShow(graphic) {
    return !!graphic.attribute.poptip;
  }
  setActiveGraphic(graphic, rerender) {
    this.activeGraphic = graphic, this.pluginService.stage.renderNextFrame();
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("pointerover", this.poptip);
  }
};
var PopTipPlugin = class extends PopTipPluginBase {
  constructor() {
    super(...arguments), this.name = "poptip", this.key = this.name + this._uid;
  }
};
PopTipPlugin = __decorate117([injectable()], PopTipPlugin);
var PopTipForClipedTextPlugin = class extends PopTipPluginBase {
  constructor() {
    super(...arguments), this.name = "poptipForText", this.key = this.name + this._uid, this.pointerlave = (e) => {
      const { stage } = this.pluginService;
      e.target === stage && this.unpoptip(e);
    };
  }
  activate(context) {
    super.activate(context);
    const { stage } = this.pluginService;
    stage.addEventListener("pointerleave", this.pointerlave);
  }
  needHide(graphic) {
    return "text" !== graphic.type || !graphic.cliped || graphic.isContainer || !graphic.attribute || graphic.attribute.disableAutoClipedPoptip;
  }
  needShow(graphic) {
    return true;
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    super.deactivate(context), stage.removeEventListener("pointerleave", this.pointerlave);
  }
};
PopTipForClipedTextPlugin = __decorate117([injectable()], PopTipForClipedTextPlugin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/poptip/module.js
var popTipModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(PopTipRenderContribution) || (bind(PopTipRenderContribution).toSelf().inSingletonScope(), bind(InteractiveSubRenderContribution).toService(PopTipRenderContribution)), isBound(PopTipPlugin) || (bind(PopTipPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipPlugin)), isBound(PopTipForClipedTextPlugin) || (bind(PopTipForClipedTextPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipForClipedTextPlugin));
});
function loadPoptip() {
  container.load(popTipModule);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/base.js
var CrosshairBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "crosshair";
  }
  render() {
    this.renderCrosshair(this);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/register.js
function loadLineCrosshairComponent() {
  registerGroup(), registerLine();
}
function loadCircleCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonCrosshairComponent() {
  registerGroup(), registerPath();
}
function loadRectCrosshairComponent() {
  registerGroup(), registerRect();
}
function loadSectorCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonSectorCrosshairComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/line.js
loadLineCrosshairComponent();
var LineCrosshair = class _LineCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-line", Object.assign({
      points: [start, end]
    }, lineStyle), "line");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
LineCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/rect.js
loadRectCrosshairComponent();
var RectCrosshair = class _RectCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _RectCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, rectStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-rect", Object.assign({
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    }, rectStyle), "rect");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
RectCrosshair.defaultAttributes = {
  rectStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/circle.js
loadCircleCrosshairComponent();
var CircleCrosshair = class _CircleCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center, radius, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-circle", Object.assign(Object.assign(Object.assign(Object.assign({}, center), {
      outerRadius: radius
    }), this.attribute), lineStyle), "arc");
  }
  setLocation(point5) {
    const { center } = this.attribute, radius = PointService.distancePP(point5, center);
    this.setAttribute("radius", radius);
  }
};
CircleCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: ["#b2bacf", false, false, false],
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/sector.js
loadSectorCrosshairComponent();
var SectorCrosshair = class _SectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center, radius, innerRadius = 0, sectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-sector", Object.assign(Object.assign(Object.assign({}, center), {
      outerRadius: radius,
      innerRadius,
      startAngle,
      endAngle
    }), sectorStyle), "arc");
  }
  setLocation(point5) {
    const { center, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center, point5));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
SectorCrosshair.defaultAttributes = {
  sectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/polygon.js
loadPolygonCrosshairComponent();
var PolygonCrosshair = class _PolygonCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center, radius, sides = 6, lineStyle } = this.attribute, { startAngle, endAngle } = this.attribute, isClose = (endAngle - startAngle) % (2 * Math.PI) == 0, eachAngle = (endAngle - startAngle) / sides;
    let path;
    for (let index = 0; index <= sides; index++) {
      const point5 = polarToCartesian(center, radius, startAngle + eachAngle * index);
      0 === index ? path = `M${point5.x},${point5.y}` : path += `L${point5.x},${point5.y}`, index === sides && isClose && (path += "Z");
    }
    return container2.createOrUpdateChild("crosshair-polygon", Object.assign({
      path
    }, lineStyle), "path");
  }
  setLocation(point5) {
    const { center } = this.attribute, radius = PointService.distancePP(point5, center);
    this.setAttribute("radius", radius);
  }
};
PolygonCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/segment/register.js
function loadSegmentComponent() {
  registerGroup(), registerLine(), registerPolygon(), registerSymbol();
}
function loadArcSegmentComponent() {
  registerGroup(), registerLine(), registerArc(), registerSymbol();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/segment/segment.js
loadSegmentComponent();
var Segment = class _Segment extends AbstractComponent {
  getStartAngle() {
    return normalizeAngle(this._startAngle);
  }
  getEndAngle() {
    return normalizeAngle(this._endAngle);
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Segment.defaultAttributes, attributes)), this.name = "segment", this.key = "segment", this.lines = [];
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, multiSegment, mainSegmentIndex } = this.attribute;
    if (!visible) return;
    this._computeLineAngle();
    const points = this._getMainSegmentPoints(), startSymbolShape = this._renderSymbol(startSymbol, points, "start"), endSymbolShape = this._renderSymbol(endSymbol, points, "end");
    if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
      const points2 = [...this.attribute.points];
      if (isValidNumber_default(mainSegmentIndex)) points2[mainSegmentIndex] = this._clipPoints(points2[mainSegmentIndex]);
      else {
        const clipPoints = this._clipPoints(flattenArray(points2));
        points2[0][0] = clipPoints[0], points2[points2.length - 1][points2[points2.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
      }
      points2.forEach((point5, index) => {
        var _a, _b;
        const line = graphicCreator.line(Object.assign(Object.assign({
          points: point5
        }, isArray_default(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
          fill: false
        }));
        line.name = `${this.name}-line`, line.id = this._getNodeId("line" + index), isEmpty_default(null == state ? void 0 : state.line) || (line.states = isArray_default(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line), this.lines.push(line);
      });
    } else {
      let lineCreator = graphicCreator.line;
      array(lineStyle)[0].cornerRadius && (lineCreator = graphicCreator.polygon);
      const line = lineCreator(Object.assign(Object.assign({
        points: this._clipPoints(this.attribute.points)
      }, array(lineStyle)[0]), {
        fill: false,
        closePath: false
      }));
      line.name = `${this.name}-line`, line.id = this._getNodeId("line"), isEmpty_default(null == state ? void 0 : state.line) || (line.states = [].concat(state.line)[0]), this.add(line), this.lines.push(line);
    }
  }
  _computeStartRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _computeEndRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _renderSymbol(attribute, points, dim) {
    if (!points.length) return;
    const { autoRotate: autoRotate2 = true } = attribute;
    let symbol;
    if (attribute && attribute.visible) {
      const startAngle = this.getStartAngle(), endAngle = this.getEndAngle(), { state } = this.attribute, start = points[0], end = points[points.length - 1], { refX = 0, refY = 0, refAngle = 0, style: style2, symbolType, size = 12 } = attribute;
      let position, rotate;
      "start" === dim ? (position = {
        x: start.x + (isValidNumber_default(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
        y: start.y + (isValidNumber_default(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
      }, rotate = this._computeStartRotate(this._startAngle)) : (position = {
        x: end.x + (isValidNumber_default(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
        y: end.y + (isValidNumber_default(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
      }, rotate = this._computeEndRotate(this._endAngle)), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
        symbolType,
        size,
        angle: autoRotate2 ? rotate + refAngle : 0,
        strokeBoundsBuffer: 0
      }), style2)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty_default(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), "start" === dim ? isEmpty_default(null == state ? void 0 : state.startSymbol) || (symbol.states = state.startSymbol) : isEmpty_default(null == state ? void 0 : state.endSymbol) || (symbol.states = state.endSymbol), this.add(symbol);
    }
    return symbol;
  }
  _getMainSegmentPoints() {
    if (this._mainSegmentPoints) return this._mainSegmentPoints;
    const { points: originPoints, multiSegment, mainSegmentIndex } = this.attribute;
    let points;
    return points = multiSegment ? isValidNumber_default(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
  }
  _clipPoints(points) {
    const { startSymbol = {}, endSymbol = {} } = this.attribute;
    let pointsAfterClip = points;
    if (startSymbol.visible) {
      const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
      pointsAfterClip = [{
        x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
        y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
      }, ...pointsAfterClip.slice(1)];
    }
    if (endSymbol.visible) {
      const endSize = endSymbol.clip ? endSymbol.size || 10 : 0, pointsEnd = {
        x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
        y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
      };
      pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
    }
    return pointsAfterClip;
  }
  _computeLineAngle() {
    const points = this._getMainSegmentPoints();
    if (points.length <= 1) return;
    const start = points[0], startInside = points[1], endInside = points[points.length - 2], end = points[points.length - 1], startVector = [start.x - startInside.x, start.y - startInside.y], startAngle = Math.atan2(startVector[1], startVector[0]), endVector = [end.x - endInside.x, end.y - endInside.y], endAngle = Math.atan2(endVector[1], endVector[0]);
    this._startAngle = startAngle, this._endAngle = endAngle;
  }
  _reset() {
    this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
  }
};
Segment.defaultAttributes = {
  visible: true,
  lineStyle: {
    lineWidth: 1,
    stroke: "#000"
  },
  startSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  },
  endSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/segment/arc-segment.js
loadArcSegmentComponent();
var ArcSegment = class extends Segment {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes)), this.name = "arc-segment", this.key = "arc-segment", this.isReverseArc = false;
  }
  getStartAngle() {
    const tangAng = this.isReverseArc ? this._startAngle + Math.PI / 2 : this._startAngle - Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getEndAngle() {
    const tangAng = this.isReverseArc ? this._endAngle - Math.PI / 2 : this._endAngle + Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  _computeStartRotate(angle2) {
    return this.isReverseArc ? angle2 + Math.PI : angle2;
  }
  _computeEndRotate(angle2) {
    return this.isReverseArc ? angle2 : angle2 + Math.PI;
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, radius, startAngle, endAngle, center } = this.attribute;
    if (!visible) return;
    this._startAngle = startAngle, this._endAngle = endAngle, this.isReverseArc = startAngle > endAngle;
    const startPoint = {
      x: center.x + radius * Math.cos(this._startAngle),
      y: center.y + radius * Math.sin(this._startAngle)
    }, endPoint = {
      x: center.x + radius * Math.cos(this._endAngle),
      y: center.y + radius * Math.sin(this._endAngle)
    };
    this._mainSegmentPoints = [startPoint, endPoint];
    const startSymbolShape = this._renderSymbol(startSymbol, this._mainSegmentPoints, "start"), endSymbolShape = this._renderSymbol(endSymbol, this._mainSegmentPoints, "end");
    this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape;
    const line = graphicCreator.arc(Object.assign({
      x: center.x,
      y: center.y,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    }, lineStyle));
    line.name = `${this.name}-line`, line.id = this._getNodeId("arc"), isEmpty_default(null == state ? void 0 : state.line) || (line.states = [].concat(state.line)[0]), this.add(line), this.line = line;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/constant.js
var AXIS_ELEMENT_NAME;
!function(AXIS_ELEMENT_NAME2) {
  AXIS_ELEMENT_NAME2.innerView = "inner-view", AXIS_ELEMENT_NAME2.axisContainer = "axis-container", AXIS_ELEMENT_NAME2.labelContainer = "axis-label-container", AXIS_ELEMENT_NAME2.tickContainer = "axis-tick-container", AXIS_ELEMENT_NAME2.tick = "axis-tick", AXIS_ELEMENT_NAME2.subTick = "axis-sub-tick", AXIS_ELEMENT_NAME2.label = "axis-label", AXIS_ELEMENT_NAME2.title = "axis-title", AXIS_ELEMENT_NAME2.gridContainer = "axis-grid-container", AXIS_ELEMENT_NAME2.grid = "axis-grid", AXIS_ELEMENT_NAME2.gridRegion = "axis-grid-region", AXIS_ELEMENT_NAME2.line = "axis-line", AXIS_ELEMENT_NAME2.background = "axis-background", AXIS_ELEMENT_NAME2.axisLabelBackground = "axis-label-background", AXIS_ELEMENT_NAME2.axisBreak = "axis-break", AXIS_ELEMENT_NAME2.axisBreakSymbol = "axis-break-symbol";
}(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
var AxisStateValue;
!function(AxisStateValue2) {
  AxisStateValue2.selected = "selected", AxisStateValue2.selectedReverse = "selected_reverse", AxisStateValue2.hover = "hover", AxisStateValue2.hoverReverse = "hover_reverse";
}(AxisStateValue || (AxisStateValue = {}));
var DEFAULT_STATES2 = {
  [AxisStateValue.selectedReverse]: {},
  [AxisStateValue.selected]: {},
  [AxisStateValue.hover]: {},
  [AxisStateValue.hoverReverse]: {}
};
var TopZIndex = 999;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/config.js
var DEFAULT_AXIS_THEME = {
  title: {
    space: 4,
    padding: 0,
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    padding: 0,
    style: {
      fontSize: 12,
      fill: "#333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  }
};
var DEFAULT_AXIS_BREAK_SYMBOL_STYLE = {
  size: 8,
  stroke: "#000",
  lineWidth: 1,
  zIndex: 1
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/util.js
function genNormalBounds(item) {
  const bounds = item.AABBBounds;
  return {
    x1: bounds.x1,
    x2: bounds.x2,
    y1: bounds.y1,
    y2: bounds.y2,
    centerX: item.attribute.x,
    centerY: item.attribute.y,
    angle: item.attribute.angle
  };
}
function genRotateBounds(items) {
  items.forEach((item) => {
    if (item.rotatedBounds || !item.attribute.angle) return;
    const bounds = genNormalBounds(item), rotatedCenter = rotatePoint({
      x: item.attribute.x,
      y: item.attribute.y
    }, bounds.angle, {
      x: bounds.centerX,
      y: bounds.centerY
    }), deltaX = rotatedCenter.x - bounds.centerX, deltaY = rotatedCenter.y - bounds.centerY;
    bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
  });
}
function itemIntersect(item1, item2) {
  var _a, _b;
  return (null === (_a = item1.OBBBounds) || void 0 === _a ? void 0 : _a.empty()) || (null === (_b = item2.OBBBounds) || void 0 === _b ? void 0 : _b.empty()) ? isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) && (!item1.rotatedBounds || !item2.rotatedBounds || isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true)) : item1.OBBBounds.intersects(item2.OBBBounds);
}
var DELTA_ANGLE = Math.sin(Math.PI / 10);
function isAngleVertical(angle2, delta = DELTA_ANGLE) {
  const hasAngle = !isNil_default(angle2) && 0 !== angle2, cos5 = hasAngle ? Math.cos(angle2) : 1;
  return hasAngle && Math.abs(cos5) <= delta;
}
function isAngleHorizontal(angle2, delta = DELTA_ANGLE) {
  const hasAngle = !isNil_default(angle2) && 0 !== angle2, sin5 = hasAngle ? Math.sin(angle2) : 0;
  return !hasAngle || Math.abs(sin5) <= delta;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/util.js
function getCircleLabelPosition(tickPosition, tickVector) {
  return {
    x: tickPosition.x + tickVector[0],
    y: tickPosition.y + tickVector[1]
  };
}
function getAxisBreakSymbolAttrs(props = {}) {
  var _a, _b;
  const { style: style2 = {}, angle: angle2 = 0.5 * Math.PI } = props, symbolStyle = merge({}, DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style2), symbolSize = null !== (_a = symbolStyle.size) && void 0 !== _a ? _a : DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;
  return Object.assign(Object.assign({}, symbolStyle), {
    symbolType: null !== (_b = symbolStyle.symbolType) && void 0 !== _b ? _b : `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle2)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle2)}`,
    symbolSize
  });
}
function getElMap(g) {
  const elMap = {};
  return traverseGroup(g, (el) => {
    "group" !== el.type && el.id && (elMap[el.id] = el);
  }), elMap;
}
function getVerticalCoord(point5, vector) {
  return {
    x: point5.x + vector[0],
    y: point5.y + vector[1]
  };
}
function getCircleVerticalVector(offset, point5, center, inside = false, axisInside = false) {
  const vector = [point5.x - center.x, point5.y - center.y];
  return scale2(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / length(vector));
}
function getPolarAngleLabelPosition(angle2, center, radius, labelOffset, inside) {
  const point5 = polarToCartesian({
    x: 0,
    y: 0
  }, radius, angle2), labelPoint = getVerticalCoord(point5, getCircleVerticalVector(labelOffset, point5, center, inside));
  return getCircleLabelPosition(labelPoint, getCircleVerticalVector(labelOffset || 1, labelPoint, center, inside));
}
function getCirclePoints(center, count, radius, startAngle, endAngle) {
  const points = [], range5 = endAngle - startAngle;
  for (let i = 0; i < count; i++) {
    const angle2 = startAngle + i * range5 / count;
    points.push(polarToCartesian(center, radius, angle2));
  }
  return points;
}
function getPolygonPath(points, closed) {
  let path = "";
  return 0 === points.length || (points.forEach((point5, index) => {
    0 === index ? path = `M${point5.x},${point5.y}` : path += `L${point5.x},${point5.y}`;
  }), closed && (path += "Z")), path;
}
function textIntersect(textA, textB, sep) {
  var _a;
  const angle2 = null === (_a = textA.attribute) || void 0 === _a ? void 0 : _a.angle;
  if (isAngleHorizontal(angle2, Number.EPSILON)) return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);
  const a2 = textA.OBBBounds, b = textB.OBBBounds;
  return !a2 || !b || a2.empty() || b.empty() ? sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds) : a2.intersects(b) || sep > obbSeparation(a2, b);
}
function hasOverlap(items, pad2) {
  for (let b, i = 1, n = items.length, a2 = items[0]; i < n; a2 = b, ++i) if (b = items[i], textIntersect(a2, b, pad2)) return true;
  return false;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/interaction.js
var dispatchHoverState = (e, container2, lastHover) => {
  const target = e.target;
  return target !== lastHover && target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.hover, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.hoverReverse, true);
  }), target) : lastHover;
};
var dispatchUnHoverState = (e, container2, lastHover) => lastHover ? (traverseGroup(container2, (node) => {
  node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
}), null) : lastHover;
var dispatchClickState = (e, container2, lastSelect) => {
  const target = e.target;
  return lastSelect === target && target.hasState(StateValue.selected) ? (traverseGroup(container2, (node) => {
    node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
  }), null) : target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.selected, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.selectedReverse, true);
  }), target) : lastSelect;
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/base.js
var AxisBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis", this.data = [], this.tickLineItems = [], this.subTickLineItems = [], this.axisLabelLayerSize = {}, this.axisLabelsContainer = null, this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this.axisContainer, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this.axisContainer, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this.axisContainer, this._lastSelect);
    };
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  getBoundsWithoutRender(attributes) {
    const currentAttribute = cloneDeep(this.attribute);
    merge(this.attribute, attributes);
    const offscreenGroup = graphicCreator.group({
      x: this.attribute.x,
      y: this.attribute.y
    });
    return this.add(offscreenGroup), this._renderInner(offscreenGroup), this.removeChild(offscreenGroup), this.attribute = currentAttribute, offscreenGroup.AABBBounds;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView), this._renderInner(this._innerView), this._bindEvent();
  }
  _bindEvent() {
    if (this.attribute.disableTriggerEvent) return;
    const { hover, select } = this.attribute;
    hover && (this._innerView.addEventListener("pointermove", this._onHover), this._innerView.addEventListener("pointerout", this._onUnHover)), select && this._innerView.addEventListener("pointerdown", this._onClick);
  }
  _renderInner(container2) {
    const { title, label, tick, line, items } = this.attribute, axisContainer = graphicCreator.group({
      x: 0,
      y: 0,
      zIndex: 1,
      pickable: false
    });
    if (axisContainer.name = AXIS_ELEMENT_NAME.axisContainer, axisContainer.id = this._getNodeId("container"), axisContainer.setMode(this.mode), this.axisContainer = axisContainer, container2.add(axisContainer), line && line.visible && this.renderLine(axisContainer), items && items.length && (this.data = this._transformItems(items[0]), tick && tick.visible && this.renderTicks(axisContainer), label && label.visible)) {
      const labelGroup = graphicCreator.group({
        x: 0,
        y: 0,
        pickable: false
      });
      labelGroup.name = AXIS_ELEMENT_NAME.labelContainer, labelGroup.id = this._getNodeId("label-container"), this.axisLabelsContainer = labelGroup, axisContainer.add(labelGroup), items.forEach((axisItems, layer) => {
        const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer), labels = layerLabelGroup.getChildren();
        this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
        let maxTextWidth = 0, maxTextHeight = 0, textAlign = "center", textBaseline = "middle", labelPos = 0;
        labels.forEach((label2, index) => {
          var _a;
          const labelStyle = label2.attribute, angle2 = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textBounds = label2.AABBBounds;
          let textWidth = textBounds.width(), textHeight = textBounds.height();
          angle2 && (textWidth = Math.abs(textWidth * Math.cos(angle2)), textHeight = Math.abs(textHeight * Math.sin(angle2))), maxTextWidth = Math.max(maxTextWidth, textWidth), maxTextHeight = Math.max(maxTextHeight, textHeight), textAlign = labelStyle.textAlign, textBaseline = labelStyle.textBaseline, 0 === index && (labelPos = labelStyle.x);
        }), this.axisLabelLayerSize[layer] = {
          width: maxTextWidth,
          height: maxTextHeight,
          labelPos,
          textAlign,
          textBaseline
        };
      });
    }
    title && title.visible && this.renderTitle(axisContainer);
  }
  renderTicks(container2) {
    const tickLineItems = this.getTickLineItems(), tickLineGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer, tickLineGroup.id = this._getNodeId("tick-container"), container2.add(tickLineGroup), tickLineItems.forEach((item, index) => {
      var _a;
      const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("tick", item, index, tickLineItems)));
      if (line.name = AXIS_ELEMENT_NAME.tick, line.id = this._getNodeId(item.id), isEmpty_default(null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.state)) line.states = DEFAULT_STATES;
      else {
        const data = this.data[index], tickLineState = merge({}, DEFAULT_STATES, this.attribute.tick.state);
        Object.keys(tickLineState).forEach((key) => {
          isFunction_default(tickLineState[key]) && (tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data));
        }), line.states = tickLineState;
      }
      tickLineGroup.add(line);
    }), this.tickLineItems = tickLineItems;
    const { subTick } = this.attribute;
    if (subTick && subTick.visible) {
      const subTickLineItems = this.getSubTickLineItems();
      subTickLineItems.length && subTickLineItems.forEach((item, index) => {
        const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("subTick", item, index, tickLineItems)));
        if (line.name = AXIS_ELEMENT_NAME.subTick, line.id = this._getNodeId(`${index}`), isEmpty_default(subTick.state)) line.states = DEFAULT_STATES;
        else {
          const subTickLineState = merge({}, DEFAULT_STATES, subTick.state);
          Object.keys(subTickLineState).forEach((key) => {
            isFunction_default(subTickLineState[key]) && (subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems));
          }), line.states = subTickLineState;
        }
        tickLineGroup.add(line);
      }), this.subTickLineItems = subTickLineItems;
    }
  }
  renderLabels(container2, items, layer) {
    const { dataFilter } = this.attribute.label;
    dataFilter && isFunction_default(dataFilter) && (items = dataFilter(items, layer));
    const data = this._transformItems(items), labelGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    return labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`, labelGroup.id = this._getNodeId(`label-container-layer-${layer}`), container2.add(labelGroup), data.forEach((item, index) => {
      var _a;
      const labelStyle = this._getLabelAttribute(item, index, data, layer), text2 = createTextGraphicByType(labelStyle);
      if (text2.name = AXIS_ELEMENT_NAME.label, text2.id = this._getNodeId(`layer${layer}-label-${item.id}`), isEmpty_default(null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.state)) text2.states = DEFAULT_STATES;
      else {
        const labelState = merge({}, DEFAULT_STATES, this.attribute.label.state);
        Object.keys(labelState).forEach((key) => {
          isFunction_default(labelState[key]) && (labelState[key] = labelState[key](item, index, data, layer));
        }), text2.states = labelState;
      }
      text2.data = Object.assign(Object.assign({}, item), {
        index,
        layer
      }), labelGroup.add(text2);
    }), labelGroup;
  }
  renderTitle(container2) {
    const titleAttributes = this.getTitleAttribute(), axisTitle = new Tag(Object.assign({}, titleAttributes));
    axisTitle.name = AXIS_ELEMENT_NAME.title, axisTitle.id = this._getNodeId("title"), container2.add(axisTitle);
  }
  getVerticalCoord(point5, offset, inside) {
    return getVerticalCoord(point5, this.getVerticalVector(offset, inside, point5));
  }
  getTickLineItems() {
    const { tick } = this.attribute, data = this.data, tickLineItems = [], { alignWithLabel, inside = false, length: length2, dataFilter } = tick;
    let tickSegment = 1;
    return data.length >= 2 && (tickSegment = data[1].value - data[0].value), (dataFilter && isFunction_default(dataFilter) ? dataFilter(data) : data).forEach((item) => {
      let point5 = item.point, tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value)) return;
        point5 = this.getTickCoord(value), tickValue = value;
      }
      const endPoint = this.getVerticalCoord(point5, length2, inside);
      if ("3d" === this.mode) {
        const vec = this.getVerticalVector(length2, inside, point5);
        let alpha = 0, beta = 0;
        abs(vec[0]) > abs(vec[1]) ? alpha = pi / 2 * (endPoint.x > point5.x ? 1 : -1) : beta = pi / 2 * (endPoint.y > point5.y ? -1 : 1), tickLineItems.push({
          start: point5,
          end: endPoint,
          value: tickValue,
          id: `tick-${item.id}`,
          anchor: [point5.x, point5.y],
          alpha,
          beta
        });
      } else tickLineItems.push({
        start: point5,
        end: endPoint,
        value: tickValue,
        id: `tick-${item.id}`
      });
    }), tickLineItems;
  }
  getSubTickLineItems() {
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) for (let i = 0; i < tickLineCount - 1; i++) {
      const pre = tickLineItems[i], next = tickLineItems[i + 1];
      for (let j = 0; j < subCount; j++) {
        const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, inside);
        subTickLineItems.push({
          start: point5,
          end: endPoint,
          value,
          id: `sub-tick-${value}`
        });
      }
    }
    return subTickLineItems;
  }
  _getTickLineAttribute(type, tickItem, index, tickItems) {
    let style2 = get_default(this.attribute, `${type}.style`);
    const data = this.data[index];
    style2 = isFunction_default(style2) ? merge({}, get_default(DEFAULT_AXIS_THEME, `${type}.style`), "tick" === type ? style2(data.rawValue, index, data, this.data) : style2(tickItem.value, index, tickItem, tickItems)) : style2;
    const { start, end, anchor, alpha, beta } = tickItem;
    return Object.assign({
      points: [start, end],
      anchor,
      alpha,
      beta
    }, style2);
  }
  _getLabelAttribute(tickDatum, index, tickData, layer) {
    var _a, _b;
    const { space = 4, inside = false, formatMethod, type = "text", text: text2 } = this.attribute.label;
    let offset = space, tickLength = 0;
    (null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.visible) && this.attribute.tick.inside === inside && (tickLength = this.attribute.tick.length || 4), (null === (_b = this.attribute.subTick) || void 0 === _b ? void 0 : _b.visible) && this.attribute.subTick.inside === inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2)), offset += tickLength;
    const axisVector = this.getRelativeVector(tickDatum.point);
    layer > 0 && (0 === axisVector[1] ? offset += (this.axisLabelLayerSize[layer - 1].height + get_default(this.attribute, "label.space", 4)) * layer : offset += (this.axisLabelLayerSize[layer - 1].width + get_default(this.attribute, "label.space", 4)) * layer);
    const point5 = this.getVerticalCoord(tickDatum.point, offset, inside), vector = this.getVerticalVector(offset || 1, inside, point5), textContent = formatMethod ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer) : tickDatum.label;
    let { style: textStyle } = this.attribute.label;
    textStyle = isFunction_default(textStyle) ? merge({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer)) : textStyle;
    const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
    return textStyle = merge(labelAlign, textStyle), isFunction_default(textStyle.text) && (textStyle.text = textStyle.text({
      label: tickDatum.label,
      value: tickDatum.rawValue,
      index: tickDatum.index,
      layer
    })), Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point5, vector, textContent, textStyle)), {
      text: null != text2 ? text2 : textContent,
      _originText: tickDatum.label,
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize,
      type
    }), textStyle);
  }
  getLabelPosition(point5, vector, text2, style2) {
    return point5;
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/auto-hide.js
var methods = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 ? item.setAttribute("opacity", 0) : 1);
  },
  greedy: function(items, sep) {
    let a2;
    return items.filter((b, i) => i && textIntersect(a2, b, sep) ? b.setAttribute("opacity", 0) : (a2 = b, 1));
  }
};
function hasBounds(item) {
  let bounds;
  return bounds = item.OBBBounds.empty() ? item.AABBBounds : item.OBBBounds, bounds.width() > 1 && bounds.height() > 1;
}
function reset(items) {
  return items.forEach((item) => item.setAttribute("opacity", 1)), items;
}
function forceItemVisible(sourceItem, items, check, comparator, inverse = false) {
  if (check && !sourceItem.attribute.opacity) {
    const remainLength = items.length;
    if (remainLength > 1) {
      sourceItem.setAttribute("opacity", 1);
      for (let i = 0; i < remainLength; i++) {
        const item = inverse ? items[remainLength - 1 - i] : items[i];
        if (!comparator(item)) break;
        item.setAttribute("opacity", 0);
      }
    }
  }
}
function autoHide(labels, config) {
  if (isEmpty_default(labels)) return;
  const source = labels.filter(hasBounds);
  if (isEmpty_default(source)) return;
  let items;
  items = reset(source);
  const { method = "parity", separation: sep = 0 } = config, reduce = isFunction_default(method) ? method : methods[method] || methods.parity;
  if (items.length >= 3 && hasOverlap(items, sep)) {
    do {
      items = reduce(items, sep);
    } while (items.length >= 3 && hasOverlap(items, sep));
    const shouldCheck = (length2, visibility, checkLength = true) => checkLength && length2 < 3 || visibility, checkFirst = shouldCheck(items.length, config.firstVisible, false);
    let checkLast = shouldCheck(items.length, config.lastVisible);
    const firstSourceItem = source[0], lastSourceItem = last(source);
    textIntersect(firstSourceItem, lastSourceItem, sep) && checkFirst && checkLast && (lastSourceItem.setAttribute("opacity", 0), checkLast = false), forceItemVisible(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, sep)), forceItemVisible(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, sep) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, sep), true);
  }
  source.forEach((item) => {
    item.setAttribute("visible", !!item.attribute.opacity);
  });
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/auto-rotate.js
function autoRotate(items, rotateConfig) {
  if (isEmpty_default(items)) return;
  const { orient, labelRotateAngle = [0, 45, 90] } = rotateConfig;
  if (0 === labelRotateAngle.length || items.some((item) => !!item.attribute.angle)) return;
  let i = 0, n = 0;
  for (labelRotateAngle && labelRotateAngle.length > 0 && (n = labelRotateAngle.length); i < n; ) {
    const angle2 = labelRotateAngle[i++];
    if (items.forEach((item) => {
      item.attribute.angle = degreeToRadian(angle2);
    }), tryRotate(orient, items), !hasIntersect(items)) break;
  }
}
function hasIntersect(items) {
  for (let i = 1; i < items.length; i++) if (itemIntersect(items[i - 1], items[i])) return true;
  return false;
}
function tryRotate(orient, items) {
  "bottom" !== orient && "top" !== orient || rotateXAxis(orient, items), "left" !== orient && "right" !== orient || rotateYAxis(orient, items), genRotateBounds(items);
}
function clampAngle(angle2 = 0) {
  if (angle2 < 0) for (; angle2 < 0; ) angle2 += 2 * Math.PI;
  if (angle2 > 0) for (; angle2 >= 2 * Math.PI; ) angle2 -= 2 * Math.PI;
  return angle2;
}
function rotateYAxis(orient, items) {
  items.forEach((item, i) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function rotateXAxis(orient, items) {
  items.forEach((item) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function getXAxisLabelAlign(orient, angle2 = 0) {
  let align = ["center", "left", "left", "left", "center", "right", "right", "right", "left"], baseline = ["top", "top", "middle", "bottom", "bottom", "bottom", "middle", "top", "top"];
  "top" === orient && (align = ["center", "right", "right", "right", "center", "left", "left", "left", "right"], baseline = ["bottom", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}
function getYAxisLabelAlign(orient, angle2 = 0) {
  let align = ["right", "right", "center", "left", "left", "left", "center", "right", "right"], baseline = ["middle", "middle", "top", "top", "middle", "middle", "bottom", "bottom", "middle"];
  "right" === orient && (align = ["left", "left", "center", "right", "right", "right", "center", "left", "left"], baseline = ["middle", "middle", "bottom", "bottom", "middle", "middle", "top", "middle", "middle"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/auto-limit.js
function normalizeOverflowLimitLength(overflowLimitLength) {
  return isValidNumber_default(overflowLimitLength) ? {
    left: overflowLimitLength,
    right: overflowLimitLength
  } : isObject_default(overflowLimitLength) ? {
    left: overflowLimitLength.left || 0,
    right: overflowLimitLength.right || 0
  } : {
    left: 0,
    right: 0
  };
}
function autoLimit(labels, config) {
  const { limitLength, verticalLimitLength, ellipsis = "...", orient, axisLength } = config;
  if (isEmpty_default(labels) || !isValidNumber_default(limitLength)) return;
  const overflowLimitLength = normalizeOverflowLimitLength(config.overflowLimitLength), firstLabel = labels[0], angle2 = firstLabel.attribute.angle, hasAngle = !isNil_default(angle2), cos5 = hasAngle ? Math.cos(angle2) : 1, sin5 = hasAngle ? Math.sin(angle2) : 0, isHorizontal2 = isAngleHorizontal(angle2), isVertical = isAngleVertical(angle2), isX = "top" === orient || "bottom" === orient, direction = firstLabel.attribute.direction, checkBox = !isHorizontal2 && !isVertical && isX && (labels.length < 2 || labels.some((label) => Math.abs(label.AABBBounds.width() - firstLabel.AABBBounds.width()) >= 2)) && firstLabel.AABBBounds.width() > Math.abs(limitLength / sin5);
  labels.forEach((label) => {
    var _a;
    if (isX) {
      if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) return;
      if (isHorizontal2 && Math.floor(label.AABBBounds.width()) <= verticalLimitLength) return;
    }
    if (!isX) {
      if ("vertical" === direction && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
      if ("vertical" !== direction) {
        if (isHorizontal2 && Math.floor(label.AABBBounds.width()) <= limitLength) return;
        if (isVertical && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
      }
    }
    let limitLabelLength = null;
    if (isHorizontal2 || isVertical) limitLabelLength = isX ? isHorizontal2 ? verticalLimitLength : limitLength : "vertical" === direction || isVertical ? verticalLimitLength : limitLength;
    else if (isX) {
      const { x1, x2 } = label.AABBBounds, tan = sin5 / cos5, verticalSizeLimit = Math.abs(limitLength / sin5);
      if (checkBox && tan > 0 && x1 <= axisLength + overflowLimitLength.right && limitLength / tan + x1 > axisLength + overflowLimitLength.right) {
        const lengthLimit = (axisLength - x1 + overflowLimitLength.right) / Math.abs(cos5);
        limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
      } else if (checkBox && tan < 0 && x2 >= -overflowLimitLength.left && limitLength / tan + x2 < -overflowLimitLength.left) {
        const lengthLimit = (x2 + overflowLimitLength.left) / Math.abs(cos5);
        limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
      } else limitLabelLength = verticalSizeLimit;
    } else limitLabelLength = Math.abs(limitLength / cos5);
    isValidNumber_default(label.attribute.maxLineWidth) && (limitLabelLength = isValidNumber_default(limitLabelLength) ? Math.min(label.attribute.maxLineWidth, limitLabelLength) : label.attribute.maxLineWidth), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
    });
  });
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/auto-wrap.js
function autoWrap(labels, config) {
  const { limitLength, axisLength, ellipsis = "...", orient } = config;
  if (isEmpty_default(labels) || !isValidNumber_default(limitLength)) return;
  const angle2 = labels[0].attribute.angle, isHorizontal2 = isAngleHorizontal(angle2), isVertical = isAngleVertical(angle2), isX = "top" === orient || "bottom" === orient;
  let verticalLimitLength = axisLength / labels.length;
  labels.forEach((label, index) => {
    var _a, _b, _c, _d, _e;
    if (isX) {
      if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) return;
      if (isHorizontal2) {
        const minGap = getLabelMinGap(label.attribute.x, null === (_a = labels[index + 1]) || void 0 === _a ? void 0 : _a.attribute.x, null === (_b = labels[index - 1]) || void 0 === _b ? void 0 : _b.attribute.x);
        isValidNumber_default(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
      }
    } else {
      if (isVertical) {
        const minGap = getLabelMinGap(label.attribute.y, null === (_c = labels[index + 1]) || void 0 === _c ? void 0 : _c.attribute.y, null === (_d = labels[index - 1]) || void 0 === _d ? void 0 : _d.attribute.y);
        isValidNumber_default(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
      }
      if (isHorizontal2 && Math.floor(label.AABBBounds.width()) <= limitLength) return;
    }
    let limitLabelLength = null, heightLimit = null;
    isX ? isVertical ? (limitLabelLength = limitLength, heightLimit = verticalLimitLength) : (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : isVertical ? (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : (limitLabelLength = limitLength, heightLimit = verticalLimitLength), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: null !== (_e = label.attribute.ellipsis) && void 0 !== _e ? _e : ellipsis,
      whiteSpace: "normal",
      heightLimit
    });
  });
}
function getLabelMinGap(current, next, prev) {
  let minGap;
  return isValidNumber_default(next) && (minGap = Math.abs(next - current)), isValidNumber_default(prev) && (minGap = isValidNumber_default(minGap) ? Math.min(Math.abs(current - prev), minGap) : Math.abs(current - prev)), minGap;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/util/align.js
function alignAxisLabels(labels, start, containerSize, orient, align) {
  "left" === orient || "right" === orient ? "left" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.x1
    });
  }) : "right" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.x2
    });
  }) : "center" === align && labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.x1 + label.AABBBounds.x2) / 2
    });
  }) : "bottom" !== orient && "top" !== orient || ("top" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.y1
    });
  }) : "bottom" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.y2
    });
  }) : "middle" === align && labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.y1 + label.AABBBounds.y2) / 2
    });
  }));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/mixin/line.js
var LineAxisMixin = class {
  isInValidValue(value) {
    return value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { start } = this.attribute, axisVector = this.getRelativeVector();
    return {
      x: start.x + axisVector[0] * tickValue,
      y: start.y + axisVector[1] * tickValue
    };
  }
  getRelativeVector(point5) {
    const { start, end } = this.attribute;
    return [end.x - start.x, end.y - start.y];
  }
  getVerticalVector(offset, inside = false, point5) {
    const { verticalFactor = 1 } = this.attribute, axisVector = this.getRelativeVector(), normalizedAxisVector = normalize(axisVector), verticalVector = [normalizedAxisVector[1], -1 * normalizedAxisVector[0]];
    return scale2(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/register.js
function loadBasicAxis() {
  registerGroup(), registerLine(), registerRichtext(), registerText();
}
function loadLineAxisComponent() {
  loadBasicAxis(), registerRect();
}
function loadCircleAxisComponent() {
  loadBasicAxis(), registerCircle();
}
function loadLineAxisGridComponent() {
  registerGroup(), registerPath();
}
function loadCircleAxisGridComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/line.js
var __rest4 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadLineAxisComponent();
var LineAxis = class _LineAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineAxis.defaultAttributes, attributes), options);
  }
  _renderInner(container2) {
    var _a;
    if (this._breaks = null, this.attribute.breaks && this.attribute.breaks.length) {
      const transformedBreaks = [];
      for (let index = 0; index < this.attribute.breaks.length; index++) {
        const aBreak = this.attribute.breaks[index], { range: range5, breakSymbol, rawRange } = aBreak;
        transformedBreaks.push({
          startPoint: this.getTickCoord(range5[0]),
          endPoint: this.getTickCoord(range5[1]),
          range: range5,
          breakSymbol,
          rawRange
        });
      }
      this._breaks = transformedBreaks;
    }
    super._renderInner(container2), this._breaks && this._breaks.length && this._breaks.forEach((b, index) => {
      const { startPoint, endPoint, breakSymbol, rawRange } = b;
      if (false !== (null == breakSymbol ? void 0 : breakSymbol.visible)) {
        const axisBreakGroup = graphicCreator.group({
          zIndex: TopZIndex
        });
        axisBreakGroup.name = AXIS_ELEMENT_NAME.axisBreak, axisBreakGroup.id = this._getNodeId(`${AXIS_ELEMENT_NAME.axisBreak}-${index}`), axisBreakGroup.data = rawRange;
        const symbolStyle = getAxisBreakSymbolAttrs(breakSymbol), shape1 = graphicCreator.symbol(Object.assign({
          x: startPoint.x,
          y: startPoint.y
        }, symbolStyle));
        shape1.name = AXIS_ELEMENT_NAME.axisBreakSymbol;
        const shape2 = graphicCreator.symbol(Object.assign({
          x: endPoint.x,
          y: endPoint.y
        }, symbolStyle));
        shape2.name = AXIS_ELEMENT_NAME.axisBreakSymbol, axisBreakGroup.add(shape1), axisBreakGroup.add(shape2), container2.add(axisBreakGroup);
      }
    });
    const { panel } = this.attribute;
    if (panel && panel.visible) {
      const axisContainer = this.axisContainer, axisContainerBounds = axisContainer.AABBBounds, bgRect = graphicCreator.rect(Object.assign({
        x: axisContainerBounds.x1,
        y: axisContainerBounds.y1,
        width: axisContainerBounds.width(),
        height: axisContainerBounds.height()
      }, panel.style));
      bgRect.name = AXIS_ELEMENT_NAME.background, bgRect.id = this._getNodeId("background"), bgRect.states = merge({}, DEFAULT_STATES2, null !== (_a = panel.state) && void 0 !== _a ? _a : {}), axisContainer.insertBefore(bgRect, axisContainer.firstChild);
    }
  }
  renderLine(container2) {
    const { start, end, line } = this.attribute, _a = line, { startSymbol, endSymbol, style: style2, state } = _a, restLineAttrs = __rest4(_a, ["startSymbol", "endSymbol", "style", "state"]), lineAttrs = Object.assign({
      startSymbol,
      endSymbol,
      lineStyle: style2
    }, restLineAttrs);
    if (this._breaks && this._breaks.length) {
      const linePoints = [];
      let lastStartPoint = start;
      this._breaks.forEach((b) => {
        const { startPoint, endPoint } = b;
        linePoints.push([lastStartPoint, startPoint]), lastStartPoint = endPoint;
      }), linePoints.push([lastStartPoint, end]), lineAttrs.points = linePoints, lineAttrs.multiSegment = true;
    } else lineAttrs.points = [start, end];
    isEmpty_default(state) || (lineAttrs.state = {
      line: merge({}, DEFAULT_STATES2, state),
      symbol: merge({}, DEFAULT_STATES2, state)
    });
    const axisLineGroup = new Segment(lineAttrs);
    axisLineGroup.name = AXIS_ELEMENT_NAME.line, axisLineGroup.id = this._getNodeId("line"), container2.add(axisLineGroup);
  }
  getTextAlign(vector) {
    let align = "center";
    return isNumberClose(vector[0], 0) ? isNumberClose(vector[1], 0) ? Object.is(vector[1], -0) ? align = "start" : Object.is(vector[0], -0) && (align = "end") : align = "center" : vector[0] > 0 ? align = "start" : vector[0] < 0 && (align = "end"), align;
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const _d = this.attribute.title, { position = "middle", space = 4, textStyle = {}, autoRotate: autoRotate2 = true, shape, background, state = {}, maxWidth } = _d, restAttrs = __rest4(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state", "maxWidth"]);
    let percent = 0.5;
    "start" === position ? percent = 0 : "end" === position && (percent = 1);
    const { verticalFactor = 1 } = this.attribute, factor = -1 * verticalFactor, point5 = this.getTickCoord(percent), axisVector = this.getRelativeVector();
    let labelLength = 0;
    if ((null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside) {
      const space2 = +get_default(this.attribute, "label.space", 4);
      labelLength += space2;
      const layerCount = Object.keys(this.axisLabelLayerSize).length;
      if (0 === axisVector[1]) {
        const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
        isFinite(labelBoundsHeight) ? labelLength += labelBoundsHeight + (layerCount - 1) * space2 : labelLength = 0;
      } else if (0 === axisVector[0]) if (this.axisLabelsContainer && this.axisLabelsContainer.AABBBounds && !this.axisLabelsContainer.AABBBounds.empty()) {
        const baseX = this.axisLabelLayerSize[0].labelPos, bounds = this.axisLabelsContainer.AABBBounds;
        labelLength += (1 === factor ? bounds.x2 > baseX ? Math.min(bounds.x2 - baseX, bounds.width()) : 0 : bounds.x1 < baseX ? Math.min(baseX - bounds.x1, bounds.width()) : 0) + (layerCount - 1) * space2;
      } else labelLength = 0;
      else Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
        labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space2 : 0);
      });
    }
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = tickLength + labelLength + space, titlePoint = this.getVerticalCoord(point5, offset, false), vector = this.getVerticalVector(offset, false, {
      x: 0,
      y: 0
    });
    let textAlign, textBaseline, { angle: angle2 } = restAttrs;
    if (textAlign = "start" === position ? "start" : "end" === position ? "end" : "center", isNil_default(angle2) && autoRotate2) {
      angle2 = angleTo(axisVector, [1, 0], true);
      const { verticalFactor: verticalFactor2 = 1 } = this.attribute;
      textBaseline = 1 === -1 * verticalFactor2 ? "bottom" : "top";
    } else textAlign = this.getTextAlign(vector), textBaseline = this.getTextBaseline(vector, false);
    let maxTagWidth = maxWidth;
    if (isNil_default(maxTagWidth)) {
      const { verticalLimitSize, verticalMinSize, orient } = this.attribute, limitSize = Math.min(verticalLimitSize || 1 / 0, verticalMinSize || 1 / 0);
      if (isValidNumber_default(limitSize)) {
        if ("bottom" === orient || "top" === orient) if (angle2 !== Math.PI / 2) {
          const cosValue = Math.abs(Math.cos(null != angle2 ? angle2 : 0));
          maxTagWidth = cosValue < 1e-6 ? 1 / 0 : this.attribute.end.x / cosValue;
        } else maxTagWidth = limitSize - offset;
        else if (angle2 && 0 !== angle2) {
          const sinValue = Math.abs(Math.sin(angle2));
          maxTagWidth = sinValue < 1e-6 ? 1 / 0 : this.attribute.end.y / sinValue;
        } else maxTagWidth = limitSize - offset;
      }
    }
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      maxWidth: maxTagWidth,
      textStyle: Object.assign({
        textAlign,
        textBaseline
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    });
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getTextBaseline(vector, inside) {
    let base = "middle";
    const { verticalFactor = 1 } = this.attribute, factor = (inside ? 1 : -1) * verticalFactor;
    return isNumberClose(vector[1], 0) ? base = !isNumberClose(vector[0], 0) || Object.is(vector[0], -0) || Object.is(vector[1], -0) ? "middle" : 1 === factor ? "bottom" : "top" : vector[1] > 0 ? base = "top" : vector[1] < 0 && (base = "bottom"), base;
  }
  getLabelAlign(vector, inside, angle2) {
    const orient = this.attribute.orient;
    if (["top", "bottom", "right", "left"].includes(orient) || 0 === vector[0] && 0 === vector[1]) {
      if ("top" === orient || "bottom" === orient) return getXAxisLabelAlign(inside ? "bottom" === orient ? "top" : "bottom" : orient, angle2);
      if ("left" === orient || "right" === orient) return getYAxisLabelAlign(inside ? "left" === orient ? "right" : "left" : orient, angle2);
    }
    return {
      textAlign: this.getTextAlign(vector),
      textBaseline: this.getTextBaseline(vector, inside)
    };
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    var _a, _b, _c, _d;
    const { flush = false } = this.attribute.label || {};
    if (flush && labelShapes.length) {
      const { orient, start: axisStart, end: axisEnd } = this.attribute, isX = "bottom" === orient || "top" === orient, first = labelShapes[0], last2 = last(labelShapes), isInverse = isX ? first.attribute.x > last2.attribute.x : first.attribute.y < last2.attribute.y;
      if (isX) {
        const leftMostLabel = isInverse ? last2 : first, rightMostLabel = isInverse ? first : last2, left = axisStart.x, right = axisEnd.x, leftBound = leftMostLabel.AABBBounds.x1, rightBound = rightMostLabel.AABBBounds.x2;
        if (leftBound < left) {
          leftMostLabel.attribute.angle ? leftMostLabel.setAttributes({
            dx: (null !== (_a = leftMostLabel.attribute.dx) && void 0 !== _a ? _a : 0) + left - leftBound
          }) : leftMostLabel.setAttributes({
            x: left,
            textAlign: "left"
          });
        }
        if (rightBound > right) {
          rightMostLabel.attribute.angle ? rightMostLabel.setAttributes({
            dx: (null !== (_b = rightMostLabel.attribute.dx) && void 0 !== _b ? _b : 0) + right - rightBound
          }) : rightMostLabel.setAttributes({
            x: right,
            textAlign: "right"
          });
        }
      } else {
        const bottomMostLabel = isInverse ? last2 : first, topMostLabel = isInverse ? first : last2, bottomBound = bottomMostLabel.AABBBounds.y2, topBound = topMostLabel.AABBBounds.y1, top = axisStart.y, bottom = axisEnd.y;
        if (topBound < top) {
          topMostLabel.attribute.angle ? topMostLabel.setAttributes({
            dy: (null !== (_c = topMostLabel.attribute.dy) && void 0 !== _c ? _c : 0) + top - topBound
          }) : topMostLabel.setAttributes({
            y: top,
            textBaseline: "top"
          });
        }
        if (bottomBound > bottom) {
          bottomMostLabel.attribute.angle ? bottomMostLabel.setAttributes({
            dy: (null !== (_d = bottomMostLabel.attribute.dy) && void 0 !== _d ? _d : 0) + bottom - bottomBound
          }) : bottomMostLabel.setAttributes({
            y: bottom,
            textBaseline: "bottom"
          });
        }
      }
    }
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes)) return;
    const { verticalLimitSize, label, orient } = this.attribute, limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount), { layoutFunc, autoRotate: autoRotate2, autoRotateAngle, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, lastVisible, firstVisible, autoWrap: autoWrap2, overflowLimitLength } = label;
    if (isFunction_default(layoutFunc)) layoutFunc(labelShapes, labelData, layer, this);
    else {
      if (autoRotate2) autoRotate(labelShapes, {
        labelRotateAngle: autoRotateAngle,
        orient
      });
      else if (autoWrap2) {
        const axisLength = "left" === orient || "right" === orient ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x);
        autoWrap(labelShapes, {
          orient,
          limitLength,
          axisLength,
          ellipsis: limitEllipsis
        });
      }
      if (!autoWrap2 && autoLimit2 && isValidNumber_default(limitLength) && limitLength > 0) {
        const isVertical = "left" === orient || "right" === orient, axisLength = isVertical ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x), verticalLimitLength = isVertical ? axisLength / labelShapes.length : autoHide2 || autoRotate2 ? 1 / 0 : axisLength / labelShapes.length;
        autoLimit(labelShapes, {
          limitLength,
          verticalLimitLength,
          ellipsis: limitEllipsis,
          orient,
          axisLength,
          overflowLimitLength
        });
      }
      autoHide2 && autoHide(labelShapes, {
        orient,
        method: autoHideMethod,
        separation: autoHideSeparation,
        lastVisible,
        firstVisible
      });
    }
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    const { verticalLimitSize, orient } = this.attribute, isHorizontal2 = "bottom" === orient || "top" === orient, axisLabelContainerBounds = labelContainer.AABBBounds;
    let axisLabelContainerSize = isHorizontal2 ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
    const { verticalMinSize } = this.attribute;
    if (isValidNumber_default(verticalMinSize) && (!isValidNumber_default(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
      const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
      let x, y;
      axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize), "left" === orient ? (x = axisLabelContainerBounds.x2 - axisLabelContainerSize, y = axisLabelContainerBounds.y1) : "right" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1) : "top" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y2 - axisLabelContainerSize) : "bottom" === orient && (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1);
      const bgRect = graphicCreator.rect({
        x,
        y,
        width: isHorizontal2 ? axisLabelContainerBounds.width() : axisLabelContainerSize,
        height: isHorizontal2 ? axisLabelContainerSize : axisLabelContainerBounds.height(),
        pickable: false
      });
      bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground, bgRect.id = this._getNodeId("axis-label-background"), labelContainer.insertBefore(bgRect, labelContainer.firstChild);
    }
    if (isValid_default(this.attribute.label.containerAlign)) {
      let start;
      "left" === orient ? start = axisLabelContainerBounds.x2 - axisLabelContainerSize : "right" === orient ? start = axisLabelContainerBounds.x1 : "top" === orient ? start = axisLabelContainerBounds.y2 - axisLabelContainerSize : "bottom" === orient && (start = axisLabelContainerBounds.y1), alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
    }
  }
  _getAxisLabelLimitLength(limitSize, layerCount) {
    var _a, _b, _c, _d, _e;
    const { label, title, line, tick } = this.attribute, labelSpace = null !== (_a = label.space) && void 0 !== _a ? _a : 4;
    let limitLength = limitSize, titleHeight = 0, titleSpacing = 0;
    const axisLineWidth = line && line.visible ? null !== (_b = line.style.lineWidth) && void 0 !== _b ? _b : 1 : 0, tickLength = tick && tick.visible ? null !== (_c = tick.length) && void 0 !== _c ? _c : 4 : 0;
    if (title && title.visible && "string" == typeof title.text) {
      titleHeight = measureTextSize(title.text, title.textStyle, null === (_e = null === (_d = this.stage) || void 0 === _d ? void 0 : _d.getTheme()) || void 0 === _e ? void 0 : _e.text).height;
      const padding = normalizePadding(title.padding);
      titleSpacing = title.space + padding[0] + padding[2];
    }
    return limitLength && (limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount), limitLength;
  }
  release() {
    super.release(), this._breaks = null;
  }
};
LineAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(LineAxis, LineAxisMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/mixin/circle.js
var CircleAxisMixin = class {
  isInValidValue(value) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
    return Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? value > 1 : value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center, radius, inside = false, innerRadius = 0 } = this.attribute;
    return polarToCartesian(center, inside && innerRadius > 0 ? innerRadius : radius, startAngle + (endAngle - startAngle) * tickValue);
  }
  getVerticalVector(offset, inside = false, point5) {
    return getCircleVerticalVector(offset, point5, this.attribute.center, inside, this.attribute.inside);
  }
  getRelativeVector(point5) {
    const { center } = this.attribute;
    return [point5.y - center.y, -1 * (point5.x - center.x)];
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/overlap/circle-auto-limit.js
function findSiblingLabels(labels, selfIndex) {
  const len = labels.length;
  return {
    prevLabel: selfIndex >= 1 ? labels[selfIndex - 1] : labels[len - 1],
    nextLabel: selfIndex < len - 1 ? labels[selfIndex + 1] : labels[0]
  };
}
function adjustMaxLineWidth(label, maxLineWidth, ellipsis) {
  var _a;
  label.setAttributes({
    maxLineWidth,
    ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
  });
}
function adjustMaxHeight(labels, selfIndex, bounds) {
  const siblings = [];
  if (labels.length >= 3) {
    const { prevLabel, nextLabel } = findSiblingLabels(labels, selfIndex);
    siblings.push(prevLabel, nextLabel);
  } else 2 === labels.length && siblings.push(labels[0 === selfIndex ? 1 : 0]);
  const label = labels[selfIndex];
  let heightLimit = Math.min(Math.abs(label.attribute.y - bounds.y1), Math.abs(label.attribute.y - bounds.y2));
  siblings.forEach((sibling) => {
    heightLimit = Math.min(heightLimit, Math.abs(sibling.attribute.y - label.attribute.y));
  }), heightLimit > 0 && label.setAttributes({
    whiteSpace: "normal",
    heightLimit
  });
}
function circleAutoLimit(labels, config) {
  const { ellipsis, inside, bounds, autoWrap: autoWrap2, center } = config;
  inside || labels.forEach((label, index) => {
    const { x, y } = label.attribute, b = label.AABBBounds;
    if (isNumberClose(x, center.x)) {
      if (y > bounds.y2 || y < bounds.y1) return void adjustMaxLineWidth(label, 0, ellipsis);
      const boxWidth = bounds.x2 - bounds.x1;
      if (labels.length >= 3) {
        const { prevLabel, nextLabel } = findSiblingLabels(labels, index);
        let leftX = prevLabel.attribute.x, rightX = nextLabel.attribute.x;
        leftX > rightX && (leftX = nextLabel.attribute.x, rightX = prevLabel.attribute.x);
        const maxWidth = leftX === rightX ? boxWidth : x >= leftX && x <= rightX ? rightX - leftX : Math.min(Math.abs(leftX - x), Math.abs(rightX - x));
        label.AABBBounds.width() > maxWidth && adjustMaxLineWidth(label, maxWidth, ellipsis);
      } else label.AABBBounds.width() > boxWidth && adjustMaxLineWidth(label, boxWidth, ellipsis);
    } else x > center.x && b.x2 > bounds.x2 ? (adjustMaxLineWidth(label, bounds.x2 - x, ellipsis), autoWrap2 && adjustMaxHeight(labels, index, bounds)) : x < center.x && b.x1 < bounds.x1 && (adjustMaxLineWidth(label, x - bounds.x1, ellipsis), autoWrap2 && adjustMaxHeight(labels, index, bounds));
  });
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/circle.js
var __rest5 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisComponent();
var CircleAxis = class _CircleAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleAxis.defaultAttributes, attributes));
  }
  renderLine(container2) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, radius, center, innerRadius = 0, line = {}, inside = false, sides } = this.attribute;
    let lineGraphic, arcRadius = radius, arcInnerRadius = innerRadius;
    if (inside && innerRadius > 0 && (arcRadius = innerRadius, arcInnerRadius = 0), isValidNumber_default(sides) && sides >= 3) {
      const gridPoints = getCirclePoints(center, sides, arcRadius, startAngle, endAngle);
      lineGraphic = graphicCreator.path(Object.assign(Object.assign({}, line.style), {
        path: getPolygonPath(gridPoints, true)
      }));
    } else {
      const arcAttrs = Object.assign(Object.assign(Object.assign({}, center), {
        startAngle,
        endAngle,
        radius: arcRadius,
        innerRadius: arcInnerRadius
      }), line.style);
      lineGraphic = graphicCreator.circle(arcAttrs);
    }
    lineGraphic.name = AXIS_ELEMENT_NAME.line, lineGraphic.id = this._getNodeId("line"), isEmpty_default(line.state) || (lineGraphic.states = merge({}, DEFAULT_STATES2, line.state)), container2.add(lineGraphic);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const { center, radius, innerRadius = 0 } = this.attribute, _d = this.attribute.title, { space = 4, textStyle = {}, shape, background, state = {} } = _d, restAttrs = __rest5(_d, ["space", "textStyle", "shape", "background", "state"]);
    let titlePoint = center, labelHeight = 0;
    (null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside && (labelHeight = get_default(this.attribute.label, "style.fontSize", 12) + get_default(this.attribute.label, "space", 4));
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = radius + tickLength + labelHeight + space;
    let textBaseline = "middle", { position } = this.attribute.title;
    isNil_default(position) && (position = 0 === innerRadius ? "end" : "middle"), "start" === position ? (textBaseline = "bottom", titlePoint = {
      x: center.x,
      y: center.y - offset
    }) : "end" === position && (textBaseline = "top", titlePoint = {
      x: center.x,
      y: center.y + offset
    });
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      textStyle: Object.assign({
        textBaseline,
        textAlign: "center"
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    }), { angle: angle2 } = restAttrs;
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getSubTickLineItems() {
    var _a, _b;
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      const tickSegment = this.data[1].value - this.data[0].value, isAlignWithLable = null === (_b = null === (_a = this.attribute) || void 0 === _a ? void 0 : _a.tick) || void 0 === _b ? void 0 : _b.alignWithLabel;
      for (let i = 0; i < tickLineCount; i++) {
        const pre = tickLineItems[i], next = tickLineItems[i + 1];
        for (let j = 0; j < subCount; j++) {
          const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : isAlignWithLable ? 1 : pre.value + tickSegment), point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, inside);
          subTickLineItems.push({
            start: point5,
            end: endPoint,
            value
          });
        }
      }
    }
    return subTickLineItems;
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes)) return;
    const { inside, radius, center, size, label, orient } = this.attribute, bounds = size ? {
      x1: 0,
      y1: 0,
      x2: size.width,
      y2: size.height
    } : {
      x1: center.x - radius,
      y1: center.y - radius,
      x2: center.x + radius,
      y2: center.y + radius
    }, { layoutFunc, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, autoWrap: autoWrap2 } = label;
    isFunction_default(layoutFunc) ? layoutFunc(labelShapes, labelData, layer, this) : ((autoLimit2 || autoWrap2) && circleAutoLimit(labelShapes, {
      inside,
      autoWrap: autoWrap2,
      bounds,
      ellipsis: limitEllipsis,
      center
    }), autoHide2 && autoHide(labelShapes, {
      orient,
      method: autoHideMethod,
      separation: autoHideSeparation
    }));
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  getTextBaseline(vector) {
    return Math.abs(vector[1] / vector[0]) < 0.3 ? "middle" : vector[1] < 0 ? "bottom" : vector[1] > 0 ? "top" : "middle";
  }
  getLabelAlign(vector, inside, angle2) {
    return isNumberClose(vector[0], 0) ? {
      textAlign: "center",
      textBaseline: vector[1] > 0 ? "top" : "bottom"
    } : vector[0] < 0 ? {
      textAlign: "right",
      textBaseline: this.getTextBaseline(vector)
    } : vector[0] > 0 ? {
      textAlign: "left",
      textBaseline: this.getTextBaseline(vector)
    } : {
      textAlign: "center",
      textBaseline: "middle"
    };
  }
  getLabelPosition(point5, vector, text2, style2) {
    return point5;
  }
};
CircleAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(CircleAxis, CircleAxisMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/tick-data/util.js
var convertDomainToTickData = (domain) => domain.map((t, index) => ({
  index,
  value: t
}));
var labelOverlap = (prevLabel, nextLabel, gap = 0) => {
  const prevBounds = new AABBBounds(prevLabel).expand(gap / 2), nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
  return prevBounds.intersects(nextBounds);
};
var MIN_TICK_GAP = 12;
var calculateFlushPos = (basePosition, size, rangePosition, otherEnd) => rangePosition < basePosition ? Math.max(basePosition - size / 2, rangePosition) : rangePosition > basePosition ? Math.min(basePosition - size / 2, rangePosition - size) : rangePosition < otherEnd ? rangePosition : rangePosition - size;
var getCartesianLabelBounds = (scale6, domain, op) => {
  var _a;
  const { labelStyle, axisOrientType, labelFlush: labelFlush2, labelFormatter, startAngle = 0 } = op;
  let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
  "vertical" === labelStyle.direction && (labelAngle += degreeToRadian(90));
  const isHorizontal2 = ["bottom", "top"].includes(axisOrientType), isVertical = ["left", "right"].includes(axisOrientType);
  let scaleX = 1, scaleY = 0;
  isHorizontal2 || (isVertical ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), scaleY = -Math.sin(startAngle)));
  const textMeasure2 = initTextMeasure(labelStyle), range5 = scale6.range(), labelBoundsList = domain.map((v, i) => {
    var _a2, _b;
    const str2 = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure2.quickMeasure(str2), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), pos = scale6.scale(v), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
    let align, baseline, textX = baseTextX, textY = baseTextY;
    labelFlush2 && isHorizontal2 && 0 === i ? textX = calculateFlushPos(baseTextX, textWidth, range5[0], range5[range5.length - 1]) : labelFlush2 && isHorizontal2 && i === domain.length - 1 ? textX = calculateFlushPos(baseTextX, textWidth, range5[range5.length - 1], range5[0]) : align = null !== (_a2 = labelStyle.textAlign) && void 0 !== _a2 ? _a2 : "center", "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), labelFlush2 && isVertical && 0 === i ? textY = calculateFlushPos(baseTextY, textHeight, range5[0], range5[range5.length - 1]) : labelFlush2 && isVertical && i === domain.length - 1 ? textY = calculateFlushPos(baseTextY, textHeight, range5[range5.length - 1], range5[0]) : baseline = null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
    const bounds = new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight);
    return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
  });
  return labelBoundsList;
};
var isAxisHorizontal = (axisOrientType) => ["bottom", "top", "z"].includes(axisOrientType);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/type.js
var ScaleEnum;
!function(ScaleEnum3) {
  ScaleEnum3.Identity = "identity", ScaleEnum3.Linear = "linear", ScaleEnum3.Log = "log", ScaleEnum3.Pow = "pow", ScaleEnum3.Sqrt = "sqrt", ScaleEnum3.Symlog = "symlog", ScaleEnum3.Time = "time", ScaleEnum3.Quantile = "quantile", ScaleEnum3.Quantize = "quantize", ScaleEnum3.Threshold = "threshold", ScaleEnum3.Ordinal = "ordinal", ScaleEnum3.Point = "point", ScaleEnum3.Band = "band";
}(ScaleEnum || (ScaleEnum = {}));
var EnableScaleMap = {};
Object.values(ScaleEnum).forEach((v) => {
  EnableScaleMap[v] = true;
});
function isContinuous(type) {
  switch (type) {
    case ScaleEnum.Linear:
    case ScaleEnum.Log:
    case ScaleEnum.Pow:
    case ScaleEnum.Sqrt:
    case ScaleEnum.Symlog:
    case ScaleEnum.Time:
      return true;
    default:
      return false;
  }
}
function isDiscrete(type) {
  switch (type) {
    case ScaleEnum.Ordinal:
    case ScaleEnum.Point:
    case ScaleEnum.Band:
      return true;
    default:
      return false;
  }
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/utils/utils.js
function identity(x) {
  return x;
}
var logNegative = (x) => -Math.log(-x);
var expNegative = (x) => -Math.exp(-x);
var pow10 = (x) => isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
var powp = (base) => 10 === base ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
var logp = (base) => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), (x) => Math.log(x) / base);
var symlog = (c2) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c2));
var symexp = (c2) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c2;
function normalize2(a2, b) {
  if (a2 = Number(a2), b = Number(b), b -= a2) return (x) => (x - a2) / b;
  const result2 = Number.isNaN(b) ? NaN : 0.5;
  return () => result2;
}
function bimap(domain, range5, interpolate3) {
  const d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];
  let d0Fuc, r0Fuc;
  return d1 < d0 ? (d0Fuc = normalize2(d1, d0), r0Fuc = interpolate3(r1, r0)) : (d0Fuc = normalize2(d0, d1), r0Fuc = interpolate3(r0, r1)), (x) => r0Fuc(d0Fuc(x));
}
function calculateWholeRangeFromRangeFactor(range5, rangeFactor) {
  const k2 = (range5[1] - range5[0]) / (rangeFactor[1] - rangeFactor[0]), b = range5[0] - k2 * rangeFactor[0];
  return [b, k2 + b];
}
function polymap(domain, range5, interpolate3) {
  const j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j);
  let i = -1;
  for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range5 = range5.slice().reverse()); ++i < j; ) d[i] = normalize2(domain[i], domain[i + 1]), r[i] = interpolate3(range5[i], range5[i + 1]);
  return function(x) {
    const i2 = bisect(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
var nice = (domain, options) => {
  const newDomain = domain.slice();
  let startIndex = 0, endIndex = newDomain.length - 1, x0 = newDomain[startIndex], x1 = newDomain[endIndex];
  return x1 < x0 && ([startIndex, endIndex] = [endIndex, startIndex], [x0, x1] = [x1, x0]), newDomain[startIndex] = options.floor(x0), newDomain[endIndex] = options.ceil(x1), newDomain;
};
var niceNumber = (value, round = false) => {
  const exponent = Math.floor(Math.log10(value)), fraction = value / Math.pow(10, exponent);
  let niceFraction;
  return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent);
};
var restrictNumber = (value, domain) => {
  let min2, max2;
  return domain[0] < domain[1] ? (min2 = domain[0], max2 = domain[1]) : (min2 = domain[1], max2 = domain[0]), Math.min(Math.max(value, min2), max2);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/base-scale.js
var BaseScale = class {
  constructor() {
    this._rangeFactorStart = null, this._rangeFactorEnd = null;
  }
  _calculateWholeRange(range5) {
    return this._wholeRange ? this._wholeRange : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range5.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range5, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range5;
  }
  rangeFactor(_, slience, clear2) {
    return _ ? (2 === _.length && _.every((r) => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear2 ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
  }
  rangeFactorStart(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  rangeFactorEnd(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  generateFishEyeTransform() {
    var _a;
    if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
    const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions, range5 = this.range(), first = range5[0], last2 = range5[range5.length - 1], min2 = Math.min(first, last2), max2 = Math.max(first, last2), focus = clamp_default(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min2, max2), rangeRadius = isNil_default(radius) ? (max2 - min2) * radiusRatio : radius;
    let k0 = Math.exp(distortion);
    k0 = k0 / (k0 - 1) * rangeRadius;
    const k1 = distortion / rangeRadius;
    this._fishEyeTransform = (output) => {
      const delta = Math.abs(output - focus);
      if (delta >= rangeRadius) return output;
      if (delta <= 1e-6) return focus;
      const k2 = k0 * (1 - Math.exp(-delta * k1)) / delta * 0.75 + 0.25;
      return focus + (output - focus) * k2;
    };
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
  get(key, defaultValue) {
    var _a;
    return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/ordinal-scale.js
var implicit = Symbol("implicit");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/utils/interpolate.js
var { interpolateRgb } = color_exports;
function interpolate(a2, b) {
  const t = typeof b;
  let c2;
  if (isNil_default(b) || "boolean" === t) return () => b;
  if ("number" === t) return interpolateNumber(a2, b);
  if ("string" === t) {
    if (c2 = color_exports.Color.parseColorString(b)) {
      const rgb2 = interpolateRgb(color_exports.Color.parseColorString(a2), c2);
      return (t2) => rgb2(t2).formatRgb();
    }
    return interpolateNumber(Number(a2), Number(b));
  }
  return b instanceof color_exports.RGB ? interpolateRgb(a2, b) : b instanceof color_exports.Color ? interpolateRgb(a2.color, b.color) : b instanceof Date ? interpolateDate(a2, b) : interpolateNumber(Number(a2), Number(b));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/continuous-scale.js
var ContinuousScale = class extends BaseScale {
  constructor(transformer = identity, untransformer = identity) {
    super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = true, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity, this._piecewise = bimap, this._interpolate = interpolate;
  }
  calculateVisibleDomain(range5) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range5.length) {
      return [this.invert(range5[0]), this.invert(range5[1])];
    }
    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
  }
  fishEye(options, slience, clear2) {
    return options || clear2 ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._clamp(x)));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(y) {
    var _a;
    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y)));
  }
  domain(_, slience) {
    var _a;
    if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
    const nextDomain = Array.from(_, toNumber);
    return this._domain = nextDomain, this.rescale(slience);
  }
  range(_, slience) {
    if (!_) return this._range.slice();
    const nextRange = Array.from(_);
    return this._range = nextRange, this.rescale(slience);
  }
  rangeRound(_, slience) {
    const nextRange = Array.from(_);
    return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
    let n = Math.min(domainLength, rangeLength);
    if (domainLength && domainLength < rangeLength && this._forceAlign) {
      const deltaStep = rangeLength - domainLength + 1, last2 = domain[domainLength - 1], delta = domainLength >= 2 ? (last2 - domain[domainLength - 2]) / deltaStep : 0;
      for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last2 - delta * (deltaStep - i);
      n = rangeLength;
    }
    return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
  }
  clamp(_, f, slience) {
    return arguments.length ? (f ? (this._autoClamp = false, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity), this.rescale(slience)) : this._clamp !== identity;
  }
  interpolate(_, slience) {
    return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
  }
  ticks(count = 10) {
    return [];
  }
  tickData(count = 10) {
    const ticks6 = this.ticks(count);
    return (null != ticks6 ? ticks6 : []).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
    }));
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
  }
  rangeFactorEnd(_, slience) {
    return isNil_default(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
  }
  forceAlignDomainRange(forceAlign) {
    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/utils/tick-sample.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var niceNumbers = [1, 2, 5, 10];
var calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
  let step = 1, start = value;
  const middleIndex = Math.floor((tickCount - 1) / 2), absVal = Math.abs(value);
  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map((index) => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
};
var d3Ticks = memoize((start, stop, count, options) => {
  let reverse, n, ticks6, step, i = -1;
  if (count = +count, (start = +start) === (stop = +stop)) return [start];
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
  if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) * step;
  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
    step = 1;
    const r0 = Math.ceil(start), r1 = Math.floor(stop);
    if (!(r0 <= r1)) return [];
    for (ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = r0 + i;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) / step;
  }
  return reverse && ticks6.reverse(), ticks6;
});
var calculateTicksByStep = (start, stop, step) => {
  let n, ticks6, i = -1;
  if (step > 0) {
    let r0 = Math.floor(start / step), r1 = Math.ceil(stop / step);
    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.floor(start * step), r1 = Math.ceil(stop * step);
    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) / step;
  }
  return ticks6;
};
var appendTicksToCount = (ticks6, count, step) => {
  let n;
  const firstTick = ticks6[0], lastTick = ticks6[ticks6.length - 1], appendCount = count - ticks6.length;
  if (lastTick <= 0) {
    const headTicks2 = [];
    for (n = appendCount; n >= 1; n--) headTicks2.push(firstTick - n * step);
    return headTicks2.concat(ticks6);
  }
  if (firstTick >= 0) {
    for (n = 1; n <= appendCount; n++) ticks6.push(lastTick + n * step);
    return ticks6;
  }
  let headTicks = [];
  const tailTicks = [];
  for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
  return headTicks.concat(ticks6).concat(tailTicks);
};
var ticks2 = memoize((start, stop, count, options) => {
  let reverse, ticks6, n;
  if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  (reverse = stop < start) && (n = start, start = stop, stop = n);
  const stepRes = tickIncrement(start, stop, count);
  let step = stepRes.step;
  if (!isFinite(step)) return [];
  if (step > 0) {
    let cur = 1;
    const { power, gap } = stepRes, delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
    for (; cur <= 5 && (ticks6 = calculateTicksByStep(start, stop, step), ticks6.length > count + 1) && count > 2; ) step += delatStep, cur += 1;
    count > 2 && ticks6.length < count - 1 && (ticks6 = appendTicksToCount(ticks6, count, step));
  } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks6 = calculateTicksByStep(start, stop, step);
  return reverse && ticks6.reverse(), ticks6;
});
var getNickStep = (step) => {
  const power = Math.floor(Math.log(step) / Math.LN10), error = step / 10 ** power;
  let gap = niceNumbers[0];
  return error >= e10 ? gap = niceNumbers[3] : error >= e5 ? gap = niceNumbers[2] : error >= e2 && (gap = niceNumbers[1]), power >= 0 ? {
    step: gap * 10 ** power,
    gap,
    power
  } : {
    step: -(10 ** -power) / gap,
    gap,
    power
  };
};
function tickIncrement(start, stop, count) {
  const step = (stop - start) / Math.max(0, count);
  return getNickStep(step);
}
function forceTicks(start, stop, count) {
  let step;
  if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
  if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
  const ticks6 = new Array(count);
  for (let i = 0; i < count; i++) ticks6[i] = start + i * step;
  return ticks6;
}
function forceTickIncrement(start, stop, count) {
  return (stop - start) / Math.max(1, count - 1);
}
function stepTicks2(start, stop, step) {
  let n, reverse, i = -1;
  if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
  const count = Math.floor((stop - start) / step + 1), ticks6 = new Array(count);
  for (; ++i < count; ) ticks6[i] = start + i * step;
  return reverse && ticks6.reverse(), ticks6;
}
function niceLinear(d, count = 10) {
  let prestep, step, i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], maxIter = 10;
  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0; ) {
    if (step = tickIncrement(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
    if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;
    else {
      if (!(step < 0)) break;
      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function parseNiceOptions(originalDomain, option) {
  const hasForceMin = isNumber_default(option.forceMin), hasForceMax = isNumber_default(option.forceMax);
  let niceType = null;
  const niceMinMax = [];
  let niceDomain = null;
  const domainValidator = hasForceMin && hasForceMax ? (x) => x >= option.forceMin && x <= option.forceMax : hasForceMin ? (x) => x >= option.forceMin : hasForceMax ? (x) => x <= option.forceMax : null;
  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber_default(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber_default(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber_default(niceMinMax[0]) && isNumber_default(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber_default(niceMinMax[0]) || isNumber_default(niceMinMax[1]) ? isNumber_default(niceMinMax[0]) ? "max" : "min" : "all", {
    niceType,
    niceDomain,
    niceMinMax,
    domainValidator
  };
}
var fixPrecision = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
var d3TicksForLog = memoize((start, stop, count, base, transformer, untransformer, options) => {
  let u = start, v = stop;
  const r = v < u;
  r && ([u, v] = [v, u]);
  let k2, t, i = transformer(u), j = transformer(v), z = [];
  if (!(base % 1) && j - i < count) {
    if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
      for (; i <= j; ++i) for (k2 = 1; k2 < base; ++k2) if (t = i < 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
        if (t > v) break;
        z.push(t);
      }
    } else for (; i <= j; ++i) for (k2 = base - 1; k2 >= 1; --k2) if (t = i > 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
      if (t > v) break;
      z.push(t);
    }
    2 * z.length < count && (z = ticks2(u, v, count));
  } else z = ticks2(i, j, Math.min(j - i, count)).map(untransformer);
  return z = z.filter((t2) => 0 !== t2), (null == options ? void 0 : options.noDecimals) && (z = Array.from(new Set(z.map((t2) => Math.floor(t2))))), r ? z.reverse() : z;
});
var ticksBaseTransform = memoize((start, stop, count, base, transformer, untransformer) => {
  const ticksResult = [], ticksMap = {}, startExp = transformer(start), stopExp = transformer(stop);
  let ticksExp = [];
  if (Number.isInteger(base)) ticksExp = ticks2(startExp, stopExp, count);
  else {
    const stepExp = (stopExp - startExp) / (count - 1);
    for (let i = 0; i < count; i++) ticksExp.push(startExp + i * stepExp);
  }
  return ticksExp.forEach((tl) => {
    const power = untransformer(tl), nicePower = Number.isInteger(base) ? fixPrecision(start, stop, power) : fixPrecision(start, stop, niceNumber(power)), scopePower = fixPrecision(start, stop, restrictNumber(nicePower, [start, stop]));
    !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
  }), ticksResult;
});
var forceTicksBaseTransform = memoize((start, stop, count, transformer, untransformer) => forceTicks(transformer(start), transformer(stop), count).map((te) => niceNumber(untransformer(te))));
var forceStepTicksBaseTransform = memoize((start, stop, step, transformer, untransformer) => stepTicks2(transformer(start), transformer(stop), step).map((te) => niceNumber(untransformer(te))));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/linear-scale.js
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super(...arguments), this.type = ScaleEnum.Linear;
  }
  clone() {
    var _a;
    const scale6 = new _LinearScale();
    return scale6.domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate), this._niceType && (scale6._niceType = this._niceType, scale6._domainValidator = this._domainValidator, scale6._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), scale6;
  }
  tickFormat() {
    return () => {
    };
  }
  d3Ticks(count = 10, options) {
    const d = this.calculateVisibleDomain(this._range);
    return d3Ticks(d[0], d[d.length - 1], count, options);
  }
  ticks(count = 10, options) {
    var _a;
    if (isFunction_default(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
    let ticksResult = ticks2(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
    if (!ticksResult.length) return ticksResult;
    if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);
    else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
      const newNiceDomain = curNiceDomain.slice();
      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
        const min2 = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max2 = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
        ticksResult = ticksResult.filter((entry) => entry >= min2 && entry <= max2);
      }
    }
    return ticksResult;
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicks(d[0], d[d.length - 1], count);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks2(d[0], d[d.length - 1], step);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [];
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else this._niceType = "all";
    if (this._niceType) {
      const niceDomain = niceLinear(originalDomain.slice(), count);
      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
    }
    return this;
  }
  niceMin(count = 10) {
    this._niceType = "min";
    const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear(this.domain(), count);
    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax(count = 10) {
    this._niceType = "max";
    const minD = this._domain[0], niceDomain = niceLinear(this._domain.slice(), count);
    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/log-nice-mixin.js
var LogNiceMixin = class {
  nice(count = 10, option) {
    var _b, _c, _d, _e;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), null !== (_c = null === (_b = this.getNiceConfig) || void 0 === _b ? void 0 : _b.call(this)) && void 0 !== _c ? _c : {
        floor: (x) => Math.floor(x),
        ceil: (x) => Math.ceil(x)
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_d = niceMinMax[1]) && void 0 !== _d ? _d : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_e = niceMinMax[0]) && void 0 !== _e ? _e : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/log-scale.js
function reflect(f) {
  return (x) => -f(-x);
}
function limitPositiveZero(min2 = Number.EPSILON) {
  return (x) => Math.max(x, min2);
}
function limitNegativeZero(min2 = Number.EPSILON) {
  return (x) => Math.min(x, -min2);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
  }
  clone() {
    return new _LogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).base(this._base);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    super.rescale();
    const logs = logp(this._base), pows = powp(this._base);
    return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), this;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._limit(this._clamp(x))));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  base(_, slience) {
    return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
  }
  tickFormat() {
    return identity;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
    return d3TicksForLog(u, v, count, this._base, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
  }
  getNiceConfig() {
    return {
      floor: (x) => this._pows(Math.floor(this._logs(this._limit(x)))),
      ceil: (x) => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
    };
  }
};
mixin(LogScale, LogNiceMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/symlog-scale.js
var SymlogScale = class _SymlogScale extends LinearScale {
  constructor() {
    super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
  }
  clone() {
    return new _SymlogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).constant(this._const);
  }
  constant(_, slience) {
    return arguments.length ? (this._const = _, this.transformer = symlog(_), this.untransformer = symexp(_), this.rescale(slience)) : this._const;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = d[0], v = d[d.length - 1];
    return d3TicksForLog(u, v, count, this._const, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
  }
};
mixin(SymlogScale, LogNiceMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/utils/time.js
var timeIntervals = [["second", 1, SECOND], ["second", 5, 5 * SECOND], ["second", 10, 10 * SECOND], ["second", 30, 30 * SECOND], ["minute", 1, MINUTE], ["minute", 5, 5 * MINUTE], ["minute", 10, 10 * MINUTE], ["minute", 30, 30 * MINUTE], ["hour", 1, HOUR], ["hour", 3, 3 * HOUR], ["hour", 6, 6 * HOUR], ["hour", 12, 12 * HOUR], ["day", 1, DAY], ["day", 2, 2 * DAY], ["day", 7, 7 * DAY], ["month", 1, MONTH], ["month", 3, 3 * MONTH], ["month", 6, 6 * MONTH], ["year", 1, 365 * DAY]];

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/identity-scale.js
var implicit2 = Symbol("implicit");

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/node_modules/@visactor/vscale/es/utils/tick-wilkinson-extended.js
var eps = 100 * Number.EPSILON;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/tick-data/continuous.js
function getScaleTicks(op, scale6, count, getTicks) {
  let scaleTicks;
  const { breakData } = op;
  if (breakData && breakData()) {
    const { breakDomains } = breakData(), domain = scale6.domain();
    scaleTicks = [];
    for (let i = 0; i < domain.length - 1; i++) {
      getTicks(count, [domain[i], domain[i + 1]]).forEach((tick) => {
        breakDomains.some((breakDomain) => tick >= breakDomain[0] && tick <= breakDomain[1]) || scaleTicks.push(tick);
      });
    }
    scale6.domain(domain);
  } else scaleTicks = getTicks(count);
  return scaleTicks;
}
function forceItemVisible2(sourceItem, items, check, comparator, inverse = false) {
  if (check && !items.includes(sourceItem)) {
    let remainLength = items.length;
    if (remainLength > 1) {
      inverse ? items.push(sourceItem) : items.unshift(sourceItem);
      for (let i = 0; i < remainLength; i++) {
        const index = inverse ? remainLength - 1 - i : i;
        if (!comparator(items[index])) break;
        items.splice(index, 1), i--, remainLength--;
      }
    }
  }
}
var continuousTicks = (scale6, op) => {
  var _a, _b;
  if (!isContinuous(scale6.type)) return convertDomainToTickData(scale6.domain());
  const range5 = scale6.range(), rangeSize = Math.abs(range5[range5.length - 1] - range5[0]);
  if (rangeSize < 2) return convertDomainToTickData([scale6.domain()[0]]);
  const { tickCount, forceTickCount, tickStep: tickStep5, noDecimals = false, labelStyle, breakData } = op;
  let scaleTicks;
  if (isValid_default(tickStep5)) ticks6 = scale6.stepTicks(tickStep5), breakDomains = breakData && breakData() ? breakData().breakDomains : null, scaleTicks = breakDomains && breakDomains.length ? ticks6.filter((tick) => breakDomains.every((breakDomain) => tick < breakDomain[0] || tick > breakDomain[1])) : ticks6;
  else if (isValid_default(forceTickCount)) scaleTicks = getScaleTicks(op, scale6, forceTickCount, (count, subDomain) => subDomain && subDomain.length ? scale6.domain(subDomain, true).forceTicks(count) : scale6.forceTicks(count));
  else if ("d3" === op.tickMode) {
    const count = null !== (_a = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount) && void 0 !== _a ? _a : 5;
    scaleTicks = getScaleTicks(op, scale6, count, (count2, subDomain) => subDomain && subDomain.length ? scale6.domain(subDomain, true).d3Ticks(count2, {
      noDecimals
    }) : scale6.d3Ticks(count2, {
      noDecimals
    }));
  } else {
    const count = null !== (_b = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount) && void 0 !== _b ? _b : 5, customTicks = isFunction_default(op.tickMode) ? op.tickMode : void 0;
    scaleTicks = getScaleTicks(op, scale6, count, (count2, subDomain) => subDomain && subDomain.length ? scale6.domain(subDomain, true).ticks(count2, {
      noDecimals,
      customTicks
    }) : scale6.ticks(count2, {
      noDecimals,
      customTicks
    }));
  }
  var ticks6, breakDomains;
  const domain = scale6.domain();
  if (op.labelFirstVisible && domain[0] !== scaleTicks[0] && !scaleTicks.includes(domain[0]) && scaleTicks.unshift(domain[0]), op.labelLastVisible && domain[domain.length - 1] !== scaleTicks[scaleTicks.length - 1] && !scaleTicks.includes(domain[domain.length - 1]) && scaleTicks.push(domain[domain.length - 1]), op.sampling && scaleTicks.length > 1 && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
    const { labelGap = 4, labelFlush: labelFlush2 } = op, MIN_FONT_SIZE = 6;
    let items;
    if (scaleTicks.length * MIN_FONT_SIZE > rangeSize) {
      const samplingScaleTicks = [], step = Math.floor(scaleTicks.length * MIN_FONT_SIZE / rangeSize);
      scaleTicks.forEach((tick, index) => {
        index % step != 0 && index !== scaleTicks.length - 1 || samplingScaleTicks.push(tick);
      }), items = getCartesianLabelBounds(scale6, samplingScaleTicks, op).map((bounds, i) => ({
        AABBBounds: bounds,
        value: samplingScaleTicks[i]
      }));
    } else items = getCartesianLabelBounds(scale6, scaleTicks, op).map((bounds, i) => ({
      AABBBounds: bounds,
      value: scaleTicks[i]
    }));
    const firstSourceItem = items[0], lastSourceItem = last(items), samplingMethod = breakData && breakData() ? methods2.greedy : methods2.parity;
    for (; items.length >= 3 && hasOverlap(items, labelGap); ) items = samplingMethod(items, labelGap);
    const checkFirst = op.labelFirstVisible;
    let checkLast = op.labelLastVisible;
    textIntersect(firstSourceItem, lastSourceItem, labelGap) && items.includes(lastSourceItem) && items.length > 1 && checkFirst && checkLast && (items.splice(items.indexOf(lastSourceItem), 1), checkLast = false), forceItemVisible2(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, labelGap)), forceItemVisible2(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, labelGap) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, labelGap), true);
    const ticks7 = items.map((item) => item.value);
    ticks7.length < 3 && labelFlush2 && (ticks7.length > 1 && ticks7.pop(), last(ticks7) !== last(scaleTicks) && ticks7.push(last(scaleTicks))), scaleTicks = ticks7;
  }
  return convertDomainToTickData(scaleTicks);
};
var methods2 = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 == 0);
  },
  greedy: function(items, sep) {
    let a2;
    return items.filter((b, i) => (!i || !textIntersect(a2, b, sep)) && (a2 = b, true));
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/tick-data/discrete/linear.js
var getOneDimensionalLabelBounds = (scale6, domain, op, isHorizontal2) => getCartesianLabelBounds(scale6, domain, op).map((bounds) => isHorizontal2 ? [bounds.x1, bounds.x2, bounds.width()] : [bounds.y1, bounds.y2, bounds.height()]);
var boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
var boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;
var linearDiscreteTicks = (scale6, op) => {
  var _a;
  const domain = scale6.domain();
  if (!domain.length) return [];
  const { tickCount, forceTickCount, tickStep: tickStep5, labelGap = 4, axisOrientType, labelStyle } = op, isHorizontal2 = isAxisHorizontal(axisOrientType), range5 = scale6.range(), rangeSize = scale6.calculateWholeRangeSize();
  if (rangeSize < 2) return op.labelLastVisible ? convertDomainToTickData([domain[domain.length - 1]]) : convertDomainToTickData([domain[0]]);
  let scaleTicks;
  if (isValid_default(tickStep5)) scaleTicks = scale6.stepTicks(tickStep5);
  else if (isValid_default(forceTickCount)) scaleTicks = scale6.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale6.ticks(count);
  } else if (op.sampling) {
    const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = minInArray(range5), rangeEnd = maxInArray(range5);
    if (domain.length <= rangeSize / fontSize) {
      const incrementUnit = (rangeEnd - rangeStart) / domain.length, labelBoundsList = getOneDimensionalLabelBounds(scale6, domain, op, isHorizontal2), minBoundsLength = Math.min(...labelBoundsList.map((bounds) => bounds[2])), stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), false);
      scaleTicks = scale6.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), scaleTicks.push(domain[domain.length - 1]));
    } else {
      const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]], tempList = getOneDimensionalLabelBounds(scale6, tempDomain, op, isHorizontal2);
      let maxBounds = null;
      tempList.forEach((current) => {
        maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
      });
      const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
      scaleTicks = scale6.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale6.scale(scaleTicks[scaleTicks.length - 1]) - scale6.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), scaleTicks.push(domain[domain.length - 1]));
    }
  } else scaleTicks = scale6.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
  let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
  const validateStep = (step2) => {
    let success = true, ptr = 0;
    do {
      ptr + step2 < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step2], labelGap) && (success = false), ptr += step2;
    } while (success && ptr < domain.length);
    return success;
  }, minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, (step2) => validateStep(step2) ? 1 : -1);
  let step = minValidStep;
  do {
    if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++;
    else {
      if (!labelLastVisible) {
        resultStep = step;
        break;
      }
      {
        const lastIndex = domain.length - 1;
        let ptr, delCount = 0;
        ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
        do {
          if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
          delCount++;
        } while (ptr > 0);
        if (ptr === lastIndex) {
          resultStep = step, resultDelCount = delCount;
          break;
        }
        {
          const tickCount = Math.floor(domain.length / step) - delCount + 1;
          if (tickCount < resultTickCount) break;
          {
            resultTickCount = tickCount;
            const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
            if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), distance1 <= distance2) break;
          }
        }
      }
      step++;
    }
  } while (step <= domain.length);
  return {
    step: resultStep,
    delCount: resultDelCount
  };
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/tick-data/discrete/polar-angle.js
var getPolarAngleLabelBounds = (scale6, domain, op) => {
  var _a;
  const { labelStyle, getRadius, labelOffset, labelFormatter, inside } = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure2 = initTextMeasure(labelStyle);
  return domain.map((v) => {
    const str2 = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure2.quickMeasure(str2), textWidth = Math.max(width, MIN_TICK_GAP), textHeight = Math.max(height, MIN_TICK_GAP), angle2 = scale6.scale(v), center = {
      x: 0,
      y: 0
    };
    let textX = 0, textY = 0;
    const orient = {
      align: labelStyle.textAlign,
      baseline: labelStyle.textBaseline
    }, { x, y } = getPolarAngleLabelPosition(angle2, center, radius, labelOffset, inside);
    orient.align || (isNumberClose(x, center.x) ? orient.baseline || (orient.baseline = y > center.y ? "top" : "bottom") : x > center.x ? orient.align = "left" : x < center.x && (orient.align = "right")), textX = x + ("right" === orient.align ? -textWidth : "left" === orient.align ? 0 : -textWidth / 2), textY = y + ("bottom" === orient.baseline ? -textHeight : "top" === orient.baseline ? 0 : -textHeight / 2);
    return new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
  });
};
var polarAngleAxisDiscreteTicks = (scale6, op) => {
  const { tickCount, forceTickCount, tickStep: tickStep5, getRadius, labelOffset, labelGap = 0, labelStyle } = op, radius = null == getRadius ? void 0 : getRadius();
  if (!radius) return convertDomainToTickData(scale6.domain());
  let scaleTicks;
  if (isValid_default(tickStep5)) scaleTicks = scale6.stepTicks(tickStep5);
  else if (isValid_default(forceTickCount)) scaleTicks = scale6.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const range5 = scale6.range(), rangeSize = Math.abs(range5[range5.length - 1] - range5[0]), count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale6.ticks(count);
  } else if (op.sampling) {
    const domain = scale6.domain(), range5 = scale6.range(), labelBoundsList = getPolarAngleLabelBounds(scale6, domain, op), rangeStart = minInArray(range5), rangeEnd = maxInArray(range5), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, { step, delCount } = getStep2(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min2, curBounds) => Math.min(min2, curBounds.width(), curBounds.height()), Number.MAX_VALUE) / incrementUnit));
    scaleTicks = scale6.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
  } else scaleTicks = scale6.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep2 = (domain, labelBoundsList, labelGap, defaultStep) => {
  let step = defaultStep;
  do {
    let success = true;
    step++;
    let ptr = 0;
    do {
      ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = false), ptr += step;
    } while (success && ptr < domain.length);
    if (success) break;
  } while (step <= domain.length);
  let delCount = 0;
  if (domain.length > 2) {
    let ptr = domain.length - domain.length % step;
    for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]); ) delCount++, ptr -= step;
  }
  return {
    step,
    delCount
  };
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/tick-data/ticks.js
var ticks3 = (scale6, op) => {
  if (isContinuous(scale6.type)) return continuousTicks(scale6, op);
  if (isDiscrete(scale6.type)) {
    if ("cartesian" === op.coordinateType) return linearDiscreteTicks(scale6, op);
    if ("polar" === op.coordinateType && "angle" === op.axisOrientType) return polarAngleAxisDiscreteTicks(scale6, op);
  }
  return convertDomainToTickData(scale6.domain());
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/crosshair/polygon-sector.js
loadPolygonSectorCrosshairComponent();
var PolygonSectorCrosshair = class _PolygonSectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonSectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center, radius, innerRadius = 0, polygonSectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute, points = [];
    points.push(polarToCartesian(center, innerRadius, startAngle)), points.push(polarToCartesian(center, radius * Math.cos((endAngle - startAngle) / 2), startAngle)), points.push(polarToCartesian(center, radius, (startAngle + endAngle) / 2)), points.push(polarToCartesian(center, radius * Math.cos((endAngle - startAngle) / 2), endAngle)), points.push(polarToCartesian(center, innerRadius, endAngle));
    return container2.createOrUpdateChild("crosshair-polygon-sector", Object.assign({
      path: getPolygonPath(points, true)
    }, polygonSectorStyle), "path");
  }
  setLocation(point5) {
    const { center, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center, point5));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
PolygonSectorCrosshair.defaultAttributes = {
  polygonSectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/overlap/bitmap.js
var RIGHT0 = new Uint32Array(33);
var RIGHT1 = new Uint32Array(33);
RIGHT1[0] = 0, RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= 32; ++i) RIGHT1[i] = RIGHT1[i - 1] << 1 | 1, RIGHT0[i] = ~RIGHT1[i];
function bitmap(w, h) {
  const array4 = new Uint32Array(~~((w * h + 32) / 32));
  function _set(index, mask) {
    array4[index] |= mask;
  }
  function _clear(index, mask) {
    array4[index] &= mask;
  }
  return {
    array: array4,
    get: (x, y) => {
      const index = y * w + x;
      return array4[index >>> 5] & 1 << (31 & index);
    },
    set: (x, y) => {
      const index = y * w + x;
      _set(index >>> 5, 1 << (31 & index));
    },
    clear: (x, y) => {
      const index = y * w + x;
      _clear(index >>> 5, ~(1 << (31 & index)));
    },
    getRange: ({ x1, y1, x2, y2 }) => {
      if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) return true;
      let start, end, indexStart, indexEnd, r = y2;
      for (; r >= y1; --r) if (start = r * w + x1, end = r * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) {
        if (array4[indexStart] & RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]) return true;
      } else {
        if (array4[indexStart] & RIGHT0[31 & start]) return true;
        if (array4[indexEnd] & RIGHT1[1 + (31 & end)]) return true;
        for (let i = indexStart + 1; i < indexEnd; ++i) if (array4[i]) return true;
      }
      return false;
    },
    setRange: ({ x1, y1, x2, y2 }) => {
      if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) return;
      let start, end, indexStart, indexEnd, i;
      for (; y1 <= y2; ++y1) if (start = y1 * w + x1, end = y1 * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _set(indexStart, RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]);
      else for (_set(indexStart, RIGHT0[31 & start]), _set(indexEnd, RIGHT1[1 + (31 & end)]), i = indexStart + 1; i < indexEnd; ++i) _set(i, 4294967295);
    },
    clearRange: ({ x1, y1, x2, y2 }) => {
      let start, end, indexStart, indexEnd, i;
      for (; y1 <= y2; ++y1) if (start = y1 * w + x1, end = y1 * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _clear(indexStart, RIGHT1[31 & start] | RIGHT0[1 + (31 & end)]);
      else for (_clear(indexStart, RIGHT1[31 & start]), _clear(indexEnd, RIGHT0[1 + (31 & end)]), i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
    },
    outOfBounds: ({ x1, y1, x2, y2 }) => x1 < 0 || y1 < 0 || y2 >= h || x2 >= w,
    toImageData: (ctx) => {
      const imageData = ctx.createImageData(w, h), data = imageData.data;
      for (let y = 0; y < h; ++y) for (let x = 0; x < w; ++x) {
        const index = y * w + x, offset = 4 * index, occupied = array4[index >>> 5] & 1 << (31 & index);
        data[offset + 0] = 255 * occupied, data[offset + 1] = 255 * occupied, data[offset + 2] = 255 * occupied, data[offset + 3] = 31;
      }
      return imageData;
    }
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/overlap/scaler.js
function bitmapTool(width, height, padding = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}) {
  const { top = 0, left = 0, right = 0, bottom = 0 } = padding, ratio = Math.max(1, Math.sqrt(width * height / 1e6)), w = ~~((width + left + right + ratio) / ratio), h = ~~((height + top + bottom + ratio) / ratio), scale6 = (_) => ~~(_ / ratio);
  return scale6.bitmap = () => bitmap(w, h), scale6.x = (_) => ~~((_ + left) / ratio), scale6.y = (_) => ~~((_ + top) / ratio), scale6.ratio = ratio, scale6.padding = padding, scale6.width = width, scale6.height = height, scale6;
}
function clampRangeByBitmap($, range5) {
  const { x1, x2, y1, y2 } = range5, { top = 0, left = 0, right = 0, bottom = 0 } = $.padding, _x1 = clamp_default(x1, -left, $.width + right), _x2 = clamp_default(x2, -left, $.width + right), _y1 = clamp_default(y1, -top, $.height + bottom), _y2 = clamp_default(y2, -top, $.height + bottom);
  return {
    x1: $.x(_x1),
    x2: $.x(_x2),
    y1: $.y(_y1),
    y2: $.y(_y2)
  };
}
function boundToRange($, bound, clamp2 = false) {
  return clamp2 ? clampRangeByBitmap($, bound) : {
    x1: $.x(bound.x1),
    x2: $.x(bound.x2),
    y1: $.y(bound.y1),
    y2: $.y(bound.y2)
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/overlap/place.js
function canPlace($, bitmap2, bound, checkBound = true, pad2 = 0) {
  let range5 = bound;
  pad2 > 0 && (range5 = {
    x1: bound.x1 - pad2,
    x2: bound.x2 + pad2,
    y1: bound.y1 - pad2,
    y2: bound.y2 + pad2
  }), range5 = boundToRange($, range5);
  const outOfBounds = bitmap2.outOfBounds(range5);
  return (!checkBound || !outOfBounds) && (outOfBounds && (range5 = clampRangeByBitmap($, range5)), !bitmap2.getRange(range5));
}
function placeToCandidates($, bitmap2, text2, candidates = [], clampForce = true, pad2 = 0, changePosition = false) {
  const validCandidates = candidates.filter((candidate) => isValid_default(candidate));
  for (let i = 0; i < validCandidates.length; i++) {
    let measureText;
    if (measureText = changePosition ? text2 : text2.clone(), measureText.setAttributes(validCandidates[i]), canPlace($, bitmap2, measureText.AABBBounds, clampForce, pad2)) return bitmap2.setRange(boundToRange($, measureText.AABBBounds, true)), validCandidates[i];
  }
  return false;
}
function place($, bitmap2, s2, attrs, text2, bounds, labeling) {
  var _a, _b;
  const clampForce = null === (_a = attrs.overlap) || void 0 === _a ? void 0 : _a.clampForce, overlapPadding = null === (_b = attrs.overlap) || void 0 === _b ? void 0 : _b.overlapPadding;
  if ("bound" === s2.type || "position" === s2.type) {
    if (isFunction_default(labeling)) {
      const candidates = ((isFunction_default(s2.position) ? s2.position(text2.attribute) : s2.position) || defaultLabelPosition(attrs.type)).map((p) => labeling(text2.AABBBounds, bounds, p, attrs.offset)), shouldClone = false === s2.restorePosition;
      return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding, shouldClone);
    }
    return false;
  }
  if ("moveY" === s2.type) {
    const candidates = (s2.offset ? isFunction_default(s2.offset) ? s2.offset(text2.attribute) : s2.offset : []).map((dy) => ({
      x: text2.attribute.x,
      y: text2.attribute.y + dy
    }));
    return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  if ("moveX" === s2.type) {
    const candidates = (s2.offset ? isFunction_default(s2.offset) ? s2.offset(text2.attribute) : s2.offset : []).map((dx) => ({
      x: text2.attribute.x + dx,
      y: text2.attribute.y
    }));
    return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  return false;
}
var DefaultPositions = ["top", "bottom", "right", "left", "top-right", "bottom-right", "top-left", "bottom-left"];
var DefaultRectPositions = ["top", "inside-top", "inside"];
function defaultLabelPosition(type) {
  return "rect" === type ? DefaultRectPositions : DefaultPositions;
}
function clampText(text2, width, height, padding = {}) {
  const { x1, x2, y1, y2 } = text2.AABBBounds, { top = 0, left = 0, right = 0, bottom = 0 } = padding, minX = Math.min(x1, x2), maxX = Math.max(x1, x2), minY = Math.min(y1, y2), maxY = Math.max(y1, y2), maxXWithPadding = width + right, maxYWithPadding = height + bottom;
  let dx = 0, dy = 0;
  return minX < 0 - left ? dx = -minX : maxX > maxXWithPadding && (dx = maxXWithPadding - maxX), minY < 0 - top ? dy = -minY : maxY > maxYWithPadding && (dy = maxYWithPadding - maxY), {
    dx,
    dy
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/animate/animate.js
var fadeIn = (textAttribute = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_a = textAttribute.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute.strokeOpacity) && void 0 !== _c ? _c : 1
    }
  };
};
var fadeOut = (textAttribute = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = textAttribute.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute.strokeOpacity) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};
var animationEffects = {
  fadeIn,
  fadeOut
};
function getAnimationAttributes(textAttribute, type) {
  var _a, _b;
  return null !== (_b = null === (_a = animationEffects[type]) || void 0 === _a ? void 0 : _a.call(animationEffects, textAttribute)) && void 0 !== _b ? _b : {
    from: {},
    to: {}
  };
}
function updateAnimation(prev, next, animationConfig) {
  const changeAttributes = (prev2, next2) => {
    const changed = {};
    for (const key in next2.attribute) prev2.attribute[key] !== next2.attribute[key] && (changed[key] = next2.attribute[key]);
    return changed;
  };
  if (!isArray_default(animationConfig)) {
    const { duration, easing, increaseEffect = true } = animationConfig;
    return prev.animate().to(changeAttributes(prev, next), duration, easing), void (increaseEffect && "text" === prev.type && "text" === next.type && playIncreaseCount(prev, next, duration, easing));
  }
  animationConfig.forEach((cfg) => {
    const { duration, easing, increaseEffect = true, channel } = cfg, { to } = update(prev, next, channel, cfg.options);
    isEmpty_default(to) || prev.animate().to(changeAttributes(prev, next), duration, easing), increaseEffect && "text" === prev.type && "text" === next.type && playIncreaseCount(prev, next, duration, easing);
  });
}
var update = (prev, next, channel, options) => {
  const from = Object.assign({}, prev.attribute), to = Object.assign({}, next.attribute);
  return array(null == options ? void 0 : options.excludeChannels).forEach((key) => {
    delete to[key];
  }), Object.keys(to).forEach((key) => {
    channel && !channel.includes(key) && delete to[key];
  }), {
    from,
    to
  };
};
function playIncreaseCount(prev, next, duration, easing) {
  prev.attribute.text !== next.attribute.text && isValidNumber_default(Number(prev.attribute.text) * Number(next.attribute.text)) && prev.animate().play(new IncreaseCount({
    text: prev.attribute.text
  }, {
    text: next.attribute.text
  }, duration, easing));
}
var DefaultLabelAnimation = {
  mode: "same-time",
  duration: 300,
  easing: "linear"
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/util.js
function isQuadrantLeft(quadrant) {
  return 3 === quadrant || 4 === quadrant;
}
function isQuadrantRight(quadrant) {
  return 1 === quadrant || 2 === quadrant;
}
function lineCirclePoints(a2, b, c2, x0, y0, r) {
  if (0 === a2 && 0 === b || r <= 0) return [];
  if (0 === a2) {
    const y12 = -c2 / b, fd2 = r ** 2 - (y12 - y0) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x0,
      y: y12
    }];
    return [{
      x: Math.sqrt(fd2) + x0,
      y: y12
    }, {
      x: -Math.sqrt(fd2) + x0,
      y: y12
    }];
  }
  if (0 === b) {
    const x12 = -c2 / a2, fd2 = r ** 2 - (x12 - x0) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x12,
      y: y0
    }];
    return [{
      x: x12,
      y: Math.sqrt(fd2) + y0
    }, {
      x: x12,
      y: -Math.sqrt(fd2) + y0
    }];
  }
  const fa = (b / a2) ** 2 + 1, fb = 2 * ((c2 / a2 + x0) * (b / a2) - y0), fd = fb ** 2 - 4 * fa * ((c2 / a2 + x0) ** 2 + y0 ** 2 - r ** 2);
  if (fd < 0) return [];
  const y1 = (-fb + Math.sqrt(fd)) / (2 * fa), y2 = (-fb - Math.sqrt(fd)) / (2 * fa), x1 = -(b * y1 + c2) / a2;
  return 0 === fd ? [{
    x: x1,
    y: y1
  }] : [{
    x: x1,
    y: y1
  }, {
    x: -(b * y2 + c2) / a2,
    y: y2
  }];
}
function connectLineRadian(radius, length2) {
  return length2 > 2 * radius ? NaN : 2 * Math.asin(length2 / 2 / radius);
}
function checkBoundsOverlap(boundsA, boundsB) {
  const { x1: ax1, y1: ay1, x2: ax2, y2: ay2 } = boundsA, { x1: bx1, y1: by1, x2: bx2, y2: by2 } = boundsB;
  return !(ax1 <= bx1 && ax2 <= bx1 || ax1 >= bx2 && ax2 >= bx2 || ay1 <= by1 && ay2 <= by1 || ay1 >= by2 && ay2 >= by2);
}
var labelingPoint = (textBounds, graphicBounds, position = "top", offset = 0) => {
  if (!textBounds) return;
  const { x1, y1, x2, y2 } = textBounds, width = Math.abs(x2 - x1), height = Math.abs(y2 - y1), anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2, anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2;
  let sx = 0, sy = 0, offsetX = 0, offsetY = 0;
  graphicBounds && (offsetX = Math.abs(graphicBounds.x1 - graphicBounds.x2) / 2, offsetY = Math.abs(graphicBounds.y1 - graphicBounds.y2) / 2);
  const angle2 = {
    "top-right": -235,
    "top-left": 235,
    "bottom-right": 45,
    "bottom-left": -45
  };
  switch (position) {
    case "top":
      sy = -1;
      break;
    case "bottom":
      sy = 1;
      break;
    case "left":
      sx = -1;
      break;
    case "right":
      sx = 1;
      break;
    case "bottom-left":
    case "bottom-right":
    case "top-left":
    case "top-right":
      sx = Math.sin(angle2[position] * (Math.PI / 180)), sy = Math.cos(angle2[position] * (Math.PI / 180));
      break;
    case "center":
      sx = 0, sy = 0;
  }
  return {
    x: anchorX + sx * (offset + offsetX) + Math.sign(sx) * (width / 2),
    y: anchorY + sy * (offset + offsetY) + Math.sign(sy) * (height / 2)
  };
};
var getPointsOfLineArea = (graphic) => {
  if (!graphic || !graphic.attribute) return [];
  const { points, segments: segments2 } = graphic.attribute;
  if (segments2 && segments2.length) {
    const res = [];
    return segments2.forEach((seg) => {
      seg.points.forEach((point5) => {
        res.push(point5);
      });
    }), res;
  }
  return points;
};
function labelingLineOrArea(textBounds, graphicBounds, position = "end", offset = 0) {
  if (!textBounds || !graphicBounds) return {
    x: 1 / 0,
    y: 1 / 0
  };
  const { x1, x2 } = textBounds, width = Math.abs(x2 - x1), anchorX = graphicBounds.x1;
  let x = anchorX;
  return "end" === position ? x = anchorX + width / 2 + offset : "start" === position && (x = anchorX - width / 2 - offset), {
    x,
    y: graphicBounds.y1
  };
}
function connectLineBetweenBounds(boundA, boundB) {
  if (!boundA || !boundB) return;
  if (isRectIntersect(boundA, boundB, true)) return;
  const x1 = Math.min(boundA.x1, boundA.x2), y1 = Math.min(boundA.y1, boundA.y2), x2 = Math.min(boundB.x1, boundB.x2), y2 = Math.min(boundB.y1, boundB.y2), w1 = Math.abs(boundA.x2 - x1) / 2, h1 = Math.abs(boundA.y2 - y1) / 2, w2 = Math.abs(boundB.x2 - x2) / 2, h2 = Math.abs(boundB.y2 - y2) / 2, cx1 = x1 + w1, cy1 = y1 + h1, cx2 = x2 + w2, cy2 = y2 + h2, dx = cx2 - cx1, dy = cy2 - cy1;
  return [getIntersection(dx, dy, cx1, cy1, w1, h1), getIntersection(-dx, -dy, cx2, cy2, w2, h2)];
}
function getIntersection(dx, dy, cx, cy, w, h) {
  return Math.abs(dy / dx) < h / w ? {
    x: cx + (dx > 0 ? w : -w),
    y: cy + dy * w / Math.abs(dx)
  } : {
    x: cx + dx * h / Math.abs(dy),
    y: cy + (dy > 0 ? h : -h)
  };
}
function getAlignOffset(align) {
  return "left" === align ? 0 : "right" === align ? 1 : 0.5;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/register.js
function loadLabelComponent() {
  registerGroup(), registerText(), registerRichtext(), registerLine();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/overlap/shiftY.js
var isIntersect = (top, bottom) => Math.ceil(top) > Math.floor(bottom);
var isXIntersect = ([a2, b], [c2, d]) => d > a2 && b > c2;
function getIntersectionLength(range1, range22) {
  const [start1, end1] = range1, [start2, end2] = range22, start = Math.max(start1, start2), end = Math.min(end1, end2);
  return Math.max(0, end - start);
}
function shiftY(texts, option) {
  const { maxY = Number.MAX_VALUE, labelling, globalShiftY = {
    enable: true,
    maxIterations: 10,
    maxError: 0.1,
    padding: 1
  } } = option, n = texts.length;
  if (n <= 1) return texts;
  const xMap = /* @__PURE__ */ new Map(), textInformation = /* @__PURE__ */ new Map(), getY1Initial = (text2) => textInformation.get(text2).y1Initial, getHeight = (text2) => textInformation.get(text2).height, getY1 = (text2) => textInformation.get(text2).y1, getX = (text2) => textInformation.get(text2).x, getX1 = (text2) => textInformation.get(text2).x1, getX2 = (text2) => textInformation.get(text2).x2, getAdjustAttempts = (text2) => textInformation.get(text2).attempts, setY1 = (text2, y) => {
    textInformation.get(text2).y1 = y;
  }, setAdjustAttempts = (text2, attempts) => {
    textInformation.get(text2).attempts = attempts;
  };
  function adjustPositionInOneGroup(texts2) {
    for (let i = texts2.length - 1; i >= 0; i--) {
      const curText = texts2[i], upperText = texts2[i - 1], lowerText = texts2[i + 1];
      if (upperText && isIntersect(getY1(upperText) + getHeight(upperText), getY1(curText)) || 0 === getY1(curText) && curText._isClamped) {
        const { y } = labelling(curText);
        lowerText && isIntersect(y + getHeight(curText) / 2, getY1(lowerText)) || y + getHeight(curText) / 2 <= maxY && setY1(curText, getY1(curText) + y - (text2 = curText, textInformation.get(text2).y));
      }
    }
    var text2;
  }
  texts.sort((a2, b) => a2.attribute.x - b.attribute.x);
  for (const text2 of texts) {
    const { y1, y2, x1, x2 } = text2.AABBBounds, { x, y } = text2.attribute;
    textInformation.set(text2, {
      y1Initial: y1,
      y1,
      y2,
      y,
      height: y2 - y1,
      x1,
      x2,
      x,
      attempts: 0
    });
    let hasRange = false;
    for (const [range5, xGroupTexts] of xMap) {
      const { start: start2, end: end2 } = range5;
      if (x1 >= start2 && x2 <= end2) xGroupTexts.push(text2), hasRange = true;
      else if (isNumberClose(x, getX(xGroupTexts[0]), void 0, 5)) {
        const newRange = {
          start: Math.min(start2, x1),
          end: Math.max(end2, x2)
        };
        xGroupTexts.push(text2), xMap.set(newRange, xGroupTexts), xMap.delete(range5), hasRange = true;
      } else if (getIntersectionLength([start2, end2], [x1, x2]) / (end2 - start2) > 0.5) {
        const newRange = {
          start: Math.min(start2, x1),
          end: Math.max(end2, x2)
        };
        xGroupTexts.push(text2), xMap.set(newRange, xGroupTexts), xMap.delete(range5), hasRange = true;
      }
      if (hasRange) break;
    }
    hasRange || xMap.set({
      start: x1,
      end: x2
    }, [text2]);
  }
  for (const xTexts of xMap.values()) xTexts.sort((a2, b) => getY1Initial(a2) - getY1Initial(b)), adjustPositionInOneGroup(xTexts);
  if (false !== globalShiftY.enable) {
    const { maxIterations = 10, maxError = 0.1, padding = 1, maxAttempts = 1e3, deltaYTolerance = Number.MAX_VALUE } = globalShiftY;
    for (let iter = 0; iter < maxIterations; iter++) {
      texts.sort((a2, b) => getY1Initial(a2) - getY1Initial(b));
      let error = 0;
      for (let i = 0; i < n - 1; i++) {
        const curText = texts[i];
        if (getAdjustAttempts(curText) >= maxAttempts) continue;
        let nextText, j = i + 1;
        for (; (nextText = texts[j]) && !isXIntersect([getX1(curText), getX2(curText)], [getX1(nextText), getX2(nextText)]); ) j += 1;
        if (nextText) {
          const y1 = getY1(curText), h0 = getHeight(curText), nextY1 = getY1(nextText), delta = nextY1 - (y1 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            if (error = Math.max(error, newDelta), y1 + newDelta + getHeight(nextText) > maxY) {
              const newY1 = y1 - (padding - delta), curTextDelta = getY1Initial(curText) - newY1;
              Math.abs(curTextDelta) <= deltaYTolerance && (setY1(curText, newY1), setAdjustAttempts(curText, getAdjustAttempts(curText) + 1));
            } else if (y1 - newDelta < 0) {
              const newY1 = nextY1 + (padding - delta), nextTextDelta = getY1Initial(nextText) - newY1;
              Math.abs(nextTextDelta) <= deltaYTolerance && (setY1(nextText, newY1), setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1));
            } else {
              const newCurY1 = y1 - newDelta, curTextDelta = getY1Initial(curText) - newCurY1, newNextY1 = nextY1 + newDelta, nextTextDelta = getY1Initial(nextText) - newNextY1;
              Math.abs(curTextDelta) <= deltaYTolerance && Math.abs(nextTextDelta) <= deltaYTolerance && (setY1(curText, newCurY1), setY1(nextText, newNextY1), setAdjustAttempts(curText, getAdjustAttempts(curText) + 1), setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1));
            }
          }
        }
      }
      if (error < maxError) break;
    }
  }
  for (const text2 of texts) {
    const finalY = text2.attribute.y + getY1(text2) - getY1Initial(text2);
    text2.setAttribute("y", finalY);
  }
  const result2 = [];
  texts.sort((a2, b) => a2.attribute.x - b.attribute.x);
  let start = 0, end = texts.length - 1;
  for (; start <= end; ) start === end ? result2.push(texts[start]) : (result2.push(texts[start]), result2.push(texts[end])), start++, end--;
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/base.js
var __rest6 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadLabelComponent();
var LabelBase = class _LabelBase extends AbstractComponent {
  setBitmap(bitmap2) {
    this._bitmap = bitmap2;
  }
  setBitmapTool(bmpTool) {
    this._bmpTool = bmpTool;
  }
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest6(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _LabelBase.defaultAttributes, restAttributes))), this.name = "label", this._onHover = (e) => {
      const target = e.target;
      target === this._lastHover || isEmpty_default(target.states) || (target.addState(StateValue.hover, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.hoverReverse, true);
      }), this._lastHover = target);
    }, this._onUnHover = (e) => {
      this._lastHover && (traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
      }), this._lastHover = null);
    }, this._onClick = (e) => {
      const target = e.target;
      if (this._lastSelect === target && target.hasState("selected")) return this._lastSelect = null, void traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
      });
      isEmpty_default(target.states) || (target.addState(StateValue.selected, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.selectedReverse, true);
      }), this._lastSelect = target);
    }, this._handleRelatedGraphicSetState = (e) => {
      var _a, _b, _c, _d, _e;
      if ((null === (_a = e.detail) || void 0 === _a ? void 0 : _a.type) === AttributeUpdateType.STATE || (null === (_b = e.detail) || void 0 === _b ? void 0 : _b.type) === AttributeUpdateType.ANIMATE_UPDATE && (null === (_c = e.detail.animationState) || void 0 === _c ? void 0 : _c.isFirstFrameOfStep)) {
        const currentStates = null !== (_e = null === (_d = e.target) || void 0 === _d ? void 0 : _d.currentStates) && void 0 !== _e ? _e : [], labels = this._isCollectionBase ? [...this._graphicToText.values()] : [this._graphicToText.get(e.target)];
        this.updateStatesOfLabels(labels, currentStates);
      }
    };
  }
  labeling(textBounds, graphicBounds, position, offset) {
  }
  _getLabelLinePoints(text2, baseMark) {
    return connectLineBetweenBounds(text2.AABBBounds, null == baseMark ? void 0 : baseMark.AABBBounds);
  }
  _createLabelLine(text2, baseMark) {
    const points = this._getLabelLinePoints(text2, baseMark);
    if (points) {
      const lineGraphic = graphicCreator.line({
        points
      }), { line = {} } = text2.attribute;
      if (line.customShape) {
        const customShape = line.customShape;
        lineGraphic.pathProxy = (attrs) => customShape({
          text: text2,
          baseMark
        }, attrs, new CustomPath2D());
      }
      return baseMark && baseMark.attribute.fill && lineGraphic.setAttribute("stroke", baseMark.attribute.fill), this.attribute.line && !isEmpty_default(this.attribute.line.style) && lineGraphic.setAttributes(this.attribute.line.style), this._setStatesOfLabelLine(lineGraphic), lineGraphic;
    }
  }
  render() {
    if (this._prepare(), isNil_default(this._idToGraphic) || this._isCollectionBase && isNil_default(this._idToPoint)) return;
    const { overlap: overlap2, smartInvert, dataFilter, customLayoutFunc, customOverlapFunc } = this.attribute;
    let data = this.attribute.data;
    if (isFunction_default(dataFilter) && (data = dataFilter(data)), data && data.length) {
      const seenIds = /* @__PURE__ */ new Set();
      data = data.filter((d) => !seenIds.has(d.id) && seenIds.add(d.id));
    }
    let labels = this._initText(data);
    labels = isFunction_default(customLayoutFunc) ? customLayoutFunc(data, labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this) : this._layout(labels), isFunction_default(customOverlapFunc) ? labels = customOverlapFunc(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this) : false !== overlap2 && (labels = this._overlapping(labels)), isFunction_default(this.attribute.onAfterOverlapping) && this.attribute.onAfterOverlapping(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this), labels && labels.length && labels.forEach((label) => {
      this._bindEvent(label), this._setStatesOfText(label);
    }), false !== smartInvert && this._smartInvert(labels), this._renderLabels(labels);
  }
  _bindEvent(target) {
    if (this.attribute.disableTriggerEvent) return;
    if (!target) return;
    const { hover, select } = this.attribute;
    hover && (target.addEventListener("pointermove", this._onHover), target.addEventListener("pointerout", this._onUnHover)), select && target.addEventListener("pointerdown", this._onClick);
  }
  _setStatesOfText(target) {
    if (!target) return;
    const state = this.attribute.state;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _setStatesOfLabelLine(target) {
    if (!target) return;
    const state = this.attribute.labelLineState;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _createLabelText(attributes) {
    var _a, _b;
    const textAttrs = Object.assign(Object.assign({}, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text), attributes);
    return createTextGraphicByType(textAttrs, "textType");
  }
  _prepare() {
    var _a, _b;
    const currentBaseMarks = [];
    let baseMarks;
    if (baseMarks = isFunction_default(this.attribute.getBaseMarks) ? this.attribute.getBaseMarks() : getMarksByName(this.getRootNode(), this.attribute.baseMarkGroupName), baseMarks.forEach((mark) => {
      "willRelease" !== mark.releaseStatus && currentBaseMarks.push(mark);
    }), null === (_a = this._idToGraphic) || void 0 === _a || _a.clear(), null === (_b = this._idToPoint) || void 0 === _b || _b.clear(), this._baseMarks = currentBaseMarks, this._isCollectionBase = "line-data" === this.attribute.type, !currentBaseMarks || 0 === currentBaseMarks.length) return;
    const { data } = this.attribute;
    if (data && 0 !== data.length) {
      if (this._idToGraphic || (this._idToGraphic = /* @__PURE__ */ new Map()), this._isCollectionBase) {
        this._idToPoint || (this._idToPoint = /* @__PURE__ */ new Map());
        let cur = 0;
        for (let i = 0; i < currentBaseMarks.length; i++) {
          const baseMark = currentBaseMarks[i], points = getPointsOfLineArea(baseMark);
          if (points && points.length) for (let j = 0; j < points.length; j++) {
            const textData = data[cur];
            textData && points[j] && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${cur}`), this._idToPoint.set(textData.id, points[j]), this._idToGraphic.set(textData.id, baseMark)), cur++;
          }
        }
      } else for (let i = 0; i < currentBaseMarks.length; i++) {
        const textData = data[i], baseMark = currentBaseMarks[i];
        textData && baseMark && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${i}`), this._idToGraphic.set(textData.id, baseMark));
      }
      if (false !== this.attribute.animation) {
        const { animation, animationEnter, animationExit, animationUpdate } = this.attribute, animationCfg = isObject_default(animation) ? animation : {};
        this._animationConfig = {
          enter: false !== animationEnter && merge({}, DefaultLabelAnimation, animationCfg, null != animationEnter ? animationEnter : {}),
          exit: false !== animationExit && merge({}, DefaultLabelAnimation, animationCfg, null != animationExit ? animationExit : {}),
          update: false !== animationUpdate && (isArray_default(animationUpdate) ? animationUpdate : merge({}, DefaultLabelAnimation, animationCfg, null != animationUpdate ? animationUpdate : {}))
        };
      } else this._animationConfig = {
        enter: false,
        exit: false,
        update: false
      };
    }
  }
  getRelatedGraphic(item) {
    return this._idToGraphic.get(item.id);
  }
  _initText(data = []) {
    const { textStyle = {} } = this.attribute, labels = [];
    for (let i = 0; i < data.length; i++) {
      const textData = data[i], baseMark = this.getRelatedGraphic(textData);
      if (!baseMark) continue;
      const labelAttribute = Object.assign(Object.assign({
        fill: this._isCollectionBase ? isArray_default(baseMark.attribute.stroke) ? baseMark.attribute.stroke.find((entry) => !!entry && true !== entry) : baseMark.attribute.stroke : baseMark.attribute.fill
      }, textStyle), textData), text2 = this._createLabelText(labelAttribute);
      labels.push(text2);
    }
    return labels;
  }
  _layout(texts) {
    const { position, offset } = this.attribute;
    for (let i = 0; i < texts.length; i++) {
      const text2 = texts[i];
      if (!text2) return;
      const textData = text2.attribute, baseMark = this.getRelatedGraphic(textData);
      if (!baseMark) continue;
      text2.attachedThemeGraphic = this;
      const textBounds = this.getGraphicBounds(text2);
      text2.attachedThemeGraphic = null;
      const actualPosition = isFunction_default(position) ? position(textData) : position, graphicBounds = this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(textData.id), actualPosition) : this.getGraphicBounds(baseMark, {
        x: textData.x,
        y: textData.y
      }, actualPosition), textLocation = this.labeling(textBounds, graphicBounds, actualPosition, offset);
      textLocation && text2.setAttributes(textLocation);
    }
    return texts;
  }
  _overlapping(labels) {
    var _a, _b, _c;
    if (0 === labels.length) return [];
    const option = isObject_default(this.attribute.overlap) ? this.attribute.overlap : {}, baseMarkGroup = this.getBaseMarkGroup(), size = null !== (_a = option.size) && void 0 !== _a ? _a : {
      width: null !== (_b = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.width()) && void 0 !== _b ? _b : 0,
      height: null !== (_c = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.height()) && void 0 !== _c ? _c : 0
    };
    if (0 === size.width || 0 === size.height) return labels;
    const { strategy, priority } = option, bmpTool = this._bmpTool || bitmapTool(size.width, size.height), bitmap2 = this._bitmap || bmpTool.bitmap();
    return priority && (labels = labels.sort((a2, b) => priority(b.attribute.data) - priority(a2.attribute.data))), "shiftY" === (null == strategy ? void 0 : strategy.type) ? this._overlapGlobal(labels, option, bmpTool, bitmap2) : this._overlapByStrategy(labels, option, bmpTool, bitmap2);
  }
  _overlapGlobal(labels, option, bmpTool, bitmap2) {
    let result2 = labels.filter((label) => label.attribute.visible && 0 !== label.attribute.opacity && this.isMarkInsideRect(this.getRelatedGraphic(label.attribute), bmpTool));
    const { clampForce = true, hideOnHit = true, overlapPadding, strategy } = option;
    if (clampForce) for (let i = 0; i < result2.length; i++) {
      const text2 = labels[i], { dx = 0, dy = 0 } = clampText(text2, bmpTool.width, bmpTool.height, bmpTool.padding);
      0 === dx && 0 === dy || (text2.setAttributes({
        x: text2.attribute.x + dx,
        y: text2.attribute.y + dy
      }), text2._isClamped = true);
    }
    result2 = shiftY(result2, Object.assign(Object.assign({
      maxY: bmpTool.height
    }, strategy), {
      labelling: (text2) => {
        const baseMark = this.getRelatedGraphic(text2.attribute), graphicBound = this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(text2.attribute.id)) : this.getGraphicBounds(baseMark, text2);
        return this.labeling(text2.AABBBounds, graphicBound, "bottom", this.attribute.offset);
      }
    }));
    for (let i = 0; i < result2.length; i++) {
      const text2 = result2[i], bounds = text2.AABBBounds, range5 = boundToRange(bmpTool, bounds, true);
      if (canPlace(bmpTool, bitmap2, bounds, clampForce, overlapPadding)) bitmap2.setRange(range5);
      else {
        if (clampForce) {
          if (this._processClampForce(text2, bmpTool, bitmap2, overlapPadding)) continue;
        }
        hideOnHit ? text2.setAttributes({
          visible: false
        }) : bitmap2.setRange(range5);
      }
    }
    return result2;
  }
  _processClampForce(text2, bmpTool, bitmap2, overlapPadding = 0) {
    const { dy = 0, dx = 0 } = clampText(text2, bmpTool.width, bmpTool.height, bmpTool.padding);
    if (0 === dx && 0 === dy) {
      if (canPlace(bmpTool, bitmap2, text2.AABBBounds, false, overlapPadding)) return bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), true;
    } else if (canPlace(bmpTool, bitmap2, {
      x1: text2.AABBBounds.x1 + dx,
      x2: text2.AABBBounds.x2 + dx,
      y1: text2.AABBBounds.y1 + dy,
      y2: text2.AABBBounds.y2 + dy
    })) return text2.setAttributes({
      x: text2.attribute.x + dx,
      y: text2.attribute.y + dy
    }), bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), true;
    return false;
  }
  _overlapByStrategy(labels, option, bmpTool, bitmap2) {
    var _a;
    const { avoidBaseMark, strategy = [], hideOnHit = true, clampForce = true, avoidMarks = [], overlapPadding } = option, result2 = [], checkBounds = strategy.some((s2) => "bound" === s2.type);
    avoidBaseMark && (null === (_a = this._baseMarks) || void 0 === _a || _a.forEach((mark) => {
      mark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, mark.AABBBounds, true));
    })), avoidMarks.length > 0 && avoidMarks.forEach((avoid) => {
      isString_default(avoid) ? getNoneGroupMarksByName(this.getRootNode(), avoid).forEach((avoidMark) => {
        avoidMark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoidMark.AABBBounds, true));
      }) : avoid.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoid.AABBBounds, true));
    });
    for (let i = 0; i < labels.length; i++) {
      if (false === labels[i].attribute.visible) continue;
      const text2 = labels[i], baseMark = this.getRelatedGraphic(text2.attribute);
      if (text2.update(), !this.isMarkInsideRect(baseMark, bmpTool)) continue;
      if (canPlace(bmpTool, bitmap2, text2.AABBBounds, clampForce, overlapPadding)) {
        if (!checkBounds) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
        if (checkBounds && baseMark && baseMark.AABBBounds && this._canPlaceInside(text2.AABBBounds, baseMark.AABBBounds)) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
      }
      let hasPlace = false;
      for (let j = 0; j < strategy.length; j++) if (hasPlace = place(bmpTool, bitmap2, strategy[j], this.attribute, text2, this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(labels[i].attribute.id)) : this.getGraphicBounds(baseMark, labels[i].attribute), this.labeling), false !== hasPlace) {
        text2.setAttributes({
          x: hasPlace.x,
          y: hasPlace.y
        }), result2.push(text2);
        break;
      }
      if (!hasPlace && clampForce) {
        if (this._processClampForce(text2, bmpTool, bitmap2, overlapPadding)) {
          result2.push(text2);
          continue;
        }
      }
      !hasPlace && !hideOnHit && result2.push(text2);
    }
    return result2;
  }
  isMarkInsideRect(baseMark, bmpTool) {
    const { left, right, top, bottom } = bmpTool.padding, rect = {
      x1: -left,
      x2: bmpTool.width + right,
      y1: -top,
      y2: bmpTool.height + bottom
    }, bounds = baseMark.AABBBounds;
    if (0 !== bounds.width() && 0 !== bounds.height()) return isRectIntersect(baseMark.AABBBounds, rect, true);
    const { attribute } = baseMark;
    if ("rect" === baseMark.type) {
      const { x, x1, y, y1 } = attribute;
      return pointInRect({
        x: null != x ? x : x1,
        y: null != y ? y : y1
      }, rect, true);
    }
    return "x" in attribute && "y" in attribute && pointInRect({
      x: attribute.x,
      y: attribute.y
    }, rect, true);
  }
  getBaseMarkGroup() {
    const { baseMarkGroupName } = this.attribute;
    if (baseMarkGroupName) return this.getRootNode().find((node) => node.name === baseMarkGroupName, true);
  }
  getGraphicBounds(graphic, point5 = {}, position) {
    if (graphic) {
      if (false !== graphic.attribute.visible) return graphic.AABBBounds;
      const { x: x2, y: y2 } = graphic.attribute;
      return {
        x1: x2,
        x2,
        y1: y2,
        y2
      };
    }
    if (point5 && position && "inside-middle" === position) {
      const { x: x2, y: y2, x1 = x2, y1 = y2 } = point5;
      return {
        x1: (x2 + x1) / 2,
        x2: (x2 + x1) / 2,
        y1: (y2 + y1) / 2,
        y2: (y2 + y1) / 2
      };
    }
    const { x, y } = point5;
    return {
      x1: x,
      x2: x,
      y1: y,
      y2: y
    };
  }
  _renderLabels(labels) {
    var _a;
    const { syncState } = this.attribute, currentTextMap = /* @__PURE__ */ new Map(), prevTextMap = this._graphicToText || /* @__PURE__ */ new Map(), texts = [], labelLines = [], { visible: showLabelLine } = null !== (_a = this.attribute.line) && void 0 !== _a ? _a : {};
    labels && labels.forEach((text2, index) => {
      var _a2;
      const relatedGraphic = this.getRelatedGraphic(text2.attribute), textKey = this._isCollectionBase ? text2.attribute.id : relatedGraphic, state = (null == prevTextMap ? void 0 : prevTextMap.get(textKey)) ? "update" : "enter";
      let labelLine;
      if (showLabelLine && (labelLine = this._createLabelLine(text2, relatedGraphic)), syncState && this.updateStatesOfLabels([labelLine ? {
        text: text2,
        labelLine
      } : {
        text: text2
      }], null !== (_a2 = relatedGraphic.currentStates) && void 0 !== _a2 ? _a2 : []), "enter" === state) texts.push(text2), currentTextMap.set(textKey, labelLine ? {
        text: text2,
        labelLine
      } : {
        text: text2
      }), this._addLabel({
        text: text2,
        labelLine
      }, texts, labelLines, index);
      else if ("update" === state) {
        const prevLabel = prevTextMap.get(textKey);
        prevTextMap.delete(textKey), currentTextMap.set(textKey, prevLabel), this._updateLabel(prevLabel, {
          text: text2,
          labelLine
        });
      }
    }), this._removeLabel(prevTextMap), this._graphicToText = currentTextMap;
  }
  _addLabel(label, texts, labelLines, index) {
    const { text: text2, labelLine } = label, relatedGraphic = this.getRelatedGraphic(text2.attribute);
    if (this._syncStateWithRelatedGraphic(relatedGraphic), false !== this._enableAnimation && false !== this._animationConfig.enter) {
      if (relatedGraphic) {
        const { from, to } = getAnimationAttributes(text2.attribute, "fadeIn");
        text2 && this.add(text2), labelLine && (labelLines.push(labelLine), this.add(labelLine)), this._animationConfig.enter.duration > 0 && relatedGraphic.once("animate-bind", (a2) => {
          text2.setAttributes(from), labelLine && labelLine.setAttributes(from);
          const listener = this._afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, this._animationConfig.enter);
          relatedGraphic.on("afterAttributeUpdate", listener);
        });
      }
    } else text2 && this.add(text2), labelLine && this.add(labelLine);
  }
  _updateLabel(prevLabel, currentLabel) {
    const { text: prevText, labelLine: prevLabelLine } = prevLabel, { text: curText, labelLine: curLabelLine } = currentLabel;
    if (false !== this._enableAnimation && false !== this._animationConfig.update) {
      const { duration, easing } = this._animationConfig.update;
      updateAnimation(prevText, curText, this._animationConfig.update), prevLabelLine && curLabelLine && prevLabel.labelLine.animate().to(curLabelLine.attribute, duration, easing);
    } else prevLabel.text.setAttributes(curText.attribute), prevLabelLine && curLabelLine && prevLabel.labelLine.setAttributes(curLabelLine.attribute);
  }
  _removeLabel(textMap) {
    const removeLabelAndLine = (label) => {
      this.removeChild(label.text), label.labelLine && this.removeChild(label.labelLine);
    };
    if (false !== this._enableAnimation && false !== this._animationConfig.exit) {
      const { duration, easing } = this._animationConfig.exit;
      textMap.forEach((label) => {
        var _a;
        null === (_a = label.text) || void 0 === _a || _a.animate().to(getAnimationAttributes(label.text.attribute, "fadeOut").to, duration, easing).onEnd(() => {
          removeLabelAndLine(label);
        });
      });
    } else textMap.forEach((label) => {
      removeLabelAndLine(label);
    });
  }
  updateStatesOfLabels(labels, currentStates) {
    labels.forEach((label) => {
      label && (label.text && label.text.useStates(currentStates), label.labelLine && label.labelLine.useStates(currentStates));
    });
  }
  _syncStateWithRelatedGraphic(relatedGraphic) {
    this.attribute.syncState && relatedGraphic && relatedGraphic.on("afterAttributeUpdate", this._handleRelatedGraphicSetState);
  }
  _afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, { mode, duration, easing, delay }) {
    const listener = (event2) => {
      var _a, _b, _c;
      const { detail } = event2;
      if (!detail) return {};
      const step = null === (_a = detail.animationState) || void 0 === _a ? void 0 : _a.step;
      if (!(detail.type === AttributeUpdateType.ANIMATE_UPDATE && step && !("wait" === step.type && null == (null === (_b = step.prev) || void 0 === _b ? void 0 : _b.type)))) return {};
      if (detail.type === AttributeUpdateType.ANIMATE_END) return text2.setAttributes(to), void (labelLine && labelLine.setAttributes(to));
      const onStart = () => {
        relatedGraphic && (relatedGraphic.onAnimateBind = void 0, relatedGraphic.removeEventListener("afterAttributeUpdate", listener));
      };
      switch (mode) {
        case "after":
          detail.animationState.end && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          break;
        case "after-all":
          index === texts.length - 1 && detail.animationState.end && (texts.forEach((t) => {
            t.animate({
              onStart
            }).wait(delay).to(to, duration, easing);
          }), labelLines.forEach((t) => {
            t.animate().wait(delay).to(to, duration, easing);
          }));
          break;
        default:
          if (this._isCollectionBase) {
            const point5 = this._idToPoint.get(text2.attribute.id);
            !point5 || text2.animates && text2.animates.has("label-animate") || !relatedGraphic.containsPoint(point5.x, point5.y, IContainPointMode.LOCAL, null === (_c = this.stage) || void 0 === _c ? void 0 : _c.getPickerService()) || (text2.animate({
              onStart
            }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          } else detail.animationState.isFirstFrameOfStep && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
      }
    };
    return listener;
  }
  _smartInvert(labels) {
    var _a, _b, _c, _d, _e, _f, _g;
    const option = isObject_default(this.attribute.smartInvert) ? this.attribute.smartInvert : {}, { textType, contrastRatiosThreshold, alternativeColors, mode, interactInvertType } = option, fillStrategy = null !== (_a = option.fillStrategy) && void 0 !== _a ? _a : "invertBase", strokeStrategy = null !== (_b = option.strokeStrategy) && void 0 !== _b ? _b : "base", brightColor = null !== (_c = option.brightColor) && void 0 !== _c ? _c : "#ffffff", darkColor = null !== (_d = option.darkColor) && void 0 !== _d ? _d : "#000000", outsideEnable = null !== (_e = option.outsideEnable) && void 0 !== _e && _e;
    if ("null" !== fillStrategy || "null" !== strokeStrategy) for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      if (!label) continue;
      const baseMark = this.getRelatedGraphic(label.attribute);
      let backgroundColor = baseMark.attribute.fill, foregroundColor = label.attribute.fill;
      if (isObject_default(backgroundColor) && backgroundColor.gradient) {
        const firstStopColor = null === (_g = null === (_f = backgroundColor.stops) || void 0 === _f ? void 0 : _f[0]) || void 0 === _g ? void 0 : _g.color;
        firstStopColor && (backgroundColor = firstStopColor, foregroundColor = firstStopColor);
      }
      const invertColor = labelSmartInvert(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode), similarColor = contrastAccessibilityChecker(invertColor, brightColor) ? brightColor : darkColor, isInside = this._canPlaceInside(label.AABBBounds, baseMark.AABBBounds), isIntersect5 = !isInside && label.AABBBounds && baseMark.AABBBounds && baseMark.AABBBounds.intersects(label.AABBBounds);
      if (isInside || outsideEnable || isIntersect5 && "inside" === interactInvertType) {
        const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
        if (fill && label.setAttributes({
          fill
        }), 0 === label.attribute.lineWidth || 0 === label.attribute.strokeOpacity) continue;
        const stroke2 = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
        stroke2 && label.setAttributes({
          stroke: stroke2
        });
      } else if (isIntersect5 && "none" !== interactInvertType) {
        if (0 === label.attribute.lineWidth || 0 === label.attribute.strokeOpacity) continue;
        if (label.attribute.stroke) {
          label.setAttributes({
            fill: labelSmartInvert(label.attribute.fill, label.attribute.stroke, textType, contrastRatiosThreshold, alternativeColors, mode)
          });
          continue;
        }
        const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
        fill && label.setAttributes({
          fill
        });
        const stroke2 = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
        stroke2 && label.setAttributes({
          stroke: stroke2
        });
      }
    }
  }
  _canPlaceInside(textBound, shapeBound) {
    return !(!textBound || !shapeBound) && shapeBound.encloses(textBound);
  }
  setLocation(point5) {
    this.translateTo(point5.x, point5.y);
  }
  disableAnimation() {
    this._enableAnimation = false;
  }
  enableAnimation() {
    this._enableAnimation = true;
  }
};
LabelBase.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-2, -1, -2, -1]
  },
  offset: 0,
  pickable: false
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/data-label-register.js
var labelComponentMap = {};
var getLabelComponent = (type) => labelComponentMap[type];

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/symbol.js
var __rest7 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var SymbolLabel = class _SymbolLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest7(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _SymbolLabel.defaultAttributes, restAttributes))), this.name = "symbol-label";
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    return labelingPoint(textBounds, graphicBounds, position, offset);
  }
};
SymbolLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "top",
  offset: 5
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/rect.js
var __rest8 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var RectLabel = class _RectLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest8(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _RectLabel.defaultAttributes, restAttributes)));
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    if (!textBounds || !graphicBounds) return;
    const { x1, y1, x2, y2 } = textBounds, width = Math.abs(x2 - x1), height = Math.abs(y2 - y1), { x: anchorX, y: anchorY } = calculateAnchorOfBounds(graphicBounds, position);
    let vx = 0, vy = 0;
    const isInside = position.includes("inside");
    switch (position.includes("top") ? vy = isInside ? 1 : -1 : position.includes("bottom") ? vy = isInside ? -1 : 1 : position.includes("left") ? vx = isInside ? 1 : -1 : position.includes("right") && (vx = isInside ? -1 : 1), position) {
      case "top-right":
      case "bottom-right":
        vx = -1;
        break;
      case "top-left":
      case "bottom-left":
        vx = 1;
    }
    return {
      x: anchorX + vx * offset + vx * width / 2,
      y: anchorY + vy * offset + vy * height / 2
    };
  }
};
RectLabel.tag = "rect-label", RectLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "top",
  offset: 5
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/line.js
var __rest9 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var LineLabel = class _LineLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest9(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _LineLabel.defaultAttributes, restAttributes))), this.name = "line-label";
  }
  getGraphicBounds(graphic, point5 = {}, position = "end") {
    if (!graphic || "line" !== graphic.type && "area" !== graphic.type) return super.getGraphicBounds(graphic, point5);
    let points = graphic.attribute.points;
    const segments2 = graphic.attribute.segments;
    !points && segments2 && segments2.length && (points = segments2.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, [])), points && 0 !== points.length || (points = [point5]);
    const index = "start" === position ? 0 : points.length - 1;
    return points[index] ? {
      x1: points[index].x,
      x2: points[index].x,
      y1: points[index].y,
      y2: points[index].y
    } : void 0;
  }
  labeling(textBounds, graphicBounds, position = "end", offset = 0) {
    return labelingLineOrArea(textBounds, graphicBounds, position, offset);
  }
};
LineLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "end",
  offset: 6
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/arc.js
var __rest10 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var ArcInfo = class {
  constructor(refDatum, center, outerCenter, quadrant, radian, middleAngle, innerRadius, outerRadius, circleCenter) {
    this.refDatum = refDatum, this.center = center, this.outerCenter = outerCenter, this.quadrant = quadrant, this.radian = radian, this.middleAngle = middleAngle, this.innerRadius = innerRadius, this.outerRadius = outerRadius, this.circleCenter = circleCenter, this.labelVisible = true;
  }
  getLabelBounds() {
    return this.labelPosition && this.labelSize ? {
      x1: this.labelPosition.x - this.labelSize.width / 2,
      y1: this.labelPosition.y - this.labelSize.height / 2,
      x2: this.labelPosition.x + this.labelSize.width / 2,
      y2: this.labelPosition.y + this.labelSize.height / 2
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
};
var ArcLabel = class _ArcLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest10(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _ArcLabel.defaultAttributes, restAttributes))), this.name = "arc-label", this._ellipsisWidth = 0, this._arcLeft = /* @__PURE__ */ new Map(), this._arcRight = /* @__PURE__ */ new Map(), this._line2MinLength = 0, this._alignOffset = 0;
  }
  _overlapping(labels) {
    return ["inside", "inside-center"].includes(this.attribute.position) ? super._overlapping(labels) : labels;
  }
  labeling(textBounds, graphicBounds, position = "outside", offset = 0) {
    if (textBounds && graphicBounds) return {
      x: 0,
      y: 0
    };
  }
  _layout(texts) {
    var _a, _b, _c;
    if (!texts || !texts.length) return;
    const labels = super._layout(texts), textBoundsArray = labels.map((label) => this.getGraphicBounds(label)), ellipsisLabelAttribute = Object.assign(Object.assign({}, this.attribute.textStyle), {
      text: "…"
    });
    let ellipsisWidth = 1 / 0;
    if (false !== ellipsisLabelAttribute.ellipsis) {
      const ellipsisText = this._createLabelText(ellipsisLabelAttribute), ellipsisTextBounds = this.getGraphicBounds(ellipsisText);
      ellipsisWidth = ellipsisTextBounds.x2 - ellipsisTextBounds.x1;
    }
    const data = labels.map((label) => label.attribute), currentMarks = Array.from(this._idToGraphic.values());
    this._line2MinLength = isFunction_default(this.attribute.line.line2MinLength) ? this.attribute.line.line2MinLength(texts, currentMarks, this.attribute) : this.attribute.line.line2MinLength, this._alignOffset = null !== (_a = isFunction_default(this.attribute.layout.alignOffset) ? this.attribute.layout.alignOffset(texts, currentMarks, this.attribute) : this.attribute.layout.alignOffset) && void 0 !== _a ? _a : 0;
    const arcs = this.layoutArcLabels(this.attribute.position, this.attribute, currentMarks, data, textBoundsArray, ellipsisWidth);
    for (let i = 0; i < data.length; i++) {
      const textData = data[i], basedArc = arcs.find((arc) => {
        var _a2;
        return (null === (_a2 = arc.refDatum) || void 0 === _a2 ? void 0 : _a2.id) === textData.id;
      });
      if (basedArc) {
        const labelAttribute = {
          visible: basedArc.labelVisible,
          x: basedArc.labelPosition.x,
          y: basedArc.labelPosition.y,
          angle: basedArc.angle,
          points: basedArc.pointA && basedArc.pointB && basedArc.pointC ? [basedArc.pointA, basedArc.pointB, basedArc.pointC] : void 0,
          line: basedArc.labelLine
        };
        "richtext" === labels[i].type ? labelAttribute.width = null !== (_b = basedArc.labelLimit) && void 0 !== _b ? _b : labels[i].attribute.width : labelAttribute.maxLineWidth = null !== (_c = basedArc.labelLimit) && void 0 !== _c ? _c : labels[i].attribute.maxLineWidth, basedArc.refArc && "arc3d" === basedArc.refArc.type && (labelAttribute.anchor3d = [basedArc.circleCenter.x - labelAttribute.x, basedArc.circleCenter.y - labelAttribute.y], labelAttribute.beta = basedArc.refArc.attribute.beta), labels[i].setAttributes(labelAttribute);
      }
    }
    return labels;
  }
  layoutArcLabels(position, attribute, currentMarks, data, textBoundsArray, ellipsisWidth) {
    this._arcLeft.clear(), this._arcRight.clear(), this._ellipsisWidth = ellipsisWidth;
    let maxRadius = 0;
    currentMarks.forEach((currentMarks2) => {
      currentMarks2.attribute.outerRadius > maxRadius && (maxRadius = currentMarks2.attribute.outerRadius);
    }), data.forEach((d, index) => {
      var _a, _b;
      const currentMark = this._idToGraphic.get(d.id), graphicAttribute = currentMark.attribute, center = {
        x: null !== (_a = null == graphicAttribute ? void 0 : graphicAttribute.x) && void 0 !== _a ? _a : 0,
        y: null !== (_b = null == graphicAttribute ? void 0 : graphicAttribute.y) && void 0 !== _b ? _b : 0
      };
      if (!isNil_default(data[index]) && !isNil_default(textBoundsArray[index])) {
        const item = data[index] ? data[index] : null, textBounds = textBoundsArray[index] ? textBoundsArray[index] : {
          x1: 0,
          x2: 0,
          y1: 0,
          y2: 0
        }, arcMiddleAngle = (graphicAttribute.startAngle + graphicAttribute.endAngle) / 2, intervalAngle = graphicAttribute.endAngle - graphicAttribute.startAngle, arcQuadrant = computeQuadrant(graphicAttribute.endAngle - intervalAngle / 2), arcMiddle = polarToCartesian(center, graphicAttribute.outerRadius, arcMiddleAngle), outerArcMiddle = polarToCartesian(center, maxRadius + attribute.line.line1MinLength, arcMiddleAngle), arc = new ArcInfo(item, arcMiddle, outerArcMiddle, arcQuadrant, intervalAngle, arcMiddleAngle, graphicAttribute.innerRadius, graphicAttribute.outerRadius, center);
        arc.refArc = currentMark, arc.pointA = polarToCartesian(center, this.computeDatumRadius(2 * center.x, 2 * center.y, graphicAttribute.outerRadius), arc.middleAngle), arc.labelSize = {
          width: textBounds.x2 - textBounds.x1,
          height: textBounds.y2 - textBounds.y1
        }, isQuadrantRight(arc.quadrant) ? this._arcRight.set(arc.refDatum, arc) : isQuadrantLeft(arc.quadrant) && this._arcLeft.set(arc.refDatum, arc);
      }
    });
    const leftArcs = Array.from(this._arcLeft.values()), rightArcs = Array.from(this._arcRight.values()), arcs = [];
    switch (position) {
      case "inside":
      case "inside-inner":
      case "inside-outer":
      case "inside-center":
        arcs.push(...this._layoutInsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutInsideLabels(leftArcs, attribute, currentMarks));
        break;
      default:
        arcs.push(...this._layoutOutsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutOutsideLabels(leftArcs, attribute, currentMarks));
    }
    return arcs;
  }
  _layoutInsideLabels(arcs, attribute, currentMarks) {
    var _a, _b;
    const labelConfig = attribute, spaceWidth = labelConfig.spaceWidth, position = null !== (_a = labelConfig.position) && void 0 !== _a ? _a : "inside", offsetRadius = null !== (_b = labelConfig.offsetRadius) && void 0 !== _b ? _b : -spaceWidth;
    return arcs.forEach((arc) => {
      var _a2, _b2, _c;
      const { labelSize, radian } = arc, innerRadius = arc.innerRadius, outerRadius = arc.outerRadius;
      let limit;
      if (radian < connectLineRadian(outerRadius, labelSize.height)) limit = 0;
      else {
        let minRadius;
        minRadius = radian >= Math.PI ? innerRadius : Math.max(innerRadius, labelSize.height / 2 / Math.tan(radian / 2)), limit = outerRadius - minRadius - spaceWidth;
      }
      true !== labelConfig.rotate && (limit = outerRadius - spaceWidth);
      const text2 = this._getFormatLabelText(arc.refDatum, limit);
      arc.labelText = text2;
      const labelWidth = Math.min(limit, arc.labelSize.width), align = this._computeAlign(arc, attribute);
      let labelRadius, alignOffset = 0;
      if ("inside" === position && (alignOffset = "left" === align ? labelWidth : "right" === align ? 0 : labelWidth / 2), labelRadius = "inside-inner" === position ? innerRadius - offsetRadius + alignOffset : "inside-center" === position ? innerRadius + (outerRadius - innerRadius) / 2 : outerRadius + offsetRadius - alignOffset, arc.labelPosition = polarToCartesian(arc.circleCenter, labelRadius, arc.middleAngle), arc.labelLimit = labelWidth, isGreater(labelWidth, 0) || (arc.labelVisible = false), false !== labelConfig.rotate) {
        arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : arc.middleAngle;
        let offsetAngle = null !== (_c = labelConfig.offsetAngle) && void 0 !== _c ? _c : 0;
        ["inside-inner", "inside-outer"].includes(position) && (offsetAngle += Math.PI / 2), arc.angle += offsetAngle;
      }
    }), arcs;
  }
  _layoutOutsideLabels(arcs, attribute, currentMarks) {
    var _a, _b, _c;
    const center_x = null !== (_a = currentMarks[0].attribute.x) && void 0 !== _a ? _a : 0, height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), labelLayout = attribute.layout, spaceWidth = attribute.spaceWidth;
    if (arcs.forEach((arc) => {
      const direction = isQuadrantLeft(arc.quadrant) ? -1 : 1;
      arc.labelPosition = {
        x: arc.outerCenter.x + direction * (arc.labelSize.width / 2 + this._line2MinLength + spaceWidth),
        y: arc.outerCenter.y
      };
    }), arcs.sort((a2, b) => a2.labelPosition.y - b.labelPosition.y), false !== attribute.coverEnable || "none" === labelLayout.strategy) {
      for (const arc of arcs) {
        const { labelPosition, labelSize } = arc;
        arc.labelLimit = labelSize.width, arc.pointB = isQuadrantLeft(arc.quadrant) ? {
          x: labelPosition.x + labelSize.width / 2 + this._line2MinLength + spaceWidth,
          y: labelPosition.y
        } : {
          x: labelPosition.x - labelSize.width / 2 - this._line2MinLength - spaceWidth,
          y: labelPosition.y
        }, this._computeX(arc, attribute, currentMarks);
      }
      false === attribute.coverEnable && "none" === labelLayout.strategy && this._coverLabels(arcs);
    } else {
      const maxLabels = height / ((null === (_c = attribute.textStyle) || void 0 === _c ? void 0 : _c.fontSize) || 16);
      this._adjustY(arcs, maxLabels, attribute, currentMarks);
      const { minY, maxY } = arcs.reduce((yInfo, arc) => {
        const { y1, y2 } = arc.getLabelBounds();
        return yInfo.minY = Math.max(0, Math.min(y1, yInfo.minY)), yInfo.maxY = Math.min(height, Math.max(y2, yInfo.maxY)), yInfo;
      }, {
        minY: 1 / 0,
        maxY: -1 / 0
      }), halfY = Math.max(Math.abs(height / 2 - minY), Math.abs(maxY - height / 2)), r = this._computeLayoutRadius(halfY, attribute, currentMarks);
      for (const arc of arcs) this._computePointB(arc, r, attribute, currentMarks), this._computeX(arc, attribute, currentMarks);
    }
    const width = 2 * center_x;
    return arcs.forEach((arc) => {
      var _a2, _b2;
      arc.labelVisible && (isLess(arc.pointB.x, this._line2MinLength + spaceWidth) || isGreater(arc.pointB.x, width - this._line2MinLength - spaceWidth)) && (arc.labelVisible = false), arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : 0, attribute.offsetAngle && (arc.angle += attribute.offsetAngle), arc.labelLine = Object.assign(Object.assign({}, attribute.line), {
        visible: arc.labelVisible
      });
    }), arcs;
  }
  _computeX(arc, attribute, currentMarks) {
    var _a;
    const center = arc.circleCenter, plotLayout_x1 = 0, plotLayout_x2 = this.attribute.width;
    this.attribute.height;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, labelLayoutAlign = null === (_a = attribute.layout) || void 0 === _a ? void 0 : _a.align, spaceWidth = attribute.spaceWidth, { labelPosition, quadrant, pointB } = arc;
    isValidNumber_default(pointB.x * pointB.y) || (arc.pointC = {
      x: NaN,
      y: NaN
    }, labelPosition.x = NaN, arc.labelLimit = 0);
    const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), flag = isQuadrantLeft(quadrant) ? -1 : 1;
    let cx = 0, limit = (flag > 0 ? plotLayout_x2 - pointB.x : pointB.x - plotLayout_x1) + this._alignOffset - this._line2MinLength - spaceWidth;
    "labelLine" === labelLayoutAlign && (cx = (radius + line1MinLength + this._line2MinLength) * flag + center.x, limit = (flag > 0 ? plotLayout_x2 - cx : cx - plotLayout_x1) - spaceWidth);
    const text2 = this._getFormatLabelText(arc.refDatum, limit);
    arc.labelText = text2;
    let labelWidth = Math.min(limit, arc.labelSize.width);
    switch (labelLayoutAlign) {
      case "labelLine":
        break;
      case "edge":
        cx = flag > 0 ? plotLayout_x2 - labelWidth - spaceWidth : plotLayout_x1 + labelWidth + spaceWidth;
        break;
      default:
        cx = pointB.x + flag * this._line2MinLength;
    }
    labelWidth = Math.max(this._ellipsisWidth, labelWidth);
    const needAdjustLimit = labelWidth < arc.labelSize.width - 1;
    arc.labelLimit = needAdjustLimit ? labelWidth : null, arc.pointC = {
      x: cx,
      y: labelPosition.y
    };
    const align = this._computeAlign(arc, attribute), targetCenterOffset = getAlignOffset(align) * (needAdjustLimit ? labelWidth : arc.labelSize.width);
    "edge" === labelLayoutAlign ? (labelPosition.x = (flag > 0 ? plotLayout_x2 : plotLayout_x1) - flag * targetCenterOffset + flag * this._alignOffset, arc.pointC.x += flag * this._alignOffset) : labelPosition.x = cx + flag * (this._alignOffset + spaceWidth + targetCenterOffset);
  }
  _computeAlign(arc, attribute) {
    var _a, _b, _c, _d, _e, _f;
    const labelConfig = attribute, textAlign = null !== (_b = null === (_a = labelConfig.textStyle) || void 0 === _a ? void 0 : _a.textAlign) && void 0 !== _b ? _b : null === (_c = labelConfig.textStyle) || void 0 === _c ? void 0 : _c.align, layoutAlign = null !== (_e = null === (_d = labelConfig.layout) || void 0 === _d ? void 0 : _d.textAlign) && void 0 !== _e ? _e : null === (_f = labelConfig.layout) || void 0 === _f ? void 0 : _f.align;
    return "inside" !== labelConfig.position ? isNil_default(textAlign) || "auto" === textAlign ? "edge" === layoutAlign ? isQuadrantLeft(arc.quadrant) ? "left" : "right" : isQuadrantLeft(arc.quadrant) ? "right" : "left" : textAlign : isNil_default(textAlign) || "auto" === textAlign ? "center" : textAlign;
  }
  _getFormatLabelText(value, limit) {
    var _a;
    return null !== (_a = null == value ? void 0 : value.text) && void 0 !== _a ? _a : "";
  }
  _adjustY(arcs, maxLabels, attribute, currentMarks) {
    var _a, _b;
    _a = currentMarks[0].attribute.x;
    const plotRect_height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), labelLayout = attribute.layout;
    if ("vertical" === labelLayout.strategy) {
      let delta, lastY = 0;
      const len = arcs.length;
      if (len <= 0) return;
      for (let i = 0; i < len; i++) {
        const { y1 } = arcs[i].getLabelBounds();
        if (delta = y1 - lastY, isLess(delta, 0)) {
          const index = this._shiftY(arcs, i, len - 1, -delta);
          this._shiftY(arcs, index, 0, delta / 2);
        }
        const { y2 } = arcs[i].getLabelBounds();
        lastY = y2;
      }
      const { y1: firstY1 } = arcs[0].getLabelBounds();
      delta = firstY1 - 0, isLess(delta, 0) && this._shiftY(arcs, 0, len - 1, -delta);
      for (let i = arcs.length - 1; i >= 0 && arcs[i].getLabelBounds().y2 > plotRect_height; i--) arcs[i].labelVisible = false;
    } else if ("none" !== labelLayout.strategy) {
      const priorityArcs = arcs.map((arc, i) => ({
        arc,
        originIndex: i,
        priorityIndex: 0
      }));
      priorityArcs.sort((a2, b) => b.arc.radian - a2.arc.radian), priorityArcs.forEach((priorityArc, i) => {
        priorityArc.priorityIndex = i, priorityArc.arc.labelVisible = false;
      });
      let topLabelIndex = 1 / 0, bottomLabelIndex = -1 / 0;
      for (let i = 0; i < maxLabels && i < arcs.length; i++) {
        this._storeY(arcs);
        const arc = priorityArcs[i].arc;
        this._computeYRange(arc, attribute, currentMarks), arc.labelVisible = true;
        const curY = arc.labelPosition.y, { lastIndex, nextIndex } = this._findNeighborIndex(arcs, priorityArcs[i]), lastArc = arcs[lastIndex], nextArc = arcs[nextIndex];
        if (-1 === lastIndex && -1 !== nextIndex) {
          const nextY = nextArc.labelPosition.y;
          curY > nextY ? arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2 : this._twoWayShift(arcs, arc, nextArc, nextIndex);
        } else if (-1 !== lastIndex && -1 === nextIndex) {
          const lastY = lastArc.labelPosition.y;
          curY < lastY ? arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2 : this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex);
        } else if (-1 !== lastIndex && -1 !== nextIndex) {
          const lastY = lastArc.labelPosition.y, nextY = nextArc.labelPosition.y;
          curY > nextY ? (arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2, this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex)) : curY < lastY ? (arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2, this._twoWayShift(arcs, arc, nextArc, nextIndex)) : (this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex), this._twoWayShift(arcs, arc, nextArc, nextIndex));
        }
        const nextTopIndex = Math.min(topLabelIndex, priorityArcs[i].originIndex), nextBottomIndex = Math.max(bottomLabelIndex, priorityArcs[i].originIndex);
        let delta;
        if (delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0) && this._shiftY(arcs, nextBottomIndex, 0, -delta), delta = arcs[nextTopIndex].getLabelBounds().y1 - 0, isLess(delta, 0) && this._shiftY(arcs, nextTopIndex, arcs.length - 1, -delta), delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0)) {
          arc.labelVisible = false, this._restoreY(arcs);
          break;
        }
        labelLayout.tangentConstraint && !this._checkYRange(arcs) ? (arc.labelVisible = false, this._restoreY(arcs)) : (topLabelIndex = nextTopIndex, bottomLabelIndex = nextBottomIndex);
      }
    }
  }
  _shiftY(arcs, start, end, delta) {
    const direction = start < end ? 1 : -1;
    let index = start;
    for (; -1 !== index; ) {
      arcs[index].labelPosition.y += delta;
      const nextIndex = this._findNextVisibleIndex(arcs, index, end, direction);
      if (nextIndex >= 0 && nextIndex < arcs.length) {
        const { y1: curY1, y2: curY2 } = arcs[index].getLabelBounds(), { y1: nextY1, y2: nextY2 } = arcs[nextIndex].getLabelBounds();
        if (direction > 0 && curY2 < nextY1 || direction < 0 && curY1 > nextY2) return index;
      }
      index = nextIndex;
    }
    return end;
  }
  _findNextVisibleIndex(arcs, start, end, direction) {
    const diff = (end - start) * direction;
    for (let i = 1; i <= diff; i++) {
      const index = start + i * direction;
      if (arcs[index].labelVisible) return index;
    }
    return -1;
  }
  _computePointB(arc, r, attribute, currentMarks) {
    const labelConfig = attribute;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = labelConfig.line.line1MinLength;
    if ("none" === labelConfig.layout.strategy) arc.pointB = {
      x: arc.outerCenter.x,
      y: arc.outerCenter.y
    };
    else {
      const center = arc.circleCenter, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), { labelPosition, quadrant } = arc, rd = r - Math.max(radius + line1MinLength, arc.outerRadius), x = Math.sqrt(r ** 2 - Math.abs(center.y - labelPosition.y) ** 2) - rd;
      isValidNumber_default(x) ? arc.pointB = {
        x: center.x + x * (isQuadrantLeft(quadrant) ? -1 : 1),
        y: labelPosition.y
      } : arc.pointB = {
        x: NaN,
        y: NaN
      };
    }
  }
  _storeY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.lastLabelY = arc.labelPosition.y);
  }
  _computeYRange(arc, attribute, currentMarks) {
    const center = arc.circleCenter, plotRect = {
      width: 2 * center.x,
      height: 2 * center.y
    };
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, { width, height } = plotRect, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), r = this._computeLayoutRadius(height / 2, attribute, currentMarks), cx = Math.abs(arc.center.x - width / 2), cy = arc.center.y - height / 2;
    let a2, b, c2;
    if (isNumberClose(width / 2, cx)) a2 = 0, b = 1, c2 = -cy;
    else if (isNumberClose(height / 2, cy)) a2 = 1, b = 0, c2 = -cx;
    else {
      const k2 = -1 / (cy / cx);
      a2 = k2, b = -1, c2 = cy - k2 * cx;
    }
    const points = lineCirclePoints(a2, b, c2, line1MinLength + radius - r, 0, r);
    if (points.length < 2) return;
    let min2, max2;
    points[0].x > points[1].x && points.reverse(), points[0].x < 0 ? isNumberClose(points[0].y, points[1].y) ? isGreater(arc.middleAngle, -Math.PI) && isLess(arc.middleAngle, 0) || isGreater(arc.middleAngle, Math.PI) && isLess(arc.middleAngle, 2 * Math.PI) ? (min2 = 0, max2 = points[1].y + height / 2) : (min2 = points[1].y + height / 2, max2 = height) : points[0].y < points[1].y ? (min2 = 0, max2 = points[1].y + height / 2) : (min2 = points[1].y + height / 2, max2 = plotRect.height) : (min2 = Math.min(points[0].y, points[1].y) + height / 2, max2 = Math.max(points[0].y, points[1].y) + height / 2), arc.labelYRange = [min2, max2];
  }
  _computeLayoutRadius(halfYLength, attribute, currentMarks) {
    const labelConfig = attribute, layoutArcGap = labelConfig.layoutArcGap, line1MinLength = labelConfig.line.line1MinLength;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), outerR = this.computeRadius(radiusRatio, attribute.width, attribute.height) + line1MinLength, a2 = outerR - layoutArcGap;
    return Math.max((a2 ** 2 + halfYLength ** 2) / (2 * a2), outerR);
  }
  _findNeighborIndex(arcs, priorityArc) {
    const index = priorityArc.originIndex;
    let lastIndex = -1, nextIndex = -1;
    for (let i = index - 1; i >= 0; i--) if (arcs[i].labelVisible) {
      lastIndex = i;
      break;
    }
    for (let i = index + 1; i < arcs.length; i++) if (arcs[i].labelVisible) {
      nextIndex = i;
      break;
    }
    return {
      lastIndex,
      nextIndex
    };
  }
  _twoWayShift(arcs, lastArc, nextArc, nextIndex) {
    const delta = nextArc.getLabelBounds().y1 - lastArc.getLabelBounds().y2;
    if (isLess(delta, 0)) {
      const i = this._shiftY(arcs, nextIndex, arcs.length - 1, -delta);
      this._shiftY(arcs, i, 0, delta / 2);
    }
  }
  _restoreY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.labelPosition.y = arc.lastLabelY);
  }
  _checkYRange(arcs) {
    for (const arc of arcs) {
      const { labelYRange, labelPosition } = arc;
      if (arc.labelVisible && labelYRange && (isLess(labelPosition.y, labelYRange[0]) || isGreater(labelPosition.y, labelYRange[1]))) return false;
    }
    return true;
  }
  _coverLabels(arcs) {
    if (arcs.length <= 1) return;
    let lastBounds = arcs[0].getLabelBounds();
    for (let i = 1; i < arcs.length; i++) {
      const bounds = arcs[i].getLabelBounds();
      checkBoundsOverlap(lastBounds, bounds) ? arcs[i].labelVisible = false : lastBounds = bounds;
    }
  }
  _getLabelLinePoints(text2, baseMark) {
    return text2.attribute.points;
  }
  _createLabelLine(text2, baseMark) {
    var _a, _b, _c, _d, _e;
    const { line = {}, visible } = text2.attribute, lineGraphic = super._createLabelLine(text2, baseMark);
    if (lineGraphic && (lineGraphic.setAttributes({
      visible: null === (_c = null !== (_a = line.visible && visible) && void 0 !== _a ? _a : null === (_b = text2.attribute) || void 0 === _b ? void 0 : _b.visible) || void 0 === _c || _c,
      lineWidth: null !== (_e = null === (_d = line.style) || void 0 === _d ? void 0 : _d.lineWidth) && void 0 !== _e ? _e : 1
    }), line.smooth && lineGraphic.setAttributes({
      curveType: "basis"
    }), "arc3d" === baseMark.type && baseMark)) {
      const { beta, x, y } = baseMark.attribute;
      lineGraphic.setAttributes({
        beta,
        anchor3d: [x, y]
      });
    }
    return lineGraphic;
  }
  computeRadius(r, width, height, k2) {
    return this.computeLayoutRadius(width || 0, height || 0) * r * (isNil_default(k2) ? 1 : k2);
  }
  computeLayoutRadius(width, height) {
    return Math.min(width / 2, height / 2);
  }
  _canPlaceInside(textBound, shapeBound) {
    return "inside" === this.attribute.position || "inside-center" === this.attribute.position;
  }
  computeLayoutOuterRadius(r, width, height) {
    return r / (Math.min(width, height) / 2);
  }
  computeDatumRadius(width, height, outerRadius) {
    const outerRadiusRatio = this.computeLayoutOuterRadius(outerRadius, width, height);
    return this.computeLayoutRadius(width || 0, height || 0) * outerRadiusRatio;
  }
};
ArcLabel.defaultAttributes = {
  coverEnable: false,
  spaceWidth: 5,
  layoutArcGap: 6,
  textStyle: {
    visible: true,
    fontSize: 14,
    fontWeight: "normal",
    fillOpacity: 1,
    boundsPadding: [-1, 0, -1, 0],
    ellipsis: true
  },
  position: "outside",
  line: {
    visible: true,
    line1MinLength: 20,
    line2MinLength: 10
  },
  layout: {
    align: "arc",
    strategy: "priority",
    tangentConstraint: true
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label/dataLabel.js
var __rest11 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var DataLabel = class _DataLabel extends AbstractComponent {
  constructor(attributes, options) {
    const { dataLabels } = attributes, restAttributes = __rest11(attributes, ["dataLabels"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      dataLabels
    }, merge({}, _DataLabel.defaultAttributes, restAttributes))), this.name = "data-label";
  }
  render() {
    var _a;
    const { dataLabels, size } = this.attribute;
    if (!dataLabels || 0 === dataLabels.length) return;
    const { width = 0, height = 0, padding } = size || {};
    if (!width || !height || !isValidNumber_default(height * width)) return;
    this._componentMap || (this._componentMap = /* @__PURE__ */ new Map());
    const tool = bitmapTool(width, height, padding), bitmap2 = tool.bitmap(), currentComponentMap = /* @__PURE__ */ new Map(), prevComponentMap = this._componentMap;
    for (let i = 0; i < dataLabels.length; i++) {
      const dataLabel = dataLabels[i], labelComponent = getLabelComponent(dataLabel.type) || LabelBase;
      if (labelComponent) {
        const { baseMarkGroupName, type } = dataLabel, id = null !== (_a = dataLabel.id) && void 0 !== _a ? _a : `${baseMarkGroupName}-${type}-${i}`;
        "arc" === dataLabel.type && (dataLabel.width = size.width, dataLabel.height = size.height);
        let component = this._componentMap.get(id);
        component ? (component.setBitmapTool(tool), component.setBitmap(bitmap2), component.setAttributes(dataLabel), currentComponentMap.set(id, component)) : (component = new labelComponent(dataLabel), component.setBitmap(bitmap2), component.setBitmapTool(tool), this.add(component), currentComponentMap.set(id, component));
      }
    }
    prevComponentMap.forEach((cp, key) => {
      currentComponentMap.get(key) || this.removeChild(cp);
    }), this._componentMap = currentComponentMap;
  }
  setLocation(point5) {
    this.translateTo(point5.x, point5.y);
  }
  disableAnimation() {
    this._componentMap.forEach((component) => {
      component.disableAnimation();
    });
  }
  enableAnimation() {
    this._componentMap.forEach((component) => {
      component.enableAnimation();
    });
  }
};
DataLabel.defaultAttributes = {
  pickable: false
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/grid/base.js
function getArcPath(center, points, reverse, closed) {
  let path = "";
  if (!center || 0 === points.length) return path;
  const firstPoint = points[0], radius = PointService.distancePP(center, firstPoint), sweepFlag = reverse ? 0 : 1;
  return closed ? path += `M${center.x},${center.y - radius}A${radius},${radius},0,0,${sweepFlag},${center.x},${center.y + radius}A${radius},${radius},0,0,${sweepFlag},${center.x},${center.y - radius}Z` : points.forEach((point5, index) => {
    0 === index ? path = `M${point5.x},${point5.y}` : path += `A${radius},${radius},0,0,${sweepFlag},${point5.x},${point5.y}`;
  }), path;
}
function getRegionPath(from, to, attribute) {
  const { type, closed } = attribute, reversePoints = to.slice(0).reverse();
  let regionPath = "", nextPath = "";
  if ("line" === type && attribute.smoothLink && attribute.center) {
    const fromStart = from[0], toEnd = reversePoints[0], center = attribute.center;
    regionPath = getPolygonPath(from, !!closed), nextPath = getPolygonPath(reversePoints, !!closed);
    const toEndRadius = PointService.distancePP(toEnd, center), fromStartRadius = PointService.distancePP(fromStart, center);
    regionPath += `A${toEndRadius},${toEndRadius},0,0,1,${toEnd.x},${toEnd.y}L${toEnd.x},${toEnd.y}`, nextPath += `A${fromStartRadius},${fromStartRadius},0,0,0,${fromStart.x},${fromStart.y}`;
  } else if ("circle" === type) {
    const { center } = attribute;
    regionPath = getArcPath(center, from, false, !!closed), nextPath = getArcPath(center, reversePoints, true, !!closed);
  } else "line" !== type && "polygon" !== type || (regionPath = getPolygonPath(from, !!closed), nextPath = getPolygonPath(reversePoints, !!closed));
  return closed ? regionPath += nextPath : (nextPath = "L" + nextPath.substring(1), regionPath += nextPath, regionPath += "Z"), regionPath;
}
var BaseGrid = class _BaseGrid extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis-grid", this.data = [];
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView);
    const { items, visible } = this.attribute;
    items && items.length && false !== visible && (this.data = this._transformItems(items), this._renderGrid(this._innerView));
  }
  getVerticalCoord(point5, offset, inside) {
    return getVerticalCoord(point5, this.getVerticalVector(offset, inside, point5));
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  _renderGrid(container2) {
    const { visible } = this.attribute.subGrid || {};
    visible && this._renderGridByType(true, container2), this._renderGridByType(false, container2);
  }
  _renderGridByType(isSubGrid, container2) {
    const gridAttrs = merge({}, this.attribute, this.getGridAttribute(isSubGrid)), { type, items, style: style2, closed, alternateColor, depth = 0 } = gridAttrs, name = isSubGrid ? `${AXIS_ELEMENT_NAME.grid}-sub` : `${AXIS_ELEMENT_NAME.grid}`;
    if (items.forEach((item, index) => {
      const { id, points } = item;
      let path = "";
      if ("line" === type || "polygon" === type) path = getPolygonPath(points, !!closed);
      else if ("circle" === type) {
        const { center } = this.attribute;
        path = getArcPath(center, points, false, !!closed);
      }
      const shape = graphicCreator.path(Object.assign({
        path,
        z: depth
      }, isFunction_default(style2) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style2(item, index)) : style2));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id}`), container2.add(shape);
    }), depth && "line" === type && items.forEach((item, index) => {
      const { id, points } = item, nextPoints = [];
      nextPoints.push(points[0]);
      const dir_x = points[1].x - points[0].x, dir_y = points[1].y - points[0].y, dirLen = Math.sqrt(dir_x * dir_x + dir_y * dir_y), ratio = depth / dirLen;
      nextPoints.push({
        x: points[0].x + dir_x * ratio,
        y: points[0].y + dir_y * ratio
      });
      const path = getPolygonPath(nextPoints, !!closed), deltaX = abs(nextPoints[0].x - nextPoints[1].x), deltaY = abs(nextPoints[0].y - nextPoints[1].y), shape = graphicCreator.path(Object.assign({
        path,
        z: 0,
        alpha: deltaX > deltaY ? (points[1].x - points[0].x > 0 ? -1 : 1) * pi / 2 : 0,
        beta: deltaX < deltaY ? -pi / 2 : 0,
        anchor3d: deltaX > deltaY ? [nextPoints[0].x, 0] : [0, nextPoints[0].y]
      }, isFunction_default(style2) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style2(item, index)) : style2));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id}`), container2.add(shape);
    }), items.length > 1 && alternateColor) {
      const colors = isArray_default(alternateColor) ? alternateColor : [alternateColor, "transparent"], getColor = (index) => colors[index % colors.length], originalItems = this.attribute.items, firstItem = originalItems[0], lastItem = originalItems[originalItems.length - 1], noZero = !isNumberClose(firstItem.value, 0) && !isNumberClose(lastItem.value, 0), noOne = !isNumberClose(firstItem.value, 1) && !isNumberClose(lastItem.value, 1), allPoints = [], isDesc = firstItem.value > lastItem.value;
      (isDesc && noOne || !isDesc && noZero) && allPoints.push(this.getGridPointsByValue(isDesc ? 1 : 0)), items.forEach((item) => {
        allPoints.push(item.points);
      }), (isDesc && noZero || !isDesc && noOne) && allPoints.push(this.getGridPointsByValue(isDesc ? 0 : 1));
      for (let index = 0; index < allPoints.length - 1; index++) {
        const path = getRegionPath(allPoints[index], allPoints[index + 1], gridAttrs), shape = graphicCreator.path({
          path,
          fill: getColor(index)
        });
        shape.name = `${name}-region`, shape.id = this._getNodeId(`${name}-region-${index}`), container2.add(shape);
      }
    }
  }
  _getNodeId(id) {
    return `${this.id}-${id}`;
  }
  _parseTickSegment() {
    let tickSegment = 1;
    return this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value), tickSegment;
  }
  _getPointsOfSubGrid(tickSegment, alignWithLabel) {
    const tickLineCount = this.data.length, points = [];
    return tickLineCount >= 2 && this.data.forEach((item) => {
      let tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value)) return;
        tickValue = value;
      }
      points.push({
        value: tickValue
      });
    }), points;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};
BaseGrid.defaultAttributes = {
  style: {
    lineWidth: 1,
    stroke: "#999",
    strokeOpacity: 1,
    lineDash: [4, 4]
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/grid/line.js
loadLineAxisGridComponent();
var LineAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  _getGridPoint(gridType, point5) {
    let gridPoints;
    if ("line" === gridType) {
      const { length: length2 } = this.attribute;
      gridPoints = [point5, this.getVerticalCoord(point5, length2, true)];
    } else if ("circle" === gridType || "polygon" === gridType) {
      const { center, sides = 6, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, distance = PointService.distancePP(center, point5);
      gridPoints = getCirclePoints(center, sides, distance, startAngle, endAngle);
    }
    return gridPoints;
  }
  getGridPointsByValue(value) {
    const basePoint = this.getTickCoord(value);
    return this._getGridPoint(this.attribute.type, basePoint);
  }
  getGridAttribute(isSubGrid) {
    const { type: gridType, alignWithLabel = true } = this.attribute, tickSegment = this._parseTickSegment();
    let gridAttribute, items = [];
    if (isSubGrid) {
      gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
      const subGridItems = [], { count: subCount = 4 } = gridAttribute;
      if (this.data.length >= 2) {
        const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
        for (let i = 0; i < points.length - 1; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: this.getGridPointsByValue(pre.value),
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value;
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: this.getGridPointsByValue(value),
              datum: {}
            });
          }
          i === points.length - 2 && subGridItems.push({
            id: `sub-${i}-${subCount + 1}`,
            points: this.getGridPointsByValue(next.value),
            datum: {}
          });
        }
        items = subGridItems;
      }
    } else {
      gridAttribute = this.attribute;
      const gridItems = [];
      this.data.forEach((item) => {
        let { point: point5 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point5 = this.getTickCoord(value);
        }
        gridItems.push({
          id: item.label,
          datum: item,
          points: this._getGridPoint(gridType, point5)
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items
    });
  }
};
mixin(LineAxisGrid, LineAxisMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/axis/grid/circle.js
var __rest12 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisGridComponent();
var CircleAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  getGridPointsByValue(value) {
    const basePoint = this.getTickCoord(value), { radius, innerRadius = 0 } = this.attribute;
    return [basePoint, this.getVerticalCoord(basePoint, radius - innerRadius, true)];
  }
  getGridAttribute(isSubGrid) {
    let gridAttribute, items = [];
    const _a = this.attribute, { radius, innerRadius = 0, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center, subGrid } = _a, grid = __rest12(_a, ["radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid"]), { alignWithLabel = true } = grid || {}, length2 = radius - innerRadius, tickSegment = this._parseTickSegment();
    if (isSubGrid) {
      gridAttribute = merge({}, grid, subGrid);
      const subGridItems = [], { count: subCount = 4 } = subGrid || {}, tickLineCount = this.data.length;
      if (tickLineCount >= 2) {
        const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
        for (let i = 0; i < tickLineCount; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length2, true)],
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment), point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, true);
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: [point5, endPoint],
              datum: {}
            });
          }
        }
        Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 && subGridItems.push(subGridItems[0]), items = subGridItems;
      }
    } else {
      gridAttribute = grid;
      const gridItems = [];
      let data;
      data = Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? [...this.data].concat(this.data[0]) : this.data, data.forEach((item) => {
        let { point: point5 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point5 = this.getTickCoord(value);
        }
        const endPoint = this.getVerticalCoord(point5, length2, true);
        gridItems.push({
          id: item.id,
          points: [point5, endPoint],
          datum: item
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items,
      center,
      type: "line"
    });
  }
};
mixin(CircleAxisGrid, CircleAxisMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/data-zoom/config.js
var DEFAULT_HANDLER_PATH = "M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z";
var DEFAULT_DATA_ZOOM_ATTRIBUTES = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  zoomLock: false,
  minSpan: 0,
  maxSpan: 1,
  delayType: "throttle",
  delayTime: 0,
  realTime: true,
  backgroundStyle: {
    fill: "white",
    stroke: "#D1DBEE",
    lineWidth: 1,
    cornerRadius: 2
  },
  dragMaskStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2
  },
  backgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1,
      fill: "#F6F8FC"
    },
    line: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1
    }
  },
  selectedBackgroundStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.5
  },
  selectedBackgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#B0C8F9",
      lineWidth: 1,
      fill: "#fbb934"
    },
    line: {
      visible: true,
      stroke: "#fbb934",
      lineWidth: 1
    }
  },
  middleHandlerStyle: {
    visible: true,
    background: {
      size: 8,
      style: {
        fill: "white",
        stroke: "#B0C8F9",
        cornerRadius: 2
      }
    },
    icon: {
      size: 6,
      fill: "white",
      stroke: "#B0C8F9",
      symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
      lineWidth: 0.5
    }
  },
  startHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  endHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  startTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  },
  endTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  }
};
var DEFAULT_HANDLER_ATTR_MAP = {
  horizontal: {
    angle: 0,
    strokeBoundsBuffer: 0,
    boundsPadding: 2,
    pickMode: "imprecise",
    cursor: "ew-resize"
  },
  vertical: {
    angle: Math.PI / 180 * 90,
    cursor: "ns-resize",
    boundsPadding: 2,
    pickMode: "imprecise",
    strokeBoundsBuffer: 0
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/data-zoom/type.js
var DataZoomActiveTag;
!function(DataZoomActiveTag2) {
  DataZoomActiveTag2.startHandler = "startHandler", DataZoomActiveTag2.endHandler = "endHandler", DataZoomActiveTag2.middleHandler = "middleHandler", DataZoomActiveTag2.background = "background";
}(DataZoomActiveTag || (DataZoomActiveTag = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/data-zoom/register.js
function loadDataZoomComponent() {
  loadTagComponent(), registerRect(), registerSymbol(), registerArea(), registerLine();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/data-zoom/data-zoom.js
var __rest13 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var delayMap2 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadDataZoomComponent();
var DataZoom = class _DataZoom extends AbstractComponent {
  setPropsFromAttrs() {
    const { start, end, orient, previewData, previewPointsX, previewPointsY, previewPointsX1, previewPointsY1 } = this.attribute;
    start && (this.state.start = start), end && (this.state.end = end);
    const { width, height } = this.getLayoutAttrFromConfig();
    this._spanCache = this.state.end - this.state.start, this._isHorizontal = "top" === orient || "bottom" === orient, this._layoutCache.max = this._isHorizontal ? width : height, this._layoutCache.attPos = this._isHorizontal ? "x" : "y", this._layoutCache.attSize = this._isHorizontal ? "width" : "height", previewData && (this._previewData = previewData), isFunction_default(previewPointsX) && (this._previewPointsX = previewPointsX), isFunction_default(previewPointsY) && (this._previewPointsY = previewPointsY), isFunction_default(previewPointsX1) && (this._previewPointsX1 = previewPointsX1), isFunction_default(previewPointsY1) && (this._previewPointsY1 = previewPointsY1);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DataZoom.defaultAttributes, attributes)), this.name = "dataZoom", this._previewData = [], this._activeState = false, this._activeCache = {
      startPos: {
        x: 0,
        y: 0
      },
      lastPos: {
        x: 0,
        y: 0
      }
    }, this._layoutCache = {
      attPos: "x",
      attSize: "width",
      max: 0
    }, this.state = {
      start: 0,
      end: 1
    }, this._statePointToData = (state) => state, this._handleTouchMove = (e) => {
      this._activeState && e.preventDefault();
    }, this._onHandlerPointerDown = (e, tag) => {
      this._clearDragEvents(), "start" === tag ? (this._activeTag = DataZoomActiveTag.startHandler, this._activeItem = this._startHandlerMask) : "end" === tag ? (this._activeTag = DataZoomActiveTag.endHandler, this._activeItem = this._endHandlerMask) : "middleRect" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerRect) : "middleSymbol" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerSymbol) : "background" === tag && (this._activeTag = DataZoomActiveTag.background, this._activeItem = this._background), this._activeState = true, this._activeCache.startPos = this.eventPosToStagePos(e), this._activeCache.lastPos = this.eventPosToStagePos(e);
      const evtTarget = "browser" === vglobal.env ? vglobal : this.stage, triggers = getEndTriggersOfDrag();
      evtTarget.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        evtTarget.addEventListener(trigger, this._onHandlerPointerUp);
      });
    }, this._pointerMove = (e) => {
      const { start: startAttr, end: endAttr, brushSelect, realTime = true } = this.attribute, pos = this.eventPosToStagePos(e), { attPos, max: max2 } = this._layoutCache, dis = (pos[attPos] - this._activeCache.lastPos[attPos]) / max2;
      let { start, end } = this.state;
      this._activeState && (this._activeTag === DataZoomActiveTag.middleHandler ? this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + dis) : this._activeTag === DataZoomActiveTag.startHandler ? start + dis > end ? (start = end, end = start + dis, this._activeTag = DataZoomActiveTag.endHandler) : start += dis : this._activeTag === DataZoomActiveTag.endHandler && (end + dis < start ? (end = start, start = end + dis, this._activeTag = DataZoomActiveTag.startHandler) : end += dis), this._activeCache.lastPos = pos, brushSelect && this.renderDragMask()), start = Math.min(Math.max(start, 0), 1), end = Math.min(Math.max(end, 0), 1), startAttr === start && endAttr === end || (this.setStateAttr(start, end, true), realTime && this._dispatchEvent("change", {
        start,
        end,
        tag: this._activeTag
      }));
    }, this._onHandlerPointerMove = 0 === this.attribute.delayTime ? this._pointerMove : delayMap2[this.attribute.delayType](this._pointerMove, this.attribute.delayTime), this._onHandlerPointerUp = (e) => {
      const { start, end, brushSelect, realTime = true } = this.attribute;
      if (this._activeState && this._activeTag === DataZoomActiveTag.background) {
        const pos = this.eventPosToStagePos(e);
        this.backgroundDragZoom(this._activeCache.startPos, pos);
      }
      this._activeState = false, brushSelect && this.renderDragMask(), this._dispatchEvent("change", {
        start: this.state.start,
        end: this.state.end,
        tag: this._activeTag
      }), this._clearDragEvents();
    };
    const { position, showDetail } = attributes;
    this._activeCache.startPos = position, this._activeCache.lastPos = position, this._showText = "auto" !== showDetail && showDetail, this.setPropsFromAttrs();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this.setPropsFromAttrs();
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return void this.setAttribute("childrenPickable", false);
    const { showDetail, brushSelect } = this.attribute;
    this._startHandlerMask && this._startHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "start")), this._endHandlerMask && this._endHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "end")), this._middleHandlerSymbol && this._middleHandlerSymbol.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleSymbol")), this._middleHandlerRect && this._middleHandlerRect.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleRect"));
    const selectedTag = brushSelect ? "background" : "middleRect";
    this._selectedBackground && this._selectedBackground.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), brushSelect && this._background && this._background.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), brushSelect && this._previewGroup && this._previewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), this._selectedPreviewGroup && this._selectedPreviewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), "auto" === showDetail && (this.addEventListener("pointerenter", this._onHandlerPointerEnter), this.addEventListener("pointerleave", this._onHandlerPointerLeave)), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    });
  }
  dragMaskSize() {
    const { position } = this.attribute, { attPos, max: max2 } = this._layoutCache;
    return this._activeCache.lastPos[attPos] - position[attPos] > max2 ? max2 + position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - position[attPos] < 0 ? position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - this._activeCache.startPos[attPos];
  }
  setStateAttr(start, end, shouldRender) {
    const { zoomLock = false, minSpan = 0, maxSpan = 1 } = this.attribute, span = end - start;
    span !== this._spanCache && (zoomLock || span < minSpan || span > maxSpan) || (this._spanCache = span, this.state.start = start, this.state.end = end, shouldRender && this.setAttributes({
      start,
      end
    }));
  }
  eventPosToStagePos(e) {
    var _a, _b;
    return null !== (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventPointTransform(e)) && void 0 !== _b ? _b : {
      x: 0,
      y: 0
    };
  }
  _clearDragEvents() {
    const evtTarget = "browser" === vglobal.env ? vglobal : this.stage, triggers = getEndTriggersOfDrag();
    evtTarget.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      evtTarget.removeEventListener(trigger, this._onHandlerPointerUp);
    }), this.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    });
  }
  _onHandlerPointerEnter(e) {
    this._showText = true, this.renderText();
  }
  _onHandlerPointerLeave(e) {
    this._showText = false, this.renderText();
  }
  backgroundDragZoom(startPos, endPos) {
    const { attPos, max: max2 } = this._layoutCache, { position } = this.attribute, startPosInComponent = startPos[attPos] - position[attPos], endPosInComponent = endPos[attPos] - position[attPos], start = Math.min(Math.max(Math.min(startPosInComponent, endPosInComponent) / max2, 0), 1), end = Math.min(Math.max(Math.max(startPosInComponent, endPosInComponent) / max2, 0), 1);
    Math.abs(start - end) < 0.01 ? this.moveZoomWithMiddle(start) : this.setStateAttr(start, end, false);
  }
  moveZoomWithMiddle(middle) {
    let offset = middle - (this.state.start + this.state.end) / 2;
    0 !== offset && (offset > 0 ? this.state.end + offset > 1 && (offset = 1 - this.state.end) : offset < 0 && this.state.start + offset < 0 && (offset = -this.state.start), this.setStateAttr(this.state.start + offset, this.state.end + offset, false));
  }
  renderDragMask() {
    const { dragMaskStyle } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    this._isHorizontal ? this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x, position.x, position.x + width),
      y: position.y,
      width: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0,
      height
    }, dragMaskStyle), "rect") : this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: position.x,
      y: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y, position.y, position.y + height),
      width,
      height: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0
    }, dragMaskStyle), "rect");
  }
  isTextOverflow(componentBoundsLike, textBounds, layout) {
    if (!textBounds) return false;
    if (this._isHorizontal) {
      if ("start" === layout) {
        if (textBounds.x1 < componentBoundsLike.x1) return true;
      } else if (textBounds.x2 > componentBoundsLike.x2) return true;
    } else if ("start" === layout) {
      if (textBounds.y1 < componentBoundsLike.y1) return true;
    } else if (textBounds.y2 > componentBoundsLike.y2) return true;
    return false;
  }
  setTextAttr(startTextBounds, endTextBounds) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { startTextStyle, endTextStyle } = this.attribute, { formatMethod: startTextFormat } = startTextStyle, restStartTextStyle = __rest13(startTextStyle, ["formatMethod"]), { formatMethod: endTextFormat } = endTextStyle, restEndTextStyle = __rest13(endTextStyle, ["formatMethod"]), { start, end } = this.state;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end);
    const { position, width, height } = this.getLayoutAttrFromConfig(), startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue, endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue, componentBoundsLike = {
      x1: position.x,
      y1: position.y,
      x2: position.x + width,
      y2: position.y + height
    };
    let startTextPosition, endTextPosition, startTextAlignStyle, endTextAlignStyle;
    this._isHorizontal ? (startTextPosition = {
      x: position.x + start * width,
      y: position.y + height / 2
    }, endTextPosition = {
      x: position.x + end * width,
      y: position.y + height / 2
    }, startTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "left" : "right",
      textBaseline: null !== (_b = null === (_a = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _a ? void 0 : _a.textBaseline) && void 0 !== _b ? _b : "middle"
    }, endTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "right" : "left",
      textBaseline: null !== (_d = null === (_c = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _c ? void 0 : _c.textBaseline) && void 0 !== _d ? _d : "middle"
    }) : (startTextPosition = {
      x: position.x + width / 2,
      y: position.y + start * height
    }, endTextPosition = {
      x: position.x + width / 2,
      y: position.y + end * height
    }, startTextAlignStyle = {
      textAlign: null !== (_f = null === (_e = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _e ? void 0 : _e.textAlign) && void 0 !== _f ? _f : "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "top" : "bottom"
    }, endTextAlignStyle = {
      textAlign: null !== (_h = null === (_g = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _g ? void 0 : _g.textAlign) && void 0 !== _h ? _h : "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "bottom" : "top"
    }), this._startText = this.maybeAddLabel(this._container, merge({}, restStartTextStyle, {
      text: startTextValue,
      x: startTextPosition.x,
      y: startTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: startTextAlignStyle
    }), `data-zoom-start-text-${position}`), this._endText = this.maybeAddLabel(this._container, merge({}, restEndTextStyle, {
      text: endTextValue,
      x: endTextPosition.x,
      y: endTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: endTextAlignStyle
    }), `data-zoom-end-text-${position}`);
  }
  renderText() {
    let startTextBounds = null, endTextBounds = null;
    this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds, this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds;
    const { x1, x2, y1, y2 } = startTextBounds, { dx: startTextDx = 0, dy: startTextDy = 0 } = this.attribute.startTextStyle;
    if (new Bounds().set(x1, y1, x2, y2).intersects(endTextBounds)) {
      const direction = "bottom" === this.attribute.orient || "right" === this.attribute.orient ? -1 : 1;
      this._isHorizontal ? this._startText.setAttribute("dy", startTextDy + direction * Math.abs(endTextBounds.y1 - endTextBounds.y2)) : this._startText.setAttribute("dx", startTextDx + direction * Math.abs(endTextBounds.x1 - endTextBounds.x2));
    } else this._isHorizontal ? this._startText.setAttribute("dy", startTextDy) : this._startText.setAttribute("dx", startTextDx);
  }
  getLayoutAttrFromConfig() {
    var _a, _b, _c, _d, _e, _f;
    if (this._layoutAttrFromConfig) return this._layoutAttrFromConfig;
    const { position: positionConfig, size, orient, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, backgroundStyle = {} } = this.attribute, { width: widthConfig, height: heightConfig } = size, middleHandlerSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10;
    let width, height, position;
    middleHandlerStyle.visible ? this._isHorizontal ? (width = widthConfig, height = heightConfig - middleHandlerSize, position = {
      x: positionConfig.x,
      y: positionConfig.y + middleHandlerSize
    }) : (width = widthConfig - middleHandlerSize, height = heightConfig, position = {
      x: positionConfig.x + ("left" === orient ? middleHandlerSize : 0),
      y: positionConfig.y
    }) : (width = widthConfig, height = heightConfig, position = positionConfig);
    const startHandlerSize = null !== (_c = startHandlerStyle.size) && void 0 !== _c ? _c : this._isHorizontal ? height : width, endHandlerSize = null !== (_d = endHandlerStyle.size) && void 0 !== _d ? _d : this._isHorizontal ? height : width;
    return startHandlerStyle.visible && (this._isHorizontal ? (width -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x + startHandlerSize / 2,
      y: position.y
    }) : (height -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x,
      y: position.y + startHandlerSize / 2
    })), height += null !== (_e = backgroundStyle.lineWidth / 2) && void 0 !== _e ? _e : 1, width += null !== (_f = backgroundStyle.lineWidth / 2) && void 0 !== _f ? _f : 1, this._layoutAttrFromConfig = {
      position,
      width,
      height
    }, this._layoutAttrFromConfig;
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
    this._layoutAttrFromConfig = null;
    const { orient, backgroundStyle, backgroundChartStyle = {}, selectedBackgroundStyle = {}, selectedBackgroundChartStyle = {}, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, brushSelect, zoomLock } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig(), startHandlerMinSize = null !== (_a = startHandlerStyle.triggerMinSize) && void 0 !== _a ? _a : 40, endHandlerMinSize = null !== (_b = endHandlerStyle.triggerMinSize) && void 0 !== _b ? _b : 40, group = this.createOrUpdateChild("dataZoom-container", {}, "group");
    if (this._container = group, this._background = group.createOrUpdateChild("background", Object.assign(Object.assign({
      x: position.x,
      y: position.y,
      width,
      height,
      cursor: brushSelect ? "crosshair" : "auto"
    }, backgroundStyle), {
      pickable: !zoomLock && (null === (_c = backgroundStyle.pickable) || void 0 === _c || _c)
    }), "rect"), (null === (_d = backgroundChartStyle.line) || void 0 === _d ? void 0 : _d.visible) && this.setPreviewAttributes("line", group), (null === (_e = backgroundChartStyle.area) || void 0 === _e ? void 0 : _e.visible) && this.setPreviewAttributes("area", group), brushSelect && this.renderDragMask(), this._isHorizontal ? this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x + start * width,
      y: position.y,
      width: (end - start) * width,
      height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_f = selectedBackgroundChartStyle.pickable) || void 0 === _f || _f)
    }), "rect") : this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x,
      y: position.y + start * height,
      width,
      height: (end - start) * height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_g = selectedBackgroundStyle.pickable) || void 0 === _g || _g)
    }), "rect"), (null === (_h = selectedBackgroundChartStyle.line) || void 0 === _h ? void 0 : _h.visible) && this.setSelectedPreviewAttributes("line", group), (null === (_j = selectedBackgroundChartStyle.area) || void 0 === _j ? void 0 : _j.visible) && this.setSelectedPreviewAttributes("area", group), this._isHorizontal) {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_k = middleHandlerStyle.background) || void 0 === _k ? void 0 : _k.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: position.x + start * width,
          y: position.y - middleHandlerBackgroundSize,
          width: (end - start) * width,
          height: middleHandlerBackgroundSize
        }, null === (_l = middleHandlerStyle.background) || void 0 === _l ? void 0 : _l.style), {
          pickable: !zoomLock && (null === (_p = null === (_o = null === (_m = middleHandlerStyle.background) || void 0 === _m ? void 0 : _m.style) || void 0 === _o ? void 0 : _o.pickable) || void 0 === _p || _p)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: position.x + (start + end) / 2 * width,
          y: position.y - middleHandlerBackgroundSize / 2,
          strokeBoundsBuffer: 0,
          angle: 0,
          symbolType: null !== (_r = null === (_q = middleHandlerStyle.icon) || void 0 === _q ? void 0 : _q.symbolType) && void 0 !== _r ? _r : "square"
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_s = middleHandlerStyle.icon.pickable) || void 0 === _s || _s)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + start * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_t = startHandlerStyle.symbolType) && void 0 !== _t ? _t : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), {
        pickable: !zoomLock && (null === (_u = startHandlerStyle.pickable) || void 0 === _u || _u)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + end * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_v = endHandlerStyle.symbolType) && void 0 !== _v ? _v : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), {
        pickable: !zoomLock && (null === (_w = endHandlerStyle.pickable) || void 0 === _w || _w)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + start * width - startHandlerWidth / 2,
        y: position.y + height / 2 - startHandlerHeight / 2,
        width: startHandlerWidth,
        height: startHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + end * width - endHandlerWidth / 2,
        y: position.y + height / 2 - endHandlerHeight / 2,
        width: endHandlerWidth,
        height: endHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect");
    } else {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_x = middleHandlerStyle.background) || void 0 === _x ? void 0 : _x.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize : position.x + width,
          y: position.y + start * height,
          width: middleHandlerBackgroundSize,
          height: (end - start) * height
        }, null === (_y = middleHandlerStyle.background) || void 0 === _y ? void 0 : _y.style), {
          pickable: !zoomLock && (null === (_1 = null === (_0 = null === (_z = middleHandlerStyle.background) || void 0 === _z ? void 0 : _z.style) || void 0 === _0 ? void 0 : _0.pickable) || void 0 === _1 || _1)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize / 2 : position.x + width + middleHandlerBackgroundSize / 2,
          y: position.y + (start + end) / 2 * height,
          angle: Math.PI / 180 * 90,
          symbolType: null !== (_3 = null === (_2 = middleHandlerStyle.icon) || void 0 === _2 ? void 0 : _2.symbolType) && void 0 !== _3 ? _3 : "square",
          strokeBoundsBuffer: 0
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_5 = null === (_4 = middleHandlerStyle.icon) || void 0 === _4 ? void 0 : _4.pickable) || void 0 === _5 || _5)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + start * height,
        size: width,
        symbolType: null !== (_6 = startHandlerStyle.symbolType) && void 0 !== _6 ? _6 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), {
        pickable: !zoomLock && (null === (_7 = startHandlerStyle.pickable) || void 0 === _7 || _7)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + end * height,
        size: width,
        symbolType: null !== (_8 = endHandlerStyle.symbolType) && void 0 !== _8 ? _8 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), {
        pickable: !zoomLock && (null === (_9 = endHandlerStyle.pickable) || void 0 === _9 || _9)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + startHandlerWidth / 2,
        y: position.y + start * height - startHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + endHandlerWidth / 2,
        y: position.y + end * height - endHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect");
    }
    this._showText && this.renderText();
  }
  computeBasePoints() {
    const { orient } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    let basePointStart, basePointEnd;
    return this._isHorizontal ? (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : "left" === orient ? (basePointStart = [{
      x: position.x + width,
      y: position.y
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x,
      y: position.y
    }]), {
      basePointStart,
      basePointEnd
    };
  }
  simplifyPoints(points) {
    var _a;
    if (points.length > 1e4) {
      const tolerance = null !== (_a = this.attribute.tolerance) && void 0 !== _a ? _a : this._previewData.length / 1e4;
      return flatten_simplify(points, tolerance, false);
    }
    return points;
  }
  getPreviewLinePoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d)
    }));
    if (0 === previewPoints.length) return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  getPreviewAreaPoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d),
      x1: this._previewPointsX1 && this._previewPointsX1(d),
      y1: this._previewPointsY1 && this._previewPointsY1(d)
    }));
    if (0 === previewPoints.length) return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  setPreviewAttributes(type, group) {
    this._previewGroup || (this._previewGroup = group.createOrUpdateChild("previewGroup", {
      pickable: false
    }, "group")), "line" === type ? this._previewLine = this._previewGroup.createOrUpdateChild("previewLine", {}, "line") : this._previewArea = this._previewGroup.createOrUpdateChild("previewArea", {
      curveType: "basis"
    }, "area");
    const { backgroundChartStyle = {} } = this.attribute;
    "line" === type && this._previewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.line)), "area" === type && this._previewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.area));
  }
  setSelectedPreviewAttributes(type, group) {
    this._selectedPreviewGroupClip || (this._selectedPreviewGroupClip = group.createOrUpdateChild("selectedPreviewGroupClip", {
      pickable: false
    }, "group"), this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild("selectedPreviewGroup", {}, "group")), "line" === type ? this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewLine", {}, "line") : this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewArea", {
      curveType: "basis"
    }, "area");
    const { selectedBackgroundChartStyle = {} } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig();
    this._selectedPreviewGroupClip.setAttributes({
      x: this._isHorizontal ? position.x + start * width : position.x,
      y: this._isHorizontal ? position.y : position.y + start * height,
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      clip: true,
      pickable: false
    }), this._selectedPreviewGroup.setAttributes({
      x: -(this._isHorizontal ? position.x + start * width : position.x),
      y: -(this._isHorizontal ? position.y : position.y + start * height),
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      pickable: false
    }), "line" === type && this._selectedPreviewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.line)), "area" === type && this._selectedPreviewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.area));
  }
  maybeAddLabel(container2, attributes, name) {
    let labelShape = this.find((node) => node.name === name, true);
    return labelShape ? labelShape.setAttributes(attributes) : (labelShape = new Tag(attributes), labelShape.name = name), container2.add(labelShape), labelShape;
  }
  setStartAndEnd(start, end) {
    const { start: startAttr, end: endAttr } = this.attribute;
    isValid_default(start) && isValid_default(end) && (start !== this.state.start || end !== this.state.end) && (this.state.start = start, this.state.end = end, startAttr === this.state.start && endAttr === this.state.end || (this.setStateAttr(start, end, true), this._dispatchEvent("change", {
      start,
      end,
      tag: this._activeTag
    })));
  }
  setPreviewData(data) {
    this._previewData = data;
  }
  setText(text2, tag) {
    "start" === tag ? this._startText.setAttribute("text", text2) : this._endText.setAttribute("text", text2);
  }
  getStartValue() {
    return this._startValue;
  }
  getEndTextValue() {
    return this._endValue;
  }
  getMiddleHandlerSize() {
    var _a, _b, _c, _d;
    const { middleHandlerStyle = {} } = this.attribute, middleHandlerRectSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10, middleHandlerSymbolSize = null !== (_d = null === (_c = middleHandlerStyle.icon) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
    return Math.max(middleHandlerRectSize, ...array(middleHandlerSymbolSize));
  }
  setPreviewPointsX(callback) {
    isFunction_default(callback) && (this._previewPointsX = callback);
  }
  setPreviewPointsY(callback) {
    isFunction_default(callback) && (this._previewPointsY = callback);
  }
  setPreviewPointsX1(callback) {
    isFunction_default(callback) && (this._previewPointsX1 = callback);
  }
  setPreviewPointsY1(callback) {
    isFunction_default(callback) && (this._previewPointsY1 = callback);
  }
  setStatePointToData(callback) {
    isFunction_default(callback) && (this._statePointToData = callback);
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearDragEvents();
  }
};
DataZoom.defaultAttributes = DEFAULT_DATA_ZOOM_ATTRIBUTES;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/type.js
var IMarkLineLabelPosition;
!function(IMarkLineLabelPosition2) {
  IMarkLineLabelPosition2.start = "start", IMarkLineLabelPosition2.startTop = "startTop", IMarkLineLabelPosition2.startBottom = "startBottom", IMarkLineLabelPosition2.insideStart = "insideStart", IMarkLineLabelPosition2.insideStartTop = "insideStartTop", IMarkLineLabelPosition2.insideStartBottom = "insideStartBottom", IMarkLineLabelPosition2.middle = "middle", IMarkLineLabelPosition2.insideMiddleTop = "insideMiddleTop", IMarkLineLabelPosition2.insideMiddleBottom = "insideMiddleBottom", IMarkLineLabelPosition2.end = "end", IMarkLineLabelPosition2.endTop = "endTop", IMarkLineLabelPosition2.endBottom = "endBottom", IMarkLineLabelPosition2.insideEnd = "insideEnd", IMarkLineLabelPosition2.insideEndTop = "insideEndTop", IMarkLineLabelPosition2.insideEndBottom = "insideEndBottom";
}(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
var IMarkAreaLabelPosition;
!function(IMarkAreaLabelPosition2) {
  IMarkAreaLabelPosition2.left = "left", IMarkAreaLabelPosition2.right = "right", IMarkAreaLabelPosition2.top = "top", IMarkAreaLabelPosition2.bottom = "bottom", IMarkAreaLabelPosition2.topLeft = "topLeft", IMarkAreaLabelPosition2.topRight = "topRight", IMarkAreaLabelPosition2.bottomLeft = "bottomLeft", IMarkAreaLabelPosition2.bottomRight = "bottomRight", IMarkAreaLabelPosition2.middle = "middle", IMarkAreaLabelPosition2.insideLeft = "insideLeft", IMarkAreaLabelPosition2.insideRight = "insideRight", IMarkAreaLabelPosition2.insideTop = "insideTop", IMarkAreaLabelPosition2.insideBottom = "insideBottom", IMarkAreaLabelPosition2.insideTopLeft = "insideTopLeft", IMarkAreaLabelPosition2.insideTopRight = "insideTopRight", IMarkAreaLabelPosition2.insideBottomLeft = "insideBottomLeft", IMarkAreaLabelPosition2.insideBottomRight = "insideBottomRight";
}(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
var IMarkCommonArcLabelPosition;
!function(IMarkCommonArcLabelPosition2) {
  IMarkCommonArcLabelPosition2.arcInnerStart = "arcInnerStart", IMarkCommonArcLabelPosition2.arcInnerEnd = "arcInnerEnd", IMarkCommonArcLabelPosition2.arcInnerMiddle = "arcInnerMiddle", IMarkCommonArcLabelPosition2.arcOuterStart = "arcOuterStart", IMarkCommonArcLabelPosition2.arcOuterEnd = "arcOuterEnd", IMarkCommonArcLabelPosition2.arcOuterMiddle = "arcOuterMiddle", IMarkCommonArcLabelPosition2.center = "center";
}(IMarkCommonArcLabelPosition || (IMarkCommonArcLabelPosition = {}));
var IMarkPointItemPosition;
!function(IMarkPointItemPosition2) {
  IMarkPointItemPosition2.top = "top", IMarkPointItemPosition2.bottom = "bottom", IMarkPointItemPosition2.middle = "middle", IMarkPointItemPosition2.insideTop = "insideTop", IMarkPointItemPosition2.insideBottom = "insideBottom", IMarkPointItemPosition2.insideMiddle = "insideMiddle";
}(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/register.js
function loadBaseMarker() {
  registerGroup(), loadTagComponent();
}
function loadMarkLineComponent() {
  loadBaseMarker(), loadSegmentComponent();
}
function loadMarkArcLineComponent() {
  loadBaseMarker(), loadArcSegmentComponent();
}
function loadMarkAreaComponent() {
  loadBaseMarker(), registerPolygon();
}
function loadMarkArcAreaComponent() {
  loadBaseMarker(), registerArc();
}
function loadMarkPointComponent() {
  loadBaseMarker(), loadSegmentComponent(), loadArcSegmentComponent(), registerSymbol(), registerImage(), registerLine();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/base.js
var Marker = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "marker", this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this._container, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this._container, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this._container, this._lastSelect);
    };
  }
  transAnimationConfig() {
    var _a, _b, _c;
    if (false !== this.attribute.animation) {
      const animation = isObject_default(this.attribute.animation) ? this.attribute.animation : {};
      this._animationConfig = {
        enter: merge({}, this.defaultUpdateAnimation, animation, null !== (_a = this.attribute.animationEnter) && void 0 !== _a ? _a : {}),
        exit: merge({}, this.defaultExitAnimation, animation, null !== (_b = this.attribute.animationExit) && void 0 !== _b ? _b : {}),
        update: merge({}, this.defaultUpdateAnimation, animation, null !== (_c = this.attribute.animationUpdate) && void 0 !== _c ? _c : {})
      };
    }
  }
  setAttribute(key, value, forceUpdateTag) {
    super.setAttribute(key, value, forceUpdateTag), "visible" === key && this.render();
  }
  _bindEvent() {
    var _a, _b, _c;
    if (!this.attribute.interactive) return;
    const { hover, select } = this.attribute;
    hover && (null === (_a = this._container) || void 0 === _a || _a.addEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.addEventListener("pointerout", this._onUnHover)), select && (null === (_c = this._container) || void 0 === _c || _c.addEventListener("pointerdown", this._onClick));
  }
  _releaseEvent() {
    var _a, _b, _c;
    null === (_a = this._container) || void 0 === _a || _a.removeEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.removeEventListener("pointerout", this._onUnHover), null === (_c = this._container) || void 0 === _c || _c.removeEventListener("pointerdown", this._onClick);
  }
  _initContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    let group;
    if (clipInRange) {
      const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), {
        clip: true,
        pickable: false
      }));
      group = graphicCreator.group({
        x: -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0),
        y: -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0),
        pickable: false
      }), groupClip.add(group), this._containerClip = groupClip, this.add(groupClip);
    } else group = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(group);
    group.name = "marker-container", this._container = group;
  }
  _updateContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    this._containerClip && this._containerClip.setAttributes(Object.assign({}, limitRect)), this._container.setAttributes({
      x: clipInRange ? -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0) : 0,
      y: clipInRange ? -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0) : 0
    });
  }
  render() {
    var _a;
    this.transAnimationConfig(), this.setAttribute("pickable", false);
    const markerVisible = null === (_a = this.attribute.visible) || void 0 === _a || _a;
    false === this.attribute.interactive && this.setAttribute("childrenPickable", false), markerVisible && this.isValidPoints() ? this._container ? (this._updateContainer(), this.updateMarker(), this.markerAnimate("update")) : (this._initContainer(), this.initMarker(this._container), this.markerAnimate("enter")) : (this.markerAnimate("exit"), this._container = null, this.removeAllChild(true)), this._releaseEvent(), this._bindEvent();
  }
  release() {
    this.markerAnimate("exit"), super.release(), this._releaseEvent(), this._container = null;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/animate/animate.js
var DefaultUpdateMarkLineAnimation = {
  type: "clipIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkAreaAnimation = {
  type: "fadeIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkPointAnimation = {
  type: "callIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultExitMarkerAnimation = {
  type: "fadeOut",
  duration: 500,
  easing: "linear",
  delay: 0
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/mixin/label.js
var MarkLabelMixin = class {
  getLabel() {
    return this._label;
  }
  _addMarkLabels(container2, labelName, defaultLabelAttrs) {
    const { label, state } = this.attribute, labelStates = array(null == state ? void 0 : state.label), labelBackgroundStates = array(null == state ? void 0 : state.labelBackground), labelShapes = array(label).map((labelAttrs, index) => {
      var _a, _b;
      const finalLabelAttrs = merge({}, defaultLabelAttrs, labelAttrs), markLabel = new Tag(Object.assign(Object.assign({}, finalLabelAttrs), {
        state: {
          panel: merge({}, DEFAULT_STATES, null !== (_a = labelBackgroundStates[index]) && void 0 !== _a ? _a : last(labelBackgroundStates)),
          text: merge({}, DEFAULT_STATES, null !== (_b = labelStates[index]) && void 0 !== _b ? _b : last(labelStates))
        }
      }));
      return markLabel.name = labelName, container2.add(markLabel), this.setLabelPos(markLabel, finalLabelAttrs), markLabel;
    });
    this._label = 1 === array(labelShapes).length ? labelShapes[0] : labelShapes;
  }
  _updateMarkLabels(defaultLabelAttrs) {
    const { label, state } = this.attribute, labelShapes = array(this._label), labelStates = array(null == state ? void 0 : state.label), labelBackgroundStates = array(null == state ? void 0 : state.labelBackground);
    if (labelShapes.length) {
      const labels = array(label);
      labelShapes.forEach((labelItem, index) => {
        var _a, _b;
        const finalLabelAttrs = merge({}, defaultLabelAttrs, labels[index]);
        labelItem.setAttributes(Object.assign(Object.assign({
          dx: 0,
          dy: 0
        }, finalLabelAttrs), {
          state: {
            panel: merge({}, DEFAULT_STATES, null !== (_a = labelBackgroundStates[index]) && void 0 !== _a ? _a : last(labelBackgroundStates)),
            text: merge({}, DEFAULT_STATES, null !== (_b = labelStates[index]) && void 0 !== _b ? _b : last(labelStates))
          }
        })), this.setLabelPos(labelItem, finalLabelAttrs);
      });
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/common-line.js
var MarkCommonLine = class extends Marker {
  constructor() {
    super(...arguments), this.name = "markCommonLine", this.defaultUpdateAnimation = DefaultUpdateMarkLineAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getLine() {
    return this._line;
  }
  setLabelPos(labelNode, labelAttrs) {
    const { limitRect } = this.attribute, { position, confine, autoRotate: autoRotate2 } = labelAttrs, labelPoint = this.getPointAttrByPosition(position, labelAttrs), labelAngle = position.toString().toLocaleLowerCase().includes("start") ? this._line.getStartAngle() || 0 : this._line.getEndAngle() || 0;
    if (labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint.position), {
      angle: autoRotate2 ? this.getRotateByAngle(labelPoint.angle, labelAttrs) : 0,
      textStyle: Object.assign(Object.assign({}, this.getTextStyle(position, labelAngle, autoRotate2)), labelAttrs.textStyle)
    })), limitRect && confine) {
      const { x, y, width, height } = limitRect;
      limitShapeInBounds(labelNode, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
    }
  }
  initMarker(container2) {
    const line = this.createSegment();
    line.name = "mark-common-line-line", this._line = line, container2.add(line), this.addMarkLineLabels(container2);
  }
  updateMarker() {
    this.setLineAttributes(), this.updateMarkLineLabels();
  }
};
mixin(MarkCommonLine, MarkLabelMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/config.js
var FUZZY_EQUAL_DELTA = 1e-3;
var DEFAULT_MARK_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    position: IMarkLineLabelPosition.end,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP = {
  postiveXAxis: {
    start: {
      textAlign: "left",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "left",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "right",
      textBaseline: "top"
    }
  },
  negativeXAxis: {
    start: {
      textAlign: "right",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "right",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "left",
      textBaseline: "top"
    }
  }
};
var DEFAULT_MARK_ARC_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    autoRotate: true,
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_MARK_AREA_THEME = {
  interactive: true,
  label: {
    position: IMarkAreaLabelPosition.right,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_MARK_ARC_AREA_THEME = {
  interactive: true,
  label: {
    autoRotate: true,
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP = {
  arcInnerStart: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerEnd: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerMiddle: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcOuterStart: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterEnd: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterMiddle: {
    textAlign: "center",
    textBaseline: "top"
  },
  center: {
    textAlign: "center",
    textBaseline: "middle"
  }
};
var DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP = {
  left: {
    textAlign: "right",
    textBaseline: "middle"
  },
  insideLeft: {
    textAlign: "left",
    textBaseline: "middle"
  },
  right: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideRight: {
    textAlign: "right",
    textBaseline: "middle"
  },
  top: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  insideTop: {
    textAlign: "center",
    textBaseline: "top"
  },
  bottom: {
    textAlign: "center",
    textBaseline: "top"
  },
  insideBottom: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  middle: {
    textAlign: "center",
    textBaseline: "middle"
  },
  topLeft: {
    textAlign: "right",
    textBaseline: "top"
  },
  insideTopLeft: {
    textAlign: "left",
    textBaseline: "top"
  },
  topRight: {
    textAlign: "left",
    textBaseline: "top"
  },
  insideTopRight: {
    textAlign: "right",
    textBaseline: "top"
  },
  bottomLeft: {
    textAlign: "right",
    textBaseline: "bottom"
  },
  insideBottomLeft: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  bottomRight: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  insideBottomRight: {
    textAlign: "right",
    textBaseline: "bottom"
  }
};
var DEFAULT_MARK_POINT_THEME = {
  interactive: true,
  targetSymbol: {
    visible: false,
    offset: 0,
    style: {
      symbolType: "circle",
      size: 20,
      fill: false,
      stroke: "rgba(46, 47, 50)"
    }
  },
  itemLine: {
    visible: true,
    decorativeLine: {
      visible: false,
      length: 30
    },
    startSymbol: {
      visible: true,
      clip: true,
      symbolType: "circle",
      size: 20,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    endSymbol: {
      visible: false,
      clip: true,
      symbolType: "triangle",
      size: 12,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    lineStyle: {
      stroke: "#000",
      lineWidth: 1
    }
  },
  itemContent: {
    type: "text",
    position: "middle",
    refX: 10,
    symbolStyle: {
      symbolType: "star",
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8,
      size: 20
    },
    textStyle: {
      dx: 0,
      dy: 0
    },
    imageStyle: {
      width: 80,
      height: 80
    },
    richTextStyle: {
      width: 100,
      height: 100
    }
  }
};
var DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
  postiveXAxis: {
    top: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "right",
      textBaseline: "middle"
    }
  },
  negativeXAxis: {
    top: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "left",
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/line.js
loadMarkLineComponent();
var MarkLine = class _MarkLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkLine._animate && this._animationConfig && _MarkLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkLine.defaultAttributes, attributes)), this.name = "markLine";
  }
  getPointAttrByPosition(position, labelAttrs) {
    var _a;
    const { refX = 0, refY = 0 } = labelAttrs, points = this._line.getMainSegmentPoints(), lineEndAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelAngle = (isPostiveXAxis(lineEndAngle), lineEndAngle), labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
    return position.includes("start") || position.includes("Start") ? {
      position: {
        x: points[0].x + labelOffsetX,
        y: points[0].y + labelOffsetY
      },
      angle: labelAngle
    } : position.includes("middle") || position.includes("Middle") ? {
      position: {
        x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
        y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
      },
      angle: labelAngle
    } : {
      position: {
        x: points[points.length - 1].x + labelOffsetX,
        y: points[points.length - 1].y + labelOffsetY
      },
      angle: labelAngle
    };
  }
  getRotateByAngle(angle2, labelAttrs) {
    var _a;
    return (isPostiveXAxis(angle2) ? angle2 : angle2 - Math.PI) + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
  }
  getTextStyle(position, labelAngle, autoRotate2) {
    return fuzzyEqualNumber(Math.abs(labelAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(labelAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, labelAngle, position) : isPostiveXAxis(labelAngle) ? DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position] : DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
  }
  createSegment() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    return new Segment({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      pickable: false,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    this._line && this._line.setAttributes({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 2) return false;
    let validFlag = true;
    return points.forEach((point5) => {
      if (point5.length) point5.forEach((p) => {
        isValidNumber_default(p.x) && isValidNumber_default(p.y) || (validFlag = false);
      });
      else if (!isValidNumber_default(point5.x) || !isValidNumber_default(point5.y)) return void (validFlag = false);
    }), validFlag;
  }
  addMarkLineLabels(container2) {
    this._addMarkLabels(container2, "mark-common-line-label", _MarkLine.defaultAttributes.label);
  }
  updateMarkLineLabels() {
    this._updateMarkLabels(_MarkLine.defaultAttributes.label);
  }
};
MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/area.js
loadMarkAreaComponent();
var MarkArea = class _MarkArea extends Marker {
  markerAnimate(state) {
    _MarkArea._animate && this._animationConfig && _MarkArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArea.defaultAttributes, attributes)), this.name = "markArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position) {
    const { x1, x2, y1, y2 } = this._area.AABBBounds, result2 = {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    };
    return (position.includes("left") || position.includes("Left")) && (result2.x = x1), (position.includes("right") || position.includes("Right")) && (result2.x = x2), (position.includes("top") || position.includes("Top")) && (result2.y = y1), (position.includes("bottom") || position.includes("Bottom")) && (result2.y = y2), result2;
  }
  setLabelPos(labelNode, labelAttrs) {
    var _a;
    if (this._area) {
      const labelPosition = null !== (_a = labelAttrs.position) && void 0 !== _a ? _a : "middle", labelPoint = this.getPointAttrByPosition(labelPosition);
      if (labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint), {
        textStyle: Object.assign(Object.assign({}, DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle)
      })), this.attribute.limitRect && labelAttrs.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(labelNode, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { points, areaStyle, state } = this.attribute, area = graphicCreator.polygon(Object.assign({
      points
    }, areaStyle));
    area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area.name = "mark-area-polygon", this._area = area, container2.add(area), this._addMarkLabels(container2, "mark-area-label", _MarkArea.defaultAttributes.label);
  }
  updateMarker() {
    const { points, areaStyle, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      points
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._updateMarkLabels(_MarkArea.defaultAttributes.label);
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 3) return false;
    let validFlag = true;
    return points.forEach((point5) => {
      isValidNumber_default(point5.x) && isValidNumber_default(point5.y) || (validFlag = false);
    }), validFlag;
  }
};
MarkArea.defaultAttributes = DEFAULT_MARK_AREA_THEME, mixin(MarkArea, MarkLabelMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/arc-line.js
loadMarkArcLineComponent();
var MarkArcLine = class _MarkArcLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkArcLine._animate && this._animationConfig && _MarkArcLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcLine.defaultAttributes, attributes)), this.name = "markArcLine";
  }
  getPointAttrByPosition(direction, labelAttrs) {
    const { center, radius, startAngle, endAngle } = this.attribute, { refX = 0, refY = 0 } = labelAttrs;
    let angle2;
    switch (direction) {
      case IMarkCommonArcLabelPosition.arcInnerStart:
        angle2 = startAngle;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        angle2 = endAngle;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.center:
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
      default:
        angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  getTextStyle(position) {
    return DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[position];
  }
  getRotateByAngle(angle2, labelAttrs) {
    var _a;
    return angle2 - Math.PI / 2 + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
  }
  createSegment() {
    const { center, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    return new ArcSegment({
      center,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { center, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    this._line && this._line.setAttributes({
      center,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    return true;
  }
  addMarkLineLabels(container2) {
    this._addMarkLabels(container2, "mark-common-line-label", _MarkArcLine.defaultAttributes.label);
  }
  updateMarkLineLabels() {
    this._updateMarkLabels(_MarkArcLine.defaultAttributes.label);
  }
};
MarkArcLine.defaultAttributes = DEFAULT_MARK_ARC_LINE_THEME;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/arc-area.js
loadMarkArcAreaComponent();
var MarkArcArea = class _MarkArcArea extends Marker {
  markerAnimate(state) {
    _MarkArcArea._animate && this._animationConfig && _MarkArcArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcArea.defaultAttributes, attributes)), this.name = "markArcArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position, labelAttrs) {
    const { center, innerRadius, outerRadius, startAngle, endAngle } = this.attribute, { refX = 0, refY = 0 } = labelAttrs;
    let radius, angle2;
    switch (position) {
      case IMarkCommonArcLabelPosition.center:
        radius = (innerRadius + outerRadius) / 2, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcInnerStart:
        radius = innerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        radius = outerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        radius = innerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        radius = outerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
        radius = outerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      default:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  setLabelPos(labelNode, labelAttrs) {
    var _a;
    if (this._area) {
      const { position: labelPosition = "arcInnerMiddle", autoRotate: autoRotate2 } = labelAttrs, labelAttr = this.getPointAttrByPosition(labelPosition, labelAttrs);
      if (labelNode.setAttributes(Object.assign(Object.assign({}, labelAttr.position), {
        angle: autoRotate2 ? labelAttr.angle - Math.PI / 2 + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0) : 0,
        textStyle: Object.assign(Object.assign({}, DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle)
      })), this.attribute.limitRect && labelAttrs.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(labelNode, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { center, innerRadius, outerRadius, startAngle, endAngle, areaStyle, state } = this.attribute, area = graphicCreator.arc(Object.assign({
      x: center.x,
      y: center.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle));
    area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area.name = "polar-mark-area-area", this._area = area, container2.add(area), this._addMarkLabels(container2, "mark-area-label", _MarkArcArea.defaultAttributes.label);
  }
  updateMarker() {
    const { center, innerRadius, outerRadius, startAngle, endAngle, areaStyle, label, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      x: center.x,
      y: center.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._updateMarkLabels(_MarkArcArea.defaultAttributes.label);
  }
  isValidPoints() {
    return true;
  }
};
MarkArcArea.defaultAttributes = DEFAULT_MARK_ARC_AREA_THEME, mixin(MarkArcArea, MarkLabelMixin);

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/marker/point.js
loadMarkPointComponent();
var MarkPoint = class _MarkPoint extends Marker {
  markerAnimate(state) {
    _MarkPoint._animate && this._animationConfig && _MarkPoint._animate([this._line, this._decorativeLine], this._item, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkPoint.defaultAttributes, attributes)), this.name = "markPoint", this.defaultUpdateAnimation = DefaultUpdateMarkPointAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation, this._isArcLine = false, this._isStraightLine = false;
  }
  setLabelPos() {
  }
  getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, itemPosition) {
    return fuzzyEqualNumber(Math.abs(lineEndAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(lineEndAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) : isPostiveXAxis(lineEndAngle) ? DEFAULT_MARK_POINT_TEXT_STYLE_MAP.postiveXAxis[itemPosition] : DEFAULT_MARK_POINT_TEXT_STYLE_MAP.negativeXAxis[itemPosition];
  }
  setItemAttributes(item, itemContent, newPosition, newItemPosition, itemType) {
    var _a, _b;
    if (!item) return;
    const { autoRotate: autoRotate2 = true, refX = 0, refY = 0, refAngle = 0, textStyle = {}, richTextStyle = {}, imageStyle = {}, position: positionType = IMarkPointItemPosition.middle } = itemContent, { state } = this.attribute, lineEndAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0, itemRefOffsetX = refX * Math.cos(lineEndAngle) + refY * Math.cos(lineEndAngle - Math.PI / 2), itemRefOffsetY = refX * Math.sin(lineEndAngle) + refY * Math.sin(lineEndAngle - Math.PI / 2);
    if ("text" === itemType) {
      const offsetX = newItemPosition.x - newPosition.x, offsetY = newItemPosition.y - newPosition.y;
      item.setAttributes(Object.assign(Object.assign({}, textStyle), {
        textStyle: Object.assign(Object.assign({}, this.getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, null !== (_b = itemContent.position) && void 0 !== _b ? _b : "end")), textStyle.textStyle),
        state: {
          panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
          text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
        }
      }));
    } else "richText" === itemType ? (item.setAttributes({
      dx: this.getItemDx(item, positionType, richTextStyle) + (richTextStyle.dx || 0),
      dy: this.getItemDy(item, positionType, richTextStyle) + (richTextStyle.dy || 0)
    }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === itemType && (item.setAttributes({
      dx: this.getItemDx(item, positionType, imageStyle) + (imageStyle.dx || 0),
      dy: this.getItemDy(item, positionType, imageStyle) + (imageStyle.dy || 0)
    }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image));
    const itemAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle - Math.PI;
    item.setAttributes({
      x: newItemPosition.x + (itemRefOffsetX || 0),
      y: newItemPosition.y + (itemRefOffsetY || 0),
      angle: autoRotate2 && itemAngle + refAngle
    });
  }
  getItemDx(item, position, style2) {
    var _a, _b;
    const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style2 ? void 0 : style2.width) || 0;
    return position.includes("inside") ? -width : 0;
  }
  getItemDy(item, position, style2) {
    var _a, _b;
    const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style2 ? void 0 : style2.height) || 0;
    return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
  }
  initItem(itemContent, newPosition, newItemPosition) {
    const { state } = this.attribute, { type = "text", symbolStyle, richTextStyle, imageStyle, renderCustomCallback } = itemContent;
    let item;
    return "symbol" === type ? (item = graphicCreator.symbol(Object.assign(Object.assign({}, newItemPosition), symbolStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.symbol)) : "text" === type ? item = new Tag(Object.assign(Object.assign({}, newItemPosition), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
      }
    })) : "richText" === type ? (item = graphicCreator.richtext(Object.assign(Object.assign({}, newItemPosition), richTextStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === type ? (item = graphicCreator.image(Object.assign(Object.assign({}, newItemPosition), imageStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback(), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.customMark)), item.name = `mark-point-${type}`, this.setItemAttributes(item, itemContent, newPosition, newItemPosition, type), item;
  }
  getItemLineAttr(itemLine, newPosition, newItemPosition) {
    let points = [], center = {
      x: 0,
      y: 0
    }, radius = 0, startAngle = 0, endAngle = 0;
    const { type = "type-s", arcRatio = 0.8 } = itemLine, itemOffsetX = newItemPosition.x - newPosition.x, itemOffsetY = newItemPosition.y - newPosition.y;
    if (this._isStraightLine = fuzzyEqualNumber(itemOffsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(itemOffsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine) {
      const { x: x1, y: y1 } = this.attribute.position, { x: x2, y: y2 } = newItemPosition, x0 = (x1 + x2) / 2, y0 = (y1 + y2) / 2, k2 = y1 === y2 ? 0 : -(x1 - x2) / (y1 - y2), centerX = x0 + arcRatio * (y2 > y1 ? -1 : 1) * x0, centerY = ((x) => k2 * (x - x0) + y0)(centerX);
      startAngle = deltaXYToAngle(y1 - centerY, x1 - centerX), endAngle = deltaXYToAngle(y2 - centerY, x2 - centerX), center = {
        x: centerX,
        y: centerY
      };
      const R = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1)), r = this.attribute.targetSymbol.style.size / 2;
      startAngle += 2 * Math.acos(Math.sqrt(1 - r * r / (4 * R * R))), arcRatio > 0 ? endAngle < startAngle && (endAngle += 2 * Math.PI) : startAngle < endAngle && (startAngle += 2 * Math.PI), radius = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1));
    } else points = "type-do" !== type || this._isStraightLine ? "type-po" !== type || this._isStraightLine ? "type-op" !== type || this._isStraightLine ? [newPosition, newItemPosition] : [newPosition, {
      x: newPosition.x,
      y: newItemPosition.y
    }, newItemPosition] : [newPosition, {
      x: newItemPosition.x,
      y: newPosition.y
    }, newItemPosition] : [newPosition, {
      x: (newPosition.x + newItemPosition.x) / 2,
      y: newItemPosition.y
    }, newItemPosition];
    return points = removeRepeatPoint(points), {
      points,
      center,
      radius,
      startAngle,
      endAngle
    };
  }
  reDrawLine(itemLine, pointsAttr) {
    this._line.release();
    const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, lineConstructor = this._isArcLine ? ArcSegment : Segment;
    this._container.removeChild(this._line), this._line = new lineConstructor(Object.assign(Object.assign({}, pointsAttr), {
      pickable: false,
      startSymbol,
      endSymbol,
      lineStyle,
      visible: itemLine.visible,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    })), this._container.add(this._line);
  }
  setItemLineAttr(itemLine, newPosition, newItemPosition) {
    if (this._line) {
      const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, pointsAttr = this.getItemLineAttr(itemLine, newPosition, newItemPosition);
      this._isArcLine && "arc-segment" === this._line.key || !this._isArcLine && "segment" === this._line.key ? this._line.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
        startSymbol,
        endSymbol,
        lineStyle,
        visible: itemLine.visible,
        state: {
          line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
          startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
          endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
        }
      })) : this.reDrawLine(itemLine, pointsAttr);
    }
  }
  getDecorativeLineAttr(itemLine) {
    var _a;
    const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10, itemAngle = this._line.getEndAngle() || 0;
    return {
      startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
      endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
    };
  }
  setDecorativeLineAttr(itemLine, newItemPosition, visible) {
    var _a;
    if (this._decorativeLine) {
      const { lineStyle } = itemLine, { startPointOffsetX, startPointOffsetY, endPointOffsetX, endPointOffsetY } = this.getDecorativeLineAttr(itemLine);
      this._decorativeLine.setAttributes(Object.assign(Object.assign({
        points: [{
          x: newItemPosition.x + startPointOffsetX,
          y: newItemPosition.y + startPointOffsetY
        }, {
          x: newItemPosition.x + endPointOffsetX,
          y: newItemPosition.y + endPointOffsetY
        }]
      }, lineStyle), {
        visible
      })), this._decorativeLine.states = merge({}, DEFAULT_STATES, null === (_a = this.attribute.state) || void 0 === _a ? void 0 : _a.line);
    }
  }
  setTargetItemAttributes(targetItem, position) {
    var _a, _b;
    this._targetItem && (this._targetItem.setAttributes(Object.assign({
      x: position.x,
      y: position.y,
      visible: null !== (_a = targetItem.visible) && void 0 !== _a && _a,
      size: targetItem.size
    }, targetItem.style)), this._targetItem.states = merge({}, DEFAULT_STATES, null === (_b = this.attribute.state) || void 0 === _b ? void 0 : _b.targetItem));
  }
  setAllOfItemsAttr(newPosition, newItemPosition) {
    var _a;
    const { position, itemLine = {}, itemContent = {}, limitRect, targetSymbol } = this.attribute, { type = "text", confine } = itemContent;
    if (limitRect && confine) {
      const { x, y, width, height } = limitRect, { dx, dy } = computeOffsetForlimit(this._item, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
      newItemPosition.x = newItemPosition.x + dx, newItemPosition.y = newItemPosition.y + dy;
    }
    this.setTargetItemAttributes(targetSymbol, position), this.setItemLineAttr(itemLine, newPosition, newItemPosition), this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setDecorativeLineAttr(itemLine, newItemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
  }
  computeNewPositionAfterTargetItem(position) {
    var _a, _b;
    const { itemContent = {}, targetSymbol, itemLine } = this.attribute, { offsetX: itemContentOffsetX = 0, offsetY: itemContentOffsetY = 0 } = itemContent, { offset: targetSymbolOffset = 0, style: targetSymbolStyle, visible: targetItemvisible = false, size: targetSymbolSize } = targetSymbol, targetSize = targetItemvisible ? null !== (_b = null !== (_a = targetSymbolStyle.size) && void 0 !== _a ? _a : targetSymbolSize) && void 0 !== _b ? _b : 20 : 0;
    let targetOffsetAngle;
    targetOffsetAngle = "type-do" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, itemContentOffsetX / 2) : "type-po" === itemLine.type ? deltaXYToAngle(0, itemContentOffsetX) : "type-op" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, 0) : deltaXYToAngle(itemContentOffsetY, itemContentOffsetX);
    return {
      newPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle),
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle)
      },
      newItemPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle) + itemContentOffsetX,
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle) + itemContentOffsetY
      }
    };
  }
  initMarker(container2) {
    const { position, itemContent = {}, itemLine } = this.attribute, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine;
    const { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position), line = new (this._isArcLine ? ArcSegment : Segment)({
      points: [],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    });
    line.name = "mark-point-line", this._line = line, container2.add(line);
    const decorativeLine = graphicCreator.line({
      points: []
    });
    decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, container2.add(decorativeLine);
    const targetItem = graphicCreator.symbol({});
    targetItem.name = "mark-point-targetItem", this._targetItem = targetItem, container2.add(this._targetItem);
    const item = this.initItem(itemContent, newPosition, newItemPosition);
    this._item = item, container2.add(item), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  updateMarker() {
    const { position, itemContent = {}, itemLine } = this.attribute, { type = "text" } = itemContent, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
    const isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine, { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position);
    isArcLine !== this._isArcLine ? (this._isArcLine = isArcLine, this.reDrawLine(itemLine, {
      points: [{
        x: 0,
        y: 0
      }],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    })) : this._isArcLine = isArcLine, this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  isValidPoints() {
    const { position } = this.attribute;
    return !(!isValidNumber_default(position.x) || !isValidNumber_default(position.y));
  }
};
MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/pager/register.js
function loadPagerComponent() {
  registerGroup(), registerSymbol(), registerText();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/pager/pager.js
var DEFAULT_HANDLER_STYLE = {
  space: 8,
  style: {
    fill: "rgb(47, 69, 84)",
    cursor: "pointer",
    size: 15
  },
  state: {
    disable: {
      fill: "rgb(170, 170, 170)",
      cursor: "not-allowed"
    },
    hover: {}
  }
};
loadPagerComponent();
var Pager = class _Pager extends AbstractComponent {
  getCurrent() {
    return this._current;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Pager.defaultAttributes, attributes)), this.name = "pager", this._current = 1, this._onHover = (e) => {
      const target = e.target;
      target.hasState("disable") || target.addState("hover");
    }, this._onUnHover = (e) => {
      e.target.removeState("hover");
    }, this._onClick = (e) => {
      const target = e.target;
      if ("preHandler" === target.name) {
        if (1 === this._current) return;
        this._current -= 1, 1 === this._current ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toPrev", {
          current: this._current,
          total: this._total,
          direction: "pre",
          event: e
        });
      }
      if ("nextHandler" === target.name) {
        if (this._current === this._total) return;
        this._current += 1, this._current === this._total ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toNext", {
          current: this._current,
          total: this._total,
          direction: "next",
          event: e
        });
      }
      this._current > 1 && this.preHandler.removeState("disable"), this._current < this._total && this.nextHandler.removeState("disable"), this.text.setAttribute("text", this._getPageText(this._current));
    };
  }
  render() {
    var _a, _b, _c;
    this._reset();
    const { layout = "horizontal", handler = DEFAULT_HANDLER_STYLE, total, defaultCurrent = 1, textStyle, padding = 0 } = this.attribute;
    this._current = defaultCurrent;
    const parsedPadding = normalizePadding(padding), isHorizontal2 = "horizontal" === layout, container2 = graphicCreator.group({
      x: 0,
      y: 0
    }), handlerStyle = handler.style || {}, handlerSize = handlerStyle.size || 15, handlerSpace = null !== (_a = handler.space) && void 0 !== _a ? _a : 8, handlerState = handler.state || {};
    let { preShape, nextShape } = handler;
    preShape || (preShape = isHorizontal2 ? "triangleLeft" : "triangleUp"), nextShape || (nextShape = isHorizontal2 ? "triangleRight" : "triangleDown");
    const preHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: 0,
      y: 0,
      symbolType: preShape,
      size: handlerSize
    }));
    preHandler.states = handlerState, preHandler.name = "preHandler", this.preHandler = preHandler, container2.add(preHandler);
    const { width: maxTextWidth, height: maxTextHeight } = measureTextSize(this._getPageText(total), Object.assign({
      textAlign: "center",
      textBaseline: "middle"
    }, textStyle), null === (_c = null === (_b = this.stage) || void 0 === _b ? void 0 : _b.getTheme()) || void 0 === _c ? void 0 : _c.text), handlerSizeX = isNumber_default(handlerSize) ? handlerSize : handlerSize[0], handlerSizeY = isNumber_default(handlerSize) ? handlerSize : handlerSize[1], text2 = graphicCreator.text(Object.assign({
      x: isHorizontal2 ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0,
      y: isHorizontal2 ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2,
      text: this._getPageText(defaultCurrent),
      textAlign: "center",
      textBaseline: "middle",
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize
    }, textStyle));
    this.text = text2, container2.add(text2);
    const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: isHorizontal2 ? handlerSizeX + 2 * handlerSpace + maxTextWidth : 0,
      y: isHorizontal2 ? 0 : handlerSizeY + 2 * handlerSpace + maxTextHeight,
      symbolType: nextShape,
      size: handlerSize
    }));
    nextHandler.name = "nextHandler", nextHandler.states = handlerState, this.nextHandler = nextHandler, container2.add(nextHandler), 1 === this._total ? (preHandler.addState("disable"), nextHandler.addState("disable")) : 1 === this._current ? preHandler.addState("disable") : this._current === total && nextHandler.addState("disable");
    const containerBounds = container2.AABBBounds, width = containerBounds.width(), height = containerBounds.height();
    container2.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]), this.add(container2), this.attribute.width = width + parsedPadding[1] + parsedPadding[3], this.attribute.height = height + parsedPadding[0] + parsedPadding[2], this._bindEvents();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || (this.preHandler && (this.preHandler.addEventListener("pointerenter", this._onHover), this.preHandler.addEventListener("pointerleave", this._onUnHover), this.preHandler.addEventListener("pointerdown", this._onClick)), this.nextHandler && (this.nextHandler.addEventListener("pointerenter", this._onHover), this.nextHandler.addEventListener("pointerleave", this._onUnHover), this.nextHandler.addEventListener("pointerdown", this._onClick)));
  }
  _reset() {
    this.removeAllChild(true), this._current = 1, this._total = this.attribute.total, this.preHandler = this.nextHandler = this.text = null;
  }
  _getPageText(current) {
    const { pageFormatter } = this.attribute;
    return pageFormatter ? isFunction_default(pageFormatter) ? pageFormatter(current, this._total) : `${pageFormatter}`.replace("{current}", `${current}`).replace("{total}", `${this._total}`) : `${current}/${this._total}`;
  }
  setTotal(total) {
    total !== this.attribute.total && (this._total = total, 1 !== this._current && this._current <= total ? this.setAttributes({
      total,
      defaultCurrent: this._current
    }) : this.setAttribute("total", total));
  }
};
Pager.defaultAttributes = {
  handler: DEFAULT_HANDLER_STYLE,
  textStyle: {
    fill: "rgb(51, 51, 51)",
    fontSize: 12
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/constant.js
var DEFAULT_SHAPE_SIZE = 10;
var DEFAULT_SHAPE_SPACE = 8;
var DEFAULT_LABEL_SPACE = 8;
var DEFAULT_VALUE_SPACE = 8;
var DEFAULT_ITEM_SPACE_COL = 16;
var DEFAULT_ITEM_SPACE_ROW = 8;
var DEFAULT_TITLE_SPACE = 12;
var DEFAULT_PAGER_SPACE = 12;
var LegendStateValue;
!function(LegendStateValue2) {
  LegendStateValue2.selected = "selected", LegendStateValue2.unSelected = "unSelected", LegendStateValue2.selectedHover = "selectedHover", LegendStateValue2.unSelectedHover = "unSelectedHover", LegendStateValue2.focus = "focus";
}(LegendStateValue || (LegendStateValue = {}));
var LegendEvent;
!function(LegendEvent2) {
  LegendEvent2.legendItemHover = "legendItemHover", LegendEvent2.legendItemUnHover = "legendItemUnHover", LegendEvent2.legendItemClick = "legendItemClick", LegendEvent2.legendItemAttributeUpdate = "legendItemAttributeUpdate";
}(LegendEvent || (LegendEvent = {}));
var LEGEND_ELEMENT_NAME;
!function(LEGEND_ELEMENT_NAME2) {
  LEGEND_ELEMENT_NAME2.innerView = "innerView", LEGEND_ELEMENT_NAME2.title = "legendTitle", LEGEND_ELEMENT_NAME2.item = "legendItem", LEGEND_ELEMENT_NAME2.itemShape = "legendItemShape", LEGEND_ELEMENT_NAME2.itemLabel = "legendItemLabel", LEGEND_ELEMENT_NAME2.itemValue = "legendItemValue", LEGEND_ELEMENT_NAME2.focus = "legendItemFocus";
}(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/base.js
var LegendBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "legend", this._title = null;
  }
  render() {
    this.removeAllChild(true);
    const { interactive = true, title, padding = 0 } = this.attribute;
    this._parsedPadding = normalizePadding(padding);
    const innerView = graphicCreator.group({
      x: this._parsedPadding[3],
      y: this._parsedPadding[0],
      pickable: interactive,
      childrenPickable: interactive
    });
    innerView.name = LEGEND_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView, (null == title ? void 0 : title.visible) && this._renderTitle(title), this._renderContent(), this._adjustLayout(), interactive && this._bindEvents();
    const viewBounds = this._innerView.AABBBounds;
    this.attribute.width = viewBounds.width() + this._parsedPadding[1] + this._parsedPadding[3], this.attribute.height = viewBounds.height() + this._parsedPadding[0] + this._parsedPadding[2];
  }
  _renderTitle(title) {
    const { text: text2 = "", textStyle, padding = 0, background, minWidth, maxWidth, shape } = title, tagAttrs = {
      x: 0,
      y: 0,
      text: text2,
      textStyle,
      padding: normalizePadding(padding),
      minWidth,
      maxWidth
    };
    shape && shape.visible && (tagAttrs.shape = Object.assign({
      visible: true
    }, shape.style), isValid_default(shape.space) && (tagAttrs.space = shape.space)), background && background.visible && (tagAttrs.panel = Object.assign({
      visible: true
    }, background.style));
    const titleTag = new Tag(tagAttrs);
    titleTag.name = LEGEND_ELEMENT_NAME.title, this._title = titleTag, this._innerView.add(titleTag);
  }
  _adjustLayout() {
    var _a;
    if (this._title) {
      const innerViewWidth = this._innerView.AABBBounds.width(), titleWidth = this._title.AABBBounds.width(), align = null === (_a = this.attribute.title) || void 0 === _a ? void 0 : _a.align;
      "center" === align ? this._title.setAttribute("x", (innerViewWidth - titleWidth) / 2) : "end" === align && this._title.setAttribute("x", innerViewWidth - titleWidth);
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/slider/register.js
function loadSliderComponent() {
  registerGroup(), registerText(), registerRect(), registerSymbol();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/register.js
function loadBaseLegend() {
  registerGroup(), loadTagComponent();
}
function loadDiscreteLegendComponent() {
  loadBaseLegend(), loadPagerComponent(), loadScrollbarComponent();
}
function loadColorContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent();
}
function loadSizeContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent(), registerPath();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/discrete/discrete.js
var __rest14 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var DEFAULT_STATES3 = {
  [LegendStateValue.focus]: {},
  [LegendStateValue.selected]: {},
  [LegendStateValue.selectedHover]: {},
  [LegendStateValue.unSelected]: {},
  [LegendStateValue.unSelectedHover]: {}
};
loadDiscreteLegendComponent();
var DiscreteLegend = class _DiscreteLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DiscreteLegend.defaultAttributes, attributes)), this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, this._itemHeight = 0, this._itemMaxWidth = 0, this._contentMaxHeight = 0, this._onHover = (e) => {
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate;
        if (this._lastActiveItem) {
          if (this._lastActiveItem.id === legendItem.id) return;
          this._unHover(this._lastActiveItem, e);
        }
        this._hover(legendItem, e);
      } else this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onUnHover = (e) => {
      this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onClick = (e) => {
      var _a, _b, _c, _d;
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate, { selectMode = "multiple" } = this.attribute;
        if (target.name === LEGEND_ELEMENT_NAME.focus || "focus" === selectMode) {
          const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
          legendItem.toggleState(LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
            this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.selected, e);
          }) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
          }));
        } else {
          null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach((item) => {
            item.removeState(LegendStateValue.focus);
          });
          const { allowAllCanceled = true } = this.attribute, isSelected = legendItem.hasState(LegendStateValue.selected), currentSelectedItems = this._getSelectedLegends();
          if ("multiple" === selectMode) {
            if (false === allowAllCanceled && isSelected && 1 === currentSelectedItems.length) return void this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
            isSelected ? (this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(legendItem, LegendStateValue.unSelected, e)) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e));
          } else this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
          });
        }
        this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
      }
    };
  }
  render() {
    super.render(), this._lastActiveItem = null;
  }
  setSelected(selectedData) {
    var _a;
    (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach((item) => {
      const itemData = item.data;
      selectedData.includes(itemData.label) ? (this._setLegendItemState(item, LegendStateValue.selected), this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover])) : (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]), this._setLegendItemState(item, LegendStateValue.unSelected));
    });
  }
  _renderItems() {
    const { item: itemAttrs = {}, maxCol = 1, maxRow = 2, maxWidth, defaultSelected, lazyload, autoPage } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW, verticalAlign = "middle" } = itemAttrs, itemsContainer = this._itemsContainer, { items: legendItems, isHorizontal: isHorizontal2, startIndex, isScrollbar } = this._itemContext, maxPages = isScrollbar ? 1 : isHorizontal2 ? maxRow : maxCol, maxHeight = this._contentMaxHeight;
    let item, { doWrap, maxWidthInCol, startX, startY, pages } = this._itemContext, lastItemWidth = 0, lastLineHeight = 0;
    const lastLineItemGroup = [];
    for (let index = startIndex, len = legendItems.length; index < len && !(lazyload && pages > this._itemContext.currentPage * maxPages); index++) {
      lazyload && (this._itemContext.startIndex = index + 1), item = legendItems[index], item.id || (item.id = item.label), item.index = index;
      let isSelected = true;
      isArray_default(defaultSelected) && (isSelected = defaultSelected.includes(item.label));
      const itemGroup = this._renderEachItem(item, isSelected, index, legendItems), itemWidth = itemGroup.attribute.width, itemHeight = itemGroup.attribute.height;
      this._itemHeight = Math.max(this._itemHeight, itemHeight), maxWidthInCol = Math.max(itemWidth, maxWidthInCol), this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth), isHorizontal2 ? (isValid_default(maxWidth) && (isScrollbar && autoPage ? (pages = Math.ceil((startX + itemWidth) / maxWidth), doWrap = pages > 1) : startX + itemWidth > maxWidth && (doWrap = true, startX > 0 && ("middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach((i) => {
        i.setAttributes({
          y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
        });
      }), pages += 1, startX = 0, startY += lastLineHeight + spaceRow, lastLineHeight = 0, lastLineItemGroup.length = 0))), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startX += spaceCol + itemWidth, lastLineHeight = Math.max(lastLineHeight, itemHeight), lastLineItemGroup.push(itemGroup)) : (isValid_default(maxHeight) && (isScrollbar && autoPage ? (pages = Math.ceil((startY + itemHeight) / maxHeight), doWrap = pages > 1) : maxHeight <= itemHeight ? (pages += 1, doWrap = true, startY = 0, index > 0 && (startX += lastItemWidth + spaceCol)) : maxHeight < startY + itemHeight && (pages += 1, doWrap = true, startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0)), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startY += spaceRow + itemHeight), itemsContainer.add(itemGroup), lastItemWidth = itemWidth;
    }
    return !isHorizontal2 || "middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach((i) => {
      i.setAttributes({
        y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
      });
    }), this._itemContext.doWrap = doWrap, this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.maxWidthInCol = maxWidthInCol, this._itemContext.pages = pages, this._itemContext.maxPages = maxPages, isScrollbar && (this._itemContext.totalPage = pages), lazyload || (this._itemContext.startIndex = legendItems.length), this._itemContext;
  }
  _renderContent() {
    const { item = {}, items, reversed, maxWidth, maxHeight } = this.attribute;
    if (false === item.visible || isEmpty_default(items)) return;
    let legendItems = items;
    reversed && (legendItems = null == items ? void 0 : items.reverse()), this._contentMaxHeight = Math.max(0, maxHeight - this._parsedPadding[0] - this._parsedPadding[2]);
    const itemsContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._itemsContainer = itemsContainer;
    const { layout, autoPage } = this.attribute, isHorizontal2 = "horizontal" === layout, { maxWidth: maxItemWidth, width: itemWidth, height: itemHeight } = item, widthsOptions = [];
    isValid_default(maxItemWidth) && widthsOptions.push(maxItemWidth), isValid_default(itemWidth) && widthsOptions.push(itemWidth), widthsOptions.length && (isValid_default(maxWidth) && widthsOptions.push(maxWidth), this._itemWidthByUser = minInArray(widthsOptions)), isValid_default(itemHeight) && (this._itemHeightByUser = itemHeight);
    const pager = this.attribute.pager;
    this._itemContext = {
      currentPage: pager && pager.defaultCurrent || 1,
      doWrap: false,
      maxWidthInCol: 0,
      maxPages: 1,
      pages: 1,
      startX: 0,
      startY: 0,
      startIndex: 0,
      items: legendItems,
      isHorizontal: isHorizontal2,
      totalPage: 1 / 0,
      isScrollbar: pager && "scrollbar" === pager.type,
      clipContainer: void 0
    }, this._itemContext = this._renderItems();
    let pagerRendered = false;
    this._itemContext.doWrap && autoPage && this._itemContext.pages > this._itemContext.maxPages && (pagerRendered = this._renderPagerComponent()), pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    if (!this._itemsContainer) return;
    const { hover = true, select = true } = this.attribute;
    if (hover) {
      let trigger = "pointermove", triggerOff = "pointerleave";
      isObject_default(hover) && (hover.trigger && (trigger = hover.trigger), hover.triggerOff && (triggerOff = hover.triggerOff)), this._itemsContainer.addEventListener(trigger, this._onHover), this._itemsContainer.addEventListener(triggerOff, this._onUnHover);
    }
    if (select) {
      let trigger = "pointerdown";
      isObject_default(select) && select.trigger && (trigger = select.trigger), this._itemsContainer.addEventListener(trigger, this._onClick);
    }
  }
  _autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape) {
    var _a, _b;
    const { label: labelAttr, value: valueAttr } = this.attribute.item, valueBounds = valueShape.AABBBounds, labelBounds = labelShape.AABBBounds, valueWidth = valueBounds.width(), labelWidth = labelBounds.width();
    let useWidthRatio = false;
    "labelFirst" === autoEllipsisStrategy ? labelWidth > layoutWidth ? useWidthRatio = true : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth) : "valueFirst" === autoEllipsisStrategy ? valueWidth > layoutWidth ? useWidthRatio = true : labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : valueWidth + labelWidth > layoutWidth && (useWidthRatio = true), useWidthRatio && (valueShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_a = labelAttr.widthRatio) && void 0 !== _a ? _a : 0.5), layoutWidth - labelWidth)), labelShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_b = valueAttr.widthRatio) && void 0 !== _b ? _b : 0.5), layoutWidth - valueWidth)));
  }
  _renderEachItem(item, isSelected, index, items) {
    var _a, _b;
    const { id, label, value, shape } = item, { padding = 0, focus, focusIconStyle, align, autoEllipsisStrategy } = this.attribute.item, { shape: shapeAttr, label: labelAttr, value: valueAttr, background } = this.attribute.item, shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items), labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items), valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items), backgroundStyle = this._handleStyle(background, item, isSelected, index, items), parsedPadding = normalizePadding(padding);
    let itemGroup;
    false === background.visible ? (itemGroup = graphicCreator.group({
      x: 0,
      y: 0,
      cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
    }), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = graphicCreator.group(Object.assign({
      x: 0,
      y: 0
    }, backgroundStyle.style)), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), itemGroup.id = `${null != id ? id : label}-${index}`, itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
    const innerGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    itemGroup.add(innerGroup);
    let focusShape, focusStartX = 0, shapeSize = 0, shapeSpace = 0;
    if (shapeAttr && false !== shapeAttr.visible) {
      const s2 = get_default(shapeStyle, "style.size", DEFAULT_SHAPE_SIZE);
      shapeSize = isArray_default(s2) ? s2[0] || 0 : s2, shapeSpace = get_default(shapeAttr, "space", DEFAULT_SHAPE_SPACE);
      const itemShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: 0,
        symbolType: "circle",
        strokeBoundsBuffer: 0
      }, shape), shapeStyle.style));
      Object.keys(shapeStyle.state || {}).forEach((key) => {
        const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
        shape.fill && isNil_default(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), shape.stroke && isNil_default(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
      }), this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(itemShape);
    }
    let focusSpace = 0;
    if (focus) {
      const focusSize = get_default(focusIconStyle, "size", DEFAULT_SHAPE_SIZE);
      focusShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: -focusSize / 2 - 1,
        strokeBoundsBuffer: 0,
        boundsPadding: parsedPadding
      }, focusIconStyle), {
        visible: true,
        pickMode: "imprecise"
      })), this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup), focusSpace = focusSize;
    }
    const text2 = labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label, labelAttributes = Object.assign(Object.assign({
      x: shapeSize / 2 + shapeSpace,
      y: 0,
      textAlign: "start",
      textBaseline: "middle",
      lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
    }, labelStyle.style), {
      text: text2,
      _originText: labelAttr.formatMethod ? label : void 0
    }), labelShape = createTextGraphicByType(labelAttributes);
    this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(labelShape);
    const labelSpace = get_default(labelAttr, "space", DEFAULT_LABEL_SPACE);
    if (isValid_default(value)) {
      const valueSpace = get_default(valueAttr, "space", focus ? DEFAULT_VALUE_SPACE : 0), valueText = valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value, valueAttributes = Object.assign(Object.assign({
        x: 0,
        y: 0,
        textAlign: "start",
        textBaseline: "middle",
        lineHeight: valueStyle.style.fontSize
      }, valueStyle.style), {
        text: valueText,
        _originText: valueAttr.formatMethod ? value : void 0
      }), valueShape = createTextGraphicByType(valueAttributes);
      if (this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), this._itemWidthByUser) {
        const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace;
        this._autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape), valueAttr.alignRight ? valueShape.setAttributes({
          textAlign: "right",
          x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
        }) : valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      } else valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      focusStartX = valueSpace + (valueShape.AABBBounds.empty() ? 0 : valueShape.AABBBounds.x2), innerGroup.add(valueShape);
    } else this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2)) : focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
    focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
    const innerGroupBounds = innerGroup.AABBBounds, innerGroupWidth = innerGroupBounds.width();
    if ("right" === align) {
      const x2 = innerGroupBounds.x2, x1 = innerGroupBounds.x1;
      innerGroup.forEachChildren((child, index2) => {
        "symbol" !== child.type && "right" !== child.attribute.textAlign || child === focusShape ? child.setAttribute("x", x1 + x2 - child.attribute.x - child.AABBBounds.width()) : "symbol" !== child.type ? child.setAttributes({
          x: x1 + x2 - child.attribute.x,
          textAlign: "left"
        }) : child.setAttribute("x", x1 + x2 - child.attribute.x);
      });
    }
    const innerGroupHeight = innerGroupBounds.height(), itemGroupWidth = isValid_default(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3], itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
    return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, focusShape && focusShape.setAttribute("visible", false), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), itemGroup;
  }
  _createPager(compStyle) {
    var _a, _b;
    const { disableTriggerEvent, maxRow } = this.attribute, estimateTotal = (num) => num <= 99 ? 99 : num <= 999 ? 999 : 9999;
    return this._itemContext.isHorizontal ? new Pager(Object.assign(Object.assign({
      layout: 1 === maxRow ? "horizontal" : "vertical",
      total: estimateTotal(this._itemContext.pages)
    }, merge({
      handler: {
        preShape: "triangleUp",
        nextShape: "triangleDown"
      }
    }, compStyle)), {
      defaultCurrent: null === (_a = this.attribute.pager) || void 0 === _a ? void 0 : _a.defaultCurrent,
      disableTriggerEvent
    })) : new Pager(Object.assign({
      layout: "horizontal",
      total: estimateTotal(this._itemContext.pages),
      disableTriggerEvent,
      defaultCurrent: null === (_b = this.attribute.pager) || void 0 === _b ? void 0 : _b.defaultCurrent
    }, compStyle));
  }
  _createScrollbar(compStyle, compSize) {
    const { disableTriggerEvent } = this.attribute;
    return this._itemContext.isHorizontal ? new ScrollBar(Object.assign(Object.assign({
      direction: "horizontal",
      disableTriggerEvent,
      range: [0, 0.5],
      height: false === compStyle.visible ? 0 : 12
    }, compStyle), {
      width: compSize
    })) : new ScrollBar(Object.assign(Object.assign({
      direction: "vertical",
      width: false === compStyle.visible ? 0 : 12,
      range: [0, 0.5]
    }, compStyle), {
      height: compSize,
      disableTriggerEvent
    }));
  }
  _updatePositionOfPager(renderStartY, compWidth, compHeight) {
    const { pager } = this.attribute, { totalPage, isHorizontal: isHorizontal2 } = this._itemContext, position = pager && pager.position || "middle";
    if (this._pagerComponent.setTotal(totalPage), isHorizontal2) {
      let y;
      y = "start" === position ? renderStartY : "end" === position ? renderStartY + compHeight - this._pagerComponent.AABBBounds.height() / 2 : renderStartY + compHeight / 2 - this._pagerComponent.AABBBounds.height() / 2, this._pagerComponent.setAttributes({
        x: compWidth - this._pagerComponent.AABBBounds.width(),
        y
      });
    } else {
      let x;
      x = "start" === position ? 0 : "end" === position ? compWidth - this._pagerComponent.AABBBounds.width() : (compWidth - this._pagerComponent.AABBBounds.width()) / 2, this._pagerComponent.setAttributes({
        x,
        y: compHeight - this._pagerComponent.AABBBounds.height()
      });
    }
  }
  _computeScrollbarDelta() {
    const { isHorizontal: isHorizontal2, clipContainer } = this._itemContext, itemContainerBounds = this._itemsContainer.AABBBounds, clipContainerBounds = clipContainer.AABBBounds;
    let delta, innerViewSize;
    return isHorizontal2 ? (innerViewSize = clipContainerBounds.width(), delta = innerViewSize / itemContainerBounds.width()) : (innerViewSize = clipContainerBounds.height(), delta = innerViewSize / itemContainerBounds.height()), delta;
  }
  _updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY) {
    const { isHorizontal: isHorizontal2, currentPage, totalPage } = this._itemContext, start = (currentPage - 1) / totalPage;
    this._pagerComponent.setScrollRange([start, start + this._computeScrollbarDelta()]), isHorizontal2 ? this._pagerComponent.setAttributes({
      x: 0,
      y: renderStartY + contentHeight
    }) : this._pagerComponent.setAttributes({
      x: contentWidth,
      y: renderStartY
    });
  }
  _bindEventsOfPager(pageSize, channel) {
    const pager = this.attribute.pager || {}, { animation = true, animationDuration = 450, animationEasing = "quadIn" } = pager, pageParser = this._itemContext.isScrollbar ? (e) => {
      const { value } = e.detail;
      let newPage;
      return newPage = 0 === value[0] ? 1 : 1 === value[1] ? this._itemContext.totalPage : value[0] * this._itemContext.totalPage + 1, newPage;
    } : (e) => e.detail.current, onScroll = (e) => {
      const scrollComponent = this._pagerComponent, preScrollRange = scrollComponent.getScrollRange(), { direction } = scrollComponent.attribute, { width, height } = scrollComponent.getSliderRenderBounds(), currentScrollValue = "vertical" === direction ? e.deltaY / height : e.deltaX / width;
      scrollComponent.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this.updateScrollMask();
    }, onPaging = (e) => {
      const newPage = pageParser(e);
      if (newPage !== this._itemContext.currentPage) {
        if (this._itemContext.currentPage = newPage, this._itemContext && this._itemContext.startIndex < this._itemContext.items.length) {
          this._renderItems();
          const newTotalPage = Math.ceil(this._itemContext.pages / this._itemContext.maxPages);
          if (this._itemContext.totalPage = newTotalPage, this._itemContext.isScrollbar && this._pagerComponent) {
            const newDelta = this._computeScrollbarDelta(), [start] = this._pagerComponent.getScrollRange();
            this._pagerComponent.setScrollRange([start, start + newDelta]);
          }
        }
        if (this._itemContext.isScrollbar) {
          const [start] = this._pagerComponent.getScrollRange();
          let containerSize;
          containerSize = this._itemContext.isHorizontal ? this._itemsContainer.AABBBounds.width() : this._itemsContainer.AABBBounds.height();
          const startOffset = containerSize * start;
          this.updateScrollMask(), animation ? this._itemsContainer.animate().to({
            [channel]: -startOffset
          }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -startOffset);
        } else animation ? this._itemsContainer.animate().to({
          [channel]: -(newPage - 1) * pageSize
        }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -(newPage - 1) * pageSize);
      }
    };
    if (this._itemContext.isScrollbar) {
      if (this._pagerComponent.addEventListener("scrollDrag", onPaging), this._pagerComponent.addEventListener("scrollUp", onPaging), this.attribute.pager.roamScroll) {
        const THROTTLE_TIME = 50;
        this.addEventListener("wheel", (e) => e.nativeEvent.preventDefault()), this.addEventListener("wheel", throttle_default(onScroll, THROTTLE_TIME));
      }
    } else this._pagerComponent.addEventListener("toPrev", onPaging), this._pagerComponent.addEventListener("toNext", onPaging);
  }
  _renderPager() {
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, maxCol = 1, maxRow = 2, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest14(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal2 } = this._itemContext, maxHeight = this._contentMaxHeight;
    let comp, compWidth = 0, compHeight = 0, contentWidth = 0, contentHeight = 0, startX = 0, startY = 0, pages = 1;
    if (isHorizontal2) {
      if (compHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, compWidth = maxWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentWidth = maxWidth - comp.AABBBounds.width() - pagerSpace, contentWidth <= 0) return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { width, height } = item2.attribute;
        contentWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startX += spaceCol + width;
      }), this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.pages = pages;
      const total = Math.ceil(pages / maxRow);
      this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
    } else {
      if (compWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, compHeight = maxHeight, contentWidth = compWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentHeight = maxHeight - comp.AABBBounds.height() - pagerSpace - renderStartY, contentHeight <= 0) return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { height } = item2.attribute;
        contentHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startY += spaceRow + height;
      });
      const total = Math.ceil(pages / maxCol);
      this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
    }
    defaultCurrent > 1 && (isHorizontal2 ? itemsContainer.setAttribute("y", -(defaultCurrent - 1) * (compHeight + spaceRow)) : itemsContainer.setAttribute("x", -(defaultCurrent - 1) * (compWidth + spaceCol)));
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: isHorizontal2 ? contentWidth : compWidth,
      height: isHorizontal2 ? compHeight : contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._bindEventsOfPager(isHorizontal2 ? compHeight + spaceRow : compWidth + spaceCol, isHorizontal2 ? "y" : "x"), true;
  }
  _renderScrollbar() {
    var _a;
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest14(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal2 } = this._itemContext, maxHeight = this._contentMaxHeight;
    let comp, contentWidth = 0, contentHeight = 0, startY = 0, pages = 1;
    if (isHorizontal2) contentWidth = maxWidth, contentHeight = this._itemHeight, comp = this._createScrollbar(compStyle, contentWidth), this._pagerComponent = comp, this._innerView.add(comp);
    else {
      if (contentHeight = maxHeight - renderStartY, contentWidth = this._itemMaxWidth, comp = this._createScrollbar(compStyle, contentHeight), this._pagerComponent = comp, this._innerView.add(comp), contentHeight <= 0) return this._innerView.removeChild(comp), false;
      const items = itemsContainer.getChildren(), itemsHeightArr = items.map((item2) => item2.attribute.height);
      if (1 === itemsHeightArr.length || itemsHeightArr.every((entry) => entry === itemsHeightArr[0])) {
        const itemHeight = itemsHeightArr[0], maxContentHeight = contentHeight, pageItemsCount = Math.floor(maxContentHeight / (spaceRow + itemHeight));
        contentHeight = pageItemsCount * (spaceRow + itemHeight), pages = Math.ceil(items.length / pageItemsCount);
      } else items.forEach((item2, index) => {
        const { height } = item2.attribute, prePages = pages, preStartY = startY;
        pages = Math.floor((startY + height) / contentHeight) + 1, startY += spaceRow + height, prePages !== pages && index === itemsContainer.getChildren().length - 1 && startY - contentHeight >= 1 / 3 * height && (contentHeight = preStartY + height, pages -= 1);
      });
      this._itemContext.totalPage = pages, this._itemContext.pages = pages;
    }
    if (defaultCurrent > 1) if (isHorizontal2) {
      const maxOffset = this._itemsContainer.AABBBounds.width() - contentWidth;
      itemsContainer.setAttribute("x", -Math.min((defaultCurrent - 1) * (contentWidth + spaceCol), maxOffset));
    } else {
      const maxOffset = this._itemsContainer.AABBBounds.height() - contentHeight;
      itemsContainer.setAttribute("y", -Math.min((defaultCurrent - 1) * (contentHeight + spaceRow), maxOffset));
    }
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: contentWidth,
      height: contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY), (null === (_a = pager.scrollMask) || void 0 === _a ? void 0 : _a.visible) && this.renderScrollMask(clipGroup), this._bindEventsOfPager(isHorizontal2 ? contentWidth : contentHeight, isHorizontal2 ? "x" : "y"), true;
  }
  renderScrollMask(clipGroup) {
    const { scrollMask = {} } = this.attribute.pager, { visible = true, gradientLength = 16, gradientStops } = scrollMask;
    if (!visible || !gradientStops) return;
    const width = clipGroup.AABBBounds.width(), height = clipGroup.AABBBounds.height(), totalLength = this._itemContext.isHorizontal ? width : height, startStops = gradientStops.map((stop) => ({
      offset: gradientLength * stop.offset / totalLength,
      color: stop.color
    })), endStops = gradientStops.map((stop) => ({
      offset: (totalLength - gradientLength * stop.offset) / totalLength,
      color: stop.color
    })), mask = graphicCreator.rect({
      x: 0,
      y: 0,
      width,
      height
    });
    this._scrollMask = mask, this._scrollMaskContext = {
      startStops,
      endStops
    }, this.updateScrollMask(), clipGroup.add(mask);
  }
  updateScrollMask() {
    if (!this._scrollMask || !this._pagerComponent) return;
    if (!this._itemContext.isScrollbar) return;
    const [start, end] = this._pagerComponent.getScrollRange(), stops = [];
    isNumberClose(clamp_default(end, 0, 1), 1) || stops.push(...this._scrollMaskContext.endStops), isNumberClose(clamp_default(start, 0, 1), 0) || stops.push(...this._scrollMaskContext.startStops), stops.length && (this._itemContext.isHorizontal ? this._scrollMask.setAttributes({
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops
      }
    }) : this._scrollMask.setAttributes({
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 1,
        stops
      }
    }));
  }
  _renderPagerComponent() {
    return this._itemContext.isScrollbar ? this._renderScrollbar() : this._renderPager(), true;
  }
  _hover(legendItem, e) {
    this._lastActiveItem = legendItem;
    legendItem.hasState(LegendStateValue.selected) ? this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e) : this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e);
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", true), this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e);
  }
  _unHover(legendItem, e) {
    let attributeUpdate = false;
    (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) && (attributeUpdate = true), legendItem.removeState(LegendStateValue.unSelectedHover), legendItem.removeState(LegendStateValue.selectedHover), legendItem.getChildren()[0].getChildren().forEach((child) => {
      attributeUpdate || !child.hasState(LegendStateValue.unSelectedHover) && !child.hasState(LegendStateValue.selectedHover) || (attributeUpdate = true), child.removeState(LegendStateValue.unSelectedHover), child.removeState(LegendStateValue.selectedHover);
    });
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", false), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e), this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e);
  }
  _setLegendItemState(legendItem, stateName, e) {
    let attributeUpdate = false;
    legendItem.hasState(stateName) || (attributeUpdate = true), legendItem.addState(stateName, true), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = true), child.addState(stateName, true));
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _removeLegendItemState(legendItem, stateNames, e) {
    let attributeUpdate = false;
    stateNames.forEach((name) => {
      !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = true), legendItem.removeState(name);
    }), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && stateNames.forEach((name) => {
        !attributeUpdate && child.hasState(name) && (attributeUpdate = true), child.removeState(name);
      });
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _getSelectedLegends() {
    var _a;
    const selectedData = [];
    return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
      item.hasState(LegendStateValue.selected) && selectedData.push(item.data);
    }), selectedData;
  }
  _appendDataToShape(shape, name, data, delegateShape, states = {}) {
    shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = merge({}, DEFAULT_STATES3, states);
  }
  _dispatchLegendEvent(eventName, legendItem, event2) {
    const currentSelectedItems = this._getSelectedLegends();
    currentSelectedItems.sort((pre, next) => pre.index - next.index);
    const currentSelected = currentSelectedItems.map((obj2) => obj2.label);
    this._dispatchEvent(eventName, {
      item: legendItem,
      data: legendItem.data,
      selected: legendItem.hasState(LegendStateValue.selected),
      currentSelectedItems,
      currentSelected,
      event: event2
    });
  }
  _handleStyle(config, item, isSelected, index, items) {
    const newConfig = {};
    return config.style && (isFunction_default(config.style) ? newConfig.style = config.style(item, isSelected, index, items) : newConfig.style = config.style), config.state && (newConfig.state = {}, Object.keys(config.state).forEach((key) => {
      config.state[key] && (isFunction_default(config.state[key]) ? newConfig.state[key] = config.state[key](item, isSelected, index, items) : newConfig.state[key] = config.state[key]);
    })), newConfig;
  }
  release() {
    super.release(), this.removeAllEventListeners();
  }
};
DiscreteLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: DEFAULT_ITEM_SPACE_COL,
    spaceRow: DEFAULT_ITEM_SPACE_ROW,
    shape: {
      space: DEFAULT_SHAPE_SPACE,
      style: {
        size: DEFAULT_SHAPE_SIZE,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          opacity: 0.5
        }
      }
    },
    label: {
      space: DEFAULT_LABEL_SPACE,
      style: {
        fontSize: 12,
        fill: "#2C3542",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      }
    },
    focus: false,
    focusIconStyle: {
      size: DEFAULT_SHAPE_SIZE,
      symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
      fill: "#333",
      cursor: "pointer"
    }
  },
  autoPage: true,
  pager: {
    space: DEFAULT_PAGER_SPACE,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: true
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/slider/constant.js
var SLIDER_ELEMENT_NAME;
!function(SLIDER_ELEMENT_NAME2) {
  SLIDER_ELEMENT_NAME2.innerView = "innerView", SLIDER_ELEMENT_NAME2.railContainer = "sliderRailContainer", SLIDER_ELEMENT_NAME2.rail = "sliderRail", SLIDER_ELEMENT_NAME2.startText = "sliderStartText", SLIDER_ELEMENT_NAME2.endText = "sliderEndText", SLIDER_ELEMENT_NAME2.startHandler = "sliderStartHandler", SLIDER_ELEMENT_NAME2.startHandlerText = "startHandlerText", SLIDER_ELEMENT_NAME2.endHandler = "sliderEndHandler", SLIDER_ELEMENT_NAME2.endHandlerText = "sliderEndHandlerText", SLIDER_ELEMENT_NAME2.track = "sliderTrack", SLIDER_ELEMENT_NAME2.trackContainer = "sliderTrackContainer";
}(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/slider/slider.js
function convertValueToRange(value) {
  return isArray_default(value) ? value : [value, value];
}
function getDefaultCursor(isHorizontal2) {
  return isHorizontal2 ? "ew-resize" : "ns-resize";
}
loadSliderComponent();
var Slider = class _Slider extends AbstractComponent {
  get track() {
    return this._track;
  }
  get currentValue() {
    return this._currentValue;
  }
  get startHandler() {
    return this._startHandler;
  }
  get endHandler() {
    return this._endHandler;
  }
  get tooltipShape() {
    return this._tooltipShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Slider.defaultAttributes, attributes)), this.name = "slider", this._isHorizontal = true, this._startHandler = null, this._endHandler = null, this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, this._currentValue = {}, this._onTooltipShow = (e) => {
      this._isChanging || this._tooltipState && this._tooltipState.isActive || (this._tooltipState ? this._tooltipState.isActive = true : this._tooltipState = {
        isActive: true
      }, this._onTooltipUpdate(e), this._dispatchTooltipEvent("sliderTooltipShow"));
    }, this._onTooltipUpdate = (e) => {
      if (this._isChanging || !this._tooltipState || !this._tooltipState.isActive) return;
      const railLen = this._isHorizontal ? this._rail.globalAABBBounds.width() : this._rail.globalAABBBounds.height(), pos = clamp_default(this._isHorizontal ? (e.viewX - this._rail.globalAABBBounds.x1) / railLen : (e.viewY - this._rail.globalAABBBounds.y1) / railLen, 0, 1);
      pos !== this._tooltipState.pos && (this._tooltipState.pos = pos, this._tooltipState.value = this.calculateValueByPos(pos * railLen), this._updateTooltip(), this._dispatchTooltipEvent("sliderTooltipUpdate"));
    }, this._onTooltipHide = () => {
      const { tooltip } = this.attribute;
      tooltip && tooltip.alwaysShow || (this._tooltipState = null, this._tooltipShape && this._tooltipShape.setAttribute("visible", false), this._tooltipText && this._tooltipText.setAttribute("visible", false), this._dispatchTooltipEvent("sliderTooltipHide"));
    }, this._onHandlerPointerdown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._currentHandler = e.target, this._prePos = this._isHorizontal ? x : y;
      const triggers = getEndTriggersOfDrag(), obj2 = "browser" === vglobal.env ? vglobal : this.stage;
      obj2.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj2.addEventListener(trigger, this._onHandlerPointerUp);
      });
    }, this._onHandlerPointerMove = (e) => {
      var _a, _b;
      this._isChanging = true;
      const { railWidth, railHeight, min: min2, max: max2 } = this.attribute;
      if (max2 === min2) return;
      const { x, y } = this.stage.eventPointTransform(e);
      let currentPos, originPos, railLen, delta = 0;
      this._isHorizontal ? (currentPos = x, delta = currentPos - this._prePos, originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, railLen = railWidth) : (currentPos = y, delta = currentPos - this._prePos, originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, railLen = railHeight);
      const newPos = clamp_default(originPos + delta, 0, railLen), currentValue = this.calculateValueByPos(newPos);
      "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onHandlerPointerUp = (e) => {
      this._isChanging = false, this._currentHandler = null, this._clearAllDragEvents();
    }, this._handleTouchMove = (e) => {
      this._isChanging && e.preventDefault();
    }, this._onTrackPointerdown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._prePos = this._isHorizontal ? x : y;
      const triggers = getEndTriggersOfDrag(), obj2 = "browser" === vglobal.env ? vglobal : this.stage;
      obj2.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj2.addEventListener(trigger, this._onTrackPointerUp);
      });
    }, this._onTrackPointerMove = (e) => {
      this._isChanging = true;
      const { railWidth, railHeight, min: min2, max: max2, inverse } = this.attribute;
      if (max2 === min2) return;
      const { startHandler, endHandler } = this._getHandlers();
      let currentPos, trackLen, railLen;
      const { x, y } = this.stage.eventPointTransform(e);
      this._isHorizontal ? (currentPos = x, trackLen = this._track.attribute.width, railLen = railWidth) : (currentPos = y, trackLen = this._track.attribute.height, railLen = railHeight);
      const delta = currentPos - this._prePos;
      if (startHandler) {
        const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, trackLen, railLen) : clamp_default(originPos + delta, 0, railLen - trackLen), currentValue = this.calculateValueByPos(newPos);
        this._updateHandler(startHandler, newPos, currentValue);
      }
      if (endHandler) {
        const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, 0, railLen - trackLen) : clamp_default(originPos + delta, trackLen, railLen), currentValue = this.calculateValueByPos(newPos), startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
        this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
          x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
          width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
        } : {
          y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
          height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
        });
      }
      this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onTrackPointerUp = (e) => {
      this._isChanging = false, this._clearAllDragEvents();
    }, this._onRailPointerDown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { railWidth, railHeight, min: min2, max: max2 } = this.attribute;
      if (max2 === min2) return;
      const startHandler = this._startHandler, endHandler = this._endHandler;
      let currentPos, startHandlerPos, endHandlerPos, railLen;
      this._isHorizontal ? (currentPos = e.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railLen = railWidth) : (currentPos = e.viewY - this._rail.globalAABBBounds.y1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, railLen = railHeight);
      const currentValue = this.calculateValueByPos(currentPos);
      if (isValid_default(endHandlerPos)) {
        const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
        this._updateHandler(updateHandler, currentPos, currentValue);
      } else this._updateHandler(startHandler, currentPos, currentValue);
      this._updateTrack(), this._dispatchChangeEvent();
    };
  }
  calculatePosByValue(value, pos) {
    const { layout, railWidth, railHeight, min: min2, max: max2, inverse } = this.attribute;
    let ratio = 0;
    ratio = min2 === max2 ? "start" === pos ? 0 : "end" === pos ? 1 : 0 : (value - min2) / (max2 - min2);
    return (inverse ? 1 - ratio : ratio) * ("vertical" === layout ? railHeight : railWidth);
  }
  calculateValueByPos(pos) {
    const { layout, railWidth, railHeight, min: min2, max: max2, inverse } = this.attribute, railLen = "vertical" === layout ? railHeight : railWidth;
    return min2 + (max2 - min2) * (inverse ? 1 - pos / railLen : pos / railLen);
  }
  setValue(value) {
    const { min: min2, max: max2 } = this.attribute;
    if (max2 === min2) return;
    const [startValue, endValue] = array(value), { startHandler, endHandler } = this._getHandlers();
    startHandler && this._updateHandler(startHandler, this.calculatePosByValue(startValue), startValue), endHandler && this._updateHandler(endHandler, this.calculatePosByValue(endValue), endValue), this._updateTrack();
  }
  render() {
    var _a, _b;
    this.removeAllChild(true);
    const { layout = "horizontal", railWidth, railHeight, startText, endText, min: min2, max: max2, showHandler = true, showTooltip } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min2, max2]), this._currentValue = {
      startValue: convertValueToRange(value)[0],
      endValue: convertValueToRange(value)[1]
    };
    const isHorizontal2 = "horizontal" === layout;
    this._isHorizontal = isHorizontal2;
    const innerView = graphicCreator.group({
      x: 0,
      y: 0
    });
    innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
    let startTextShape, startLen = 0;
    if (startText && startText.visible) {
      startTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal2 ? 0 : railWidth / 2,
        y: isHorizontal2 ? railHeight / 2 : 0,
        textAlign: isHorizontal2 ? "start" : "center",
        textBaseline: isHorizontal2 ? "middle" : "top",
        text: startText.text,
        lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
      }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
      const space = isValid_default(startText.space) ? startText.space : 0;
      startLen += (isHorizontal2 ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
    }
    const mainContainer = graphicCreator.group({
      x: isHorizontal2 ? startLen : 0,
      y: isHorizontal2 ? 0 : startLen
    });
    innerView.add(mainContainer);
    const railContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    let endTextShape;
    if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, mainContainer.add(railContainer), this._mainContainer = mainContainer, this._renderRail(railContainer), startLen += isHorizontal2 ? railWidth : railHeight, endText && endText.visible) {
      const space = isValid_default(endText.space) ? endText.space : 0;
      endTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal2 ? startLen + space : railWidth / 2,
        y: isHorizontal2 ? railHeight / 2 : startLen + space,
        textAlign: isHorizontal2 ? "start" : "center",
        textBaseline: isHorizontal2 ? "middle" : "top",
        text: endText.text,
        lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
      }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
    }
    this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), this._bindEvents()), showTooltip && (this._renderTooltip(), this._bindTooltipEvents());
  }
  _renderRail(container2) {
    const { railWidth, railHeight, railStyle, slidable } = this.attribute;
    let cursor = "default";
    false !== slidable && (cursor = "pointer");
    const railShape = graphicCreator.rect(Object.assign({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cursor
    }, railStyle));
    return railShape.name = SLIDER_ELEMENT_NAME.rail, container2.add(railShape), this._rail = railShape, railShape;
  }
  _renderHandlers(container2) {
    const { range: range5, min: min2, max: max2, handlerSize = 14, handlerStyle, handlerText, railHeight, railWidth, slidable } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min2, max2]);
    const handlerTextVisible = handlerText && handlerText.visible, isHorizontal2 = this._isHorizontal, [startValue, endValue] = convertValueToRange(value), startPos = this.calculatePosByValue(startValue, range5 ? "start" : "end"), startHandler = this._renderHandler(Object.assign({
      x: isHorizontal2 ? startPos : railWidth / 2,
      y: isHorizontal2 ? railHeight / 2 : startPos,
      size: handlerSize,
      strokeBoundsBuffer: 0,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal2)
    }, handlerStyle));
    if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, container2.add(startHandler), this._currentValue.startPos = startPos, handlerTextVisible) {
      const startHandlerText = this._renderHandlerText(startValue, range5 ? "start" : "end");
      startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container2.add(startHandlerText), this._startHandlerText = startHandlerText;
    }
    if (range5) {
      const endPos = this.calculatePosByValue(endValue, "end"), endHandler = this._renderHandler(Object.assign({
        x: isHorizontal2 ? endPos : railWidth / 2,
        y: isHorizontal2 ? railHeight / 2 : endPos,
        size: handlerSize,
        strokeBoundsBuffer: 0,
        cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal2)
      }, handlerStyle));
      if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, container2.add(endHandler), this._currentValue.endPos = endPos, handlerTextVisible) {
        const endHandlerText = this._renderHandlerText(endValue, "end");
        endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container2.add(endHandlerText), this._endHandlerText = endHandlerText;
      }
    }
  }
  _renderTrack(container2) {
    const { range: range5, min: min2, max: max2, railHeight, railWidth, trackStyle, railStyle, slidable, value } = this.attribute;
    let startValue, endValue;
    if (isNil_default(value)) range5 ? (startValue = min2, endValue = max2) : startValue = endValue = min2;
    else if (range5) {
      const clampValue = clampRange_default(value, min2, max2);
      startValue = clampValue[0], endValue = clampValue[1];
    } else startValue = min2, endValue = clamp_default(value, min2, max2);
    const isHorizontal2 = this._isHorizontal;
    range5 || (startValue = min2);
    const trackContainer = graphicCreator.group({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
      clip: true,
      pickable: false
    });
    trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
    const draggableTrack = isObject_default(range5) && true === range5.draggableTrack;
    let cursor;
    cursor = false === slidable ? "default" : false === range5 || false === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal2);
    const startPos = this.calculatePosByValue(startValue, "start"), endPos = this.calculatePosByValue(endValue, range5 ? "end" : "start"), track = graphicCreator.rect(Object.assign({
      x: isHorizontal2 ? Math.min(startPos, endPos) : 0,
      y: isHorizontal2 ? 0 : Math.min(startPos, endPos),
      width: isHorizontal2 ? Math.abs(endPos - startPos) : railWidth,
      height: isHorizontal2 ? railHeight : Math.abs(endPos - startPos),
      cursor
    }, trackStyle));
    track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), container2.add(trackContainer);
  }
  _renderHandler(style2) {
    return graphicCreator.symbol(style2);
  }
  _renderHandlerText(value, position) {
    var _a, _b, _c;
    const { align, handlerSize = 14, handlerText = {}, railHeight, railWidth, slidable } = this.attribute, isHorizontal2 = this._isHorizontal, pos = this.calculatePosByValue(value, position), textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4, textStyle = {
      text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
      lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal2)
    };
    isHorizontal2 ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, textStyle.y = pos) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = pos);
    return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
  }
  _renderTooltip() {
    var _a;
    const { tooltip, railHeight, railWidth, align } = this.attribute;
    tooltip && tooltip.alwaysShow ? this._tooltipState = {
      value: this._currentValue.startValue,
      pos: this._currentValue.startPos
    } : this._tooltipState = null;
    const cx = this._isHorizontal ? 0 : railWidth / 2, cy = this._isHorizontal ? railHeight / 2 : 0;
    if (tooltip && tooltip.shape) {
      const shape = graphicCreator.symbol(Object.assign({
        pickable: false,
        visible: !!this._tooltipState,
        x: cx,
        y: cy,
        symbolType: "circle"
      }, tooltip.shapeStyle));
      this._tooltipShape = shape, this._mainContainer.add(shape);
    }
    const textConfig = tooltip && tooltip.text || {}, space = null !== (_a = textConfig.space) && void 0 !== _a ? _a : 6, textStyle = {
      pickable: false,
      visible: !!this._tooltipState,
      text: ""
    };
    this._isHorizontal ? (textStyle.x = cx, textStyle.y = "top" === align ? cy - railHeight / 2 - space : cy + railHeight / 2 + space, textStyle.textAlign = "center", textStyle.textBaseline = "top" === align ? "bottom" : "top") : (textStyle.y = cy, textStyle.x = "left" === align ? cx - railWidth / 2 - space : cy + railWidth / 2 + space, textStyle.textAlign = "left" === align ? "end" : "start", textStyle.textBaseline = "middle");
    const text2 = graphicCreator.text(Object.assign(Object.assign({}, textStyle), textConfig.style));
    this._mainContainer.add(text2), this._tooltipText = text2, this._tooltipState && this._updateTooltip();
  }
  _updateTooltip() {
    var _a, _b;
    if (!this._tooltipShape && !this._tooltipText || !this._tooltipState) return;
    const { railWidth, railHeight } = this.attribute, railLen = this._isHorizontal ? railWidth : railHeight, coord = this._tooltipState.pos * railLen, coordKey = this._isHorizontal ? "x" : "y";
    this._tooltipShape && this._tooltipShape.setAttributes({
      visible: true,
      [coordKey]: coord
    });
    const { align } = this.attribute;
    if (this._tooltipText) {
      const textConfig = this.attribute.tooltip && this.attribute.tooltip.text || {};
      this._tooltipText.setAttributes({
        visible: true,
        [coordKey]: coord,
        text: textConfig.formatter ? textConfig.formatter(this._tooltipState.value) : this._isHorizontal || "left" !== align ? `≈ ${this._tooltipState.value.toFixed(null !== (_b = textConfig.precision) && void 0 !== _b ? _b : 0)}` : `${this._tooltipState.value.toFixed(null !== (_a = textConfig.precision) && void 0 !== _a ? _a : 0)} ≈`
      });
    }
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { slidable, range: range5 } = this.attribute;
    slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), isObject_default(range5) && range5.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), this._railContainer.addEventListener("pointerdown", this._onRailPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }));
  }
  _bindTooltipEvents() {
    this.attribute.disableTriggerEvent || (this._mainContainer.addEventListener("pointerenter", this._onTooltipShow), this._mainContainer.addEventListener("pointermove", this._onTooltipUpdate), this._mainContainer.addEventListener("pointerleave", this._onTooltipHide));
  }
  _clearAllDragEvents() {
    const triggers = getEndTriggersOfDrag(), obj2 = "browser" === vglobal.env ? vglobal : this.stage;
    obj2.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj2.removeEventListener(trigger, this._onHandlerPointerUp);
    }), obj2.removeEventListener("pointermove", this._onTrackPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj2.removeEventListener(trigger, this._onTrackPointerUp);
    });
  }
  _updateTrack() {
    const { inverse, railWidth, railHeight } = this.attribute, startHandler = this._startHandler, endHandler = this._endHandler;
    if (this._isHorizontal) {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
        this._track.setAttributes({
          x: Math.min(startHandlerPos, endHandlerPos),
          width: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else inverse ? this._track.setAttributes({
        x: startHandlerPos,
        width: railWidth - startHandlerPos
      }) : this._track.setAttributes({
        width: startHandlerPos
      });
    } else {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
        this._track.setAttributes({
          y: Math.min(startHandlerPos, endHandlerPos),
          height: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else inverse ? this._track.setAttributes({
        y: startHandlerPos,
        height: railHeight - startHandlerPos
      }) : this._track.setAttributes({
        height: startHandlerPos
      });
    }
  }
  _updateHandler(handler, position, value) {
    var _a;
    const isHorizontal2 = this._isHorizontal;
    handler.setAttribute(isHorizontal2 ? "x" : "y", position);
    const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
    if (updateHandlerText) {
      const { handlerText = {} } = this.attribute;
      updateHandlerText.setAttributes({
        text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
        [isHorizontal2 ? "x" : "y"]: position
      });
    }
    handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _updateHandlerText(handlerText, position, value) {
    var _a;
    const isHorizontal2 = this._isHorizontal, { handlerText: handlerTextAttr = {} } = this.attribute;
    handlerText.setAttributes({
      [isHorizontal2 ? "x" : "y"]: position,
      text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
    });
    const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
    updateHandler && updateHandler.setAttributes({
      [isHorizontal2 ? "x" : "y"]: position
    }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _dispatchChangeEvent() {
    const isRange = !!this.attribute.range, currentValue = this._currentValue;
    this._dispatchEvent("change", {
      value: isRange ? [Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue)] : currentValue.startValue,
      position: isRange ? [Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos)] : currentValue.startPos
    });
  }
  _dispatchTooltipEvent(type) {
    this._dispatchEvent("sliderTooltip", {
      type,
      position: this._tooltipState && this._tooltipState.pos,
      value: this._tooltipState && this._tooltipState.value
    });
  }
  _getHandlers() {
    const { inverse } = this.attribute;
    let startHandler = this._startHandler, endHandler = this._endHandler;
    return endHandler ? (this._isHorizontal ? (!inverse && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) || inverse && endHandler.attribute.x > (null == startHandler ? void 0 : startHandler.attribute.x)) && ([startHandler, endHandler] = [endHandler, startHandler]) : (!inverse && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) || inverse && endHandler.attribute.y > (null == startHandler ? void 0 : startHandler.attribute.y)) && ([startHandler, endHandler] = [endHandler, startHandler]), {
      startHandler,
      endHandler
    }) : {
      startHandler,
      endHandler
    };
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearAllDragEvents();
  }
};
Slider.defaultAttributes = {
  slidable: true,
  layout: "horizontal",
  align: "bottom",
  height: 8,
  showHandler: true,
  handlerSize: 14,
  handlerStyle: {
    symbolType: "circle",
    fill: "#fff",
    stroke: "#91caff",
    lineWidth: 2
  },
  tooltip: {
    shapeStyle: {
      symbolType: "circle",
      fill: "#fff",
      stroke: "#91caff",
      lineWidth: 2
    },
    text: {
      style: {
        fill: "#2C3542",
        fontSize: 12
      }
    }
  },
  railStyle: {
    fill: "rgba(0,0,0,.04)"
  },
  trackStyle: {
    fill: "#91caff"
  },
  showValue: true,
  valueStyle: {
    fill: "#2C3542",
    fontSize: 12
  },
  startText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  endText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  handlerText: {
    visible: true,
    space: 4,
    precision: 0,
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/color/color.js
loadColorContinuousLegendComponent();
var ColorContinuousLegend = class _ColorContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ColorContinuousLegend.defaultAttributes, attributes)), this.name = "colorLegend", this._onSliderToolipChange = (e) => {
      const tooltipShape = this._slider.tooltipShape;
      if (tooltipShape && e.detail && !isNil_default(e.detail.value)) {
        const color = this._colorScale.scale(e.detail.value);
        tooltipShape.setAttribute("fill", color);
      }
      this.dispatchEvent(e);
    }, this._onSliderChange = (e) => {
      this._updateColor(), this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && (this._slider.setValue(value), this._updateColor());
  }
  _renderContent() {
    const { colors, slidable, layout, align, min: min2, max: max2, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip, tooltip, inverse, disableTriggerEvent } = this.attribute, domain = [], step = (max2 - min2) / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) domain.push(min2 + step * i);
    this._colorScale = new LinearScale().domain(domain, true).range(colors), this._color = this._getTrackColor();
    const slider = new Slider({
      x: 0,
      y: 0,
      range: {
        draggableTrack: true
      },
      slidable,
      layout,
      align,
      min: min2,
      max: max2,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle,
      railStyle,
      trackStyle: Object.assign({
        fill: this._color
      }, trackStyle),
      startText,
      endText,
      handlerText,
      showTooltip,
      tooltip,
      disableTriggerEvent,
      inverse
    });
    this._innerView.add(slider), this._slider = slider, slider.translateTo(0 - slider.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0) - slider.AABBBounds.y1), this._updateColor();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
  _getTrackColor() {
    const { colors, layout, inverse } = this.attribute;
    if (isEmpty_default(colors)) return;
    const count = colors.length;
    if (1 === count) return colors[0];
    const stops = [];
    for (let i = 0; i < count; i++) {
      const percent = i / (count - 1);
      stops.push({
        offset: percent,
        color: colors[i]
      });
    }
    const isHorizontal2 = "horizontal" === layout, res = {
      gradient: "linear",
      stops,
      x0: 0,
      y0: 0,
      x1: isHorizontal2 ? 1 : 0,
      y1: isHorizontal2 ? 0 : 1
    };
    return inverse && (isHorizontal2 ? (res.x0 = 1, res.x1 = 0) : (res.y0 = 1, res.y1 = 0)), res;
  }
  _updateColor() {
    var _a;
    const { layout = "horizontal", colors, railWidth, railHeight } = this.attribute, { startHandler, endHandler, track, attribute } = this._slider, { startValue, endValue, startPos, endPos } = this._slider.currentValue, handlerColor = null === (_a = attribute.handlerStyle) || void 0 === _a ? void 0 : _a.fill;
    if (startHandler && !handlerColor) {
      const startHandlerColor = this._colorScale.scale(startValue);
      startHandler.setAttribute("fill", startHandlerColor);
    }
    if (endHandler && !handlerColor) {
      const endHandlerColor = this._colorScale.scale(endValue);
      endHandler.setAttribute("fill", endHandlerColor);
    }
    const railLen = "horizontal" === layout ? railWidth : railHeight;
    if (Math.abs(startPos - endPos) !== railLen && colors && colors.length > 1) {
      const stops = this._color.stops, start = Math.min(startPos, endPos), end = Math.max(startPos, endPos), startRatio = start / railLen, endRatio = end / railLen, range5 = endRatio - startRatio, betweenStops = stops.filter((stop) => stop.offset > startRatio && stop.offset < endRatio), minValue = Math.min(startValue, endValue), maxValue = Math.max(startValue, endValue), startColor = this._colorScale.scale(minValue), endColor = this._colorScale.scale(maxValue), newStops = [{
        offset: 0,
        color: startColor
      }];
      betweenStops.forEach((stop) => {
        newStops.push({
          offset: (stop.offset - startRatio) / range5,
          color: stop.color
        });
      }), newStops.push({
        offset: 1,
        color: endColor
      }), track.setAttribute("fill", Object.assign(Object.assign({}, this._color), {
        stops: newStops
      }));
    }
  }
};
ColorContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    fill: null,
    lineWidth: 4,
    stroke: "#fff",
    outerBorder: {
      distance: 2,
      lineWidth: 1,
      stroke: "#ccc"
    }
  },
  tooltip: {
    shapeStyle: {
      lineWidth: 4,
      stroke: "#fff"
    }
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/util.js
function getSizeHandlerPath(align = "bottom") {
  let centerX = 0;
  return "top" === align ? `
    M${centerX},-6L${centerX - 3.5},-2.5
    v5
    h7
    v-5
    Z
` : "left" === align ? (centerX = 1, `
    M${centerX - 6},0L${centerX - 6 + 2.5},-3.5
    h5
    v7
    h-5
    Z
`) : "right" === align ? (centerX = -1, `
    M${centerX + 6},0L${centerX + 6 - 2.5},-3.5
    h-5
    v7
    h5
    Z
  `) : `
    M${centerX},6L${centerX - 3.5},2.5
    v-5
    h7
    v5
    Z
`;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/legend/size/size.js
loadSizeContinuousLegendComponent();
var SizeContinuousLegend = class _SizeContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SizeContinuousLegend.defaultAttributes, attributes)), this.name = "sizeLegend", this._onSliderChange = (e) => {
      this.dispatchEvent(e);
    }, this._onSliderToolipChange = (e) => {
      this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && this._slider.setValue(value);
  }
  _renderContent() {
    const { slidable, layout, align, min: min2, max: max2, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip, tooltip, sizeBackground, disableTriggerEvent, inverse } = this.attribute, mainContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._innerView.add(mainContainer);
    const slider = new Slider({
      x: 0,
      y: 0,
      zIndex: 1,
      range: {
        draggableTrack: true
      },
      slidable,
      layout,
      align,
      min: min2,
      max: max2,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle: Object.assign({
        symbolType: getSizeHandlerPath(align)
      }, handlerStyle),
      railStyle,
      trackStyle,
      startText,
      endText,
      handlerText,
      showTooltip,
      tooltip,
      disableTriggerEvent,
      inverse
    });
    mainContainer.add(slider);
    let path, start = 0;
    "horizontal" === layout ? "top" === align ? (path = `M0,0L${railWidth},0L${inverse ? 0 : railWidth},12Z`, start = railHeight) : (path = `M0,12L${railWidth},12L${inverse ? 0 : railWidth},0Z`, slider.setAttribute("y", 12)) : "left" === align ? path = `M${railWidth},0L${railWidth + 12},${inverse ? 0 : railHeight}L${railWidth},${railHeight}Z` : (path = `M0,${inverse ? 0 : railHeight}L12,${railHeight}L12,0Z`, slider.setAttribute("x", 12));
    const background = graphicCreator.path(Object.assign(Object.assign({
      x: 0,
      y: start,
      path
    }, sizeBackground), {
      zIndex: 0
    }));
    mainContainer.add(background);
    const titleSpace = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0;
    mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1), this._slider = slider;
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
};
SizeContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    lineWidth: 1,
    stroke: "#ccc",
    fill: "#fff"
  },
  sizeBackground: {
    fill: "rgba(20,20,20,0.1)"
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/title/register.js
function loadTitleComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/title/title.js
loadTitleComponent();
var Title = class _Title extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Title.defaultAttributes, attributes)), this.name = "title";
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const { textType, text: text2, subtextType, textStyle = {}, subtext, subtextStyle = {}, width, height, minWidth, maxWidth, minHeight, maxHeight, align, verticalAlign, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("title-container", {
      x: parsedPadding[3],
      y: parsedPadding[0],
      zIndex: 1
    }, "group"), fixedMainTitleHeight = null !== (_a = textStyle.height) && void 0 !== _a ? _a : height;
    if (false !== this.attribute.visible && false !== textStyle.visible) {
      const { width: mainTitleWidth, maxHeight: mainTitleMaxHeight, maxWidth: mainTitleMaxWidth, x = 0, y = 0, ellipsis = true, wordBreak = "break-word", maxWidth: maxWidth2, lineClamp } = textStyle;
      if ("rich" === textType || isValid_default(textStyle.character)) {
        const attr = Object.assign({
          x,
          y,
          width: null !== (_b = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _b ? _b : 0,
          height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
          ellipsis: null == ellipsis || ellipsis,
          wordBreak: null != wordBreak ? wordBreak : "break-word",
          maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
          maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth2,
          textConfig: null !== (_c = textStyle.character) && void 0 !== _c ? _c : text2
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else if ("html" === textType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: text2
          }, DEFAULT_HTML_TEXT_SPEC), textStyle),
          x,
          y,
          width: null !== (_d = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _d ? _d : 0,
          height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
          maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth2,
          textConfig: []
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else isValid_default(text2) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
        text: isArray_default(text2) ? text2 : [text2],
        whiteSpace: "normal"
      }, textStyle), {
        maxLineWidth: null !== (_f = null !== (_e = textStyle.maxLineWidth) && void 0 !== _e ? _e : mainTitleWidth) && void 0 !== _f ? _f : width,
        heightLimit: null !== (_g = textStyle.height) && void 0 !== _g ? _g : maxHeight,
        lineClamp,
        ellipsis,
        x,
        y
      }), "text"));
    }
    const mainTextBoundsHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0, mainTextBoundsWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
    if (false !== this.attribute.visible && false !== subtextStyle.visible) {
      const { width: subTitleWidth, height: subTitleHeight, maxWidth: subTitleMaxWidth, maxHeight: subTitleMaxHeight, x = 0, y = 0, ellipsis = true, wordBreak = "break-word", lineClamp } = subtextStyle, maxSubTextHeight = Math.max(Number.MIN_VALUE, maxHeight - mainTextBoundsHeight);
      if ("rich" === subtextType || isValid_default(subtextStyle.character)) {
        const attr = Object.assign({
          x,
          y,
          width: null !== (_h = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _h ? _h : 0,
          height: null !== (_j = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _j ? _j : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
          maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
          textConfig: null !== (_k = subtextStyle.character) && void 0 !== _k ? _k : subtext
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else if ("html" === subtextType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: subtext
          }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
          x,
          y,
          width: null !== (_l = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _l ? _l : 0,
          height: null !== (_m = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _m ? _m : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
          maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
          textConfig: []
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else isValid_default(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
        text: isArray_default(subtext) ? subtext : [subtext],
        whiteSpace: "normal"
      }, subtextStyle), {
        maxLineWidth: null !== (_o = subtextStyle.maxLineWidth) && void 0 !== _o ? _o : width,
        heightLimit: null !== (_p = subtextStyle.heightLimit) && void 0 !== _p ? _p : maxSubTextHeight,
        lineClamp,
        ellipsis,
        x: 0,
        y: mainTextBoundsHeight
      }), "text"));
    }
    const subTextBoundsHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0, subTextBoundsWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
    let totalWidth = Math.max(mainTextBoundsWidth, subTextBoundsWidth), totalHeight = mainTextBoundsHeight + (null !== (_q = subtextStyle.height) && void 0 !== _q ? _q : subTextBoundsHeight);
    if (isValid_default(width) && (totalWidth = width), isValid_default(height) && (totalHeight = height), isValid_default(minWidth) && totalWidth < minWidth && (totalWidth = minWidth), isValid_default(maxWidth) && totalWidth > maxWidth && (totalWidth = maxWidth), isValid_default(minHeight) && totalHeight < minHeight && (totalHeight = minHeight), isValid_default(maxHeight) && totalHeight > maxHeight && (totalHeight = maxHeight), group.attribute.width = totalWidth, group.attribute.height = totalHeight, group.attribute.boundsPadding = parsedPadding, this._mainTitle) {
      if (isValid_default(align) || isValid_default(textStyle.align)) {
        const mainTitleAlign = textStyle.align ? textStyle.align : align, mainTitleWidth = null !== (_r = textStyle.width) && void 0 !== _r ? _r : totalWidth;
        "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth), this._mainTitle.setAttribute("textAlign", "right")) : (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left"));
      }
      const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign, mainTitleHeight = null != fixedMainTitleHeight ? fixedMainTitleHeight : this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height();
      "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight), this._mainTitle.setAttribute("textBaseline", "bottom")) : (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top"));
    }
    if (this._subTitle) {
      if (isValid_default(align) || isValid_default(subtextStyle.align)) {
        const subTitleAlign = subtextStyle.align ? subtextStyle.align : align, subTitleWidth = null !== (_t = null !== (_s = subtextStyle.width) && void 0 !== _s ? _s : textStyle.width) && void 0 !== _t ? _t : totalWidth;
        "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth), this._subTitle.setAttribute("textAlign", "right")) : (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left"));
      }
      const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign, subTitleYStart = this._mainTitle ? isValid_default(fixedMainTitleHeight) ? this._mainTitle.AABBBounds.y1 + Math.max(this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height(), fixedMainTitleHeight) : this._mainTitle.AABBBounds.y2 : 0, subTitleHeight = null !== (_v = null !== (_u = subtextStyle.height) && void 0 !== _u ? _u : height) && void 0 !== _v ? _v : this._subTitle.AABBBounds.empty() ? 0 : this._subTitle.AABBBounds.height();
      "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), this._subTitle.setAttribute("textBaseline", "bottom")) : (this._subTitle.setAttribute("y", subTitleYStart), this._subTitle.setAttribute("textBaseline", "top"));
    }
  }
};
Title.defaultAttributes = {
  textStyle: {
    ellipsis: "...",
    fill: "#333",
    fontSize: 20,
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "top"
  },
  subtextStyle: {
    ellipsis: "...",
    fill: "#6F6F6F",
    fontSize: 16,
    fontWeight: "normal",
    textAlign: "left",
    textBaseline: "top"
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/indicator/register.js
function loadIndicatorComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/indicator/indicator.js
loadIndicatorComponent();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/link-path/register.js
function loadLinkPathComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/link-path/link-path.js
var getHorizontalPath = (options, ratio) => {
  let x0 = options.x0, x1 = options.x1;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let y00 = options.y0 - options.thickness / 2, y10 = options.y1 - options.thickness / 2;
  "center" === options.align ? (y00 = options.y0 - thickness / 2, y10 = options.y1 - thickness / 2) : "end" === options.align && (y00 = options.y0 + options.thickness / 2 - thickness, y10 = options.y1 + options.thickness / 2 - thickness);
  let midX = (x0 + x1) / 2, y01 = y00 + thickness, y11 = y10 + thickness;
  options.round && (x0 = Math.round(x0), x1 = Math.round(x1), y00 = Math.round(y00), y10 = Math.round(y10), y01 = Math.round(y01), y11 = Math.round(y11), midX = Math.round(midX));
  const hasLength = Math.abs(x1 - x0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x1},${y10 - thickness / 2}L${x1 + thickness},${(y10 + y11) / 2}L${x1},${y11 + thickness / 2}` : "", startArrowPath = options.startArrow && hasLength ? `L${x0},${y01 + thickness / 2}L${x0 - thickness},${(y00 + y01) / 2}L${x0},${y00 - thickness / 2}` : "";
  return false === options.isSmooth ? `M${x0},${y00}L${x1},${y10}${endArrowPath}L${x1},${y11}L${x0},${y01}${startArrowPath}Z` : `M${x0},${y00}
  C${midX},${y00},${midX},${y10},${x1},${y10}
  ${endArrowPath}
  L${x1},${y11}
  C${midX},${y11},${midX},${y01},${x0},${y01}
  ${startArrowPath}
  Z`;
};
var getVerticalPath = (options, ratio) => {
  let y0 = options.y0, y1 = options.y1, x00 = options.x0 - options.thickness / 2, x10 = options.x1 - options.thickness / 2;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  "center" === options.align ? (x00 = options.x0 - thickness / 2, x10 = options.x1 - thickness / 2) : "end" === options.align && (x00 = options.x0 + options.thickness / 2 - thickness, x10 = options.x1 + options.thickness / 2 - thickness);
  let midY = (y0 + y1) / 2, x01 = x00 + thickness, x11 = x10 + thickness;
  options.round && (y0 = Math.round(y0), y1 = Math.round(y1), x00 = Math.round(x00), x10 = Math.round(x10), x01 = Math.round(x01), x11 = Math.round(x11), midY = Math.round(midY));
  const hasLength = Math.abs(y1 - y0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x10 - thickness / 2},${y1}L${(x10 + x11) / 2},${y1 + thickness}L${x11 + thickness / 2},${y1}` : "", startArrowPath = options.startArrow && hasLength ? `L${x01 + thickness / 2},${y0}L${(x01 + x00) / 2},${y0 - thickness}L${x00 - thickness / 2},${y0}` : "";
  return false === options.isSmooth ? `M${x00},${y0}L${x10},${y1}${endArrowPath}L${x11},${y1}L${x01},${y0}${startArrowPath}Z` : `M${x00},${y0}
  C${x00},${midY},${x10},${midY},${x10},${y1}
  ${endArrowPath}
  L${x11},${y1}
  C${x11},${midY},${x01},${midY},${x01},${y0}
  ${startArrowPath}
  Z`;
};
loadLinkPathComponent();
var LinkPath = class _LinkPath extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LinkPath.defaultAttributes, attributes));
  }
  render() {
    const { direction = "horizontal" } = this.attribute, parsePath = "vertical" === direction ? getVerticalPath : getHorizontalPath, isRatioShow = "number" == typeof this.attribute.ratio && this.attribute.ratio >= 0 && this.attribute.ratio <= 1, groupAttrKeys = ["direction", "x0", "x1", "y0", "y1", "thickness", "round", "ratio", "align", "isSmooth", "backgroudStyle"], commonStyle = {};
    if (Object.keys(this.attribute).forEach((key) => {
      groupAttrKeys.includes(key) || (commonStyle[key] = this.attribute[key]);
    }), isRatioShow) {
      const background = this.createOrUpdateChild("sankey-link-background", Object.assign({}, commonStyle, this.attribute.backgroudStyle, {
        path: parsePath(this.attribute, 1),
        visible: true,
        pickable: false,
        zIndex: -1
      }), "path");
      this._backPath = background;
    } else this._backPath && this._backPath.setAttribute("visible", false);
    const front = this.createOrUpdateChild("sankey-link-front", Object.assign({}, commonStyle, {
      path: parsePath(this.attribute, isRatioShow ? this.attribute.ratio : 1),
      pickable: false
    }), "path");
    this._frontPath = front;
  }
};
LinkPath.defaultAttributes = {
  direction: "horizontal",
  align: "start"
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/controller/assets/index.js
var iconPlay = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z";
var iconPause = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z";
var iconLeft = "M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z";
var iconDown = "M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z";
var iconUp = "m 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z";
var iconRight = "M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z";

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/controller/icon/icon.js
var PlayerIcon = class extends Symbol2 {
  constructor(params2) {
    super(params2);
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/controller/constant.js
var ControllerEventEnum;
!function(ControllerEventEnum2) {
  ControllerEventEnum2.OnPlay = "onPlay", ControllerEventEnum2.OnPause = "onPause", ControllerEventEnum2.OnForward = "onForward", ControllerEventEnum2.OnBackward = "onBackward";
}(ControllerEventEnum || (ControllerEventEnum = {}));
var ControllerTypeEnum;
!function(ControllerTypeEnum2) {
  ControllerTypeEnum2.Start = "start", ControllerTypeEnum2.Pause = "pause", ControllerTypeEnum2.Forward = "forward", ControllerTypeEnum2.Backward = "backward";
}(ControllerTypeEnum || (ControllerTypeEnum = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/controller/controller.js
var Controller = class _Controller extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Controller.defaultAttributes, attributes)), this._isPaused = true, this.updateAttributes = () => {
      this._startAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPlay
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.start.visible
        }), this.attribute.start.style)
      }, this._pauseAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPause
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.pause.visible
        }), this.attribute.pause.style)
      }, this._forwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.forward.visible
        }), this.attribute.forward.style)
      }, this._backwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.backward.visible
        }), this.attribute.backward.style)
      }, this.updateLayout();
    }, this.updateLayout = () => {
      var _a, _b, _c, _d;
      this._layout = this.attribute.layout, "horizontal" === this._layout ? (this._backwardAttr.style.symbolType = null !== (_a = this._backwardAttr.style.symbolType) && void 0 !== _a ? _a : iconLeft, this._forwardAttr.style.symbolType = null !== (_b = this._forwardAttr.style.symbolType) && void 0 !== _b ? _b : iconRight) : "vertical" === this._layout && (this._backwardAttr.style.symbolType = null !== (_c = this._backwardAttr.style.symbolType) && void 0 !== _c ? _c : iconUp, this._forwardAttr.style.symbolType = null !== (_d = this._forwardAttr.style.symbolType) && void 0 !== _d ? _d : iconDown);
    }, this._initPlay = () => {
      isNil_default(this._playController) && (this._playController = new PlayerIcon(Object.assign({}, this._startAttr.style)), this.add(this._playController));
    }, this._initBackward = () => {
      isNil_default(this._backwardController) && (this._backwardController = new PlayerIcon(Object.assign({}, this._backwardAttr.style)), this.add(this._backwardController));
    }, this._initForward = () => {
      isNil_default(this._forwardController) && (this._forwardController = new PlayerIcon(Object.assign({}, this._forwardAttr.style)), this.add(this._forwardController));
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._playController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), true === this._isPaused ? this.play() : this.pause();
      }), this._backwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.backward();
      }), this._forwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.forward();
      }));
    }, this.renderPlay = () => {
      this._isPaused ? this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._startAttr.style)) : this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._pauseAttr.style));
    }, this.renderBackward = () => {
      this._backwardController.setAttributes(this._backwardAttr.style);
    }, this.renderForward = () => {
      this._forwardController.setAttributes(this._forwardAttr.style);
    }, this.play = () => {
      this._dispatchEvent(ControllerEventEnum.OnPlay);
    }, this.pause = () => {
      this._dispatchEvent(ControllerEventEnum.OnPause);
    }, this.forward = () => {
      this._dispatchEvent(ControllerEventEnum.OnForward);
    }, this.backward = () => {
      this._dispatchEvent(ControllerEventEnum.OnBackward);
    }, this.togglePlay = () => {
      this._playController.setAttributes(this._startAttr.style), this._isPaused = true;
    }, this.togglePause = () => {
      this._playController.setAttributes(this._pauseAttr.style), this._isPaused = false;
    }, this.updateAttributes(), this._initPlay(), this._initBackward(), this._initForward(), this._initEvents();
  }
  render() {
    this.updateAttributes(), this.renderPlay(), this.renderBackward(), this.renderForward();
  }
};
Controller.defaultControllerAttr = {
  visible: true,
  x: 0,
  y: 0,
  size: 20,
  fill: "#91caff",
  pickMode: "imprecise",
  cursor: "pointer"
}, Controller.defaultAttributes = {
  [ControllerTypeEnum.Start]: {},
  [ControllerTypeEnum.Pause]: {},
  [ControllerTypeEnum.Backward]: {},
  [ControllerTypeEnum.Forward]: {}
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/constant.js
var defaultControllerAttributes = {
  visible: true,
  style: {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    size: 20
  },
  order: 0,
  space: 10
};
var RailDefaultSize = [200, 10];

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/type/direction.js
var DirectionEnum;
!function(DirectionEnum2) {
  DirectionEnum2.Default = "default", DirectionEnum2.Reverse = "reverse";
}(DirectionEnum || (DirectionEnum = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/type/event.js
var PlayerEventEnum;
!function(PlayerEventEnum2) {
  PlayerEventEnum2.change = "change", PlayerEventEnum2.play = "play", PlayerEventEnum2.pause = "pause", PlayerEventEnum2.backward = "backward", PlayerEventEnum2.forward = "forward", PlayerEventEnum2.end = "end", PlayerEventEnum2.OnChange = "change", PlayerEventEnum2.OnPlay = "play", PlayerEventEnum2.OnPause = "pause", PlayerEventEnum2.OnBackward = "backward", PlayerEventEnum2.OnForward = "forward", PlayerEventEnum2.OnEnd = "end";
}(PlayerEventEnum || (PlayerEventEnum = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/utils.js
var isHorizontal = (orient) => "top" === orient || "bottom" === orient;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/base-player.js
var BasePlayer = class _BasePlayer extends AbstractComponent {
  getMinIndex() {
    return this._minIndex;
  }
  getMaxIndex() {
    return this._maxIndex;
  }
  getDataIndex() {
    return this._dataIndex;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _BasePlayer.defaultAttributes, attributes)), this._data = [], this._dataIndex = 0, this._layoutInfo = {}, this._updateSliderAttrs = () => {
      var _a, _b;
      let handlerSize;
      isValidNumber_default(this._handlerStyle.size) ? handlerSize = this._handlerStyle.size : this._handlerStyle.size && this._handlerStyle.size.length && (handlerSize = max(this._handlerStyle.size[0], this._handlerStyle.size[1]));
      const attrs = {
        visible: this._sliderVisible,
        min: this._minIndex,
        max: this._maxIndex,
        value: this._dataIndex,
        railWidth: this._railStyle.width,
        railHeight: this._railStyle.height,
        railStyle: this._railStyle,
        trackStyle: this._trackStyle,
        handlerSize: isValidNumber_default(handlerSize) ? handlerSize : void 0,
        handlerStyle: this._handlerStyle,
        dy: this.attribute.slider.dy,
        dx: this.attribute.slider.dx,
        slidable: true,
        range: false,
        handlerText: {
          visible: false
        },
        startText: {
          visible: false
        },
        endText: {
          visible: false
        },
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      if (isHorizontal(this._orient)) {
        const railWidth = Math.max(0, this._layoutInfo.slider.size), railHeight = null !== (_a = this._railStyle.height) && void 0 !== _a ? _a : RailDefaultSize[1];
        attrs.layout = "horizontal", attrs.railHeight = railHeight, attrs.railWidth = railWidth, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      } else {
        const railHeight = Math.max(0, this._layoutInfo.slider.size), railWidth = null !== (_b = this._railStyle.width) && void 0 !== _b ? _b : RailDefaultSize[1];
        attrs.layout = "vertical", attrs.railWidth = railWidth, attrs.railHeight = railHeight, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      }
      return attrs;
    }, this._initSlider = () => {
      const attrs = this._updateSliderAttrs();
      this._slider = new Slider(attrs), this._sliderVisible && this.add(this._slider);
    }, this._updateControllerAttrs = () => {
      const attrs = {
        start: this._start,
        pause: this._pause,
        forward: this._forward,
        backward: this._backward,
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      return attrs.layout = isHorizontal(this._orient) ? "horizontal" : "vertical", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      }), attrs;
    }, this._initController = () => {
      const attrs = this._updateControllerAttrs();
      this._controller = new Controller(attrs), this._controllerVisible && this.add(this._controller);
    }, this._initAttributes(), this._initDataIndex(), this._initLayoutInfo(), this._initController(), this._initSlider();
  }
  _initAttributes() {
    this._size = this.attribute.size, this._orient = this.attribute.orient, this._data = this.attribute.data, this._minIndex = 0, this._maxIndex = this._data.length - 1;
    const { slider = {}, controller = {} } = this.attribute;
    this._sliderVisible = slider.visible, this._railStyle = Object.assign({}, slider.railStyle), this._trackStyle = Object.assign({}, slider.trackStyle), this._handlerStyle = Object.assign({}, slider.handlerStyle), this._controllerVisible = controller.visible, this._start = Object.assign({}, controller.start), this._pause = Object.assign({}, controller.pause), this._forward = Object.assign({}, controller.forward), this._backward = Object.assign({}, controller.backward);
  }
  _initDataIndex() {
    var _a;
    this._dataIndex = null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0;
  }
  _initLayoutInfo() {
    var _a, _b, _c;
    const controllers = [this._start, this._backward, this._forward].sort((a2, b) => a2.order - b.order), startControllers = controllers.filter((d) => "end" !== d.position), endControllers = controllers.filter((d) => "end" === d.position), railSectionLength = null !== (_a = isHorizontal(this._orient) ? this._railStyle.height : this._railStyle.width) && void 0 !== _a ? _a : RailDefaultSize[1], controllerPx = controllers.reduce((len, controller) => {
      const size = controller.style.size, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return len + controller.space + maxSize;
    }, 0), sliderPx = this._sliderVisible ? (isHorizontal(this._orient) ? null === (_b = this._size) || void 0 === _b ? void 0 : _b.width : null === (_c = this._size) || void 0 === _c ? void 0 : _c.height) - controllerPx : 0, railPx = sliderPx - this.attribute.slider.space, startPx = startControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, 0);
    this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), {
      size: railPx,
      x: isHorizontal(this._orient) ? startPx + this.attribute.slider.space : (this._size.width - railSectionLength) / 2,
      y: isHorizontal(this._orient) ? (this._size.height - railSectionLength) / 2 : startPx + this.attribute.slider.space
    }), endControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, startPx + sliderPx);
  }
  render() {
    this._initLayoutInfo(), this.renderSlider(), this.renderController();
  }
  renderSlider() {
    const attrs = this._updateSliderAttrs();
    this._slider.setAttributes(attrs);
  }
  renderController() {
    const attrs = this._updateControllerAttrs();
    this._controller.setAttributes(attrs);
  }
  dispatchCustomEvent(eventType, dataIndex) {
    this._dispatchEvent(eventType, {
      eventType,
      index: dataIndex,
      value: this._data[dataIndex]
    });
  }
};
BasePlayer.defaultAttributes = {
  visible: true,
  data: [],
  interval: 1e3,
  orient: "bottom",
  align: "center",
  size: {
    height: 20,
    width: 300
  },
  slider: {
    visible: true,
    space: 10,
    dx: 0,
    dy: 0,
    railStyle: {
      cornerRadius: 5
    },
    trackStyle: {},
    handlerStyle: {}
  },
  controller: {
    visible: true,
    start: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "start",
      position: "start",
      space: 0
    }),
    pause: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "pause",
      position: "start"
    }),
    forward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "forward",
      position: "end"
    }),
    backward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "backward",
      position: "start"
    })
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/register.js
function loadBasePlayer() {
  loadSliderComponent(), registerGroup(), registerSymbol();
}
function loadDiscretePlayerComponent() {
  loadBasePlayer();
}
function loadContinuousPlayerComponent() {
  loadBasePlayer();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/discrete-player.js
loadDiscretePlayerComponent();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/player/continuous-player.js
loadContinuousPlayerComponent();

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/brush/type.js
var IOperateType;
!function(IOperateType2) {
  IOperateType2.drawStart = "drawStart", IOperateType2.drawEnd = "drawEnd", IOperateType2.drawing = "drawing", IOperateType2.moving = "moving", IOperateType2.moveStart = "moveStart", IOperateType2.moveEnd = "moveEnd", IOperateType2.brushActive = "brushActive", IOperateType2.brushClear = "brushClear";
}(IOperateType || (IOperateType = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/brush/config.js
var DEFAULT_BRUSH_ATTRIBUTES = {
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: ["pointerup", "pointerleave"],
  resetTrigger: "pointerupoutside",
  hasMask: true,
  brushMode: "single",
  brushType: "rect",
  brushStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    strokeWidth: 2
  },
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 10,
  interactiveRange: {
    minY: -1 / 0,
    maxY: 1 / 0,
    minX: -1 / 0,
    maxX: 1 / 0
  }
};
var DEFAULT_SIZE_THRESHOLD = 5;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/brush/register.js
function loadBrushComponent() {
  registerGroup(), registerPolygon();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/brush/brush.js
var delayMap3 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadBrushComponent();
var Brush = class _Brush extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Brush.defaultAttributes, attributes)), this.name = "brush", this._activeDrawState = false, this._cacheDrawPoints = [], this._activeMoveState = false, this._operatingMaskMoveDx = 0, this._operatingMaskMoveDy = 0, this._operatingMaskMoveRangeX = [-1 / 0, 1 / 0], this._operatingMaskMoveRangeY = [-1 / 0, 1 / 0], this._brushMaskAABBBoundsDict = {}, this._firstUpdate = true, this._onBrushStart = (e) => {
      if (this._outOfInteractiveRange(e)) return void (this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)));
      const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, brushMoved = true } = this.attribute;
      array(updateTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushingWithDelay)), array(endTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushEnd)), e.stopPropagation(), this._firstUpdate = true, this._activeMoveState = brushMoved && this._isPosInBrushMask(e), this._activeDrawState = !this._activeMoveState, this._startPos = this.eventPosToStagePos(e), this._cacheDrawPoints = [this._startPos];
    }, this._onBrushing = (e) => {
      this._outOfInteractiveRange(e) || (e.stopPropagation(), this._firstUpdate ? (this._activeDrawState && this._initDraw(e), this._activeMoveState && this._initMove(e), this._firstUpdate = false) : (this._activeDrawState && this._drawing(e), this._activeMoveState && this._moving(e)));
    }, this._onBrushingWithDelay = 0 === this.attribute.delayTime ? this._onBrushing : delayMap3[this.attribute.delayType](this._onBrushing, this.attribute.delayTime), this._onBrushEnd = (e) => {
      this._releaseBrushUpdateEvents(), e.preventDefault(), this._activeDrawState && this._drawEnd(e), this._activeMoveState && this._moveEnd(e), this._activeDrawState = false, this._activeMoveState = false;
    }, this._onBrushClear = (e) => {
      e.preventDefault(), this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)), this._activeDrawState = false, this._activeMoveState = false;
    };
  }
  _bindBrushEvents() {
    if (this.releaseBrushEvents(), this.attribute.disableTriggerEvent) return;
    const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    array(trigger).forEach((t) => this.stage.addEventListener(t, this._onBrushStart)), array(resetTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushClear));
  }
  _initDraw(e) {
    const { brushMode } = this.attribute, pos = this.eventPosToStagePos(e);
    this._cacheDrawPoints.push(pos), "single" === brushMode && this._clearMask(), this._addBrushMask(), this._dispatchBrushEvent(IOperateType.drawStart, e), 1 === Object.keys(this._brushMaskAABBBoundsDict).length && this._dispatchBrushEvent(IOperateType.brushActive, e);
  }
  _initMove(e) {
    var _a, _b;
    this._cacheMovePoint = this.eventPosToStagePos(e), this._operatingMaskMoveDx = null !== (_a = this._operatingMask.attribute.dx) && void 0 !== _a ? _a : 0, this._operatingMaskMoveDy = null !== (_b = this._operatingMask.attribute.dy) && void 0 !== _b ? _b : 0;
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, { x1, x2, y1, y2 } = this._operatingMask.globalAABBBounds, minMoveStepX = minX - x1, maxMoveStepX = maxX - x2, minMoveStepY = minY - y1, maxMoveStepY = maxY - y2;
    this._operatingMaskMoveRangeX = [minMoveStepX, maxMoveStepX], this._operatingMaskMoveRangeY = [minMoveStepY, maxMoveStepY], this._operatingMask.setAttribute("pickable", true), this._dispatchBrushEvent(IOperateType.moveStart, e);
  }
  _drawing(e) {
    var _a;
    const pos = this.eventPosToStagePos(e), { brushType } = this.attribute, cacheLength = this._cacheDrawPoints.length;
    if (cacheLength > 0) {
      const lastPos = null !== (_a = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) && void 0 !== _a ? _a : {};
      if (pos.x === lastPos.x && pos.y === lastPos.y) return;
    }
    "polygon" === brushType || cacheLength <= 1 ? this._cacheDrawPoints.push(pos) : this._cacheDrawPoints[cacheLength - 1] = pos;
    const maskPoints = this._computeMaskPoints();
    this._operatingMask.setAttribute("points", maskPoints), this._dispatchBrushEvent(IOperateType.drawing, e);
  }
  _moving(e) {
    const startPos = this._cacheMovePoint, pos = this.eventPosToStagePos(e);
    if (pos.x === (null == startPos ? void 0 : startPos.x) && pos.y === (null == startPos ? void 0 : startPos.y)) return;
    const moveStepX = pos.x - startPos.x, moveStepY = pos.y - startPos.y, moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) + this._operatingMaskMoveDx, moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) + this._operatingMaskMoveDy;
    this._operatingMask.setAttributes({
      dx: moveX,
      dy: moveY
    }), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchBrushEvent(IOperateType.moving, e);
  }
  _drawEnd(e) {
    const { removeOnClick = true, sizeThreshold = DEFAULT_SIZE_THRESHOLD } = this.attribute;
    if (this._outOfInteractiveRange(e)) this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e));
    else {
      const { x: x1, y: y1 } = this._startPos, { x: x2, y: y2 } = this.eventPosToStagePos(e);
      Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1 && removeOnClick ? this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)) : Math.abs(x2 - x1) < sizeThreshold && Math.abs(y1 - y2) < sizeThreshold ? (delete this._brushMaskAABBBoundsDict[this._operatingMask.name], this._container.setAttributes({}), this._container.removeChild(this._operatingMask), this._isEmptyMask() && this._dispatchBrushEvent(IOperateType.brushClear, e)) : (this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchBrushEvent(IOperateType.drawEnd, e));
    }
  }
  _moveEnd(e) {
    this._operatingMask && this._operatingMask.setAttribute("pickable", false), this._dispatchBrushEvent(IOperateType.moveEnd, e);
  }
  render() {
    this._bindBrushEvents();
    const group = this.createOrUpdateChild("brush-container", {}, "group");
    this._container = group;
  }
  releaseBrushEvents() {
    const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    array(trigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushStart)), array(resetTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushClear)), this._releaseBrushUpdateEvents();
  }
  _releaseBrushUpdateEvents() {
    const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger } = this.attribute;
    array(updateTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushingWithDelay)), array(endTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushEnd));
  }
  _computeMaskPoints() {
    const { brushType, xRange = [0, 0], yRange = [0, 0] } = this.attribute;
    let maskPoints = [];
    const startPoint = this._cacheDrawPoints[0], endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
    return maskPoints = "rect" === brushType ? [startPoint, {
      x: endPoint.x,
      y: startPoint.y
    }, endPoint, {
      x: startPoint.x,
      y: endPoint.y
    }] : "x" === brushType ? [{
      x: startPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[1]
    }, {
      x: startPoint.x,
      y: yRange[1]
    }] : "y" === brushType ? [{
      x: xRange[0],
      y: startPoint.y
    }, {
      x: xRange[0],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: startPoint.y
    }] : cloneDeep(this._cacheDrawPoints), maskPoints;
  }
  _addBrushMask() {
    var _a;
    const { brushStyle, hasMask } = this.attribute, brushMask = graphicCreator.polygon(Object.assign(Object.assign({
      points: cloneDeep(this._cacheDrawPoints),
      cursor: "move",
      pickable: false
    }, brushStyle), {
      opacity: hasMask ? null !== (_a = brushStyle.opacity) && void 0 !== _a ? _a : 1 : 0
    }));
    brushMask.name = `brush-${Date.now()}`, this._operatingMask = brushMask, this._container.add(brushMask), this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
  }
  _isPosInBrushMask(e) {
    const pos = this.eventPosToStagePos(e), brushMasks = this._container.getChildren();
    for (let i = 0; i < brushMasks.length; i++) {
      const { points = [], dx = 0, dy = 0 } = brushMasks[i].attribute, pointsConsiderOffset = points.map((point5) => ({
        x: point5.x + dx,
        y: point5.y + dy
      }));
      if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y)) return this._operatingMask = brushMasks[i], true;
    }
    return false;
  }
  _outOfInteractiveRange(e) {
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, pos = this.eventPosToStagePos(e);
    return pos.x > maxX || pos.x < minX || pos.y > maxY || pos.y < minY;
  }
  eventPosToStagePos(e) {
    return this.stage.eventPointTransform(e);
  }
  _dispatchBrushEvent(operateType, e) {
    this._dispatchEvent(operateType, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    });
  }
  _clearMask() {
    this._brushMaskAABBBoundsDict = {}, this._container.incrementalClearChild(), this._operatingMask = null;
  }
  _isEmptyMask() {
    return isEmpty_default(this._brushMaskAABBBoundsDict) || Object.keys(this._brushMaskAABBBoundsDict).every((key) => this._brushMaskAABBBoundsDict[key].empty());
  }
};
Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tooltip/util.js
var mergeRowAttrs = (target, ...sources) => {
  const shapeList = [target.shape, ...sources.map((s2) => null == s2 ? void 0 : s2.shape)], keyList = [target.key, ...sources.map((s2) => null == s2 ? void 0 : s2.key)], valueList = [target.value, ...sources.map((s2) => null == s2 ? void 0 : s2.value)];
  return merge(target, ...sources, {
    shape: shapeList.every(isNil_default) ? void 0 : merge({}, ...shapeList),
    key: keyList.every(isNil_default) ? void 0 : merge({}, ...keyList),
    value: valueList.every(isNil_default) ? void 0 : merge({}, ...valueList)
  });
};
var getRichTextAttribute = (attr) => {
  const { width, height, wordBreak = "break-word", textAlign, textBaseline, text: text2 } = attr;
  return Array.isArray(text2) ? {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: array(text2).map((text3) => Object.assign(Object.assign({}, attr), {
      text: text3
    }))
  } : {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: null == text2 ? void 0 : text2.text
  };
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tooltip/config.js
var defaultAttributes = {
  panel: {
    visible: true,
    cornerRadius: [3, 3, 3, 3],
    fill: "white",
    shadow: true,
    shadowBlur: 12,
    shadowColor: "rgba(0, 0, 0, 0.1)",
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowSpread: 0,
    stroke: "white"
  },
  titleStyle: {
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 14,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle"
    },
    spaceRow: 6
  },
  contentStyle: {
    shape: {
      fill: "black",
      size: 8,
      symbolType: "circle",
      spacing: 6
    },
    key: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle",
      spacing: 26
    },
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "right",
      textBaseline: "middle",
      spacing: 0
    },
    spaceRow: 6
  },
  padding: 10,
  positionX: "right",
  positionY: "bottom",
  offsetX: 10,
  offsetY: 10,
  parentBounds: new AABBBounds().setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
  autoCalculatePosition: true,
  autoMeasure: true,
  pickable: false,
  childrenPickable: false,
  zIndex: 500
};
var TOOLTIP_POSITION_ATTRIBUTES = ["pointerX", "pointerY", "offsetX", "offsetY", "positionX", "positionY", "parentBounds"];

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tooltip/register.js
function loadTooltipComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerText(), registerRichtext();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/tooltip/tooltip.js
loadTooltipComponent();
var Tooltip = class _Tooltip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tooltip.defaultAttributes, attributes), options), this.name = "tooltip";
  }
  render() {
    var _a;
    const { visible, content, panel, keyWidth, valueWidth, hasContentShape, autoCalculatePosition, autoMeasure, align } = this.attribute;
    if (!visible) return void this.hideAll();
    autoMeasure && _Tooltip.measureTooltip(this.attribute), autoCalculatePosition && _Tooltip.calculateTooltipPosition(this.attribute);
    const padding = normalizePadding(this.attribute.padding);
    this._tooltipPanel = this.createOrUpdateChild("tooltip-background", Object.assign({
      visible: true
    }, panel), "rect"), this._tooltipTitleContainer = this.createOrUpdateChild("tooltip-title", {
      visible: true,
      x: padding[3],
      y: padding[0]
    }, "group");
    const titleAttr = _Tooltip.getTitleAttr(this.attribute);
    this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-shape", merge({
      symbolType: "circle"
    }, titleAttr.shape, {
      visible: isVisible(titleAttr) && isVisible(titleAttr.shape)
    }), "symbol"), "object" != typeof titleAttr.value.text || null === titleAttr.value.text || "rich" !== titleAttr.value.text.type && "html" !== titleAttr.value.text.type ? titleAttr.value.multiLine ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      text: null !== (_a = titleAttr.value.text) && void 0 !== _a ? _a : "",
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, titleAttr.value), "text") : "rich" === titleAttr.value.text.type ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : "html" === titleAttr.value.text.type && (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      html: Object.assign(Object.assign({
        dom: titleAttr.value.text.text
      }, DEFAULT_HTML_TEXT_SPEC), titleAttr.value),
      visible: isVisible(titleAttr) && isVisible(titleAttr.value),
      width: titleAttr.value.width,
      height: titleAttr.value.height,
      wordBreak: titleAttr.value.wordBreak,
      textAlign: titleAttr.value.textAlign,
      textBaseline: titleAttr.value.textBaseline,
      singleLine: false,
      textConfig: []
    }, titleAttr.value), "richtext"));
    const titlePaddingLeft = isVisible(titleAttr.shape) ? titleAttr.shape.size + titleAttr.shape.spacing : 0, { textAlign, textBaseline } = titleAttr.value, contentWidth = panel.width - padding[3] - padding[0] - titlePaddingLeft;
    "center" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth / 2) : "right" === textAlign || "end" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth) : this._tooltipTitle.setAttribute("x", titlePaddingLeft), "bottom" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height) : "middle" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height / 2) : this._tooltipTitle.setAttribute("y", 0);
    const titleHeight = isVisible(titleAttr) ? titleAttr.height + titleAttr.spaceRow : 0;
    if (this._tooltipContent = this.createOrUpdateChild("tooltip-content", {
      visible: true
    }, "group"), this._tooltipContent.removeAllChild(true), content && content.length) {
      this._tooltipContent.setAttribute("x", padding[3]), this._tooltipContent.setAttribute("y", padding[0] + titleHeight);
      let lastYPos = 0;
      content.forEach((item, i) => {
        const itemAttr = _Tooltip.getContentAttr(this.attribute, i);
        if (!isVisible(itemAttr)) return;
        const itemGroupName = `tooltip-content-${i}`, itemGroup = this._tooltipContent.createOrUpdateChild(itemGroupName, {
          visible: true,
          x: 0,
          y: lastYPos
        }, "group"), shapeOffsetWidth = itemAttr.shape.size + itemAttr.shape.spacing;
        let x = "right" === align ? (hasContentShape ? shapeOffsetWidth : 0) + (isVisible(itemAttr.key) ? keyWidth + itemAttr.key.spacing : 0) + (isVisible(itemAttr.value) ? valueWidth : 0) : 0;
        this._createShape("right" === align ? x - itemAttr.shape.size / 2 : x + itemAttr.shape.size / 2, itemAttr, itemGroup, itemGroupName), hasContentShape && ("right" === align ? x -= shapeOffsetWidth : x += shapeOffsetWidth);
        const keyGraphic = this._createKey(itemAttr, itemGroup, itemGroupName);
        keyGraphic && (alignTextInLine(align, keyGraphic, itemAttr.key.textAlign, x, keyWidth), keyGraphic.setAttribute("y", 0), "right" === align ? x -= keyWidth + itemAttr.key.spacing : x += keyWidth + itemAttr.key.spacing);
        const valueGraphic = this._createValue(itemAttr, itemGroup, itemGroupName);
        if (valueGraphic) {
          let textAlign2 = "right";
          isValid_default(itemAttr.value.textAlign) ? textAlign2 = itemAttr.value.textAlign : isVisible(itemAttr.key) || "right" === align || (textAlign2 = "left"), valueGraphic.setAttribute("textAlign", textAlign2), alignTextInLine(align, valueGraphic, textAlign2, x, valueWidth), valueGraphic.setAttribute("y", 0);
        }
        lastYPos += itemAttr.height + itemAttr.spaceRow;
      });
    }
  }
  _createShape(x, itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.shape)) return itemGroup.createOrUpdateChild(`${itemGroupName}-shape`, Object.assign({
      visible: true,
      x,
      y: itemAttr.shape.size / 2 + ((null !== (_a = calculateLineHeight(itemAttr.key.lineHeight, itemAttr.key.fontSize)) && void 0 !== _a ? _a : itemAttr.key.fontSize) - itemAttr.shape.size) / 2
    }, itemAttr.shape), "symbol");
  }
  _createKey(itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.key)) {
      let element;
      return element = itemAttr.key.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.key)), {
        textBaseline: "top"
      }), "richtext") : "object" != typeof itemAttr.key.text || null === itemAttr.key.text || "rich" !== itemAttr.key.text.type && "html" !== itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
        visible: true,
        text: null !== (_a = itemAttr.key.text) && void 0 !== _a ? _a : ""
      }, itemAttr.key), {
        textBaseline: "top"
      }), "text") : "rich" === itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.key)), {
        textBaseline: "top"
      }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
        html: Object.assign(Object.assign({
          dom: itemAttr.key.text.text
        }, DEFAULT_HTML_TEXT_SPEC), itemAttr.key)
      }, "richtext"), element;
    }
  }
  _createValue(itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.value)) {
      let element;
      return element = itemAttr.value.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.value)), {
        textBaseline: "top"
      }), "richtext") : "object" != typeof itemAttr.value.text || null === itemAttr.value.text || "rich" !== itemAttr.value.text.type && "html" !== itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true,
        text: null !== (_a = itemAttr.value.text) && void 0 !== _a ? _a : ""
      }, itemAttr.value), {
        textBaseline: "top"
      }), "text") : "rich" === itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.value)), {
        textBaseline: "top"
      }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
        html: Object.assign({
          dom: itemAttr.value.text.text,
          container: "",
          width: 30,
          height: 30,
          style: {}
        }, itemAttr.value)
      }, "richtext"), element;
    }
  }
  setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this.attribute.autoCalculatePosition && keys2.every((key) => TOOLTIP_POSITION_ATTRIBUTES.includes(key)) ? (this._mergeAttributes(params2, keys2), isNil_default(this.attribute.panel.width) && this.attribute.autoMeasure && _Tooltip.measureTooltip(this.attribute), _Tooltip.calculateTooltipPosition(this.attribute), super.setAttributes({
      x: this.attribute.x,
      y: this.attribute.y
    }, forceUpdateTag)) : super.setAttributes(params2, forceUpdateTag);
  }
  static calculateTooltipPosition(attribute) {
    const { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = attribute.panel, { offsetX, offsetY, pointerX, pointerY, positionX, positionY, parentBounds } = attribute;
    let x = pointerX, y = pointerY;
    return "left" === positionX ? x -= tooltipBoxWidth + offsetX : "center" === positionX ? x -= tooltipBoxWidth / 2 : x += offsetX, "top" === positionY ? y -= tooltipBoxHeight + offsetY : "middle" === positionY ? y -= tooltipBoxHeight / 2 : y += offsetY, x + tooltipBoxWidth > parentBounds.x2 && (x -= tooltipBoxWidth + offsetX), y + tooltipBoxHeight > parentBounds.y2 && (y -= tooltipBoxHeight + offsetY), x < parentBounds.x1 && (x = parentBounds.x1), y < parentBounds.y1 && (y = parentBounds.y1), attribute.x = x, attribute.y = y, attribute;
  }
  static measureTooltip(attribute) {
    const { content, contentStyle } = attribute, padding = normalizePadding(attribute.padding), titleAttr = _Tooltip.getTitleAttr(attribute);
    let maxWidth = 0, containerHeight = padding[0] + padding[2], titleMaxHeight = 0;
    const { value: titleValue, shape: titleShape } = titleAttr, { visible: titleHasShape = false, symbolType: titleShapeType = "" } = null != titleShape ? titleShape : {};
    if (isValid_default(titleValue) && "object" != typeof titleAttr.value.text) {
      const { width, height } = initTextMeasure(titleValue).quickMeasure(titleValue.text);
      maxWidth = width, titleMaxHeight = height;
    }
    if (titleHasShape && builtinSymbolsMap[titleShapeType] && (maxWidth += titleShape.size + titleShape.spacing, titleMaxHeight = Math.max(titleShape.size, titleMaxHeight)), attribute.title && (attribute.title.width = maxWidth, attribute.title.height = titleMaxHeight), isVisible(titleAttr) && (containerHeight += titleMaxHeight + titleAttr.spaceRow), content && content.length) {
      const filteredContent = [];
      if (content.forEach((item, i) => {
        const itemAttr = _Tooltip.getContentAttr(attribute, i);
        (item.key || item.value) && isVisible(itemAttr) && filteredContent.push([item, itemAttr]);
      }), filteredContent.length) {
        let hasContentShape = false;
        const shapeWidths = [], keyWidths = [], valueWidths = [];
        filteredContent.forEach(([item, itemAttr], i) => {
          var _a;
          const { key, value, shape, spaceRow } = itemAttr, itemHasShape = isVisible(shape), itemShapeType = null !== (_a = null == shape ? void 0 : shape.symbolType) && void 0 !== _a ? _a : "", keyTextMeasure = initTextMeasure(key), valueTextMeasure = initTextMeasure(value);
          let itemHeight = 0;
          if (isVisible(key)) {
            const { width, height } = keyTextMeasure.quickMeasure(key.text);
            keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          if (isVisible(value)) {
            const { width, height } = valueTextMeasure.quickMeasure(value.text);
            valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          itemHasShape && builtinSymbolsMap[itemShapeType] && (hasContentShape = true, shapeWidths.push(shape.size), itemHeight = Math.max(shape.size, itemHeight)), item.height = itemHeight, containerHeight += itemHeight, i < filteredContent.length - 1 && (containerHeight += null != spaceRow ? spaceRow : contentStyle.spaceRow);
        });
        const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : 0, maxKeyWidth = keyWidths.length ? Math.max(...keyWidths) : 0, maxValueWidth = valueWidths.length ? Math.max(...valueWidths) : 0;
        maxWidth = Math.max(maxKeyWidth + maxValueWidth + contentStyle.key.spacing + contentStyle.value.spacing + (hasContentShape ? maxShapeWidth + contentStyle.shape.spacing : 0), maxWidth), content.forEach((item) => {
          item.width = maxWidth;
        }), attribute.hasContentShape = hasContentShape, attribute.keyWidth = maxKeyWidth, attribute.valueWidth = maxValueWidth;
      }
    }
    return attribute.panel.width = maxWidth + padding[1] + padding[3], attribute.panel.height = containerHeight, attribute;
  }
  static getTitleAttr(attribute) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.titleStyle, _Tooltip.defaultAttributes.title, attribute.titleStyle, attribute.title);
  }
  static getContentAttr(attribute, index) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.contentStyle, attribute.contentStyle, attribute.content[index]);
  }
};
Tooltip.defaultAttributes = defaultAttributes;

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/timeline/register.js
function loadTimelineComponent() {
  registerGroup(), registerText(), registerSymbol(), registerLine();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/timeline/timeline.js
loadTimelineComponent();
var Timeline = class _Timeline extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Timeline.defaultAttributes, attributes)), this.name = "timeline";
  }
  render() {
    const { width, lineStyle, activeLineStyle, symbolStyle, activeSymbolStyle, labelStyle, activeLabelStyle, times, pointLayoutMode, labelSpace, clipRange, animation } = this.attribute;
    if (!times || !times.length) return;
    const symbolHeight = (isArray_default(symbolStyle.size) ? symbolStyle.size[1] : symbolStyle.size) || 0, activeSymbolHeight = (isArray_default(activeSymbolStyle.size) ? activeSymbolStyle.size[1] : activeSymbolStyle.size) || 0, lineSymbolHeight = Math.max(lineStyle.lineWidth || 0, activeLineStyle.lineWidth || 0, symbolHeight, activeSymbolHeight), lineY = lineSymbolHeight / 2, lineAttr = {
      y: lineY,
      points: [{
        x: 0,
        y: 0
      }, {
        x: width,
        y: 0
      }]
    };
    this._line = this.createOrUpdateChild("line-axes", Object.assign(Object.assign({}, lineStyle), lineAttr), "line"), this._activeLine = this.createOrUpdateChild("active-line-axes", Object.assign(Object.assign(Object.assign({}, activeLineStyle), lineAttr), {
      clipRange
    }), "line");
    const activeWidth = width * clipRange, symbolGroup = this.createOrUpdateChild("symbol-group", {
      y: lineY
    }, "group"), symbolSpace = 1 === times.length ? width : "space-between" === pointLayoutMode ? width / (times.length - 1) : width / times.length, symbolStartX = "space-between" === pointLayoutMode ? 0 : symbolSpace / 2;
    this._timesPercent = times.map((_, i) => (symbolStartX + symbolSpace * i) / width), times.forEach((item, i) => {
      const x = this._timesPercent[i] * width;
      symbolGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, symbolStyle), {
        x
      }), "symbol");
    }), this._symbolGroup = symbolGroup;
    const labelY = lineSymbolHeight + labelSpace, labelGroup = this.createOrUpdateChild("label-group", {
      y: labelY
    }, "group");
    times.forEach((item, i) => {
      const x = this._timesPercent[i] * width;
      labelGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, labelStyle), {
        x,
        text: item.label
      }), "text");
    }), this._labelGroup = labelGroup;
    const setActive = (group, activeStyle) => {
      group.forEachChildren((label) => {
        if (label.currentStates) {
          const currentStates = label.currentStates;
          label.clearStates(), label.useStates(currentStates, false);
        }
        label.states = {
          active: activeStyle
        }, label.attribute.x <= activeWidth && label.useStates(["active"], animation);
      });
    };
    setActive(labelGroup, activeLabelStyle), setActive(symbolGroup, activeSymbolStyle);
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig, { activeLabelStyle, activeSymbolStyle } = this.attribute, percent = duration / 1e3, lineDuration = 500 * percent, activeLineDuration = 200 * percent, perSymbolDuration = 100 * percent, perSymbolNormalDuration = 90 * percent, symbolDelay = 100 * percent, symbolNormalDelay = 600 * percent;
    if (this._line && (this._line.setAttributes({
      clipRange: 0
    }), this._line.animate().to({
      clipRange: 1
    }, lineDuration, easing)), this._activeLine && (this._activeLine.setAttributes({
      opacity: 0
    }), this._activeLine.animate().wait(500).to({
      opacity: 1
    }, activeLineDuration, easing)), this._symbolGroup) {
      const size = this._symbolGroup.count - 1, delay = percent * (1 === size ? 0 : 400 / (size - 1)), delayNormal = percent * (1 === size ? 0 : 240 / (size - 1));
      this._symbolGroup.forEachChildren((symbol, i) => {
        const originAttrs = {};
        Object.keys(activeSymbolStyle).forEach((k2) => {
          originAttrs[k2] = symbol.attribute[k2];
        }), symbol.setAttributes({
          opacity: 0
        }), symbol.animate().wait(symbolDelay + delay * i).to({
          opacity: 1
        }, perSymbolDuration, easing), symbol.animate().wait(symbolNormalDelay + delayNormal * i).to(Object.assign({}, activeSymbolStyle), perSymbolNormalDuration, easing).to(Object.assign({}, originAttrs), perSymbolNormalDuration, easing);
      });
    }
    if (this._labelGroup) {
      const size = this._labelGroup.count - 1, delay = percent * (1 === size ? 0 : 400 / (size - 1)), delayNormal = percent * (1 === size ? 0 : 240 / (size - 1));
      this._labelGroup.forEachChildren((label, i) => {
        const originAttrs = {};
        Object.keys(activeLabelStyle).forEach((k2) => {
          originAttrs[k2] = label.attribute[k2];
        }), label.setAttributes({
          opacity: 0
        }), label.animate().wait(symbolDelay + delay * i).to({
          opacity: 1
        }, perSymbolDuration, easing), label.animate().wait(symbolNormalDelay + delayNormal * i).to(Object.assign({
          dy: 10
        }, activeLabelStyle), perSymbolNormalDuration, easing).to(Object.assign({
          dy: 0
        }, originAttrs), perSymbolNormalDuration, easing);
      });
    }
  }
  goto(flag, animateConfig) {
    let { clipRange } = this.attribute;
    const { animation } = this.attribute;
    if (flag > 0) {
      if (clipRange >= 1) return;
      clipRange < 0 && (clipRange = 0);
    } else {
      if (clipRange <= 0) return;
      clipRange > 1 && (clipRange = 1);
    }
    clipRange !== this.attribute.clipRange && this.setAttributes({
      clipRange
    });
    let i = 0;
    for (; i < this._timesPercent.length && !(clipRange < this._timesPercent[i]); i++) ;
    const nextClipRange = flag > 0 ? this._timesPercent[i] || 1 : this._timesPercent[i - 1] || 0;
    if (animation) {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this.animate().to({
        clipRange: nextClipRange
      }, duration, easing);
    } else this.setAttributes({
      clipRange: nextClipRange
    });
  }
  forward(animateConfig) {
    this.goto(1, animateConfig);
  }
  backward(animateConfig) {
    this.goto(-1, animateConfig);
  }
};
Timeline.defaultAttributes = {
  labelSpace: 10,
  pointLayoutMode: "space-around",
  animation: true,
  symbolStyle: {
    fill: "black",
    size: 12,
    symbolType: "circle"
  },
  activeSymbolStyle: {
    fill: "orange",
    size: 16
  },
  lineStyle: {
    lineDash: [2, 2],
    lineCap: "butt",
    stroke: "black",
    lineWidth: 2
  },
  activeLineStyle: {
    stroke: "orange",
    lineWidth: 4
  },
  labelStyle: {
    fontSize: 12,
    fill: "black",
    textAlign: "center",
    textBaseline: "top"
  },
  activeLabelStyle: {
    fontSize: 14,
    fill: "orange"
  },
  clipRange: 0
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/checkbox/register.js
function loadCheckBoxComponent() {
  registerGroup(), registerRect(), registerText(), registerImage();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/checkbox/checkbox.js
var checkSvg = '<svg width="200" height="200" viewBox="0 0 1024 1024" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z"></path></svg>';
var indeterminateSvg = '<svg width="200" height="200" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none"><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="5" d="M5 12h14"/></svg>';
loadCheckBoxComponent();
var CheckBox = class _CheckBox extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CheckBox.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || (this.attribute.checked ? (this.setAttribute("checked", false), this.setAttribute("indeterminate", false)) : (this.setAttribute("checked", true), this.setAttribute("indeterminate", false)), this._dispatchEvent("checkbox_state_change", {
        eventType: "checkbox_state_change",
        checked: this.attribute.checked
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderBox(), this.renderIcon(), this.renderText(), this.layout();
  }
  renderBox() {
    this._box = new Rect(merge({}, this.attribute.box));
    const isCheckedOrIndeterminate = this.attribute.checked || this.attribute.indeterminate;
    isCheckedOrIndeterminate && this.attribute.disabled ? this._box.setAttributes({
      fill: this.attribute.box.disableCheckedFill,
      stroke: this.attribute.box.disableCheckedStroke
    }) : isCheckedOrIndeterminate ? this._box.setAttributes({
      fill: this.attribute.box.checkedFill,
      stroke: this.attribute.box.checkedStroke
    }) : this.attribute.disabled && this._box.setAttributes({
      fill: this.attribute.box.disableFill
    }), this.appendChild(this._box);
  }
  renderIcon() {
    this._checkIcon = new Image2(merge({
      image: this.attribute.icon.checkIconImage
    }, this.attribute.icon)), this.appendChild(this._checkIcon), this._indeterminateIcon = new Image2(merge({
      image: this.attribute.icon.indeterminateIconImage
    }, this.attribute.icon)), this.appendChild(this._indeterminateIcon), this.attribute.checked ? (this._checkIcon.setAttribute("visible", true), this._indeterminateIcon.setAttribute("visible", false)) : this.attribute.indeterminate ? (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", true)) : (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", false));
  }
  renderText() {
    this._text = new Text(merge({
      wrap: true
    }, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    const boxHeight = this.attribute.box.height, iconHeight = this.attribute.icon.height, textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(boxHeight, iconHeight, textHeight), boxY = maxHeight / 2 - boxHeight / 2, iconY = maxHeight / 2 - iconHeight / 2, textY = maxHeight / 2 - textHeight / 2, boxWidth = this.attribute.box.width, iconWidth = this.attribute.icon.width, maxWidth = Math.max(boxWidth, iconWidth), boxX = maxWidth / 2 - boxWidth / 2, iconX = maxWidth / 2 - iconWidth / 2, textX = maxWidth + this.attribute.spaceBetweenTextAndIcon;
    this._box.setAttributes({
      x: boxX,
      y: boxY
    }), this._checkIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._indeterminateIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._text.setAttributes({
      x: textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _CheckBox.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
CheckBox.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  indeterminate: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  spaceBetweenTextAndIcon: 8,
  text: {
    text: "text",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    textBaseline: "top",
    pickable: false
  },
  icon: {
    checkIconImage: checkSvg,
    indeterminateIconImage: indeterminateSvg,
    width: 10,
    height: 10,
    pickable: false
  },
  box: {
    width: 14,
    height: 14,
    cornerRadius: 2,
    fill: "#fff",
    stroke: "rgb(229,230,235)",
    disableFill: "rgb(242,243,245)",
    checkedFill: "rgb(22, 93, 255)",
    checkedStroke: "rgb(22, 93, 255)",
    disableCheckedFill: "rgb(148, 191, 255)",
    disableCheckedStroke: "rgb(148, 191, 255)",
    pickable: false
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/radio/register.js
function loadRadioComponent() {
  registerGroup(), registerRect(), registerWrapText(), registerImage();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/radio/radio.js
loadRadioComponent();
var Radio = class _Radio extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Radio.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || this.attribute.checked || (this.setAttribute("checked", true), this._dispatchEvent("radio_checked", {
        eventType: "radio_checked",
        target: this
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderCircle(), this.renderText(), this.layout();
  }
  renderCircle() {
    this._circle = new Arc(merge({}, this.attribute.circle));
    const isChecked = this.attribute.checked;
    isChecked && this.attribute.disabled ? this._circle.setAttributes({
      fill: this.attribute.circle.disableCheckedFill,
      stroke: this.attribute.circle.disableCheckedStroke
    }) : isChecked ? this._circle.setAttributes({
      fill: this.attribute.circle.checkedFill,
      stroke: this.attribute.circle.checkedStroke
    }) : this.attribute.disabled && this._circle.setAttributes({
      fill: this.attribute.circle.disableFill
    }), this.appendChild(this._circle);
  }
  renderText() {
    this._text = new Text(merge({}, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    const circleHeight = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth), textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(circleHeight, textHeight), circleY = maxHeight / 2 - circleHeight / 2 + this.attribute.circle.outerRadius + this.attribute.circle.lineWidth, textY = maxHeight / 2 - textHeight / 2, circleWidth = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth), circleX = this.attribute.circle.outerRadius + this.attribute.circle.lineWidth, textX = circleWidth + this.attribute.spaceBetweenTextAndIcon;
    this._circle.setAttributes({
      x: circleX,
      y: circleY
    }), this._text.setAttributes({
      x: textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Radio.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
Radio.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  spaceBetweenTextAndIcon: 8,
  text: {
    text: "text",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    textBaseline: "top",
    pickable: false
  },
  circle: {
    outerRadius: 7,
    innerRadius: 3,
    startAngle: 0,
    endAngle: 2 * Math.PI,
    lineWidth: 1,
    fill: "#fff",
    stroke: "rgb(229,230,235)",
    disableFill: "rgb(242,243,245)",
    checkedFill: "rgb(22, 93, 255)",
    checkedStroke: "rgb(22, 93, 255)",
    disableCheckedFill: "rgb(148, 191, 255)",
    disableCheckedStroke: "rgb(148, 191, 255)",
    pickable: false
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/empty-tip/register.js
function loadEmptyTipComponent() {
  registerGroup(), registerText(), registerImage();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/empty-tip/empty-tip.js
var emptyTipSvg = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
loadEmptyTipComponent();
var EmptyTip = class _EmptyTip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _EmptyTip.defaultAttributes, attributes));
  }
  render() {
    this.removeAllChild(true), this.renderIcon(), this.renderText(), this.layout();
  }
  renderIcon() {
    this._emptyTipIcon = new Image2(merge({
      image: this.attribute.icon.image
    }, this.attribute.icon)), this.appendChild(this._emptyTipIcon);
  }
  renderText() {
    this._text = new Text(merge({
      wrap: true
    }, this.attribute.text)), this.appendChild(this._text);
  }
  layout() {
    const iconHeight = this.attribute.icon.height, textHeight = this._text.AABBBounds.height(), iconWidth = this.attribute.icon.width, { width, height, spaceBetweenTextAndIcon } = this.attribute;
    this._emptyTipIcon.setAttribute("x", width / 2 - iconWidth / 2), this._emptyTipIcon.setAttribute("y", height / 2 - iconHeight / 2 - textHeight / 2 - spaceBetweenTextAndIcon / 2), this._text.setAttribute("x", width / 2), this._text.setAttribute("textAlign", "center"), this._text.setAttribute("y", height / 2 + iconHeight / 2 + spaceBetweenTextAndIcon / 2), this._text.setAttribute("textBaseline", "middle");
  }
};
EmptyTip.defaultAttributes = {
  spaceBetweenTextAndIcon: 20,
  text: {
    text: "no data",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    pickable: false
  },
  icon: {
    image: emptyTipSvg,
    width: 100,
    height: 100,
    pickable: false
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/weather/weather-box.js
function random() {
  return Math.random();
}
function createUniformRandom(count) {
  const result2 = [], step = 1 / count;
  for (let i = 0; i < count; i++) result2.push((random() - 0.5) * step / 2 + step * i);
  result2.sort(() => Math.random() - 0.5);
  let idx = 0;
  return function(i) {
    return idx > count - 1 && (idx = 0), void 0 === i && (i = idx, idx++), result2[i];
  };
}
var WeatherBox = class _WeatherBox extends AbstractComponent {
  constructor(attributes, options) {
    var _a;
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _WeatherBox.defaultAttributes, attributes)), this.name = "weatherBox", this.timeline = null !== (_a = null == options ? void 0 : options.timeline) && void 0 !== _a ? _a : new DefaultTimeline();
  }
  render() {
    const { rainRatio, rainIconPath, snowRatio, snowIconPath, rainCountThreshold, snowCountThreshold, windRatio, rainSizeRange, snowSizeRange, rainSpeed, snowSpeed, width, height, windIconPath, windSize, windSpeed } = this.attribute;
    this.attribute.clip = true;
    const windAngle = -windRatio * Math.PI / 4, rainGroup = this.createOrUpdateChild("rain-container", {
      zIndex: 1,
      width,
      height
    }, "group");
    rainRatio > 0 && this.generateRainOrSnow("rain", rainRatio, rainCountThreshold, windRatio, rainGroup, rainIconPath, windAngle, rainSizeRange, rainSpeed);
    const snowGroup = this.createOrUpdateChild("snow-container", {
      zIndex: 1,
      width,
      height
    }, "group");
    snowRatio > 0 && this.generateRainOrSnow("snow", snowRatio, snowCountThreshold, windRatio, snowGroup, snowIconPath, windAngle, snowSizeRange, snowSpeed);
    const windGroup = this.createOrUpdateChild("wind-container", {
      zIndex: 0,
      width,
      height
    }, "group");
    windRatio > 0 && this.generateWind(windRatio, windIconPath, windGroup, windSize, windSpeed);
  }
  generateWind(windRatio, windIconPath, group, size, speed) {
    const { width, height } = group.attribute, { windAnimateEffect, windStyle = {} } = this.attribute;
    let fromAttribute = {
      opacity: 0,
      clipRange: 1
    }, toAttribute = {
      opacity: 1,
      clipRange: 1
    };
    "clipRange" === windAnimateEffect && (fromAttribute = {
      clipRange: 0,
      opacity: 1
    }, toAttribute = {
      clipRange: 1,
      opacity: 1
    });
    const wind = group.createOrUpdateChild("wind", Object.assign(Object.assign({
      x: (width - size) / 2,
      y: (height - size) / 2,
      symbolType: windIconPath,
      size,
      stroke: "white",
      lineWidth: 2,
      dx: -size / 2,
      dy: -size / 2
    }, windStyle), fromAttribute), "symbol"), duration = speed / 4 * 1e3;
    new Animate(void 0, this.timeline).bind(wind).to(fromAttribute, duration, "linear").to(toAttribute, duration, "linear").wait(duration / 2).loop(1 / 0);
  }
  generateRainOrSnow(type, ratio, threshold, windRatio, group, path, windAngle, sizeRange, speed) {
    let { width } = group.attribute;
    const { height } = group.attribute, { snowRainBottomPadding, rainStyle = {}, snowStyle = {} } = this.attribute;
    let maxCount = Math.round(ratio * threshold);
    windRatio > 0 && (maxCount *= Math.round(1 + windRatio)), width *= Math.round(1 + windRatio);
    const uniformRandomX = createUniformRandom(maxCount), uniformRandomY = createUniformRandom(maxCount);
    for (let i = 0; i < maxCount; i++) {
      const x = uniformRandomX(), y = uniformRandomY(), size = sizeRange[0] + random() * (sizeRange[1] - sizeRange[0]), startX = x * width - (windAngle ? height * Math.tan(Math.abs(windAngle)) : 0), startY = -y * height, particle = group.createOrUpdateChild(`${type}-${i}`, Object.assign({
        x: startX,
        y: startY,
        symbolType: path,
        size,
        fill: "white",
        angle: windAngle
      }, "rain" === type ? rainStyle : snowStyle), "symbol"), duration = 1 / speed / 2 * (1 + y) * 1e3;
      let endX = x * width;
      "rain" === type && windAngle && (endX = startX + (1 + y) * height * Math.tan(Math.abs(windAngle))), new Animate(void 0, this.timeline).bind(particle).to({
        x: endX,
        y: height - snowRainBottomPadding
      }, duration, "linear").loop(1 / 0), new Animate(void 0, this.timeline).bind(particle).to({
        opacity: 0
      }, duration, "quintIn").loop(1 / 0);
    }
  }
};
WeatherBox.defaultAttributes = {
  snowIconPath: "M512 64c24.7 0 44.8 20.1 44.8 44.8v43.1l29.3-15.5c21.9-11.6 49-3.2 60.5 18.7s3.2 49-18.7 60.5l-71.2 37.6v85.2c32 8.2 60.6 25.1 83.1 48l73.8-42.6-3-80.4c-0.9-24.7 18.4-45.5 43.1-46.4 24.7-0.9 45.5 18.4 46.4 43.1l1.2 33.1 37.3-21.5c21.4-12.4 48.8-5 61.2 16.4 12.4 21.4 5 48.8-16.4 61.2l-37.3 21.5 28.1 17.6c21 13.2 27.3 40.8 14.1 61.8-13.2 20.9-40.8 27.3-61.8 14.1l-68.2-42.8-73.6 42.5c4.2 15.3 6.5 31.4 6.5 48s-2.3 32.7-6.5 48l73.8 42.6 68.2-42.8c20.9-13.2 48.6-6.8 61.8 14.1 13.2 21 6.8 48.6-14.1 61.8l-28.1 17.6 37.3 21.5c21.4 12.4 28.8 39.8 16.4 61.2-12.4 21.4-39.8 28.8-61.2 16.4l-37.3-21.5-1.2 33.1c-0.9 24.7-21.7 44-46.4 43.1-24.7-0.9-44-21.7-43.1-46.4l3-80.4-73.8-42.6c-22.5 22.9-51 39.8-83.1 48v85.2l71.2 37.6c21.9 11.6 30.2 38.7 18.7 60.5-11.6 21.9-38.7 30.2-60.5 18.7L557 872.2v43.1c0 24.7-20.1 44.8-44.8 44.8-24.7 0-44.8-20.1-44.8-44.8v-43.1l-29.3 15.5c-21.9 11.6-49 3.2-60.5-18.7-11.6-21.9-3.2-49 18.7-60.5l71.2-37.6v-85.2c-32-8.2-60.6-25.1-83.1-48l-73.8 42.6 3 80.4c0.9 24.7-18.4 45.5-43.1 46.4-24.7 0.9-45.5-18.4-46.4-43.1l-1.2-33.1-37.3 21.5c-21.4 12.4-48.8 5-61.2-16.4s-5-48.8 16.4-61.2l37.3-21.5-28.1-17.6c-21-13.2-27.3-40.8-14.1-61.8 13.2-20.9 40.8-27.3 61.8-14.1l68.2 42.8 73.8-42.6c-4.2-15.3-6.5-31.4-6.5-48s2.3-32.7 6.5-48l-73.8-42.6-68.2 42.8c-21 13.2-48.6 6.8-61.8-14.1-13.2-21-6.8-48.6 14.1-61.8l28.1-17.6-37.3-21.5C119 336.8 111.7 309.4 124 288c12.4-21.4 39.8-28.8 61.2-16.4l37.3 21.5 1.2-33.1c0.9-24.7 21.7-44 46.4-43.1 24.7 0.9 44 21.7 43.1 46.4l-3 80.4 73.8 42.6c22.5-22.9 51-39.8 83.1-48v-85.2L396 215.6c-21.9-11.6-30.2-38.7-18.7-60.5 11.6-21.9 38.7-30.2 60.5-18.7l29.3 15.5v-43.1C467.2 84.1 487.3 64 512 64z m0 537.6c49.5 0 89.6-40.1 89.6-89.6s-40.1-89.6-89.6-89.6-89.6 40.1-89.6 89.6 40.1 89.6 89.6 89.6z",
  rainIconPath: "M802.94208 583.04c19.328 38.016 29.056 78.336 29.056 120.96a313.216 313.216 0 0 1-44.032 161.536 324.48 324.48 0 0 1-114.56 114.944c-23.552 13.696-49.024 24.32-76.416 32-27.264 7.68-55.68 11.52-84.992 11.52-29.44 0-57.6-3.84-84.992-11.52a331.136 331.136 0 0 1-76.544-32 337.536 337.536 0 0 1-65.024-49.92 337.536 337.536 0 0 1-49.92-65.024 331.136 331.136 0 0 1-32-76.544A313.216 313.216 0 0 1 191.99808 704c0-42.24 9.344-82.56 28.032-120.448L509.43808 0l293.504 583.04z",
  windIconPath: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\n      <path d="M 4.0003 14.0002 L 12.0003 14.0008 M 12.0003 14.0008 C 13.1049 14.0009 14.0003 14.8964 14.0002 16.001 C 14.0001 17.1055 13.1046 18.0009 12 18.0008 L 10.5 18.0007" stroke-linecap="round" stroke-linejoin="round"/>\n      <path d="M 7 10.0002 L 14.5 10.0008 C 15.6046 10.0009 16.5001 9.1055 16.5002 8.001 C 16.5003 6.8964 15.6049 6.0009 14.5003 6.0008 L 13.0003 6.0007" stroke-linecap="round" stroke-linejoin="round"/>\n    </svg>',
  windRatio: 0,
  rainRatio: 0,
  snowRatio: 0,
  rainCountThreshold: 10,
  snowCountThreshold: 10,
  rainSizeRange: [5, 10],
  snowSizeRange: [5, 13],
  windSize: 30,
  rainSpeed: 1,
  snowSpeed: 0.5,
  windSpeed: 1,
  windAnimateEffect: "fade",
  rainStyle: {},
  snowStyle: {},
  windStyle: {
    opacity: 0.8
  },
  snowRainBottomPadding: 0
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/switch/register.js
function loadSwitchComponent() {
  registerGroup(), registerRect(), registerText(), registerCircle();
}

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/switch/switch.js
loadSwitchComponent();
var Switch = class _Switch extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Switch.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || (this.attribute.checked ? this.setAttribute("checked", false) : this.setAttribute("checked", true), this._dispatchEvent("switch_state_change", {
        eventType: "switch_state_change",
        checked: this.attribute.checked
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderBox(), this.renderCircle(), this.renderText(), this.layout();
  }
  renderBox() {
    this._box = new Rect(merge({}, this.attribute.box)), this.attribute.disabled && this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.disableCheckedFill
    }) : this.attribute.disabled && !this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.disableUncheckedFill
    }) : this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.checkedFill
    }) : this._box.setAttributes({
      fill: this.attribute.box.uncheckedFill
    }), this.appendChild(this._box);
  }
  renderCircle() {
    this._circle = new Circle(merge({}, this.attribute.circle)), this.appendChild(this._circle);
  }
  renderText() {
    var _a, _b, _c;
    this._text = new Text(merge({}, null !== (_a = this.attribute.text) && void 0 !== _a ? _a : {})), this.attribute.checked && (null === (_b = this.attribute.text) || void 0 === _b ? void 0 : _b.checkedText) ? this._text.setAttributes({
      text: this.attribute.text.checkedText
    }) : (null === (_c = this.attribute.text) || void 0 === _c ? void 0 : _c.uncheckedText) && this._text.setAttributes({
      text: this.attribute.text.uncheckedText
    }), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const space = this.attribute.spaceBetweenTextAndCircle, radius = this.attribute.circle.radius, boxHeight = this.attribute.box.height, circleHeight = 2 * radius, textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(boxHeight, circleHeight, textHeight), circleY = maxHeight / 2 - circleHeight / 2 + radius, textY = maxHeight / 2 - textHeight / 2, boxWidth = this.attribute.box.width, circleWidth = 2 * radius, textWidth = measureTextSize((null !== (_c = null === (_b = null === (_a = this.attribute.text) || void 0 === _a ? void 0 : _a.checkedText) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) > (null !== (_f = null === (_e = null === (_d = this.attribute.text) || void 0 === _d ? void 0 : _d.uncheckedText) || void 0 === _e ? void 0 : _e.length) && void 0 !== _f ? _f : 0) ? null !== (_h = null === (_g = this.attribute.text) || void 0 === _g ? void 0 : _g.checkedText) && void 0 !== _h ? _h : "" : null !== (_k = null === (_j = this.attribute.text) || void 0 === _j ? void 0 : _j.uncheckedText) && void 0 !== _k ? _k : "", this._text.attribute).width, maxWidth = Math.max(boxWidth, circleWidth + textWidth + 3 * space), circleX = boxHeight / 2 - circleWidth / 2 + radius, textX = circleX + radius + space;
    this._box.setAttributes({
      width: maxWidth,
      height: maxHeight
    }), this._circle.setAttributes({
      y: circleY,
      x: this.attribute.checked ? maxWidth - circleX : circleX
    }), this._text.setAttributes({
      x: this.attribute.checked ? maxWidth - textX - textWidth : textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Switch.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
Switch.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  circle: {
    radius: 8,
    fill: "#FFF",
    pickable: false
  },
  box: {
    width: 40,
    height: 24,
    cornerRadius: 12,
    uncheckedFill: "rgb(201,205,212)",
    checkedFill: "#165DFF",
    disableUncheckedFill: "rgb(242,243,245)",
    disableCheckedFill: "rgb(148,191,255)",
    pickable: false
  },
  text: {
    textAlign: "left",
    textBaseline: "top",
    pickable: false
  },
  spaceBetweenTextAndCircle: 6
};

// node_modules/@visactor/vtable/node_modules/@visactor/vrender-components/es/label-item/label-item.js
var StoryLabelItem = class _StoryLabelItem extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _StoryLabelItem.defaultAttributes, attributes));
  }
  render() {
    const { contentOffsetX, contentOffsetY, lineStyle, symbolStartStyle, symbolEndStyle, symbolStartOuterStyle, titleTop: titleTopText, titleBottom: titleBottomText, titleTopStyle, titleBottomStyle, titleSpace, titleTopPanelStyle, titleBottomPanelStyle, theme: theme4 } = this.attribute, group = this.createOrUpdateChild("label-item-container", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group"), symbolStart = group.createOrUpdateChild("label-item-symbol-start", Object.assign({
      x: 0,
      y: 0
    }, symbolStartStyle), "symbol"), symbolEnd = group.createOrUpdateChild("label-item-symbol-end", Object.assign({
      x: contentOffsetX,
      y: contentOffsetY
    }, symbolEndStyle), "symbol"), symbolStartOut = group.createOrUpdateChild("label-item-symbol-start-out", Object.assign({
      x: 0,
      y: 0
    }, symbolStartOuterStyle), "symbol"), spaceW = titleSpace[0], spaceH = titleSpace[1], titleTopGroup = group.createOrUpdateChild("label-item-title-top-group", {
      x: contentOffsetX,
      y: contentOffsetY,
      clip: true
    }, "group"), titleTop = titleTopGroup.createOrUpdateChild("label-item-title-top", Object.assign(Object.assign({
      x: spaceW,
      y: -spaceH,
      text: titleTopText
    }, titleTopStyle), {
      textBaseline: "bottom",
      textAlign: "left",
      zIndex: 10
    }), "text"), titleTopBounds = titleTop.AABBBounds;
    contentOffsetX > 0 && titleTopGroup.setAttributes({
      x: contentOffsetX - titleTopBounds.width() - 2 * spaceW
    }), titleTopGroup.setAttributes({
      width: titleTopBounds.width() + 2 * spaceW,
      height: -titleTopBounds.height() - 2 * spaceH
    });
    const titleTopPanel = titleTopGroup.createOrUpdateChild("label-item-title-top-panel", Object.assign(Object.assign({}, titleTopPanelStyle), {
      x: titleTopPanelStyle.padding.left,
      y: (titleTopGroup.attribute.height > 0 ? 0 : titleTopGroup.attribute.height) + titleTopPanelStyle.padding.top,
      width: titleTopGroup.attribute.width - titleTopPanelStyle.padding.left - titleTopPanelStyle.padding.right,
      height: (titleTopGroup.attribute.height > 0 ? 1 : -1) * titleTopGroup.attribute.height - titleTopPanelStyle.padding.bottom - titleTopPanelStyle.padding.top,
      scaleCenter: [titleTopGroup.attribute.width / 2, titleTopGroup.attribute.height / 2]
    }), "rect");
    this._titleTopPanel = titleTopPanel;
    const titleBottomGroup = group.createOrUpdateChild("label-item-title-bottom-group", {
      x: contentOffsetX,
      y: contentOffsetY,
      clip: true
    }, "group"), titleBottom = titleBottomGroup.createOrUpdateChild("label-item-title-bottom", Object.assign(Object.assign({
      x: spaceW,
      y: spaceH,
      text: titleBottomText
    }, titleBottomStyle), {
      textBaseline: "top",
      textAlign: "left",
      zIndex: 10
    }), "text"), titleBottomBounds = titleBottom.AABBBounds;
    contentOffsetX > 0 && titleBottomGroup.setAttributes({
      x: contentOffsetX - titleBottomBounds.width() - 2 * spaceW
    }), titleBottomGroup.setAttributes({
      width: titleBottomBounds.width() + 2 * spaceW,
      height: titleTopBounds.height() + 2 * spaceH
    });
    const titleBottomPanel = titleBottomGroup.createOrUpdateChild("label-item-title-bottom-panel", Object.assign(Object.assign({}, titleBottomPanelStyle), {
      x: titleBottomPanelStyle.padding.left,
      y: (titleBottomGroup.attribute.height > 0 ? 0 : titleBottomGroup.attribute.height) + titleBottomPanelStyle.padding.top,
      width: titleBottomGroup.attribute.width - titleBottomPanelStyle.padding.left - titleBottomPanelStyle.padding.right,
      height: (titleBottomGroup.attribute.height > 0 ? 1 : -1) * titleBottomGroup.attribute.height - titleBottomPanelStyle.padding.bottom - titleBottomPanelStyle.padding.top,
      scaleCenter: [titleBottomGroup.attribute.width / 2, titleBottomGroup.attribute.height / 2]
    }), "rect");
    this._titleBottomPanel = titleBottomPanel;
    const maxTextWidth = Math.max(titleTop.AABBBounds.width(), titleBottom.AABBBounds.width()) + 2 * spaceW, points = [{
      x: 0,
      y: 0
    }, contentOffsetX > 0 ? {
      x: contentOffsetX - maxTextWidth,
      y: contentOffsetY
    } : {
      x: contentOffsetX + maxTextWidth,
      y: contentOffsetY
    }, {
      x: contentOffsetX,
      y: contentOffsetY
    }];
    if ("simple" === theme4) {
      points.pop();
      const p = points[1];
      symbolEnd.setAttributes(p);
    }
    const line = group.createOrUpdateChild("label-item-line", Object.assign(Object.assign({
      x: 0,
      y: 0
    }, lineStyle), {
      points
    }), "line");
    this._symbolEnd = symbolEnd, this._symbolStart = symbolStart, this._symbolStartOuter = symbolStartOut, this._titleTop = titleTop, this._titleBottom = titleBottom, this._line = line;
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut", symbolStartOuterType = "scale", titleType = "typewriter", titlePanelType = "scale" } = animateConfig, symbolTime = duration / 10;
    let symbolStartOuterFrom, symbolStartOuterTo;
    if (this._symbolStart.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this._symbolStart.animate().to({
      scaleX: 1,
      scaleY: 1
    }, 5 * symbolTime, easing), "scale" === symbolStartOuterType ? (symbolStartOuterFrom = {
      scaleX: 0,
      scaleY: 0
    }, symbolStartOuterTo = {
      scaleX: 1,
      scaleY: 1
    }) : (symbolStartOuterFrom = {
      clipRange: 0
    }, symbolStartOuterTo = {
      clipRange: 1
    }), this._symbolStartOuter.setAttributes(symbolStartOuterFrom), this._symbolStartOuter.animate().to(symbolStartOuterTo, 5 * symbolTime, easing), this._symbolEnd.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this._symbolEnd.animate().wait(8 * symbolTime).to({
      scaleX: 1,
      scaleY: 1
    }, 2 * symbolTime, easing), this._line.setAttributes({
      clipRange: 0
    }), this._line.animate().to({
      clipRange: 1
    }, 9 * symbolTime, easing), "typewriter" === titleType) {
      const titleTopText = this._titleTop.attribute.text;
      this._titleTop.setAttributes({
        text: ""
      }), this._titleTop.animate().wait(5 * symbolTime).play(new InputText({
        text: ""
      }, {
        text: titleTopText
      }, 4 * symbolTime, "linear"));
      const titleBottomText = this._titleBottom.attribute.text;
      this._titleBottom.setAttributes({
        text: ""
      }), this._titleBottom.animate().wait(5 * symbolTime).play(new InputText({
        text: ""
      }, {
        text: titleBottomText
      }, 4 * symbolTime, "linear"));
    } else this._titleTop.setAttributes({
      dy: this._titleTop.AABBBounds.height() + 10
    }), this._titleTop.animate().wait(5 * symbolTime).to({
      dy: 0
    }, 4 * symbolTime, "linear"), this._titleBottom.setAttributes({
      dy: -(10 + this._titleBottom.AABBBounds.height())
    }), this._titleBottom.animate().wait(5 * symbolTime).to({
      dy: 0
    }, 4 * symbolTime, "linear");
    "scale" === titlePanelType ? [this._titleTopPanel, this._titleBottomPanel].forEach((panel) => {
      const scaleX = panel.attribute.scaleX;
      panel.setAttributes({
        scaleX: 0
      }), panel.animate().to({
        scaleX
      }, duration, "circInOut");
    }) : "stroke" === titlePanelType && [this._titleTopPanel, this._titleBottomPanel].forEach((panel) => {
      const b = panel.AABBBounds, totalLen = 2 * (b.width() + b.height());
      panel.setAttributes({
        lineDash: [0, 10 * totalLen]
      }), panel.animate().to({
        lineDash: [totalLen, 10 * totalLen]
      }, duration, "quadOut");
    });
  }
  disappearAnimate(animateConfig) {
    if ("scale" === animateConfig.mode) {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this.animate().to({
        scaleX: 0,
        scaleY: 0
      }, duration, easing);
    } else {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this._line.animate().to({
        clipRange: 0
      }, duration, easing), this._symbolStart.animate().wait(duration / 2).to({
        scaleX: 0,
        scaleY: 0
      }, duration / 2, easing), this._symbolEnd.animate().to({
        scaleX: 0,
        scaleY: 0
      }, duration, easing), this._titleTop.animate().to({
        dy: this._titleTop.AABBBounds.height() + 10
      }, duration / 2, easing), this._titleBottom.animate().to({
        dy: -(10 + this._titleBottom.AABBBounds.height())
      }, duration / 2, easing), this._symbolStartOuter.animate().wait(duration / 2).to({
        clipRange: 0
      }, duration / 2, easing), this._titleTopPanel.animate().to({
        scaleX: 0
      }, duration, "circInOut"), this._titleBottomPanel.animate().to({
        scaleX: 0
      }, duration, "circInOut");
    }
  }
};
StoryLabelItem.defaultAttributes = {
  contentOffsetX: 100,
  contentOffsetY: -60,
  titleTopStyle: {
    fontSize: 12,
    fill: "white"
  },
  titleBottomStyle: {
    fontSize: 12,
    fill: "white"
  },
  lineStyle: {
    stroke: "white",
    lineWidth: 1
  },
  symbolStartStyle: {
    symbolType: "circle",
    size: 3,
    fill: "white"
  },
  symbolEndStyle: {
    symbolType: "circle",
    size: 3,
    fill: "white"
  },
  symbolStartOuterStyle: {
    symbolType: "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0",
    size: 8,
    stroke: "white"
  },
  titleSpace: [2, 2],
  titleTopPanelStyle: {
    visible: false,
    padding: {
      left: 0,
      right: 0,
      bottom: 2,
      top: 2
    },
    cornerRadius: 3
  },
  titleBottomPanelStyle: {
    visible: false,
    padding: {
      left: 0,
      right: 0,
      bottom: 2,
      top: 2
    },
    cornerRadius: 3
  },
  theme: "default"
};

// node_modules/@visactor/vtable/es/vrender.js
var registed = false;
function registerForVrender() {
  registed || (registed = true, preLoadAllModule(), isBrowserEnv() ? loadBrowserEnv(container) : isNodeEnv() && loadNodeEnv(container), registerArc(), registerCircle(), registerGroup(), registerImage(), registerLine(), registerRect(), registerRichtext(), registerShadowRoot(), registerSymbol(), registerText(), registerFlexLayoutPlugin(), loadPoptip(), registerFlexLayoutPlugin());
}

// node_modules/@visactor/vtable/es/ts-types/index.js
var ts_types_exports = {};
__export(ts_types_exports, {
  AggregationType: () => AggregationType,
  Aggregator: () => Aggregator,
  AvgAggregator: () => AvgAggregator,
  CountAggregator: () => CountAggregator,
  CustomAggregator: () => CustomAggregator,
  HierarchyState: () => HierarchyState,
  HighlightScope: () => HighlightScope,
  IconFuncTypeEnum: () => IconFuncTypeEnum,
  IconPosition: () => IconPosition,
  InteractionState: () => InteractionState,
  InternalIconName: () => InternalIconName,
  MaxAggregator: () => MaxAggregator,
  MinAggregator: () => MinAggregator,
  NoneAggregator: () => NoneAggregator,
  Placement: () => Placement,
  RecalculateAggregator: () => RecalculateAggregator,
  RecordAggregator: () => RecordAggregator,
  SortType: () => SortType,
  SumAggregator: () => SumAggregator,
  cellStyleKeys: () => cellStyleKeys,
  indicatorSort: () => indicatorSort,
  naturalSort: () => naturalSort,
  registeredAggregators: () => registeredAggregators,
  sortBy: () => sortBy,
  typeSort: () => typeSort
});

// node_modules/@visactor/vtable/es/ts-types/common.js
var InteractionState;
!function(InteractionState2) {
  InteractionState2.default = "default", InteractionState2.grabing = "grabing", InteractionState2.scrolling = "scrolling";
}(InteractionState || (InteractionState = {}));
var HighlightScope;
!function(HighlightScope2) {
  HighlightScope2.single = "single", HighlightScope2.column = "column", HighlightScope2.row = "row", HighlightScope2.cross = "cross", HighlightScope2.none = "none";
}(HighlightScope || (HighlightScope = {}));

// node_modules/@visactor/vtable/es/ts-types/column/style.js
var cellStyleKeys = ["bgColor", "color", "strokeColor", "borderColor", "linkColor"];

// node_modules/@visactor/vtable/es/ts-types/new-data-set.js
var AggregationType;
!function(AggregationType2) {
  AggregationType2.RECORD = "RECORD", AggregationType2.NONE = "NONE", AggregationType2.SUM = "SUM", AggregationType2.MIN = "MIN", AggregationType2.MAX = "MAX", AggregationType2.AVG = "AVG", AggregationType2.COUNT = "COUNT", AggregationType2.CUSTOM = "CUSTOM", AggregationType2.RECALCULATE = "RECALCULATE";
}(AggregationType || (AggregationType = {}));
var SortType;
!function(SortType2) {
  SortType2.ASC = "ASC", SortType2.DESC = "DESC", SortType2.NORMAL = "NORMAL", SortType2.desc = "desc", SortType2.asc = "asc", SortType2.normal = "normal";
}(SortType || (SortType = {}));

// node_modules/@visactor/vtable/es/ts-types/table-engine.js
var Placement;
!function(Placement2) {
  Placement2.top = "top", Placement2.bottom = "bottom", Placement2.left = "left", Placement2.right = "right";
}(Placement || (Placement = {}));
var HierarchyState;
!function(HierarchyState2) {
  HierarchyState2.expand = "expand", HierarchyState2.collapse = "collapse", HierarchyState2.none = "none", HierarchyState2.loading = "loading";
}(HierarchyState || (HierarchyState = {}));

// node_modules/@visactor/vtable/es/ts-types/icon.js
var IconPosition;
!function(IconPosition2) {
  IconPosition2.inlineFront = "inlineFront", IconPosition2.inlineEnd = "inlineEnd", IconPosition2.left = "left", IconPosition2.right = "right", IconPosition2.absoluteRight = "absoluteRight", IconPosition2.contentLeft = "contentLeft", IconPosition2.contentRight = "contentRight", IconPosition2.absolute = "absolute";
}(IconPosition || (IconPosition = {}));
var IconFuncTypeEnum;
!function(IconFuncTypeEnum2) {
  IconFuncTypeEnum2.frozen = "frozen", IconFuncTypeEnum2.sort = "sort", IconFuncTypeEnum2.dropDown = "dropDown", IconFuncTypeEnum2.dropDownState = "dropDownState", IconFuncTypeEnum2.play = "play", IconFuncTypeEnum2.damagePic = "damagePic", IconFuncTypeEnum2.expand = "expand", IconFuncTypeEnum2.collapse = "collapse", IconFuncTypeEnum2.drillDown = "drillDown", IconFuncTypeEnum2.drillUp = "drillUp", IconFuncTypeEnum2.dragReorder = "dragReorder";
}(IconFuncTypeEnum || (IconFuncTypeEnum = {}));
var InternalIconName;
!function(InternalIconName2) {
  InternalIconName2.upwardIconName = "sort_upward", InternalIconName2.downwardIconName = "sort_downward", InternalIconName2.normalIconName = "sort_normal", InternalIconName2.freezeIconName = "freeze", InternalIconName2.frozenIconName = "frozen", InternalIconName2.frozenCurrentIconName = "frozenCurrent", InternalIconName2.dropdownIconName = "dropdownIcon", InternalIconName2.expandIconName = "expand", InternalIconName2.collapseIconName = "collapse", InternalIconName2.dragReorderIconName = "dragReorder", InternalIconName2.loadingIconName = "loading";
}(InternalIconName || (InternalIconName = {}));

// node_modules/@visactor/vtable/es/ts-types/dataset/aggregation.js
var registeredAggregators = {};
var Aggregator = class {
  constructor(config) {
    var _a;
    this.isAggregator = true, this.isRecord = true, this.records = [], this.key = config.key, this.field = config.field, this.formatFun = config.formatFun, this.isRecord = null !== (_a = config.isRecord) && void 0 !== _a ? _a : this.isRecord;
  }
  clearCacheValue() {
    this._formatedValue = void 0;
  }
  formatValue(col, row, table) {
    return this._formatedValue || (this.formatFun ? this._formatedValue = this.formatFun(this.value(), col, row, table) : this._formatedValue = this.value()), this._formatedValue;
  }
  reset() {
    this.records = [], this.clearCacheValue();
  }
};
var RecordAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.RECORD, this.isRecord = true;
  }
  push(record) {
    record && this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.clearCacheValue());
  }
  value() {
    return this.records;
  }
  reset() {
    this.records = [];
  }
  recalculate() {
  }
};
var NoneAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.NONE, this.isRecord = true;
  }
  push(record) {
    record && (this.isRecord && (this.records = [record]), this.field && (this.fieldValue = record[this.field])), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.field && this.records.length && (this.fieldValue = this.records[this.records.length - 1][this.field])), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.field && this.records.length && (this.fieldValue = this.records[this.records.length - 1][this.field]), this.clearCacheValue());
  }
  value() {
    return this.fieldValue;
  }
  reset() {
    this.records = [], this.fieldValue = void 0;
  }
  recalculate() {
  }
};
var CustomAggregator = class extends Aggregator {
  constructor(config) {
    super(config), this.type = AggregationType.CUSTOM, this.isRecord = true, this.values = [], this.aggregationFun = config.aggregationFun;
  }
  push(record) {
    record && (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), this.field && this.values.push(record[this.field])), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.field && this.records.length && (this.values = this.records.map((item) => item[this.field])), this.clearCacheValue());
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.field && this.records.length && (this.values = this.records.map((item) => item[this.field]))), this.clearCacheValue();
  }
  value() {
    var _a;
    return this.fieldValue || (this.fieldValue = null === (_a = this.aggregationFun) || void 0 === _a ? void 0 : _a.call(this, this.values, this.records, this.field)), this.fieldValue;
  }
  reset() {
    this.records = [], this.fieldValue = void 0;
  }
  recalculate() {
    this.fieldValue = void 0, this._formatedValue = void 0;
  }
};
var RecalculateAggregator = class extends Aggregator {
  constructor(config) {
    super(config), this.type = AggregationType.RECALCULATE, this.isRecord = true, this.calculateFun = config.calculateFun, this.dependAggregators = config.dependAggregators, this.dependIndicatorKeys = config.dependIndicatorKeys;
  }
  push(record) {
    record && this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.clearCacheValue());
  }
  value() {
    var _a;
    if (!this.fieldValue) {
      const aggregatorValue = _getDependAggregatorValues(this.dependAggregators, this.dependIndicatorKeys);
      this.fieldValue = null === (_a = this.calculateFun) || void 0 === _a ? void 0 : _a.call(this, aggregatorValue, this.records, this.field);
    }
    return this.fieldValue;
  }
  reset() {
    this.records = [], this.fieldValue = void 0;
  }
  recalculate() {
  }
};
var SumAggregator = class extends Aggregator {
  constructor(config) {
    var _a;
    super(config), this.type = AggregationType.SUM, this.sum = 0, this.positiveSum = 0, this.nagetiveSum = 0, this.needSplitPositiveAndNegativeForSum = false, this.needSplitPositiveAndNegativeForSum = null !== (_a = config.needSplitPositiveAndNegative) && void 0 !== _a && _a;
  }
  push(record) {
    if (record) {
      if (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), record.isAggregator) {
        const value = record.value();
        this.sum += null != value ? value : 0, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum += value : value < 0 && (this.nagetiveSum += value));
      } else if (this.field && !isNaN(parseFloat(record[this.field]))) {
        const value = parseFloat(record[this.field]);
        this.sum += value, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum += value : value < 0 && (this.nagetiveSum += value));
      }
    }
    this.clearCacheValue();
  }
  deleteRecord(record) {
    if (record) {
      if (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), record.isAggregator) {
        const value = record.value();
        this.sum -= null != value ? value : 0, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum -= value : value < 0 && (this.nagetiveSum -= value));
      } else if (this.field && !isNaN(parseFloat(record[this.field]))) {
        const value = parseFloat(record[this.field]);
        this.sum -= value, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum -= value : value < 0 && (this.nagetiveSum -= value));
      }
    }
    this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    if (oldRecord && newRecord) {
      if (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), oldRecord.isAggregator) {
        const oldValue = oldRecord.value(), newValue = newRecord.value();
        this.sum += newValue - oldValue, this.needSplitPositiveAndNegativeForSum && (oldValue > 0 ? this.positiveSum -= oldValue : oldValue < 0 && (this.nagetiveSum -= oldValue), newValue > 0 ? this.positiveSum += newValue : newValue < 0 && (this.nagetiveSum += newValue));
      } else if (this.field && !isNaN(parseFloat(oldRecord[this.field]))) {
        const oldValue = parseFloat(oldRecord[this.field]), newValue = parseFloat(newRecord[this.field]);
        this.sum += newValue - oldValue, this.needSplitPositiveAndNegativeForSum && (oldValue > 0 ? this.positiveSum -= oldValue : oldValue < 0 && (this.nagetiveSum -= oldValue), newValue > 0 ? this.positiveSum += newValue : newValue < 0 && (this.nagetiveSum += newValue));
      }
      this.clearCacheValue();
    }
  }
  value() {
    var _a;
    return (null === (_a = this.records) || void 0 === _a ? void 0 : _a.length) >= 1 ? this.sum : void 0;
  }
  positiveValue() {
    return this.positiveSum;
  }
  negativeValue() {
    return this.nagetiveSum;
  }
  reset() {
    super.reset(), this.records = [], this.sum = 0;
  }
  recalculate() {
    if (this.sum = 0, this._formatedValue = void 0, this.records) for (let i = 0; i < this.records.length; i++) {
      const record = this.records[i];
      if (record.isAggregator) {
        const value = record.value();
        this.sum += null != value ? value : 0, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum += value : value < 0 && (this.nagetiveSum += value));
      } else if (this.field && !isNaN(parseFloat(record[this.field]))) {
        const value = parseFloat(record[this.field]);
        this.sum += value, this.needSplitPositiveAndNegativeForSum && (value > 0 ? this.positiveSum += value : value < 0 && (this.nagetiveSum += value));
      }
    }
  }
};
var CountAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.COUNT, this.count = 0;
  }
  push(record) {
    record && (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), record.isAggregator ? this.count += record.value() : this.count++), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), record.isAggregator ? this.count -= record.value() : this.count--), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), oldRecord.isAggregator && (this.count += newRecord.value() - oldRecord.value()));
  }
  value() {
    return this.count;
  }
  reset() {
    this.records = [], this.count = 0;
  }
  recalculate() {
    if (this.count = 0, this._formatedValue = void 0, this.records) for (let i = 0; i < this.records.length; i++) {
      const record = this.records[i];
      record.isAggregator ? this.count += record.value() : this.count++;
    }
  }
};
var AvgAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.AVG, this.sum = 0, this.count = 0;
  }
  push(record) {
    record && (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), record.isAggregator && record.type === AggregationType.AVG ? (this.sum += record.sum, this.count += record.count) : this.field && !isNaN(parseFloat(record[this.field])) && (this.sum += parseFloat(record[this.field]), this.count++)), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), record.isAggregator && record.type === AggregationType.AVG ? (this.sum -= record.sum, this.count -= record.count) : this.field && !isNaN(parseFloat(record[this.field])) && (this.sum -= parseFloat(record[this.field]), this.count--)), this.clearCacheValue();
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), oldRecord.isAggregator && oldRecord.type === AggregationType.AVG ? (this.sum += newRecord.sum - oldRecord.sum, this.count += newRecord.count - oldRecord.count) : this.field && !isNaN(parseFloat(oldRecord[this.field])) && (this.sum += parseFloat(newRecord[this.field]) - parseFloat(oldRecord[this.field])), this.clearCacheValue());
  }
  value() {
    var _a;
    return (null === (_a = this.records) || void 0 === _a ? void 0 : _a.length) >= 1 ? this.sum / this.count : void 0;
  }
  reset() {
    this.records = [], this.sum = 0, this.count = 0;
  }
  recalculate() {
    if (this.sum = 0, this.count = 0, this._formatedValue = void 0, this.records) for (let i = 0; i < this.records.length; i++) {
      const record = this.records[i];
      record.isAggregator && record.type === AggregationType.AVG ? (this.sum += record.sum, this.count += record.count) : this.field && !isNaN(parseFloat(record[this.field])) && (this.sum += parseFloat(record[this.field]), this.count++);
    }
  }
};
var MaxAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.MAX, this.max = Number.MIN_SAFE_INTEGER;
  }
  push(record) {
    record && (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), record.isAggregator ? this.max = record.max > this.max ? record.max : this.max : "number" == typeof record ? this.max = record > this.max ? record : this.max : this.field && "number" == typeof record[this.field] ? this.max = record[this.field] > this.max ? record[this.field] : this.max : this.field && !isNaN(record[this.field]) && (this.max = parseFloat(record[this.field]) > this.max ? parseFloat(record[this.field]) : this.max)), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.recalculate());
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.recalculate());
  }
  value() {
    var _a;
    return (null === (_a = this.records) || void 0 === _a ? void 0 : _a.length) >= 1 ? this.max : void 0;
  }
  reset() {
    this.records = [], this.max = Number.MIN_SAFE_INTEGER;
  }
  recalculate() {
    if (this.max = Number.MIN_SAFE_INTEGER, this._formatedValue = void 0, this.records) for (let i = 0; i < this.records.length; i++) {
      const record = this.records[i];
      record.isAggregator ? this.max = record.max > this.max ? record.max : this.max : "number" == typeof record ? this.max = record > this.max ? record : this.max : this.field && "number" == typeof record[this.field] ? this.max = record[this.field] > this.max ? record[this.field] : this.max : this.field && !isNaN(record[this.field]) && (this.max = parseFloat(record[this.field]) > this.max ? parseFloat(record[this.field]) : this.max);
    }
  }
};
var MinAggregator = class extends Aggregator {
  constructor() {
    super(...arguments), this.type = AggregationType.MIN, this.min = Number.MAX_SAFE_INTEGER;
  }
  push(record) {
    record && (this.isRecord && this.records && (record.isAggregator ? this.records.push(...record.records) : this.records.push(record)), record.isAggregator ? this.min = record.min < this.min ? record.min : this.min : "number" == typeof record ? this.min = record < this.min ? record : this.min : this.field && "number" == typeof record[this.field] ? this.min = record[this.field] < this.min ? record[this.field] : this.min : this.field && !isNaN(record[this.field]) && (this.min = parseFloat(record[this.field]) < this.min ? parseFloat(record[this.field]) : this.min)), this.clearCacheValue();
  }
  deleteRecord(record) {
    record && (this.isRecord && this.records && (this.records = this.records.filter((item) => item !== record)), this.recalculate());
  }
  updateRecord(oldRecord, newRecord) {
    oldRecord && newRecord && (this.isRecord && this.records && (this.records = this.records.map((item) => item === oldRecord ? newRecord : item)), this.recalculate());
  }
  value() {
    var _a;
    return (null === (_a = this.records) || void 0 === _a ? void 0 : _a.length) >= 1 ? this.min : void 0;
  }
  reset() {
    this.records = [], this.min = Number.MAX_SAFE_INTEGER;
  }
  recalculate() {
    if (this.min = Number.MAX_SAFE_INTEGER, this._formatedValue = void 0, this.records) for (let i = 0; i < this.records.length; i++) {
      const record = this.records[i];
      record.isAggregator ? this.min = record.min < this.min ? record.min : this.min : "number" == typeof record ? this.min = record < this.min ? record : this.min : this.field && "number" == typeof record[this.field] ? this.min = record[this.field] < this.min ? record[this.field] : this.min : this.field && !isNaN(record[this.field]) && (this.min = parseFloat(record[this.field]) < this.min ? parseFloat(record[this.field]) : this.min);
    }
  }
};
function indicatorSort(a2, b) {
  return a2 && b ? a2.toString().localeCompare(b.toString(), "zh") : a2 ? 1 : -1;
}
function typeSort(a2, b, sortType) {
  if (sortType === SortType.NORMAL || sortType === SortType.normal) return 0;
  const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
  return a2 && b ? a2.toString().localeCompare(b.toString(), "zh") * factor : a2 ? 1 * factor : -1 * factor;
}
function naturalSort(as, bs, sortType) {
  if (sortType === SortType.NORMAL || sortType === SortType.normal) return 0;
  const rx = /(\d+)|(\D+)/g, rd = /\d/, rz = /^0/;
  let a2, a1, b, b1, nas = 0, nbs = 0;
  const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
  if (null !== bs && null === as) return -1 * factor;
  if (null !== as && null === bs) return 1 * factor;
  if ("number" == typeof as && isNaN(as)) return -1 * factor;
  if ("number" == typeof bs && isNaN(bs)) return 1 * factor;
  if (nas = +as, nbs = +bs, nas < nbs) return -1 * factor;
  if (nas > nbs) return 1 * factor;
  if ("number" == typeof as && "number" != typeof bs) return -1 * factor;
  if ("number" == typeof bs && "number" != typeof as) return 1 * factor;
  if ("number" == typeof as && "number" == typeof bs) return 0;
  if (isNaN(nbs) && !isNaN(nas)) return -1 * factor;
  if (isNaN(nas) && !isNaN(nbs)) return 1 * factor;
  if (a2 = String(as), b = String(bs), a2 === b) return 0;
  if (!rd.test(a2) || !rd.test(b)) return (a2 > b ? 1 : -1) * factor;
  for (a2 = a2.match(rx), b = b.match(rx); a2.length && b.length; ) if (a1 = a2.shift(), b1 = b.shift(), a1 !== b1) return rd.test(a1) && rd.test(b1) ? (a1.replace(rz, ".0") - b1.replace(rz, ".0")) * factor : (a1 > b1 ? 1 : -1) * factor;
  return (a2.length - b.length) * factor;
}
function sortBy(order) {
  let x;
  const mapping = {}, lowercase_mapping = {};
  for (let i = 0; i < order.length; i++) x = order[i], mapping[x] = i, "string" == typeof x && (lowercase_mapping[x.toLowerCase()] = i);
  return function(a2, b, sortType) {
    if (sortType === SortType.NORMAL || sortType === SortType.normal) return 0;
    const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
    let comparison;
    return null !== mapping[a2] && void 0 !== mapping[a2] && null !== mapping[b] && void 0 !== mapping[b] ? comparison = mapping[a2] - mapping[b] : null !== mapping[a2] && void 0 !== mapping[a2] ? comparison = -1 : null !== mapping[b] && void 0 !== mapping[b] ? comparison = 1 : null !== lowercase_mapping[a2] && void 0 !== mapping[a2] && null !== lowercase_mapping[b] && void 0 !== mapping[b] ? comparison = lowercase_mapping[a2] - lowercase_mapping[b] : null === lowercase_mapping[a2] || void 0 === mapping[a2] || null === lowercase_mapping[b] || void 0 === mapping[b] ? comparison = 0 : null !== lowercase_mapping[a2] && void 0 !== mapping[a2] ? comparison = -1 : null !== lowercase_mapping[b] && void 0 !== mapping[b] && (comparison = 1), isValid_default(comparison) ? comparison * factor : naturalSort(a2, b, sortType);
  };
}
function _getDependAggregatorValues(aggregators, dependIndicatorKeys) {
  const dependAggregatorValues = {};
  for (let m3 = 0; m3 < (null == dependIndicatorKeys ? void 0 : dependIndicatorKeys.length); m3++) {
    const aggrator = aggregators.find((aggrator2) => (null == aggrator2 ? void 0 : aggrator2.key) === dependIndicatorKeys[m3]);
    aggrator && (dependAggregatorValues[aggrator.key] = null == aggrator ? void 0 : aggrator.value());
  }
  return dependAggregatorValues;
}

// node_modules/@visactor/vtable/es/core.js
var core_exports = {};
__export(core_exports, {
  BaseTable: () => BaseTable
});

// node_modules/@visactor/vtable/es/event/EventTarget.js
var idCount = 1;
var EventTarget3 = class {
  constructor() {
    this.listenersData = {
      listeners: {},
      listenerData: {}
    };
  }
  on(type, listener) {
    const list = this.listenersData.listeners[type] || (this.listenersData.listeners[type] = []);
    list.push(listener);
    const id = idCount++;
    return this.listenersData.listenerData[id] = {
      type,
      listener,
      remove: () => {
        delete this.listenersData.listenerData[id];
        const index = list.indexOf(listener);
        list.splice(index, 1), this.listenersData.listeners[type].length || delete this.listenersData.listeners[type];
      }
    }, id;
  }
  off(idOrType, listener) {
    var _a;
    if (listener) {
      const type = idOrType;
      this.removeEventListener(type, listener);
    } else {
      const id = idOrType;
      if (!this.listenersData) return;
      null === (_a = this.listenersData.listenerData[id]) || void 0 === _a || _a.remove();
    }
  }
  addEventListener(type, listener, option) {
    this.on(type, listener);
  }
  removeEventListener(type, listener) {
    if (this.listenersData) for (const key in this.listenersData.listenerData) {
      const listenerData = this.listenersData.listenerData[key];
      listenerData.type === type && listenerData.listener === listener && this.off(key);
    }
  }
  hasListeners(type) {
    return !!this.listenersData && !!this.listenersData.listeners[type];
  }
  fireListeners(type, event2) {
    if (!this.listenersData) return [];
    const list = this.listenersData.listeners[type];
    return list ? list.map((listener) => listener.call(this, event2)).filter((r) => isValid_default(r)) : [];
  }
  release() {
    delete this.listenersData;
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/Style.js
var defaultStyle;
var STYLE_EVENT_TYPE = {
  CHANGE_STYLE: "change_style"
};
var Style = class _Style extends EventTarget3 {
  static get EVENT_TYPE() {
    return STYLE_EVENT_TYPE;
  }
  static get DEFAULT() {
    return defaultStyle || (defaultStyle = new _Style());
  }
  constructor(style2 = {}, bodyStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
    super(), this._defaultPadding = [10, 16, 10, 16], this._textAlign = null !== (_a = null == style2 ? void 0 : style2.textAlign) && void 0 !== _a ? _a : null == bodyStyle ? void 0 : bodyStyle.textAlign, this._textBaseline = null !== (_b = null == style2 ? void 0 : style2.textBaseline) && void 0 !== _b ? _b : null == bodyStyle ? void 0 : bodyStyle.textBaseline, this._color = null !== (_c = null == style2 ? void 0 : style2.color) && void 0 !== _c ? _c : null == bodyStyle ? void 0 : bodyStyle.color, this._strokeColor = null !== (_d = null == style2 ? void 0 : style2.strokeColor) && void 0 !== _d ? _d : null == bodyStyle ? void 0 : bodyStyle.strokeColor, this._fontSize = null !== (_e = style2.fontSize) && void 0 !== _e ? _e : null == bodyStyle ? void 0 : bodyStyle.fontSize, this._fontFamily = null !== (_f = style2.fontFamily) && void 0 !== _f ? _f : null == bodyStyle ? void 0 : bodyStyle.fontFamily, this._fontWeight = null !== (_g = style2.fontWeight) && void 0 !== _g ? _g : null == bodyStyle ? void 0 : bodyStyle.fontWeight, this._fontVariant = null !== (_h = style2.fontVariant) && void 0 !== _h ? _h : null == bodyStyle ? void 0 : bodyStyle.fontVariant, this._fontStyle = null !== (_j = style2.fontStyle) && void 0 !== _j ? _j : null == bodyStyle ? void 0 : bodyStyle.fontStyle, this._padding = null !== (_l = null !== (_k = null == style2 ? void 0 : style2.padding) && void 0 !== _k ? _k : null == bodyStyle ? void 0 : bodyStyle.padding) && void 0 !== _l ? _l : this._defaultPadding, this._borderColor = null !== (_m = null == style2 ? void 0 : style2.borderColor) && void 0 !== _m ? _m : null == bodyStyle ? void 0 : bodyStyle.borderColor, this._textOverflow = null !== (_o = null == style2 ? void 0 : style2.textOverflow) && void 0 !== _o ? _o : null == bodyStyle ? void 0 : bodyStyle.textOverflow, this._textStick = null !== (_q = null !== (_p = style2.textStick) && void 0 !== _p ? _p : null == bodyStyle ? void 0 : bodyStyle.textStick) && void 0 !== _q && _q, this._textStickBaseOnAlign = null !== (_s = null !== (_r = style2.textStickBaseOnAlign) && void 0 !== _r ? _r : null == bodyStyle ? void 0 : bodyStyle.textStickBaseOnAlign) && void 0 !== _s && _s, this._bgColor = null !== (_t = null == style2 ? void 0 : style2.bgColor) && void 0 !== _t ? _t : null == bodyStyle ? void 0 : bodyStyle.bgColor, this._lineHeight = null !== (_u = null == style2 ? void 0 : style2.lineHeight) && void 0 !== _u ? _u : null == bodyStyle ? void 0 : bodyStyle.lineHeight, this._underline = null !== (_v = null == style2 ? void 0 : style2.underline) && void 0 !== _v ? _v : null == bodyStyle ? void 0 : bodyStyle.underline, this._underlineColor = null !== (_w = null == style2 ? void 0 : style2.underlineColor) && void 0 !== _w ? _w : null == bodyStyle ? void 0 : bodyStyle.underlineColor, this._underlineDash = null !== (_x = null == style2 ? void 0 : style2.underlineDash) && void 0 !== _x ? _x : null == bodyStyle ? void 0 : bodyStyle.underlineDash, this._underlineOffset = null !== (_y = null == style2 ? void 0 : style2.underlineOffset) && void 0 !== _y ? _y : null == bodyStyle ? void 0 : bodyStyle.underlineOffset, this._lineThrough = null !== (_z = null == style2 ? void 0 : style2.lineThrough) && void 0 !== _z ? _z : null == bodyStyle ? void 0 : bodyStyle.lineThrough, this._lineThroughColor = null !== (_0 = null == style2 ? void 0 : style2.lineThroughColor) && void 0 !== _0 ? _0 : null == bodyStyle ? void 0 : bodyStyle.lineThroughColor, this._lineThroughDash = null !== (_1 = null == style2 ? void 0 : style2.lineThroughDash) && void 0 !== _1 ? _1 : null == bodyStyle ? void 0 : bodyStyle.lineThroughDash, this._linkColor = null !== (_2 = null == style2 ? void 0 : style2.linkColor) && void 0 !== _2 ? _2 : null == bodyStyle ? void 0 : bodyStyle.linkColor, this._cursor = null !== (_3 = style2.cursor) && void 0 !== _3 ? _3 : null == bodyStyle ? void 0 : bodyStyle.cursor, this._borderLineWidth = null !== (_4 = style2.borderLineWidth) && void 0 !== _4 ? _4 : null == bodyStyle ? void 0 : bodyStyle.borderLineWidth, this._borderLineDash = null !== (_5 = style2.borderLineDash) && void 0 !== _5 ? _5 : null == bodyStyle ? void 0 : bodyStyle.borderLineDash, this._marked = null !== (_6 = style2.marked) && void 0 !== _6 ? _6 : null == bodyStyle ? void 0 : bodyStyle.marked;
  }
  get color() {
    return this._color;
  }
  set color(color) {
    this._color = color;
  }
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(strokeColor) {
    this._strokeColor = strokeColor;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    this._fontSize = fontSize;
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    this._fontFamily = fontFamily;
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    this._fontWeight = fontWeight;
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    this._fontVariant = fontVariant;
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    this._fontStyle = fontStyle;
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    this._padding = padding;
  }
  get textOverflow() {
    return this._textOverflow;
  }
  set textOverflow(textOverflow) {
    this._textOverflow = textOverflow;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(bgColor) {
    this._bgColor = bgColor;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(borderColor) {
    this._borderColor = borderColor;
  }
  get textStick() {
    return this._textStick;
  }
  set textStick(textStick) {
    this._textStick = textStick;
  }
  get textStickBaseOnAlign() {
    return this._textStickBaseOnAlign;
  }
  set textStickBaseOnAlign(textStickBaseOnAlign) {
    this._textStickBaseOnAlign = textStickBaseOnAlign;
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(textAlign) {
    this._textAlign = textAlign;
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    this._textBaseline = textBaseline;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    this._lineHeight = lineHeight;
  }
  get underline() {
    return this._underline;
  }
  set underline(underline) {
    this._underline = underline;
  }
  get underlineColor() {
    return this._underlineColor;
  }
  set underlineColor(underlineColor) {
    this._underlineColor = underlineColor;
  }
  get underlineDash() {
    return this._underlineDash;
  }
  set underlineDash(underlineDash) {
    this._underlineDash = underlineDash;
  }
  get underlineOffset() {
    return this._underlineOffset;
  }
  set underlineOffset(underlineOffset) {
    this._underlineOffset = underlineOffset;
  }
  get lineThrough() {
    return this._lineThrough;
  }
  set lineThrough(lineThrough) {
    this._lineThrough = lineThrough;
  }
  get lineThroughColor() {
    return this._lineThroughColor;
  }
  set lineThroughColor(lineThroughColor) {
    this._lineThroughColor = lineThroughColor;
  }
  get lineThroughDash() {
    return this._lineThroughDash;
  }
  set lineThroughDash(lineThroughDash) {
    this._lineThroughDash = lineThroughDash;
  }
  get linkColor() {
    return this._linkColor;
  }
  set linkColor(linkColor) {
    this._linkColor = linkColor;
  }
  get cursor() {
    return this._cursor;
  }
  set cursor(cursor) {
    this._cursor = cursor;
  }
  get borderLineWidth() {
    return this._borderLineWidth;
  }
  set borderLineWidth(borderLineWidth) {
    this._borderLineWidth = borderLineWidth;
  }
  get borderLineDash() {
    return this._borderLineDash;
  }
  set borderLineDash(borderLineDash) {
    this._borderLineDash = borderLineDash;
  }
  get marked() {
    return this._marked;
  }
  set marked(marked) {
    this._marked = marked;
  }
  clone() {
    return new _Style(this, null);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/ImageStyle.js
var defaultStyle2;
var ImageStyle = class _ImageStyle extends Style {
  static get DEFAULT() {
    return defaultStyle2 || (defaultStyle2 = new _ImageStyle());
  }
  constructor(style2 = {}, bodyStyle = {}) {
    super(style2, bodyStyle);
  }
  clone() {
    return new _ImageStyle(this, null);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/MultilineTextStyle.js
var defaultStyle3;
var TextStyle = class _TextStyle extends Style {
  static get DEFAULT() {
    return defaultStyle3 || (defaultStyle3 = new _TextStyle());
  }
  constructor(style2 = {}, bodyStyle = {}) {
    var _a, _b;
    super(style2, bodyStyle), this._autoWrapText = null !== (_a = null == style2 ? void 0 : style2.autoWrapText) && void 0 !== _a ? _a : null == bodyStyle ? void 0 : bodyStyle.autoWrapText, this._lineClamp = null !== (_b = null == style2 ? void 0 : style2.lineClamp) && void 0 !== _b ? _b : null == bodyStyle ? void 0 : bodyStyle.lineClamp;
  }
  clone() {
    return new _TextStyle(this, null);
  }
  get lineClamp() {
    return this._lineClamp;
  }
  set lineClamp(lineClamp) {
    this._lineClamp = lineClamp;
  }
  get autoWrapText() {
    return this._autoWrapText;
  }
  set autoWrapText(autoWrapText) {
    this._autoWrapText = autoWrapText;
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/CheckboxStyle.js
var defaultStyle4;
var CheckboxStyle = class _CheckboxStyle extends Style {
  static get DEFAULT() {
    return defaultStyle4 || (defaultStyle4 = new _CheckboxStyle());
  }
  constructor(style2 = {}, headerStyle = {}, checkboxThemeStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    super(style2, headerStyle), this._size = (null !== (_b = null !== (_a = null == style2 ? void 0 : style2.size) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.size) && void 0 !== _b ? _b : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.size) || 14, this._spaceBetweenTextAndIcon = (null !== (_d = null !== (_c = null == style2 ? void 0 : style2.spaceBetweenTextAndIcon) && void 0 !== _c ? _c : null == headerStyle ? void 0 : headerStyle.spaceBetweenTextAndIcon) && void 0 !== _d ? _d : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.spaceBetweenTextAndIcon) || 8, this._defaultFill = null !== (_f = null === (_e = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _e ? void 0 : _e.defaultFill) && void 0 !== _f ? _f : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.defaultFill, this._defaultStroke = null !== (_h = null === (_g = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _g ? void 0 : _g.defaultStroke) && void 0 !== _h ? _h : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.defaultStroke, this._disableFill = null !== (_k = null === (_j = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _j ? void 0 : _j.disableFill) && void 0 !== _k ? _k : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableFill, this._checkedFill = null !== (_m = null === (_l = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _l ? void 0 : _l.checkedFill) && void 0 !== _m ? _m : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkedFill, this._checkedStroke = null !== (_p = null === (_o = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _o ? void 0 : _o.checkedStroke) && void 0 !== _p ? _p : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkedStroke, this._disableCheckedFill = null !== (_r = null === (_q = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _q ? void 0 : _q.disableCheckedFill) && void 0 !== _r ? _r : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableCheckedFill, this._disableCheckedStroke = null !== (_t = null === (_s = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _s ? void 0 : _s.disableCheckedStroke) && void 0 !== _t ? _t : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableCheckedStroke, this._checkIconImage = null !== (_v = null === (_u = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _u ? void 0 : _u.checkIconImage) && void 0 !== _v ? _v : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkIconImage, this._indeterminateIconImage = null !== (_x = null === (_w = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _w ? void 0 : _w.indeterminateIconImage) && void 0 !== _x ? _x : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.indeterminateIconImage;
  }
  get size() {
    return this._size;
  }
  set size(size) {
    this._size = size;
  }
  get spaceBetweenTextAndIcon() {
    return this._spaceBetweenTextAndIcon;
  }
  set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
    this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
  }
  get defaultFill() {
    return this._defaultFill;
  }
  set defaultFill(defaultFill) {
    this._defaultFill = defaultFill;
  }
  get defaultStroke() {
    return this._defaultStroke;
  }
  set defaultStroke(defaultStroke) {
    this._defaultStroke = defaultStroke;
  }
  get disableFill() {
    return this._disableFill;
  }
  set disableFill(disableFill) {
    this._disableFill = disableFill;
  }
  get checkedFill() {
    return this._checkedFill;
  }
  set checkedFill(checkedFill) {
    this._checkedFill = checkedFill;
  }
  get checkedStroke() {
    return this._checkedStroke;
  }
  set checkedStroke(checkedStroke) {
    this._checkedStroke = checkedStroke;
  }
  get disableCheckedFill() {
    return this._disableCheckedFill;
  }
  set disableCheckedFill(disableCheckedFill) {
    this._disableCheckedFill = disableCheckedFill;
  }
  get disableCheckedStroke() {
    return this._disableCheckedStroke;
  }
  set disableCheckedStroke(disableCheckedStroke) {
    this._disableCheckedStroke = disableCheckedStroke;
  }
  get checkIconImage() {
    return this._checkIconImage;
  }
  set checkIconImage(checkIconImage) {
    this._checkIconImage = checkIconImage;
  }
  get indeterminateIconImage() {
    return this._indeterminateIconImage;
  }
  set indeterminateIconImage(indeterminateIconImage) {
    this._indeterminateIconImage = indeterminateIconImage;
  }
  getStyle(style2) {
    return new _CheckboxStyle(style2, this);
  }
  clone() {
    return new _CheckboxStyle(this);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/RadioStyle.js
var defaultStyle5;
var RadioStyle = class _RadioStyle extends Style {
  static get DEFAULT() {
    return defaultStyle5 || (defaultStyle5 = new _RadioStyle());
  }
  constructor(style2 = {}, headerStyle = {}, radioThemeStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    super(style2, headerStyle), this._size = (null !== (_b = null !== (_a = null == style2 ? void 0 : style2.size) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.size) && void 0 !== _b ? _b : null == radioThemeStyle ? void 0 : radioThemeStyle.size) || 14, this._spaceBetweenTextAndIcon = (null !== (_d = null !== (_c = null == style2 ? void 0 : style2.spaceBetweenTextAndIcon) && void 0 !== _c ? _c : null == headerStyle ? void 0 : headerStyle.spaceBetweenTextAndIcon) && void 0 !== _d ? _d : null == radioThemeStyle ? void 0 : radioThemeStyle.spaceBetweenTextAndIcon) || 8, this._spaceBetweenRadio = (null !== (_f = null !== (_e = null == style2 ? void 0 : style2.spaceBetweenRadio) && void 0 !== _e ? _e : null == headerStyle ? void 0 : headerStyle.spaceBetweenRadio) && void 0 !== _f ? _f : null == radioThemeStyle ? void 0 : radioThemeStyle.spaceBetweenRadio) || 2, this._innerRadius = null !== (_h = null === (_g = null == style2 ? void 0 : style2.radioStyle) || void 0 === _g ? void 0 : _g.innerRadius) && void 0 !== _h ? _h : null == radioThemeStyle ? void 0 : radioThemeStyle.innerRadius, this._outerRadius = null !== (_k = null === (_j = null == style2 ? void 0 : style2.radioStyle) || void 0 === _j ? void 0 : _j.outerRadius) && void 0 !== _k ? _k : null == radioThemeStyle ? void 0 : radioThemeStyle.outerRadius, this._defaultFill = null !== (_m = null === (_l = null == style2 ? void 0 : style2.radioStyle) || void 0 === _l ? void 0 : _l.defaultFill) && void 0 !== _m ? _m : null == radioThemeStyle ? void 0 : radioThemeStyle.defaultFill, this._defaultStroke = null !== (_p = null === (_o = null == style2 ? void 0 : style2.radioStyle) || void 0 === _o ? void 0 : _o.defaultStroke) && void 0 !== _p ? _p : null == radioThemeStyle ? void 0 : radioThemeStyle.defaultStroke, this._disableFill = null !== (_r = null === (_q = null == style2 ? void 0 : style2.radioStyle) || void 0 === _q ? void 0 : _q.disableFill) && void 0 !== _r ? _r : null == radioThemeStyle ? void 0 : radioThemeStyle.disableFill, this._checkedFill = null !== (_t = null === (_s = null == style2 ? void 0 : style2.radioStyle) || void 0 === _s ? void 0 : _s.checkedFill) && void 0 !== _t ? _t : null == radioThemeStyle ? void 0 : radioThemeStyle.checkedFill, this._checkedStroke = null !== (_v = null === (_u = null == style2 ? void 0 : style2.radioStyle) || void 0 === _u ? void 0 : _u.checkedStroke) && void 0 !== _v ? _v : null == radioThemeStyle ? void 0 : radioThemeStyle.checkedStroke, this._disableCheckedFill = null !== (_x = null === (_w = null == style2 ? void 0 : style2.radioStyle) || void 0 === _w ? void 0 : _w.disableCheckedFill) && void 0 !== _x ? _x : null == radioThemeStyle ? void 0 : radioThemeStyle.disableCheckedFill, this._disableCheckedStroke = null !== (_z = null === (_y = null == style2 ? void 0 : style2.radioStyle) || void 0 === _y ? void 0 : _y.disableCheckedStroke) && void 0 !== _z ? _z : null == radioThemeStyle ? void 0 : radioThemeStyle.disableCheckedStroke;
  }
  get size() {
    return this._size;
  }
  set size(size) {
    this._size = size;
  }
  get spaceBetweenTextAndIcon() {
    return this._spaceBetweenTextAndIcon;
  }
  set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
    this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
  }
  get spaceBetweenRadio() {
    return this._spaceBetweenRadio;
  }
  set spaceBetweenRadio(spaceBetweenRadio) {
    this._spaceBetweenRadio = spaceBetweenRadio;
  }
  get innerRadius() {
    return this._innerRadius;
  }
  set innerRadius(innerRadius) {
    this._innerRadius = innerRadius;
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(outerRadius) {
    this._outerRadius = outerRadius;
  }
  get defaultFill() {
    return this._defaultFill;
  }
  set defaultFill(defaultFill) {
    this._defaultFill = defaultFill;
  }
  get defaultStroke() {
    return this._defaultStroke;
  }
  set defaultStroke(defaultStroke) {
    this._defaultStroke = defaultStroke;
  }
  get disableFill() {
    return this._disableFill;
  }
  set disableFill(disableFill) {
    this._disableFill = disableFill;
  }
  get checkedFill() {
    return this._checkedFill;
  }
  set checkedFill(checkedFill) {
    this._checkedFill = checkedFill;
  }
  get checkedStroke() {
    return this._checkedStroke;
  }
  set checkedStroke(checkedStroke) {
    this._checkedStroke = checkedStroke;
  }
  get disableCheckedFill() {
    return this._disableCheckedFill;
  }
  set disableCheckedFill(disableCheckedFill) {
    this._disableCheckedFill = disableCheckedFill;
  }
  get disableCheckedStroke() {
    return this._disableCheckedStroke;
  }
  set disableCheckedStroke(disableCheckedStroke) {
    this._disableCheckedStroke = disableCheckedStroke;
  }
  getStyle(style2) {
    return new _RadioStyle(style2, this);
  }
  clone() {
    return new _RadioStyle(this);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/SwitchStyle.js
var defaultStyle6;
var SwitchStyle = class _SwitchStyle extends Style {
  static get DEFAULT() {
    return defaultStyle6 || (defaultStyle6 = new _SwitchStyle());
  }
  constructor(style2 = {}, headerStyle = {}, switchThemeStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    super(style2, headerStyle), this._spaceBetweenTextAndCircle = (null !== (_b = null !== (_a = null == style2 ? void 0 : style2.spaceBetweenTextAndCircle) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.spaceBetweenTextAndCircle) && void 0 !== _b ? _b : null == switchThemeStyle ? void 0 : switchThemeStyle.spaceBetweenTextAndCircle) || 6, this._circleRadius = (null !== (_d = null === (_c = null == style2 ? void 0 : style2.switchStyle) || void 0 === _c ? void 0 : _c.circleRadius) && void 0 !== _d ? _d : null == switchThemeStyle ? void 0 : switchThemeStyle.circleRadius) || 8, this._boxWidth = (null !== (_f = null === (_e = null == style2 ? void 0 : style2.switchStyle) || void 0 === _e ? void 0 : _e.boxWidth) && void 0 !== _f ? _f : null == switchThemeStyle ? void 0 : switchThemeStyle.boxWidth) || 40, this._boxHeight = (null !== (_h = null === (_g = null == style2 ? void 0 : style2.switchStyle) || void 0 === _g ? void 0 : _g.boxHeight) && void 0 !== _h ? _h : null == switchThemeStyle ? void 0 : switchThemeStyle.boxHeight) || 24, this._checkedFill = (null !== (_k = null === (_j = null == style2 ? void 0 : style2.switchStyle) || void 0 === _j ? void 0 : _j.checkedFill) && void 0 !== _k ? _k : null == switchThemeStyle ? void 0 : switchThemeStyle.checkedFill) || "#165DFF", this._uncheckedFill = (null !== (_m = null === (_l = null == style2 ? void 0 : style2.switchStyle) || void 0 === _l ? void 0 : _l.uncheckedFill) && void 0 !== _m ? _m : null == switchThemeStyle ? void 0 : switchThemeStyle.uncheckedFill) || "#c9cdd4", this._disableCheckedFill = (null !== (_p = null === (_o = null == style2 ? void 0 : style2.switchStyle) || void 0 === _o ? void 0 : _o.disableCheckedFill) && void 0 !== _p ? _p : null == switchThemeStyle ? void 0 : switchThemeStyle.disableCheckedFill) || "#94bfff", this._disableUncheckedFill = (null !== (_r = null === (_q = null == style2 ? void 0 : style2.switchStyle) || void 0 === _q ? void 0 : _q.disableUncheckedFill) && void 0 !== _r ? _r : null == switchThemeStyle ? void 0 : switchThemeStyle.disableUncheckedFill) || "#f2f3f5", this._circleFill = (null !== (_t = null === (_s = null == style2 ? void 0 : style2.switchStyle) || void 0 === _s ? void 0 : _s.circleFill) && void 0 !== _t ? _t : null == switchThemeStyle ? void 0 : switchThemeStyle.circleFill) || "#FFF";
  }
  get spaceBetweenTextAndCircle() {
    return this._spaceBetweenTextAndCircle;
  }
  set spaceBetweenTextAndCircle(spaceBetweenTextAndCircle) {
    this._spaceBetweenTextAndCircle = spaceBetweenTextAndCircle;
  }
  get circleRadius() {
    return this._circleRadius;
  }
  set circleRadius(circleRadius) {
    this._circleRadius = circleRadius;
  }
  get boxWidth() {
    return this._boxWidth;
  }
  set boxWidth(boxWidth) {
    this._boxWidth = boxWidth;
  }
  get boxHeight() {
    return this._boxHeight;
  }
  set boxHeight(boxHeight) {
    this._boxHeight = boxHeight;
  }
  get checkedFill() {
    return this._checkedFill;
  }
  set checkedFill(checkedFill) {
    this._checkedFill = checkedFill;
  }
  get uncheckedFill() {
    return this._uncheckedFill;
  }
  set uncheckedFill(uncheckedFill) {
    this._uncheckedFill = uncheckedFill;
  }
  get disableCheckedFill() {
    return this._disableCheckedFill;
  }
  set disableCheckedFill(disableCheckedFill) {
    this._disableCheckedFill = disableCheckedFill;
  }
  get disableUncheckedFill() {
    return this._disableUncheckedFill;
  }
  set disableUncheckedFill(disableUncheckedFill) {
    this._disableUncheckedFill = disableUncheckedFill;
  }
  get circleFill() {
    return this._circleFill;
  }
  set circleFill(circleFill) {
    this._circleFill = circleFill;
  }
  getStyle(style2) {
    return new _SwitchStyle(style2, this);
  }
  clone() {
    return new _SwitchStyle(this);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/ButtonStyle.js
var defaultStyle7;
var ButtonStyle = class _ButtonStyle extends Style {
  static get DEFAULT() {
    return defaultStyle7 || (defaultStyle7 = new _ButtonStyle());
  }
  constructor(style2 = {}, headerStyle = {}, buttonThemeStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    super(style2, headerStyle), this._buttonColor = (null !== (_b = null === (_a = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _a ? void 0 : _a.buttonColor) && void 0 !== _b ? _b : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonColor) || "#165DFF", this._buttonBorderColor = (null !== (_d = null === (_c = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _c ? void 0 : _c.buttonBorderColor) && void 0 !== _d ? _d : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonBorderColor) || "#165DFF", this._buttonLineWidth = (null !== (_f = null === (_e = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _e ? void 0 : _e.buttonLineWidth) && void 0 !== _f ? _f : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonLineWidth) || 1, this._buttonBorderRadius = (null !== (_h = null === (_g = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _g ? void 0 : _g.buttonBorderRadius) && void 0 !== _h ? _h : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonBorderRadius) || 2, this._buttonHoverColor = (null !== (_k = null === (_j = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _j ? void 0 : _j.buttonHoverColor) && void 0 !== _k ? _k : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonHoverColor) || "#4080FF", this._buttonHoverBorderColor = (null !== (_m = null === (_l = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _l ? void 0 : _l.buttonHoverBorderColor) && void 0 !== _m ? _m : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonHoverBorderColor) || "#4080FF", this._buttonTextHoverColor = null !== (_p = null === (_o = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _o ? void 0 : _o.buttonTextHoverColor) && void 0 !== _p ? _p : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonTextHoverColor, this._buttonDisableColor = (null !== (_r = null === (_q = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _q ? void 0 : _q.buttonDisableColor) && void 0 !== _r ? _r : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonDisableColor) || "#94bfff", this._buttonDisableBorderColor = (null !== (_t = null === (_s = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _s ? void 0 : _s.buttonDisableBorderColor) && void 0 !== _t ? _t : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonDisableBorderColor) || "#94bfff", this._buttonTextDisableColor = null !== (_v = null === (_u = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _u ? void 0 : _u.buttonTextDisableColor) && void 0 !== _v ? _v : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonTextDisableColor, this._buttonPadding = (null !== (_x = null === (_w = null == style2 ? void 0 : style2.buttonStyle) || void 0 === _w ? void 0 : _w.buttonPadding) && void 0 !== _x ? _x : null == buttonThemeStyle ? void 0 : buttonThemeStyle.buttonPadding) || 10;
  }
  get buttonColor() {
    return this._buttonColor;
  }
  set buttonColor(buttonColor) {
    this._buttonColor = buttonColor;
  }
  get buttonBorderColor() {
    return this._buttonBorderColor;
  }
  set buttonBorderColor(buttonBorderColor) {
    this._buttonBorderColor = buttonBorderColor;
  }
  get buttonLineWidth() {
    return this._buttonLineWidth;
  }
  set buttonLineWidth(buttonLineWidth) {
    this._buttonLineWidth = buttonLineWidth;
  }
  get buttonBorderRadius() {
    return this._buttonBorderRadius;
  }
  set buttonBorderRadius(buttonBorderRadius) {
    this._buttonBorderRadius = buttonBorderRadius;
  }
  get buttonHoverColor() {
    return this._buttonHoverColor;
  }
  set buttonHoverColor(buttonHoverColor) {
    this._buttonHoverColor = buttonHoverColor;
  }
  get buttonHoverBorderColor() {
    return this._buttonHoverBorderColor;
  }
  set buttonHoverBorderColor(buttonHoverBorderColor) {
    this._buttonHoverBorderColor = buttonHoverBorderColor;
  }
  get buttonTextHoverColor() {
    return this._buttonTextHoverColor;
  }
  set buttonTextHoverColor(buttonTextHoverColor) {
    this._buttonTextHoverColor = buttonTextHoverColor;
  }
  get buttonDisableColor() {
    return this._buttonDisableColor;
  }
  set buttonDisableColor(buttonDisableColor) {
    this._buttonDisableColor = buttonDisableColor;
  }
  get buttonDisableBorderColor() {
    return this._buttonDisableBorderColor;
  }
  set buttonDisableBorderColor(buttonDisableBorderColor) {
    this._buttonDisableBorderColor = buttonDisableBorderColor;
  }
  get buttonTextDisableColor() {
    return this._buttonTextDisableColor;
  }
  set buttonTextDisableColor(buttonTextDisableColor) {
    this._buttonTextDisableColor = buttonTextDisableColor;
  }
  get buttonTextHoverBorderColor() {
    return this._buttonTextHoverBorderColor;
  }
  set buttonTextHoverBorderColor(buttonTextHoverBorderColor) {
    this._buttonTextHoverBorderColor = buttonTextHoverBorderColor;
  }
  get buttonPadding() {
    return this._buttonPadding;
  }
  set buttonPadding(buttonPadding) {
    this._buttonPadding = buttonPadding;
  }
  getStyle(style2) {
    return new _ButtonStyle(style2, this);
  }
  clone() {
    return new _ButtonStyle(this);
  }
};

// node_modules/@visactor/vtable/es/body-helper/style.js
var { EVENT_TYPE } = Style;
function of(columnStyle, bodyStyle, styleArg, StyleClassDef = Style, globalAutoWrapText, theme4) {
  var _a, _b, _c, _d;
  return columnStyle || bodyStyle ? columnStyle instanceof Style ? columnStyle : "function" == typeof columnStyle ? of(columnStyle(styleArg), bodyStyle, styleArg, StyleClassDef, globalAutoWrapText, theme4) : (columnStyle || (columnStyle = {}), globalAutoWrapText && !isValid_default(columnStyle.autoWrapText) && (columnStyle.autoWrapText = true), StyleClassDef === CheckboxStyle ? new CheckboxStyle(null != columnStyle ? columnStyle : {}, null != bodyStyle ? bodyStyle : {}, null !== (_a = theme4.checkboxStyle) && void 0 !== _a ? _a : {}) : StyleClassDef === RadioStyle ? new RadioStyle(null != columnStyle ? columnStyle : {}, null != bodyStyle ? bodyStyle : {}, null !== (_b = theme4.radioStyle) && void 0 !== _b ? _b : {}) : StyleClassDef === SwitchStyle ? new SwitchStyle(null != columnStyle ? columnStyle : {}, null != bodyStyle ? bodyStyle : {}, null !== (_c = theme4.switchStyle) && void 0 !== _c ? _c : {}) : StyleClassDef === ButtonStyle ? new ButtonStyle(null != columnStyle ? columnStyle : {}, null != bodyStyle ? bodyStyle : {}, null !== (_d = theme4.buttonStyle) && void 0 !== _d ? _d : {}) : new StyleClassDef(null != columnStyle ? columnStyle : {}, null != bodyStyle ? bodyStyle : {})) : StyleClassDef.DEFAULT;
}

// node_modules/@visactor/vtable/es/tools/env.js
var Env = class _Env {
  static get mode() {
    return _Env._mode || (_Env._mode = defaultMode()), _Env._mode;
  }
  static set mode(mode) {
    _Env._mode = mode;
  }
  static RegisterCreateCanvas(func) {
    _Env.CreateCanvas = func;
  }
  static RegisterLoadImage(func) {
    _Env.LoadImage = func;
  }
  static GetCreateCanvasFunc() {
    return _Env.CreateCanvas ? _Env.CreateCanvas : "worker" === _Env.mode ? (width = 200, height = 200) => new OffscreenCanvas(width, height) : void 0;
  }
  static RegisterRequestAnimationFrame(func) {
    _Env.RequestAnimationFrame = func();
  }
  static GetRequestAnimationFrame() {
    if (_Env.RequestAnimationFrame) return _Env.RequestAnimationFrame;
  }
  static RegisterCancelAnimationFrame(func) {
    _Env.CancelAnimationFrame = func();
  }
  static GetCancelAnimationFrame() {
    if (_Env.CancelAnimationFrame) return _Env.CancelAnimationFrame;
  }
};
function defaultMode() {
  let mode = "browser";
  try {
    "node" === window.type ? mode = "node" : "undefined" == typeof window || window.performance ? "undefined" == typeof window && (mode = "node") : mode = "miniApp";
  } catch (err) {
    mode = "node";
  }
  return mode;
}
Env.dpr = 0;

// node_modules/@visactor/vtable/es/core/style.js
function importStyle() {
  if ("node" === Env.mode) return;
  const styleElement = document.createElement("style");
  styleElement.id = "vtable-style-styleSheet", styleElement.textContent = "\n.vtable .input-container {\n	position: absolute;\n	top:0px;\n}\n.vtable .table-scrollable {\n	position: absolute;\n	overflow: scroll;\n}\n.vtable .table-scrollable::-webkit-scrollbar-button{\n	background-color: transparent;\n}\n.vtable .table-scrollable::-webkit-scrollbar-track-piece{\n	background-color: transparent;\n}\n.vtable .table-scrollable::-webkit-scrollbar-corner {\n	background-color: transparent;\n}\n.vtable .table-scrollable::-webkit-scrollbar-thumb {\n	border-radius      : 4px;\n	background-color   : rgba(100, 100, 100, .5);\n}\n\n.vtable .table-scroll-end-point {\n	opacity: 0;\n	position: relative;\n}\n.vtable {\n	/* 设置overflow: auto 应该是为了滚动条的某个问题 但设置了auto之后 dom的下拉菜单只能显示在vtable节点中 超出会截断;现在去掉auto 暂时滚动条的问题没有发现 */\n	/* overflow: auto; */\n	position: relative;\n	width: 100%;\n	height: 100%;\n	text-align: left;\n  -webkit-font-smoothing:auto;\n\n  overflow: hidden; // for react-vtable dom custom element\n}\n\n.vtable-gantt {\n	/* 设置overflow: auto 应该是为了滚动条的某个问题 但设置了auto之后 dom的下拉菜单只能显示在vtable节点中 超出会截断;现在去掉auto 暂时滚动条的问题没有发现 */\n	/* overflow: auto; */\n	position: absolute;\n	width: 100%;\n	height: 100%;\n	text-align: left;\n  -webkit-font-smoothing:auto;\n\n  overflow: hidden; // for react-vtable dom custom element\n}\n.vtable .table-component-container {\n  pointer-events: none;\n  overflow: hidden;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.vtable > canvas {\n	position: absolute;\n	width: 0;\n	height: 0;\n}\n.vtable .table-focus-control {\n	position: relative !important;\n	width: 1px;\n	height: 1px;\n	opacity: 0;\n	padding: 0;\n	margin: 0;\n	box-sizing: border-box;\n	pointer-events: none;\n	max-width: 500px;\n	max-height: 500px;\n	float: none !important;\n}\n.vtable input.table-focus-control::-ms-clear {\n	visibility: hidden;\n}\n.vtable input.table-focus-control.composition {\n	opacity: 1;\n	max-width: none;\n	max-height: none;\n}\n", document.head.appendChild(styleElement);
}

// node_modules/@visactor/vtable/es/tools/style.js
function getHorizontalScrollBarSize(scrollStyle) {
  var _a;
  return (null == scrollStyle ? void 0 : scrollStyle.hoverOn) || (null == scrollStyle ? void 0 : scrollStyle.horizontalVisible) && "none" === (null == scrollStyle ? void 0 : scrollStyle.horizontalVisible) || !(null == scrollStyle ? void 0 : scrollStyle.horizontalVisible) && "none" === (null == scrollStyle ? void 0 : scrollStyle.visible) ? 0 : null !== (_a = null == scrollStyle ? void 0 : scrollStyle.width) && void 0 !== _a ? _a : 7;
}
function getVerticalScrollBarSize(scrollStyle) {
  var _a;
  return (null == scrollStyle ? void 0 : scrollStyle.hoverOn) || (null == scrollStyle ? void 0 : scrollStyle.verticalVisible) && "none" === (null == scrollStyle ? void 0 : scrollStyle.verticalVisible) || !(null == scrollStyle ? void 0 : scrollStyle.verticalVisible) && "none" === (null == scrollStyle ? void 0 : scrollStyle.visible) ? 0 : null !== (_a = null == scrollStyle ? void 0 : scrollStyle.width) && void 0 !== _a ? _a : 7;
}
function isValidStyle(style2) {
  return !!isValid_default(style2) && (!isArray_default(style2) || style2.some((s2) => isValid_default(s2)));
}
function isZeroStyle(style2) {
  return 0 === style2 || isArray_default(style2) && style2.every((s2) => 0 === s2);
}

// node_modules/@visactor/vtable/es/tools/util.js
var judgeType = (value) => {
  switch (Object.prototype.toString.call(value)) {
    case "[object Object]":
      return "object";
    case "[object Function]":
      return "function";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
    case "[object Number]":
      return "number";
    case "[object RegExp]":
      return "regExp";
    case "[object Boolean]":
      return "boolean";
    case "[object Symbol]":
      return "symbol";
    case "[object Date]":
      return "date";
    case "[object Undefined]":
      return "undefined";
    case "[object Null]":
      return "null";
    case "[object Error]":
      return "error";
    case "[object HTMLDocument]":
      return "document";
    case "[object global]":
      return "global";
    default:
      return null;
  }
};
var isIt = (v, type) => judgeType(v) === type;
var isObject = (v) => isIt(v, "object");
var isString = (v) => isIt(v, "string");
var isNumber2 = (v) => isIt(v, "number");
var isBoolean = (v) => isIt(v, "boolean");
function ingoreNoneValueMerge(target, ...sources) {
  if (!sources.length) return target || {};
  const source = sources.shift();
  if (isObject(target) && isObject(source)) for (const key in source) isObject(source[key]) ? (target[key] || Object.assign(target, {
    [key]: {}
  }), isObject(target[key]) || Object.assign(target, {
    [key]: source[key]
  }), ingoreNoneValueMerge(target[key], source[key])) : null !== source[key] && void 0 !== source[key] && Object.assign(target, {
    [key]: source[key]
  });
  return ingoreNoneValueMerge(target, ...sources);
}
function convertInternal(value) {
  return "function" == typeof value && (value = value()), isValid_default(value) ? `${value}` : "";
}
function transpose(matrix) {
  if ((null == matrix ? void 0 : matrix.length) <= 0) return matrix;
  const m3 = matrix.length, n = matrix[0].length, transposed = new Array(n);
  for (let i = 0; i < m3; i++) for (let j = 0; j < n; j++) transposed[j] || (transposed[j] = new Array(m3)), transposed[j][i] = matrix[i][j];
  return transposed;
}
function throttle(func, delay) {
  let timer = null;
  return function(...args) {
    timer || (func.apply(this, args), timer = setTimeout(() => {
      timer = null;
    }, delay));
  };
}
function throttle2(func, delay) {
  let timer = null;
  return function(...args) {
    timer || (timer = setTimeout(() => {
      func.apply(this, args), timer = null;
    }, delay));
  };
}
function pad(num, totalChars) {
  for (num = `${num}`; num.length < totalChars; ) num = "0" + num;
  return num;
}
function changeColor(color, ratio, isDarker) {
  color = (color = color.replace(/^\s*|\s*$/, "")).replace(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i, "#$1$1$2$2$3$3");
  const difference = Math.round(256 * ratio) * (isDarker ? -1 : 1), rgb2 = color.match(new RegExp("^rgba?\\(\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])(?:\\s*,\\s*(0|1|0?\\.\\d+))?\\s*\\)$", "i")), alpha = rgb2 && isValid_default(rgb2[4]) ? rgb2[4] : null, decimal = rgb2 ? [rgb2[1], rgb2[2], rgb2[3]] : color.replace(/^#?([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])/i, function() {
    return `${parseInt(arguments[1], 16)},${parseInt(arguments[2], 16)},${parseInt(arguments[3], 16)}`;
  }).split(/,/);
  return rgb2 ? `rgb${null !== alpha ? "a" : ""}(${Math[isDarker ? "max" : "min"](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? "max" : "min"](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? "max" : "min"](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255)}${null !== alpha ? `, ${alpha}` : ""})` : ["#", pad(Math[isDarker ? "max" : "min"](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255).toString(16), 2), pad(Math[isDarker ? "max" : "min"](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255).toString(16), 2), pad(Math[isDarker ? "max" : "min"](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255).toString(16), 2)].join("");
}
function validToString(v) {
  return isString(v) || isNumber2(v) || isBoolean(v) ? v.toString() : "";
}
function isMobile() {
  return navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
}
function defaultOrderFn(v1, v2, order) {
  return "desc" !== order ? v1 === v2 ? 0 : v1 > v2 ? 1 : -1 : v1 === v2 ? 0 : v1 < v2 ? 1 : -1;
}
function getValueByPath(obj2, paths) {
  let prop, res = obj2;
  for (; (prop = paths.shift()) && (res = res[prop], res); ) ;
  return res;
}
function isAllDigits(str2) {
  return /^-?\d+(\.\d+)?$/.test(str2);
}
function deduplication(array4) {
  const result2 = [];
  for (let i = 0; i < array4.length; i++) -1 === result2.indexOf(array4[i]) && result2.push(array4[i]);
  return result2;
}
function isDivSelected(div) {
  const selection = window.getSelection();
  if (selection.rangeCount) {
    const range5 = selection.getRangeAt(0);
    return range5.endOffset > range5.startOffset && div.contains(range5.commonAncestorContainer);
  }
  return false;
}
function traverseObject(obj2, childrenProperty, callback) {
  callback(obj2), (null == obj2 ? void 0 : obj2[childrenProperty]) && Array.isArray(null == obj2 ? void 0 : obj2[childrenProperty]) && obj2[childrenProperty].forEach((child) => traverseObject(child, childrenProperty, callback));
}

// node_modules/@visactor/vtable/es/tools/helper.js
var isNode = "undefined" == typeof window || void 0 === window.window;
var arrayFind;
var arrayFindIndex;
var array2 = {
  get find() {
    return arrayFind || (arrayFind = Array.prototype.find ? (arr, predicate) => Array.prototype.find.call(arr, predicate) : (arr, predicate) => {
      const index = array2.findIndex(arr, predicate);
      return index >= 0 ? arr[index] : void 0;
    }, arrayFind);
  },
  get findIndex() {
    return arrayFindIndex || (arrayFindIndex = Array.prototype.findIndex ? (arr, predicate) => Array.prototype.findIndex.call(arr, predicate) : (arr, predicate) => {
      const { length: length2 } = arr;
      for (let i = 0; i < length2; i++) {
        if (predicate(arr[i], i, arr)) return i;
      }
      return -1;
    }, arrayFindIndex);
  }
};
function analyzeUserAgent() {
  if (isNode) return {
    IE: false,
    Edge: false,
    Chrome: false,
    Firefox: false,
    Safari: false
  };
  const ua = window.navigator.userAgent.toLowerCase();
  return {
    IE: !!/(msie|trident)/.exec(ua),
    Edge: ua.indexOf("edge") > -1,
    Chrome: ua.indexOf("chrome") > -1 && -1 === ua.indexOf("edge"),
    Firefox: ua.indexOf("firefox") > -1,
    Safari: ua.indexOf("safari") > -1 && -1 === ua.indexOf("edge")
  };
}
var { IE, Chrome, Firefox, Edge: Edge2, Safari } = analyzeUserAgent();
function isObject2(obj2) {
  return obj2 === Object(obj2);
}
function extend(...args) {
  const result2 = {};
  return args.forEach((source) => {
    for (const key in source) Object.defineProperty(result2, key, {
      get: () => source[key],
      set(val) {
        source[key] = val;
      },
      configurable: true,
      enumerable: true
    });
  }), result2;
}
function applyChainSafe(obj2, fn, ...names) {
  let value = obj2;
  for (let i = 0; i < names.length && null != value; i++) value = fn(value, names[i]);
  return value;
}
function getChainSafe(obj2, ...names) {
  return applyChainSafe(obj2, (val, name) => val[name], ...names);
}
function getOrApply(value, ...args) {
  return "function" == typeof value ? value(...args) : value;
}
function endsWith(str2, searchString, position) {
  const subjectString = validToString(str2);
  ("number" != typeof position || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) && (position = subjectString.length), position -= searchString.length;
  const lastIndex = subjectString.lastIndexOf(searchString, position);
  return -1 !== lastIndex && lastIndex === position;
}
function isPromise(data) {
  return Boolean(data && "function" == typeof data.then);
}
function getPromiseValue(value, callback) {
  isPromise(value) ? value.then((result2) => {
    callback(result2);
  }).catch((err) => {
  }) : callback(value);
}
function isTouchEvent(e) {
  return !!e.changedTouches;
}
function getIgnoreCase(obj2, name) {
  if (obj2[name]) return obj2[name];
  const l = name.toLowerCase();
  if (obj2[l]) return obj2[l];
  const u = name.toLowerCase();
  if (obj2[u]) return obj2[u];
  for (const k2 in obj2) if (k2.toLowerCase() === l) return obj2[k2];
}
function toBoxArray(obj2) {
  return Array.isArray(obj2) ? 3 === obj2.length ? [obj2[0], obj2[1], obj2[2], obj2[1]] : 2 === obj2.length ? [obj2[0], obj2[1], obj2[0], obj2[1]] : 1 === obj2.length ? [obj2[0], obj2[0], obj2[0], obj2[0]] : [obj2[0], obj2[1], obj2[2], obj2[3]] : [obj2, obj2, obj2, obj2];
}
function cellInRange(range5, col, row) {
  return range5.start.col <= col && col <= range5.end.col && range5.start.row <= row && row <= range5.end.row || range5.end.col <= col && col <= range5.start.col && range5.end.row <= row && row <= range5.start.row || range5.end.col <= col && col <= range5.start.col && range5.start.row <= row && row <= range5.end.row || range5.start.col <= col && col <= range5.end.col && range5.end.row <= row && row <= range5.start.row;
}
function cellInRanges(ranges, col, row) {
  for (let i = 0; i < ranges.length; i++) {
    const range5 = ranges[i], startCol = Math.min(range5.start.col, range5.end.col), endCol = Math.max(range5.start.col, range5.end.col), startRow = Math.min(range5.start.row, range5.end.row), endRow = Math.max(range5.start.row, range5.end.row);
    if (startCol <= col && col <= endCol && startRow <= row && row <= endRow || endCol <= col && col <= startCol && endRow <= row && row <= startRow) return true;
  }
  return false;
}
function adjust(range5) {
  return {
    start: {
      col: Math.min(range5.start.col, range5.end.col),
      row: Math.min(range5.start.row, range5.end.row)
    },
    end: {
      col: Math.max(range5.start.col, range5.end.col),
      row: Math.max(range5.start.row, range5.end.row)
    }
  };
}
function rangeIntersected(range5, range1) {
  const rangeAdjust = adjust(range5), range1Adjust = adjust(range1);
  if (Math.max(rangeAdjust.start.col, range1Adjust.start.col) <= Math.min(rangeAdjust.end.col, range1Adjust.end.col)) {
    if (Math.max(rangeAdjust.start.row, range1Adjust.start.row) <= Math.min(rangeAdjust.end.row, range1Adjust.end.row)) return true;
  }
  return false;
}
var browser2 = {
  IE,
  Edge: Edge2,
  Chrome,
  Firefox,
  Safari,
  heightLimit: Chrome ? 33554431 : Firefox ? 17895588 : 10737433
};
var obj = {
  isObject: isObject2
};
var str = {
  endsWith
};
var event = {
  isTouchEvent
};
var style = {
  toBoxArray
};
var emptyFn = Function.prototype;

// node_modules/@visactor/vtable/es/core/TABLE_EVENT_TYPE.js
var TABLE_EVENT_TYPE = {
  CLICK_CELL: "click_cell",
  DBLCLICK_CELL: "dblclick_cell",
  MOUSEDOWN_CELL: "mousedown_cell",
  MOUSEUP_CELL: "mouseup_cell",
  SELECTED_CELL: "selected_cell",
  SELECTED_CLEAR: "selected_clear",
  BEFORE_KEYDOWN: "before_keydown",
  KEYDOWN: "keydown",
  MOUSEENTER_TABLE: "mouseenter_table",
  MOUSELEAVE_TABLE: "mouseleave_table",
  MOUSEDOWN_TABLE: "mousedown_table",
  MOUSEMOVE_TABLE: "mousemove_table",
  MOUSEMOVE_CELL: "mousemove_cell",
  MOUSEENTER_CELL: "mouseenter_cell",
  MOUSELEAVE_CELL: "mouseleave_cell",
  CONTEXTMENU_CELL: "contextmenu_cell",
  RESIZE_COLUMN: "resize_column",
  RESIZE_COLUMN_END: "resize_column_end",
  RESIZE_ROW: "resize_row",
  RESIZE_ROW_END: "resize_row_end",
  CHANGE_HEADER_POSITION_START: "change_header_position_start",
  CHANGE_HEADER_POSITION: "change_header_position",
  CHANGING_HEADER_POSITION: "changing_header_position",
  CHANGE_HEADER_POSITION_FAIL: "change_header_position_fail",
  SORT_CLICK: "sort_click",
  AFTER_SORT: "after_sort",
  FREEZE_CLICK: "freeze_click",
  SCROLL: "scroll",
  CAN_SCROLL: "can_scroll",
  SCROLL_HORIZONTAL_END: "scroll_horizontal_end",
  SCROLL_VERTICAL_END: "scroll_vertical_end",
  DROPDOWN_MENU_CLICK: "dropdown_menu_click",
  MOUSEOVER_CHART_SYMBOL: "mouseover_chart_symbol",
  DRAG_SELECT_END: "drag_select_end",
  COPY_DATA: "copy_data",
  DROPDOWN_ICON_CLICK: "dropdown_icon_click",
  DROPDOWN_MENU_CLEAR: "dropdown_menu_clear",
  TREE_HIERARCHY_STATE_CHANGE: "tree_hierarchy_state_change",
  SHOW_MENU: "show_menu",
  HIDE_MENU: "hide_menu",
  ICON_CLICK: "icon_click",
  LEGEND_ITEM_CLICK: "legend_item_click",
  LEGEND_ITEM_HOVER: "legend_item_hover",
  LEGEND_ITEM_UNHOVER: "legend_item_unHover",
  LEGEND_CHANGE: "legend_change",
  MOUSEENTER_AXIS: "mouseenter_axis",
  MOUSELEAVE_AXIS: "mouseleave_axis",
  CHECKBOX_STATE_CHANGE: "checkbox_state_change",
  RADIO_STATE_CHANGE: "radio_state_change",
  SWITCH_STATE_CHANGE: "switch_state_change",
  BEFORE_SET_SIZE: "before_set_size",
  BEFORE_INIT: "before_init",
  AFTER_RENDER: "after_render",
  INITIALIZED: "initialized",
  CHANGE_CELL_VALUE: "change_cell_value",
  DRAG_FILL_HANDLE_END: "drag_fill_handle_end",
  MOUSEDOWN_FILL_HANDLE: "mousedown_fill_handle",
  DBLCLICK_FILL_HANDLE: "dblclick_fill_handle",
  EMPTY_TIP_CLICK: "empty_tip_click",
  EMPTY_TIP_DBLCLICK: "empty_tip_dblclick",
  BUTTON_CLICK: "button_click",
  BEFORE_CACHE_CHART_IMAGE: "before_cache_chart_image"
};

// node_modules/@visactor/vtable/es/tools/isx.js
var judgeType2 = (value) => {
  switch (Object.prototype.toString.call(value)) {
    case "[object Object]":
      return "object";
    case "[object Function]":
      return "function";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
    case "[object Number]":
      return "number";
    case "[object RegExp]":
      return "regExp";
    case "[object Boolean]":
      return "boolean";
    case "[object Symbol]":
      return "symbol";
    case "[object Date]":
      return "date";
    case "[object Undefined]":
      return "undefined";
    case "[object Null]":
      return "null";
    case "[object Error]":
      return "error";
    case "[object HTMLDocument]":
      return "document";
    case "[object global]":
      return "global";
    default:
      return null;
  }
};
var isIt2 = (v, type) => judgeType2(v) === type;
var isObject3 = (v) => isIt2(v, "object");

// node_modules/@visactor/vtable/es/tools/debounce.js
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, maxing = false, leading = false, trailing = true;
  const useRAF = !wait && 0 !== wait && "function" == typeof requestAnimationFrame;
  if ("function" != typeof func) throw new TypeError("Expected a function");
  function invokeFunc(time) {
    const args = lastArgs, thisArg = lastThis;
    return lastThis = void 0, lastArgs = void 0, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
  }
  function startTimer(pendingFunc, wait2) {
    return useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait2);
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) return function(time2) {
      return timerId = void 0, trailing && lastArgs ? invokeFunc(time2) : (lastThis = void 0, lastArgs = void 0, result2);
    }(time);
    timerId = startTimer(timerExpired, function(time2) {
      const timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait && -(time2 - lastCallTime);
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }(time));
  }
  return wait = +wait || 0, isObject3(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxing && (maxWait = Math.max(+options.maxWait || 0, wait)), trailing = "trailing" in options ? !!options.trailing : trailing), function(...args) {
    const time = Date.now(), isInvoking = shouldInvoke(time);
    if (lastArgs = args, lastThis = this, lastCallTime = time, isInvoking) {
      if (void 0 === timerId) return function(time2) {
        return lastInvokeTime = time2, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time2) : result2;
      }(lastCallTime);
      if (maxing) return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
    }
    return void 0 === timerId && (timerId = startTimer(timerExpired, wait)), result2;
  };
}

// node_modules/@visactor/vtable/es/event/EventHandler.js
var idCount2 = 1;
var ResizeObserver = class {
  constructor(element, cb, resizeTime) {
    var _a;
    if (this.resizeTime = 100, this.lastSize = {
      width: 0,
      height: 0
    }, this.mutationResize = () => {
      this.onResize();
    }, this.callBack = () => {
      const newSize = this.getSize();
      let windowSizeNotChange = false;
      newSize.width === this.lastSize.width && newSize.height === this.lastSize.height && (windowSizeNotChange = true), this.lastSize = newSize, this.cb && this.cb(Object.assign(Object.assign({}, this.lastSize), {
        windowSizeNotChange
      }));
    }, this.onResize = () => {
      this.callBackDebounce();
    }, this.element = element, this.cb = cb, this.lastSize = this.getSize(), resizeTime && (this.resizeTime = Math.max(resizeTime, 16)), this.callBackDebounce = debounce(this.callBack, this.resizeTime), null === window || void 0 === window || window.addEventListener("resize", this.onResize), "ResizeObserver" in window) {
      const ResizeObserverWindow = window.ResizeObserver;
      this.observer = new ResizeObserverWindow(this.mutationResize), null === (_a = this.observer) || void 0 === _a || _a.observe(this.element);
    } else "MutationObserver" in window && (this.observer = new MutationObserver(this.mutationResize), this.observer.observe(this.element, {
      attributes: true,
      attributeFilter: ["style"]
    }));
  }
  disConnect() {
    window.removeEventListener("resize", this.onResize), this.observer && (this.observer.disconnect(), this.observer = void 0);
  }
  setSize(size) {
    this.lastSize = size;
  }
  checkSize() {
    const newSize = this.getSize();
    return newSize.width !== this.lastSize.width || newSize.height !== this.lastSize.height;
  }
  getSize() {
    return this.element ? {
      width: Math.floor(this.element.clientWidth),
      height: Math.floor(this.element.clientHeight)
    } : Object.assign({}, this.lastSize);
  }
};
var EventHandler = class {
  constructor() {
    this.listeners = {}, this.reseizeListeners = {};
  }
  on(target, type, listener, ...options) {
    if ("node" === Env.mode) return -1;
    const id = idCount2++;
    if (null == target ? void 0 : target.addEventListener) if ("resize" !== type || target === window) null == target || target.addEventListener(type, listener, ...options);
    else {
      const resizeObserver = new ResizeObserver(target, listener, this.resizeTime);
      this.reseizeListeners[id] = resizeObserver;
    }
    const obj2 = {
      target,
      type,
      listener,
      options
    };
    return this.listeners[id] = obj2, id;
  }
  once(target, type, listener, ...options) {
    if ("node" === Env.mode) return -1;
    const id = this.on(target, type, (...args) => {
      this.off(id), listener(...args);
    }, ...options);
    return id;
  }
  off(id) {
    var _a;
    if ("node" === Env.mode) return;
    if (null === id) return;
    const obj2 = null === (_a = this.listeners) || void 0 === _a ? void 0 : _a[id];
    obj2 && (delete this.listeners[id], obj2.target.removeEventListener && obj2.target.removeEventListener(obj2.type, obj2.listener, ...obj2.options));
  }
  fire(target, type, ...args) {
    if ("node" !== Env.mode) for (const key in this.listeners) {
      const listener = this.listeners[key];
      listener.target === target && listener.type === type && listener.listener.call(listener.target, ...args);
    }
  }
  hasListener(target, type) {
    if ("node" === Env.mode) return false;
    let result2 = false;
    for (const key in this.listeners) {
      const listener = this.listeners[key];
      listener.target === target && listener.type === type && (result2 = true);
    }
    return result2;
  }
  clear() {
    if ("node" !== Env.mode) {
      for (const key in this.listeners) {
        const listener = this.listeners[key];
        listener.target.removeEventListener && listener.target.removeEventListener(listener.type, listener.listener, ...listener.options);
      }
      for (const key in this.reseizeListeners) {
        const resizeObserver = this.reseizeListeners[key];
        null == resizeObserver || resizeObserver.disConnect();
      }
      this.listeners = {};
    }
  }
  release() {
    "node" !== Env.mode && (this.clear(), this.listeners = {});
  }
};

// node_modules/@visactor/vtable/es/tools/NumberMap.js
var indexFirst = (arr, elm) => {
  let low = 0, high = arr.length - 1;
  for (; low <= high; ) {
    const i = Math.floor((low + high) / 2);
    if (arr[i] === elm) return i;
    arr[i] > elm ? high = i - 1 : low = i + 1;
  }
  return high < 0 ? 0 : high;
};
var NumberMap = class {
  constructor() {
    this._keys = [], this._vals = {}, this._sorted = false;
  }
  count() {
    return this._keys.length;
  }
  values() {
    return this._vals;
  }
  valueArr() {
    return Object.values(this._vals);
  }
  adjustOrder(sourceIndex, targetIndex, moveCount) {
    const { _keys: keys2 } = this;
    if (this._sorted || (keys2.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0), this._sorted = true), sourceIndex > targetIndex) {
      const sourceVals = [];
      for (let i = indexFirst(keys2, sourceIndex + moveCount - 1); i >= 0; i--) {
        const key = keys2[i];
        if (key >= sourceIndex) sourceVals.push(this.get(key));
        else if (targetIndex <= key && key < sourceIndex) this.put(key + moveCount, this.get(key));
        else if (key < targetIndex) break;
      }
      for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[moveCount - 1 - i]);
    }
    const { length: length2 } = keys2;
    if (sourceIndex < targetIndex) {
      const sourceVals = [];
      for (let i = indexFirst(keys2, sourceIndex); i < length2; i++) {
        const key = keys2[i];
        if (key >= sourceIndex && key < sourceIndex + moveCount) sourceVals.push(this.get(key));
        else if (sourceIndex + moveCount <= key && key <= targetIndex) this.put(key - moveCount, this.get(key));
        else if (key > targetIndex) break;
      }
      for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[i]);
    }
  }
  exchangeOrder(sourceIndex, sourceCount, targetIndex, targetCount, insertIndex) {
    const { _keys: keys2 } = this;
    if (this._sorted || (keys2.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0), this._sorted = true), sourceIndex > targetIndex) {
      const targetVals = [], sourceVals = [];
      for (let i = indexFirst(keys2, targetIndex); i < indexFirst(keys2, sourceIndex) + sourceCount; i++) {
        const key = keys2[i];
        key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
      }
      for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
      for (let i = 0; i < targetVals.length; i++) this.put(insertIndex + sourceCount + i, targetVals[i]);
    } else {
      const targetVals = [], sourceVals = [];
      for (let i = indexFirst(keys2, sourceIndex); i < indexFirst(keys2, targetIndex) + targetCount; i++) {
        const key = keys2[i];
        key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
      }
      for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
      for (let i = 0; i < targetVals.length; i++) this.put(sourceIndex + i, targetVals[i]);
    }
  }
  del(key) {
    delete this._vals[key];
    const index = this._keys.indexOf(key);
    -1 !== index && this._keys.splice(index, 1);
  }
  put(key, value) {
    key in this._vals || (this._keys.push(key), this._sorted = false), this._vals[key] = value;
  }
  get(key) {
    return this._vals[key];
  }
  has(key) {
    return isValid_default(this._vals[key]);
  }
  contain(value) {
    return Object.values(this._vals).indexOf(value) >= 0;
  }
  each(keyFrom, keyTo, fn) {
    const { _keys: keys2 } = this, { length: length2 } = keys2;
    this._sorted || (keys2.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0), this._sorted = true);
    for (let i = indexFirst(keys2, keyFrom); i < length2; i++) {
      const key = keys2[i];
      if (keyFrom <= key && key <= keyTo) {
        if (false === fn(this.get(key), key)) break;
      } else if (keyTo < key) return;
    }
  }
  clear() {
    this._keys.length = 0, this._vals = {}, this._sorted = false;
  }
  getLastIndex() {
    return this._keys[this._keys.length - 1];
  }
  delLast() {
    const lastIndex = this.getLastIndex();
    this.del(lastIndex);
  }
  delAndReorder(index) {
    if (!this.has(index)) return;
    const lastIndex = this.getLastIndex();
    this.adjustOrder(index + 1, index, lastIndex - index), this.delLast();
  }
  addAndReorder(index, newValue) {
    if (isValid_default(newValue)) {
      const lastIndex = this.getLastIndex();
      this.adjustOrder(index, index + 1, lastIndex - index), this.put(index, newValue);
    }
  }
};

// node_modules/@visactor/vtable/es/tools/Rect.js
var Rect2 = class _Rect {
  constructor(left, top, width, height) {
    this.bounds = new Bounds(), this.bounds.set(left, top, left + width, top + height);
  }
  static bounds(left, top, right, bottom) {
    return new _Rect(left, top, Math.round(right - left), Math.round(bottom - top));
  }
  get left() {
    return this.bounds.x1;
  }
  set left(left) {
    this.bounds.x1 = left;
  }
  get top() {
    return this.bounds.y1;
  }
  set top(top) {
    this.bounds.y1 = top;
  }
  get right() {
    return this.bounds.x2;
  }
  set right(right) {
    this.bounds.x2 = right;
  }
  get bottom() {
    return this.bounds.y2;
  }
  set bottom(bottom) {
    this.bounds.y2 = bottom;
  }
  get width() {
    return this.bounds.width();
  }
  set width(width) {
    this.bounds.x2 = this.bounds.x1 + width;
  }
  get height() {
    return this.bounds.height();
  }
  set height(height) {
    this.bounds.y2 = this.bounds.y1 + height;
  }
  offsetLeft(offset) {
    this.bounds.translate(offset, 0);
  }
  offsetTop(offset) {
    this.bounds.translate(0, offset);
  }
  copy() {
    return new _Rect(this.left, this.top, this.width, this.height);
  }
  contains(another) {
    return this.bounds.encloses(another.bounds);
  }
  inPoint(x, y) {
    return this.bounds.contains(x, y);
  }
};

// node_modules/@visactor/vtable/es/themes.js
var themes_exports = {};
__export(themes_exports, {
  ARCO: () => ARCO,
  BRIGHT: () => BRIGHT,
  DARK: () => DARK,
  DEFAULT: () => DEFAULT,
  SIMPLIFY: () => SIMPLIFY,
  TableTheme: () => TableTheme,
  default: () => themes_default,
  get: () => get,
  of: () => of2,
  theme: () => theme2
});

// node_modules/@visactor/vtable/es/themes/DARK.js
function getBackgroundColor(args) {
  const { row, table } = args;
  return 1 & row - table.frozenRowCount ? "#282a2e" : "#2d3137";
}
var DARK_default = {
  name: "DARK",
  underlayBackgroundColor: "transparent",
  defaultStyle: {
    color: "#D3D5DA",
    bgColor: "#373b45",
    fontSize: 12,
    fontFamily: "PingFang SC",
    fontWeight: 500,
    lineHeight: 12,
    borderColor: "#444A54",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#2F4774"
    }
  },
  headerStyle: {
    color: "#D3D5DA",
    bgColor: "#373b45",
    fontSize: 12,
    fontFamily: "PingFang SC",
    fontWeight: 500,
    lineHeight: 12,
    borderColor: "#444A54",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#2F4774"
    }
  },
  rowHeaderStyle: {},
  cornerHeaderStyle: {},
  bodyStyle: {
    color: "#e5e7ea",
    bgColor: getBackgroundColor,
    fontSize: 12,
    fontFamily: "PingFang SC",
    fontWeight: 500,
    lineHeight: 12,
    borderColor: "#444A54",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#29364D"
    }
  },
  frameStyle: {
    borderColor: "#d1d5da",
    borderLineWidth: 1,
    borderLineDash: [],
    cornerRadius: 10,
    shadowBlur: 6,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "rgba(00, 24, 47, 0.06)"
  },
  columnResize: {
    lineWidth: 1,
    lineColor: "#416EFF",
    bgColor: "#D9E2FF",
    width: 3
  },
  frozenColumnLine: {
    shadow: {
      width: 4,
      startColor: "rgba(00, 24, 47, 0.05)",
      endColor: "rgba(00, 24, 47, 0)",
      visible: "always"
    }
  },
  selectionStyle: {
    cellBgColor: "rgba(255, 255, 255, 0.1)",
    cellBorderColor: "#4284FF",
    cellBorderLineWidth: 2
  },
  tooltipStyle: {
    bgColor: "#FFF",
    color: "#000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif"
  },
  functionalIconsStyle: {
    sort_color: "#FFFFFF",
    sort_color_opacity: "0.75",
    sort_color_2: "#416EFF",
    sort_color_opacity_2: "1",
    frozen_color: "#FFFFFF",
    frozen_color_opacity: "0.75",
    collapse_color: "#FFF",
    collapse_color_opacity: "0.75",
    expand_color: "#FFF",
    expand_color_opacity: "0.75",
    dragReorder_color: "#FFF",
    dragReorder_color_opacity: "0.75"
  }
};

// node_modules/@visactor/vtable/es/themes/BRIGHT.js
function getBackgroundColor2(args) {
  const { row, table } = args;
  return 1 & row - table.frozenRowCount ? "#FFF" : "#F4F8FF";
}
var BRIGHT_default = {
  name: "BRIGHT",
  underlayBackgroundColor: "#FFF",
  defaultStyle: {
    color: "#FFF",
    bgColor: "#5389FF",
    borderColor: "#5286FA",
    hover: {
      cellBgColor: "#2E67E3"
    }
  },
  headerStyle: {
    color: "#FFF",
    bgColor: "#5389FF",
    borderColor: "#A1C1FF",
    hover: {
      cellBgColor: "#2E67E3"
    }
  },
  bodyStyle: {
    color: "#000",
    bgColor: getBackgroundColor2,
    borderColor: "#E0EAFE",
    hover: {
      cellBgColor: "#E9EFFD"
    }
  },
  frameStyle: {
    borderColor: "#E1E4E8",
    borderLineWidth: 1,
    borderLineDash: [],
    cornerRadius: 0,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "black"
  },
  columnResize: {
    lineWidth: 1,
    lineColor: "#416EFF",
    bgColor: "#D9E2FF",
    width: 3
  },
  frozenColumnLine: {
    shadow: {
      width: 3,
      startColor: "#CBDCFE",
      endColor: "#CBDCFE",
      visible: "always"
    }
  },
  selectionStyle: {
    cellBgColor: "rgba(0, 0, 255,0.1)"
  },
  tooltipStyle: {
    bgColor: "#FFF",
    color: "#000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif"
  }
};

// node_modules/@visactor/vtable/es/themes/ARCO.js
function getBackgroundColor3(args) {
  const { row, table } = args;
  return 1 & row - table.frozenRowCount ? "#fbfbfc" : "#FFF";
}
var ARCO_default = {
  name: "ARCO",
  underlayBackgroundColor: "#FFF",
  defaultStyle: {
    color: "#1B1F23",
    bgColor: "#EEF1F5",
    fontSize: 14,
    fontFamily: "Arial,sans-serif",
    fontWeight: 600,
    lineHeight: 14,
    borderColor: "#e1e4e8",
    padding: [8, 12, 8, 12]
  },
  headerStyle: {
    color: "#1B1F23",
    bgColor: "#EEF1F5",
    fontSize: 14,
    fontFamily: "Arial,sans-serif",
    fontWeight: 600,
    lineHeight: 14,
    borderColor: "#e1e4e8",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#c8daf6"
    }
  },
  rowHeaderStyle: {
    color: "#1B1F23",
    bgColor: "#EEF1F5",
    fontSize: 12,
    fontFamily: "PingFang SC",
    fontWeight: 500,
    lineHeight: 12,
    borderColor: "#e1e4e8",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#c8daf6"
    }
  },
  cornerHeaderStyle: {
    color: "#1B1F23",
    bgColor: "#EEF1F5",
    fontSize: 12,
    fontFamily: "PingFang SC",
    fontWeight: 500,
    lineHeight: 12,
    borderColor: "#e1e4e8",
    padding: [8, 12, 8, 12],
    hover: {
      cellBgColor: "#c8daf6"
    }
  },
  bodyStyle: {
    padding: [8, 12, 8, 12],
    color: "#141414",
    fontSize: 14,
    fontFamily: "Arial,sans-serif",
    fontWeight: 400,
    textAlign: "left",
    bgColor: getBackgroundColor3,
    borderColor: "#e1e4e8",
    lineHeight: 14,
    hover: {
      cellBgColor: "#F7F8FA",
      inlineRowBgColor: "#F3F8FF",
      inlineColumnBgColor: "#F3F8FF"
    }
  },
  frameStyle: {
    borderColor: "#d1d5da",
    borderLineWidth: 1,
    borderLineDash: [],
    cornerRadius: 4,
    shadowBlur: 6,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "rgba(00, 24, 47, 0.06)"
  },
  columnResize: {
    lineWidth: 1,
    lineColor: "#416EFF",
    bgColor: "#D9E2FF",
    width: 3
  },
  frozenColumnLine: {
    shadow: {
      width: 4,
      startColor: "rgba(00, 24, 47, 0.05)",
      endColor: "rgba(00, 24, 47, 0)",
      visible: "always"
    }
  },
  selectionStyle: {
    cellBgColor: "rgba(0, 0, 255,0.1)",
    cellBorderLineWidth: 2,
    cellBorderColor: "#3073f2"
  },
  tooltipStyle: {
    bgColor: "#FFF",
    color: "#000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif"
  }
};

// node_modules/@visactor/vtable/es/themes/DEFAULT.js
function getBackgroundColor4(args) {
  const { row, table } = args;
  return 1 & row - table.frozenRowCount ? "#FDFDFD" : "#FAF9FB";
}
var DEFAULT_default = {
  name: "DEFAULT",
  underlayBackgroundColor: "#FFF",
  defaultStyle: {
    borderColor: "#E1E4E8",
    color: "#000",
    bgColor: "#ECF1F5"
  },
  headerStyle: {
    fontSize: 16,
    fontWeight: "bold",
    bgColor: "#ECF1F5",
    hover: {
      cellBgColor: "#CCE0FF",
      inlineRowBgColor: "#F3F8FF",
      inlineColumnBgColor: "#F3F8FF"
    }
  },
  rowHeaderStyle: {
    fontSize: 16,
    fontWeight: "bold",
    bgColor: "#ECF1F5",
    hover: {
      cellBgColor: "#CCE0FF",
      inlineRowBgColor: "#F3F8FF",
      inlineColumnBgColor: "#F3F8FF"
    }
  },
  cornerHeaderStyle: {
    fontSize: 16,
    fontWeight: "bold"
  },
  bodyStyle: {
    fontSize: 14,
    bgColor: getBackgroundColor4,
    hover: {
      cellBgColor: "#CCE0FF",
      inlineRowBgColor: "#F3F8FF",
      inlineColumnBgColor: "#F3F8FF"
    }
  },
  frameStyle: {
    borderColor: "#E1E4E8",
    borderLineWidth: 1,
    borderLineDash: [],
    cornerRadius: 0,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "black"
  },
  columnResize: {
    lineWidth: 1,
    lineColor: "#416EFF",
    bgColor: "#D9E2FF",
    width: 3
  },
  frozenColumnLine: {
    shadow: {
      width: 3,
      startColor: "rgba(225, 228, 232, 0.6)",
      endColor: "rgba(225, 228, 232, 0.6)",
      visible: "always"
    }
  },
  selectionStyle: {
    cellBgColor: "rgba(0, 0, 255,0.1)",
    cellBorderLineWidth: 2,
    cellBorderColor: "#0000ff"
  },
  tooltipStyle: {
    bgColor: "#FFF",
    color: "#000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif"
  }
};

// node_modules/@visactor/vtable/es/themes/SIMPLIFY.js
function getFrozenRowsBorderColor(args) {
  const { row, table: { frozenRowCount } } = args;
  return frozenRowCount - 1 === row ? ["#f2f2f2", "#f2f2f2", "#ccc7c7", "#f2f2f2"] : ["#f2f2f2"];
}
function getBorderColor(args) {
  const { col, table } = args, { colCount, frozenColCount } = table, top = "#ccc7c7";
  return frozenColCount - 1 === col || colCount - 1 === col ? [top, "#f2f2f2", "#ccc7c7", null] : [top, null, "#ccc7c7", null];
}
var SIMPLIFY_default = {
  name: "SIMPLIFY",
  underlayBackgroundColor: "#FFF",
  defaultStyle: {
    borderColor: getBorderColor,
    hover: {
      cellBorderColor: "#0000FF",
      cellBgColor: "#D0E0E3"
    },
    bgColor: "#FFF"
  },
  headerStyle: {
    color: "rgba(0, 0, 0, 0.87)",
    borderColor: getFrozenRowsBorderColor
  },
  bodyStyle: {
    color: "rgba(0, 0, 0, 0.87)"
  },
  frameStyle: {
    borderColor: "#f2f2f2",
    borderLineWidth: 1
  },
  columnResize: {
    lineWidth: 1,
    lineColor: "#416EFF",
    bgColor: "#D9E2FF"
  },
  selectionStyle: {
    cellBorderColor: "#FD5",
    cellBgColor: "rgba(111, 168, 220, 0.1)"
  },
  tooltipStyle: {
    bgColor: "#FFF",
    color: "#000",
    fontSize: 12,
    fontFamily: "Arial,sans-serif"
  }
};

// node_modules/@visactor/vtable/es/themes/themes.js
var themes = {};

// node_modules/@visactor/vtable/es/tools/global.js
var DEFAULTFONTSIZE = 16;
var DEFAULTFONTFAMILY = "Arial,sans-serif";
var DEFAULTBGCOLOR = "#FFF";
var DEFAULTBORDERCOLOR = "#000";
var DEFAULTBORDERLINEWIDTH = 1;
var DEFAULTBORDERLINEDASH = [];
var DEFAULTFONTCOLOR = "#000";
var regUrl = /^(https?|ftp|file):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/;
var IndicatorDimensionKeyPlaceholder = "$$indicator$$";
var DrillDown = '<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><rect x="0" y="0" width="1024" height="1024" rx="20%" ry="20%" fill="#ffffff" /><path  d="M810.666667 85.333333c70.688 0 128 57.312 128 128v597.333334c0 70.688-57.312 128-128 128H213.333333c-70.688 0-128-57.312-128-128V213.333333c0-70.688 57.312-128 128-128h597.333334z m0 85.333334H213.333333a42.666667 42.666667 0 0 0-42.613333 40.533333L170.666667 213.333333v597.333334a42.666667 42.666667 0 0 0 40.533333 42.613333L213.333333 853.333333h597.333334a42.666667 42.666667 0 0 0 42.613333-40.533333L853.333333 810.666667V213.333333a42.666667 42.666667 0 0 0-40.533333-42.613333L810.666667 170.666667zM549.333333 288a5.333333 5.333333 0 0 1 5.333334 5.333333V469.333333h176a5.333333 5.333333 0 0 1 5.333333 5.333334v74.666666a5.333333 5.333333 0 0 1-5.333333 5.333334H554.666667v176a5.333333 5.333333 0 0 1-5.333334 5.333333h-74.666666a5.333333 5.333333 0 0 1-5.333334-5.333333V554.666667H293.333333a5.333333 5.333333 0 0 1-5.333333-5.333334v-74.666666a5.333333 5.333333 0 0 1 5.333333-5.333334H469.333333V293.333333a5.333333 5.333333 0 0 1 5.333334-5.333333h74.666666z"></path></svg>';
var DrillUp = '<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><rect x="0" y="0" width="1024" height="1024" rx="20%" ry="20%" fill="#ffffff" /><path d="M810.666667 85.333333c70.688 0 128 57.312 128 128v597.333334c0 70.688-57.312 128-128 128H213.333333c-70.688 0-128-57.312-128-128V213.333333c0-70.688 57.312-128 128-128h597.333334z m0 85.333334H213.333333a42.666667 42.666667 0 0 0-42.613333 40.533333L170.666667 213.333333v597.333334a42.666667 42.666667 0 0 0 40.533333 42.613333L213.333333 853.333333h597.333334a42.666667 42.666667 0 0 0 42.613333-40.533333L853.333333 810.666667V213.333333a42.666667 42.666667 0 0 0-40.533333-42.613333L810.666667 170.666667zM693.333333 469.333333a42.666667 42.666667 0 1 1 0 85.333334H330.666667a42.666667 42.666667 0 1 1 0-85.333334h362.666666z"></path></svg>';
var DefaultSparklineSpec = {
  type: "line"
};

// node_modules/@visactor/vtable/es/themes/component.js
function getAxisStyle(axisStyle) {
  return {
    defaultAxisStyle: getSingleAxisStyle(axisStyle.defaultAxisStyle),
    leftAxisStyle: getSingleAxisStyle(axisStyle.leftAxisStyle),
    rightAxisStyle: getSingleAxisStyle(axisStyle.rightAxisStyle),
    topAxisStyle: getSingleAxisStyle(axisStyle.topAxisStyle),
    bottomAxisStyle: getSingleAxisStyle(axisStyle.bottomAxisStyle)
  };
}
function getSingleAxisStyle(axisStyle) {
  return axisStyle || {};
}
var defalutPoptipStyle = {
  visible: true,
  position: "auto",
  padding: 8,
  titleStyle: {
    fontSize: 12,
    fontWeight: "bold",
    fill: "#4E5969"
  },
  contentStyle: {
    fontSize: 12,
    fill: "#4E5969"
  },
  panel: {
    visible: true,
    fill: "#fff",
    stroke: "#ffffff",
    lineWidth: 0,
    cornerRadius: 3,
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: "rgba(0, 0, 0, 0.1)",
    size: 0,
    space: 12
  }
};

// node_modules/@visactor/vtable/es/themes/theme-define.js
function getProp(obj2, superObj, names, defNames) {
  var _a, _b, _c;
  return null !== (_c = null !== (_b = null !== (_a = getChainSafe(obj2, ...names)) && void 0 !== _a ? _a : getChainSafe(superObj, ...names)) && void 0 !== _b ? _b : defNames && getChainSafe(obj2, ...defNames)) && void 0 !== _c ? _c : defNames && getChainSafe(superObj, ...defNames);
}
var TableTheme = class _TableTheme {
  constructor(obj2, superTheme) {
    this._defaultStyle = null, this._header = null, this._cornerHeader = null, this._cornerRightTopCell = null, this._cornerLeftBottomCell = null, this._cornerRightBottomCell = null, this._rightFrozen = null, this._bottomFrozen = null, this._rowHeader = null, this._body = null, this._groupTitle = null, this._scroll = null, this._tooltip = null, this._frameStyle = null, this._columnResize = null, this._dragHeaderSplitLine = null, this._frozenColumnLine = null, this._selectionStyle = null, this._axisStyle = null, this._checkboxStyle = null, this._radioStyle = null, this._switchStyle = null, this._buttonStyle = null, this._textPopTipStyle = null, this._internalIconsStyle = null, this.isPivot = false, this.name = "", this.internalTheme = {
      obj: obj2,
      superTheme
    }, this.name = getProp(obj2, superTheme, ["name"]);
  }
  getExtendTheme() {
    return this.internalTheme.obj;
  }
  clearBodyStyleCache() {
    this._body = null;
  }
  get font() {
    const { obj: obj2, superTheme } = this.internalTheme;
    return getProp(obj2, superTheme, ["font"], ["bodyStyle", "font"]);
  }
  get underlayBackgroundColor() {
    const { obj: obj2, superTheme } = this.internalTheme;
    return getProp(obj2, superTheme, ["underlayBackgroundColor"]);
  }
  get cellInnerBorder() {
    var _a;
    const { obj: obj2, superTheme } = this.internalTheme;
    return null === (_a = getProp(obj2, superTheme, ["cellInnerBorder"])) || void 0 === _a || _a;
  }
  get cellBorderClipDirection() {
    var _a;
    const { obj: obj2, superTheme } = this.internalTheme;
    return null !== (_a = getProp(obj2, superTheme, ["cellBorderClipDirection"])) && void 0 !== _a ? _a : "top-left";
  }
  get _contentOffset() {
    var _a;
    const { obj: obj2, superTheme } = this.internalTheme;
    return null !== (_a = getProp(obj2, superTheme, ["_contentOffset"])) && void 0 !== _a ? _a : 0;
  }
  get defaultStyle() {
    const that = this;
    if (!this._defaultStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, defaultStyle13 = ingoreNoneValueMerge({}, superTheme.defaultStyle, obj2.defaultStyle);
      this._defaultStyle = {
        get fontSize() {
          var _a;
          return null !== (_a = defaultStyle13.fontSize) && void 0 !== _a ? _a : DEFAULTFONTSIZE;
        },
        get fontFamily() {
          var _a;
          return null !== (_a = defaultStyle13.fontFamily) && void 0 !== _a ? _a : DEFAULTFONTFAMILY;
        },
        get fontWeight() {
          return defaultStyle13.fontWeight;
        },
        get fontVariant() {
          return defaultStyle13.fontVariant;
        },
        get fontStyle() {
          return defaultStyle13.fontStyle;
        },
        get bgColor() {
          var _a;
          return null !== (_a = defaultStyle13.bgColor) && void 0 !== _a ? _a : DEFAULTBGCOLOR;
        },
        get color() {
          var _a;
          return null !== (_a = defaultStyle13.color) && void 0 !== _a ? _a : DEFAULTFONTCOLOR;
        },
        get borderColor() {
          var _a;
          return null !== (_a = defaultStyle13.borderColor) && void 0 !== _a ? _a : DEFAULTBORDERCOLOR;
        },
        get borderLineWidth() {
          var _a;
          return null !== (_a = defaultStyle13.borderLineWidth) && void 0 !== _a ? _a : DEFAULTBORDERLINEWIDTH;
        },
        get borderLineDash() {
          var _a;
          return null !== (_a = defaultStyle13.borderLineDash) && void 0 !== _a ? _a : DEFAULTBORDERLINEDASH;
        },
        get hover() {
          if (defaultStyle13.hover) return {
            get cellBgColor() {
              var _a, _b;
              return null !== (_b = null === (_a = defaultStyle13.hover) || void 0 === _a ? void 0 : _a.cellBgColor) && void 0 !== _b ? _b : void 0;
            },
            get inlineColumnBgColor() {
              var _a, _b, _c, _d, _e, _f;
              return null !== (_f = null !== (_b = null === (_a = defaultStyle13.hover) || void 0 === _a ? void 0 : _a.inlineColumnBgColor) && void 0 !== _b ? _b : (null === (_c = defaultStyle13.hover) || void 0 === _c ? void 0 : _c.cellBgColor) && "string" == typeof (null === (_d = defaultStyle13.hover) || void 0 === _d ? void 0 : _d.cellBgColor) ? changeColor(null === (_e = defaultStyle13.hover) || void 0 === _e ? void 0 : _e.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
            },
            get inlineRowBgColor() {
              var _a, _b, _c, _d, _e, _f;
              return null !== (_f = null !== (_b = null === (_a = defaultStyle13.hover) || void 0 === _a ? void 0 : _a.inlineRowBgColor) && void 0 !== _b ? _b : (null === (_c = defaultStyle13.hover) || void 0 === _c ? void 0 : _c.cellBgColor) && "string" == typeof (null === (_d = defaultStyle13.hover) || void 0 === _d ? void 0 : _d.cellBgColor) ? changeColor(null === (_e = defaultStyle13.hover) || void 0 === _e ? void 0 : _e.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
            }
          };
        },
        get select() {
          if (defaultStyle13.select) return {
            get inlineColumnBgColor() {
              var _a, _b, _c, _d, _e, _f;
              return null !== (_f = null !== (_d = null !== (_b = null === (_a = defaultStyle13.select) || void 0 === _a ? void 0 : _a.inlineColumnBgColor) && void 0 !== _b ? _b : null === (_c = that.selectionStyle) || void 0 === _c ? void 0 : _c.inlineColumnBgColor) && void 0 !== _d ? _d : (null === (_e = that.selectionStyle) || void 0 === _e ? void 0 : _e.cellBgColor) && "string" == typeof that.selectionStyle.cellBgColor ? changeColor(that.selectionStyle.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
            },
            get inlineRowBgColor() {
              var _a, _b, _c, _d, _e;
              return null !== (_e = null !== (_c = null !== (_b = null === (_a = defaultStyle13.select) || void 0 === _a ? void 0 : _a.inlineRowBgColor) && void 0 !== _b ? _b : that.selectionStyle.inlineRowBgColor) && void 0 !== _c ? _c : (null === (_d = that.selectionStyle) || void 0 === _d ? void 0 : _d.cellBgColor) && "string" == typeof that.selectionStyle.cellBgColor ? changeColor(that.selectionStyle.cellBgColor, 0.1, false) : void 0) && void 0 !== _e ? _e : void 0;
            }
          };
        },
        get padding() {
          var _a;
          return null !== (_a = defaultStyle13.padding) && void 0 !== _a ? _a : [10, 16, 10, 16];
        },
        get textAlign() {
          var _a;
          return null !== (_a = defaultStyle13.textAlign) && void 0 !== _a ? _a : "left";
        },
        get textBaseline() {
          var _a;
          return null !== (_a = defaultStyle13.textBaseline) && void 0 !== _a ? _a : "middle";
        },
        get textOverflow() {
          var _a;
          return null !== (_a = defaultStyle13.textOverflow) && void 0 !== _a ? _a : "ellipsis";
        },
        get lineHeight() {
          return defaultStyle13.lineHeight;
        },
        get autoWrapText() {
          var _a;
          return null !== (_a = defaultStyle13.autoWrapText) && void 0 !== _a && _a;
        },
        get lineClamp() {
          var _a;
          return null !== (_a = defaultStyle13.lineClamp) && void 0 !== _a ? _a : "auto";
        },
        get linkColor() {
          var _a;
          return null !== (_a = defaultStyle13.linkColor) && void 0 !== _a ? _a : "#3772ff";
        },
        get cursor() {
          var _a;
          return null !== (_a = defaultStyle13.cursor) && void 0 !== _a ? _a : "auto";
        },
        get marked() {
          var _a;
          return null !== (_a = defaultStyle13.marked) && void 0 !== _a && _a;
        },
        get underline() {
          var _a;
          return null !== (_a = defaultStyle13.underline) && void 0 !== _a && _a;
        },
        get underlineColor() {
          return defaultStyle13.underlineColor;
        },
        get underlineDash() {
          return defaultStyle13.underlineDash;
        },
        get underlineOffset() {
          return defaultStyle13.underlineOffset;
        },
        get lineThrough() {
          var _a;
          return null !== (_a = defaultStyle13.lineThrough) && void 0 !== _a && _a;
        },
        get lineThroughColor() {
          return defaultStyle13.lineThroughColor;
        },
        get lineThroughDash() {
          return defaultStyle13.lineThroughDash;
        }
      };
    }
    return this._defaultStyle;
  }
  get cornerHeaderStyle() {
    if (!this._cornerHeader) {
      const { obj: obj2, superTheme } = this.internalTheme, header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerHeaderStyle, obj2.cornerHeaderStyle);
      this._cornerHeader = this.getStyle(header);
    }
    return this._cornerHeader;
  }
  get cornerRightTopCellStyle() {
    if (!this._cornerRightTopCell) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.cornerRightTopCellStyle && !obj2.cornerRightTopCellStyle) return this._cornerRightTopCell;
      const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerRightTopCellStyle, obj2.cornerRightTopCellStyle);
      this._cornerRightTopCell = this.getStyle(header);
    }
    return this._cornerRightTopCell;
  }
  get cornerLeftBottomCellStyle() {
    if (!this._cornerLeftBottomCell) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.cornerLeftBottomCellStyle && !obj2.cornerLeftBottomCellStyle) return this._cornerLeftBottomCell;
      const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerLeftBottomCellStyle, obj2.cornerLeftBottomCellStyle);
      this._cornerLeftBottomCell = this.getStyle(header);
    }
    return this._cornerLeftBottomCell;
  }
  get cornerRightBottomCellStyle() {
    if (!this._cornerRightBottomCell) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.cornerRightBottomCellStyle && !obj2.cornerRightBottomCellStyle) return this._cornerRightBottomCell;
      const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerRightBottomCellStyle, obj2.cornerRightBottomCellStyle);
      this._cornerRightBottomCell = this.getStyle(header);
    }
    return this._cornerRightBottomCell;
  }
  get rightFrozenStyle() {
    if (!this._rightFrozen) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.rightFrozenStyle && !obj2.rightFrozenStyle) return this._rightFrozen;
      const header = ingoreNoneValueMerge({}, this.defaultStyle, this.rowHeaderStyle, superTheme.rightFrozenStyle, obj2.rightFrozenStyle);
      this._rightFrozen = this.getStyle(header);
    }
    return this._rightFrozen;
  }
  get bottomFrozenStyle() {
    if (!this._bottomFrozen) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.bottomFrozenStyle && !obj2.bottomFrozenStyle) return this._bottomFrozen;
      const header = ingoreNoneValueMerge({}, this.defaultStyle, this.headerStyle, superTheme.bottomFrozenStyle, obj2.bottomFrozenStyle);
      this._bottomFrozen = this.getStyle(header);
    }
    return this._bottomFrozen;
  }
  get rowHeaderStyle() {
    var _a;
    if (!this._rowHeader) {
      const { obj: obj2, superTheme } = this.internalTheme, header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.rowHeaderStyle, null !== (_a = obj2.rowHeaderStyle) && void 0 !== _a ? _a : this.isPivot ? null : obj2.headerStyle);
      this._rowHeader = this.getStyle(header);
    }
    return this._rowHeader;
  }
  get headerStyle() {
    if (!this._header) {
      const { obj: obj2, superTheme } = this.internalTheme, header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.headerStyle, obj2.headerStyle);
      this._header = this.getStyle(header);
    }
    return this._header;
  }
  get bodyStyle() {
    if (!this._body) {
      const { obj: obj2, superTheme } = this.internalTheme, body = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.bodyStyle, obj2.bodyStyle);
      this._body = this.getStyle(body);
    }
    return this._body;
  }
  get groupTitleStyle() {
    if (!this._groupTitle) {
      const { obj: obj2, superTheme } = this.internalTheme;
      if (!superTheme.groupTitleStyle && !obj2.groupTitleStyle) return this._groupTitle;
      const groupTitle = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.groupTitleStyle, obj2.groupTitleStyle);
      this._groupTitle = this.getStyle(groupTitle);
    }
    return this._groupTitle;
  }
  get frameStyle() {
    if (!this._frameStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, frameStyle = ingoreNoneValueMerge({}, superTheme.frameStyle, obj2.frameStyle);
      this._frameStyle = {
        get borderColor() {
          return frameStyle.borderColor;
        },
        get borderLineWidth() {
          return frameStyle.borderLineWidth;
        },
        get borderLineDash() {
          return frameStyle.borderLineDash;
        },
        get innerBorder() {
          return frameStyle.innerBorder;
        },
        get shadowBlur() {
          return frameStyle.shadowBlur;
        },
        get shadowColor() {
          return frameStyle.shadowColor;
        },
        get shadowOffsetX() {
          return frameStyle.shadowOffsetX;
        },
        get shadowOffsetY() {
          return frameStyle.shadowOffsetY;
        },
        get cornerRadius() {
          return frameStyle.cornerRadius;
        }
      };
    }
    return this._frameStyle;
  }
  get scrollStyle() {
    if (!this._scroll) {
      const { obj: obj2, superTheme } = this.internalTheme, scroll = ingoreNoneValueMerge({}, superTheme.scrollStyle, obj2.scrollStyle);
      this._scroll = {
        get scrollSliderColor() {
          var _a;
          return null !== (_a = scroll.scrollSliderColor) && void 0 !== _a ? _a : "#C0C0C0";
        },
        get scrollSliderCornerRadius() {
          return scroll.scrollSliderCornerRadius;
        },
        get scrollRailColor() {
          return scroll.scrollRailColor;
        },
        get visible() {
          var _a;
          return null !== (_a = scroll.visible) && void 0 !== _a ? _a : "scrolling";
        },
        get verticalVisible() {
          return scroll.verticalVisible;
        },
        get horizontalVisible() {
          return scroll.horizontalVisible;
        },
        get width() {
          var _a;
          return null !== (_a = scroll.width) && void 0 !== _a ? _a : 7;
        },
        get hoverOn() {
          var _a;
          return null === (_a = scroll.hoverOn) || void 0 === _a || _a;
        },
        get barToSide() {
          var _a;
          return null !== (_a = scroll.barToSide) && void 0 !== _a && _a;
        },
        get horizontalPadding() {
          var _a;
          return null !== (_a = scroll.horizontalPadding) && void 0 !== _a ? _a : 0;
        },
        get verticalPadding() {
          var _a;
          return null !== (_a = scroll.verticalPadding) && void 0 !== _a ? _a : 0;
        }
      };
    }
    return this._scroll;
  }
  get tooltipStyle() {
    if (!this._tooltip) {
      const { obj: obj2, superTheme } = this.internalTheme, tooltip = ingoreNoneValueMerge({}, superTheme.tooltipStyle, obj2.tooltipStyle);
      this._tooltip = {
        get fontFamily() {
          var _a;
          return null !== (_a = tooltip.fontFamily) && void 0 !== _a ? _a : DEFAULTFONTFAMILY;
        },
        get fontSize() {
          var _a;
          return null !== (_a = tooltip.fontSize) && void 0 !== _a ? _a : DEFAULTFONTSIZE;
        },
        get bgColor() {
          var _a;
          return null !== (_a = tooltip.bgColor) && void 0 !== _a ? _a : "#000";
        },
        get padding() {
          var _a;
          return null !== (_a = tooltip.padding) && void 0 !== _a ? _a : [6, 8];
        },
        get color() {
          var _a;
          return null !== (_a = tooltip.color) && void 0 !== _a ? _a : "#FFF";
        },
        get maxWidth() {
          return tooltip.maxWidth;
        },
        get maxHeight() {
          return tooltip.maxHeight;
        }
      };
    }
    return this._tooltip;
  }
  get columnResize() {
    if (!this._columnResize) {
      const { obj: obj2, superTheme } = this.internalTheme, columnResize = ingoreNoneValueMerge({}, superTheme.columnResize, obj2.columnResize);
      this._columnResize = {
        get lineColor() {
          var _a;
          return null !== (_a = columnResize.lineColor) && void 0 !== _a ? _a : "#416EFF";
        },
        get bgColor() {
          var _a;
          return null !== (_a = columnResize.bgColor) && void 0 !== _a ? _a : "#D9E2FF";
        },
        get lineWidth() {
          var _a;
          return null !== (_a = columnResize.lineWidth) && void 0 !== _a ? _a : 1;
        },
        get width() {
          var _a;
          return null !== (_a = columnResize.width) && void 0 !== _a ? _a : columnResize.lineWidth + 2;
        },
        get resizeHotSpotSize() {
          var _a;
          return null !== (_a = columnResize.resizeHotSpotSize) && void 0 !== _a ? _a : 16;
        },
        get labelColor() {
          var _a;
          return null !== (_a = columnResize.labelColor) && void 0 !== _a ? _a : "#FFF";
        },
        get labelFontSize() {
          var _a;
          return null !== (_a = columnResize.labelFontSize) && void 0 !== _a ? _a : 10;
        },
        get labelFontFamily() {
          var _a;
          return null !== (_a = columnResize.labelFontFamily) && void 0 !== _a ? _a : "sans-serif";
        },
        get labelBackgroundFill() {
          var _a;
          return null !== (_a = columnResize.labelBackgroundFill) && void 0 !== _a ? _a : "#3073F2";
        },
        get labelBackgroundCornerRadius() {
          var _a;
          return null !== (_a = columnResize.labelBackgroundCornerRadius) && void 0 !== _a ? _a : 5;
        },
        get labelVisible() {
          var _a;
          return null === (_a = columnResize.labelVisible) || void 0 === _a || _a;
        },
        get visibleOnHover() {
          var _a;
          return null !== (_a = columnResize.visibleOnHover) && void 0 !== _a && _a;
        }
      };
    }
    return this._columnResize;
  }
  get dragHeaderSplitLine() {
    if (!this._dragHeaderSplitLine) {
      const { obj: obj2, superTheme } = this.internalTheme, dragHeaderSplitLine = ingoreNoneValueMerge({}, superTheme.dragHeaderSplitLine, obj2.dragHeaderSplitLine);
      this._dragHeaderSplitLine = {
        get lineColor() {
          var _a;
          return null !== (_a = dragHeaderSplitLine.lineColor) && void 0 !== _a ? _a : "blue";
        },
        get lineWidth() {
          var _a;
          return null !== (_a = dragHeaderSplitLine.lineWidth) && void 0 !== _a ? _a : 2;
        },
        get shadowBlockColor() {
          var _a;
          return null !== (_a = dragHeaderSplitLine.shadowBlockColor) && void 0 !== _a ? _a : "rgba(204,204,204,0.3)";
        }
      };
    }
    return this._dragHeaderSplitLine;
  }
  get frozenColumnLine() {
    if (!this._frozenColumnLine) {
      const { obj: obj2, superTheme } = this.internalTheme, frozenColumnLine = ingoreNoneValueMerge({}, superTheme.frozenColumnLine, obj2.frozenColumnLine);
      this._frozenColumnLine = {
        get shadow() {
          if (frozenColumnLine.shadow) return {
            get width() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.shadow) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : 24;
            },
            get startColor() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.shadow) || void 0 === _a ? void 0 : _a.startColor) && void 0 !== _b ? _b : "rgba(00, 24, 47, 0.06)";
            },
            get endColor() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.shadow) || void 0 === _a ? void 0 : _a.endColor) && void 0 !== _b ? _b : "rgba(00, 24, 47, 0)";
            },
            get visible() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.shadow) || void 0 === _a ? void 0 : _a.visible) && void 0 !== _b ? _b : "always";
            }
          };
        },
        get border() {
          if (frozenColumnLine.border) return {
            get lineColor() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.border) || void 0 === _a ? void 0 : _a.lineColor) && void 0 !== _b ? _b : "rgba(00, 24, 47, 0.06)";
            },
            get bgColor() {
              var _a, _b, _c, _d;
              return null !== (_d = null !== (_b = null === (_a = frozenColumnLine.border) || void 0 === _a ? void 0 : _a.bgColor) && void 0 !== _b ? _b : null === (_c = frozenColumnLine.border) || void 0 === _c ? void 0 : _c.lineColor) && void 0 !== _d ? _d : "rgba(00, 24, 47, 0.06)";
            },
            get lineWidth() {
              var _a, _b;
              return null !== (_b = null === (_a = frozenColumnLine.border) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : 4;
            },
            get width() {
              var _a, _b, _c, _d;
              return null !== (_d = null !== (_b = null === (_a = frozenColumnLine.border) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : null === (_c = frozenColumnLine.border) || void 0 === _c ? void 0 : _c.lineWidth) && void 0 !== _d ? _d : 4;
            }
          };
        }
      };
    }
    return this._frozenColumnLine;
  }
  get selectionStyle() {
    if (!this._selectionStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, selectionStyle = ingoreNoneValueMerge({}, superTheme.selectionStyle, obj2.selectionStyle);
      this._selectionStyle = {
        get cellBgColor() {
          var _a;
          return null !== (_a = null == selectionStyle ? void 0 : selectionStyle.cellBgColor) && void 0 !== _a ? _a : "rgba(0, 0, 255,0.1)";
        },
        get cellBorderColor() {
          var _a;
          return null !== (_a = null == selectionStyle ? void 0 : selectionStyle.cellBorderColor) && void 0 !== _a ? _a : "#3073f2";
        },
        get cellBorderLineWidth() {
          var _a;
          return null !== (_a = null == selectionStyle ? void 0 : selectionStyle.cellBorderLineWidth) && void 0 !== _a ? _a : 2;
        },
        get inlineColumnBgColor() {
          return null == selectionStyle ? void 0 : selectionStyle.inlineColumnBgColor;
        },
        get inlineRowBgColor() {
          return null == selectionStyle ? void 0 : selectionStyle.inlineRowBgColor;
        },
        get selectionFillMode() {
          var _a;
          return null !== (_a = null == selectionStyle ? void 0 : selectionStyle.selectionFillMode) && void 0 !== _a ? _a : "overlay";
        },
        get dynamicUpdateSelectionSize() {
          var _a;
          return null !== (_a = null == selectionStyle ? void 0 : selectionStyle.dynamicUpdateSelectionSize) && void 0 !== _a && _a;
        }
      };
    }
    return this._selectionStyle;
  }
  get axisStyle() {
    if (!this._axisStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, axisStyle = ingoreNoneValueMerge({}, superTheme.axisStyle, obj2.axisStyle);
      this._axisStyle = getAxisStyle(axisStyle);
    }
    return this._axisStyle;
  }
  get checkboxStyle() {
    if (!this._checkboxStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, checkboxStyle = ingoreNoneValueMerge({}, superTheme.checkboxStyle, obj2.checkboxStyle);
      this._checkboxStyle = checkboxStyle;
    }
    return this._checkboxStyle;
  }
  get radioStyle() {
    if (!this._radioStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, radioStyle = ingoreNoneValueMerge({}, superTheme.radioStyle, obj2.radioStyle);
      this._radioStyle = radioStyle;
    }
    return this._radioStyle;
  }
  get switchStyle() {
    if (!this._switchStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, switchStyle = ingoreNoneValueMerge({}, superTheme.switchStyle, obj2.switchStyle);
      this._switchStyle = switchStyle;
    }
    return this._switchStyle;
  }
  get buttonStyle() {
    if (!this._buttonStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, buttonStyle = ingoreNoneValueMerge({}, superTheme.buttonStyle, obj2.buttonStyle);
      this._buttonStyle = buttonStyle;
    }
    return this._buttonStyle;
  }
  get textPopTipStyle() {
    if (!this._textPopTipStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, textPopTipStyle = ingoreNoneValueMerge({}, defalutPoptipStyle, superTheme.textPopTipStyle, obj2.textPopTipStyle);
      this._textPopTipStyle = textPopTipStyle;
    }
    return this._textPopTipStyle;
  }
  get functionalIconsStyle() {
    if (!this._internalIconsStyle) {
      const { obj: obj2, superTheme } = this.internalTheme, functionalIconsStyle = ingoreNoneValueMerge({}, superTheme.functionalIconsStyle, obj2.functionalIconsStyle);
      this._internalIconsStyle = functionalIconsStyle;
    }
    return this._internalIconsStyle;
  }
  hasProperty(names) {
    const { obj: obj2, superTheme } = this.internalTheme;
    return hasThemeProperty(obj2, names) || hasThemeProperty(superTheme, names);
  }
  extends(obj2) {
    return new _TableTheme(ingoreNoneValueMerge({}, obj2), ingoreNoneValueMerge(this.internalTheme.superTheme, this.internalTheme.obj));
  }
  getStyle(style2) {
    const that = this;
    return {
      get fontSize() {
        return style2.fontSize;
      },
      get fontFamily() {
        return style2.fontFamily;
      },
      get fontWeight() {
        return style2.fontWeight;
      },
      get fontVariant() {
        return style2.fontVariant;
      },
      get fontStyle() {
        return style2.fontStyle;
      },
      get bgColor() {
        return style2.bgColor;
      },
      get color() {
        return style2.color;
      },
      get strokeColor() {
        return style2.strokeColor;
      },
      get borderColor() {
        return style2.borderColor;
      },
      get borderLineWidth() {
        return style2.borderLineWidth;
      },
      get borderLineDash() {
        return style2.borderLineDash;
      },
      get hover() {
        if (style2.hover) return {
          get cellBgColor() {
            var _a, _b;
            return null !== (_b = null === (_a = style2.hover) || void 0 === _a ? void 0 : _a.cellBgColor) && void 0 !== _b ? _b : void 0;
          },
          get inlineColumnBgColor() {
            var _a, _b, _c, _d, _e, _f;
            return null !== (_f = null !== (_b = null === (_a = style2.hover) || void 0 === _a ? void 0 : _a.inlineColumnBgColor) && void 0 !== _b ? _b : (null === (_c = style2.hover) || void 0 === _c ? void 0 : _c.cellBgColor) && "string" == typeof (null === (_d = style2.hover) || void 0 === _d ? void 0 : _d.cellBgColor) ? changeColor(null === (_e = style2.hover) || void 0 === _e ? void 0 : _e.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
          },
          get inlineRowBgColor() {
            var _a, _b, _c, _d, _e, _f;
            return null !== (_f = null !== (_b = null === (_a = style2.hover) || void 0 === _a ? void 0 : _a.inlineRowBgColor) && void 0 !== _b ? _b : (null === (_c = style2.hover) || void 0 === _c ? void 0 : _c.cellBgColor) && "string" == typeof (null === (_d = style2.hover) || void 0 === _d ? void 0 : _d.cellBgColor) ? changeColor(null === (_e = style2.hover) || void 0 === _e ? void 0 : _e.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
          }
        };
      },
      get select() {
        return {
          get inlineColumnBgColor() {
            var _a, _b, _c, _d, _e, _f;
            return null !== (_f = null !== (_d = null !== (_b = null === (_a = style2.select) || void 0 === _a ? void 0 : _a.inlineColumnBgColor) && void 0 !== _b ? _b : null === (_c = that.selectionStyle) || void 0 === _c ? void 0 : _c.inlineColumnBgColor) && void 0 !== _d ? _d : (null === (_e = that.selectionStyle) || void 0 === _e ? void 0 : _e.cellBgColor) && "string" == typeof that.selectionStyle.cellBgColor ? changeColor(that.selectionStyle.cellBgColor, 0.1, false) : void 0) && void 0 !== _f ? _f : void 0;
          },
          get inlineRowBgColor() {
            var _a, _b, _c, _d, _e;
            return null !== (_e = null !== (_c = null !== (_b = null === (_a = style2.select) || void 0 === _a ? void 0 : _a.inlineRowBgColor) && void 0 !== _b ? _b : that.selectionStyle.inlineRowBgColor) && void 0 !== _c ? _c : (null === (_d = that.selectionStyle) || void 0 === _d ? void 0 : _d.cellBgColor) && "string" == typeof that.selectionStyle.cellBgColor ? changeColor(that.selectionStyle.cellBgColor, 0.1, false) : void 0) && void 0 !== _e ? _e : void 0;
          },
          get cellBgColor() {
            var _a, _b, _c;
            if ("replace" === that.selectionStyle.selectionFillMode) return null !== (_c = null !== (_b = null === (_a = style2.select) || void 0 === _a ? void 0 : _a.cellBgColor) && void 0 !== _b ? _b : that.selectionStyle.cellBgColor) && void 0 !== _c ? _c : void 0;
          }
        };
      },
      get frameStyle() {
        if (style2.frameStyle) return {
          get borderColor() {
            var _a, _b;
            return null !== (_b = null === (_a = style2.frameStyle) || void 0 === _a ? void 0 : _a.borderColor) && void 0 !== _b ? _b : void 0;
          },
          get borderLineWidth() {
            var _a, _b;
            return null !== (_b = null === (_a = style2.frameStyle) || void 0 === _a ? void 0 : _a.borderLineWidth) && void 0 !== _b ? _b : void 0;
          },
          get borderLineDash() {
            var _a, _b;
            return null !== (_b = null === (_a = style2.frameStyle) || void 0 === _a ? void 0 : _a.borderLineDash) && void 0 !== _b ? _b : void 0;
          }
        };
      },
      get padding() {
        return style2.padding;
      },
      get textAlign() {
        return style2.textAlign;
      },
      get textBaseline() {
        return style2.textBaseline;
      },
      get textOverflow() {
        return style2.textOverflow;
      },
      get lineHeight() {
        return style2.lineHeight;
      },
      get autoWrapText() {
        return style2.autoWrapText;
      },
      get lineClamp() {
        return style2.lineClamp;
      },
      get linkColor() {
        return style2.linkColor;
      },
      get cursor() {
        return style2.cursor;
      },
      get textStick() {
        return style2.textStick;
      },
      get marked() {
        return style2.marked;
      },
      get underline() {
        var _a;
        return null !== (_a = style2.underline) && void 0 !== _a && _a;
      },
      get underlineColor() {
        return style2.underlineColor;
      },
      get underlineDash() {
        return style2.underlineDash;
      },
      get underlineOffset() {
        return style2.underlineOffset;
      },
      get lineThrough() {
        var _a;
        return null !== (_a = style2.lineThrough) && void 0 !== _a && _a;
      },
      get lineThroughColor() {
        return style2.lineThroughColor;
      },
      get lineThroughDash() {
        return style2.lineThroughDash;
      }
    };
  }
};
function hasThemeProperty(obj2, names) {
  if (obj2 instanceof TableTheme) return obj2.hasProperty(names);
  let o = obj2;
  if (!o) return false;
  for (let index = 0; index < names.length; index++) {
    if (o = o[names[index]], !o) return false;
  }
  return !!o;
}

// node_modules/@visactor/vtable/es/themes.js
var DARK = new TableTheme(DARK_default, DARK_default);
var BRIGHT = new TableTheme(BRIGHT_default, BRIGHT_default);
var ARCO = new TableTheme(ARCO_default, ARCO_default);
var DEFAULT = new TableTheme(DEFAULT_default, DEFAULT_default);
var SIMPLIFY = new TableTheme(SIMPLIFY_default, SIMPLIFY_default);
var builtin = {
  DEFAULT,
  SIMPLIFY,
  ARCO,
  DARK,
  BRIGHT
};
var theme2 = {
  TableTheme
};
function of2(value) {
  if (!value) return null;
  if ("string" == typeof value) {
    const t = getIgnoreCase(get(), value);
    return t ? t instanceof TableTheme ? t : new TableTheme(t, t) : null;
  }
  return value instanceof TableTheme ? value : new TableTheme(value, value);
}
function get() {
  return extend(builtin, themes);
}
var themes_default = {
  DARK,
  BRIGHT,
  ARCO,
  DEFAULT,
  SIMPLIFY,
  theme: theme2,
  of: of2,
  get
};

// node_modules/@visactor/vtable/es/scenegraph/utils/get-cell-merge.js
function getCellMergeInfo(table, col, row) {
  var _a;
  if (table.internalProps.customMergeCell) {
    const customMerge = table.getCustomMerge(col, row);
    if (customMerge) return customMerge.range;
  }
  if (!table.internalProps.enableTreeNodeMerge && !table.isHeader(col, row) && !(null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell)) return false;
  const range5 = table.getCellRange(col, row);
  return !(range5.start.col === range5.end.col && range5.start.row === range5.end.row) && range5;
}

// node_modules/@visactor/vtable/es/core/factory.js
var Factory2 = class _Factory {
  static registerComponent(key, component) {
    _Factory._components[key] = component;
  }
  static getComponent(key) {
    return _Factory._components[key];
  }
  static registerFunction(key, func) {
    _Factory._functions[key] = func;
  }
  static getFunction(key) {
    return _Factory._functions[key];
  }
  static registerCellType(key, cellType) {
    _Factory._cellTypes[key] = cellType;
  }
  static getCellType(key) {
    return _Factory._cellTypes[key];
  }
};
Factory2._components = {}, Factory2._functions = {}, Factory2._cellTypes = {};

// node_modules/@visactor/vtable/es/data.js
var data_exports = {};
__export(data_exports, {
  CachedDataSource: () => CachedDataSource,
  DataSource: () => DataSource
});

// node_modules/@visactor/vtable/es/tools/sort.js
function createArray(get6, length2) {
  const array4 = new Array(length2);
  for (let i = 0; i < length2; i++) array4[i] = get6(i);
  return array4;
}
function sort(get6, set, length2, compare, order, getField2) {
  const old = createArray(get6, length2);
  old.sort((r1, r2) => compare(getField2(r1), getField2(r2), order));
  for (let i = 0; i < length2; i++) set(i, old[i]);
}

// node_modules/@visactor/vtable/es/data/DataSource.js
function isFieldAssessor(field) {
  if (obj.isObject(field)) {
    const a2 = field;
    if (isValid_default(a2.get) && isValid_default(a2.set)) return true;
  }
  return false;
}
var EVENT_TYPE2 = {
  SOURCE_LENGTH_UPDATE: "source_length_update",
  CHANGE_ORDER: "change_order"
};
function getValue(value, promiseCallBack) {
  const maybePromiseOrValue = getOrApply(value);
  if (isPromise(maybePromiseOrValue)) {
    const promiseValue = maybePromiseOrValue.then((r) => (promiseCallBack(r), r));
    return promiseCallBack(promiseValue), promiseValue;
  }
  return maybePromiseOrValue;
}
function getField(record, field, col, row, table, promiseCallBack) {
  if (null == record) return;
  if (isPromise(record)) return record.then((r) => getField(r, field, col, row, table, promiseCallBack));
  const fieldGet = isFieldAssessor(field) ? field.get : field;
  if ((void 0 === fieldGet || "" === fieldGet) && Array.isArray(record)) {
    return record[col - table.leftRowSeriesNumberCount];
  }
  if (isObject_default(record) && fieldGet in record) {
    return getValue(record[fieldGet], promiseCallBack);
  }
  if ("function" == typeof fieldGet) {
    return getValue(fieldGet(record, col, row, table), promiseCallBack);
  }
  if (Array.isArray(fieldGet)) {
    return getValue(getValueByPath(record, [...fieldGet]), promiseCallBack);
  }
  const fieldArray = `${fieldGet}`.split(".");
  if (fieldArray.length <= 1) {
    return getValue(record[fieldGet], promiseCallBack);
  }
  return getValue(applyChainSafe(record, (val, name) => getField(val, name, col, row, table, emptyFn), ...fieldArray), promiseCallBack);
}
function _getIndex(sortedIndexMap, index) {
  if (!sortedIndexMap) return index;
  const mapIndex = sortedIndexMap[index];
  return isValid_default(mapIndex) ? mapIndex : index;
}
var DataSource = class extends EventTarget3 {
  static get EVENT_TYPE() {
    return EVENT_TYPE2;
  }
  constructor(dataSourceObj, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
    var _a;
    super(), this.currentIndexedData = [], this.hierarchyExpandLevel = 0, this.hasHierarchyStateExpand = false, this.beforeChangedRecordsMap = /* @__PURE__ */ new Map(), this.registedAggregators = {}, this.rowHierarchyType = "grid", this.fieldAggregators = [], this.registerAggregators(), this.dataSourceObj = dataSourceObj, this.dataConfig = dataConfig, this._get = null == dataSourceObj ? void 0 : dataSourceObj.get, this.columns = columns, this._source = (null == dataSourceObj ? void 0 : dataSourceObj.records) ? this.processRecords(null == dataSourceObj ? void 0 : dataSourceObj.records) : dataSourceObj, this._sourceLength = (null === (_a = this._source) || void 0 === _a ? void 0 : _a.length) || 0, this.sortedIndexMap = /* @__PURE__ */ new Map(), this._currentPagerIndexedData = [], this.userPagination = pagination, this.pagination = pagination || {
      totalCount: this._sourceLength,
      perPageCount: this._sourceLength,
      currentPage: 0
    }, hierarchyExpandLevel >= 1 && (this.hierarchyExpandLevel = hierarchyExpandLevel), this.currentIndexedData = Array.from({
      length: this._sourceLength
    }, (_, i) => i), "tree" === rowHierarchyType && this.initTreeHierarchyState(), this.rowHierarchyType = rowHierarchyType, this.updatePagerData();
  }
  initTreeHierarchyState() {
    var _a;
    this.currentIndexedData = Array.from({
      length: this._sourceLength
    }, (_, i) => i);
    let nodeLength = this._sourceLength;
    for (let i = 0; i < nodeLength; i++) {
      const indexKey = this.currentIndexedData[i], nodeData = this.getOriginalRecord(indexKey), children = null !== (_a = nodeData.filteredChildren) && void 0 !== _a ? _a : nodeData.children;
      if ((null == children ? void 0 : children.length) > 0) {
        if (this.hierarchyExpandLevel > 1 ? !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.expand) : !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse), this.hasHierarchyStateExpand = true, nodeData.hierarchyState === HierarchyState.collapse) continue;
        const childrenLength = this.initChildrenNodeHierarchy(indexKey, this.hierarchyExpandLevel, 2, nodeData);
        i += childrenLength, nodeLength += childrenLength;
      } else true === nodeData.children && !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
    }
  }
  supplementConfig(pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
    var _a;
    this.columns = columns, this._sourceLength = (null === (_a = this._source) || void 0 === _a ? void 0 : _a.length) || 0, this.sortedIndexMap = /* @__PURE__ */ new Map(), this._currentPagerIndexedData = [], this.userPagination = pagination, this.pagination = pagination || {
      totalCount: this._sourceLength,
      perPageCount: this._sourceLength,
      currentPage: 0
    }, hierarchyExpandLevel >= 1 && (this.hierarchyExpandLevel = hierarchyExpandLevel), this.currentIndexedData = Array.from({
      length: this._sourceLength
    }, (_, i) => i), "tree" === rowHierarchyType && this.initTreeHierarchyState(), this.rowHierarchyType = rowHierarchyType, this.updatePagerData();
  }
  registerAggregator(type, aggregator2) {
    this.registedAggregators[type] = aggregator2;
  }
  registerAggregators() {
    this.registerAggregator(AggregationType.RECORD, RecordAggregator), this.registerAggregator(AggregationType.SUM, SumAggregator), this.registerAggregator(AggregationType.COUNT, CountAggregator), this.registerAggregator(AggregationType.MAX, MaxAggregator), this.registerAggregator(AggregationType.MIN, MinAggregator), this.registerAggregator(AggregationType.AVG, AvgAggregator), this.registerAggregator(AggregationType.NONE, NoneAggregator), this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
  }
  updateColumns(columns) {
    this.columns = columns;
  }
  _generateFieldAggragations() {
    const columnObjs = this.columns;
    this.fieldAggregators = [];
    const processColumn = (column) => {
      delete column.vtable_aggregator;
      const field = column.field, aggregation = column.aggregation;
      if (aggregation) if (Array.isArray(aggregation)) for (const item of aggregation) {
        const aggregator2 = new this.registedAggregators[item.aggregationType]({
          field,
          formatFun: item.formatFun,
          isRecord: true,
          aggregationFun: item.aggregationFun
        });
        this.fieldAggregators.push(aggregator2), column.vtable_aggregator || (column.vtable_aggregator = []), column.vtable_aggregator.push(aggregator2);
      }
      else {
        const aggregator2 = new this.registedAggregators[aggregation.aggregationType]({
          field,
          formatFun: aggregation.formatFun,
          isRecord: true,
          aggregationFun: aggregation.aggregationFun
        });
        this.fieldAggregators.push(aggregator2), column.vtable_aggregator = aggregator2;
      }
    }, traverseColumns = (columns) => {
      if (columns && 0 !== columns.length) for (const column of columns) processColumn(column), column.columns && traverseColumns(column.columns);
    };
    traverseColumns(columnObjs);
  }
  processRecords(records) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this._generateFieldAggragations();
    const filteredRecords = [], isHasAggregation = this.fieldAggregators.length >= 1;
    if ((null === (_b = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.filterRules) || void 0 === _b ? void 0 : _b.length) >= 1 || (null === (_c = this.lastFilterRules) || void 0 === _c ? void 0 : _c.length) >= 1 || isHasAggregation) {
      for (let i = 0, len = records.length; i < len; i++) {
        const record = records[i];
        (null === (_e = null === (_d = this.dataConfig) || void 0 === _d ? void 0 : _d.filterRules) || void 0 === _e ? void 0 : _e.length) >= 1 ? this.filterRecord(record) && (filteredRecords.push(record), "tree" === this.rowHierarchyType && record.children && (record.filteredChildren = this.filteredChildren(record.children)), isHasAggregation && this.processRecord(record)) : (null === (_f = this.lastFilterRules) || void 0 === _f ? void 0 : _f.length) >= 1 ? (this.clearFilteredChildren(record), isHasAggregation && this.processRecord(record)) : isHasAggregation && this.processRecord(record);
      }
      if ((null === (_h = null === (_g = this.dataConfig) || void 0 === _g ? void 0 : _g.filterRules) || void 0 === _h ? void 0 : _h.length) >= 1) return filteredRecords;
    }
    return records;
  }
  filteredChildren(records) {
    const filteredRecords = [];
    for (let i = 0, len = records.length; i < len; i++) {
      const record = records[i];
      this.filterRecord(record) && (filteredRecords.push(record), record.children && (record.filteredChildren = this.filteredChildren(record.children)));
    }
    return filteredRecords;
  }
  processRecord(record) {
    for (let i = 0; i < this.fieldAggregators.length; i++) {
      this.fieldAggregators[i].push(record);
    }
  }
  initChildrenNodeHierarchy(indexKey, hierarchyExpandLevel, currentLevel, nodeData) {
    var _a, _b, _c;
    let childTotalLength = 0;
    const nodeLength = nodeData.filteredChildren ? nodeData.filteredChildren.length : null !== (_b = null === (_a = nodeData.children) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
    for (let j = 0; j < nodeLength; j++) {
      (currentLevel <= hierarchyExpandLevel || nodeData.hierarchyState === HierarchyState.expand) && (childTotalLength += 1);
      const childNodeData = nodeData.filteredChildren ? nodeData.filteredChildren[j] : nodeData.children[j], childIndexKey = Array.isArray(indexKey) ? indexKey.concat(j) : [indexKey, j];
      (currentLevel <= hierarchyExpandLevel || nodeData.hierarchyState === HierarchyState.expand) && this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childTotalLength, 0, childIndexKey), (childNodeData.filteredChildren ? childNodeData.filteredChildren.length > 0 : (null === (_c = childNodeData.children) || void 0 === _c ? void 0 : _c.length) > 0) && (currentLevel < hierarchyExpandLevel || childNodeData.hierarchyState === HierarchyState.expand ? (!childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.expand), this.hasHierarchyStateExpand = true) : !childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.collapse)), childNodeData.hierarchyState === HierarchyState.expand && (childTotalLength += this.initChildrenNodeHierarchy(childIndexKey, hierarchyExpandLevel, currentLevel + 1, childNodeData)), true === childNodeData.children && !childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.collapse);
    }
    return childTotalLength;
  }
  updatePagination(pagination) {
    this.pagination = pagination || {
      totalCount: this._sourceLength,
      perPageCount: this._sourceLength,
      currentPage: 0
    }, this.updatePagerData();
  }
  updatePagerData() {
    const { currentIndexedData } = this, { perPageCount, currentPage } = this.pagination, startIndex = perPageCount * (currentPage || 0), endIndex = startIndex + perPageCount;
    if (this._currentPagerIndexedData.length = 0, currentIndexedData && currentIndexedData.length > 0) {
      let firstLevelIndex = -1;
      for (let i = 0; i < currentIndexedData.length; i++) if ((Array.isArray(currentIndexedData[i]) && 1 === currentIndexedData[i].length || !Array.isArray(currentIndexedData[i])) && firstLevelIndex++, firstLevelIndex >= startIndex && firstLevelIndex < endIndex) this._currentPagerIndexedData.push(currentIndexedData[i]);
      else if (firstLevelIndex >= endIndex) break;
    } else if (this._sourceLength > 0) throw new Error("currentIndexedData should has values!");
  }
  getRecordIndexPaths(bodyShowIndex) {
    return this._currentPagerIndexedData[bodyShowIndex];
  }
  get records() {
    return Array.isArray(this._source) ? this._source : [];
  }
  get source() {
    return this._source;
  }
  get(index) {
    return this.getOriginalRecord(_getIndex(this.currentPagerIndexedData, index));
  }
  getRaw(index) {
    return this.getRawRecord(_getIndex(this.currentPagerIndexedData, index));
  }
  getIndexKey(index) {
    return _getIndex(this.currentPagerIndexedData, index);
  }
  getTableIndex(colOrRow) {
    return Array.isArray(colOrRow) ? "tree" === this.rowHierarchyType ? this.currentPagerIndexedData.findIndex((value) => arrayEqual(value, colOrRow)) : this.currentPagerIndexedData.findIndex((value) => value === colOrRow[0]) : this.currentPagerIndexedData.findIndex((value) => value === colOrRow);
  }
  getField(index, field, col, row, table) {
    return this.getOriginalField(_getIndex(this.currentPagerIndexedData, index), field, col, row, table);
  }
  getRawField(index, field, col, row, table) {
    return this.getRawFieldData(_getIndex(this.currentPagerIndexedData, index), field, col, row, table);
  }
  hasField(index, field) {
    return this.hasOriginalField(_getIndex(this.currentPagerIndexedData, index), field);
  }
  getHierarchyState(index) {
    var _a;
    const record = this.getOriginalRecord(this.currentPagerIndexedData[index]);
    if (null == record ? void 0 : record.hierarchyState) {
      const hierarchyState = record.hierarchyState;
      if ((null === (_a = record.children) || void 0 === _a ? void 0 : _a.length) > 0 || true === record.children) return hierarchyState;
    }
    return null;
  }
  toggleHierarchyState(index, bodyStartIndex, bodyEndIndex) {
    const oldIndexedData = this.currentIndexedData.slice(0), indexed = this.getIndexKey(index), state = this.getHierarchyState(index), data = this.getOriginalRecord(indexed);
    if (this.clearSortedIndexMap(), state === HierarchyState.collapse) data.hierarchyState = HierarchyState.expand, this.pushChildrenNode(indexed, HierarchyState.expand, data), this.hasHierarchyStateExpand = true;
    else if (state === HierarchyState.expand) {
      let childrenLength = 0;
      const computeChildrenNodeLength = (indexKey, hierarchyState, nodeData) => {
        if (!hierarchyState || hierarchyState === HierarchyState.collapse || hierarchyState === HierarchyState.none) return;
        const children = nodeData.filteredChildren ? nodeData.filteredChildren : nodeData.children;
        if (children) for (let i = 0; i < children.length; i++) {
          childrenLength += 1;
          const childIndex = Array.isArray(indexKey) ? indexKey.concat([i]) : [indexKey, i];
          computeChildrenNodeLength(childIndex, children[i].hierarchyState, children[i]);
        }
      };
      computeChildrenNodeLength(indexed, state, data), this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexed) + 1, childrenLength), data.hierarchyState = HierarchyState.collapse;
    }
    this.updatePagerData();
    const add = [], remove = [];
    if (state === HierarchyState.collapse) {
      const addLength = this.currentIndexedData.length - oldIndexedData.length;
      for (let i = 0; i < addLength; i++) add.push(index + i + 1);
    } else if (state === HierarchyState.expand) {
      const removeLength = oldIndexedData.length - this.currentIndexedData.length;
      for (let i = 0; i < removeLength; i++) remove.push(index + i + 1);
    }
    return {
      add,
      remove
    };
  }
  pushChildrenNode(indexKey, hierarchyState, nodeData) {
    var _a, _b;
    if (!hierarchyState || hierarchyState === HierarchyState.collapse || hierarchyState === HierarchyState.none) return 0;
    let childrenLength = 0;
    const children = nodeData.filteredChildren ? nodeData.filteredChildren : nodeData.children;
    if (children) {
      const subNodeSortedIndexArray = Array.from({
        length: children.length
      }, (_, i) => i);
      null === (_a = this.lastSortStates) || void 0 === _a || _a.forEach((state) => {
        "normal" !== state.order && sort((index) => isValid_default(subNodeSortedIndexArray[index]) ? subNodeSortedIndexArray[index] : subNodeSortedIndexArray[index] = index, (index, rel) => {
          subNodeSortedIndexArray[index] = rel;
        }, children.length, state.orderFn, state.order, (index) => this.getOriginalField(Array.isArray(indexKey) ? indexKey.concat([index]) : [indexKey, index], state.field));
      });
      for (let i = 0; i < subNodeSortedIndexArray.length; i++) {
        childrenLength += 1;
        const childIndex = Array.isArray(indexKey) ? indexKey.concat([subNodeSortedIndexArray[i]]) : [indexKey, subNodeSortedIndexArray[i]];
        this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childrenLength, 0, childIndex);
        const childData = this.getOriginalRecord(childIndex);
        !childData.hierarchyState && (null !== (_b = childData.filteredChildren) && void 0 !== _b ? _b : childData.children) && (childData.hierarchyState = HierarchyState.collapse), childrenLength += this.pushChildrenNode(childIndex, childData.hierarchyState, children[subNodeSortedIndexArray[i]]);
      }
    }
    return childrenLength;
  }
  changeFieldValue(value, index, field, col, row, table) {
    var _a;
    if (null !== field && index >= 0) {
      const dataIndex = this.getIndexKey(index);
      if (this.cacheBeforeChangedRecord(dataIndex, table), void 0 !== field && "" !== field || (field = col - table.leftRowSeriesNumberCount), "string" == typeof field || "number" == typeof field) {
        const beforeChangedValue = null === (_a = this.beforeChangedRecordsMap.get(dataIndex.toString())) || void 0 === _a ? void 0 : _a[field], record = this.getOriginalRecord(dataIndex);
        let formatValue = value;
        "number" == typeof beforeChangedValue && isAllDigits(value) && (formatValue = parseFloat(value)), isPromise(record) ? record.then((record2) => {
          record2[field] = formatValue;
        }).catch((err) => {
        }) : record ? record[field] = formatValue : (this.records[dataIndex] = {}, this.records[dataIndex][field] = formatValue);
      }
    }
  }
  cacheBeforeChangedRecord(dataIndex, table) {
    var _a;
    if (!this.beforeChangedRecordsMap.has(dataIndex.toString())) {
      const originRecord = this.getOriginalRecord(dataIndex);
      this.beforeChangedRecordsMap.set(dataIndex.toString(), null !== (_a = cloneDeep(originRecord, void 0, ["vtable_gantt_linkedFrom", "vtable_gantt_linkedTo"])) && void 0 !== _a ? _a : {});
    }
  }
  setRecord(record, index) {
    var _a, _b;
    let isAdd = true;
    if ((null === (_b = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.filterRules) || void 0 === _b ? void 0 : _b.length) >= 1 && (this.filterRecord(record) ? "tree" === this.rowHierarchyType && record.children && (record.filteredChildren = this.filteredChildren(record.children)) : isAdd = false), isAdd && Array.isArray(this.records)) {
      const indexed = this.getIndexKey(index);
      Array.isArray(indexed) || this.records.splice(indexed, 1, record);
    }
  }
  addRecord(record, index) {
    var _a;
    if (Array.isArray(this.records)) {
      this.records.splice(index, 0, record), this.adjustBeforeChangedRecordsMap(index, 1), this.currentIndexedData.push(this.currentIndexedData.length), this._sourceLength += 1;
      for (let i = 0; i < this.fieldAggregators.length; i++) this.fieldAggregators[i].push(record);
      if ("tree" === this.rowHierarchyType && this.initTreeHierarchyState(), this.userPagination) {
        this.pagination.totalCount = this._sourceLength;
        const { perPageCount, currentPage } = this.pagination;
        index < perPageCount * (currentPage || 0) + perPageCount && this.updatePagerData();
      } else this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength, this.updatePagerData();
      (null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.added) && this.dataSourceObj.added(index, 1);
    }
  }
  addRecords(recordArr, index) {
    var _a;
    if (Array.isArray(this.records)) {
      if (Array.isArray(recordArr)) {
        this.records.splice(index, 0, ...recordArr), this.adjustBeforeChangedRecordsMap(index, recordArr.length);
        for (let i = 0; i < recordArr.length; i++) this.currentIndexedData.push(this.currentIndexedData.length);
        this._sourceLength += recordArr.length;
        for (let i = 0; i < this.fieldAggregators.length; i++) for (let j = 0; j < recordArr.length; j++) this.fieldAggregators[i].push(recordArr[j]);
      }
      if (this.userPagination) {
        this.pagination.totalCount = this._sourceLength;
        const { perPageCount, currentPage } = this.pagination;
        index < perPageCount * (currentPage || 0) + perPageCount && this.updatePagerData();
      } else this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength, this.updatePagerData();
      (null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.added) && this.dataSourceObj.added(index, recordArr.length);
    }
  }
  addRecordForSorted(record) {
    Array.isArray(this.records) && (this.beforeChangedRecordsMap.clear(), this.records.push(record), this.currentIndexedData.push(this.currentIndexedData.length), this._sourceLength += 1, this.sortedIndexMap.clear(), this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength));
  }
  addRecordsForSorted(recordArr) {
    if (Array.isArray(this.records)) {
      if (this.beforeChangedRecordsMap.clear(), Array.isArray(recordArr)) {
        this.records.push(...recordArr);
        for (let i = 0; i < recordArr.length; i++) this.currentIndexedData.push(this.currentIndexedData.length);
        this._sourceLength += recordArr.length, this.sortedIndexMap.clear();
      }
      this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength);
    }
  }
  adjustBeforeChangedRecordsMap(insertIndex, insertCount, type = "add") {
    for (let key = this.beforeChangedRecordsMap.size - 1; key >= insertIndex; key--) {
      const record = this.beforeChangedRecordsMap.get(key.toString());
      this.beforeChangedRecordsMap.delete(key.toString()), this.beforeChangedRecordsMap.set((key + ("add" === type ? insertCount : -insertCount)).toString(), record);
    }
  }
  deleteRecords(recordIndexs) {
    var _a;
    if (Array.isArray(this.records)) {
      const realDeletedRecordIndexs = [], recordIndexsMaxToMin = recordIndexs.sort((a2, b) => b - a2);
      for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
        const recordIndex = recordIndexsMaxToMin[index];
        if (recordIndex >= this._sourceLength || recordIndex < 0) continue;
        this.adjustBeforeChangedRecordsMap(recordIndex, 1, "delete"), realDeletedRecordIndexs.push(recordIndex);
        const deletedRecord = this.records[recordIndex];
        for (let i = 0; i < this.fieldAggregators.length; i++) this.fieldAggregators[i].deleteRecord(deletedRecord);
        this.records.splice(recordIndex, 1), this.currentIndexedData.pop(), this._sourceLength -= 1;
      }
      return this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength), this.updatePagerData(), (null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.deleted) && this.dataSourceObj.deleted(realDeletedRecordIndexs), realDeletedRecordIndexs;
    }
    return [];
  }
  deleteRecordsForSorted(recordIndexs) {
    if (Array.isArray(this.records)) {
      const recordIndexsMaxToMin = recordIndexs.sort((a2, b) => b - a2);
      for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
        const recordIndex = recordIndexsMaxToMin[index];
        if (recordIndex >= this._sourceLength || recordIndex < 0) continue;
        const rawIndex = this.currentIndexedData[recordIndex];
        this.records.splice(rawIndex, 1), this._sourceLength -= 1;
      }
      this.sortedIndexMap.clear(), this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength), this.beforeChangedRecordsMap.clear();
    }
  }
  updateRecords(records, recordIndexs) {
    const realDeletedRecordIndexs = [];
    for (let index = 0; index < recordIndexs.length; index++) {
      const recordIndex = recordIndexs[index];
      if (Array.isArray(recordIndex)) this.beforeChangedRecordsMap.delete(recordIndex.toString()), realDeletedRecordIndexs.push(recordIndex), recordIndex.slice(0, -1).reduce((acc, key) => (void 0 === acc[key] && (acc[key] = {}), acc[key].children), this.records)[recordIndex[recordIndex.length - 1]] = records[index];
      else {
        if (recordIndex >= this._sourceLength || recordIndex < 0) continue;
        this.beforeChangedRecordsMap.delete(recordIndex.toString()), realDeletedRecordIndexs.push(recordIndex);
        for (let i = 0; i < this.fieldAggregators.length; i++) this.fieldAggregators[i].updateRecord(this.records[recordIndex], records[index]);
        this.records[recordIndex] = records[index];
      }
    }
    return this.userPagination && this.updatePagerData(), realDeletedRecordIndexs;
  }
  updateRecordsForSorted(records, recordIndexs) {
    const realDeletedRecordIndexs = [];
    for (let index = 0; index < recordIndexs.length; index++) {
      const recordIndex = recordIndexs[index];
      if (recordIndex >= this._sourceLength || recordIndex < 0) continue;
      const rawIndex = this.currentIndexedData[recordIndex];
      if ("number" != typeof rawIndex) return;
      this.beforeChangedRecordsMap.delete(rawIndex.toString()), realDeletedRecordIndexs.push(recordIndex), this.records[rawIndex] = records[index];
    }
    this.sortedIndexMap.clear();
  }
  sort(states) {
    states = (Array.isArray(states) ? states : [states]).filter((state) => {
      const column = this.columns.find((obj2) => obj2.field === state.field);
      return false !== (null == column ? void 0 : column.sort) && "normal" !== state.order;
    }), this.lastSortStates = states;
    let filedMapArray = states.map((state) => this.sortedIndexMap.get(null == state ? void 0 : state.field) || {
      asc: [],
      desc: [],
      normal: []
    }), orderedData = null;
    if (filedMapArray.length > 0 && (orderedData = states.reduce((data, state, index) => {
      var _a;
      const currentData = null === (_a = filedMapArray[index]) || void 0 === _a ? void 0 : _a[state.order];
      return currentData && currentData.length > 0 ? currentData : data;
    }, null), orderedData && orderedData.length > 0)) return this.currentIndexedData = orderedData, this.updatePagerData(), void this.fireListeners(EVENT_TYPE2.CHANGE_ORDER, null);
    const sortedIndexArray = Array.from({
      length: this._sourceLength
    }, (_, i) => i);
    if (sortedIndexArray.sort((indexA, indexB) => states.reduce((result2, state) => {
      if (0 !== result2) return result2;
      return (state.orderFn || ("desc" !== state.order ? (v1, v2) => v1 === v2 ? 0 : v1 > v2 ? 1 : -1 : (v1, v2) => v1 === v2 ? 0 : v1 < v2 ? 1 : -1))(this.getOriginalField(indexA, state.field), this.getOriginalField(indexB, state.field), state.order);
    }, 0)), this.currentIndexedData = sortedIndexArray, this.hierarchyExpandLevel) {
      let nodeLength = sortedIndexArray.length;
      for (let i = 0; i < nodeLength; i++) {
        const record = this.getOriginalRecord(sortedIndexArray[i]), subNodeLength = this.pushChildrenNode(sortedIndexArray[i], record.hierarchyState, this.getOriginalRecord(sortedIndexArray[i]));
        nodeLength += subNodeLength, i += subNodeLength;
      }
    }
    if (!filedMapArray.length) {
      filedMapArray = states.map(() => ({
        asc: [],
        desc: [],
        normal: []
      }));
      for (let index = 0; index < states.length; index++) this.sortedIndexMap.set(states[index].field, filedMapArray[index]);
    }
    states.forEach((state, index) => {
      filedMapArray[index][state.order] = sortedIndexArray.slice();
    }), this.updatePagerData(), this.fireListeners(EVENT_TYPE2.CHANGE_ORDER, null);
  }
  setSortedIndexMap(field, filedMap) {
    this.sortedIndexMap.set(field, filedMap);
  }
  clearFilteredChildren(record) {
    var _a, _b;
    record.filteredChildren = void 0;
    for (let i = 0; i < (null !== (_b = null === (_a = record.children) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0); i++) this.clearFilteredChildren(record.children[i]);
  }
  filterRecord(record) {
    var _a, _b, _c;
    let isReserved = true;
    for (let i = 0; i < (null === (_a = this.dataConfig.filterRules) || void 0 === _a ? void 0 : _a.length); i++) {
      const filterRule = null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.filterRules[i];
      if (filterRule.filterKey) {
        const filterValue = record[filterRule.filterKey];
        if (-1 === filterRule.filteredValues.indexOf(filterValue)) {
          isReserved = false;
          break;
        }
      } else if (!(null === (_c = filterRule.filterFunc) || void 0 === _c ? void 0 : _c.call(filterRule, record))) {
        isReserved = false;
        break;
      }
    }
    return isReserved;
  }
  updateFilterRulesForSorted(filterRules) {
    var _a, _b, _c;
    this.lastFilterRules = this.dataConfig.filterRules, this.dataConfig.filterRules = filterRules, this._source = this.processRecords(null !== (_b = null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.records) && void 0 !== _b ? _b : this.dataSourceObj), this._sourceLength = (null === (_c = this._source) || void 0 === _c ? void 0 : _c.length) || 0, this.sortedIndexMap.clear(), this.currentIndexedData = Array.from({
      length: this._sourceLength
    }, (_, i) => i), this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength);
  }
  updateFilterRules(filterRules) {
    var _a, _b, _c;
    this.lastFilterRules = this.dataConfig.filterRules, this.dataConfig.filterRules = filterRules, this._source = this.processRecords(null !== (_b = null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.records) && void 0 !== _b ? _b : this.dataSourceObj), this._sourceLength = (null === (_c = this._source) || void 0 === _c ? void 0 : _c.length) || 0, this.currentIndexedData = Array.from({
      length: this._sourceLength
    }, (_, i) => i), this.userPagination || (this.pagination.perPageCount = this._sourceLength, this.pagination.totalCount = this._sourceLength, "tree" === this.rowHierarchyType && this.initTreeHierarchyState()), this.updatePagerData();
  }
  clearSortedIndexMap() {
    this.lastSortStates && this.lastSortStates.length > 0 && this.sortedIndexMap.forEach((sortMap, key) => {
      this.lastSortStates.some((state) => state.field === key) ? this.lastSortStates.forEach((state) => {
        "asc" === state.order ? (sortMap.desc = [], sortMap.normal = []) : "desc" === state.order ? (sortMap.asc = [], sortMap.normal = []) : (sortMap.asc = [], sortMap.desc = []);
      }) : this.sortedIndexMap.delete(key);
    });
  }
  get sourceLength() {
    return this._sourceLength;
  }
  set sourceLength(sourceLen) {
    this._sourceLength !== sourceLen && (this._sourceLength = sourceLen, this.fireListeners(EVENT_TYPE2.SOURCE_LENGTH_UPDATE, this._sourceLength));
  }
  get length() {
    return this.currentPagerIndexedData.length;
  }
  get dataSource() {
    return this;
  }
  get currentPagerIndexedData() {
    return this._currentPagerIndexedData.length > 0 ? this._currentPagerIndexedData : [];
  }
  release() {
    var _a;
    null === (_a = super.release) || void 0 === _a || _a.call(this), this.lastFilterRules = null, this.clearSortedMap(), this.clearCurrentIndexedData(), this.currentPagerIndexedData.length = 0;
  }
  clearSortedMap() {
    this.currentIndexedData && (this.currentIndexedData.length = 0), this.currentIndexedData = null, this.sortedIndexMap.forEach((item) => {
      item.asc && (item.asc.length = 0), item.desc && (item.desc.length = 0);
    }), this.sortedIndexMap.clear();
  }
  clearCurrentIndexedData() {
    this.currentIndexedData = null, this.currentPagerIndexedData.length = 0;
  }
  getOriginalRecord(dataIndex) {
    let data;
    return data = this.dataSourceObj.records ? Array.isArray(dataIndex) ? getValueFromDeepArray(this.records, dataIndex) : this.records[dataIndex] : this._get(dataIndex), getValue(data, (val) => {
      this.recordPromiseCallBack(dataIndex, val);
    });
  }
  getRawRecord(dataIndex) {
    var _a, _b;
    if (null === (_a = this.beforeChangedRecordsMap) || void 0 === _a ? void 0 : _a.has(dataIndex.toString())) return null === (_b = this.beforeChangedRecordsMap) || void 0 === _b ? void 0 : _b.get(dataIndex.toString());
    let data;
    return data = this.dataSourceObj.records ? Array.isArray(dataIndex) ? getValueFromDeepArray(this.records, dataIndex) : this.records[dataIndex] : this._get(dataIndex), getValue(data, (val) => {
      this.recordPromiseCallBack(dataIndex, val);
    });
  }
  getOriginalField(index, field, col, row, table) {
    if (null === field) return;
    return getField(this.getOriginalRecord(index), field, col, row, table, (val) => {
      this.fieldPromiseCallBack(index, field, val);
    });
  }
  getRawFieldData(index, field, col, row, table) {
    if (null === field) return;
    return getField(this.getRawRecord(index), field, col, row, table, (val) => {
      this.fieldPromiseCallBack(index, field, val);
    });
  }
  hasOriginalField(index, field) {
    if (null === field) return false;
    if ("function" == typeof field) return true;
    const record = this.getOriginalRecord(index);
    return Boolean(record && field in record);
  }
  fieldPromiseCallBack(_index, _field, _value) {
  }
  recordPromiseCallBack(_index, _record) {
  }
  canChangeOrder(sourceIndex, targetIndex) {
    var _a;
    if (null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.canChangeOrder) return this.dataSourceObj.canChangeOrder(sourceIndex, targetIndex);
    if (this.hasHierarchyStateExpand) {
      let sourceIndexs = this.currentPagerIndexedData[sourceIndex], targetIndexs = this.currentPagerIndexedData[targetIndex];
      if (sourceIndexs = Array.isArray(sourceIndexs) ? [...sourceIndexs] : [sourceIndexs], targetIndexs = Array.isArray(targetIndexs) ? [...targetIndexs] : [targetIndexs], targetIndex > sourceIndex && targetIndexs.length > sourceIndexs.length) {
        let targetNextIndexs = this.currentPagerIndexedData[targetIndex + 1];
        targetNextIndexs = Array.isArray(targetNextIndexs) ? [...targetNextIndexs] : [targetNextIndexs], targetNextIndexs.length < targetIndexs.length && targetIndexs.splice(targetIndexs.length - 1, 1);
      }
      if (sourceIndexs.length === targetIndexs.length) {
        for (let i = 0; i <= sourceIndexs.length - 2; i++) if (sourceIndexs[i] !== targetIndexs[i]) return false;
        return true;
      }
      return false;
    }
    return true;
  }
  changeOrder(sourceIndex, targetIndex) {
    var _a, _b, _c;
    if (null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.changeOrder) this.dataSourceObj.changeOrder(sourceIndex, targetIndex);
    else if (!(null === (_b = this.lastSortStates) || void 0 === _b ? void 0 : _b.some((state) => "asc" === state.order || "desc" === state.order)) && this.canChangeOrder(sourceIndex, targetIndex)) if (this.hasHierarchyStateExpand) {
      let sourceI, targetI, sourceIndexs = this.currentPagerIndexedData[sourceIndex], targetIndexs = this.currentPagerIndexedData[targetIndex];
      if (sourceIndexs = Array.isArray(sourceIndexs) ? [...sourceIndexs] : [sourceIndexs], targetIndexs = Array.isArray(targetIndexs) ? [...targetIndexs] : [targetIndexs], sourceIndexs.length > 1 || targetIndexs.length > 1) {
        if (targetIndex > sourceIndex && targetIndexs.length > sourceIndexs.length) {
          let targetNextIndexs = this.currentPagerIndexedData[targetIndex + 1];
          targetNextIndexs = Array.isArray(targetNextIndexs) ? [...targetNextIndexs] : [targetNextIndexs], targetNextIndexs.length < targetIndexs.length && targetIndexs.splice(targetIndexs.length - 1, 1);
        }
        if (sourceI = sourceIndexs.splice(sourceIndexs.length - 1, 1)[0], targetI = targetIndexs.splice(targetIndexs.length - 1, 1)[0], sourceIndexs.length >= 1) {
          const parent = this.getOriginalRecord(sourceIndexs), sourceIds = parent.filteredChildren ? parent.filteredChildren.splice(sourceI, 1) : parent.children.splice(sourceI, 1);
          sourceIds.unshift(targetI, 0), Array.prototype.splice.apply(null !== (_c = parent.filteredChildren) && void 0 !== _c ? _c : parent.children, sourceIds);
        } else {
          const sourceIds = this.records.splice(sourceI, 1);
          sourceIds.unshift(targetI, 0), Array.prototype.splice.apply(this.records, sourceIds);
        }
      } else {
        sourceI = this.currentPagerIndexedData[sourceIndex], targetI = this.currentPagerIndexedData[targetIndex];
        const records = this.records.splice(sourceI, 1);
        records.unshift(targetI, 0), Array.prototype.splice.apply(this.records, records);
      }
      this.restoreTreeHierarchyState(), this.updatePagerData();
    } else {
      const records = this.records.splice(sourceIndex, 1);
      records.unshift(targetIndex, 0), Array.prototype.splice.apply(this.records, records);
    }
  }
  restoreTreeHierarchyState() {
    var _a, _b;
    if (this.hierarchyExpandLevel) {
      for (let i = 0; i < this._sourceLength; i++) {
        const nodeData = this.getOriginalRecord(i);
        (null !== (_a = nodeData.filteredChildren) && void 0 !== _a ? _a : nodeData.children) && !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
      }
      this.currentIndexedData = Array.from({
        length: this._sourceLength
      }, (_, i) => i);
      let nodeLength = this._sourceLength;
      for (let i = 0; i < nodeLength; i++) {
        const indexKey = this.currentIndexedData[i], nodeData = this.getOriginalRecord(indexKey), children = null !== (_b = nodeData.filteredChildren) && void 0 !== _b ? _b : nodeData.children;
        if ((null == children ? void 0 : children.length) > 0 && nodeData.hierarchyState === HierarchyState.expand) {
          this.hasHierarchyStateExpand = true;
          const childrenLength = this.restoreChildrenNodeHierarchy(indexKey, nodeData);
          i += childrenLength, nodeLength += childrenLength;
        } else true === nodeData.children && !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
      }
    }
  }
  restoreChildrenNodeHierarchy(indexKey, nodeData) {
    var _a, _b;
    let childTotalLength = 0;
    const children = null !== (_a = nodeData.filteredChildren) && void 0 !== _a ? _a : nodeData.children, nodeLength = null !== (_b = null == children ? void 0 : children.length) && void 0 !== _b ? _b : 0;
    for (let j = 0; j < nodeLength; j++) {
      nodeData.hierarchyState === HierarchyState.expand && (childTotalLength += 1);
      const childNodeData = children[j], childIndexKey = Array.isArray(indexKey) ? indexKey.concat(j) : [indexKey, j];
      nodeData.hierarchyState === HierarchyState.expand && this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childTotalLength, 0, childIndexKey), childTotalLength += this.restoreChildrenNodeHierarchy(childIndexKey, childNodeData);
    }
    return childTotalLength;
  }
};
DataSource.EMPTY = new DataSource({
  get() {
  },
  length: 0
});
function getValueFromDeepArray(array4, index) {
  var _a;
  let result2 = array4;
  for (let i = 0; i < index.length; i++) {
    const currentIdx = index[i];
    if (!result2[currentIdx]) return;
    result2 = result2[currentIdx];
    const children = null !== (_a = result2.filteredChildren) && void 0 !== _a ? _a : null == result2 ? void 0 : result2.children;
    children && i + 1 < index.length && (result2 = children);
  }
  return result2;
}
function sortRecordIndexs(recordIndexs, sort2) {
  return recordIndexs.sort((a2, b) => {
    var _a, _b;
    isNumber_default(a2) && (a2 = [a2]), isNumber_default(b) && (b = [b]);
    const length2 = Math.max(a2.length, b.length);
    for (let i = 0; i < length2; i++) {
      const aa = null !== (_a = a2[i]) && void 0 !== _a ? _a : -1, bb = null !== (_b = b[i]) && void 0 !== _b ? _b : -1;
      if (aa !== bb) return 1 === sort2 ? aa - bb : bb - aa;
    }
    return 0;
  });
}

// node_modules/@visactor/vtable/es/data/CachedDataSource.js
var import_get = __toESM(require_get());
function _setFieldCache(fCache, index, field, value) {
  (fCache[index] || (fCache[index] = /* @__PURE__ */ new Map())).set(field, value);
}
var CachedDataSource = class _CachedDataSource extends DataSource {
  static get EVENT_TYPE() {
    return DataSource.EVENT_TYPE;
  }
  static ofArray(array4, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
    return new _CachedDataSource({
      get: (index) => array4[index],
      length: array4.length,
      records: array4
    }, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel);
  }
  constructor(opt, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
    let _isGrouped;
    isArray_default(null == dataConfig ? void 0 : dataConfig.groupByRules) && (rowHierarchyType = "tree", _isGrouped = true), super(opt, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel), this._isGrouped = _isGrouped, this._recordCache = [], this._fieldCache = {};
  }
  getOriginalRecord(index) {
    return isNumber_default(index) && this._recordCache && this._recordCache[index] ? this._recordCache[index] : super.getOriginalRecord(index);
  }
  getRawRecord(index) {
    var _a, _b, _c, _d;
    let originRecordIndex, data;
    if (this._isGrouped) {
      if (originRecordIndex = this.getOriginRecordIndexForGroup(index), isValid_default(originRecordIndex) && (null === (_a = this.beforeChangedRecordsMap) || void 0 === _a ? void 0 : _a.has(originRecordIndex.toString()))) return null === (_b = this.beforeChangedRecordsMap) || void 0 === _b ? void 0 : _b.get(originRecordIndex.toString());
    } else if (null === (_c = this.beforeChangedRecordsMap) || void 0 === _c ? void 0 : _c.has(index.toString())) return null === (_d = this.beforeChangedRecordsMap) || void 0 === _d ? void 0 : _d.get(index.toString());
    return isNumber_default(index) && this._recordCache && this._recordCache[index] ? this._recordCache[index] : (data = this.dataSourceObj.records ? Array.isArray(index) ? getValueFromDeepArray(this.records, index) : this.records[index] : this._get(index), getValue(data, (val) => {
      this.recordPromiseCallBack(index, val);
    }));
  }
  getOriginalField(index, field, col, row, table) {
    const rowCache = this._fieldCache && this._fieldCache[index];
    if (rowCache) {
      const cache = rowCache.get(field);
      if (cache) return cache;
    }
    return super.getOriginalField(index, field, col, row, table);
  }
  clearCache() {
    this._recordCache && (this._recordCache = []), this._fieldCache && (this._fieldCache = {});
  }
  fieldPromiseCallBack(index, field, value) {
    _setFieldCache(this._fieldCache, index, field, value);
  }
  recordPromiseCallBack(index, record) {
    this._recordCache && (this._recordCache[index] = record);
  }
  get records() {
    return Array.isArray(this._recordCache) && this._recordCache.length > 0 ? this._recordCache : super.records;
  }
  release() {
    var _a;
    null === (_a = super.release) || void 0 === _a || _a.call(this), this._recordCache = null, this._fieldCache = null;
  }
  _generateFieldAggragations() {
    var _a;
    if (super._generateFieldAggragations(), isArray_default(null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.groupByRules)) {
      const groupByKeys = this.dataConfig.groupByRules;
      this.groupAggregator = new this.registedAggregators[AggregationType.CUSTOM]({
        field: "",
        aggregationFun: (values, records, field) => {
          const groupMap = /* @__PURE__ */ new Map(), groupResult = [];
          for (let i = 0; i < records.length; i++) dealWithGroup(records[i], groupResult, groupMap, groupByKeys, 0);
          return groupResult;
        }
      }), this.fieldAggregators.push(this.groupAggregator);
    }
  }
  processRecords(records) {
    var _a;
    const result2 = super.processRecords(records), groupResult = null === (_a = this.groupAggregator) || void 0 === _a ? void 0 : _a.value();
    return groupResult || result2;
  }
  getGroupLength() {
    var _a, _b, _c;
    return null !== (_c = null === (_b = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.groupByRules) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0;
  }
  updateGroup() {
    var _a, _b, _c;
    this.clearCache();
    const oldSource = this.source;
    this._source = this.processRecords(null !== (_b = null === (_a = this.dataSourceObj) || void 0 === _a ? void 0 : _a.records) && void 0 !== _b ? _b : this.dataSourceObj), oldSource && syncGroupCollapseState(oldSource, this.source), this.sourceLength = (null === (_c = this.source) || void 0 === _c ? void 0 : _c.length) || 0, this.sortedIndexMap.clear(), this.currentIndexedData = Array.from({
      length: this.sourceLength
    }, (_, i) => i), this.userPagination || (this.pagination.perPageCount = this.sourceLength, this.pagination.totalCount = this.sourceLength), this.initTreeHierarchyState(), this.updatePagerData();
  }
  getOriginRecordIndexForGroup(recordIndex) {
    const targetRecord = this.getOriginalRecord(recordIndex);
    if (isValid_default(targetRecord) && !(targetRecord.children && targetRecord.children.length > 0)) {
      for (let i = 0; i < this.dataSourceObj.records.length; i++) if (this.dataSourceObj.records[i] === targetRecord) return i;
    }
  }
  addRecordsForGroup(recordArr, recordIndex) {
    if (!isArray_default(recordArr) || 0 === recordArr.length) return;
    let originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
    (void 0 === originRecordIndex || originRecordIndex > this.dataSourceObj.records) && (originRecordIndex = this.dataSourceObj.records.length), this.dataSourceObj.records.splice(originRecordIndex, 0, ...recordArr), this.adjustBeforeChangedRecordsMap(originRecordIndex, recordArr.length), this.updateGroup();
  }
  deleteRecordsForGroup(recordIndexs) {
    if (!isArray_default(recordIndexs) || 0 === recordIndexs.length) return;
    const recordIndexsMaxToMin = sortRecordIndexs(recordIndexs, -1);
    for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
      const recordIndex = recordIndexsMaxToMin[index];
      if (isNumber_default(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) continue;
      const originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
      this.beforeChangedRecordsMap.delete(originRecordIndex.toString()), this.dataSourceObj.records.splice(originRecordIndex, 1), this.sourceLength -= 1, this.adjustBeforeChangedRecordsMap(originRecordIndex, 1, "delete");
    }
    this.updateGroup();
  }
  updateRecordsForGroup(records, recordIndexs) {
    for (let index = 0; index < recordIndexs.length; index++) {
      const recordIndex = recordIndexs[index];
      if (isNumber_default(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) continue;
      const originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
      this.beforeChangedRecordsMap.delete(originRecordIndex.toString()), this.dataSourceObj.records[originRecordIndex] = records[index];
    }
    this.updateGroup();
  }
  addRecordsForTree(recordArr, recordIndex) {
    if (isArray_default(recordArr) && 0 !== recordArr.length) {
      if (this.adjustBeforeChangedRecordsMap(recordIndex, recordArr.length), isNumber_default(recordIndex)) this.dataSourceObj.records.splice(recordIndex, 0, ...recordArr);
      else {
        const index = recordIndex.pop(), parentRecord = this.getOriginalRecord(recordIndex);
        parentRecord.children ? parentRecord.children.splice(index, 0, ...recordArr) : parentRecord.children = recordArr;
      }
      this.initTreeHierarchyState(), this.updatePagerData();
    }
  }
  deleteRecordsForTree(recordIndexs) {
    if (!isArray_default(recordIndexs) || 0 === recordIndexs.length) return;
    const recordIndexsMaxToMin = sortRecordIndexs(recordIndexs, -1);
    for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
      const recordIndex = recordIndexsMaxToMin[index];
      if (!isNumber_default(recordIndex) || !(recordIndex >= this.sourceLength || recordIndex < 0)) {
        if (this.beforeChangedRecordsMap.delete(recordIndex.toString()), isNumber_default(recordIndex)) this.dataSourceObj.records.splice(recordIndex, 1);
        else {
          const index2 = recordIndex.pop();
          this.getOriginalRecord(recordIndex).children.splice(index2, 1);
        }
        this.adjustBeforeChangedRecordsMap(recordIndex, 1, "delete");
      }
    }
    this.initTreeHierarchyState(), this.updatePagerData();
  }
  updateRecordsForTree(records, recordIndexs) {
    for (let index = 0; index < recordIndexs.length; index++) {
      const recordIndex = recordIndexs[index], record = records[index];
      if (!isNumber_default(recordIndex) || !(recordIndex >= this.sourceLength || recordIndex < 0)) if (this.beforeChangedRecordsMap.delete(recordIndex.toString()), isNumber_default(recordIndex)) this.dataSourceObj.records.splice(recordIndex, 1, record);
      else {
        const index2 = recordIndex.pop();
        this.getOriginalRecord(recordIndex).children.splice(index2, 1, record);
      }
    }
    this.initTreeHierarchyState(), this.updatePagerData();
  }
  adjustBeforeChangedRecordsMap(insertIndex, insertCount, type = "add") {
    if ("tree" === this.rowHierarchyType) {
      let insertIndexArr;
      insertIndexArr = isNumber_default(insertIndex) ? [insertIndex] : insertIndex;
      const targetResult = [];
      this.beforeChangedRecordsMap.forEach((value, key) => {
        var _a, _b;
        const keyArray = key.split(","), length2 = Math.max(keyArray.length, insertIndexArr.length);
        for (let i = 0; i < length2; i++) {
          const current = null !== (_a = insertIndexArr[i]) && void 0 !== _a ? _a : -1, keyIndex = null !== (_b = Number(keyArray[i])) && void 0 !== _b ? _b : -1;
          if (current < keyIndex || current === keyIndex && i === keyArray.length - 1 && i === insertIndexArr.length - 1) return keyArray[i] = (keyIndex + ("add" === type ? insertCount : -insertCount)).toString(), void targetResult.push({
            originKey: key,
            targetKey: keyArray.toString(),
            value
          });
        }
      }), targetResult.forEach(({ originKey, targetKey, value }) => {
        this.beforeChangedRecordsMap.delete(originKey), this.beforeChangedRecordsMap.set(targetKey, value);
      });
    } else super.adjustBeforeChangedRecordsMap(insertIndex, insertCount, type);
  }
  cacheBeforeChangedRecord(dataIndex, table) {
    var _a;
    const originRecord = this.getOriginalRecord(dataIndex);
    table.options.groupBy && (dataIndex = this.getOriginRecordIndexForGroup(dataIndex)), this.beforeChangedRecordsMap.has(dataIndex.toString()) || this.beforeChangedRecordsMap.set(dataIndex.toString(), null !== (_a = cloneDeep(originRecord, void 0, ["vtable_gantt_linkedFrom", "vtable_gantt_linkedTo"])) && void 0 !== _a ? _a : {});
  }
  getGroupSeriesNumber(showIndex) {
    const recordIndex = this.dataSource.currentIndexedData[showIndex], parentRecordIndexLength = recordIndex.length - 1;
    let recordIndexLength = recordIndex.length, i = 1;
    for (; recordIndexLength > parentRecordIndexLength; i++) {
      const index = this.dataSource.currentIndexedData[showIndex - i];
      recordIndexLength = isNumber_default(index) ? 1 : index.length;
    }
    return i - 1;
  }
};
function dealWithGroup(record, children, map2, groupByKeys, level) {
  const groupByKey = groupByKeys[level];
  if (!isValid_default(groupByKey)) return void children.push(record);
  const value = (0, import_get.default)(record, groupByKey);
  if (void 0 !== value) {
    if (map2.has(value)) {
      const index = map2.get(value);
      return dealWithGroup(record, children[index].children, children[index].map, groupByKeys, level + 1);
    }
    return map2.set(value, children.length), children.push({
      vtableMerge: true,
      vtableMergeName: value,
      children: [],
      map: /* @__PURE__ */ new Map()
    }), dealWithGroup(record, children[children.length - 1].children, children[children.length - 1].map, groupByKeys, level + 1);
  }
}
function syncGroupCollapseState(oldSource, newSource, oldGroupMap, newGroupMap) {
  if (!oldGroupMap) {
    oldGroupMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < oldSource.length; i++) {
      const record = oldSource[i];
      record.vtableMerge && oldGroupMap.set(record.vtableMergeName, i);
    }
  }
  if (!newGroupMap) {
    newGroupMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < newSource.length; i++) {
      const record = newSource[i];
      record.vtableMerge && newGroupMap.set(record.vtableMergeName, i);
    }
  }
  for (let i = 0; i < oldSource.length; i++) {
    const oldRecord = oldSource[i], newRecord = newSource[newGroupMap.get(oldRecord.vtableMergeName)];
    isValid_default(newRecord) && (newRecord.hierarchyState = oldSource[i].hierarchyState), isArray_default(oldRecord.children) && isArray_default(newRecord.children) && 0 !== oldRecord.map.size && 0 !== newRecord.map.size && syncGroupCollapseState(oldRecord.children, newRecord.children, oldRecord.map, newRecord.map);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/utils/font.js
var import_cssfontparser = __toESM(require_cssfontparser());
function parseFont(font) {
  return (0, import_cssfontparser.default)(font);
}

// node_modules/@visactor/vtable/es/scenegraph/utils/padding.js
function getQuadProps(paddingOrigin) {
  var _a, _b, _c, _d;
  if (isNumber_default(paddingOrigin) || isString_default(paddingOrigin) || isArray_default(paddingOrigin)) {
    let padding = parsePadding(paddingOrigin);
    return "number" == typeof padding || "string" == typeof padding ? padding = [padding, padding, padding, padding] : Array.isArray(padding) && (padding = padding.slice(0)), padding;
  }
  return paddingOrigin && (isFinite(paddingOrigin.bottom) || isFinite(paddingOrigin.left) || isFinite(paddingOrigin.right) || isFinite(paddingOrigin.top)) ? [null !== (_a = paddingOrigin.top) && void 0 !== _a ? _a : 0, null !== (_b = paddingOrigin.right) && void 0 !== _b ? _b : 0, null !== (_c = paddingOrigin.bottom) && void 0 !== _c ? _c : 0, null !== (_d = paddingOrigin.left) && void 0 !== _d ? _d : 0] : [0, 0, 0, 0];
}

// node_modules/@visactor/vtable/es/tools/calc.js
var TYPE_PAREN = 0;
var TYPE_UNIT = 1;
var TYPE_OPERATOR = 2;
var TYPE_NUMBER = 3;
var NODE_TYPE_UNIT = 10;
var NODE_TYPE_BINARY_EXPRESSION = 11;
var NODE_TYPE_NUMBER = 12;
var TABULATION = 9;
var CARRIAGE_RETURN = 13;
var LINE_FEED = 10;
var FORM_FEED = 12;
var SPACE = 32;
var PERCENT = 37;
var FULL_STOP = 46;
var DIGIT_0 = 48;
var DIGIT_9 = 57;
var LATIN_CAPITAL_A = 65;
var LATIN_CAPITAL_Z = 90;
var LATIN_SMALL_A = 97;
var LATIN_SMALL_Z = 122;
function isUpperLetter(cp) {
  return cp >= LATIN_CAPITAL_A && cp <= LATIN_CAPITAL_Z;
}
function isLowerLetter(cp) {
  return cp >= LATIN_SMALL_A && cp <= LATIN_SMALL_Z;
}
function isLetter(cp) {
  return isLowerLetter(cp) || isUpperLetter(cp);
}
function isWhitespace(cp) {
  return cp === TABULATION || cp === LINE_FEED || cp === FORM_FEED || cp === CARRIAGE_RETURN || cp === SPACE;
}
function isDigit(cp) {
  return cp >= DIGIT_0 && cp <= DIGIT_9;
}
function isDot(cp) {
  return cp === FULL_STOP;
}
function isUnit(cp) {
  return isLetter(cp) || cp === PERCENT;
}
function createError(calc) {
  return new Error(`calc parse error: ${calc}`);
}
function tokenize(calc) {
  const exp = calc.replace(/calc\(/g, "(").trim(), tokens = [], len = exp.length;
  for (let index = 0; index < len; index++) {
    const c2 = exp[index], cp = c2.charCodeAt(0);
    if ("(" === c2 || ")" === c2) tokens.push({
      value: c2,
      type: TYPE_PAREN
    });
    else if ("*" === c2 || "/" === c2) tokens.push({
      value: c2,
      type: TYPE_OPERATOR
    });
    else if ("+" === c2 || "-" === c2) index = parseSign(c2, index + 1) - 1;
    else if (isDigit(cp) || isDot(cp)) index = parseNum(c2, index + 1) - 1;
    else if (!isWhitespace(cp)) throw createError(calc);
  }
  function parseSign(sign2, start) {
    if (start < len) {
      const c2 = exp[start], cp = c2.charCodeAt(0);
      if (isDigit(cp) || isDot(cp)) return parseNum(sign2 + c2, start + 1);
    }
    return tokens.push({
      value: sign2,
      type: TYPE_OPERATOR
    }), start;
  }
  function parseNum(num, start) {
    let index = start;
    for (; index < len; index++) {
      const c2 = exp[index], cp = c2.charCodeAt(0);
      if (isDigit(cp)) num += c2;
      else {
        if ("." !== c2) {
          if (isUnit(cp)) return parseUnit(num, c2, index + 1);
          break;
        }
        if (num.indexOf(".") >= 0) throw createError(calc);
        num += c2;
      }
    }
    if ("." === num) throw createError(calc);
    return tokens.push({
      value: parseFloat(num),
      type: TYPE_NUMBER
    }), index;
  }
  function parseUnit(num, unit, start) {
    let index = start;
    for (; index < len; index++) {
      const c2 = exp[index];
      if (!isUnit(c2.charCodeAt(0))) break;
      unit += c2;
    }
    return tokens.push({
      value: parseFloat(num),
      unit,
      type: TYPE_UNIT
    }), index;
  }
  return tokens;
}
var PRECEDENCE = {
  "*": 3,
  "/": 3,
  "+": 2,
  "-": 2
};
function lex(tokens, calc) {
  function buildBinaryExpNode(stack2) {
    const right = stack2.pop(), op = stack2.pop(), left = stack2.pop();
    if (!(left && left.nodeType && op && op.type === TYPE_OPERATOR && right && right.nodeType)) throw createError(calc);
    return {
      nodeType: NODE_TYPE_BINARY_EXPRESSION,
      left,
      op,
      right
    };
  }
  const stack = [];
  for (; tokens.length; ) {
    const token = tokens.shift();
    if (token.type === TYPE_PAREN && "(" === token.value) {
      let deep = 0;
      const closeIndex = array2.findIndex(tokens, (t) => {
        if (t.type === TYPE_PAREN && "(" === t.value) deep++;
        else if (t.type === TYPE_PAREN && ")" === t.value) {
          if (!deep) return true;
          deep--;
        }
        return false;
      });
      if (-1 === closeIndex) throw createError(calc);
      stack.push(lex(tokens.splice(0, closeIndex), calc)), tokens.shift();
    } else if (token.type === TYPE_OPERATOR) {
      if (stack.length >= 3) {
        const beforeOp = stack[stack.length - 2].value;
        PRECEDENCE[token.value] <= PRECEDENCE[beforeOp] && stack.push(buildBinaryExpNode(stack));
      }
      stack.push(token);
    } else if (token.type === TYPE_UNIT) {
      const { value: num, unit } = token;
      stack.push({
        nodeType: NODE_TYPE_UNIT,
        value: num,
        unit
      });
    } else token.type === TYPE_NUMBER && stack.push({
      nodeType: NODE_TYPE_NUMBER,
      value: token.value
    });
  }
  for (; stack.length > 1; ) stack.push(buildBinaryExpNode(stack));
  return stack[0];
}
function parse3(calcStr) {
  return lex(tokenize(calcStr), calcStr);
}
function calcNode(node, context) {
  if (node.nodeType === NODE_TYPE_BINARY_EXPRESSION) {
    const left = calcNode(node.left, context), right = calcNode(node.right, context);
    switch (node.op.value) {
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      default:
        throw new Error(`calc error. unknown operator: ${node.op.value}`);
    }
  } else if (node.nodeType === NODE_TYPE_UNIT) switch (node.unit) {
    case "%":
      return node.value * context.full / 100;
    case "px":
      return node.value;
    default:
      throw new Error(`calc error. unknown unit: ${node.unit}`);
  }
  else if (node.nodeType === NODE_TYPE_NUMBER) return node.value;
  throw new Error("calc error.");
}
function toPxInternal(value, context) {
  return calcNode(parse3(value), context);
}
function toPx(value, context) {
  return "string" == typeof value ? toPxInternal(value.trim(), context) : value - 0;
}
function couldBeValidNumber(v) {
  return !isNil_default(v) && (!!isNumber_default(v) || +v == +v);
}
function isPercent(v) {
  return !!isString_default(v) && (!!v.endsWith("%") && couldBeValidNumber(v.substring(0, v.length - 1)));
}

// node_modules/@visactor/vtable/es/core/tableHelper.js
function createRootElement(padding, className = "vtable") {
  var _a, _b;
  const element = document.createElement("div");
  element.setAttribute("tabindex", "0"), element.classList.add(className), element.style.outline = "none", element.style.margin = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
  const width = (element.offsetWidth || (null === (_a = element.parentElement) || void 0 === _a ? void 0 : _a.offsetWidth) || 1) - 1, height = (element.offsetHeight || (null === (_b = element.parentElement) || void 0 === _b ? void 0 : _b.offsetHeight) || 1) - 1;
  return element.style.width = width && width - padding.left - padding.right + "px" || "0px", element.style.height = height && height - padding.top - padding.bottom + "px" || "0px", element;
}
function updateRootElementPadding(element, padding) {
  var _a, _b;
  element.style.margin = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
  const width = (element.offsetWidth || (null === (_a = element.parentElement) || void 0 === _a ? void 0 : _a.offsetWidth) || 1) - 1, height = (element.offsetHeight || (null === (_b = element.parentElement) || void 0 === _b ? void 0 : _b.offsetHeight) || 1) - 1;
  element.style.width = width && width - padding.left - padding.right + "px" || "0px", element.style.height = height && height - padding.top - padding.bottom + "px" || "0px";
}
function _dealWithUpdateDataSource(table, fn) {
  const { dataSourceEventIds } = table.internalProps;
  dataSourceEventIds && dataSourceEventIds.forEach((id) => table.internalProps.handler.off(id)), fn(table), table.internalProps.dataSourceEventIds = [table.internalProps.handler.on(table.internalProps.dataSource, DataSource.EVENT_TYPE.CHANGE_ORDER, () => {
    table.dataSource.hierarchyExpandLevel && table.refreshRowColCount(), table.render();
  })];
}
function _setRecords(table, records = []) {
  _dealWithUpdateDataSource(table, () => {
    table.internalProps.records = records;
    const newDataSource = table.internalProps.dataSource = CachedDataSource.ofArray(records, table.internalProps.dataConfig, table.pagination, table.internalProps.columns, table.internalProps.layoutMap.rowHierarchyType, getHierarchyExpandLevel(table));
    table.addReleaseObj(newDataSource);
  });
}
function getHierarchyExpandLevel(table) {
  var _a;
  return table.options.hierarchyExpandLevel ? table.options.hierarchyExpandLevel : table.options.groupBy ? 1 / 0 : (null === (_a = table._hasHierarchyTreeHeader) || void 0 === _a ? void 0 : _a.call(table)) ? 1 : void 0;
}
function _setDataSource(table, dataSource) {
  _dealWithUpdateDataSource(table, () => {
    table.internalProps.dataSource && table.internalProps.releaseList.forEach((releaseObj) => {
      releaseObj instanceof DataSource && (releaseObj.release(), table.internalProps.releaseList.splice(table.internalProps.releaseList.indexOf(releaseObj), 1));
    }), dataSource ? dataSource instanceof DataSource ? (table.internalProps.dataSource = dataSource, table.internalProps.dataSource.supplementConfig(table.pagination, table.options.columns, table.internalProps.layoutMap.rowHierarchyType, getHierarchyExpandLevel(table))) : table.internalProps.dataSource = new CachedDataSource(dataSource) : table.internalProps.dataSource = DataSource.EMPTY, table.addReleaseObj(table.internalProps.dataSource), table.internalProps.records = null;
  });
}
function _getTargetFrozenRowAt(table, absoluteY) {
  if (!table.internalProps.frozenRowCount) return null;
  let { scrollTop } = table;
  const rowCount = table.internalProps.frozenRowCount;
  for (let row = 0; row < rowCount; row++) {
    const height = table.getRowHeight(row), bottom = scrollTop + height;
    if (bottom > absoluteY) return {
      top: scrollTop,
      row,
      bottom,
      height
    };
    scrollTop = bottom;
  }
  return null;
}
function _getTargetFrozenColAt(table, absoluteX) {
  if (!table.internalProps.frozenColCount) return null;
  let { scrollLeft } = table;
  const colCount = table.internalProps.frozenColCount;
  for (let col = 0; col < colCount; col++) {
    const width = table.getColWidth(col), right = scrollLeft + width;
    if (right > absoluteX) return {
      left: scrollLeft,
      col,
      right,
      width
    };
    scrollLeft = right;
  }
  return null;
}
function _toPxWidth(table, width) {
  return Math.round(toPx(width, table.internalProps.calcWidthContext));
}
function _applyColWidthLimits(limits, orgWidth) {
  return limits ? limits.min && limits.min > orgWidth ? limits.min : limits.max && limits.max < orgWidth ? limits.max : orgWidth : orgWidth;
}
function _getScrollableVisibleRect(table) {
  let frozenColsWidth = 0, rightFrozenColsWidth = 0;
  table.frozenColCount > 0 && (frozenColsWidth = table.getFrozenColsWidth()), table.rightFrozenColCount > 0 && (rightFrozenColsWidth = table.getRightFrozenColsWidth());
  let frozenRowsHeight = 0, bottomFrozenRowsHeight = 0;
  return table.frozenRowCount > 0 && (frozenRowsHeight = table.getFrozenRowsHeight()), table.bottomFrozenRowCount > 0 && (bottomFrozenRowsHeight = table.getBottomFrozenRowsHeight()), new Rect2(table.scrollLeft + frozenColsWidth, table.scrollTop + frozenRowsHeight, table.tableNoFrameWidth - frozenColsWidth - rightFrozenColsWidth, table.tableNoFrameHeight - frozenRowsHeight - bottomFrozenRowsHeight);
}
function getStyleTheme(headerStyle, table, col, row, getProp3, needGetTheme = true) {
  const padding = getQuadProps(getProp3("padding", headerStyle, col, row, table)), bgColor = getProp3("bgColor", headerStyle, col, row, table), font = getProp3("font", headerStyle, col, row, table);
  let fontFamily, fontSize, fontWeight, fontStyle, fontVariant;
  if (font) {
    const { family, size, weight, style: style2, variant } = parseFont(font);
    fontFamily = family.join(" "), fontSize = size, fontWeight = weight, fontStyle = style2, fontStyle = variant;
  } else fontFamily = getProp3("fontFamily", headerStyle, col, row, table), fontSize = getProp3("fontSize", headerStyle, col, row, table), fontWeight = getProp3("fontWeight", headerStyle, col, row, table), fontStyle = getProp3("fontStyle", headerStyle, col, row, table), fontVariant = getProp3("fontVariant", headerStyle, col, row, table);
  const textAlign = getProp3("textAlign", headerStyle, col, row, table), textBaseline = getProp3("textBaseline", headerStyle, col, row, table), color = getProp3("color", headerStyle, col, row, table), strokeColor = getProp3("strokeColor", headerStyle, col, row, table), lineHeight = getProp3("lineHeight", headerStyle, col, row, table), underline = getProp3("underline", headerStyle, col, row, table), underlineDash = getProp3("underlineDash", headerStyle, col, row, table), underlineOffset = getProp3("underlineOffset", headerStyle, col, row, table), lineThrough = getProp3("lineThrough", headerStyle, col, row, table), textDecorationWidth = Math.max(1, Math.floor(fontSize / 10)), textOverflow = getProp3("textOverflow", headerStyle, col, row, table), borderColor = getProp3("borderColor", headerStyle, col, row, table), borderLineWidth = getProp3("borderLineWidth", headerStyle, col, row, table), borderLineDash = getProp3("borderLineDash", headerStyle, col, row, table), marked = getProp3("marked", headerStyle, col, row, table), cursor = getProp3("cursor", headerStyle, col, row, table), hasFunctionPros = !(padding && bgColor && font && textAlign && textBaseline && color && textOverflow && borderColor && borderLineWidth && borderLineDash && "boolean" == typeof underline && "boolean" == typeof lineThrough && "boolean" == typeof marked);
  if (!needGetTheme) return {
    hasFunctionPros
  };
  const theme4 = {
    text: {
      fontFamily,
      fontSize,
      fontWeight,
      fontStyle,
      fontVariant,
      fill: color,
      stroke: null != strokeColor && strokeColor,
      textAlign,
      textBaseline,
      lineHeight: null != lineHeight ? lineHeight : fontSize,
      underline: underline ? textDecorationWidth : void 0,
      underlineDash,
      underlineOffset,
      lineThrough: lineThrough ? textDecorationWidth : void 0,
      ellipsis: "clip" === textOverflow ? "" : "ellipsis" === textOverflow ? "..." : isValid_default(textOverflow) ? textOverflow : void 0
    },
    group: {
      fill: bgColor,
      lineDash: borderLineDash,
      lineWidth: borderLineWidth,
      stroke: borderColor,
      cursor: "auto" === cursor || "default" === cursor ? void 0 : cursor
    },
    _vtable: {
      padding,
      marked
    }
  };
  if (Array.isArray(borderLineWidth) && (theme4.group.strokeArrayWidth = getQuadProps(borderLineWidth)), Array.isArray(borderColor)) {
    const strokeColors = getQuadProps(borderColor);
    theme4.group.stroke = !strokeColors.every((color2) => !color2) && strokeColors, theme4.group.strokeArrayColor = getQuadProps(borderColor);
  }
  return {
    theme: theme4,
    hasFunctionPros
  };
}
function getCellCornerRadius(col, row, table) {
  const tableCornerRadius = table.theme.frameStyle.cornerRadius;
  if (table.theme.cellInnerBorder) {
    if (Array.isArray(tableCornerRadius)) {
      const radius = [0, 0, 0, 0];
      return 0 === col && 0 === row && (radius[0] = tableCornerRadius[0]), col === table.colCount - 1 && 0 === row && (radius[1] = tableCornerRadius[1]), 0 === col && row === table.rowCount - 1 && (radius[3] = tableCornerRadius[3]), col === table.colCount - 1 && row === table.rowCount - 1 && (radius[2] = tableCornerRadius[2]), radius;
    }
    if (tableCornerRadius) {
      const radius = [0, 0, 0, 0];
      return 0 === col && 0 === row && (radius[0] = tableCornerRadius), col === table.colCount - 1 && 0 === row && (radius[1] = tableCornerRadius), 0 === col && row === table.rowCount - 1 && (radius[3] = tableCornerRadius), col === table.colCount - 1 && row === table.rowCount - 1 && (radius[2] = tableCornerRadius), radius;
    }
  }
  return 0;
}
function parseMarkLineGetExtendRange(markLine) {
  var _a, _b, _c, _d;
  if (markLine) {
    if (Array.isArray(markLine)) {
      let extendRange;
      for (let i = 0; i < markLine.length; i++) if (markLine[i].autoRange) {
        if ("sum" === markLine[i].y || "sum" === markLine[i].x || "sum" === markLine[i].y1 || "sum" === markLine[i].x1) return "sum";
        "max" !== markLine[i].y && "max" !== markLine[i].x && "max" !== markLine[i].y1 && "max" !== markLine[i].x1 || (extendRange = "max"), "number" == typeof markLine[i].y && "number" == typeof (null != extendRange ? extendRange : 0) && (extendRange = Math.max(null !== (_a = extendRange) && void 0 !== _a ? _a : 0, markLine[i].y)), "number" == typeof markLine[i].x && "number" == typeof (null != extendRange ? extendRange : 0) && (extendRange = Math.max(null !== (_b = extendRange) && void 0 !== _b ? _b : 0, markLine[i].x)), "number" == typeof markLine[i].y1 && "number" == typeof (null != extendRange ? extendRange : 0) && (extendRange = Math.max(null !== (_c = extendRange) && void 0 !== _c ? _c : 0, markLine[i].y1)), "number" == typeof markLine[i].x1 && "number" == typeof (null != extendRange ? extendRange : 0) && (extendRange = Math.max(null !== (_d = extendRange) && void 0 !== _d ? _d : 0, markLine[i].x1));
      }
      return extendRange;
    }
    if (markLine.autoRange) {
      if ("sum" === markLine.y || "sum" === markLine.x || "sum" === markLine.y1 || "sum" === markLine.x1) return "sum";
      if ("max" === markLine.y || "max" === markLine.x || "max" === markLine.y1 || "max" === markLine.x1) return "max";
      if ("number" == typeof markLine.y) return markLine.y;
      if ("number" == typeof markLine.x) return markLine.x;
      if ("number" == typeof markLine.y1) return markLine.y1;
      if ("number" == typeof markLine.x1) return markLine.x1;
    }
  }
}
function generateAggregationForColumn(table) {
  for (let col = 0; col < table.internalProps.columns.length; col++) {
    const colDef = table.internalProps.columns[col];
    if (colDef.aggregation) ;
    else if (table.options.aggregation) {
      let aggregation;
      if (aggregation = "function" == typeof table.options.aggregation ? table.options.aggregation({
        col,
        field: colDef.field
      }) : table.options.aggregation, aggregation) if (Array.isArray(aggregation)) {
        const aggregations = [];
        aggregation.forEach((item) => {
          aggregations.push(Object.assign({
            showOnTop: false
          }, item));
        }), colDef.aggregation = aggregations;
      } else colDef.aggregation = Object.assign({
        showOnTop: false
      }, aggregation);
    }
  }
}
function checkHasAggregationOnColumnDefine(colDefs) {
  for (let i = 0; i < colDefs.length; i++) {
    if (colDefs[i].aggregation) return true;
  }
  return false;
}
function checkHasColumnAutoWidth(table) {
  if ("autoWidth" === table.options.widthMode) return true;
  if ("auto" === table.options.defaultHeaderColWidth || Array.isArray(table.options.defaultHeaderColWidth) && table.options.defaultHeaderColWidth.includes("auto")) return true;
  const columnObjects = table.internalProps.layoutMap.columnObjects;
  for (let i = 0; i < columnObjects.length; i++) {
    if ("auto" === columnObjects[i].width) return true;
  }
  return false;
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/icon.js
var import_gifuct_js2 = __toESM(require_lib());
var Icon = class extends Image2 {
  constructor(params2) {
    super(params2), "mouseenter_cell" !== this.attribute.visibleTime && "click_cell" !== this.attribute.visibleTime || (this.attribute.opacity = 0), this.attribute.hoverImage && (this.attribute.originImage = this.attribute.image), this.attribute.isGif && this.attribute.gif && this.loadGif();
  }
  loadGif() {
    this.playing = false, ResourceLoader.GetFile(this.attribute.gif + `?role=gif&radom=${Math.random()}`, "arrayBuffer").then((res) => {
      const gif = (0, import_gifuct_js2.parseGIF)(res), frames = (0, import_gifuct_js2.decompressFrames)(gif, true);
      this.renderGIF(frames), this.resources.set(this.attribute.image, {
        state: "success",
        data: this.gifCanvas
      });
    }).catch((e) => {
    });
  }
  get backgroundWidth() {
    var _a, _b;
    return null !== (_b = null !== (_a = this.attribute.backgroundWidth) && void 0 !== _a ? _a : this.attribute.width) && void 0 !== _b ? _b : 0;
  }
  get backgroundHeight() {
    var _a, _b;
    return null !== (_b = null !== (_a = this.attribute.backgroundHeight) && void 0 !== _a ? _a : this.attribute.height) && void 0 !== _b ? _b : 0;
  }
  renderGIF(frames) {
    this.loadedFrames = frames, this.frameIndex = 0, this.tempCanvas || (this.tempCanvas = document.createElement("canvas"), this.tempCtx = this.tempCanvas.getContext("2d")), this.gifCanvas || (this.gifCanvas = document.createElement("canvas"), this.gifCtx = this.gifCanvas.getContext("2d")), this.gifCanvas.width = frames[0].dims.width, this.gifCanvas.height = frames[0].dims.height, this.playing = true, this.lastTime = (/* @__PURE__ */ new Date()).getTime(), this.animate().to({}, 1e3, "linear").loop(1 / 0);
  }
  renderFrame(context, x, y) {
    const frame = this.loadedFrames[this.frameIndex || 0];
    2 === frame.disposalType && this.gifCtx.clearRect(0, 0, this.gifCanvas.width, this.gifCanvas.height), this.drawPatch(frame), this.manipulate(context, x, y);
    const diff = (/* @__PURE__ */ new Date()).getTime() - this.lastTime;
    frame.delay < diff && (this.frameIndex++, this.lastTime = (/* @__PURE__ */ new Date()).getTime()), this.frameIndex >= this.loadedFrames.length && (this.frameIndex = 0);
  }
  drawPatch(frame) {
    const dims = frame.dims;
    this.frameImageData && dims.width === this.frameImageData.width && dims.height === this.frameImageData.height || (this.tempCanvas.width = dims.width, this.tempCanvas.height = dims.height, this.frameImageData = this.tempCtx.createImageData(dims.width, dims.height)), this.frameImageData.data.set(frame.patch), this.tempCtx.putImageData(this.frameImageData, 0, 0), this.gifCtx.drawImage(this.tempCanvas, dims.left, dims.top);
  }
  manipulate(context, x, y) {
    context.drawImage(this.gifCanvas, 0, 0, this.gifCanvas.width, this.gifCanvas.height, x, y, this.attribute.width, this.attribute.height);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), "gif" === key && this.loadGif();
  }
  setAttributes(params2, forceUpdateTag, context) {
    super.setAttributes(params2, forceUpdateTag, context), params2.gif && this.loadGif();
  }
};
var TextIcon = class extends Text {
  constructor(params2) {
    var _a, _b, _c, _d, _e;
    params2.fill = null !== (_a = params2.fill) && void 0 !== _a ? _a : "#00F", params2.fontSize = null !== (_b = params2.fontSize) && void 0 !== _b ? _b : 12, params2.underline = null !== (_c = params2.underline) && void 0 !== _c ? _c : 1, params2.textBaseline = null !== (_d = params2.textBaseline) && void 0 !== _d ? _d : "top", params2.cursor = null !== (_e = params2.cursor) && void 0 !== _e ? _e : "pointer", super(params2);
  }
};

// node_modules/@visactor/vtable/es/components/react/react-custom-layout.js
function emptyCustomLayout(args) {
  return {
    rootContainer: new Group({}),
    renderDefault: true
  };
}
var ReactCustomLayout = class {
  constructor(table) {
    this.table = table, this.customLayoutFuncCache = /* @__PURE__ */ new Map(), this.reactRemoveGraphicCache = /* @__PURE__ */ new Map(), this.reactRemoveAllGraphicCache = /* @__PURE__ */ new Map(), this.headerCustomLayoutFuncCache = /* @__PURE__ */ new Map(), this.headerReactRemoveGraphicCache = /* @__PURE__ */ new Map(), this.headerReactRemoveAllGraphicCache = /* @__PURE__ */ new Map();
  }
  hasReactCreateGraphic(componentId, isHeaderCustomLayout) {
    return isHeaderCustomLayout ? this.headerCustomLayoutFuncCache.has(componentId) : this.customLayoutFuncCache.has(componentId);
  }
  setReactCreateGraphic(componentId, createGraphic, isHeaderCustomLayout) {
    isHeaderCustomLayout ? this.headerCustomLayoutFuncCache.set(componentId, createGraphic) : this.customLayoutFuncCache.set(componentId, createGraphic);
  }
  setReactRemoveGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
    isHeaderCustomLayout ? this.headerReactRemoveGraphicCache.set(componentId, removeGraphic) : this.reactRemoveGraphicCache.set(componentId, removeGraphic);
  }
  setReactRemoveAllGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
    isHeaderCustomLayout ? this.headerReactRemoveAllGraphicCache.set(componentId, removeGraphic) : this.reactRemoveAllGraphicCache.set(componentId, removeGraphic);
  }
  updateCustomCell(componentId, isHeaderCustomLayout) {
    const table = this.table;
    if ("autoWidth" === table.widthMode && table.scenegraph.recalculateColWidths(), (table.isAutoRowHeight() || "auto" === table.internalProps.defaultRowHeight && !isHeaderCustomLayout || "auto" === table.internalProps.defaultHeaderRowHeight && isHeaderCustomLayout) && table.scenegraph.recalculateRowHeights(), table.isPivotTable()) {
      const ranges = getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout);
      for (let i = 0; i < ranges.length; i++) {
        const range5 = ranges[i];
        for (let col = range5.start.col; col <= range5.end.col; col++) for (let row = range5.start.row; row <= range5.end.row; row++) table.scenegraph.updateCellContent(col, row);
      }
    } else {
      const range5 = getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout);
      for (let col = range5.start.col; col <= range5.end.col; col++) for (let row = range5.start.row; row <= range5.end.row; row++) table.scenegraph.updateCellContent(col, row);
    }
    table.scenegraph.renderSceneGraph();
  }
  getCustomLayoutFunc(col, row) {
    var _a;
    if (this.table.isHeader(col, row)) {
      const { componentId: componentId2 } = this.table.getHeaderDefine(col, row);
      return null !== (_a = this.headerCustomLayoutFuncCache.get(componentId2)) && void 0 !== _a ? _a : emptyCustomLayout;
    }
    const { componentId } = this.table.getBodyColumnDefine(col, row);
    return this.customLayoutFuncCache.get(componentId) || emptyCustomLayout;
  }
  removeCustomCell(col, row) {
    let removeFun;
    if (this.table.isHeader(col, row)) {
      const define = this.table.getHeaderDefine(col, row), { componentId } = define;
      removeFun = this.headerReactRemoveGraphicCache.get(componentId);
    } else {
      const define = this.table.getBodyColumnDefine(col, row), { componentId } = define;
      removeFun = this.reactRemoveGraphicCache.get(componentId);
    }
    removeFun && removeFun(col, row);
  }
  clearCache() {
    this.reactRemoveAllGraphicCache.forEach((removeFun) => {
      removeFun();
    }), this.headerReactRemoveAllGraphicCache.forEach((removeFun) => {
      removeFun();
    });
  }
  updateAllCustomCell() {
    this.customLayoutFuncCache.forEach((createFun, componentId) => {
      this.updateCustomCell(componentId);
    }), this.headerCustomLayoutFuncCache.forEach((createFun, componentId) => {
      this.updateCustomCell(componentId, true);
    });
  }
};
function getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout) {
  const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0;
  if (isHeaderCustomLayout) {
    const layoutMap = table.internalProps.layoutMap, { headerObjects } = table.internalProps.layoutMap;
    let headerId;
    for (let i = 0; i < headerObjects.length; i++) {
      const headerObject = headerObjects[i];
      if (headerObject.define.componentId === componentId) {
        headerId = headerObject.id;
        break;
      }
    }
    const startCell = layoutMap.getHeaderCellAdressById(headerId);
    return layoutMap.getCellRange(startCell.col, startCell.row);
  }
  const { columnObjects } = table.internalProps.layoutMap;
  for (let i = 0; i < columnObjects.length; i++) {
    if (columnObjects[i].define.componentId === componentId) return {
      start: {
        col: rowSeriesNumber + i,
        row: table.columnHeaderLevelCount
      },
      end: {
        col: rowSeriesNumber + i,
        row: table.rowCount - 1
      }
    };
  }
  return {
    start: {
      col: 0,
      row: 0
    },
    end: {
      col: table.colCount - 1,
      row: table.rowCount - 1
    }
  };
}
function getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout) {
  const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0, ranges = [], layoutMap = table.internalProps.layoutMap;
  if (isHeaderCustomLayout) {
    const { headerObjects } = layoutMap, headerIds = [];
    for (let i = 0; i < headerObjects.length; i++) {
      const headerObject = headerObjects[i];
      headerObject && (headerObject.define.componentId === componentId && headerIds.push(headerObject.id));
    }
    for (let i = 0; i < headerIds.length; i++) {
      const headerId = headerIds[i], startCell = layoutMap.getHeaderCellAdressById(headerId), range5 = layoutMap.getCellRange(startCell.col, startCell.row);
      ranges.push(range5);
    }
  } else {
    let columnIndex;
    const { columnObjects, indicatorsAsCol } = layoutMap;
    for (let i = 0; i < columnObjects.length; i++) {
      if (columnObjects[i].define.componentId === componentId) {
        columnIndex = i;
        break;
      }
    }
    if (indicatorsAsCol) for (let column = layoutMap.rowHeaderLevelCount + columnIndex; column < layoutMap.colCount; column += columnObjects.length) {
      const range5 = {
        start: {
          col: column + rowSeriesNumber,
          row: layoutMap.columnHeaderLevelCount
        },
        end: {
          col: column + rowSeriesNumber,
          row: layoutMap.rowCount - 1
        }
      };
      ranges.push(range5);
    }
    else for (let row = layoutMap.columnHeaderLevelCount + columnIndex; row < layoutMap.rowCount; row += columnObjects.length) {
      const range5 = {
        start: {
          col: layoutMap.rowHeaderLevelCount + rowSeriesNumber,
          row
        },
        end: {
          col: layoutMap.colCount - 1,
          row
        }
      };
      ranges.push(range5);
    }
  }
  return ranges;
}

// node_modules/@visactor/vtable/es/event/util.js
function getCellEventArgsSet(e) {
  const tableEvent = {
    abstractPos: {
      x: e.viewport.x,
      y: e.viewport.y
    }
  }, targetCell = getTargetCell(e.target);
  return targetCell && (tableEvent.eventArgs = {
    col: targetCell.col,
    row: targetCell.row,
    event: e,
    targetCell,
    mergeInfo: getMergeCellInfo(targetCell),
    target: e.target
  }), tableEvent;
}
function getTargetCell(target) {
  for (; target && target.parent; ) {
    if ("cell" === target.role) return target;
    target = target.parent;
  }
  return null;
}
function getMergeCellInfo(cellGroup) {
  if (isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeEndRow)) return {
    colStart: cellGroup.mergeStartCol,
    colEnd: cellGroup.mergeEndCol,
    rowStart: cellGroup.mergeStartRow,
    rowEnd: cellGroup.mergeEndRow
  };
}
var regIndexReg = /radio-\d+-\d+-(\d+)/;

// node_modules/@visactor/vtable/es/scenegraph/component/custom.js
var CUSTOM_MERGE_PRE_NAME = "_custom_";
var CUSTOM_CONTAINER_NAME = "custom-container";
var CUSTOM_MERGE_CONTAINER_NAME = CUSTOM_MERGE_PRE_NAME + "_0";
function dealWithCustom(customLayout, customRender, col, row, width, height, autoWidth, autoHeight, padding, range5, table) {
  var _a, _b, _c;
  let expectedWidth, expectedHeight, customElements, elementsGroup, renderDefault = true, enableCellPadding = false;
  if ("react-custom-layout" === customLayout && (customLayout = (null === (_a = table.reactCustomLayout) || void 0 === _a ? void 0 : _a.getCustomLayoutFunc(col, row)) || emptyCustomLayout), "function" == typeof customLayout) {
    const customRenderObj = customLayout({
      col: null !== (_b = null == range5 ? void 0 : range5.start.col) && void 0 !== _b ? _b : col,
      row: null !== (_c = null == range5 ? void 0 : range5.start.row) && void 0 !== _c ? _c : row,
      dataValue: table.getCellOriginValue(col, row),
      value: table.getCellValue(col, row) || "",
      rect: {
        left: 0,
        top: 0,
        right: width,
        bottom: height,
        width,
        height
      },
      table,
      originCol: col,
      originRow: row
    });
    if (!customRenderObj) return {
      renderDefault: true
    };
    customRenderObj.rootContainer && (customRenderObj.rootContainer = decodeReactDom(customRenderObj.rootContainer, table.animationManager.timeline)), customRenderObj.rootContainer instanceof Group && (elementsGroup = customRenderObj.rootContainer, elementsGroup.name = CUSTOM_CONTAINER_NAME, elementsGroup.col = col, elementsGroup.row = row), renderDefault = customRenderObj.renderDefault, enableCellPadding = customRenderObj.enableCellPadding;
  } else if ("function" == typeof customRender) {
    const customRenderObj = customRender({
      col,
      row,
      dataValue: table.getCellOriginValue(col, row),
      value: table.getCellValue(col, row) || "",
      rect: {
        left: 0,
        top: 0,
        right: width,
        bottom: height,
        width,
        height
      },
      table
    });
    customRenderObj && (customElements = customRenderObj.elements, renderDefault = customRenderObj.renderDefault, expectedWidth = customRenderObj.expectedWidth, expectedHeight = customRenderObj.expectedHeight);
  } else customRender && (expectedWidth = customRender.expectedWidth, expectedHeight = customRender.expectedHeight, customElements = customRender.elements, renderDefault = customRender.renderDefault);
  if (customElements) {
    elementsGroup = adjustElementToGroup(customElements, autoWidth ? expectedWidth : width, autoHeight ? expectedHeight : height, table.getCellValue(col, row));
  }
  return enableCellPadding && elementsGroup.setAttributes({
    x: padding[3],
    y: padding[0],
    width: width - padding[1] - padding[3],
    height: height - padding[0] - padding[2]
  }), dealPercentCalc(elementsGroup, width, height), !range5 || range5.start.col === range5.end.col && range5.start.row === range5.end.row || bindAttributeUpdate(elementsGroup, col, row, 0), {
    elementsGroup,
    renderDefault
  };
}
function adjustElementToGroup(elements, width, height, value) {
  const customGroup = new Group({
    x: 0,
    y: 0,
    width,
    height,
    fill: false,
    stroke: false,
    pickable: false
  });
  customGroup.name = CUSTOM_CONTAINER_NAME;
  return adjustElementsPos(elements, width, height, value).forEach((element) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
    switch (element.clickable && (element.pickable = element.clickable), element.type) {
      case "arc":
        const arc = createArc({
          x: element.x,
          y: element.y,
          dx: null !== (_a = element.dx) && void 0 !== _a ? _a : 0,
          dy: null !== (_b = element.dy) && void 0 !== _b ? _b : 0,
          fill: element.fill,
          stroke: element.stroke,
          outerRadius: element.radius,
          startAngle: element.startAngle,
          endAngle: element.endAngle,
          pickable: !!element.pickable,
          cursor: element.cursor
        });
        arc.name = element.name, customGroup.appendChild(arc);
        break;
      case "text":
        if (element.background) {
          const expandX = null !== (_d = null === (_c = element.background) || void 0 === _c ? void 0 : _c.expandX) && void 0 !== _d ? _d : 0, expandY = null !== (_f = null === (_e = element.background) || void 0 === _e ? void 0 : _e.expandY) && void 0 !== _f ? _f : 0, textBackRect = createRect({
            x: element.x - expandX,
            y: element.y - expandY,
            dx: null !== (_g = element.dx) && void 0 !== _g ? _g : 0,
            dy: null !== (_h = element.dy) && void 0 !== _h ? _h : 0,
            width: element.width + 2 * expandX,
            height: element.height + 2 * expandY,
            cornerRadius: null !== (_k = null === (_j = element.background) || void 0 === _j ? void 0 : _j.cornerRadius) && void 0 !== _k ? _k : 0,
            fill: null !== (_m = null === (_l = element.background) || void 0 === _l ? void 0 : _l.fill) && void 0 !== _m ? _m : "#888"
          });
          customGroup.appendChild(textBackRect);
        }
        const text2 = new Text(Object.assign({
          pickable: !!element.pickable,
          fill: null !== (_o = element.color) && void 0 !== _o ? _o : element.fill
        }, element));
        text2.name = element.name, customGroup.appendChild(text2);
        break;
      case "rect":
        const rect = createRect({
          x: element.x,
          y: element.y,
          dx: null !== (_p = element.dx) && void 0 !== _p ? _p : 0,
          dy: null !== (_q = element.dy) && void 0 !== _q ? _q : 0,
          width: element.width,
          height: element.height,
          cornerRadius: element.radius,
          fill: element.fill,
          stroke: element.stroke,
          pickable: !!element.pickable,
          cursor: element.cursor
        });
        rect.name = element.name, customGroup.appendChild(rect);
        break;
      case "circle":
        const circle2 = createCircle({
          x: element.x,
          y: element.y,
          dx: null !== (_r = element.dx) && void 0 !== _r ? _r : 0,
          dy: null !== (_s = element.dy) && void 0 !== _s ? _s : 0,
          radius: element.radius,
          fill: element.fill,
          stroke: element.stroke,
          pickable: !!element.pickable,
          cursor: element.cursor
        });
        circle2.name = element.name, customGroup.appendChild(circle2);
        break;
      case "icon":
        const icon2 = new Icon({
          x: element.x,
          y: element.y,
          dx: null !== (_t = element.dx) && void 0 !== _t ? _t : 0,
          dy: null !== (_u = element.dy) && void 0 !== _u ? _u : 0,
          width: element.width,
          height: element.height,
          image: element.svg,
          backgroundWidth: element.hover ? null !== (_v = element.hover.width) && void 0 !== _v ? _v : element.width : void 0,
          backgroundHeight: element.hover ? null !== (_w = element.hover.width) && void 0 !== _w ? _w : element.width : void 0,
          backgroundColor: element.hover ? null !== (_x = element.hover.bgColor) && void 0 !== _x ? _x : "rgba(22,44,66,0.2)" : void 0,
          pickable: !!element.pickable,
          cursor: element.cursor
        });
        icon2.name = element.name, icon2.role = "icon-custom", customGroup.appendChild(icon2);
        break;
      case "image":
        const image = new Icon({
          x: element.x,
          y: element.y,
          dx: null !== (_y = element.dx) && void 0 !== _y ? _y : 0,
          dy: null !== (_z = element.dy) && void 0 !== _z ? _z : 0,
          width: element.width,
          height: element.height,
          image: element.src,
          backgroundWidth: element.hover ? null !== (_0 = element.hover.width) && void 0 !== _0 ? _0 : element.width : void 0,
          backgroundHeight: element.hover ? null !== (_1 = element.hover.width) && void 0 !== _1 ? _1 : element.width : void 0,
          backgroundColor: element.hover ? null !== (_2 = element.hover.bgColor) && void 0 !== _2 ? _2 : "rgba(22,44,66,0.2)" : void 0,
          pickable: !!element.pickable,
          cursor: element.cursor,
          shape: element.shape
        });
        image.name = element.name, image.role = "image-custom", customGroup.appendChild(image);
        break;
      case "line":
        const line = createLine({
          points: element.points,
          lineWidth: null !== (_3 = element.lineWidth) && void 0 !== _3 ? _3 : 1,
          stroke: element.stroke,
          pickable: !!element.pickable,
          cursor: element.cursor
        });
        line.name = element.name, customGroup.appendChild(line);
    }
  }), customGroup;
}
function adjustElementsPos(originalElements, width, height, value) {
  const result2 = [], borderLineWidths = [0, 0, 0, 0];
  for (let i = 0; i < originalElements.length; i++) {
    const originalElement = originalElements[i], element = Object.assign({}, originalElement);
    for (const name in element) element.hasOwnProperty(name) && isFunction_default(element[name]) && (element[name] = element[name](value));
    const rect = element;
    isValid_default(rect.x) && (rect.x = isString_default(rect.x) ? transformString(rect.x, width - borderLineWidths[1]) : Number(rect.x)), isValid_default(rect.y) && (rect.y = isString_default(rect.y) ? transformString(rect.y, height - borderLineWidths[2]) : Number(rect.y)), "width" in element && (element.width = isString_default(element.width) ? transformString(element.width, width - borderLineWidths[1]) : Number(element.width)), "height" in element && (element.height = isString_default(element.height) ? transformString(element.height, height - borderLineWidths[2]) : Number(element.height)), "radius" in element && (element.radius = isString_default(element.radius) ? transformString(element.radius, Math.min(width - borderLineWidths[1], height - borderLineWidths[2])) : Number(element.radius)), "hover" in element && (element.hover.x = isString_default(element.hover.x) ? transformString(element.hover.x, width - borderLineWidths[1]) : Number(element.hover.x), element.hover.y = isString_default(element.hover.y) ? transformString(element.hover.y, height - borderLineWidths[2]) : Number(element.hover.y), element.hover.width = isString_default(element.hover.width) ? transformString(element.hover.width, width - borderLineWidths[1]) : Number(element.hover.width), element.hover.height = isString_default(element.hover.height) ? transformString(element.hover.height, height - borderLineWidths[2]) : Number(element.hover.height), element.hover.x += 0, element.hover.y += 0), rect.x = rect.x + 0, rect.y = rect.y + 0, result2.push(element);
  }
  return result2;
}
function transformString(str2, size) {
  return str2.endsWith("px") ? parseInt(str2, 10) : str2.endsWith("%") && size ? parseInt(str2, 10) / 100 * size : parseInt(str2, 10);
}
function dealPercentCalc(group, parentWidth, parentHeight) {
  group && group.forEachChildren((child) => {
    var _a, _b;
    child && (isObject_default(child.attribute.width) && child.attribute.width.percent && child.setAttribute("width", Math.max(0, child.attribute.width.percent / 100 * parentWidth + (null !== (_a = child.attribute.width.delta) && void 0 !== _a ? _a : 0))), child.attribute.width < 0 && child.setAttribute("width", 0), isObject_default(child.attribute.height) && child.attribute.height.percent && child.setAttribute("height", Math.max(0, child.attribute.height.percent / 100 * parentHeight + (null !== (_b = child.attribute.height.delta) && void 0 !== _b ? _b : 0))), child.attribute.height < 0 && child.setAttribute("height", 0), "group" === child.type && dealPercentCalc(child, child.attribute.width, child.attribute.height));
  });
}
function decodeReactDom(dom, timeline) {
  if (!dom || !isValid_default(dom.$$typeof) && !isValid_default(dom.vtype)) return dom;
  const type = dom.type, { attribute, children, stateProxy, animation } = dom.props, g = type({
    attribute
  });
  if (parseToGraphic2(g, dom.props), stateProxy && (g.stateProxy = stateProxy), g.id = attribute.id, g.name = attribute.name, isArray_default(children) ? children.forEach((item) => {
    const c2 = decodeReactDom(item, timeline);
    c2 && c2.type && g.add(c2);
  }) : children && g.add(decodeReactDom(children, timeline)), isArray_default(animation) && timeline) {
    const animate = g.animate();
    animate.setTimeline(timeline), animation.forEach((item) => {
      animate[item[0]](...item.slice(1));
    });
  }
  return g;
}
function parseToGraphic2(g, props) {
  let isGraphic = false;
  switch (g.type) {
    case "richtext":
    case "rich/image":
      break;
    default:
      isGraphic = true;
  }
  isGraphic && Object.keys(props).forEach((k2) => {
    const en = REACT_TO_CANOPUS_EVENTS[k2];
    en && g.on(en, props[k2]);
  });
}
function bindAttributeUpdate(group, col, row, index, preId) {
  group && (group.name = `${CUSTOM_MERGE_PRE_NAME}${null != preId ? preId : ""}_${index}`, group.onBeforeAttributeUpdate = onBeforeAttributeUpdate, "group" === group.type && group.childrenCount && group.forEachChildren((child, childIndex) => {
    bindAttributeUpdate(child, col, row, childIndex, (null != preId ? preId : "") + "_" + index);
  }));
}
function onBeforeAttributeUpdate(val, attribute) {
  const graphic = this;
  if (graphic.skipMergeUpdate) return;
  const cellGroup = getTargetCell(graphic);
  if (!cellGroup || !cellGroup.stage) return;
  const table = cellGroup.stage.table;
  graphic.skipAttributeUpdate = true;
  const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow } = cellGroup;
  if (isValid_default(mergeStartCol) && isValid_default(mergeEndCol) && isValid_default(mergeStartRow) && isValid_default(mergeEndRow) && (mergeStartCol !== mergeEndCol || mergeStartRow !== mergeEndRow)) {
    for (let col = mergeStartCol; col <= mergeEndCol; col++) for (let row = mergeStartRow; row <= mergeEndRow; row++) {
      if (col === cellGroup.col && row === cellGroup.row) continue;
      const cell = table.scenegraph.highPerformanceGetCell(col, row);
      if ("cell" === cell.role) {
        const target = cell.getChildByName(graphic.name, true);
        if (!target || target.skipAttributeUpdate) continue;
        for (const key in val) val[key] !== target.attribute[key] && "dx" !== key && "dy" !== key && target.setAttribute(key, val[key]);
      }
    }
    graphic.skipAttributeUpdate = void 0;
  }
}

// node_modules/@visactor/vtable/es/icons.js
var sort_color;
var sort_color_opacity;
var sort_color_2;
var sort_color_opacity_2;
var sort_size;
var sort_size_2;
var frozen_color;
var frozen_color_opacity;
var freeze_color_opacity;
var frozen_color_2;
var frozen_color_opacity_2;
var frozen_size;
var frozen_size_2;
var collapse_color;
var collapse_color_opacity;
var collapse_size;
var collapse_size_2;
var expand_color;
var expand_color_opacity;
var expand_size;
var expand_size_2;
var dragReorder_color;
var dragReorder_color_opacity;
var dragReorder_size;
function setIconColor(themeIconsColor) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  sort_color = null !== (_a = null == themeIconsColor ? void 0 : themeIconsColor.sort_color) && void 0 !== _a ? _a : "#282F38", sort_color_opacity = null !== (_b = null == themeIconsColor ? void 0 : themeIconsColor.sort_color_opacity) && void 0 !== _b ? _b : "0.35", sort_color_2 = null !== (_c = null == themeIconsColor ? void 0 : themeIconsColor.sort_color_2) && void 0 !== _c ? _c : "#416EFF", sort_color_opacity_2 = null !== (_d = null == themeIconsColor ? void 0 : themeIconsColor.sort_color_opacity_2) && void 0 !== _d ? _d : "1", sort_size = null !== (_e = null == themeIconsColor ? void 0 : themeIconsColor.sort_size) && void 0 !== _e ? _e : 16, sort_size_2 = null !== (_f = null == themeIconsColor ? void 0 : themeIconsColor.sort_size_2) && void 0 !== _f ? _f : 22, frozen_color = null !== (_g = null == themeIconsColor ? void 0 : themeIconsColor.frozen_color) && void 0 !== _g ? _g : "#282F38", frozen_color_opacity = null !== (_h = null == themeIconsColor ? void 0 : themeIconsColor.frozen_color_opacity) && void 0 !== _h ? _h : "0.35", freeze_color_opacity = null !== (_j = null == themeIconsColor ? void 0 : themeIconsColor.frozen_color_opacity) && void 0 !== _j ? _j : "0.2", frozen_color_2 = null !== (_k = null == themeIconsColor ? void 0 : themeIconsColor.frozen_color_2) && void 0 !== _k ? _k : "#416EFF", frozen_color_opacity_2 = null !== (_l = null == themeIconsColor ? void 0 : themeIconsColor.frozen_color_opacity_2) && void 0 !== _l ? _l : "1", frozen_size = null !== (_m = null == themeIconsColor ? void 0 : themeIconsColor.frozen_size) && void 0 !== _m ? _m : 22, frozen_size_2 = null !== (_o = null == themeIconsColor ? void 0 : themeIconsColor.frozen_size_2) && void 0 !== _o ? _o : 22, collapse_color = null !== (_p = null == themeIconsColor ? void 0 : themeIconsColor.collapse_color) && void 0 !== _p ? _p : "#141414", collapse_color_opacity = null !== (_q = null == themeIconsColor ? void 0 : themeIconsColor.collapse_color_opacity) && void 0 !== _q ? _q : "0.65", collapse_size = null !== (_r = null == themeIconsColor ? void 0 : themeIconsColor.collapse_size) && void 0 !== _r ? _r : 16, collapse_size_2 = null !== (_s = null == themeIconsColor ? void 0 : themeIconsColor.frozen_size_2) && void 0 !== _s ? _s : 22, expand_color = null !== (_t = null == themeIconsColor ? void 0 : themeIconsColor.expand_color) && void 0 !== _t ? _t : "#141414", expand_color_opacity = null !== (_u = null == themeIconsColor ? void 0 : themeIconsColor.expand_color_opacity) && void 0 !== _u ? _u : "0.65", expand_size = null !== (_v = null == themeIconsColor ? void 0 : themeIconsColor.expand_size) && void 0 !== _v ? _v : 16, expand_size_2 = null !== (_w = null == themeIconsColor ? void 0 : themeIconsColor.expand_size_2) && void 0 !== _w ? _w : 22, dragReorder_color = null !== (_x = null == themeIconsColor ? void 0 : themeIconsColor.dragReorder_color) && void 0 !== _x ? _x : "#666666", dragReorder_color_opacity = null !== (_y = null == themeIconsColor ? void 0 : themeIconsColor.dragReorder_color_opacity) && void 0 !== _y ? _y : "1", dragReorder_size = null !== (_z = null == themeIconsColor ? void 0 : themeIconsColor.dragReorder_size) && void 0 !== _z ? _z : 20;
}
var builtins = {
  get sort_downward() {
    return {
      type: "svg",
      svg: `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color_2}"  fill-opacity="${sort_color_opacity_2}"/><path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/></svg> `,
      width: sort_size,
      height: sort_size,
      funcType: IconFuncTypeEnum.sort,
      name: "sort_downward",
      positionType: IconPosition.contentRight,
      marginLeft: 3,
      hover: {
        width: sort_size_2,
        height: sort_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get sort_upward() {
    return {
      type: "svg",
      svg: `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color}"  fill-opacity="${sort_color_opacity}"/><path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color_2}"  fill-opacity="${sort_color_opacity_2}"/> </svg>`,
      width: sort_size,
      height: sort_size,
      funcType: IconFuncTypeEnum.sort,
      positionType: IconPosition.contentRight,
      name: "sort_upward",
      marginLeft: 3,
      hover: {
        width: sort_size_2,
        height: sort_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get sort_normal() {
    return {
      type: "svg",
      svg: `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/><path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/></svg> `,
      width: sort_size,
      height: sort_size,
      funcType: IconFuncTypeEnum.sort,
      positionType: IconPosition.contentRight,
      name: "sort_normal",
      marginLeft: 3,
      hover: {
        width: sort_size_2,
        height: sort_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get freeze() {
    return {
      type: "svg",
      svg: `<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0)"><path d="M17.1313 8.42047C17.1932 8.48238 17.2423 8.55587 17.2759 8.63676C17.3094 8.71764 17.3266 8.80434 17.3266 8.89189C17.3266 8.97944 17.3094 9.06613 17.2759 9.14702C17.2423 9.2279 17.1932 9.3014 17.1313 9.3633L13.3843 13.1103C13.7007 14.3048 13.5305 15.4443 12.8388 16.2395C12.8104 16.2781 12.7778 16.3136 12.7417 16.3451L12.712 16.3755C12.6501 16.4374 12.5766 16.4865 12.4957 16.52C12.4148 16.5535 12.3281 16.5707 12.2406 16.5707C12.153 16.5707 12.0663 16.5535 11.9854 16.52C11.9046 16.4865 11.8311 16.4374 11.7692 16.3755L9.17633 13.7826L6.05316 16.9058L5.11983 17.0925C5.09291 17.0979 5.06508 17.0965 5.03881 17.0886C5.01254 17.0806 4.98863 17.0663 4.96923 17.0469C4.94982 17.0275 4.9355 17.0036 4.92755 16.9773C4.9196 16.951 4.91827 16.9232 4.92366 16.8963L5.11033 15.963L8.23333 12.8396L5.64066 10.2471C5.57875 10.1852 5.52964 10.1117 5.49614 10.0309C5.46263 9.94997 5.44539 9.86327 5.44539 9.77572C5.44539 9.68817 5.46263 9.60148 5.49614 9.52059C5.52964 9.43971 5.57875 9.36621 5.64066 9.3043C5.65066 9.2943 5.66066 9.2843 5.67099 9.27464C5.70266 9.2383 5.73833 9.20547 5.77766 9.17664C6.57283 8.48564 7.71199 8.31564 8.90599 8.63197L12.6528 4.88497C12.7147 4.82306 12.7882 4.77395 12.8691 4.74045C12.95 4.70694 13.0367 4.6897 13.1242 4.6897C13.2118 4.6897 13.2985 4.70694 13.3794 4.74045C13.4603 4.77395 13.5338 4.82306 13.5957 4.88497L17.1312 8.42047H17.1313ZM15.7172 8.8918L13.1243 6.29914L9.56483 9.8588C9.47574 9.94788 9.36323 10.0099 9.24034 10.0376C9.11746 10.0654 8.98922 10.0578 8.87049 10.0156C8.22783 9.78764 7.63899 9.7553 7.17749 9.89814L12.1182 14.8388C12.261 14.3771 12.2287 13.7885 12.0007 13.146C11.9585 13.0272 11.9509 12.899 11.9787 12.7761C12.0064 12.6532 12.0684 12.5407 12.1575 12.4516L15.7172 8.89164V8.8918Z" fill="${frozen_color}" fill-opacity="${freeze_color_opacity}"/></g><defs><clipPath id="clip0"><rect width="22" height="22" fill="white"/></clipPath></defs></svg>`,
      width: frozen_size,
      height: frozen_size,
      name: "freeze",
      funcType: IconFuncTypeEnum.frozen,
      positionType: IconPosition.right,
      marginRight: 0,
      hover: {
        width: frozen_size_2,
        height: frozen_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get frozen() {
    return {
      type: "svg",
      svg: `<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.49975 3.66663C8.32294 3.66663 8.15337 3.73686 8.02835 3.86189C7.90332 3.98691 7.83309 4.15648 7.83309 4.33329V9.63246C6.76475 10.2533 6.07942 11.1795 6.00625 12.2308C5.99892 12.2786 5.99692 12.3268 6.00009 12.3741L5.99975 12.4166C5.99975 12.5934 6.06999 12.763 6.19501 12.888C6.32004 13.0131 6.48961 13.0833 6.66642 13.0833H10.3333L10.3331 17.5L10.8611 18.292C10.8763 18.3148 10.8969 18.3335 10.9211 18.3464C10.9453 18.3594 10.9723 18.3662 10.9998 18.3662C11.0272 18.3662 11.0542 18.3594 11.0784 18.3464C11.1026 18.3335 11.1232 18.3148 11.1384 18.292L11.6664 17.5L11.6666 13.0833H15.3331C15.5099 13.0833 15.6795 13.0131 15.8045 12.888C15.9295 12.763 15.9998 12.5934 15.9998 12.4166C15.9998 12.4025 15.9998 12.3883 15.9994 12.3741C16.0028 12.3263 16.0008 12.2776 15.9933 12.2295C15.9196 11.1786 15.2343 10.2528 14.1664 9.63229V4.33329C14.1664 4.15648 14.0962 3.98691 13.9712 3.86189C13.8461 3.73686 13.6766 3.66663 13.4998 3.66663H8.49975Z" fill="${frozen_color}" fill-opacity="${frozen_color_opacity}"/></svg>`,
      width: frozen_size,
      height: frozen_size,
      name: "frozen",
      funcType: IconFuncTypeEnum.frozen,
      positionType: IconPosition.right,
      marginRight: 0,
      hover: {
        width: frozen_size_2,
        height: frozen_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get frozenCurrent() {
    return {
      type: "svg",
      svg: `<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.49975 3.66663C8.32294 3.66663 8.15337 3.73686 8.02835 3.86189C7.90332 3.98691 7.83309 4.15648 7.83309 4.33329V9.63246C6.76475 10.2533 6.07942 11.1795 6.00625 12.2308C5.99892 12.2786 5.99692 12.3268 6.00009 12.3741L5.99975 12.4166C5.99975 12.5934 6.06999 12.763 6.19501 12.888C6.32004 13.0131 6.48961 13.0833 6.66642 13.0833H10.3333L10.3331 17.5L10.8611 18.292C10.8763 18.3148 10.8969 18.3335 10.9211 18.3464C10.9453 18.3594 10.9723 18.3662 10.9998 18.3662C11.0272 18.3662 11.0542 18.3594 11.0784 18.3464C11.1026 18.3335 11.1232 18.3148 11.1384 18.292L11.6664 17.5L11.6666 13.0833H15.3331C15.5099 13.0833 15.6795 13.0131 15.8045 12.888C15.9295 12.763 15.9998 12.5934 15.9998 12.4166C15.9998 12.4025 15.9998 12.3883 15.9994 12.3741C16.0028 12.3263 16.0008 12.2776 15.9933 12.2295C15.9196 11.1786 15.2343 10.2528 14.1664 9.63229V4.33329C14.1664 4.15648 14.0962 3.98691 13.9712 3.86189C13.8461 3.73686 13.6766 3.66663 13.4998 3.66663H8.49975Z"  fill="${frozen_color_2}" fill-opacity="${frozen_color_opacity_2}"/></svg>`,
      width: frozen_size,
      height: frozen_size,
      funcType: IconFuncTypeEnum.frozen,
      positionType: IconPosition.right,
      name: "frozenCurrent",
      marginRight: 0,
      hover: {
        width: frozen_size_2,
        height: frozen_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get dropdownIcon() {
    return {
      type: "svg",
      svg: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g><rect x="2" y="1" width="20" height="20" rx="10" fill="white"/><rect x="2.5" y="1.5" width="19" height="19" rx="9.5" stroke="#959DA5"/></g><path d="M14.9492 9.39531C15.0086 9.31911 15.0165 9.21887 14.9698 9.1356C14.923 9.05234 14.8294 9 14.7273 9L9.27273 9C9.17057 9 9.07697 9.05234 9.03023 9.1356C8.98348 9.21887 8.99142 9.31911 9.0508 9.39531L11.7781 12.8953C11.8293 12.961 11.9119 13 12 13C12.0881 13 12.1707 12.961 12.2219 12.8953L14.9492 9.39531Z" fill="#4F5965"/></svg>',
      width: 24,
      height: 24,
      funcType: IconFuncTypeEnum.dropDown,
      positionType: IconPosition.absoluteRight,
      name: "dropdownIcon",
      marginRight: 0,
      hover: {
        width: 24,
        height: 24,
        bgColor: "rgba(101, 117, 168, 0.1)",
        image: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g><rect x="2" y="1" width="20" height="20" rx="10" fill="#1E54C9"/><rect x="2.5" y="1.5" width="19" height="19" rx="9.5" stroke="#141414" stroke-opacity="0.2"/></g><path d="M14.9492 9.39531C15.0086 9.31911 15.0165 9.21887 14.9698 9.1356C14.923 9.05234 14.8294 9 14.7273 9L9.27273 9C9.17057 9 9.07697 9.05234 9.03023 9.1356C8.98348 9.21887 8.99142 9.31911 9.0508 9.39531L11.7781 12.8953C11.8293 12.961 11.9119 13 12 13C12.0881 13 12.1707 12.961 12.2219 12.8953L14.9492 9.39531Z" fill="white"/></svg>'
      },
      cursor: "pointer",
      visibleTime: "mouseenter_cell"
    };
  },
  get play() {
    return {
      type: "svg",
      svg: '<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="48" height="48" fill="white" fill-opacity="0.01" /><path d="M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z" fill="none" stroke="#686a6e" stroke-width="4" stroke-linejoin="round" stroke-opacity="0.7" /><path d="M20 24V17.0718L26 20.5359L32 24L26 27.4641L20 30.9282V24Z" fill="none" stroke="#686a6e" stroke-width="4" stroke-linejoin="round" stroke-opacity="0.7" /></svg>',
      width: 24,
      height: 24,
      funcType: IconFuncTypeEnum.play,
      positionType: IconPosition.right,
      name: "play",
      marginRight: 0,
      hover: {
        width: 24,
        height: 24,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get damage_pic() {
    return {
      type: "svg",
      svg: '<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 10V38C5 39.1046 5.89543 40 7 40H14H18L15 29L22 27L21 20L29 16L27 13L30 8H7C5.89543 8 5 8.89543 5 10Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M43 38V10C43 8.89543 42.1046 8 41 8H38L34 14L37 19L28 23L29 31L22 33L24 40H41C42.1046 40 43 39.1046 43 38Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 18C15.3284 18 16 17.3284 16 16.5C16 15.6716 15.3284 15 14.5 15C13.6716 15 13 15.6716 13 16.5C13 17.3284 13.6716 18 14.5 18Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      width: 24,
      height: 24,
      funcType: IconFuncTypeEnum.damagePic,
      positionType: IconPosition.left,
      name: "damage_pic",
      marginRight: 0,
      hover: {
        width: 24,
        height: 24,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get loading_pic() {
    return {
      type: "svg",
      svg: '<svg viewBox="0 0 400 300" fill="none" xmlns="http://www.w3.org/2000/svg"><mask id="a" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="50" y="65" width="301" height="170"><path d="M350.3 65H50v169.8h300.3V65Z" fill="#fff"/></mask><g mask="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M58.3 233.2h32.8v-36.8H58.3v36.8Z" fill="#C7DEFF"/><path d="M91.1 224.5v8.8H58.3M82.4 196.2H58.3" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M305.4 182.5s-2.7 12.6 0 17.4c2.7 4.8 8.3 6.7 12.4 4.4 4.2-2.4 5.3-8.1 2.6-12.9-2.7-4.8-15-8.9-15-8.9ZM336 204.7c4.3 2 9.7-.4 12-5.4 2.3-5-1.5-17.3-1.5-17.3s-11.8 5.1-14.1 10.1c-2.3 5-.7 10.6 3.6 12.6Z" fill="#00E4E5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M326.7 174s-10 11.8-10 18.6c0 6.7 4.5 12.2 10 12.2s10-5.5 10-12.3c0-6.8-10-18.5-10-18.5Z" fill="#00E4E5"/><path d="M332.3 181.5c2.3 3.6 4.4 7.8 4.4 10.9M316.7 192.5c0-3.1 2.1-7.2 4.3-10.8" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M343.1 227.3v-9.7h-34v9.7c0 3.7 3 6.6 6.6 6.6h20.9c3.6 0 6.5-2.9 6.5-6.6Z" fill="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M350.4 220.8V198H302v22.8c0 5.9 4.8 10.7 10.7 10.7h26.9c5.9 0 10.7-4.8 10.8-10.7Z" fill="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M331.7 74.2H117.8L87.4 203h213.8l30.5-128.8Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M337 74.2h-6.2l-30.6 129.2h6.2L337 74.2Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M303.8 203.5h2.4l30.7-129.3h-1.8l-31.3 129.3Z" fill="#C7DEFF"/><path d="m337 74.2-30.6 129.2h-5.9" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M229.9 202.1h-47.6l2 9.6h47.3l-1.7-9.6Z" fill="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M94.7 172.6 87.4 203h213.1l7.8-30.4H94.7Z" fill="#006EFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M94.7 172.6 87.4 203h213.1l7.8-30.4H94.7Z" fill="#006EFF"/><path d="M138.5 74.2h193.2l-23.4 98.6M94.5 172.7l11-46.3M104.8 155.4l-2.3 11.5h6.7M316 112.1l1.1-4.5" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M148.3 138.1h97V119h-97v19.1Z" fill="#00E4E5"/><path d="M303.1 80.6h20.3l-4.6 19.6M228.3 234.3c3.6 0 6.3-3.2 5.7-6.8l-4.1-24.1" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M226.2 229.5h-68.9v1.2c0 2 1.6 3.7 3.7 3.7h60.1c2.8 0 5-2.2 5.1-4.9Z" fill="#C7DEFF"/><path d="M180.699 226.8h-19.9c-2.8 0-4.6 3-3.3 5.5m0 0c.6 1.2 1.9 2 3.3 2h57.8M175.9 203.4l3.6 17.6M241.2 234.3h65.1M104.6 234.3h41.3" stroke="#071F4D"/><path d="M206.2 234.3h14.9c3.1 0 5.5-2.8 5-5.9l-4.3-24.9M160.7 226.8h46M62.2 226.1h-9.5c-1.2 0-2.2-1-2.2-2.2v-18.3c0-1.2 1-2.2 2.2-2.2h9.5" stroke="#071F4D"/><path d="M53.4 171.7H68c2.1 0 3.7 1.7 3.7 3.7v16.1M79.1 192v-21.8c0-2.5 2-4.6 4.6-4.6h2.2c2.5 0 4.5-2 4.5-4.5m0 0c0-2.5-2-4.5-4.5-4.5H56.1c-2.4 0-4.3-1.9-4.3-4.3V148M71.2 165.2h-18M64 181.7v10.1" stroke="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M85.7 120H124c4.3 0 7.7-3.5 7.7-7.7V65.5H94.2c-4.7 0-8.5 4.9-8.5 11V120Z" fill="#C7DEFF"/><path d="M85.7 110.7V73c0-4.1 3.4-7.5 7.5-7.5h38.5M146.2 73.8v-2.5c0-3.2-2-5.8-5.8-5.8-2.8 0-6 1.1-6 5.8v42.4c0 4.7-3.8 8.5-8.5 8.5h-15.6" stroke="#071F4D"/><path d="M119.7 122.3H87c-6.1 0-11.1-5-11.1-11.1m0 0h39M126.1 122.3c-6.1 0-11.1-5-11.1-11.1" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M85.4 122.1h37.2c-6.5-1.8-8-10.5-8-10.5H76.2c.6 8.8 9.2 10.5 9.2 10.5Z" fill="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M95.8 102.9h4.8V83.6h-4.8v19.3ZM106.6 102.9h4.8V77.6h-4.8v25.3ZM117.3 102.9h4.8V89.1h-4.8v13.8Z" fill="#fff"/><path d="M273.2 195.9h16.9M261.2 195.9h5" stroke="#fff"/><path d="M62.4 201.9v2.9M62.4 224.5v2.9" stroke="#071F4D"/><path d="m153.6 138.1 9.7-19.1M168.8 138.1l9.7-19.1M184.1 138.1l9.7-19.1M199.4 138.1l9.7-19.1M214.6 138.1l9.8-19.1M229.9 138.1l9.7-19.1" stroke="#fff"/><path d="M148.3 138.1h121.6V119H148.3v19.1Z" stroke="#071F4D"/></g></svg>',
      width: 400,
      height: 300,
      name: "loading_pic",
      positionType: IconPosition.left
    };
  },
  get expand() {
    return {
      type: "svg",
      svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
      <path d="M4.64988 6.81235C4.38797 6.48497 4.62106 6 5.04031 6L10.9597 6C11.3789 6 11.612 6.48497 11.3501 6.81235L8.39043 10.512C8.19027 10.7622 7.80973 10.7622 7.60957 10.512L4.64988 6.81235Z" fill="${expand_color}" fill-opacity="${expand_color_opacity}"/>
      </svg>`,
      width: expand_size,
      height: expand_size,
      funcType: IconFuncTypeEnum.expand,
      name: "expand",
      positionType: IconPosition.contentLeft,
      marginLeft: 0,
      marginRight: 4,
      hover: {
        width: expand_size_2,
        height: expand_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get collapse() {
    return {
      type: "svg",
      svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
      <path d="M5.81235 11.3501C5.48497 11.612 5 11.3789 5 10.9597L5 5.04031C5 4.62106 5.48497 4.38797 5.81235 4.64988L9.51196 7.60957C9.76216 7.80973 9.76216 8.19027 9.51196 8.39044L5.81235 11.3501Z"  fill="${collapse_color}" fill-opacity="${collapse_color_opacity}"/>
      </svg>`,
      width: collapse_size,
      height: collapse_size,
      funcType: IconFuncTypeEnum.collapse,
      name: "collapse",
      positionType: IconPosition.contentLeft,
      marginLeft: 0,
      marginRight: 4,
      hover: {
        width: collapse_size_2,
        height: collapse_size_2,
        bgColor: "rgba(101, 117, 168, 0.1)"
      },
      cursor: "pointer"
    };
  },
  get drillDown() {
    return {
      name: "drillDown",
      type: "svg",
      positionType: IconPosition.absolute,
      funcType: IconFuncTypeEnum.drillDown,
      svg: DrillDown,
      width: 13,
      height: 13,
      cursor: "pointer"
    };
  },
  get drillUp() {
    return {
      name: "drillUp",
      type: "svg",
      positionType: IconPosition.absolute,
      funcType: IconFuncTypeEnum.drillUp,
      svg: DrillUp,
      width: 13,
      height: 13,
      cursor: "pointer"
    };
  },
  get dragReorder() {
    return {
      type: "svg",
      svg: `<svg t="1710129136961" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5166" width="200" height="200"><path d="M362.666667 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5167"></path><path d="M661.333333 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5168"></path><path d="M362.666667 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5169"></path><path d="M661.333333 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5170"></path><path d="M362.666667 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5171"></path><path d="M661.333333 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5172"></path></svg>`,
      width: dragReorder_size,
      height: dragReorder_size,
      funcType: IconFuncTypeEnum.dragReorder,
      positionType: IconPosition.left,
      name: "dragReorder",
      marginLeft: -10,
      marginRight: 10,
      cursor: "grab"
    };
  }
};
var icons = {};
function get3() {
  return extend(builtins, icons);
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/group.js
var Group2 = class extends Group {
  clear() {
    this.removeAllChild();
  }
  getChildByName(name, deep) {
    let result2 = null;
    return this.forEachChildren((child) => child.name === name && (result2 = child, true)), deep && this.forEachChildren((child) => {
      if (child.getChildByName) {
        const target = child.getChildByName(name, true);
        if (target) return result2 = target, true;
      }
      return false;
    }), result2;
  }
  get width() {
    var _a;
    let width = this.AABBBounds.width();
    return width !== 1 / 0 && width !== -1 / 0 || (width = 0), Math.max(width, null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0);
  }
  get height() {
    var _a;
    let height = this.AABBBounds.height();
    return height !== 1 / 0 && height !== -1 / 0 || (height = 0), Math.max(height, null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0);
  }
  setDeltaWidth(deltaX) {
    var _a;
    0 !== deltaX && (this.setAttribute("width", (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + deltaX), this.border && (this.border.setAttribute("width", this.border.attribute.width + deltaX), "group" === this.border.type && this.border.firstChild.setAttribute("width", this.border.firstChild.attribute.width + deltaX)));
  }
  setDeltaHeight(deltaY) {
    var _a;
    0 !== deltaY && (this.setAttribute("height", (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + deltaY), this.border && (this.border.setAttribute("height", this.border.attribute.height + deltaY), "group" === this.border.type && this.border.firstChild.setAttribute("width", this.border.firstChild.attribute.height + deltaY)));
  }
  setDeltaX(deltaX) {
    0 !== deltaX && this.setAttribute("x", this.attribute.x + deltaX);
  }
  setDeltaY(deltaY) {
    0 !== deltaY && this.setAttribute("y", this.attribute.y + deltaY);
  }
  forEachChildrenSkipChild(cb, skipChildName = "border-rect", reverse = false) {
    if (reverse) {
      let child = this._lastChild, i = 0;
      for (; child; ) {
        if (child.name !== skipChildName) {
          if (cb(child, i++)) return;
        }
        child = child._prev;
      }
    } else {
      let child = this._firstChild, i = 0;
      for (; child; ) {
        if (child.name !== skipChildName) {
          if (cb(child, i++)) return;
        }
        child = child._next;
      }
    }
  }
  getColGroup(col) {
    let c2 = this._firstChild;
    if (!c2) return null;
    for (let i = 0; i < this.childrenCount; i++) {
      if (c2.col === col) return c2;
      c2 = c2._next;
    }
    return null;
  }
  getRowGroup(row) {
    let c2 = this._firstChild;
    if (!c2) return null;
    for (let i = 0; i < this.childrenCount; i++) {
      if (c2.row === row) return c2;
      c2 = c2._next;
    }
    return null;
  }
  addCellGroup(cellGroup) {
    if (0 === this.childrenCount || this.lastChild.row === cellGroup.row - 1) this.addChild(cellGroup);
    else {
      let c2 = this._firstChild;
      for (let i = 0; i < this.childrenCount; i++) {
        if (c2.row === cellGroup.row - 1) return void this.insertAfter(cellGroup, c2);
        c2 = c2._next;
      }
      this.addChild(cellGroup);
    }
  }
  getChildAt(index) {
    const child = super.getChildAt(index);
    return child && "border-rect" === child.name ? child._next : child;
  }
  tryUpdateAABBBounds() {
    if ("cell" === this.role) {
      if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
      const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
      return this.addUpdateLayoutTag(), after(this, selfChange), bounds;
    }
    return super.tryUpdateAABBBounds();
  }
  doUpdateAABBBounds() {
    if ("cell" === this.role) {
      const attribute = this.attribute, { x, y, width, height } = attribute;
      return this._AABBBounds.setValue(x, y, x + width, y + height), this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), this.shadowRoot && this.shadowRoot.tryUpdateAABBBounds(), this._AABBBounds;
    }
    return "body" === this.role || "row-header" === this.role || "col-header" === this.role || "right-frozen" === this.role || "bottom-frozen" === this.role || "corner-header" === this.role || "corner-right-top-header" === this.role || "corner-right-bottom-header" === this.role || "corner-left-bottom-header" === this.role ? (this._AABBBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), this.shadowRoot && this.shadowRoot.tryUpdateAABBBounds(), this._AABBBounds) : super.doUpdateAABBBounds();
  }
  updateColumnRowNumber(row) {
    this.rowNumber ? this.rowNumber = Math.max(this.rowNumber, row) : this.rowNumber = row;
  }
  updateColumnHeight(cellHeight) {
    this.colHeight ? this.colHeight += cellHeight : this.colHeight = cellHeight;
  }
};
function after(group, selfChange) {
  group.stage && group.stage.dirtyBounds && group.stage.renderCount && (group.isContainer && !selfChange || group.stage.dirty(group.globalAABBBounds));
}

// node_modules/@visactor/vtable/es/scenegraph/utils/keep-aspect-ratio.js
function calcKeepAspectRatioSize(width, height, maxWidth, maxHeight) {
  const rectRatio = width / height;
  let newWidth, newHeight, offsetX, offsetY;
  return rectRatio > maxWidth / maxHeight ? (newWidth = maxWidth, newHeight = newWidth / rectRatio, offsetX = 0, offsetY = (maxHeight - newHeight) / 2) : (newHeight = maxHeight, newWidth = newHeight * rectRatio, offsetY = 0, offsetX = (maxWidth - newWidth) / 2), {
    width: newWidth,
    height: newHeight
  };
}

// node_modules/@visactor/vtable/es/scenegraph/utils/cell-pos.js
function calcStartPosition(left, top, width, height, contentWidth, contentHeight, textAlign = "left", textBaseline = "middle", margin = [0, 0, 0, 0], paddingLeft = 0, paddingRight = 0, paddingTop = 0, paddingBottom = 0) {
  const right = left + width, bottom = top + height;
  let x = left + margin[3] + paddingLeft;
  "right" === textAlign || "end" === textAlign ? x = right - contentWidth - margin[1] - paddingRight : "center" === textAlign && (x = left + (width - contentWidth + paddingLeft - paddingRight) / 2);
  let y = top + margin[0] + paddingTop;
  return "bottom" === textBaseline || "alphabetic" === textBaseline || "ideographic" === textBaseline ? y = bottom - contentHeight - margin[2] - paddingBottom : "middle" === textBaseline && (y = top + (height - contentHeight + paddingTop - paddingBottom) / 2), {
    x,
    y
  };
}

// node_modules/@visactor/vtable/es/scenegraph/utils/get-prop.js
function getProp2(name, cellStyle, col, row, _table) {
  const prop = cellStyle && isValid_default(cellStyle[name]) ? cellStyle[name] : void 0;
  if ("function" == typeof prop) {
    return prop({
      col,
      row,
      table: _table,
      value: _table.getCellValue(col, row),
      dataValue: _table.getCellOriginValue(col, row),
      cellHeaderPaths: _table.getCellHeaderPaths(col, row)
    });
  }
  return prop;
}
function getFunctionalProp(name, cellStyle, col, row, _table) {
  const prop = cellStyle && isValid_default(cellStyle[name]) ? cellStyle[name] : void 0;
  if ("function" == typeof prop) {
    return prop({
      col,
      row,
      table: _table,
      value: _table.getCellValue(col, row),
      dataValue: _table.getCellOriginValue(col, row),
      cellHeaderPaths: _table.getCellHeaderPaths(col, row)
    });
  }
}

// node_modules/@visactor/vtable/es/scenegraph/utils/cell-border-stroke-width.js
function getCellBorderStrokeWidth(col, row, cellTheme, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  let strokeArrayWidth = null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.strokeArrayWidth) && void 0 !== _b ? _b : void 0;
  return table.theme.cellInnerBorder || !isValidStyle(table.theme.frameStyle.borderLineWidth) || isZeroStyle(table.theme.frameStyle.borderLineWidth) || (0 === col && (strokeArrayWidth = null != strokeArrayWidth ? strokeArrayWidth : [null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.lineWidth, null === (_d = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _d ? void 0 : _d.lineWidth, null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.lineWidth, null === (_f = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _f ? void 0 : _f.lineWidth], strokeArrayWidth[3] = 0), col === table.colCount - 1 && (strokeArrayWidth = null != strokeArrayWidth ? strokeArrayWidth : [null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth, null === (_h = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _h ? void 0 : _h.lineWidth, null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.lineWidth, null === (_k = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _k ? void 0 : _k.lineWidth], strokeArrayWidth[1] = 0), 0 === row && (strokeArrayWidth = null != strokeArrayWidth ? strokeArrayWidth : [null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineWidth, null === (_m = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _m ? void 0 : _m.lineWidth, null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth, null === (_p = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _p ? void 0 : _p.lineWidth], strokeArrayWidth[0] = 0), row === table.rowCount - 1 && (strokeArrayWidth = null != strokeArrayWidth ? strokeArrayWidth : [null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.lineWidth, null === (_r = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _r ? void 0 : _r.lineWidth, null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineWidth, null === (_t = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _t ? void 0 : _t.lineWidth], strokeArrayWidth[2] = 0)), strokeArrayWidth;
}

// node_modules/@visactor/vtable/es/scenegraph/component/cell-content.js
var CellContent = class extends Group2 {
  constructor(params2) {
    super(params2), this._autoWidth = false, this._autoHeight = false, this._leftGroup = new Group2({
      pickable: false,
      fill: false,
      stroke: false
    }), this._leftGroup.role = "content-left", this._rightGroup = new Group2({
      pickable: false,
      fill: false,
      stroke: false
    }), this._rightGroup.role = "content-right", this._centerGroup = new Group2({
      pickable: false,
      fill: false,
      stroke: false
    }), this._centerGroup.role = "content-center", this.appendChild(this._leftGroup), this.appendChild(this._rightGroup), this.appendChild(this._centerGroup);
  }
  setCellContentOption(option) {
    this._autoWidth = option.autoWidth, this._autoHeight = option.autoHeight, this._cellWidth = option.cellWidth, this._originCellWidth = option.cellWidth, this._cellHeight = option.cellHeight, this._align = option.align, this._baseline = option.baseline;
  }
  addLeftOccupyingIcon(icon2) {
    var _a, _b, _c;
    icon2.setAttribute("x", this._leftGroup.width + (null !== (_a = icon2.attribute.marginLeft) && void 0 !== _a ? _a : 0)), this._leftGroup.appendChild(icon2), this._leftGroup.setDeltaWidth((null !== (_b = icon2.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = icon2.attribute.marginRight) && void 0 !== _c ? _c : 0) + icon2.attribute.width);
  }
  addRightOccupyingIcon(icon2) {
    var _a, _b, _c;
    icon2.setAttribute("x", this._rightGroup.width + (null !== (_a = icon2.attribute.marginLeft) && void 0 !== _a ? _a : 0)), this._rightGroup.appendChild(icon2), this._rightGroup.setDeltaWidth((null !== (_b = icon2.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = icon2.attribute.marginRight) && void 0 !== _c ? _c : 0) + icon2.attribute.width);
  }
  addContent(content) {
    const lastChild = this._centerGroup.lastChild;
    lastChild && content.setAttributes({
      x: lastChild.attribute.x + lastChild.AABBBounds.width()
    }), this._centerGroup.appendChild(content), content instanceof Text && (this._centerGroup.setAttribute("pickable", false), content.setAttribute("textAlign", "left"));
  }
  layout() {
    let leftOccupyingWidth = this._leftGroup.width;
    leftOccupyingWidth === 1 / 0 && (leftOccupyingWidth = 0);
    let rightOccupyingWidth = this._rightGroup.width;
    if (rightOccupyingWidth === -1 / 0 && (rightOccupyingWidth = 0), this._autoWidth) {
      const centerWidth = this._centerGroup.width;
      this._cellWidth = leftOccupyingWidth + rightOccupyingWidth + centerWidth, this.setAttribute("width", this._cellWidth);
    } else {
      const contentWidth = this._cellWidth - leftOccupyingWidth - rightOccupyingWidth;
      this.updateCenterLayout(contentWidth);
      const centerWidth = this._centerGroup.width;
      this._cellWidth = leftOccupyingWidth + rightOccupyingWidth + centerWidth, this.setAttribute("width", this._cellWidth);
    }
    this.updateHorizontalPos();
    const leftOccupyingHeight = this._leftGroup.height, rightOccupyingHeight = this._rightGroup.height, centerHeight = this._centerGroup.height;
    this._cellHeight = Math.max(leftOccupyingHeight, rightOccupyingHeight, centerHeight), this.setAttribute("height", this._cellHeight), this.updateVerticalPos();
  }
  updateCenterLayout(contentWidth) {
    let textWidth = contentWidth;
    this._centerGroup.forEachChildren((child) => {
      (child instanceof Icon || child instanceof TextIcon) && (textWidth -= child.AABBBounds.width());
    });
    const text2 = this._centerGroup.getChildByName("text");
    text2 instanceof RichText ? text2.setAttribute("width", textWidth) : text2 instanceof Text && text2.setAttribute("maxLineWidth", textWidth);
    let x = 0;
    this._centerGroup.forEachChildren((child) => {
      child.setAttribute("x", x), x += child.AABBBounds.width();
    });
  }
  updateHorizontalPos() {
    this._leftGroup.setAttribute("x", 0), this._rightGroup.setAttribute("x", this._cellWidth - this._rightGroup.width), this._centerGroup.setAttribute("x", this._leftGroup.width), "left" === this._align || "start" === this._align ? this.setAttribute("dx", 0) : "center" === this._align ? this.setAttribute("dx", -this.attribute.width / 2) : "right" !== this._align && "end" !== this._align || this.setAttribute("dx", -this.attribute.width);
  }
  updateVerticalPos() {
    "top" === this._baseline ? (this._leftGroup.setAttribute("y", 0), this._rightGroup.setAttribute("y", 0), this._centerGroup.setAttribute("y", 0)) : "middle" === this._baseline ? (this._leftGroup.forEachChildren((icon2) => {
      icon2.setAttribute("y", (this._leftGroup.height - icon2.AABBBounds.height()) / 2);
    }), this._rightGroup.forEachChildren((icon2) => {
      icon2.setAttribute("y", (this._rightGroup.height - icon2.AABBBounds.height()) / 2);
    }), this._leftGroup.setAttribute("y", this._cellHeight / 2 - this._leftGroup.height / 2), this._rightGroup.setAttribute("y", this._cellHeight / 2 - this._rightGroup.height / 2), this._centerGroup.setAttribute("y", this._cellHeight / 2 - this._centerGroup.height / 2)) : "bottom" === this._baseline && (this._leftGroup.forEachChildren((icon2) => {
      icon2.setAttribute("y", this._leftGroup.height - icon2.AABBBounds.height());
    }), this._rightGroup.forEachChildren((icon2) => {
      icon2.setAttribute("y", this._rightGroup.height - icon2.AABBBounds.height());
    }), this._leftGroup.setAttribute("y", this._cellHeight - this._leftGroup.height), this._rightGroup.setAttribute("y", this._cellHeight - this._rightGroup.height), this._centerGroup.setAttribute("y", this._cellHeight - this._centerGroup.height));
  }
  updateWidth(width) {
    this._cellWidth = width, this._originCellWidth = width, this.layout();
  }
  updateHeight(height) {
    this._cellHeight = height, this._cellWidth = this._originCellWidth;
    const textMark = this.getChildByName("text", true);
    textMark && textMark.setAttribute("heightLimit", height), this.layout();
  }
};

// node_modules/@visactor/vtable/es/scenegraph/utils/get-hierarchy-offset.js
function getHierarchyOffset(col, row, table) {
  var _a, _b, _c, _d, _e;
  let cellHierarchyIndent = 0;
  const layoutMap = table.internalProps.layoutMap;
  if (layoutMap.isHeader(col, row)) {
    const hd = layoutMap.getHeader(col, row);
    isValid_default(null == hd ? void 0 : hd.hierarchyLevel) && (cellHierarchyIndent = (null !== (_a = hd.hierarchyLevel) && void 0 !== _a ? _a : 0) * ("tree" === layoutMap.rowHierarchyType && null !== (_b = layoutMap.rowHierarchyIndent) && void 0 !== _b ? _b : 0), layoutMap.rowHierarchyTextStartAlignment && !table.internalProps.headerHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth()));
  } else if (table.options.groupBy || (null === (_c = table.getBodyColumnDefine(col, row)) || void 0 === _c ? void 0 : _c.tree)) {
    const indexArr = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row)), groupLength = null !== (_d = table.dataSource.getGroupLength()) && void 0 !== _d ? _d : 0;
    let indexArrLngth = isArray_default(indexArr) ? indexArr.length - 1 : 0;
    groupLength > 0 && indexArrLngth === groupLength && (indexArrLngth = 0), cellHierarchyIndent = Array.isArray(indexArr) && table.getHierarchyState(col, row) !== HierarchyState.none ? indexArrLngth * (null !== (_e = layoutMap.hierarchyIndent) && void 0 !== _e ? _e : 0) : 0, layoutMap.hierarchyTextStartAlignment && !table.internalProps.bodyHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.bodyHelper.getHierarchyIconWidth());
  }
  return cellHierarchyIndent;
}

// node_modules/@visactor/vtable/es/scenegraph/utils/break-string.js
function breakString(textStr, table) {
  var _a, _b;
  let text2, moreThanMaxCharacters = false;
  for (isString_default(textStr) && textStr.length > (table.options.maxCharactersNumber || 200) && (textStr = textStr.slice(0, table.options.maxCharactersNumber || 200), textStr += "…", moreThanMaxCharacters = true), text2 = table.internalProps.enableLineBreak || (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.multilinesForXTable) ? convertInternal(textStr).replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n") || [] : [convertInternal(textStr)]; text2.length && text2.length > 1 && !text2[text2.length - 1]; ) text2.pop();
  if ((null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.multilinesForXTable) && !table.internalProps.autoWrapText) for (; text2.length && text2.length > 1 && !text2[0]; ) text2.shift();
  return {
    text: text2,
    moreThanMaxCharacters
  };
}

// node_modules/@visactor/vtable/es/scenegraph/utils/text-icon-layout.js
function createCellContent(cellGroup, icons2, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, lineClamp, cellWidth, cellHeight, textAlign, textBaseline, table, cellTheme, range5) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  let contentWidth, contentHeight, leftIconWidth = 0, rightIconWidth = 0, absoluteRightIconWidth = 0;
  if (Array.isArray(icons2) && 0 !== icons2.length) {
    const { inlineFrontIcons, inlineEndIcons, contentLeftIcons, contentRightIcons, leftIconWidth: layoutLeftIconWidth, rightIconWidth: layoutRightIconWidth, absoluteRightIconWidth: layoutAbsoluteRightIconWidth } = dealWithIconLayout(icons2, cellGroup, range5, table);
    let textMark;
    if (leftIconWidth = layoutLeftIconWidth, rightIconWidth = layoutRightIconWidth, absoluteRightIconWidth = layoutAbsoluteRightIconWidth, 0 === inlineFrontIcons.length && 0 === inlineEndIcons.length) {
      let _contentOffset = 0;
      isNumber_default(table.theme._contentOffset) && ("left" === textAlign ? _contentOffset = table.theme._contentOffset : "right" === textAlign && (_contentOffset = -table.theme._contentOffset));
      const hierarchyOffset = range5 ? getHierarchyOffset(range5.start.col, range5.start.row, table) : getHierarchyOffset(cellGroup.col, cellGroup.row, table), { text: text2, moreThanMaxCharacters } = breakString(textStr, table), attribute = {
        text: 1 === text2.length ? text2[0] : text2,
        moreThanMaxCharacters,
        maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth - hierarchyOffset,
        textBaseline: "top",
        heightLimit: false === (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.limitContentHeight) || autoRowHeight && !(null === (_e = table.options.customConfig) || void 0 === _e ? void 0 : _e.multilinesForXTable) ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
        pickable: false,
        autoWrapText,
        lineClamp,
        wordBreak: "break-word",
        whiteSpace: false === (null === (_f = table.options.customConfig) || void 0 === _f ? void 0 : _f.limitContentHeight) || 1 !== text2.length || autoWrapText ? "normal" : "no-wrap",
        dx: ("left" === textAlign ? contentLeftIcons.length ? 0 : hierarchyOffset : 0) + _contentOffset,
        keepCenterInLine: true
      }, wrapText = new Text(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
      wrapText.name = "text", textMark = wrapText;
    } else {
      const textOption = Object.assign({
        text: null == textStr ? void 0 : textStr.toString()
      }, (null === (_j = null === (_h = null === (_g = cellGroup.parent) || void 0 === _g ? void 0 : _g.theme) || void 0 === _h ? void 0 : _h.userTheme) || void 0 === _j ? void 0 : _j.text) || {});
      cellTheme.text && Object.assign(textOption, cellTheme.text), textOption.textBaseline = "middle";
      const textConfig = [...inlineFrontIcons.map((icon2) => dealWithRichTextIcon(icon2)), textOption, ...inlineEndIcons.map((icon2) => dealWithRichTextIcon(icon2))];
      textConfig[0].textAlign = textAlign;
      const text2 = new RichText({
        width: autoColWidth ? 0 : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
        height: autoRowHeight && autoWrapText ? 0 : Math.ceil(cellHeight - (padding[0] + padding[2])),
        textConfig,
        verticalDirection: autoRowHeight && autoWrapText ? "top" : textBaseline,
        ellipsis: textOption.ellipsis
      });
      text2.name = "text", textMark = text2, text2.bindIconEvent(), !range5 || range5.start.col === range5.end.col && range5.start.row === range5.end.row || (text2.onBeforeAttributeUpdate = onBeforeAttributeUpdate2);
    }
    if (0 !== contentLeftIcons.length || 0 !== contentRightIcons.length) {
      const cellContent = new CellContent({
        x: 0,
        y: 0,
        fill: false,
        stroke: false,
        pickable: false
      });
      cellContent.name = "content", cellContent.setCellContentOption({
        autoWidth: autoColWidth,
        autoHeight: autoRowHeight,
        cellWidth: cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
        cellHeight: cellHeight - (padding[0] + padding[2]),
        align: textAlign,
        baseline: textBaseline
      });
      const dealWithIconComputeVar = {
        addedHierarchyOffset: 0
      };
      contentLeftIcons.forEach((icon2) => {
        const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table, dealWithIconComputeVar);
        iconMark.role = "icon-content-left", iconMark.name = icon2.name, cellContent.addLeftOccupyingIcon(iconMark);
      }), contentRightIcons.forEach((icon2) => {
        const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table, dealWithIconComputeVar);
        iconMark.role = "icon-content-right", iconMark.name = icon2.name, cellContent.addRightOccupyingIcon(iconMark);
      }), cellContent.addContent(textMark), cellGroup.appendChild(cellContent), cellContent.layout(), contentWidth = cellContent.AABBBounds.width(), contentHeight = cellContent.AABBBounds.height();
    } else cellGroup.firstChild ? cellGroup.insertBefore(textMark, cellGroup.firstChild) : cellGroup.appendChild(textMark), contentWidth = textMark.AABBBounds.width(), contentHeight = textMark.AABBBounds.height();
  } else if (isValid_default(textStr)) {
    const { text: text2, moreThanMaxCharacters } = breakString(textStr, table), hierarchyOffset = range5 ? getHierarchyOffset(range5.start.col, range5.start.row, table) : getHierarchyOffset(cellGroup.col, cellGroup.row, table);
    let _contentOffset = 0;
    isNumber_default(table.theme._contentOffset) && ("left" === textAlign ? _contentOffset = table.theme._contentOffset : "right" === textAlign && (_contentOffset = -table.theme._contentOffset));
    const attribute = {
      text: 1 === text2.length ? text2[0] : text2,
      moreThanMaxCharacters,
      maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
      textBaseline: "top",
      autoWrapText,
      lineClamp,
      wordBreak: "break-word",
      heightLimit: false === (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.limitContentHeight) || autoRowHeight && !(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.multilinesForXTable) ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
      pickable: false,
      dx: ("left" === textAlign ? hierarchyOffset : 0) + _contentOffset,
      whiteSpace: false === (null === (_c = table.options.customConfig) || void 0 === _c ? void 0 : _c.limitContentHeight) || 1 !== text2.length || autoWrapText ? "normal" : "no-wrap",
      keepCenterInLine: true
    }, wrapText = new Text(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
    wrapText.name = "text", wrapText.textBaseline = textBaseline, cellGroup.appendChild(wrapText), contentWidth = wrapText.AABBBounds.width(), contentHeight = wrapText.AABBBounds.height();
  }
  const width = autoColWidth ? leftIconWidth + contentWidth + rightIconWidth : cellWidth - (padding[1] + padding[3]), height = cellHeight - (padding[0] + padding[2]);
  cellGroup.forEachChildren((child) => {
    "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth + padding[3]) : "icon-absolute-right" === child.role ? child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth + padding[3] + padding[1]) : "content" !== child.name && "text" !== child.name || ("center" === textAlign && "richtext" !== child.type ? child.setAttribute("x", padding[3] + leftIconWidth + (width - leftIconWidth - rightIconWidth) / 2) : "right" === textAlign && "richtext" !== child.type ? child.setAttribute("x", padding[3] + width - rightIconWidth) : child.setAttribute("x", padding[3] + leftIconWidth));
  }), cellGroup.forEachChildren((child) => {
    child.name !== CUSTOM_CONTAINER_NAME && ("middle" === textBaseline ? child.setAttribute("y", padding[0] + (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + height - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
  }), cellGroup.setAttributes({
    width: width + padding[1] + padding[3],
    height: height + padding[0] + padding[2]
  });
}
function dealWithIcon(icon2, mark, col, row, range5, table, dealWithIconComputeVar) {
  var _a, _b, _c, _d, _e, _f;
  const iconAttribute = {};
  "image" === icon2.type ? icon2.isGif ? (iconAttribute.gif = icon2.src, iconAttribute.image = icon2.src) : iconAttribute.image = icon2.src : ("svg" === icon2.type || "svg" in icon2) && (iconAttribute.image = icon2.svg), iconAttribute.width = icon2.width, iconAttribute.height = icon2.height, iconAttribute.visibleTime = null !== (_a = icon2.visibleTime) && void 0 !== _a ? _a : "always", iconAttribute.funcType = icon2.funcType, iconAttribute.interactive = icon2.interactive, iconAttribute.isGif = icon2.isGif;
  let iconMark, hierarchyOffset = 0;
  return dealWithIconComputeVar && 0 !== (null == dealWithIconComputeVar ? void 0 : dealWithIconComputeVar.addedHierarchyOffset) || !isNumber_default(col) || !isNumber_default(row) || !table || icon2.funcType !== IconFuncTypeEnum.collapse && icon2.funcType !== IconFuncTypeEnum.expand && icon2.positionType !== IconPosition.contentLeft && icon2.positionType !== IconPosition.contentRight || (hierarchyOffset = range5 ? getHierarchyOffset(range5.start.col, range5.start.row, table) : getHierarchyOffset(col, row, table), dealWithIconComputeVar && (dealWithIconComputeVar.addedHierarchyOffset = 1)), iconAttribute.marginLeft = (null !== (_b = icon2.marginLeft) && void 0 !== _b ? _b : 0) + hierarchyOffset, iconAttribute.marginRight = null !== (_c = icon2.marginRight) && void 0 !== _c ? _c : 0, false === icon2.interactive && (iconAttribute.pickable = false), icon2.hover && (iconAttribute.backgroundWidth = null !== (_d = icon2.hover.width) && void 0 !== _d ? _d : icon2.width, iconAttribute.backgroundHeight = null !== (_e = icon2.hover.width) && void 0 !== _e ? _e : icon2.width, iconAttribute.backgroundColor = null !== (_f = icon2.hover.bgColor) && void 0 !== _f ? _f : "rgba(22,44,66,0.2)", iconAttribute.hoverImage = icon2.hover.image), icon2.cursor && (iconAttribute.cursor = icon2.cursor), "shape" in icon2 && "circle" === icon2.shape && (iconAttribute.shape = icon2.shape), mark ? (mark.setAttributes(iconAttribute), mark.loadImage(iconAttribute.image), mark.tooltip = icon2.tooltip, mark.name = icon2.name, mark) : ("text" === icon2.type ? (iconAttribute.text = icon2.content, merge(iconAttribute, icon2.style), iconMark = new TextIcon(iconAttribute), iconMark.tooltip = icon2.tooltip, iconMark.name = icon2.name) : (iconMark = new Icon(iconAttribute), iconMark.tooltip = icon2.tooltip, iconMark.name = icon2.name), iconMark);
}
function dealWithRichTextIcon(icon2) {
  var _a, _b, _c, _d, _e, _f;
  const config = {};
  return "image" === icon2.type ? config.image = icon2.src : ("svg" === icon2.type || "svg" in icon2) && (config.image = icon2.svg), config.visibleTime = null !== (_a = icon2.visibleTime) && void 0 !== _a ? _a : "always", config.funcType = icon2.funcType, config.id = icon2.name, config.width = icon2.width, config.height = icon2.height, (icon2.marginRight || icon2.marginLeft) && (config.margin = [0, null !== (_b = icon2.marginRight) && void 0 !== _b ? _b : 0, 0, null !== (_c = icon2.marginLeft) && void 0 !== _c ? _c : 0]), icon2.hover && (config.backgroundWidth = null !== (_d = icon2.hover.width) && void 0 !== _d ? _d : icon2.width, config.backgroundHeight = null !== (_e = icon2.hover.height) && void 0 !== _e ? _e : icon2.height, config.backgroundShowMode = "hover", config.hoverImage = icon2.hover.image, config.backgroundStroke = false, config.backgroundFill = null !== (_f = icon2.hover.bgColor) && void 0 !== _f ? _f : "rgba(22,44,66,0.2)"), icon2.cursor && (config.cursor = icon2.cursor), config.tooltip = icon2.tooltip, config;
}
function updateCellContentWidth(cellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding, textAlign, textBaseline, scene) {
  var _a, _b, _c, _d;
  isValidNumber_default(cellGroup.contentWidth) && (detaX = distWidth - (null !== (_a = cellGroup.contentWidth) && void 0 !== _a ? _a : cellGroup.attribute.width));
  let oldTextHeight, leftIconWidth = 0, leftIconHeight = 0, rightIconWidth = 0, rightIconHeight = 0;
  cellGroup.forEachChildren((iconMark) => {
    var _a2, _b2, _c2, _d2;
    "icon-left" === iconMark.role ? (leftIconWidth += iconMark.AABBBounds.width() + (null !== (_a2 = iconMark.attribute.marginLeft) && void 0 !== _a2 ? _a2 : 0) + (null !== (_b2 = iconMark.attribute.marginRight) && void 0 !== _b2 ? _b2 : 0), leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height())) : "icon-right" === iconMark.role && (rightIconWidth += iconMark.AABBBounds.width() + (null !== (_c2 = iconMark.attribute.marginLeft) && void 0 !== _c2 ? _c2 : 0) + (null !== (_d2 = iconMark.attribute.marginRight) && void 0 !== _d2 ? _d2 : 0), rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height()));
  });
  const textMark = cellGroup.getChildByName("text"), cellContent = cellGroup.getChildByName("content");
  let contentHeight;
  textMark instanceof Text ? (oldTextHeight = textMark.AABBBounds.height(), textMark.setAttribute("maxLineWidth", distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3]) - (null !== (_b = textMark.attribute.dx) && void 0 !== _b ? _b : 0) - (null !== (_c = scene.table.theme._contentOffset) && void 0 !== _c ? _c : 0)), contentHeight = textMark.AABBBounds.height()) : textMark instanceof RichText ? (oldTextHeight = textMark.AABBBounds.height(), textMark.setAttribute("width", distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3])), contentHeight = textMark.AABBBounds.height()) : cellContent && (oldTextHeight = cellContent.AABBBounds.height(), cellContent.updateWidth(distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3])), contentHeight = cellContent.AABBBounds.height());
  const oldCellHeight = Math.round(Math.max(leftIconHeight, rightIconHeight, oldTextHeight) + padding[0] + padding[2]);
  if (cellGroup.forEachChildren((child) => {
    var _a2;
    if ("icon-left" === child.role) ;
    else if ("icon-right" === child.role) child.setAttribute("x", child.attribute.x + detaX);
    else if ("icon-absolute-right" === child.role) child.setAttribute("x", child.attribute.x + detaX);
    else if ("content" === child.name || "text" === child.name && "richtext" !== child.type) {
      const childTextAlign = null !== (_a2 = child.attribute.textAlign) && void 0 !== _a2 ? _a2 : textAlign;
      "center" === childTextAlign ? child.setAttribute("x", padding[3] + leftIconWidth + (distWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth) / 2) : "right" === childTextAlign && child.setAttribute("x", padding[3] + distWidth - (padding[1] + padding[3]) - rightIconWidth);
    } else "mark" === child.name && child.setAttribute("x", cellGroup.attribute.width);
  }), autoRowHeight) {
    let newHeight = Math.max(leftIconHeight, contentHeight, rightIconHeight);
    if (isCellHeightUpdate(scene, cellGroup, Math.round(newHeight + padding[0] + padding[2]), oldCellHeight)) return true;
    newHeight = (null !== (_d = cellGroup.contentHeight) && void 0 !== _d ? _d : cellHeight) - (padding[0] + padding[2]), cellGroup.forEachChildren((child) => {
      "rect" !== child.type && "chart" !== child.type && child.name !== CUSTOM_CONTAINER_NAME && ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", padding[0] + (newHeight - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + newHeight - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
    });
  } else "middle" !== textBaseline && "bottom" !== textBaseline || cellGroup.forEachChildren((child) => {
    "rect" !== child.type && "chart" !== child.type && child.name !== CUSTOM_CONTAINER_NAME && ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", (cellHeight - padding[2] + padding[0] - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", cellHeight - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]));
  });
  return false;
}
function updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, textAlign, textBaseline, table) {
  var _a;
  const newHeight = distHeight - Math.floor(padding[0] + padding[2]), textMark = cellGroup.getChildByName("text");
  if (textMark instanceof Text && !autoRowHeight) textMark.setAttributes({
    heightLimit: false === (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.limitContentHeight) ? -1 : newHeight
  });
  else if (textMark instanceof RichText && !autoRowHeight) textMark.setAttributes({
    height: newHeight
  });
  else if (cellGroup.getChildByName("content")) {
    cellGroup.getChildByName("content").updateHeight(newHeight);
  }
  cellGroup.forEachChildren((child) => {
    child.setAttribute("dy", 0), "rect" === child.type || "chart" === child.type || child.name === CUSTOM_CONTAINER_NAME || ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", padding[0] + (newHeight - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + newHeight - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
  });
}
function isCellHeightUpdate(scene, cellGroup, newHeight, oldHeight) {
  const table = scene.table, mergeInfo = getCellMergeInfo(table, cellGroup.col, cellGroup.row);
  if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) {
    oldHeight /= mergeInfo.end.row - mergeInfo.start.row + 1, newHeight /= mergeInfo.end.row - mergeInfo.start.row + 1;
    for (let rowIndex = mergeInfo.start.row; rowIndex <= mergeInfo.end.row; rowIndex++) {
      const rowHeight = table.getRowHeight(rowIndex);
      if (rowHeight === oldHeight && newHeight !== rowHeight) return true;
      if (newHeight > rowHeight) return true;
    }
  } else {
    const rowHeight = table.getRowHeight(cellGroup.row);
    if (rowHeight === oldHeight && newHeight !== rowHeight) return true;
    if (newHeight > rowHeight) return true;
  }
  return false;
}
function dealWithIconLayout(icons2, cellGroup, range5, table) {
  const leftIcons = [], rightIcons = [], contentLeftIcons = [], contentRightIcons = [], inlineFrontIcons = [], inlineEndIcons = [], absoluteLeftIcons = [], absoluteRightIcons = [];
  let leftIconWidth = 0, leftIconHeight = 0, rightIconWidth = 0, rightIconHeight = 0, absoluteLeftIconWidth = 0, absoluteRightIconWidth = 0;
  return icons2.forEach((icon2) => {
    switch (icon2.positionType) {
      case IconPosition.left:
        leftIcons.push(icon2);
        break;
      case IconPosition.right:
        rightIcons.push(icon2);
        break;
      case IconPosition.contentLeft:
        contentLeftIcons.push(icon2);
        break;
      case IconPosition.contentRight:
        contentRightIcons.push(icon2);
        break;
      case IconPosition.absoluteRight:
        absoluteRightIcons.push(icon2);
        break;
      case IconPosition.inlineFront:
        inlineFrontIcons.push(icon2);
        break;
      case IconPosition.inlineEnd:
        inlineEndIcons.push(icon2);
    }
  }), leftIcons.forEach((icon2) => {
    var _a, _b, _c;
    const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table);
    iconMark.role = "icon-left", iconMark.name = icon2.name, iconMark.setAttribute("x", leftIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), leftIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height()), cellGroup.appendChild(iconMark);
  }), rightIcons.forEach((icon2) => {
    var _a, _b, _c;
    const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table);
    iconMark.role = "icon-right", iconMark.name = icon2.name, iconMark.setAttribute("x", rightIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), rightIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height()), cellGroup.appendChild(iconMark);
  }), absoluteLeftIcons.forEach((icon2) => {
    var _a, _b, _c;
    const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table);
    iconMark.role = "icon-absolute-left", iconMark.name = icon2.name, iconMark.setAttribute("x", absoluteLeftIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), absoluteLeftIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), cellGroup.appendChild(iconMark);
  }), absoluteRightIcons.forEach((icon2) => {
    var _a, _b, _c;
    const iconMark = dealWithIcon(icon2, void 0, cellGroup.col, cellGroup.row, range5, table);
    iconMark.role = "icon-absolute-right", iconMark.name = icon2.name, iconMark.setAttribute("x", absoluteRightIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), absoluteRightIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), cellGroup.appendChild(iconMark);
  }), {
    leftIcons,
    rightIcons,
    contentLeftIcons,
    contentRightIcons,
    inlineFrontIcons,
    inlineEndIcons,
    absoluteLeftIcons,
    absoluteRightIcons,
    leftIconWidth,
    leftIconHeight,
    rightIconWidth,
    rightIconHeight,
    absoluteLeftIconWidth,
    absoluteRightIconWidth
  };
}
function onBeforeAttributeUpdate2(val, attribute) {
  if (val.hasOwnProperty("hoverIconId")) {
    const graphic = this;
    if (graphic.skipMergeUpdate) return;
    const cellGroup = getTargetCell(graphic);
    if (!cellGroup || !cellGroup.stage) return;
    const table = cellGroup.stage.table;
    graphic.skipAttributeUpdate = true;
    const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow } = cellGroup;
    if (isValid_default(mergeStartCol) && isValid_default(mergeEndCol) && isValid_default(mergeStartRow) && isValid_default(mergeEndRow) && (mergeStartCol !== mergeEndCol || mergeStartRow !== mergeEndRow)) {
      for (let col = mergeStartCol; col <= mergeEndCol; col++) for (let row = mergeStartRow; row <= mergeEndRow; row++) {
        if (col === cellGroup.col && row === cellGroup.row) {
          if (val.hoverIconId !== graphic.attribute.hoverIconId) {
            const icon2 = graphic._frameCache.icons.get(val.hoverIconId);
            graphic.updateHoverIconState(icon2);
          }
          continue;
        }
        const cell = table.scenegraph.highPerformanceGetCell(col, row);
        if ("cell" === cell.role) {
          const target = cell.getChildByName(graphic.name, true);
          if (!target || target.skipAttributeUpdate) continue;
          val.hoverIconId !== target.attribute.hoverIconId && (target.setAttribute("hoverIconId", val.hoverIconId), cell.addUpdateBoundTag());
        }
      }
      graphic.skipAttributeUpdate = void 0;
    }
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/image-cell.js
function createImageCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
  const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
  (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.imageMargin) ? padding = getQuadProps(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.imageMargin) : isValid_default(functionalPadding) && (padding = functionalPadding), (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textAlign) && (textAlign = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textAlign), (null === (_e = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _e ? void 0 : _e.textBaseline) && (textBaseline = null === (_f = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _f ? void 0 : _f.textBaseline);
  const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
  let cellGroup, cellIcons;
  if (isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true), cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
    x: xOrigin,
    y: yOrigin,
    width,
    height,
    lineWidth: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth) && void 0 !== _h ? _h : void 0,
    fill: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.fill) && void 0 !== _k ? _k : void 0,
    stroke: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.stroke) && void 0 !== _m ? _m : void 0,
    strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
    strokeArrayColor: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.strokeArrayColor) && void 0 !== _p ? _p : void 0,
    cursor: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.cursor) && void 0 !== _r ? _r : void 0,
    lineDash: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineDash) && void 0 !== _t ? _t : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group2({
    x: xOrigin,
    y: yOrigin,
    width,
    height,
    lineWidth: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.lineWidth) && void 0 !== _v ? _v : void 0,
    fill: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.fill) && void 0 !== _x ? _x : void 0,
    stroke: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.stroke) && void 0 !== _z ? _z : void 0,
    strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
    strokeArrayColor: null !== (_1 = null === (_0 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _0 ? void 0 : _0.strokeArrayColor) && void 0 !== _1 ? _1 : void 0,
    cursor: null !== (_3 = null === (_2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _2 ? void 0 : _2.cursor) && void 0 !== _3 ? _3 : void 0,
    lineDash: null !== (_5 = null === (_4 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _4 ? void 0 : _4.lineDash) && void 0 !== _5 ? _5 : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), mayHaveIcon) {
    let iconCol = col, iconRow = row;
    range5 && (iconCol = range5.start.col, iconRow = range5.start.row), cellIcons = table.getCellIcons(iconCol, iconRow);
  }
  let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
  if (Array.isArray(cellIcons) && 0 !== cellIcons.length) {
    const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(cellIcons, cellGroup, range5, table);
    iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, cellGroup.forEachChildren((child) => {
      "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
    }), cellGroup.forEachChildren((child) => {
      "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
    }), cellGroup._cellLeftIconWidth = cellLeftIconWidth, cellGroup._cellRightIconWidth = cellRightIconWidth;
  }
  const value = table.getCellValue(col, row), image = createImage({
    x: padding[3],
    y: padding[0],
    width: width - padding[1] - padding[3] - iconWidth,
    height: height - padding[0] - padding[2],
    image: value,
    cursor: "pointer"
  });
  return image.name = "image", image.keepAspectRatio = keepAspectRatio, image.textAlign = textAlign, image.textBaseline = textBaseline, keepAspectRatio || imageAutoSizing ? image.resources && image.resources.has(image.attribute.image) && "success" === image.resources.get(image.attribute.image).state ? (image.setAttribute("opacity", 0), setTimeout(() => {
    image.setAttribute("opacity", 1), updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table), table.scenegraph.updateNextFrame();
  }, 0)) : image.successCallback = () => {
    updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table), table.scenegraph.updateNextFrame();
  } : image.resources && image.resources.has(image.attribute.image) && "success" === image.resources.get(image.attribute.image).state ? updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table) : image.successCallback = () => {
    updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table);
  }, image.failCallback = () => {
    const regedIcons3 = get3();
    image.image = regedIcons3.damage_pic.svg;
  }, cellGroup.appendChild(image), cellGroup;
}
function _adjustWidthHeight(col, row, width, height, scene, padding, cellGroup) {
  let needInvalidate = false, targetWidth = null, targetHeight = null;
  const { width: cellWidth, height: cellHeight, isMerge } = getCellRange(cellGroup, scene.table);
  if (cellWidth < width + padding[1] + padding[3] && (targetWidth = width + padding[1] + padding[3], needInvalidate = true), cellHeight < height + padding[2] + padding[0] && (targetHeight = height + padding[2] + padding[0], needInvalidate = true), needInvalidate) {
    if ("number" == typeof targetWidth) if (isMerge) for (let col2 = cellGroup.mergeStartCol; col2 <= cellGroup.mergeEndCol; col2++) scene.setColWidth(col2, targetWidth / (cellGroup.mergeEndCol - cellGroup.mergeStartCol + 1));
    else scene.setColWidth(col, targetWidth);
    if ("number" == typeof targetHeight) if (isMerge) for (let row2 = cellGroup.mergeStartRow; row2 <= cellGroup.mergeEndRow; row2++) scene.setRowHeight(row2, targetHeight / (cellGroup.mergeEndRow - cellGroup.mergeStartRow + 1));
    else scene.setRowHeight(row, targetHeight);
    return scene.component.updateScrollBar(), true;
  }
  return false;
}
function updateImageCellContentWhileResize(cellGroup, col, row, deltaX, deltaY, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const image = cellGroup.getChildByName("image");
  if (!image) return;
  const originImage = "string" != typeof image.attribute.image && image.attribute.image || (null === (_a = image.resources) || void 0 === _a ? void 0 : _a.get(image.attribute.image).data);
  if (!originImage) return;
  const headerStyle = table._getCellStyle(col, row), textAlign = null !== (_b = getProp2("textAlign", headerStyle, col, row, table)) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = getProp2("textBaseline", headerStyle, col, row, table)) && void 0 !== _c ? _c : "middle";
  let padding;
  padding = (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.imageMargin) ? getQuadProps(null === (_e = table.options.customConfig) || void 0 === _e ? void 0 : _e.imageMargin) : null !== (_f = getQuadProps(getProp2("padding", headerStyle, col, row, table))) && void 0 !== _f ? _f : [0, 0, 0, 0];
  const { width: cellWidth, height: cellHeight, isMerge } = getCellRange(cellGroup, table), colStart = null !== (_g = cellGroup.mergeStartCol) && void 0 !== _g ? _g : cellGroup.col, rowStart = null !== (_h = cellGroup.mergeStartRow) && void 0 !== _h ? _h : cellGroup.row, colEnd = null !== (_j = cellGroup.mergeEndCol) && void 0 !== _j ? _j : cellGroup.col, rowEnd = null !== (_k = cellGroup.mergeEndCol) && void 0 !== _k ? _k : cellGroup.row, leftIconWidth = null !== (_l = cellGroup._cellLeftIconWidth) && void 0 !== _l ? _l : 0, rightIconWidth = null !== (_m = cellGroup._cellRightIconWidth) && void 0 !== _m ? _m : 0;
  if (image.keepAspectRatio) {
    const { width: imageWidth, height: imageHeight } = calcKeepAspectRatioSize(originImage.width || originImage.videoWidth, originImage.height || originImage.videoHeight, cellWidth - (padding[1] + padding[3]), cellHeight - (padding[0] + padding[2])), pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
    for (let col2 = colStart; col2 <= colEnd; col2++) for (let row2 = rowStart; row2 <= rowEnd; row2++) {
      const image2 = table.scenegraph.getCell(col2, row2).getChildByName("image");
      null == image2 || image2.setAttributes({
        x: pos.x,
        y: pos.y,
        width: imageWidth,
        height: imageHeight
      });
    }
  } else for (let col2 = colStart; col2 <= colEnd; col2++) for (let row2 = rowStart; row2 <= rowEnd; row2++) {
    const image2 = table.scenegraph.getCell(col2, row2).getChildByName("image");
    null == image2 || image2.setAttributes({
      x: leftIconWidth + padding[3],
      y: padding[0],
      width: cellWidth - padding[1] - padding[3] - rightIconWidth - leftIconWidth,
      height: cellHeight - padding[0] - padding[2]
    });
  }
  if (cellGroup.getChildByName("play-icon")) {
    const left = 0, top = 0, { width, height } = getCellRange(cellGroup, table), iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2), anchorX = left + (width > image.attribute.width ? image.attribute.x - left + image.attribute.width / 2 : width / 2), anchorY = top + (height > image.attribute.height ? image.attribute.y - top + image.attribute.height / 2 : height / 2);
    for (let col2 = colStart; col2 <= colEnd; col2++) for (let row2 = rowStart; row2 <= rowEnd; row2++) {
      table.scenegraph.getCell(col2, row2).getChildByName("play-icon").setAttributes({
        x: anchorX - iconSize / 2,
        y: anchorY - iconSize / 2,
        width: iconSize,
        height: iconSize
      });
    }
  }
  cellGroup.forEachChildren((child) => {
    "icon-left" === child.role || ("icon-right" === child.role || "icon-absolute-right" === child.role) && child.setAttribute("x", child.attribute.x + deltaX);
  }), cellGroup.forEachChildren((child) => {
    ("rect" === child.type || child.role && child.role.startsWith("icon")) && ("middle" === textBaseline ? child.setAttribute("y", padding[0] + (cellHeight - padding[0] - padding[2] - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + cellHeight - padding[0] - padding[2] - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
  }), isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
}
function getCellRange(cellGroup, table) {
  return "cell" === cellGroup.role && isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndRow) ? {
    width: table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol),
    height: table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow),
    isMerge: true
  } : {
    width: cellGroup.attribute.width,
    height: cellGroup.attribute.height,
    isMerge: false
  };
}
function updateImageDxDy(startCol, endCol, startRow, endRow, table) {
  for (let col = startCol; col <= endCol; col++) for (let row = startRow; row <= endRow; row++) {
    const cellGroup = table.scenegraph.getCell(col, row);
    if (cellGroup) {
      const image = cellGroup.getChildByName("image");
      image && image.setAttributes({
        dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
        dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
      });
      const playIcon = cellGroup.getChildByName("play-icon");
      playIcon && playIcon.setAttributes({
        dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
        dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
      });
    }
  }
}
function updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table) {
  const originImage = image.resources.get(image.attribute.image).data, { col, row } = cellGroup;
  if (imageAutoSizing && !isDamagePic(image) && _adjustWidthHeight(col, row, originImage.width, originImage.height, table.scenegraph, padding, cellGroup), keepAspectRatio || isDamagePic(image)) {
    const { width: cellWidth, height: cellHeight, isMerge } = getCellRange(cellGroup, table), { width: imageWidth, height: imageHeight } = calcKeepAspectRatioSize(originImage.width, originImage.height, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]), pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
    image.setAttributes({
      x: pos.x,
      y: pos.y,
      width: imageWidth,
      height: imageHeight
    }), isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
  }
}
function isDamagePic(image) {
  const regedIcons3 = get3();
  return image.attribute.image === regedIcons3.damage_pic.svg;
}

// node_modules/@visactor/vtable/es/scenegraph/utils/deal-promise-data.js
function dealPromiseData(dataPromise, tabel, callback) {
  dataPromise.then(() => {
    callback(), tabel.scenegraph.updateNextFrame();
  }).catch((err) => {
  });
}

// node_modules/@visactor/vtable/es/plugins/invert-highlight.js
function onBeforeAttributeUpdateForInvertHighlight(val, attribute) {
  var _a, _b;
  const graphic = this;
  if (graphic.shadowRoot && graphic.shadowRoot.childrenCount && (isValid_default(val.width) || isValid_default(val.height))) {
    const shadowRect = graphic.shadowRoot.findChildrenByName("shadow-rect")[0];
    shadowRect && shadowRect.setAttributes({
      width: null !== (_a = val.width) && void 0 !== _a ? _a : shadowRect.attribute.width,
      height: null !== (_b = val.height) && void 0 !== _b ? _b : shadowRect.attribute.height
    });
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-helper.js
function createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range5, customResult) {
  var _a, _b;
  let cellGroup, isAsync = false;
  if (isPromise(value)) {
    if ("cell" !== table.scenegraph.highPerformanceGetCell(col, row).role) return cellGroup;
    value = table.getCellValue(col, row), isAsync = true;
  }
  if ("text" === type || "link" === type || customResult) {
    if ("link" === type) {
      const cellValue = value, cellOriginValue = table.getCellOriginValue(col, row), headerStyle = table._getCellStyle(col, row);
      "link" === type && ("templateLink" in define && define.templateLink || !("linkDetect" in define) || !getOrApply(define.linkDetect, {
        col,
        row,
        table,
        value: cellValue,
        dataValue: cellOriginValue,
        cellHeaderPaths: void 0
      }) || regUrl.test(cellValue)) && (cellTheme ? (cellTheme.text.fill = getProp2("linkColor", headerStyle, col, row, table), cellTheme.group.cursor = "pointer") : cellTheme = {
        text: {
          fill: getProp2("linkColor", headerStyle, col, row, table)
        },
        group: {
          cursor: "pointer"
        }
      });
    }
    const { customElementsGroup, renderDefault } = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range5, customResult);
    cellGroup = Factory2.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range5, isAsync);
    const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
    if (axisConfig) {
      const axis = new (Factory2.getComponent("axis"))(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, null !== (_a = axisConfig.__vtablePadding) && void 0 !== _a ? _a : padding, table);
      cellGroup.clear(), cellGroup.appendChild(axis.component), axis.overlap();
    } else table.internalProps.layoutMap.isEmpty(col, row) ? (cellGroup.setAttributes({
      fill: false,
      stroke: false
    }), cellGroup.clear()) : table.internalProps.layoutMap.isAxisCell(col, row) && cellGroup.clear();
  } else if ("image" === type) {
    cellGroup = Factory2.getFunction("createImageCellGroup")(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range5, isAsync);
  } else if ("video" === type) {
    cellGroup = Factory2.getFunction("createVideoCellGroup")(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range5, isAsync);
  } else if ("chart" === type) {
    const chartInstance = table.internalProps.layoutMap.getChartInstance(col, row);
    cellGroup = Factory2.getFunction("createChartCellGroup")(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, value, define.chartModule, table.internalProps.layoutMap.getChartSpec(col, row), chartInstance, null !== (_b = table.internalProps.layoutMap.getChartDataId(col, row)) && void 0 !== _b ? _b : "data", table, cellTheme, table.internalProps.layoutMap.isShareChartSpec(col, row), isAsync, table.internalProps.layoutMap.isNoChartDataRenderNothing(col, row));
  } else if ("progressbar" === type) {
    const { customElementsGroup, renderDefault } = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range5, customResult), style2 = table._getCellStyle(col, row), dataValue = table.getCellOriginValue(col, row);
    cellGroup = Factory2.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, false, customElementsGroup, renderDefault, cellTheme, range5, isAsync);
    const progressBarGroup = Factory2.getFunction("createProgressBarCell")(define, style2, colWidth, value, dataValue, col, row, padding, table, range5);
    cellGroup.firstChild ? cellGroup.insertBefore(progressBarGroup, cellGroup.firstChild) : cellGroup.appendChild(progressBarGroup);
  } else if ("sparkline" === type) {
    cellGroup = Factory2.getFunction("createSparkLineCellGroup")(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, table, cellTheme, isAsync);
  } else if ("checkbox" === type) {
    const isAggregation = "isAggregation" in table.internalProps.layoutMap && table.internalProps.layoutMap.isAggregation(col, row), isSeriesNumber = table.internalProps.layoutMap.isSeriesNumber(col, row);
    if (isAggregation && isSeriesNumber) {
      cellGroup = Factory2.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, false, void 0, true, cellTheme, range5, isAsync);
    } else {
      cellGroup = Factory2.getFunction("createCheckboxCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync);
    }
  } else if ("radio" === type) {
    cellGroup = Factory2.getFunction("createRadioCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellTheme, define, range5);
  } else if ("switch" === type) {
    cellGroup = Factory2.getFunction("createSwitchCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync);
  } else if ("button" === type) {
    cellGroup = Factory2.getFunction("createButtonCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync);
  }
  return cellGroup.onBeforeAttributeUpdate = onBeforeAttributeUpdateForInvertHighlight, cellGroup;
}
function _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range5, customResult) {
  let customElementsGroup, renderDefault = true;
  if (customResult) customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault;
  else if ((null == range5 ? void 0 : range5.isCustom) && !table.isCornerHeader(col, row)) ;
  else {
    let customRender, customLayout;
    if ("body" !== table.getCellLocation(col, row) ? (customRender = null == define ? void 0 : define.headerCustomRender, customLayout = null == define ? void 0 : define.headerCustomLayout) : (customRender = (null == define ? void 0 : define.customRender) || table.customRender, customLayout = null == define ? void 0 : define.customLayout), customLayout || customRender) {
      const customResult2 = dealWithCustom(customLayout, customRender, col, row, cellWidth, cellHeight, false, table.isAutoRowHeight(row), padding, range5, table);
      customElementsGroup = customResult2.elementsGroup, renderDefault = customResult2.renderDefault;
    }
  }
  return {
    customElementsGroup,
    renderDefault
  };
}
function updateCell(col, row, table, addNew, isShadow, forceFastUpdate) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const oldCellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
  if ("cell" !== oldCellGroup.role && !addNew) return;
  const cellLocation = table.getCellLocation(col, row);
  let isMerge, range5, customStyle, customResult, value = table.getCellValue(col, row), isCustomMerge = false;
  if (table.internalProps.customMergeCell) {
    const customMerge = table.getCustomMerge(col, row);
    if (customMerge) {
      const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout, customRender } = customMerge;
      range5 = customMergeRange, isMerge = range5.start.col !== range5.end.col || range5.start.row !== range5.end.row, value = customMergeText, customStyle = customMergeStyle, (customLayout || customRender) && (customResult = dealWithCustom(customLayout, customRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range5, table)), isCustomMerge = true;
    }
  }
  let colForDefine = col, rowForDefine = row;
  range5 && (colForDefine = range5.start.col, rowForDefine = range5.start.row);
  const define = "body" !== cellLocation ? table.getHeaderDefine(colForDefine, rowForDefine) : table.getBodyColumnDefine(colForDefine, rowForDefine);
  let mayHaveIcon = "body" !== cellLocation || ((null == define ? void 0 : define.dragOrder) || !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree));
  range5 || !table.internalProps.enableTreeNodeMerge && "body" === cellLocation && !(null == define ? void 0 : define.mergeCell) || (range5 = table.getCellRange(col, row), isMerge = range5.start.col !== range5.end.col || range5.start.row !== range5.end.row);
  let isVtableMerge = false;
  if (table.internalProps.enableTreeNodeMerge && isMerge) {
    const rawRecord = table.getCellRawRecord(range5.start.col, range5.start.row), { vtableMergeName, vtableMerge } = null != rawRecord ? rawRecord : {};
    isVtableMerge = vtableMerge, vtableMerge && (mayHaveIcon = true, table.options.groupTitleCustomLayout && (customResult = dealWithCustom(table.options.groupTitleCustomLayout, void 0, range5.start.col, range5.start.row, table.getColsWidth(range5.start.col, range5.end.col), table.getRowsHeight(range5.start.row, range5.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range5, table)), table.options.groupTitleFieldFormat ? value = table.options.groupTitleFieldFormat(rawRecord, col, row, table) : vtableMergeName && (value = vtableMergeName));
  }
  const cellStyle = customStyle || table._getCellStyle(range5 ? range5.start.col : col, range5 ? range5.start.row : row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, cellTheme = getStyleTheme(cellStyle, table, isMerge ? range5.start.col : col, isMerge ? range5.start.row : row, getProp2).theme;
  if (cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table), !addNew && !isMerge && !((null == define ? void 0 : define.customLayout) || (null == define ? void 0 : define.customRender) || (null == define ? void 0 : define.headerCustomLayout) || (null == define ? void 0 : define.headerCustomRender)) && (forceFastUpdate || canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table))) {
    const cellWidth2 = table.getColWidth(col), cellHeight2 = table.getRowHeight(row), strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    oldCellGroup.setAttributes({
      width: cellWidth2,
      height: cellHeight2,
      lineWidth: null !== (_c = null === (_b = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _b ? void 0 : _b.lineWidth) && void 0 !== _c ? _c : void 0,
      fill: null !== (_e = null === (_d = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _d ? void 0 : _d.fill) && void 0 !== _e ? _e : void 0,
      stroke: null !== (_g = null === (_f = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _f ? void 0 : _f.stroke) && void 0 !== _g ? _g : void 0,
      strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
      strokeArrayColor: null !== (_j = null === (_h = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _h ? void 0 : _h.strokeArrayColor) && void 0 !== _j ? _j : void 0,
      cursor: null !== (_l = null === (_k = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _k ? void 0 : _k.cursor) && void 0 !== _l ? _l : void 0,
      cornerRadius: null !== (_o = null === (_m = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _m ? void 0 : _m.cornerRadius) && void 0 !== _o ? _o : 0,
      lineDash: null !== (_q = null === (_p = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _p ? void 0 : _p.lineDash) && void 0 !== _q ? _q : void 0,
      y: table.scenegraph.getCellGroupY(row)
    }), oldCellGroup.forEachChildren((child) => {
      child.setAttributes({
        dx: 0,
        dy: 0
      });
    });
    const textMark = oldCellGroup.getChildByName("text");
    if (forceFastUpdate && textMark) {
      const attribute = {
        textBaseline: "top"
      };
      textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
    } else if (textMark) {
      const text2 = table.getCellValue(col, row), { text: textArr, moreThanMaxCharacters } = breakString(text2, table), hierarchyOffset = getHierarchyOffset(col, row, table), lineClamp = cellStyle.lineClamp, padding2 = null !== (_r = getQuadProps(getProp2("padding", cellStyle, col, row, table))) && void 0 !== _r ? _r : [0, 0, 0, 0], textAlign2 = cellTheme.text.textAlign;
      let x = 0;
      x = "center" === textAlign2 ? padding2[3] + (cellWidth2 - (padding2[1] + padding2[3])) / 2 : "right" === textAlign2 ? padding2[3] + cellWidth2 - (padding2[1] + padding2[3]) : padding2[3];
      const attribute = {
        text: 1 !== textArr.length || autoWrapText ? textArr : textArr[0],
        moreThanMaxCharacters,
        maxLineWidth: cellWidth2 - (padding2[1] + padding2[3] + hierarchyOffset),
        textBaseline: "top",
        autoWrapText,
        lineClamp,
        wordBreak: "break-word",
        heightLimit: cellHeight2 - Math.floor(padding2[0] + padding2[2]),
        pickable: false,
        dx: "left" === textAlign2 ? hierarchyOffset : 0,
        x
      };
      if (textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute), textMark.attribute.text) {
        const textBaseline2 = cellTheme.text.textBaseline, height = cellHeight2 - (padding2[0] + padding2[2]);
        let y = 0;
        y = "middle" === textBaseline2 ? padding2[0] + (height - textMark.AABBBounds.height()) / 2 : "bottom" === textBaseline2 ? padding2[0] + height - textMark.AABBBounds.height() : padding2[0], textMark.setAttributes({
          y
        });
      }
    }
    return oldCellGroup;
  }
  if (!addNew && "empty" === oldCellGroup.role) return;
  const type = isVtableMerge || isCustomMerge ? "text" : table.isHeader(col, row) ? null !== (_s = table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _s ? _s : "text" : null !== (_t = table.getBodyColumnType(col, row)) && void 0 !== _t ? _t : "text", padding = cellTheme._vtable.padding, textAlign = cellTheme.text.textAlign, textBaseline = cellTheme.text.textBaseline;
  let newCellGroup, cellWidth, cellHeight;
  if (range5 ? (cellWidth = table.getColsWidth(range5.start.col, range5.end.col), cellHeight = table.getRowsHeight(range5.start.row, range5.end.row)) : (cellWidth = table.getColWidth(col), cellHeight = table.getRowHeight(row)), isPromise(value) ? (oldCellGroup.removeAllChild(), dealPromiseData(value, table, callUpdateCellContentForPromiseValue.bind(null, {
    type,
    value,
    define,
    table,
    col,
    row,
    cellWidth,
    cellHeight,
    oldCellGroup,
    padding,
    textAlign,
    textBaseline,
    mayHaveIcon,
    addNew,
    range: range5,
    customResult,
    customStyle
  }))) : newCellGroup = updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range5, customResult), isMerge) {
    const { width: contentWidth } = newCellGroup.attribute, { height: contentHeight } = newCellGroup.attribute;
    newCellGroup.contentWidth = contentWidth, newCellGroup.contentHeight = contentHeight, isShadow ? dealWithMergeCellSizeForShadow(range5, cellWidth, cellHeight, padding, textAlign, textBaseline, table, newCellGroup) : dealWithMergeCellSize(range5, cellWidth, cellHeight, padding, textAlign, textBaseline, table);
  }
  return newCellGroup;
}
function updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range5, customResult) {
  var _a, _b;
  if (isPromise(value) && (value = table.getCellValue(col, row)), !addNew && (oldCellGroup.row !== row || oldCellGroup.col !== col)) return null;
  if (!addNew && oldCellGroup.parent && table.reactCustomLayout) {
    const reactGroup = oldCellGroup.getChildByName("custom-container");
    if (reactGroup) {
      const { col: col2, row: row2 } = reactGroup;
      isNumber_default(col2) && isNumber_default(row2) && table.reactCustomLayout.removeCustomCell(col2, row2);
    }
  }
  const newCellGroup = createCell(type, value, define, table, col, row, table.getColWidth(col), cellWidth, cellHeight, addNew ? table.scenegraph.getColGroup(col) : oldCellGroup.parent, addNew ? 0 : table.scenegraph.getCellGroupY(row), padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range5, customResult);
  return !addNew && oldCellGroup.parent && (oldCellGroup.parent.insertAfter(newCellGroup, oldCellGroup), oldCellGroup.parent.removeChild(oldCellGroup), (null === (_a = table.scenegraph) || void 0 === _a ? void 0 : _a.proxy.cellCache.get(col)) && (null === (_b = table.scenegraph) || void 0 === _b || _b.proxy.cellCache.set(col, newCellGroup))), newCellGroup;
}
function canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table) {
  var _a;
  const cellType = table.getBodyColumnType(col, row), autoRowHeight = table.isAutoRowHeight(row), value = table.getCellValue(col, row);
  return !(table.isHeader(col, row) || "cell" !== oldCellGroup.role || "text" !== cellType || autoWrapText || autoRowHeight || mayHaveIcon || "text" !== (null === (_a = oldCellGroup.firstChild) || void 0 === _a ? void 0 : _a.type) || isPromise(value));
}
function callUpdateCellContentForPromiseValue(updateCellArgs) {
  const { type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, range: range5, customResult, customStyle } = updateCellArgs, cellStyle = customStyle || table._getCellStyle(range5 ? range5.start.col : col, range5 ? range5.start.row : row), cellTheme = getStyleTheme(cellStyle, table, range5 ? range5.start.col : col, range5 ? range5.start.row : row, getProp2).theme;
  cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table), updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range5, customResult);
}
function dealWithMergeCellSize(range5, cellWidth, cellHeight, padding, textAlign, textBaseline, table) {
  for (let col = range5.start.col; col <= range5.end.col; col++) for (let row = range5.start.row; row <= range5.end.row; row++) {
    const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
    if ("cell" !== cellGroup.role) continue;
    range5.start.row !== range5.end.row && cellGroup.contentHeight !== cellHeight && updateCellContentHeight(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table), range5.start.col !== range5.end.col && cellGroup.contentWidth !== cellWidth && updateCellContentWidth(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph), cellGroup.contentWidth = cellWidth, cellGroup.contentHeight = cellHeight;
    const rangeHeight = table.getRowHeight(row);
    resizeCellGroup(cellGroup, table.getColWidth(col), rangeHeight, range5, table);
  }
}
function dealWithMergeCellSizeForShadow(range5, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellGroup) {
  const { col, row } = cellGroup;
  range5.start.row !== range5.end.row && cellGroup.contentHeight !== cellHeight && updateCellContentHeight(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table), range5.start.col !== range5.end.col && cellGroup.contentWidth !== cellWidth && updateCellContentWidth(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph), cellGroup.contentWidth = cellWidth, cellGroup.contentHeight = cellHeight;
  const rangeHeight = table.getRowHeight(row);
  resizeCellGroup(cellGroup, table.getColWidth(col), rangeHeight, range5, table);
}
function resizeCellGroup(cellGroup, rangeWidth, rangeHeight, range5, table) {
  var _a, _b;
  const { col, row } = cellGroup, dx = -table.getColsWidth(range5.start.col, col - 1);
  let dy = 0;
  if (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) for (let i = range5.start.row; i <= row - 1; i++) dy -= table.getRowHeight(i);
  else dy = -table.getRowsHeight(range5.start.row, row - 1);
  cellGroup.forEachChildren((child) => {
    var _a2, _b2, _c, _d, _e, _f;
    "number" == typeof child._dx ? (child.skipMergeUpdate = true, child.setAttributes({
      dx: (null !== (_a2 = child._dx) && void 0 !== _a2 ? _a2 : 0) + dx
    }), child.skipMergeUpdate = false) : (child.skipMergeUpdate = true, child._dx = null !== (_b2 = child.attribute.dx) && void 0 !== _b2 ? _b2 : 0, child.setAttributes({
      dx: (null !== (_c = child.attribute.dx) && void 0 !== _c ? _c : 0) + dx
    }), child.skipMergeUpdate = false), "number" == typeof child._dy ? (child.skipMergeUpdate = true, child.setAttributes({
      dy: (null !== (_d = child._dy) && void 0 !== _d ? _d : 0) + dy
    }), child.skipMergeUpdate = false) : (child._dy = null !== (_e = child.attribute.dy) && void 0 !== _e ? _e : 0, child.skipMergeUpdate = true, child.setAttributes({
      dy: (null !== (_f = child.attribute.dy) && void 0 !== _f ? _f : 0) + dy
    }), child.skipMergeUpdate = false);
  });
  const lineWidth = null !== (_b = cellGroup.attribute.strokeArrayWidth) && void 0 !== _b ? _b : cellGroup.attribute.lineWidth, isLineWidthArray = isArray_default(lineWidth), newLineWidth = [0, 0, 0, 0];
  col === range5.start.col && (newLineWidth[3] = isLineWidthArray ? lineWidth[3] : lineWidth), row === range5.start.row && (newLineWidth[0] = isLineWidthArray ? lineWidth[0] : lineWidth), col === range5.end.col && (newLineWidth[1] = isLineWidthArray ? lineWidth[1] : lineWidth), row === range5.end.row && (newLineWidth[2] = isLineWidthArray ? lineWidth[2] : lineWidth);
  const widthChange = rangeWidth !== cellGroup.attribute.width, heightChange = rangeHeight !== cellGroup.attribute.height;
  return cellGroup.skipMergeUpdate = true, cellGroup.setAttributes({
    width: rangeWidth,
    height: rangeHeight,
    strokeArrayWidth: newLineWidth
  }), cellGroup.skipMergeUpdate = false, cellGroup.mergeStartCol = range5.start.col, cellGroup.mergeStartRow = range5.start.row, cellGroup.mergeEndCol = range5.end.col, cellGroup.mergeEndRow = range5.end.row, {
    widthChange,
    heightChange
  };
}
function getCustomCellMergeCustom(col, row, cellGroup, table) {
  if (table.internalProps.customMergeCell) {
    const customMerge = table.getCustomMerge(col, row);
    if (customMerge) {
      const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout: customMergeLayout, customRender: customMergeRender } = customMerge;
      if (customMergeLayout || customMergeRender) {
        const customElementsGroup = dealWithCustom(customMergeLayout, customMergeRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], customMergeRange, table).elementsGroup;
        cellGroup.childrenCount > 0 && customElementsGroup ? cellGroup.insertBefore(customElementsGroup, cellGroup.firstChild) : customElementsGroup && cellGroup.appendChild(customElementsGroup);
        const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col), { width: contentWidth } = cellGroup.attribute, { height: contentHeight } = cellGroup.attribute;
        return cellGroup.contentWidth = contentWidth, cellGroup.contentHeight = contentHeight, resizeCellGroup(cellGroup, rangeWidth, rangeHeight, customMergeRange, table), customMergeRange;
      }
    }
  }
}

// node_modules/@visactor/vtable/es/scenegraph/utils/is-merge-cell-group.js
function isMergeCellGroup(cellGroup) {
  return !!("cell" === cellGroup.role && isNumber_default(cellGroup.mergeStartCol) && isNumber_default(cellGroup.mergeStartRow) && isNumber_default(cellGroup.mergeEndCol) && isNumber_default(cellGroup.mergeEndRow));
}

// node_modules/@visactor/vtable/es/scenegraph/layout/height-util.js
var utilCheckBoxMark = new CheckBox({});
var utilRadioMark = new Radio({});
var utilButtonMark = new Tag({});
function computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
  const text2 = isObject_default(cellValue) ? cellValue.text : cellValue, lines = validToString(text2).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = getProp2("size", actStyle, col, row, table);
  let maxHeight = 0;
  if (autoWrapText) {
    const spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - size - spaceBetweenTextAndIcon;
    utilCheckBoxMark.setAttributes({
      text: {
        maxLineWidth,
        text: lines,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        wordBreak: "break-word",
        lineClamp
      },
      icon: {
        width: Math.floor(size / 1.4),
        height: Math.floor(size / 1.4)
      },
      box: {
        width: size,
        height: size
      },
      spaceBetweenTextAndIcon
    }), utilCheckBoxMark.render(), maxHeight = utilCheckBoxMark.AABBBounds.height();
  } else maxHeight = Math.max(size, lines.length * lineHeight);
  return maxHeight;
}
function computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
  var _a;
  if (isArray_default(cellValue)) {
    let maxHeight = 0;
    const define = table.getBodyColumnDefine(col, row), spaceBetweenRadio = getProp2("spaceBetweenRadio", actStyle, col, row, table), radioDirectionInCell = null !== (_a = null == define ? void 0 : define.radioDirectionInCell) && void 0 !== _a ? _a : "vertical";
    return "vertical" === radioDirectionInCell ? cellValue.forEach((singleValue, index) => {
      const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
      maxHeight += height, index !== cellValue.length - 1 && (maxHeight += spaceBetweenRadio);
    }) : "horizontal" === radioDirectionInCell && cellValue.forEach((singleValue) => {
      const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
      maxHeight = Math.max(height, maxHeight);
    }), maxHeight;
  }
  return computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
}
function computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
  const text2 = isObject_default(cellValue) ? cellValue.text : cellValue, lines = validToString(text2).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = getProp2("size", actStyle, col, row, table);
  let outerRadius = getProp2("outerRadius", actStyle, col, row, table);
  const circleSize = isNumber_default(outerRadius) ? 2 * outerRadius : size;
  let maxHeight = 0;
  if (autoWrapText) {
    const spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - circleSize - spaceBetweenTextAndIcon;
    isNumber_default(outerRadius) || (outerRadius = Math.round(size / 2)), utilRadioMark.setAttributes({
      text: {
        maxLineWidth,
        text: lines,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        wordBreak: "break-word",
        lineClamp
      },
      circle: {
        outerRadius
      },
      spaceBetweenTextAndIcon
    }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
  } else maxHeight = Math.max(size, lines.length * lineHeight);
  return maxHeight;
}
function computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
  return getProp2("boxWidth", actStyle, col, row, table);
}
function computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
  const text2 = isObject_default(cellValue) ? cellValue.text : cellValue, lines = validToString(text2).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), buttonPadding = getProp2("buttonPadding", actStyle, col, row, table), buttonLineWidth = getProp2("buttonLineWidth", actStyle, col, row, table);
  let maxHeight = 0;
  if (autoWrapText) {
    const maxLineWidth = cellWidth - (padding[1] + padding[3]);
    utilButtonMark.setAttributes({
      text: lines,
      textStyle: {
        maxLineWidth,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        wordBreak: "break-word",
        lineClamp
      },
      padding: buttonPadding,
      panel: {
        visible: true,
        fill: "red",
        stroke: "red",
        lineWidth: buttonLineWidth
      }
    }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
  } else maxHeight = lines.length * lineHeight + 2 * buttonPadding;
  return maxHeight;
}

// node_modules/@visactor/vtable/es/scenegraph/utils/text-measure.js
var customAlphabetCharSet = "";
var textMeasureMode = "quick";
var textMeasureModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(TextMeasureContribution) ? rebind(TextMeasureContribution).to(FastTextMeasureContribution).inSingletonScope() : bind(TextMeasureContribution).to(FastTextMeasureContribution).inSingletonScope();
});
var restoreTextMeasureModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(TextMeasureContribution) ? rebind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope() : bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope();
});
var text_measure_default = textMeasureModule;
var fastTextMeasureCache = /* @__PURE__ */ new Map();
function getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle = "normal") {
  const key = `${fontSize}-${fontWeight}-${fontFamily}-${fontStyle}`, cache = fastTextMeasureCache.get(key);
  if (cache) return cache;
  const fastTextMeasure = (textSpec = {
    fontSize,
    fontFamily,
    fontWeight,
    fontStyle
  }, new TextMeasure(Object.assign({
    defaultFontParams: {
      fontFamily: DefaultTextStyle.fontFamily,
      fontSize: DefaultTextStyle.fontSize
    },
    getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
    specialCharSet: `{}()//&-/: .,@%'"~…=——${TextMeasure.ALPHABET_CHAR_SET}${TextMeasure.ALPHABET_CHAR_SET.toUpperCase()}0123456789${customAlphabetCharSet}`
  }, null != option ? option : {}), textSpec));
  var textSpec, option, useNaiveCanvas;
  return fastTextMeasureCache.set(key, fastTextMeasure), fastTextMeasure;
}
var FastTextMeasureContribution = class extends DefaultTextMeasureContribution {
  _fastMeasure(text2, options) {
    const { fontSize, fontFamily = "Arial,sans-serif", fontWeight = "normal", fontStyle = "normal" } = options, textMeasure2 = getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle).measure(text2, textMeasureMode);
    if (!isValid_default(textMeasure2.fontBoundingBoxAscent) && !isValid_default(textMeasure2.fontBoundingBoxDescent)) {
      const { ascent, descent } = this.measureTextBoundADscentEstimate(options);
      textMeasure2.fontBoundingBoxAscent = ascent, textMeasure2.fontBoundingBoxDescent = descent;
    }
    return textMeasure2;
  }
  measureTextWidth(text2, options) {
    return this._fastMeasure(text2, options).width;
  }
  measureText(text2, options) {
    return this._fastMeasure(text2, options);
  }
  _measureTextWithoutAlignBaseline(text2, options, compatible) {
    return this._fastMeasure(text2, options);
  }
  _measureTextWithAlignBaseline(text2, options, compatible) {
    return this._fastMeasure(text2, options);
  }
};
var TextMeasureTool = class {
  measureText(text2, options) {
    const { fontSize, fontFamily = "Arial,sans-serif", fontWeight = "normal", fontStyle = "normal" } = options;
    return getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle).measure(text2, textMeasureMode);
  }
  measureTextWidth(text2, options) {
    const { fontSize, fontFamily = "Arial,sans-serif", fontWeight = "normal", fontStyle = "normal" } = options;
    return getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle).measure(text2, textMeasureMode).width;
  }
  clipText(text2, options, width) {
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    let length2 = this.measureTextWidth(text2, options);
    return length2 <= width ? {
      str: text2,
      width: length2
    } : (length2 = this.measureTextWidth(text2[0], options), length2 > width ? {
      str: "",
      width: 0
    } : this._clipText(text2, options, width, 0, text2.length - 1));
  }
  _clipText(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text2.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str2 = text2.substring(0, middleIdx);
      return length2 = this.measureTextWidth(str2, options), length2 <= width ? {
        str: str2,
        width: length2
      } : this._clipText(text2, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text2.length - 1) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str2 = text2.substring(0, middleIdx + 2);
      return length2 = this.measureTextWidth(str2, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipText(text2, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  clipTextWithSuffix(text2, options, width, suffix) {
    if ("" === suffix) return this.clipText(text2, options, width);
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    const length2 = this.measureTextWidth(text2, options);
    if (length2 <= width) return {
      str: text2,
      width: length2
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    width -= suffixWidth;
    const data = this._clipText(text2, options, width, 0, text2.length - 1);
    return data.str += suffix, data.width += suffixWidth, data;
  }
};
var textMeasure = new TextMeasureTool();
function setCustomAlphabetCharSet(str2) {
  customAlphabetCharSet = str2, fastTextMeasureCache.clear();
}
function restoreMeasureText() {
  textMeasureMode = "canvas", container.load(restoreTextMeasureModule);
}
var utilTextMark = new Text({
  ignoreBuf: true
});
function measureTextBounds(attribute) {
  return utilTextMark.initAttributes(Object.assign(Object.assign({}, attribute), {
    ignoreBuf: true
  })), utilTextMark.AABBBounds;
}

// node_modules/@visactor/vtable/es/scenegraph/layout/compute-row-height.js
var utilRichTextMark = new RichText({
  width: 0,
  height: 0,
  textConfig: []
});
function computeRowsHeight(table, rowStart, rowEnd, isClearRowRangeHeightsMap = true, update2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  "undefined" != typeof window && window.performance.now();
  const oldRowHeights = [], newHeights = [];
  if (update2) for (let row = rowStart; row <= rowEnd; row++) oldRowHeights[row] = table.getRowHeight(row);
  const layoutMap = table.internalProps.layoutMap;
  table.isPivotTable() && (layoutMap.enableUseGetBodyCache(), layoutMap.enableUseHeaderPathCache()), table.defaultHeaderRowHeight, table.defaultHeaderColWidth;
  const isDefaultHeaderHasAuto = "auto" === table.defaultHeaderRowHeight || isArray_default(table.defaultHeaderRowHeight) && table.defaultHeaderRowHeight.some((item) => "auto" === item), isAllRowsAuto = table.isAutoRowHeight(rowStart) || "adaptive" === table.heightMode && false !== table.options.autoHeightInAdaptiveMode, isDefaultRowHeightIsAuto = "auto" === table.options.defaultRowHeight;
  if (isAllRowsAuto || isDefaultHeaderHasAuto || isDefaultRowHeightIsAuto) {
    rowStart = null != rowStart ? rowStart : 0, rowEnd = null != rowEnd ? rowEnd : table.rowCount - 1, (0 === rowStart && rowEnd === table.rowCount - 1 || isClearRowRangeHeightsMap) && table._clearRowRangeHeightsMap();
    for (let row = rowStart; row < table.columnHeaderLevelCount; row++) {
      let startCol = 0, endCol = table.colCount - 1;
      if ((table.isPivotTable() && !table.isPivotChart() || table.isPivotChart() && !table.internalProps.layoutMap.indicatorsAsCol) && checkPivotFixedStyleAndNoWrap(table, row) && !getCellMergeInfo(table, table.rowHeaderLevelCount, row) && (startCol = 0, endCol = table.rowHeaderLevelCount), isAllRowsAuto || "auto" === table.getDefaultRowHeight(row)) {
        const height = computeRowHeight(row, startCol, endCol, table);
        newHeights[row] = Math.round(height), "only-body" !== table.heightAdaptiveMode && update2 || table._setRowHeight(row, height);
      }
    }
    for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) if (isAllRowsAuto || "auto" === table.getDefaultRowHeight(row)) {
      const height = computeRowHeight(row, 0, table.colCount - 1, table);
      update2 ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
    }
    if (rowEnd < table.columnHeaderLevelCount || !isAllRowsAuto && !isDefaultRowHeightIsAuto) ;
    else if (table.internalProps.transpose || table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol || table.options.customComputeRowHeight || !checkFixedStyleAndNoWrap(table, rowStart)) if (table.internalProps.transpose || table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol) for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
      let height;
      height = checkFixedStyleAndNoWrapForTranspose(table, row) ? computeRowHeight(row, 0, table.rowHeaderLevelCount, table) : computeRowHeight(row, 0, table.colCount - 1, table), update2 ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
    }
    else for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
      const height = computeRowHeight(row, 0, table.colCount - 1, table);
      update2 ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
    }
    else {
      fillRowsHeight(computeRowHeight(table.columnHeaderLevelCount, 0, table.colCount - 1, table), table.columnHeaderLevelCount, table.rowCount - 1 - table.bottomFrozenRowCount, table, update2 ? newHeights : void 0);
      for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) {
        const height = computeRowHeight(row, 0, table.colCount - 1, table);
        update2 ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
      }
    }
  } else if (("adaptive" === table.heightMode || table.autoFillHeight) && table.clearRowHeightCache(), update2) for (let row = rowStart; row <= rowEnd; row++) newHeights[row] = table.getRowHeight(row);
  if ((0 === rowStart && rowEnd === table.rowCount - 1 || isClearRowRangeHeightsMap) && table._clearRowRangeHeightsMap(), "adaptive" === table.heightMode) {
    table._clearRowRangeHeightsMap();
    let totalDrawHeight = table.tableNoFrameHeight, startRow = 0, endRow = table.rowCount;
    if ("only-body" === table.heightAdaptiveMode) {
      const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1), bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0;
      totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight, startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
    }
    let actualHeight = 0;
    for (let row = startRow; row < endRow; row++) actualHeight += update2 && null !== (_a = newHeights[row]) && void 0 !== _a ? _a : table.getRowHeight(row);
    const factor = totalDrawHeight / actualHeight;
    for (let row = startRow; row < endRow; row++) {
      let rowHeight;
      rowHeight = row === endRow - 1 ? totalDrawHeight - (update2 ? newHeights.reduce((acr, cur, index) => index >= startRow && index <= endRow - 2 ? acr + cur : acr, 0) : table.getRowsHeight(startRow, endRow - 2)) : Math.round((update2 && null !== (_b = newHeights[row]) && void 0 !== _b ? _b : table.getRowHeight(row)) * factor), update2 ? newHeights[row] = rowHeight : table._setRowHeight(row, rowHeight, false);
    }
  } else if (table.autoFillHeight) {
    table._clearRowRangeHeightsMap();
    const canvasHeight = table.tableNoFrameHeight;
    let actualHeight = 0, actualHeaderHeight = 0;
    for (let row = 0; row < table.rowCount; row++) {
      const rowHeight = update2 && null !== (_c = newHeights[row]) && void 0 !== _c ? _c : table.getRowHeight(row);
      (row < table.columnHeaderLevelCount || table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount) && (actualHeaderHeight += rowHeight), actualHeight += rowHeight;
    }
    if (table.scenegraph._dealAutoFillHeightOriginRowsHeight = actualHeight, actualHeight < canvasHeight && actualHeight - actualHeaderHeight > 0) {
      const startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount, factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
      for (let row = startRow; row < endRow; row++) {
        let rowHeight;
        rowHeight = row === endRow - 1 ? canvasHeight - actualHeaderHeight - (update2 ? newHeights.reduce((acr, cur, index) => index >= startRow && index <= endRow - 2 ? acr + cur : acr, 0) : table.getRowsHeight(startRow, endRow - 2)) : Math.round((update2 && null !== (_d = newHeights[row]) && void 0 !== _d ? _d : table.getRowHeight(row)) * factor), update2 ? newHeights[row] = rowHeight : table._setRowHeight(row, rowHeight, false);
      }
    }
  }
  if (update2) {
    for (let row = rowStart; row <= rowEnd; row++) {
      const newRowHeight = null !== (_e = newHeights[row]) && void 0 !== _e ? _e : table.getRowHeight(row);
      isValid_default(newRowHeight) && table._setRowHeight(row, newRowHeight);
    }
    for (let row = 0; row <= table.frozenRowCount - 1; row++) {
      const newRowHeight = table.getRowHeight(row);
      newRowHeight !== (null !== (_f = oldRowHeights[row]) && void 0 !== _f ? _f : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_g = oldRowHeights[row]) && void 0 !== _g ? _g : table.getRowHeight(row)), true);
    }
    for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) {
      const newRowHeight = table.getRowHeight(row);
      newRowHeight !== (null !== (_h = oldRowHeights[row]) && void 0 !== _h ? _h : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_j = oldRowHeights[row]) && void 0 !== _j ? _j : table.getRowHeight(row)), true);
    }
    for (let row = table.scenegraph.proxy.rowStart; row <= table.scenegraph.proxy.rowEnd; row++) {
      const newRowHeight = table.getRowHeight(row);
      newRowHeight !== (null !== (_k = oldRowHeights[row]) && void 0 !== _k ? _k : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_l = oldRowHeights[row]) && void 0 !== _l ? _l : table.getRowHeight(row)), true);
    }
  }
  table.isPivotTable() && (layoutMap.disableUseGetBodyCache(), layoutMap.disableUseHeaderPathCache());
}
function computeRowHeight(row, startCol, endCol, table) {
  var _a;
  if (!(table.isAutoRowHeight(row) || "adaptive" === table.heightMode && false !== table.options.autoHeightInAdaptiveMode) && "auto" !== table.getDefaultRowHeight(row)) return table.getDefaultRowHeight(row);
  let maxHeight;
  if (table.options.customComputeRowHeight) {
    const customRowHeight = table.options.customComputeRowHeight({
      row,
      table
    });
    if ("number" == typeof customRowHeight) return customRowHeight;
    if ("auto" !== customRowHeight) return table.getDefaultRowHeight(row);
  }
  if (table.isPivotChart() && row >= table.columnHeaderLevelCount && row < table.rowCount - table.bottomFrozenRowCount) if (table.internalProps.layoutMap.indicatorsAsCol) {
    const optimunHeight = table.internalProps.layoutMap.getOptimunHeightForChart(row);
    if (optimunHeight > 0) return optimunHeight;
  } else {
    const defaultHeight2 = table.getDefaultRowHeight(row);
    if (isNumber_default(defaultHeight2)) return defaultHeight2;
  }
  for (let col = startCol; col <= endCol; col++) {
    const customHeight = computeCustomRenderHeight(col, row, table);
    if (customHeight && (maxHeight = isValid_default(maxHeight) ? Math.max(customHeight.height, maxHeight) : customHeight.height, !customHeight.renderDefault)) continue;
    if (table.isPivotChart()) {
      const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
      if (axisConfig) {
        const axisWidth = Factory2.getFunction("computeAxisComponentHeight")(axisConfig, table);
        if ("number" == typeof axisWidth) {
          maxHeight = isValid_default(maxHeight) ? Math.max(axisWidth, maxHeight) : axisWidth;
          continue;
        }
      }
    }
    if (table.isPivotChart() && (table.isLeftFrozenColumn(col) && table.isBottomFrozenRow(row) || table.isRightFrozenColumn(col) && table.isBottomFrozenRow(row))) continue;
    const textHeight = computeTextHeight(col, row, table.isHeader(col, row) ? null === (_a = table._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.headerType : table.getBodyColumnType(col, row), table);
    maxHeight = isValid_default(maxHeight) ? Math.max(textHeight, maxHeight) : textHeight;
  }
  if (isValid_default(maxHeight)) return maxHeight;
  const defaultHeight = table.getDefaultRowHeight(row);
  return isNumber_default(defaultHeight) ? defaultHeight : table.defaultRowHeight;
}
function checkFixedStyleAndNoWrap(table, rowStart) {
  var _a, _b, _c;
  const { layoutMap } = table.internalProps, row = table.columnHeaderLevelCount;
  if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak || table.isPivotChart()) && (table.isAutoRowHeight(rowStart) || "adaptive" === table.options.heightMode)) return false;
  for (let col = 0; col < table.colCount; col++) {
    const cellDefine = layoutMap.getBody(col, row);
    if ("radio" === cellDefine.cellType) return false;
    if ("function" == typeof cellDefine.style || "function" == typeof cellDefine.icon || (null === (_a = cellDefine.define) || void 0 === _a ? void 0 : _a.customRender) || (null === (_b = cellDefine.define) || void 0 === _b ? void 0 : _b.customLayout) || "function" == typeof (null === (_c = cellDefine.define) || void 0 === _c ? void 0 : _c.icon)) return false;
    const cellStyle = table._getCellStyle(col, row);
    if ("function" == typeof cellStyle.padding || "function" == typeof cellStyle.fontSize || "function" == typeof cellStyle.lineHeight || true === cellStyle.autoWrapText) return false;
  }
  return true;
}
function checkFixedStyleAndNoWrapForTranspose(table, row) {
  var _a, _b, _c;
  const { layoutMap } = table.internalProps;
  if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak) && (table.isAutoRowHeight(row) || "adaptive" === table.options.heightMode)) return false;
  const cellDefine = layoutMap.getBody(table.rowHeaderLevelCount, row);
  if ("function" == typeof cellDefine.style || "function" == typeof cellDefine.icon || (null === (_a = cellDefine.define) || void 0 === _a ? void 0 : _a.customRender) || (null === (_b = cellDefine.define) || void 0 === _b ? void 0 : _b.customLayout) || "function" == typeof (null === (_c = cellDefine.define) || void 0 === _c ? void 0 : _c.icon)) return false;
  const cellStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
  return "function" != typeof cellStyle.padding && "function" != typeof cellStyle.fontSize && "function" != typeof cellStyle.lineHeight && true !== cellStyle.autoWrapText;
}
function checkPivotFixedStyleAndNoWrap(table, row) {
  var _a, _b, _c;
  const { layoutMap } = table.internalProps;
  if (table.internalProps.autoWrapText && (table.isAutoRowHeight(row) || "adaptive" === table.options.heightMode)) return false;
  const headerDefine = layoutMap.getHeader(table.rowHeaderLevelCount, row);
  if ("function" == typeof headerDefine.style || "function" == typeof headerDefine.icons || (null === (_a = headerDefine.define) || void 0 === _a ? void 0 : _a.headerCustomRender) || (null === (_b = headerDefine.define) || void 0 === _b ? void 0 : _b.headerCustomLayout) || "function" == typeof (null === (_c = headerDefine.define) || void 0 === _c ? void 0 : _c.icon)) return false;
  const headerStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
  return "function" != typeof headerStyle.padding && "function" != typeof headerStyle.fontSize && "function" != typeof headerStyle.lineHeight && true !== headerStyle.autoWrapText;
}
function fillRowsHeight(height, startRow, endRow, table, newHeights) {
  if (!table.internalProps.useOneRowHeightFillAll) {
    for (let row = startRow; row <= endRow; row++) newHeights ? newHeights[row] = height : table._setRowHeight(row, height);
    table.internalProps.useOneRowHeightFillAll = true;
  }
}
function computeCustomRenderHeight(col, row, table) {
  var _a, _b, _c, _d, _e, _f, _g;
  const customRender = table.getCustomRender(col, row);
  let customLayout = table.getCustomLayout(col, row);
  if (customRender || customLayout) {
    let cellRange, spanRow = 1, height = 0, renderDefault = false, enableCellPadding = false;
    (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) && (cellRange = table.getCellRange(col, row), spanRow = cellRange.end.row - cellRange.start.row + 1);
    const arg = {
      col: null !== (_b = null == cellRange ? void 0 : cellRange.start.col) && void 0 !== _b ? _b : col,
      row: null !== (_c = null == cellRange ? void 0 : cellRange.start.row) && void 0 !== _c ? _c : row,
      dataValue: table.getCellOriginValue(col, row),
      value: table.getCellValue(col, row) || "",
      rect: getCellRect(col, row, table),
      table,
      originCol: col,
      originRow: row,
      forComputation: true
    };
    if ("react-custom-layout" === customLayout && (customLayout = (null === (_d = table.reactCustomLayout) || void 0 === _d ? void 0 : _d.getCustomLayoutFunc(col, row)) || emptyCustomLayout), isFunction_default(customLayout)) {
      const customLayoutObj = customLayout(arg);
      customLayoutObj.rootContainer ? (customLayoutObj.rootContainer = decodeReactDom(customLayoutObj.rootContainer), dealPercentCalc(customLayoutObj.rootContainer, table.getColWidth(col), 0), customLayoutObj.rootContainer.setStage(table.scenegraph.stage), height = null !== (_e = customLayoutObj.rootContainer.AABBBounds.height()) && void 0 !== _e ? _e : 0, renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding) : (height = 0, renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding);
    } else if ("function" == typeof customRender) {
      const customRenderObj = customRender(arg);
      height = null !== (_f = null == customRenderObj ? void 0 : customRenderObj.expectedHeight) && void 0 !== _f ? _f : 0, renderDefault = null == customRenderObj ? void 0 : customRenderObj.renderDefault;
    } else height = null !== (_g = null == customRender ? void 0 : customRender.expectedHeight) && void 0 !== _g ? _g : 0, renderDefault = null == customRender ? void 0 : customRender.renderDefault;
    if (enableCellPadding) {
      const actStyle = table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", actStyle, col, row, table));
      height += padding[0] + padding[2];
    }
    return {
      height: height / spanRow,
      renderDefault
    };
  }
}
function computeTextHeight(col, row, cellType, table) {
  var _a, _b, _c, _d;
  let maxHeight = 0;
  const cellValue = table.getCellValue(col, row), actStyle = table._getCellStyle(col, row);
  let iconHeight = 0, iconWidth = 0;
  const iconInlineFront = [];
  let iconInlineFrontHeight = 0;
  const iconInlineEnd = [];
  let iconInlineEndHeight = 0, mayHaveIcon = false;
  if ("body" !== table.getCellLocation(col, row)) mayHaveIcon = true;
  else {
    const define = table.getBodyColumnDefine(col, row);
    mayHaveIcon = !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree) || (null == define ? void 0 : define.dragOrder);
  }
  if (mayHaveIcon) {
    const icons2 = table.getCellIcons(col, row);
    null == icons2 || icons2.forEach((icon2) => {
      var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _j, _k;
      icon2.positionType !== IconPosition.absoluteRight && icon2.positionType !== IconPosition.inlineFront && icon2.positionType !== IconPosition.inlineEnd ? (iconWidth += (null !== (_a2 = icon2.width) && void 0 !== _a2 ? _a2 : 0) + (null !== (_b2 = icon2.marginLeft) && void 0 !== _b2 ? _b2 : 0) + (null !== (_c2 = icon2.marginRight) && void 0 !== _c2 ? _c2 : 0), iconHeight = Math.max(iconHeight, null !== (_d2 = icon2.height) && void 0 !== _d2 ? _d2 : 0)) : icon2.positionType === IconPosition.inlineFront ? (iconInlineFront.push(icon2), iconInlineFrontHeight = Math.max(iconInlineFrontHeight, (null !== (_e = icon2.height) && void 0 !== _e ? _e : 0) + (null !== (_f = icon2.marginLeft) && void 0 !== _f ? _f : 0) + (null !== (_g = icon2.marginRight) && void 0 !== _g ? _g : 0))) : icon2.positionType === IconPosition.inlineEnd && (iconInlineEnd.push(icon2), iconInlineEndHeight = Math.max(iconInlineEndHeight, (null !== (_h = icon2.height) && void 0 !== _h ? _h : 0) + (null !== (_j = icon2.marginLeft) && void 0 !== _j ? _j : 0) + (null !== (_k = icon2.marginRight) && void 0 !== _k ? _k : 0)));
    });
  }
  let spanRow = 1, endCol = col;
  if (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) {
    const cellRange = table.getCellRange(col, row);
    spanRow = cellRange.end.row - cellRange.start.row + 1, col = cellRange.start.col, endCol = cellRange.end.col;
  }
  const padding = getQuadProps(getProp2("padding", actStyle, col, row, table)), fontSize = getProp2("fontSize", actStyle, col, row, table), fontStyle = getProp2("fontStyle", actStyle, col, row, table), fontWeight = getProp2("fontWeight", actStyle, col, row, table), lineHeight = null !== (_b = getProp2("lineHeight", actStyle, col, row, table)) && void 0 !== _b ? _b : fontSize, fontFamily = getProp2("fontFamily", actStyle, col, row, table), autoWrapText = getProp2("autoWrapText", actStyle, col, row, table), lineClamp = getProp2("lineClamp", actStyle, col, row, table), underline = getProp2("underline", actStyle, col, row, table), underlineOffset = null !== (_c = getProp2("underlineOffset", actStyle, col, row, table)) && void 0 !== _c ? _c : 0;
  let text2;
  if ("text" !== cellType && "link" !== cellType && "progressbar" !== cellType && "checkbox" !== cellType && "radio" !== cellType && "switch" !== cellType && "button" !== cellType) maxHeight = lineHeight;
  else if ("checkbox" === cellType) maxHeight = computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
  else if ("radio" === cellType) maxHeight = computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
  else if ("switch" === cellType) maxHeight = computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
  else if ("button" === cellType) maxHeight = computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
  else {
    text2 = cellValue;
    const lines = breakString(text2, table).text, cellWidth = table.getColsWidth(col, endCol);
    if (iconInlineFront.length || iconInlineEnd.length) if (autoWrapText) {
      const textOption = Object.assign({
        text: null == cellValue ? void 0 : cellValue.toString(),
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        lineHeight
      });
      textOption.textBaseline = "middle";
      const textConfig = [...iconInlineFront.map((icon2) => dealWithRichTextIcon(icon2)), textOption, ...iconInlineEnd.map((icon2) => dealWithRichTextIcon(icon2))];
      utilRichTextMark.setAttributes({
        width: cellWidth - (padding[1] + padding[3]) - iconWidth,
        height: 0,
        textConfig
      }), maxHeight = utilRichTextMark.AABBBounds.height();
    } else maxHeight = 0, lines.forEach((line, index) => {
      var _a2;
      (null === (_a2 = table.options.customConfig) || void 0 === _a2 ? void 0 : _a2.multilinesForXTable) && 0 !== index || (0 === index && iconInlineFront.length ? maxHeight += Math.max(lineHeight, iconInlineFrontHeight) : index === lines.length - 1 && iconInlineEnd.length ? maxHeight += Math.max(lineHeight, iconInlineEndHeight) : maxHeight += lineHeight);
    });
    else if (autoWrapText) {
      const hierarchyOffset = getHierarchyOffset(col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - hierarchyOffset, bounds = measureTextBounds({
        maxLineWidth,
        text: lines,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        wordBreak: "break-word",
        whiteSpace: 1 !== lines.length || autoWrapText ? "normal" : "no-wrap",
        lineClamp
      });
      maxHeight = (bounds.height() || ("number" == typeof lineHeight ? lineHeight : fontSize)) + (underline ? underlineOffset : 0);
    } else maxHeight = (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.multilinesForXTable) ? lineHeight : lines.length * lineHeight;
  }
  return (Math.max(maxHeight, iconHeight) + padding[0] + padding[2]) / spanRow;
}
function getCellRect(col, row, table) {
  return {
    left: 0,
    top: 0,
    right: table.getColWidth(col),
    bottom: table.getRowHeight(row),
    width: table.getColWidth(col),
    height: 0
  };
}

// node_modules/@visactor/vtable/es/tools/merge-range.js
function getCellMergeRange(cellGroup, scene) {
  if (!scene || !scene.proxy) return {
    colStart: 0,
    colEnd: 0,
    rowStart: 0,
    rowEnd: 0
  };
  const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow, col, row } = cellGroup;
  return {
    colStart: mergeStartCol,
    colEnd: mergeEndCol,
    rowStart: mergeStartRow,
    rowEnd: mergeEndRow
  };
}
function expendCellRange(cellRange, table) {
  const colStart = cellRange.start.col, colEnd = cellRange.end.col, rowStart = cellRange.start.row, rowEnd = cellRange.end.row;
  let newColStart = colStart, newColEnd = colEnd, newRowStart = rowStart, newRowEnd = rowEnd;
  for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
    const mergeRange = table.getCellRange(col, row);
    mergeRange && (newColStart = Math.min(newColStart, mergeRange.start.col), newColEnd = Math.max(newColEnd, mergeRange.end.col), newRowStart = Math.min(newRowStart, mergeRange.start.row), newRowEnd = Math.max(newRowEnd, mergeRange.end.row));
  }
  return cellRange.start.col = newColStart, cellRange.end.col = newColEnd, cellRange.start.row = newRowStart, cellRange.end.row = newRowEnd, cellRange;
}

// node_modules/@visactor/vtable/es/scenegraph/layout/update-height.js
function updateRowHeight(scene, row, detaY, skipTableHeightMap) {
  skipTableHeightMap || scene.table._setRowHeight(row, scene.table.getRowHeight(row) + detaY, true);
  for (let col = 0; col < scene.table.colCount; col++) {
    const cell = scene.getCell(col, row);
    if ("empty" === cell.role) continue;
    const mergeInfo = getCellMergeInfo(scene.table, col, row);
    if (mergeInfo && mergeInfo.start.col !== col) continue;
    updateCellHeightForRow(scene, cell, col, row, cell.attribute.height + detaY, detaY, scene.table.isHeader(col, row)), scene.updateCellContentWhileResize(col, row);
  }
  let rowStart = 0, rowEnd = 0;
  row < scene.table.frozenRowCount ? (rowStart = row + 1, rowEnd = scene.table.frozenRowCount - 1) : row >= scene.table.rowCount - scene.table.bottomFrozenRowCount ? (rowStart = row + 1, rowEnd = scene.table.rowCount - 1) : (rowStart = row + 1, rowEnd = Math.min(scene.proxy.rowEnd, scene.table.rowCount - scene.table.bottomFrozenRowCount - 1));
  for (let colIndex = 0; colIndex < scene.table.colCount; colIndex++) for (let rowIndex = rowStart; rowIndex <= rowEnd; rowIndex++) {
    const cellGroup = scene.highPerformanceGetCell(colIndex, rowIndex);
    "cell" === cellGroup.role && cellGroup.setAttribute("y", cellGroup.attribute.y + detaY);
  }
}
function updateCellHeightForRow(scene, cell, col, row, height, detaY, isHeader) {
  cell && updateCellHeight(scene, cell, col, row, height, detaY, isHeader);
}
function updateCellHeight(scene, cell, col, row, distHeight, detaY, isHeader) {
  var _a, _b, _c, _d, _e;
  if (cell.attribute.height === distHeight && !cell.needUpdateHeight) return;
  cell.needUpdateHeight = false, cell.setAttribute("height", distHeight);
  const isVtableMerge = null === (_a = scene.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge, isCustomMerge = !!scene.table.getCustomMerge(col, row), type = isVtableMerge || isCustomMerge ? "text" : scene.table.isHeader(col, row) ? null !== (_b = scene.table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _b ? _b : "text" : null !== (_c = scene.table.getBodyColumnType(col, row)) && void 0 !== _c ? _c : "text";
  if ("progressbar" === type) {
    const columnDefine = scene.table.getBodyColumnDefine(col, row), style2 = scene.table._getCellStyle(col, row), value = scene.table.getCellValue(col, row), dataValue = scene.table.getCellOriginValue(col, row), padding = getQuadProps(getProp2("padding", style2, col, row, scene.table));
    let range5;
    (null == columnDefine ? void 0 : columnDefine.mergeCell) && (range5 = scene.table.getCellRange(col, row));
    const newBarCell = Factory2.getFunction("createProgressBarCell")(columnDefine, style2, cell.attribute.width, value, dataValue, col, row, padding, scene.table, range5), oldBarCell = cell.getChildByName("progress-bar");
    cell.insertBefore(newBarCell, oldBarCell), cell.removeChild(oldBarCell), oldBarCell.removeAllChild(), oldBarCell.release(), updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), true, scene.table);
  } else if ("sparkline" === type) {
    cell.removeAllChild();
    const headerStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", headerStyle, col, row, scene.table));
    Factory2.getFunction("createSparkLineCellGroup")(cell, cell.parent, cell.attribute.x, cell.attribute.y, col, row, cell.attribute.width, cell.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp2).theme, false);
  } else if ("image" === type || "video" === type) updateImageCellContentWhileResize(cell, col, row, 0, detaY, scene.table);
  else if ("axis" === (null === (_d = cell.firstChild) || void 0 === _d ? void 0 : _d.name)) null === (_e = cell.firstChild) || void 0 === _e || _e.originAxis.resize(cell.attribute.width, cell.attribute.height);
  else {
    let renderDefault = true;
    const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) || cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
    if (customContainer) {
      let customElementsGroup;
      cell.removeChild(customContainer);
      const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
      if (customMergeRange) for (let mergeRow = customMergeRange.start.row; mergeRow <= customMergeRange.end.row; mergeRow++) {
        if (mergeRow === row) continue;
        const mergedCell = scene.getCell(col, mergeRow), customContainer2 = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) || mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
        customContainer2.removeAllChild(), mergedCell.removeChild(customContainer2), getCustomCellMergeCustom(col, mergeRow, mergedCell, scene.table);
      }
      else {
        let customRender, customLayout;
        const cellLocation = scene.table.getCellLocation(col, row), { vtableMerge } = scene.table.getCellRawRecord(col, row) || {};
        if (vtableMerge && scene.table.options.groupTitleCustomLayout) customLayout = scene.table.options.groupTitleCustomLayout;
        else if ("body" !== cellLocation) {
          const define = scene.table.getHeaderDefine(col, row);
          customRender = null == define ? void 0 : define.headerCustomRender, customLayout = null == define ? void 0 : define.headerCustomLayout;
        } else {
          const define = scene.table.getBodyColumnDefine(col, row);
          customRender = (null == define ? void 0 : define.customRender) || scene.table.customRender, customLayout = null == define ? void 0 : define.customLayout;
        }
        if ((customRender || customLayout) && isMergeCellGroup(cell)) for (let mergeCol = cell.mergeStartCol; mergeCol <= cell.mergeEndCol; mergeCol++) for (let mergeRow = cell.mergeStartRow; mergeRow <= cell.mergeEndRow; mergeRow++) mergeRow !== row && scene.updateCellContent(mergeCol, mergeRow);
        if (customLayout || customRender) {
          const style2 = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", style2, col, row, scene.table));
          let width = cell.attribute.width, height = cell.attribute.height;
          isMergeCellGroup(cell) && (width = scene.table.getColsWidth(cell.mergeStartCol, cell.mergeEndCol), height = scene.table.getRowsHeight(cell.mergeStartRow, cell.mergeEndRow));
          const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, false, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cell) ? {
            start: {
              col: cell.mergeStartCol,
              row: cell.mergeStartRow
            },
            end: {
              col: cell.mergeEndCol,
              row: cell.mergeEndRow
            }
          } : void 0, scene.table);
          customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault;
        }
        cell.childrenCount > 0 && customElementsGroup ? cell.insertBefore(customElementsGroup, cell.firstChild) : customElementsGroup && cell.appendChild(customElementsGroup);
      }
    }
    updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), renderDefault, scene.table);
  }
}
function updateMergeCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, renderDefault, table) {
  if (isMergeCellGroup(cellGroup)) {
    distHeight = 0;
    for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) distHeight += table.getRowHeight(row);
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      const singleCellGroup = table.scenegraph.getCell(col, row);
      if ("cell" !== singleCellGroup.role) continue;
      if (singleCellGroup.forEachChildren((child) => {
        child.setAttributes({
          dx: 0,
          dy: 0
        });
      }), renderDefault) {
        const style2 = table._getCellStyle(colStart, rowStart), padding = getQuadProps(getProp2("padding", style2, col, row, table));
        updateCellContentHeight(singleCellGroup, distHeight, detaY, autoRowHeight, padding, style2.textAlign, style2.textBaseline, table);
      }
      const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col);
      singleCellGroup.contentHeight = distHeight;
      const { widthChange } = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
        start: {
          col: cellGroup.mergeStartCol,
          row: cellGroup.mergeStartRow
        },
        end: {
          col: cellGroup.mergeEndCol,
          row: cellGroup.mergeEndRow
        }
      }, table);
      widthChange && (singleCellGroup.needUpdateWidth = true);
    }
  } else {
    const style2 = table._getCellStyle(cellGroup.col, cellGroup.row), padding = getQuadProps(getProp2("padding", style2, cellGroup.col, cellGroup.row, table));
    updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, style2.textAlign, style2.textBaseline, table);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/layout/update-width.js
function updateColWidth(scene, col, detaX, skipTableWidthMap) {
  skipTableWidthMap || scene.table._setColWidth(col, scene.table.getColWidth(col) + detaX, true);
  const colOrCornerHeaderColumn = scene.getColGroup(col, true), rightTopColumn = scene.getColGroupInRightTopCorner(col);
  colOrCornerHeaderColumn && !rightTopColumn && updateColunmWidth(colOrCornerHeaderColumn, detaX, "col-corner", scene), rightTopColumn && updateColunmWidth(rightTopColumn, detaX, "right-top", scene);
  const rowHeaderOrBodyColumn = scene.getColGroup(col);
  rowHeaderOrBodyColumn && updateColunmWidth(rowHeaderOrBodyColumn, detaX, "row-body", scene);
  const leftBottomColumn = scene.getColGroupInLeftBottomCorner(col);
  leftBottomColumn && updateColunmWidth(leftBottomColumn, detaX, "left-bottom", scene);
  const bottomColumn = scene.getColGroupInBottom(col);
  bottomColumn && updateColunmWidth(bottomColumn, detaX, "bottom", scene);
  const rightBottomColumn = scene.getColGroupInRightBottomCorner(col);
  rightBottomColumn && updateColunmWidth(rightBottomColumn, detaX, "right-bottom", scene), col < scene.frozenColCount ? (scene.cornerHeaderGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  }), scene.rowHeaderGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  })) : (scene.colHeaderGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  }), scene.bodyGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  })), leftBottomColumn && scene.leftBottomCornerGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  }), bottomColumn && scene.bottomFrozenGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  }), rightBottomColumn && scene.rightBottomCornerGroup.forEachChildrenSkipChild((column, index) => {
    column.col > col && column.setAttribute("x", column.attribute.x + detaX);
  });
}
function updateColunmWidth(columnGroup, detaX, mode, scene) {
  var _a, _b, _c, _d, _e, _f, _g;
  let needRerangeRow = false;
  const oldColumnWidth = null !== (_a = null == columnGroup ? void 0 : columnGroup.attribute.width) && void 0 !== _a ? _a : 0;
  if (null == columnGroup || columnGroup.setAttribute("width", oldColumnWidth + detaX), null == columnGroup || columnGroup.forEachChildren((cell, index) => {
    if (updateCellWidth(scene, cell, cell.col, cell.row, oldColumnWidth, oldColumnWidth + detaX, detaX, "row-body" !== mode || cell.col < scene.table.rowHeaderLevelCount, scene.table.internalProps.autoWrapText)) {
      const mergeInfo = getCellMergeInfo(scene.table, cell.col, cell.row);
      if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) for (let row = mergeInfo.start.row; row <= mergeInfo.end.row; row++) resetRowHeight(scene, row);
      else resetRowHeight(scene, cell.row);
      needRerangeRow = true;
    }
  }), needRerangeRow) {
    let colGroup, oldContainerHeight, row, newTotalHeight = 0;
    for (let col = 0; col < scene.table.colCount; col++) {
      if ("col-corner" === mode ? (row = 0, colGroup = scene.getColGroup(col, true), oldContainerHeight = null !== (_b = scene.colHeaderGroup.attribute.height) && void 0 !== _b ? _b : 0) : "row-body" === mode ? (row = scene.table.frozenRowCount, colGroup = scene.getColGroup(col, false), oldContainerHeight = null !== (_c = scene.bodyGroup.attribute.height) && void 0 !== _c ? _c : 0) : "bottom" === mode ? (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, colGroup = scene.getColGroupInBottom(col), oldContainerHeight = null !== (_d = scene.bottomFrozenGroup.attribute.height) && void 0 !== _d ? _d : 0) : "left-bottom" === mode ? (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, colGroup = scene.getColGroupInLeftBottomCorner(col), oldContainerHeight = null !== (_e = scene.leftBottomCornerGroup.attribute.height) && void 0 !== _e ? _e : 0) : "right-top" === mode ? (row = 0, colGroup = scene.getColGroupInRightTopCorner(col), oldContainerHeight = null !== (_f = scene.rightTopCornerGroup.attribute.height) && void 0 !== _f ? _f : 0) : "right-bottom" === mode && (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, colGroup = scene.getColGroupInRightBottomCorner(col), oldContainerHeight = null !== (_g = scene.rightBottomCornerGroup.attribute.height) && void 0 !== _g ? _g : 0), !colGroup) continue;
      let y = 0;
      colGroup.forEachChildren((cellGroup) => {
        var _a2;
        cellGroup.setAttribute("y", y), y += null !== (_a2 = scene.table.getRowHeight(cellGroup.row)) && void 0 !== _a2 ? _a2 : 0;
      }), newTotalHeight = y;
    }
    scene.updateContainerHeight(row, newTotalHeight - oldContainerHeight);
    for (let col = 0; col < scene.table.frozenColCount; col++) {
      const leftBottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
      let y = 0;
      null == leftBottomFrozenColumnGroup || leftBottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
      });
    }
    for (let col = scene.table.colCount - scene.table.rightFrozenColCount; col < scene.table.colCount; col++) {
      const rightBottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
      let y = 0;
      null == rightBottomFrozenColumnGroup || rightBottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
      });
    }
    for (let col = scene.table.frozenColCount; col < scene.table.colCount - scene.table.rightFrozenColCount; col++) {
      const rightBottomFrozenColumnGroup = scene.getColGroupInBottom(col);
      let y = 0;
      null == rightBottomFrozenColumnGroup || rightBottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
      });
    }
  }
}
function updateCellWidth(scene, cell, col, row, oldWidth, distWidth, detaX, isHeader, autoWrapText) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (cell.attribute.width === distWidth && !cell.needUpdateWidth) return false;
  cell.needUpdateWidth = false, cell.setAttribute("width", distWidth);
  const cellGroup = cell;
  if (!cellGroup) return false;
  const autoRowHeight = scene.table.isAutoRowHeight(row), isVtableMerge = null === (_a = scene.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge, isCustomMerge = !!scene.table.getCustomMerge(col, row), type = isVtableMerge || isCustomMerge ? "text" : scene.table.isHeader(col, row) ? null !== (_b = scene.table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _b ? _b : "text" : null !== (_c = scene.table.getBodyColumnType(col, row)) && void 0 !== _c ? _c : "text";
  let isHeightChange = false;
  if ("progressbar" === type) {
    const columnDefine = scene.table.getBodyColumnDefine(col, row), style2 = scene.table._getCellStyle(col, row), value = scene.table.getCellValue(col, row), dataValue = scene.table.getCellOriginValue(col, row), padding = getQuadProps(getProp2("padding", style2, col, row, scene.table));
    let range5;
    (null == columnDefine ? void 0 : columnDefine.mergeCell) && (range5 = scene.table.getCellRange(col, row));
    const newBarCell = Factory2.getFunction("createProgressBarCell")(columnDefine, style2, cellGroup.attribute.width, value, dataValue, col, row, padding, scene.table, range5), oldBarCell = cellGroup.getChildByName("progress-bar");
    cellGroup.insertBefore(newBarCell, oldBarCell), cellGroup.removeChild(oldBarCell), oldBarCell.removeAllChild(), oldBarCell.release();
    const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, true, scene.table);
    isHeightChange = isHeightChange || cellChange;
  } else if ("sparkline" === type) {
    cellGroup.removeAllChild();
    const headerStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", headerStyle, col, row, scene.table));
    Factory2.getFunction("createSparkLineCellGroup")(cellGroup, cellGroup.parent, cellGroup.attribute.x, cellGroup.attribute.y, col, row, cellGroup.attribute.width, cellGroup.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp2).theme, false);
  } else if ("image" === type || "video" === type) updateImageCellContentWhileResize(cellGroup, col, row, detaX, 0, scene.table);
  else if ("axis" === (null === (_d = cellGroup.firstChild) || void 0 === _d ? void 0 : _d.name)) {
    const axisConfig = scene.table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row), cellStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", cellStyle, col, row, scene.table));
    if (axisConfig) {
      const axis = new (Factory2.getComponent("axis"))(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, null !== (_e = axisConfig.__vtablePadding) && void 0 !== _e ? _e : padding, scene.table);
      cellGroup.clear(), cellGroup.appendChild(axis.component), axis.overlap();
    }
  } else if ("axis" === (null === (_f = cell.firstChild) || void 0 === _f ? void 0 : _f.name)) null === (_g = cell.firstChild) || void 0 === _g || _g.originAxis.resize(cell.attribute.width, cell.attribute.height);
  else {
    let renderDefault = true;
    const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) || cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
    if (customContainer) {
      let customElementsGroup;
      cell.removeChild(customContainer);
      const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
      if (customMergeRange) for (let mergeCol = customMergeRange.start.col; mergeCol <= customMergeRange.end.col; mergeCol++) {
        if (mergeCol === col) continue;
        const mergedCell = scene.getCell(mergeCol, row), customContainer2 = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) || mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
        customContainer2.removeAllChild(), mergedCell.removeChild(customContainer2), getCustomCellMergeCustom(mergeCol, row, mergedCell, scene.table);
      }
      else {
        let customRender, customLayout;
        const cellType = scene.table.getCellLocation(col, row), { vtableMerge } = scene.table.getCellRawRecord(col, row) || {};
        if (vtableMerge && scene.table.options.groupTitleCustomLayout) customLayout = scene.table.options.groupTitleCustomLayout;
        else if ("body" !== cellType) {
          const define = scene.table.getHeaderDefine(col, row);
          customRender = null == define ? void 0 : define.headerCustomRender, customLayout = null == define ? void 0 : define.headerCustomLayout;
        } else {
          const define = scene.table.getBodyColumnDefine(col, row);
          customRender = (null == define ? void 0 : define.customRender) || scene.table.customRender, customLayout = null == define ? void 0 : define.customLayout;
        }
        if ((customRender || customLayout) && isMergeCellGroup(cellGroup)) {
          for (let mergeCol = cellGroup.mergeStartCol; mergeCol <= cellGroup.mergeEndCol; mergeCol++) if (mergeCol !== col) for (let mergeRow = cellGroup.mergeStartRow; mergeRow <= cellGroup.mergeEndRow; mergeRow++) scene.updateCellContent(mergeCol, mergeRow);
        }
        if (customLayout || customRender) {
          const style2 = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", style2, col, row, scene.table));
          let width = cellGroup.attribute.width, height = cellGroup.attribute.height;
          isMergeCellGroup(cellGroup) && (width = scene.table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol), height = scene.table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow));
          const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, false, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cellGroup) ? {
            start: {
              col: cellGroup.mergeStartCol,
              row: cellGroup.mergeStartRow
            },
            end: {
              col: cellGroup.mergeEndCol,
              row: cellGroup.mergeEndRow
            }
          } : void 0, scene.table);
          customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault, isHeightChange = true;
        }
        cell.childrenCount > 0 && customElementsGroup ? cell.insertBefore(customElementsGroup, cell.firstChild) : customElementsGroup && cell.appendChild(customElementsGroup);
      }
    }
    const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, scene.table);
    isHeightChange = isHeightChange || cellChange;
  }
  if (!autoWrapText) {
    autoWrapText = scene.table._getCellStyle(col, row).autoWrapText;
  }
  return !(!autoRowHeight || !autoWrapText) && isHeightChange;
}
function updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, table) {
  if (isMergeCellGroup(cellGroup)) {
    distWidth = 0;
    let isHeightChange = false;
    for (let col = cellGroup.mergeStartCol; col <= cellGroup.mergeEndCol; col++) distWidth += table.getColWidth(col);
    let cellHeight = 0;
    for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) cellHeight += table.getRowHeight(row);
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      if (col === cellGroup.col && row !== cellGroup.row) continue;
      const singleCellGroup = table.scenegraph.getCell(col, row);
      if ("cell" !== singleCellGroup.role) continue;
      singleCellGroup.forEachChildren((child) => {
        child.setAttributes({
          dx: 0,
          dy: 0
        });
      });
      let changed = false;
      if (renderDefault) {
        const style3 = table._getCellStyle(colStart, rowStart), padding2 = getQuadProps(getProp2("padding", style3, col, row, table)), textAlign2 = style3.textAlign, textBaseline2 = style3.textBaseline;
        changed = updateCellContentWidth(singleCellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding2, textAlign2, textBaseline2, table.scenegraph);
        const hierarchyOffset = getHierarchyOffset(singleCellGroup.col, singleCellGroup.row, table);
        if (hierarchyOffset) {
          const text2 = singleCellGroup.getChildByName("text"), icon2 = singleCellGroup.getChildByName("expand") || singleCellGroup.getChildByName("collapse");
          "icon-left" !== (null == icon2 ? void 0 : icon2.role) && text2 && text2.setAttribute("dx", hierarchyOffset);
        }
      }
      const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col);
      singleCellGroup.contentWidth = distWidth;
      const { heightChange } = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
        start: {
          col: cellGroup.mergeStartCol,
          row: cellGroup.mergeStartRow
        },
        end: {
          col: cellGroup.mergeEndCol,
          row: cellGroup.mergeEndRow
        }
      }, table);
      heightChange && (singleCellGroup.needUpdateHeight = true), isHeightChange = isHeightChange || changed;
    }
    return isHeightChange;
  }
  const style2 = table._getCellStyle(cellGroup.col, cellGroup.row), padding = getQuadProps(getProp2("padding", style2, cellGroup.col, cellGroup.row, table)), textAlign = style2.textAlign, textBaseline = style2.textBaseline;
  return updateCellContentWidth(cellGroup, distWidth, table.getRowHeight(cellGroup.row), detaX, autoRowHeight, padding, textAlign, textBaseline, table.scenegraph);
}
function resetRowHeight(scene, row) {
  const maxHeight = Math.round(computeRowHeight(row, 0, scene.table.colCount - 1, scene.table));
  scene.table._setRowHeight(row, maxHeight, true);
  for (let col = 0; col < scene.table.colCount; col++) {
    const distHeight = maxHeight, cell = scene.highPerformanceGetCell(col, row);
    "empty" !== cell.role && updateCellHeightForRow(scene, cell, col, row, distHeight, distHeight - cell.attribute.height, scene.table.isHeader(col, row));
  }
}

// node_modules/@visactor/vtable/es/scenegraph/component/menu.js
var MenuType;
!function(MenuType2) {
  MenuType2.dropDown = "dropDown", MenuType2.contextmenu = "contextmenu", MenuType2.custom = "custom";
}(MenuType || (MenuType = {}));
var menuStyle = {
  fontSize: 12,
  fontFamily: "Arial,sans-serif",
  color: "#000",
  highlightColor: "#2E68CF",
  hoverBgColor: "#EEE",
  lineHeight: 30,
  bgColor: "#FFF",
  cornerRadius: 4,
  borderWidth: 0.5,
  borderColor: "#CCC",
  menuPadding: 6,
  menuItemPadding: 9,
  maxLineWidth: 200
};
var MenuHandler = class {
  constructor(table) {
    this._table = table, this._menuInstance = new Group2({
      x: 0,
      y: 0,
      fill: menuStyle.bgColor,
      stroke: menuStyle.borderColor,
      cornerRadius: menuStyle.cornerRadius,
      lineWidth: menuStyle.borderWidth
    }), this._menuInfo = {
      x: -1,
      y: -1,
      col: -1,
      row: -1,
      type: MenuType.dropDown,
      menuInfo: [],
      highlightIndex: -1
    };
  }
  bindTableComponent(componentGroup) {
    componentGroup.appendChild(this._menuInstance), this.bindEvent();
  }
  release() {
  }
  attach(x, y, col, row, type, menuInfo) {
    if (type === MenuType.dropDown && this.checkDropDownMenuChange(col, row)) {
      const tableMenuInfo = this.getMenuInfo(col, row, type);
      if (!tableMenuInfo) return;
      const { menuInfo: menuInfo2, highlightIndex } = tableMenuInfo;
      this.updateMenuInfo(col, row, type, menuInfo2, highlightIndex), this.updateMenuInstance(menuInfo2, highlightIndex);
    } else if (type === MenuType.contextmenu && this.checkContextMenuChange(x, y)) {
      const tableMenuInfo = this.getMenuInfo(col, row, type);
      if (!tableMenuInfo) return;
      const { menuInfo: menuInfo2, highlightIndex } = tableMenuInfo;
      this.updateMenuInfo(col, row, type, menuInfo2, highlightIndex), this.updateMenuInstance(menuInfo2, highlightIndex);
    }
    this.updatePosition(x - this._table.scenegraph.x, y - this._table.scenegraph.y), this.addToScene();
  }
  updateMenuInfo(col, row, type, menuInfo, highlightIndex) {
    this._menuInfo.col = col, this._menuInfo.row = row, this._menuInfo.type = type, this._menuInfo.menuInfo = menuInfo, this._menuInfo.highlightIndex = highlightIndex;
  }
  checkDropDownMenuChange(col, row) {
    const { type, col: curCol, row: curRow } = this._menuInfo;
    return type !== MenuType.dropDown || col !== curCol || row !== curRow;
  }
  checkContextMenuChange(x, y) {
    var _a;
    const { type, menuInfo } = this._menuInfo;
    return type !== MenuType.contextmenu || menuInfo !== (null === (_a = this._table.internalProps.menu) || void 0 === _a ? void 0 : _a.contextMenuItems);
  }
  updateMenuInstance(menuInfo, highlightIndex) {
    this._menuInstance.removeAllChild();
    let y = menuStyle.menuPadding;
    const x = menuStyle.menuPadding;
    let maxWidth = 0;
    menuInfo.forEach((item, index) => {
      var _a, _b;
      const isisHighlight = highlightIndex === index;
      let icon2, text2;
      "string" == typeof item ? text2 = item : "object" == typeof item && (text2 = item.text, icon2 = isisHighlight ? item.selectedIcon : item.icon);
      const group = new Group2({
        y,
        x,
        height: menuStyle.lineHeight,
        fill: menuStyle.bgColor
      });
      group.role = "menu-item", this._menuInstance.appendChild(group), group.stateProxy = (stateName) => "hover" === stateName ? {
        fill: menuStyle.hoverBgColor
      } : {
        fill: menuStyle.bgColor
      }, group.addEventListener("pointerenter", (e) => {
        group.addState("hover", true, false), this._table.scenegraph.updateNextFrame();
      }), group.addEventListener("pointerleave", (e) => {
        group.removeState("hover", false), this._table.scenegraph.updateNextFrame();
      });
      const textMark = new Text({
        x: menuStyle.menuItemPadding,
        y: menuStyle.menuItemPadding,
        fill: isisHighlight ? menuStyle.highlightColor : menuStyle.color,
        text: text2,
        textBaseline: "top",
        fontSize: menuStyle.fontSize,
        fontFamily: menuStyle.fontFamily,
        pickable: false,
        maxLineWidth: menuStyle.maxLineWidth,
        ellipsis: "…"
      });
      if (group.addChild(textMark), icon2) {
        textMark.AABBBounds.height();
        const iconWidth = null !== (_a = icon2.width) && void 0 !== _a ? _a : 16, iconHeight = null !== (_b = icon2.height) && void 0 !== _b ? _b : 16, iconMark = new Icon({
          x: menuStyle.menuItemPadding,
          y: (menuStyle.lineHeight - iconHeight) / 2,
          width: iconWidth,
          height: iconHeight,
          image: icon2.svg,
          pickable: false
        });
        iconMark.role = "menu-icon", group.insertBefore(iconMark, textMark), textMark.setAttribute("x", iconWidth + menuStyle.menuItemPadding);
      }
      maxWidth = Math.max(group.AABBBounds.width(), maxWidth), y += menuStyle.lineHeight;
    }), this._menuInstance.setAttributes({
      width: maxWidth + 2 * menuStyle.menuItemPadding + 2 * menuStyle.menuPadding,
      height: y + menuStyle.menuPadding
    }), this._menuInstance.forEachChildren((itemGroup) => {
      itemGroup.setAttribute("width", maxWidth + 2 * menuStyle.menuItemPadding);
    });
  }
  updatePosition(x, y) {
    this._menuInstance.setAttributes({
      x: this._menuInfo.type === MenuType.dropDown ? x - this._menuInstance.attribute.width : x,
      y
    }), this._menuInfo.x = MenuType.dropDown ? x - this._menuInstance.attribute.width : x, this._menuInfo.y = y;
  }
  addToScene() {
    this._table.scenegraph.updateNextFrame();
  }
  detach() {
    this._menuInstance.setAttributes({
      x: -1e3,
      y: -1e3
    }), this._table.scenegraph.updateNextFrame();
  }
  getMenuInfo(col, row, type) {
    var _a;
    if (type === MenuType.dropDown) {
      let dropDownMenu = this._table.globalDropDownMenu;
      dropDownMenu = this._table._getHeaderLayoutMap(col, row).dropDownMenu, "function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
        row,
        col,
        table: this._table
      }));
      let highlightIndex = -1;
      if (Array.isArray(dropDownMenu)) {
        for (let i = 0; i < dropDownMenu.length; i++) if (this._table._dropDownMenuIsHighlight(col, row, i)) {
          highlightIndex = i;
          break;
        }
      }
      return {
        menuInfo: dropDownMenu,
        highlightIndex
      };
    }
    if (type === MenuType.contextmenu) {
      const contextmenu = null === (_a = this._table.internalProps.menu) || void 0 === _a ? void 0 : _a.contextMenuItems;
      let menuInfo;
      if (Array.isArray(contextmenu)) menuInfo = contextmenu;
      else if ("function" == typeof contextmenu) {
        const { field } = this._table.isHeader(col, row) ? this._table.getHeaderDefine(col, row) : this._table.getBodyColumnDefine(col, row);
        menuInfo = contextmenu(field, row, col);
      }
      return {
        menuInfo,
        highlightIndex: -1
      };
    }
  }
  bindEvent() {
    this._menuInstance.addEventListener("click", (e) => {
      const { target } = e;
      if (target && "menu-item" === target.role) {
        const resultMenuInfo = this.getEventInfo(target), resultTableInfo = this._table.getMenuInfo(this._menuInfo.col, this._menuInfo.row, this._menuInfo.type), result2 = Object.assign(resultMenuInfo, resultTableInfo);
        result2.event = e.nativeEvent, this._table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, result2);
      }
    });
  }
  getEventInfo(target) {
    const parent = target.parent;
    let index = 0;
    parent.forEachChildren((child, i) => child === target && (index = i - 1, true));
    const text2 = "string" == typeof this._menuInfo.menuInfo[index] ? this._menuInfo.menuInfo[index] : this._menuInfo.menuInfo[index].text, menuKey = "string" == typeof this._menuInfo.menuInfo[index] ? text2 : this._menuInfo.menuInfo[index].menuKey || text2;
    return {
      col: this._menuInfo.col,
      row: this._menuInfo.row,
      dropDownIndex: index,
      highlight: index === this._menuInfo.highlightIndex,
      text: text2,
      menuKey
    };
  }
  get bounds() {
    return this._menuInstance.globalAABBBounds;
  }
};

// node_modules/@visactor/vtable/es/scenegraph/component/drill-icon.js
var regedIcons = get3();
var DrillIcon = class {
  constructor() {
    const iconOption = regedIcons.drillDown;
    this.icon = new Icon({
      x: -1e3,
      y: -1e3,
      image: iconOption.svg,
      width: iconOption.width,
      height: iconOption.height,
      dx: -iconOption.width / 2,
      dy: -iconOption.height / 2,
      visible: false,
      funcType: iconOption.funcType,
      cursor: iconOption.cursor
    }), this.icon.role = "icon-drill";
  }
  appand(parent) {
    parent.appendChild(this.icon);
  }
  update(visible, x, y, drillDown, drillUp, scene) {
    if (!visible || drillDown && drillUp) return this.icon.setAttributes({
      x: -1e3,
      y: -1e3,
      visible: false
    }), void scene.updateNextFrame();
    const drillDownOption = regedIcons.drillDown, drillUpOption = regedIcons.drillUp;
    this.icon.setAttributes({
      x,
      y,
      image: drillDown ? drillDownOption.svg : drillUpOption.svg,
      visible: true
    }), this.icon.loadImage(this.icon.attribute.image), scene.updateNextFrame();
  }
};

// node_modules/@visactor/vtable/es/scenegraph/component/cell-mover.js
var CellMover = class {
  constructor(table) {
    const columnMoverLineWidth = table.theme.dragHeaderSplitLine.lineWidth, columnMoverLineColor = table.theme.dragHeaderSplitLine.lineColor, columnMoverShadowBlockColor = table.theme.dragHeaderSplitLine.shadowBlockColor;
    this.columnMoverLabel = createSymbol({
      visible: false,
      pickable: false,
      x: 0,
      y: 0,
      symbolType: "triangle",
      fill: columnMoverLineColor
    }), this.columnMoverLine = createLine({
      visible: false,
      pickable: false,
      stroke: columnMoverLineColor,
      lineWidth: columnMoverLineWidth,
      x: 0,
      y: 0,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }]
    }), this.columnMoverBack = createRect({
      visible: false,
      pickable: false,
      fill: columnMoverShadowBlockColor,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.table = table;
  }
  appand(parent) {
    parent.appendChild(this.columnMoverLabel), parent.appendChild(this.columnMoverLine), parent.appendChild(this.columnMoverBack);
  }
  show(col, row, delta) {
    const cellLocation = this.table.getCellLocation(col, row), mergeInfo = getCellMergeInfo(this.table, col, row);
    mergeInfo && (col = mergeInfo.start.col, row = mergeInfo.start.row);
    let rectX = 0, rectY = 0, rectWidth = 0, rectHeight = 0, rectDx = 0, rectDy = 0, symbolX = 0, symbolY = 0, symbolRotate = Math.PI;
    const linePoints = [];
    return "columnHeader" === cellLocation ? (rectX = this.table.getColsWidth(0, col - 1) - this.table.stateManager.scroll.horizontalBarPos, rectY = this.table.getRowsHeight(0, this.table.frozenRowCount - 1), rectHeight = this.table.tableNoFrameHeight, rectWidth = mergeInfo ? this.table.getColsWidth(mergeInfo.start.col, mergeInfo.end.col) : this.table.getColWidth(col), rectDx = rectX - delta, symbolX = rectX + rectWidth, symbolY = 2, linePoints.push({
      x: 0,
      y: 0
    }), linePoints.push({
      x: 0,
      y: this.table.tableNoFrameHeight
    })) : ("rowHeader" === cellLocation || this.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) && (rectY = this.table.getRowsHeight(0, row - 1) - this.table.stateManager.scroll.verticalBarPos, rectX = this.table.getColsWidth(0, this.table.frozenColCount - 1), rectWidth = this.table.tableNoFrameWidth, rectHeight = mergeInfo ? this.table.getRowsHeight(mergeInfo.start.row, mergeInfo.end.row) : this.table.getRowHeight(row), rectDy = rectY - delta, symbolX = 2, symbolY = rectY + rectHeight, symbolRotate = Math.PI / 2, linePoints.push({
      x: 0,
      y: 0
    }), linePoints.push({
      x: this.table.tableNoFrameWidth,
      y: 0
    })), this.columnMoverBack.setAttributes({
      visible: true,
      x: rectX - rectDx,
      y: rectY - rectDy,
      width: rectWidth,
      height: rectHeight,
      dx: rectDx,
      dy: rectDy
    }), this.columnMoverLine.setAttributes({
      x: symbolX,
      y: symbolY,
      visible: true,
      points: linePoints
    }), this.columnMoverLabel.setAttributes({
      visible: true,
      x: symbolX,
      y: symbolY,
      angle: symbolRotate
    }), {
      backX: rectX - rectDx,
      lineX: symbolX,
      backY: rectY - rectDy,
      lineY: symbolY
    };
  }
  hide() {
    this.columnMoverLabel.setAttribute("visible", false), this.columnMoverLine.setAttribute("visible", false), this.columnMoverBack.setAttribute("visible", false);
  }
  update(backX, lineX, backY, lineY) {
    "number" == typeof backX && "number" == typeof lineX ? (this.columnMoverLabel.setAttribute("x", lineX), this.columnMoverLine.setAttribute("x", lineX), this.columnMoverBack.setAttribute("x", backX)) : "number" == typeof backY && "number" == typeof lineY && (this.columnMoverLabel.setAttribute("y", lineY), this.columnMoverLine.setAttribute("y", lineY), this.columnMoverBack.setAttribute("y", backY));
  }
  updateStyle() {
    const columnMoverLineWidth = this.table.theme.dragHeaderSplitLine.lineWidth, columnMoverLineColor = this.table.theme.dragHeaderSplitLine.lineColor, columnMoverShadowBlockColor = this.table.theme.dragHeaderSplitLine.shadowBlockColor;
    this.columnMoverLabel.setAttributes({
      fill: columnMoverLineColor
    }), this.columnMoverLine.setAttributes({
      stroke: columnMoverLineColor,
      lineWidth: columnMoverLineWidth
    }), this.columnMoverBack.setAttributes({
      fill: columnMoverShadowBlockColor
    });
  }
};

// node_modules/@visactor/vtable/es/scenegraph/component/util.js
function getColX(col, table, isRightFrozen) {
  if (isRightFrozen) return Math.min(table.tableNoFrameWidth, table.getAllColsWidth()) - table.getColsWidth(col, table.colCount - 1);
  let colX = table.getColsWidth(0, col);
  return col >= table.frozenColCount && (colX -= table.scrollLeft), colX;
}
function getRowY(row, table, isBottomFrozen) {
  if (isBottomFrozen) return Math.min(table.tableNoFrameWidth, table.getAllRowsHeight()) - table.getRowsHeight(row, table.rowCount - 1);
  let rowY = table.getRowsHeight(0, row);
  return row >= table.frozenRowCount && (rowY -= table.scrollTop), rowY;
}

// node_modules/@visactor/vtable/es/scenegraph/component/table-component.js
var TableComponent = class {
  constructor(table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    this.table = table;
    const theme4 = this.table.theme;
    this.createScrollBar();
    const columnResizeColor = null === (_a = theme4.columnResize) || void 0 === _a ? void 0 : _a.lineColor, columnResizeWidth = null === (_b = theme4.columnResize) || void 0 === _b ? void 0 : _b.lineWidth, columnResizeBgColor = null === (_c = theme4.columnResize) || void 0 === _c ? void 0 : _c.bgColor, columnResizeBgWidth = null === (_d = theme4.columnResize) || void 0 === _d ? void 0 : _d.width, labelVisible = null === (_f = null === (_e = theme4.columnResize) || void 0 === _e ? void 0 : _e.labelVisible) || void 0 === _f || _f, labelColor = null === (_g = theme4.columnResize) || void 0 === _g ? void 0 : _g.labelColor, labelFontSize = null === (_h = theme4.columnResize) || void 0 === _h ? void 0 : _h.labelFontSize, labelFontFamily = null === (_j = theme4.columnResize) || void 0 === _j ? void 0 : _j.labelFontFamily, labelBackgroundFill = null === (_k = theme4.columnResize) || void 0 === _k ? void 0 : _k.labelBackgroundFill, labelBackgroundCornerRadius = null === (_l = theme4.columnResize) || void 0 === _l ? void 0 : _l.labelBackgroundCornerRadius;
    this.labelVisible = labelVisible, this.columnResizeLine = createLine({
      visible: false,
      pickable: false,
      stroke: columnResizeColor,
      lineWidth: columnResizeWidth,
      x: 0,
      y: 0,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }]
    }), this.columnResizeBgLine = createLine({
      visible: false,
      pickable: false,
      stroke: columnResizeBgColor,
      lineWidth: columnResizeBgWidth,
      x: 0,
      y: 0,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }]
    });
    const columnResizeLabelText = createText({
      visible: false,
      pickable: false,
      x: 0,
      y: 0,
      fontSize: labelFontSize,
      fill: labelColor,
      fontFamily: labelFontFamily,
      text: "",
      textBaseline: "top",
      dx: 16,
      dy: -labelFontSize / 2
    }), columnResizeLabelBack = createRect({
      visible: false,
      pickable: false,
      fill: labelBackgroundFill,
      x: 0,
      y: 0,
      width: 5 * labelFontSize * 0.8,
      height: labelFontSize + 8,
      cornerRadius: labelBackgroundCornerRadius,
      dx: 12,
      dy: -labelFontSize / 2 - 4
    });
    this.columnResizeLabel = createGroup({
      visible: false,
      pickable: false,
      x: 0,
      y: 0
    }), this.columnResizeLabel.appendChild(columnResizeLabelBack), this.columnResizeLabel.appendChild(columnResizeLabelText), this.rowResizeLine = createLine({
      visible: false,
      pickable: false,
      stroke: columnResizeColor,
      lineWidth: columnResizeWidth,
      x: 0,
      y: 0,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }]
    }), this.rowResizeBgLine = createLine({
      visible: false,
      pickable: false,
      stroke: columnResizeBgColor,
      lineWidth: columnResizeBgWidth,
      x: 0,
      y: 0,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }]
    });
    const rowResizeLabelText = createText({
      visible: false,
      pickable: false,
      x: 0,
      y: 0,
      fontSize: labelFontSize,
      fill: labelColor,
      fontFamily: labelFontFamily,
      text: "",
      textBaseline: "top",
      dx: 16,
      dy: -labelFontSize / 2
    }), rowResizeLabelBack = createRect({
      visible: false,
      pickable: false,
      fill: labelBackgroundFill,
      x: 0,
      y: 0,
      width: 5 * labelFontSize * 0.8,
      height: labelFontSize + 8,
      cornerRadius: labelBackgroundCornerRadius,
      dx: 12,
      dy: -labelFontSize / 2 - 4
    });
    this.rowResizeLabel = createGroup({
      visible: false,
      pickable: false,
      x: 0,
      y: 0
    }), this.rowResizeLabel.appendChild(rowResizeLabelBack), this.rowResizeLabel.appendChild(rowResizeLabelText), this.cellMover = new CellMover(this.table);
    const shadowWidth = null === (_o = null === (_m = theme4.frozenColumnLine) || void 0 === _m ? void 0 : _m.shadow) || void 0 === _o ? void 0 : _o.width, shadowStartColor = null === (_q = null === (_p = theme4.frozenColumnLine) || void 0 === _p ? void 0 : _p.shadow) || void 0 === _q ? void 0 : _q.startColor, shadowEndColor = null === (_s = null === (_r = theme4.frozenColumnLine) || void 0 === _r ? void 0 : _r.shadow) || void 0 === _s ? void 0 : _s.endColor, visible = null === (_u = null === (_t = theme4.frozenColumnLine) || void 0 === _t ? void 0 : _t.shadow) || void 0 === _u ? void 0 : _u.visible;
    this.frozenShadowLine = createRect({
      visible: "always" === visible,
      pickable: false,
      x: 0,
      y: 0,
      width: shadowWidth,
      height: 0,
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops: [{
          color: shadowStartColor,
          offset: 0
        }, {
          color: shadowEndColor,
          offset: 1
        }]
      }
    }), this.rightFrozenShadowLine = createRect({
      visible: "always" === visible,
      pickable: false,
      x: 0,
      y: 0,
      width: shadowWidth,
      height: 0,
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops: [{
          color: shadowEndColor,
          offset: 0
        }, {
          color: shadowStartColor,
          offset: 1
        }]
      }
    }), this.menu = new MenuHandler(this.table), this.drillIcon = new DrillIcon();
  }
  addToGroup(componentGroup) {
    componentGroup.addChild(this.frozenShadowLine), componentGroup.addChild(this.rightFrozenShadowLine), componentGroup.addChild(this.columnResizeBgLine), componentGroup.addChild(this.columnResizeLine), componentGroup.addChild(this.columnResizeLabel), componentGroup.addChild(this.rowResizeBgLine), componentGroup.addChild(this.rowResizeLine), componentGroup.addChild(this.rowResizeLabel);
    this.table.theme.scrollStyle.hoverOn && !this.table.theme.scrollStyle.barToSide ? (componentGroup.addChild(this.hScrollBar), componentGroup.addChild(this.vScrollBar)) : (componentGroup.stage.defaultLayer.addChild(this.hScrollBar), componentGroup.stage.defaultLayer.addChild(this.vScrollBar)), this.menu.bindTableComponent(componentGroup), this.drillIcon.appand(componentGroup), this.cellMover.appand(componentGroup);
  }
  createScrollBar() {
    var _a, _b, _c, _d, _e, _f;
    const theme4 = this.table.theme, scrollRailColor = null === (_a = theme4.scrollStyle) || void 0 === _a ? void 0 : _a.scrollRailColor, scrollSliderColor = null === (_b = theme4.scrollStyle) || void 0 === _b ? void 0 : _b.scrollSliderColor, scrollSliderCornerRadius = null === (_c = theme4.scrollStyle) || void 0 === _c ? void 0 : _c.scrollSliderCornerRadius, width = null === (_d = theme4.scrollStyle) || void 0 === _d ? void 0 : _d.width, horizontalPadding = null === (_e = theme4.scrollStyle) || void 0 === _e ? void 0 : _e.horizontalPadding, verticalPadding = null === (_f = theme4.scrollStyle) || void 0 === _f ? void 0 : _f.verticalPadding;
    let sliderStyle;
    sliderStyle = isValid_default(scrollSliderCornerRadius) ? {
      cornerRadius: scrollSliderCornerRadius,
      fill: scrollSliderColor
    } : {
      fill: scrollSliderColor
    }, this.hScrollBar = new ScrollBar({
      direction: "horizontal",
      x: 2 * -this.table.tableNoFrameWidth,
      y: 2 * -this.table.tableNoFrameHeight,
      width: this.table.tableNoFrameWidth,
      height: width,
      padding: horizontalPadding,
      railStyle: {
        fill: scrollRailColor
      },
      sliderStyle,
      range: [0, 0.1],
      visible: false
    }), this.hScrollBar.render(), this.hScrollBar.hideAll(), this.vScrollBar = new ScrollBar({
      direction: "vertical",
      x: 2 * -this.table.tableNoFrameWidth,
      y: 2 * -this.table.tableNoFrameHeight,
      width,
      height: this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight(),
      padding: verticalPadding,
      railStyle: {
        fill: scrollRailColor
      },
      sliderStyle,
      range: [0, 0.1],
      visible: false
    }), this.vScrollBar.render(), this.vScrollBar.hideAll();
  }
  updateScrollBar() {
    var _a, _b, _c, _d, _e, _f, _g;
    const oldHorizontalBarPos = this.table.stateManager.scroll.horizontalBarPos, oldVerticalBarPos = this.table.stateManager.scroll.verticalBarPos, theme4 = this.table.theme, width = null === (_a = theme4.scrollStyle) || void 0 === _a ? void 0 : _a.width, visible1 = null === (_b = theme4.scrollStyle) || void 0 === _b ? void 0 : _b.visible, horizontalVisible = null !== (_d = null === (_c = theme4.scrollStyle) || void 0 === _c ? void 0 : _c.horizontalVisible) && void 0 !== _d ? _d : visible1, verticalVisible = null !== (_f = null === (_e = theme4.scrollStyle) || void 0 === _e ? void 0 : _e.verticalVisible) && void 0 !== _f ? _f : visible1, tableWidth = Math.ceil(this.table.scenegraph.tableGroup.attribute.width), tableHeight = Math.ceil(this.table.scenegraph.tableGroup.attribute.height), totalHeight = this.table.getAllRowsHeight(), totalWidth = this.table.getAllColsWidth(), frozenRowsHeight = this.table.getFrozenRowsHeight(), frozenColsWidth = this.table.getFrozenColsWidth(), bottomFrozenRowsHeight = this.table.getBottomFrozenRowsHeight(), rightFrozenColsWidth = this.table.getRightFrozenColsWidth(), sizeTolerance = (null === (_g = this.table.options.customConfig) || void 0 === _g ? void 0 : _g._disableColumnAndRowSizeRound) ? 1 : 0;
    if (totalWidth > tableWidth + sizeTolerance) {
      const y = Math.min(tableHeight, totalHeight), rangeEnd = Math.max(0.05, (tableWidth - frozenColsWidth) / (totalWidth - frozenColsWidth)), hoverOn = this.table.theme.scrollStyle.hoverOn;
      let attrY = 0;
      attrY = this.table.theme.scrollStyle.barToSide ? this.table.tableNoFrameHeight - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.y) + this.table.tableY : y - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.y), this.hScrollBar.setAttributes({
        x: frozenColsWidth + (hoverOn ? 0 : this.table.scenegraph.tableGroup.attribute.x),
        y: attrY,
        width: tableWidth - frozenColsWidth - rightFrozenColsWidth,
        range: [0, rangeEnd],
        visible: "always" === horizontalVisible
      });
      const bounds = this.hScrollBar.AABBBounds && this.hScrollBar.globalAABBBounds;
      this.hScrollBar._viewPosition = {
        x: bounds.x1,
        y: bounds.y1
      }, "always" === horizontalVisible && this.hScrollBar.showAll();
    } else this.hScrollBar.setAttributes({
      x: 2 * -this.table.tableNoFrameWidth,
      y: 2 * -this.table.tableNoFrameHeight,
      width: 0,
      visible: false
    });
    if (totalHeight > tableHeight + sizeTolerance) {
      const x = Math.min(tableWidth, totalWidth), rangeEnd = Math.max(0.05, (tableHeight - frozenRowsHeight) / (totalHeight - frozenRowsHeight));
      let attrX = 0;
      const hoverOn = this.table.theme.scrollStyle.hoverOn;
      attrX = this.table.theme.scrollStyle.barToSide ? this.table.tableNoFrameWidth - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.x) + this.table.tableX : x - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.x), this.vScrollBar.setAttributes({
        x: attrX,
        y: frozenRowsHeight + (hoverOn ? 0 : this.table.scenegraph.tableGroup.attribute.y),
        height: tableHeight - frozenRowsHeight - bottomFrozenRowsHeight,
        range: [0, rangeEnd],
        visible: "always" === verticalVisible
      });
      const bounds = this.vScrollBar.AABBBounds && this.vScrollBar.globalAABBBounds;
      this.vScrollBar._viewPosition = {
        x: bounds.x1,
        y: bounds.y1
      }, "always" === verticalVisible && this.vScrollBar.showAll();
    } else this.vScrollBar.setAttributes({
      x: 2 * -this.table.tableNoFrameWidth,
      y: 2 * -this.table.tableNoFrameHeight,
      height: 0,
      visible: false
    });
    this.table.stateManager.setScrollLeft(oldHorizontalBarPos), this.table.stateManager.setScrollTop(oldVerticalBarPos);
  }
  hideResizeCol() {
    this.columnResizeLine.setAttribute("visible", false), this.columnResizeBgLine.setAttribute("visible", false), this.columnResizeLabel.setAttribute("visible", false), this.columnResizeLabel.hideAll();
  }
  showResizeCol(col, y, isRightFrozen) {
    const colX = getColX(col, this.table, isRightFrozen);
    this.columnResizeLine.setAttributes({
      visible: true,
      x: colX,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: this.table.getRowsHeight(0, this.table.rowCount - 1)
      }]
    }), this.columnResizeBgLine.setAttributes({
      visible: true,
      x: colX,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: this.table.getRowsHeight(0, this.table.rowCount - 1)
      }]
    }), this.labelVisible && (this.columnResizeLabel.showAll(), this.columnResizeLabel.setAttributes({
      visible: true,
      x: colX,
      y
    }), this.columnResizeLabel.lastChild.setAttribute("text", `${this.table.getColWidth(col)}px`));
  }
  updateResizeCol(col, y, isRightFrozen) {
    const colX = getColX(col, this.table, isRightFrozen);
    this.columnResizeLine.setAttributes({
      x: colX,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: this.table.getRowsHeight(0, this.table.rowCount - 1)
      }]
    }), this.columnResizeBgLine.setAttributes({
      x: colX,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: this.table.getRowsHeight(0, this.table.rowCount - 1)
      }]
    }), this.labelVisible && (this.columnResizeLabel.setAttributes({
      x: colX,
      y
    }), this.columnResizeLabel.lastChild.setAttribute("text", `${Math.floor(this.table.getColWidth(col))}px`));
  }
  hideResizeRow() {
    this.rowResizeLine.setAttribute("visible", false), this.rowResizeBgLine.setAttribute("visible", false), this.rowResizeLabel.setAttribute("visible", false), this.rowResizeLabel.hideAll();
  }
  showResizeRow(row, x, isRightFrozen) {
    const rowY = getRowY(row, this.table, isRightFrozen);
    this.rowResizeLine.setAttributes({
      visible: true,
      y: rowY,
      points: [{
        y: 0,
        x: 0
      }, {
        y: 0,
        x: this.table.getColsWidth(0, this.table.colCount - 1)
      }]
    }), this.rowResizeBgLine.setAttributes({
      visible: true,
      y: rowY,
      points: [{
        y: 0,
        x: 0
      }, {
        y: 0,
        x: this.table.getColsWidth(0, this.table.colCount - 1)
      }]
    }), this.labelVisible && (this.rowResizeLabel.showAll(), this.rowResizeLabel.setAttributes({
      visible: true,
      y: rowY,
      x
    }), this.rowResizeLabel.lastChild.setAttribute("text", `${this.table.getRowHeight(row)}px`));
  }
  updateResizeRow(row, x, isBottomFrozen) {
    const rowY = getRowY(row, this.table, isBottomFrozen);
    this.rowResizeLine.setAttributes({
      y: rowY,
      points: [{
        y: 0,
        x: 0
      }, {
        y: 0,
        x: this.table.getColsWidth(0, this.table.colCount - 1)
      }]
    }), this.rowResizeBgLine.setAttributes({
      y: rowY,
      points: [{
        y: 0,
        x: 0
      }, {
        y: 0,
        x: this.table.getColsWidth(0, this.table.colCount - 1)
      }]
    }), this.labelVisible && (this.rowResizeLabel.setAttributes({
      y: rowY,
      x
    }), this.rowResizeLabel.lastChild.setAttribute("text", `${Math.floor(this.table.getRowHeight(row))}px`));
  }
  hideMoveCol() {
    this.cellMover.hide();
  }
  showMoveCol(col, row, delta) {
    return this.cellMover.show(col, row, delta);
  }
  updateMoveCol(backX, lineX, backY, lineY) {
    this.cellMover.update(backX, lineX, backY, lineY);
  }
  setFrozenColumnShadow(col, isRightFrozen) {
    var _a, _b;
    const colX = getColX(col, this.table, isRightFrozen);
    col < 0 || "always" !== (null === (_b = null === (_a = this.table.theme.frozenColumnLine) || void 0 === _a ? void 0 : _a.shadow) || void 0 === _b ? void 0 : _b.visible) ? this.frozenShadowLine.setAttributes({
      visible: false,
      x: colX,
      height: this.table.getDrawRange().height
    }) : this.frozenShadowLine.setAttributes({
      visible: true,
      x: colX,
      height: this.table.getDrawRange().height
    });
  }
  setRightFrozenColumnShadow(col) {
    var _a, _b;
    const colX = getColX(col, this.table, true);
    col >= this.table.colCount || "always" !== (null === (_b = null === (_a = this.table.theme.frozenColumnLine) || void 0 === _a ? void 0 : _a.shadow) || void 0 === _b ? void 0 : _b.visible) ? this.rightFrozenShadowLine.setAttributes({
      visible: false,
      x: colX - this.rightFrozenShadowLine.attribute.width,
      height: this.table.getDrawRange().height
    }) : this.rightFrozenShadowLine.setAttributes({
      visible: true,
      x: colX - this.rightFrozenShadowLine.attribute.width,
      height: this.table.getDrawRange().height
    });
  }
  hideFrozenColumnShadow() {
    var _a, _b, _c, _d, _e;
    const visible1 = null === (_b = null === (_a = this.table.theme.frozenColumnLine) || void 0 === _a ? void 0 : _a.shadow) || void 0 === _b ? void 0 : _b.visible;
    "scrolling" === (null !== (_e = null === (_d = null === (_c = this.table.theme.frozenColumnLine) || void 0 === _c ? void 0 : _c.shadow) || void 0 === _d ? void 0 : _d.visible) && void 0 !== _e ? _e : visible1) && (this.frozenShadowLine.setAttribute("visible", false), this.rightFrozenShadowLine.setAttribute("visible", false), this.table.scenegraph.updateNextFrame());
  }
  showFrozenColumnShadow() {
    var _a, _b, _c, _d, _e;
    const visible1 = null === (_b = null === (_a = this.table.theme.frozenColumnLine) || void 0 === _a ? void 0 : _a.shadow) || void 0 === _b ? void 0 : _b.visible;
    "scrolling" === (null !== (_e = null === (_d = null === (_c = this.table.theme.frozenColumnLine) || void 0 === _c ? void 0 : _c.shadow) || void 0 === _d ? void 0 : _d.visible) && void 0 !== _e ? _e : visible1) && (this.frozenShadowLine.setAttribute("visible", true), this.rightFrozenShadowLine.setAttribute("visible", true), this.table.scenegraph.updateNextFrame());
  }
  hideVerticalScrollBar() {
    var _a;
    const visible1 = this.table.theme.scrollStyle.visible, verticalVisible = null !== (_a = this.table.theme.scrollStyle.verticalVisible) && void 0 !== _a ? _a : visible1;
    "focus" !== verticalVisible && "scrolling" !== verticalVisible || (this.vScrollBar.setAttribute("visible", false), this.vScrollBar.hideAll(), this.table.scenegraph.updateNextFrame());
  }
  showVerticalScrollBar() {
    var _a;
    const visible1 = this.table.theme.scrollStyle.visible, verticalVisible = null !== (_a = this.table.theme.scrollStyle.verticalVisible) && void 0 !== _a ? _a : visible1;
    "focus" !== verticalVisible && "scrolling" !== verticalVisible || (this.vScrollBar.setAttribute("visible", true), this.vScrollBar.showAll(), this.table.scenegraph.updateNextFrame());
  }
  hideHorizontalScrollBar() {
    var _a;
    const visible1 = this.table.theme.scrollStyle.visible, horizontalVisible = null !== (_a = this.table.theme.scrollStyle.horizontalVisible) && void 0 !== _a ? _a : visible1;
    "focus" !== horizontalVisible && "scrolling" !== horizontalVisible || (this.hScrollBar.setAttribute("visible", false), this.hScrollBar.hideAll(), this.table.scenegraph.updateNextFrame());
  }
  showHorizontalScrollBar() {
    var _a;
    const visible1 = this.table.theme.scrollStyle.visible, horizontalVisible = null !== (_a = this.table.theme.scrollStyle.horizontalVisible) && void 0 !== _a ? _a : visible1;
    "focus" !== horizontalVisible && "scrolling" !== horizontalVisible || (this.hScrollBar.setAttribute("visible", true), this.hScrollBar.showAll(), this.table.scenegraph.updateNextFrame());
  }
  updateVerticalScrollBarPos(topRatio) {
    const range5 = this.vScrollBar.attribute.range, size = range5[1] - range5[0], range0 = topRatio * (1 - size);
    this.vScrollBar.setAttribute("range", [range0, range0 + size]);
    const bounds = this.vScrollBar.AABBBounds && this.vScrollBar.globalAABBBounds;
    this.vScrollBar._viewPosition = {
      x: bounds.x1,
      y: bounds.y1
    };
  }
  updateHorizontalScrollBarPos(leftRatio) {
    const range5 = this.hScrollBar.attribute.range, size = range5[1] - range5[0], range0 = leftRatio * (1 - size);
    this.hScrollBar.setAttribute("range", [range0, range0 + size]);
    const bounds = this.hScrollBar.AABBBounds && this.hScrollBar.globalAABBBounds;
    this.hScrollBar._viewPosition = {
      x: bounds.x1,
      y: bounds.y1
    };
  }
  updateStyle() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const theme4 = this.table.theme, scrollRailColor = null === (_a = theme4.scrollStyle) || void 0 === _a ? void 0 : _a.scrollRailColor, scrollSliderColor = null === (_b = theme4.scrollStyle) || void 0 === _b ? void 0 : _b.scrollSliderColor, scrollSliderCornerRadius = null === (_c = theme4.scrollStyle) || void 0 === _c ? void 0 : _c.scrollSliderCornerRadius, width = null === (_d = theme4.scrollStyle) || void 0 === _d ? void 0 : _d.width, horizontalPadding = null === (_e = theme4.scrollStyle) || void 0 === _e ? void 0 : _e.horizontalPadding, verticalPadding = null === (_f = theme4.scrollStyle) || void 0 === _f ? void 0 : _f.verticalPadding;
    let sliderStyle;
    sliderStyle = isValid_default(scrollSliderCornerRadius) ? {
      cornerRadius: scrollSliderCornerRadius,
      fill: scrollSliderColor
    } : {
      fill: scrollSliderColor
    }, this.hScrollBar.setAttributes({
      height: width,
      padding: horizontalPadding,
      railStyle: {
        fill: scrollRailColor
      },
      sliderStyle
    }), this.vScrollBar.setAttributes({
      width,
      padding: verticalPadding,
      railStyle: {
        fill: scrollRailColor
      },
      sliderStyle
    });
    const columnResizeColor = null === (_g = theme4.columnResize) || void 0 === _g ? void 0 : _g.lineColor, columnResizeWidth = null === (_h = theme4.columnResize) || void 0 === _h ? void 0 : _h.lineWidth, columnResizeBgColor = null === (_j = theme4.columnResize) || void 0 === _j ? void 0 : _j.bgColor, columnResizeBgWidth = null === (_k = theme4.columnResize) || void 0 === _k ? void 0 : _k.width;
    this.columnResizeLine.setAttributes({
      stroke: columnResizeColor,
      lineWidth: columnResizeWidth
    }), this.columnResizeBgLine = createLine({
      stroke: columnResizeBgColor,
      lineWidth: columnResizeBgWidth
    });
    const labelColor = null === (_l = theme4.columnResize) || void 0 === _l ? void 0 : _l.labelColor, labelFontSize = null === (_m = theme4.columnResize) || void 0 === _m ? void 0 : _m.labelFontSize, labelFontFamily = null === (_o = theme4.columnResize) || void 0 === _o ? void 0 : _o.labelFontFamily, labelBackgroundFill = null === (_p = theme4.columnResize) || void 0 === _p ? void 0 : _p.labelBackgroundFill, labelBackgroundCornerRadius = null === (_q = theme4.columnResize) || void 0 === _q ? void 0 : _q.labelBackgroundCornerRadius, labelVisible = null === (_s = null === (_r = theme4.columnResize) || void 0 === _r ? void 0 : _r.labelVisible) || void 0 === _s || _s;
    this.labelVisible = labelVisible, this.columnResizeLabel.lastChild.setAttributes({
      fontSize: labelFontSize,
      fill: labelColor,
      fontFamily: labelFontFamily,
      dy: -labelFontSize / 2
    }), this.columnResizeLabel.firstChild.setAttributes({
      fill: labelBackgroundFill,
      width: 5 * labelFontSize * 0.8,
      height: labelFontSize + 8,
      cornerRadius: labelBackgroundCornerRadius,
      dy: -labelFontSize / 2 - 4
    }), this.rowResizeLabel.lastChild.setAttributes({
      fontSize: labelFontSize,
      fill: labelColor,
      fontFamily: labelFontFamily,
      dy: -labelFontSize / 2
    }), this.rowResizeLabel.firstChild.setAttributes({
      fill: labelBackgroundFill,
      width: 5 * labelFontSize * 0.8,
      height: labelFontSize + 8,
      cornerRadius: labelBackgroundCornerRadius,
      dy: -labelFontSize / 2 - 4
    });
    const shadowWidth = null === (_u = null === (_t = theme4.frozenColumnLine) || void 0 === _t ? void 0 : _t.shadow) || void 0 === _u ? void 0 : _u.width, shadowStartColor = null === (_w = null === (_v = theme4.frozenColumnLine) || void 0 === _v ? void 0 : _v.shadow) || void 0 === _w ? void 0 : _w.startColor, shadowEndColor = null === (_y = null === (_x = theme4.frozenColumnLine) || void 0 === _x ? void 0 : _x.shadow) || void 0 === _y ? void 0 : _y.endColor;
    this.frozenShadowLine.setAttributes({
      width: shadowWidth,
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops: [{
          color: shadowStartColor,
          offset: 0
        }, {
          color: shadowEndColor,
          offset: 1
        }]
      }
    }), this.rightFrozenShadowLine.setAttributes({
      width: shadowWidth,
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops: [{
          color: shadowEndColor,
          offset: 0
        }, {
          color: shadowStartColor,
          offset: 1
        }]
      }
    }), this.cellMover.updateStyle();
  }
};

// node_modules/@visactor/vtable/es/scenegraph/style/frame-border.js
function createFrameBorder(group, frameTheme, role, strokeArray, justForXYPosition) {
  var _a, _b, _c, _d, _e, _f;
  if (!frameTheme) return;
  const isTableGroup = "table" === role, { shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor, cornerRadius, borderColor, borderLineWidth, borderLineDash } = frameTheme;
  let hasShadow = false;
  const groupAttributes = {}, rectAttributes = {
    pickable: false
  };
  shadowBlur && isTableGroup && (rectAttributes.shadowBlur = shadowBlur, rectAttributes.shadowOffsetX = shadowOffsetX, rectAttributes.shadowOffsetY = shadowOffsetY, rectAttributes.shadowColor = shadowColor, rectAttributes.stroke = true, rectAttributes.stroke = shadowColor, rectAttributes.lineWidth = 1, hasShadow = true), borderLineWidth && (rectAttributes.stroke = true, rectAttributes.fill = false, rectAttributes.stroke = getStroke(null != borderColor ? borderColor : "#E1E4E8", strokeArray, borderLineWidth), rectAttributes.lineWidth = borderLineWidth, borderLineDash && (rectAttributes.lineDash = borderLineDash), rectAttributes.lineCap = "butt"), Array.isArray(borderColor) && (rectAttributes.strokeArrayColor = getQuadProps(borderColor)), Array.isArray(borderLineWidth) && (rectAttributes.strokeArrayWidth = getQuadProps(borderLineWidth), rectAttributes.lineWidth = 1), cornerRadius && (rectAttributes.cornerRadius = cornerRadius, groupAttributes.cornerRadius = cornerRadius);
  const borderTop = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[0] : null !== (_a = rectAttributes.lineWidth) && void 0 !== _a ? _a : 0, borderRight = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[1] : null !== (_b = rectAttributes.lineWidth) && void 0 !== _b ? _b : 0, borderBottom = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[2] : null !== (_c = rectAttributes.lineWidth) && void 0 !== _c ? _c : 0, borderLeft = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[3] : null !== (_d = rectAttributes.lineWidth) && void 0 !== _d ? _d : 0;
  if (group.setAttributes(groupAttributes), !justForXYPosition) if (rectAttributes.stroke) if (rectAttributes.x = borderLeft / 2, rectAttributes.y = borderTop / 2, rectAttributes.pickable = false, isTableGroup) {
    if (cornerRadius) if (Array.isArray(cornerRadius)) {
      const cornerRadiusArr = getQuadProps(cornerRadius);
      rectAttributes.cornerRadius = cornerRadiusArr, groupAttributes.cornerRadius = cornerRadiusArr, cornerRadiusArr[0] && (cornerRadiusArr[0] = cornerRadiusArr[0] + Math.min(borderLeft, borderTop) / 2), cornerRadiusArr[1] && (cornerRadiusArr[1] = cornerRadiusArr[1] + Math.min(borderTop, borderRight) / 2), cornerRadiusArr[2] && (cornerRadiusArr[2] = cornerRadiusArr[2] + Math.min(borderRight, borderBottom) / 2), cornerRadiusArr[3] && (cornerRadiusArr[3] = cornerRadiusArr[3] + Math.min(borderBottom, borderLeft) / 2);
    } else if (isArray_default(borderLineWidth)) {
      const cornerRadiusArr = [];
      rectAttributes.cornerRadius = cornerRadiusArr, groupAttributes.cornerRadius = cornerRadiusArr, cornerRadiusArr[0] = cornerRadius + Math.min(borderLeft, borderTop) / 2, cornerRadiusArr[1] = cornerRadius + Math.min(borderTop, borderRight) / 2, cornerRadiusArr[2] = cornerRadius + Math.min(borderRight, borderBottom) / 2, cornerRadiusArr[3] = cornerRadius + Math.min(borderBottom, borderLeft) / 2;
    } else rectAttributes.cornerRadius = cornerRadius + (null !== (_e = rectAttributes.lineWidth) && void 0 !== _e ? _e : 0) / 2, groupAttributes.cornerRadius = cornerRadius + (null !== (_f = rectAttributes.lineWidth) && void 0 !== _f ? _f : 0) / 2;
    let shadowRect, borderRect;
    if (frameTheme.innerBorder ? (rectAttributes.x = group.attribute.x + borderLeft / 2, rectAttributes.y = group.attribute.y + borderTop / 2, rectAttributes.width = group.attribute.width - borderLeft / 2 - borderRight / 2, rectAttributes.height = group.attribute.height - borderTop / 2 - borderBottom / 2) : (rectAttributes.x = group.attribute.x - borderLeft / 2, rectAttributes.y = group.attribute.y - borderTop / 2, rectAttributes.width = group.attribute.width + borderLeft / 2 + borderRight / 2, rectAttributes.height = group.attribute.height + borderTop / 2 + borderBottom / 2), hasShadow) {
      rectAttributes.fill = "white", rectAttributes.notAdjustPos = true, borderRect = createGroup(rectAttributes), borderRect.name = "table-border-rect", shadowRect = createRect({
        x: borderLeft / 2,
        y: borderTop / 2,
        width: group.attribute.width,
        height: group.attribute.height,
        fill: "red",
        cornerRadius: group.attribute.cornerRadius,
        globalCompositeOperation: "destination-out"
      }), borderRect.addChild(shadowRect);
      const hackRect = createRect({
        x: borderLeft / 2,
        y: borderTop / 2,
        width: group.attribute.width,
        height: group.attribute.height,
        fill: "transparent",
        pickable: false,
        globalCompositeOperation: "source-over"
      });
      borderRect.addChild(hackRect);
    } else borderRect = createRect(rectAttributes), borderRect.name = "table-border-rect";
    frameTheme.innerBorder && !hasShadow ? group.parent.insertAfter(borderRect, group) : group.parent.insertBefore(borderRect, group), group.border = borderRect;
  } else {
    rectAttributes.width = group.attribute.width - borderLeft / 2 - borderRight / 2, rectAttributes.height = group.attribute.height - borderTop / 2 - borderBottom / 2;
    const borderRect = createRect(rectAttributes);
    borderRect.name = "border-rect", group.addChild(borderRect), group.border = borderRect;
  }
  else {
    const borderRect = createRect({
      fill: false,
      stroke: false,
      pickable: false,
      lineWidth: 0
    });
    borderRect.name = "border-rect", group.addChild(borderRect), group.border = borderRect;
  }
}
function updateFrameBorder(group, frameTheme, strokeArray) {
  var _a;
  if (!frameTheme) return;
  const { borderColor } = frameTheme;
  null === (_a = group.border) || void 0 === _a || _a.setAttribute("stroke", getStroke(borderColor, strokeArray));
}
function getStroke(borderColor, strokeArray, strokeLineWidth) {
  let stroke2 = true;
  return !strokeArray && !isArray_default(strokeLineWidth) || isArray_default(borderColor) ? strokeArray ? stroke2 = strokeArray : strokeArray || isArray_default(borderColor) ? isArray_default(borderColor) && (stroke2 = true) : stroke2 = borderColor : stroke2 = (null != strokeArray ? strokeArray : strokeLineWidth).map((stroke3) => !!stroke3 && borderColor), stroke2;
}
function updateFrameBorderSize(group) {
  var _a, _b, _c, _d;
  if (!group.border) return;
  const borderTop = group.border.attribute.strokeArrayWidth ? group.border.attribute.strokeArrayWidth[0] : null !== (_a = group.border.attribute.lineWidth) && void 0 !== _a ? _a : 0, borderRight = group.border.attribute.strokeArrayWidth ? group.border.attribute.strokeArrayWidth[1] : null !== (_b = group.border.attribute.lineWidth) && void 0 !== _b ? _b : 0, borderBottom = group.border.attribute.strokeArrayWidth ? group.border.attribute.strokeArrayWidth[2] : null !== (_c = group.border.attribute.lineWidth) && void 0 !== _c ? _c : 0, borderLeft = group.border.attribute.strokeArrayWidth ? group.border.attribute.strokeArrayWidth[3] : null !== (_d = group.border.attribute.lineWidth) && void 0 !== _d ? _d : 0;
  group.border.setAttributes({
    borderLeft,
    borderTop,
    borderRight,
    borderBottom,
    width: group.attribute.width - borderLeft / 2 - borderRight / 2,
    height: group.attribute.height - borderTop / 2 - borderBottom / 2
  }), "group" === group.border.type && group.border.firstChild.setAttributes({
    width: group.attribute.width,
    height: group.attribute.height
  });
}
function updateCornerRadius(table) {
  if (!table.theme.frameStyle.cornerRadius) return;
  const cornerRadius = table.theme.frameStyle.cornerRadius, { cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, bodyGroup, rightTopCornerGroup, leftBottomCornerGroup, rightBottomCornerGroup, rightFrozenGroup, bottomFrozenGroup } = table.scenegraph;
  cornerHeaderGroup.setAttribute("cornerRadius", 0), colHeaderGroup.setAttribute("cornerRadius", 0), rowHeaderGroup.setAttribute("cornerRadius", 0), bodyGroup.setAttribute("cornerRadius", 0), rightTopCornerGroup.setAttribute("cornerRadius", 0), leftBottomCornerGroup.setAttribute("cornerRadius", 0), rightBottomCornerGroup.setAttribute("cornerRadius", 0), rightFrozenGroup.setAttribute("cornerRadius", 0), bottomFrozenGroup.setAttribute("cornerRadius", 0);
  const cornerRadiusArray = toBoxArray(cornerRadius);
  cornerHeaderGroup.attribute.width > 0 && cornerHeaderGroup.attribute.height > 0 ? setCornerRadius(cornerHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]) : colHeaderGroup.attribute.height > 0 ? setCornerRadius(colHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]) : rowHeaderGroup.attribute.width > 0 ? setCornerRadius(rowHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]) : setCornerRadius(bodyGroup, [cornerRadiusArray[0], 0, 0, 0]), leftBottomCornerGroup.attribute.width > 0 && leftBottomCornerGroup.attribute.height > 0 ? setCornerRadius(leftBottomCornerGroup, [0, 0, 0, cornerRadiusArray[3]]) : bottomFrozenGroup.attribute.height > 0 ? setCornerRadius(bottomFrozenGroup, [0, 0, 0, cornerRadiusArray[3]]) : rowHeaderGroup.attribute.width > 0 ? setCornerRadius(rowHeaderGroup, [0, 0, 0, cornerRadiusArray[3]]) : setCornerRadius(bodyGroup, [0, 0, 0, cornerRadiusArray[3]]), rightTopCornerGroup.attribute.width > 0 && rightTopCornerGroup.attribute.height > 0 ? setCornerRadius(rightTopCornerGroup, [0, cornerRadiusArray[1], 0, 0]) : colHeaderGroup.attribute.height > 0 ? setCornerRadius(colHeaderGroup, [0, cornerRadiusArray[1], 0, 0]) : rightFrozenGroup.attribute.width > 0 ? setCornerRadius(rightFrozenGroup, [0, cornerRadiusArray[1], 0, 0]) : setCornerRadius(bodyGroup, [0, cornerRadiusArray[1], 0, 0]), rightBottomCornerGroup.attribute.width > 0 && rightBottomCornerGroup.attribute.height > 0 ? setCornerRadius(rightBottomCornerGroup, [0, 0, cornerRadiusArray[2], 0]) : rightFrozenGroup.attribute.width > 0 ? setCornerRadius(rightFrozenGroup, [0, 0, cornerRadiusArray[2], 0]) : bottomFrozenGroup.attribute.height > 0 ? setCornerRadius(bottomFrozenGroup, [0, 0, cornerRadiusArray[2], 0]) : setCornerRadius(bodyGroup, [0, 0, cornerRadiusArray[2], 0]);
}
function setCornerRadius(group, cornerRadius) {
  group.setAttribute("cornerRadius", cornerRadius), group.border && group.border.setAttribute("cornerRadius", cornerRadius);
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/chart.js
var CHART_NUMBER_TYPE = genNumberType();
var Chart = class _Chart extends Rect {
  constructor(isShareChartSpec2, params2) {
    if (super(params2), this.type = "chart", this.numberType = CHART_NUMBER_TYPE, this.isShareChartSpec = isShareChartSpec2, params2.chartInstance) this.chartInstance = params2.chartInstance;
    else {
      const chartInstance = this.chartInstance = new params2.ClassType(params2.spec, merge({}, this.attribute.tableChartOption, {
        renderCanvas: params2.canvas,
        mode: "node" === this.attribute.mode ? "node" : "desktop-browser",
        modeParams: this.attribute.modeParams,
        canvasControled: false,
        viewBox: {
          x1: 0,
          x2: 0,
          y1: 0,
          y2: 0
        },
        dpr: params2.dpr,
        interactive: false,
        animation: false,
        autoFit: false
      }));
      chartInstance.renderSync(), chartInstance.getStage().enableDirtyBounds(), params2.chartInstance = this.chartInstance = chartInstance;
    }
  }
  activate(table) {
    var _a, _b, _c, _d, _e;
    this.active = true;
    const { col, row } = this.parent, { x1, y1, x2, y2 } = this.getViewBox(), clipBound = getTableBounds(col, row, table).intersect({
      x1: x1 - table.scrollLeft,
      x2: x2 - table.scrollLeft,
      y1: y1 - table.scrollTop,
      y2: y2 - table.scrollTop
    });
    null === (_a = this.activeChartInstance) || void 0 === _a || _a.release(), this.activeChartInstance = new this.attribute.ClassType(this.attribute.spec, merge({}, this.attribute.tableChartOption, {
      renderCanvas: this.attribute.canvas,
      mode: "desktop-browser",
      canvasControled: false,
      viewBox: {
        x1: 0,
        x2: x2 - x1,
        y1: 0,
        y2: y2 - y1
      },
      dpr: table.internalProps.pixelRatio,
      animation: false,
      interactive: true,
      autoFit: false,
      beforeRender: (chartStage2) => {
        const stage = this.stage, ctx = chartStage2.window.getContext(), stageMatrix2 = stage.window.getViewBoxTransform(), viewBox = stage.window.getViewBox();
        ctx.inuse = true, ctx.clearMatrix(), ctx.setTransform(stageMatrix2.a, stageMatrix2.b, stageMatrix2.c, stageMatrix2.d, stageMatrix2.e, stageMatrix2.f, true), ctx.translate(viewBox.x1, viewBox.y1), ctx.setTransformForCurrent(true), ctx.beginPath(), ctx.rect(clipBound.x1, clipBound.y1, clipBound.x2 - clipBound.x1, clipBound.y2 - clipBound.y1), ctx.clip(), ctx.clearMatrix(), table.options.canvas && !chartStage2.needRender && (chartStage2.pauseRender(), table.scenegraph.stage.dirtyBounds.union(this.globalAABBBounds), table.scenegraph.updateNextFrame());
      },
      afterRender(stage) {
        stage.window.getContext().inuse = false, stage.needRender = false, chartStage.resumeRender();
      }
    }));
    const chartStage = this.activeChartInstance.getStage(), matrix = this.globalTransMatrix.clone(), stageMatrix = this.stage.window.getViewBoxTransform();
    matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), chartStage.window.setViewBoxTransform && chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), this.activeChartInstance.renderSync(), null === (_c = null === (_b = table.internalProps.layoutMap) || void 0 === _b ? void 0 : _b.updateDataStateToActiveChartInstance) || void 0 === _c || _c.call(_b, this.activeChartInstance), this.activeChartInstance.on("click", (params2) => {
      var _a2;
      false === (null === (_a2 = this.attribute.spec.select) || void 0 === _a2 ? void 0 : _a2.enable) ? table.scenegraph.updateChartState(null) : _Chart.temp && table.scenegraph.updateChartState(null == params2 ? void 0 : params2.datum);
    }), this.activeChartInstance.on("brushEnd", (params2) => {
      var _a2;
      table.scenegraph.updateChartState(null === (_a2 = null == params2 ? void 0 : params2.value) || void 0 === _a2 ? void 0 : _a2.inBrushData), _Chart.temp = 0, setTimeout(() => {
        _Chart.temp = 1;
      }, 0);
    }), null === (_e = (_d = table)._bindChartEvent) || void 0 === _e || _e.call(_d, this.activeChartInstance);
  }
  deactivate() {
    var _a, _b;
    this.active = false, null === (_a = this.activeChartInstance) || void 0 === _a || _a.updateViewBox({
      x1: -1e3,
      x2: -800,
      y1: -1e3,
      y2: -800
    }, false, false), null === (_b = this.activeChartInstance) || void 0 === _b || _b.release(), this.activeChartInstance = null;
  }
  updateData(data) {
    this.attribute.data = data;
  }
  getViewBox() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const cellGroup = this.parent, padding = this.attribute.cellPadding, table = this.stage.table, { x1, y1, x2, y2 } = cellGroup.globalAABBBounds;
    return {
      x1: Math.ceil(x1 + padding[3] + table.scrollLeft + (null !== (_b = null === (_a = table.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0)),
      x2: Math.ceil(x1 + cellGroup.attribute.width - padding[1] + table.scrollLeft + (null !== (_d = null === (_c = table.options.viewBox) || void 0 === _c ? void 0 : _c.x1) && void 0 !== _d ? _d : 0)),
      y1: Math.ceil(y1 + padding[0] + table.scrollTop + (null !== (_f = null === (_e = table.options.viewBox) || void 0 === _e ? void 0 : _e.y1) && void 0 !== _f ? _f : 0)),
      y2: Math.ceil(y1 + cellGroup.attribute.height - padding[2] + table.scrollTop + (null !== (_h = null === (_g = table.options.viewBox) || void 0 === _g ? void 0 : _g.y1) && void 0 !== _h ? _h : 0))
    };
  }
};
function getTableBounds(col, row, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { layoutMap } = table.internalProps, bodyBound = new Bounds(), tableBound = table.scenegraph.tableGroup.globalAABBBounds;
  return bodyBound.x1 = tableBound.x1, bodyBound.x2 = tableBound.x2, bodyBound.y1 = tableBound.y1, bodyBound.y2 = tableBound.y2, layoutMap.isLeftBottomCorner(col, row) || layoutMap.isRightTopCorner(col, row) || layoutMap.isLeftTopCorner(col, row) || layoutMap.isRightBottomCorner(col, row) || (layoutMap.isFrozenColumn(col, row) ? (bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight(), bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight()) : layoutMap.isFrozenRow(col, row) ? (bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth(), bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth()) : layoutMap.isRightFrozenColumn(col, row) ? (bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight(), bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight()) : layoutMap.isBottomFrozenRow(col, row) ? (bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth(), bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth()) : layoutMap.isFrozenColumn(col, row) || layoutMap.isRightFrozenColumn(col, row) || (bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth(), bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth(), bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight(), bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight())), bodyBound.x1 = bodyBound.x1 + (null !== (_b = null === (_a = table.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0), bodyBound.x2 = bodyBound.x2 + (null !== (_d = null === (_c = table.options.viewBox) || void 0 === _c ? void 0 : _c.x1) && void 0 !== _d ? _d : 0), bodyBound.y1 = bodyBound.y1 + (null !== (_f = null === (_e = table.options.viewBox) || void 0 === _e ? void 0 : _e.y1) && void 0 !== _f ? _f : 0), bodyBound.y2 = bodyBound.y2 + (null !== (_h = null === (_g = table.options.viewBox) || void 0 === _g ? void 0 : _g.y1) && void 0 !== _h ? _h : 0), bodyBound;
}
Chart.temp = 1;

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/chart-render-helper.js
var chartRenderKeys = [];
var chartRenderQueueList = [];
var requestAnimationFrameId;
var batchRenderChartCount = 5;
var isHandlingChartQueue = false;
function setBatchRenderChartCount(count) {
  isValid_default(count) && (batchRenderChartCount = count);
}
function clearChartRenderQueue() {
  chartRenderKeys = [], chartRenderQueueList = [], isHandlingChartQueue = false, cancelAnimationFrame(requestAnimationFrameId);
}
function IsHandlingChartQueue() {
  return isHandlingChartQueue;
}
function renderChart(chart) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { axes, dataId, data, spec, ClassType, canvas, mode, modeParams, dpr } = chart.attribute;
  let { chartInstance } = chart;
  chartInstance || (chartInstance = new ClassType(spec, {
    renderCanvas: canvas,
    mode: "node" === mode ? "node" : "desktop-browser",
    modeParams,
    canvasControled: false,
    viewBox: {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    },
    dpr,
    interactive: false,
    animation: false,
    autoFit: false
  }), chartInstance.renderSync(), chart.chartInstance = chartInstance);
  const viewBox = chart.getViewBox();
  viewBox.x2 <= viewBox.x1 && (viewBox.x2 = viewBox.x1 + 1), viewBox.y2 <= viewBox.y1 && (viewBox.y2 = viewBox.y1 + 1), chartInstance.updateViewBox({
    x1: 0,
    x2: viewBox.x2 - viewBox.x1,
    y1: 0,
    y2: viewBox.y2 - viewBox.y1
  }, false, false);
  const chartStage = chartInstance.getStage(), matrix = chart.globalTransMatrix.clone(), stageMatrix = chart.stage.window.getViewBoxTransform();
  matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), chartStage.window.setViewBoxTransform && chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  const { table } = chart.getRootNode();
  let updateSpec = false;
  if (table.options.specFormat) {
    const formatResult = table.options.specFormat(chart.attribute.spec, chartInstance, chart);
    if (formatResult.needFormatSpec && formatResult.spec) {
      const spec2 = formatResult.spec;
      chartInstance.updateSpecSync(spec2), updateSpec = null === (_a = formatResult.updateSpec) || void 0 === _a || _a;
    }
  }
  if (!updateSpec) if (null == axes || axes.forEach((axis, index) => {
    var _a2, _b2, _c2, _d2, _e2;
    "band" === axis.type ? chartInstance.updateModelSpec({
      type: "axes",
      index
    }, {
      domain: axis.domain.slice(0)
    }, true) : chartInstance.updateModelSpecSync({
      type: "axes",
      index
    }, {
      min: null !== (_b2 = null === (_a2 = axis.range) || void 0 === _a2 ? void 0 : _a2.min) && void 0 !== _b2 ? _b2 : 0,
      max: null !== (_d2 = null === (_c2 = axis.range) || void 0 === _c2 ? void 0 : _c2.max) && void 0 !== _d2 ? _d2 : 0,
      tick: {
        tickMode: null === (_e2 = axis.tick) || void 0 === _e2 ? void 0 : _e2.tickMode
      }
    }, true);
  }), null === (_c = null === (_b = table.internalProps.layoutMap) || void 0 === _b ? void 0 : _b.updateDataStateToActiveChartInstance) || void 0 === _c || _c.call(_b, chartInstance), "string" == typeof dataId) chartInstance.updateDataSync(dataId, null != data ? data : []);
  else {
    const dataBatch = [];
    for (const dataIdStr in dataId) {
      const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item) => {
        var _a2;
        return (null === (_a2 = null == item ? void 0 : item.data) || void 0 === _a2 ? void 0 : _a2.id) === dataIdStr;
      });
      dataBatch.push({
        id: dataIdStr,
        values: dataIdAndField ? null !== (_d = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _d ? _d : [] : null != data ? data : [],
        fields: null === (_e = null == series ? void 0 : series.data) || void 0 === _e ? void 0 : _e.fields
      }), chartInstance.updateFullDataSync || chartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_f = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _f ? _f : [] : null != data ? data : []);
    }
    null === (_g = chartInstance.updateFullDataSync) || void 0 === _g || _g.call(chartInstance, dataBatch);
  }
  table.fireListeners("before_cache_chart_image", {
    chartInstance
  });
  cacheStageCanvas(chartInstance.getStage(), chart);
}
function startRenderChartQueue(table) {
  isHandlingChartQueue = true, chartRenderQueueList.length > 0 ? requestAnimationFrameId = requestAnimationFrame(() => {
    const chartsToRender = chartRenderQueueList.splice(0, batchRenderChartCount);
    chartRenderKeys.splice(0, batchRenderChartCount), chartsToRender.forEach((chart) => {
      renderChart(chart), chart.addUpdateBoundTag();
    }), table.render(), startRenderChartQueue(table);
  }) : isHandlingChartQueue = false;
}
var cacheCanvasSizeLimit = 2e3;
function cacheStageCanvas(stage, chart) {
  var _a;
  const { viewWidth, viewHeight } = stage;
  if (viewWidth < cacheCanvasSizeLimit && viewHeight < cacheCanvasSizeLimit) return chart.cacheCanvas = toCanvas(stage), void (chart.isShareChartSpec || (null === (_a = chart.chartInstance) || void 0 === _a || _a.release(), chart.chartInstance = null, chart.setAttribute("chartInstance", null)));
  const rows = Math.ceil(viewHeight / cacheCanvasSizeLimit), columns = Math.ceil(viewWidth / cacheCanvasSizeLimit), cacheCanvas = [];
  for (let row = 0; row < rows; row++) for (let col = 0; col < columns; col++) {
    const startX = col * cacheCanvasSizeLimit, startY = row * cacheCanvasSizeLimit, endX = startX + cacheCanvasSizeLimit > viewWidth ? viewWidth : startX + cacheCanvasSizeLimit, endY = startY + cacheCanvasSizeLimit > viewHeight ? viewHeight : startY + cacheCanvasSizeLimit, width = endX - startX, height = endY - startY, bounds = new Bounds();
    bounds.setValue(startX, startY, endX, endY);
    const canvas = toCanvas(stage, false, bounds);
    cacheCanvas.push({
      canvas,
      x: startX,
      y: startY,
      width,
      height
    });
  }
  chart.cacheCanvas = cacheCanvas;
}
function toCanvas(stage, fullImage = true, viewBox) {
  if ("released" === stage.releaseStatus) return null;
  const matrix = stage.window.getViewBoxTransform(), window2 = renderToNewWindow(stage, fullImage, viewBox);
  window2.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, 0, 0), stage.renderTo(window2);
  const c2 = window2.getNativeHandler();
  return c2.nativeCanvas ? c2.nativeCanvas : null;
}
function renderToNewWindow(stage, fullImage = true, viewBox) {
  const matrix = stage.window.getViewBoxTransform(), window2 = container.get(VWindow), x1 = viewBox ? -viewBox.x1 : 0, y1 = viewBox ? -viewBox.y1 : 0, x2 = viewBox ? viewBox.x2 : stage.viewWidth, y2 = viewBox ? viewBox.y2 : stage.viewHeight, width = viewBox ? viewBox.width() : stage.viewWidth, height = viewBox ? viewBox.height() : stage.viewHeight;
  return window2.create({
    viewBox: {
      x1,
      y1,
      x2,
      y2
    },
    width: width * matrix.a,
    height: height * matrix.d,
    dpr: stage.window.dpr,
    canvasControled: true,
    offscreen: true,
    title: ""
  }), stage.renderTo(window2), window2;
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/chart-render.js
var __decorate118 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChartRender = Symbol.for("ChartRender");
var ChartRenderContribution = Symbol.for("ChartRenderContribution");
var DefaultCanvasChartRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = CHART_NUMBER_TYPE;
  }
  drawShape(chart, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d;
    const groupAttribute = getTheme(chart, null == params2 ? void 0 : params2.theme).group, { dataId, data, spec } = chart.attribute, { width = groupAttribute.width, height = groupAttribute.height } = (chart.getViewBox(), chart.attribute), { table } = chart.getRootNode(), { active, cacheCanvas, activeChartInstance } = chart;
    if (!active && cacheCanvas) isArray_default(cacheCanvas) ? cacheCanvas.forEach((singleCacheCanvas) => {
      const { x: x2, y: y2, width: width2, height: height2, canvas } = singleCacheCanvas;
      context.drawImage(canvas, x2, y2, width2, height2);
    }) : context.drawImage(cacheCanvas, x, y, width, height);
    else if (activeChartInstance) {
      if (table.options.specFormat) {
        const formatResult = table.options.specFormat(chart.attribute.spec, activeChartInstance, chart);
        if (formatResult.needFormatSpec && formatResult.spec) {
          const spec2 = formatResult.spec;
          activeChartInstance.updateSpecSync(spec2);
        }
      }
      const viewBox = chart.getViewBox();
      activeChartInstance.updateViewBox({
        x1: 0,
        x2: viewBox.x2 - viewBox.x1,
        y1: 0,
        y2: viewBox.y2 - viewBox.y1
      }, false, false);
      const chartStage = activeChartInstance.getStage();
      chartStage.needRender = true;
      const matrix = chart.globalTransMatrix.clone(), stageMatrix = chart.stage.window.getViewBoxTransform().clone();
      if (stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), "string" == typeof dataId) activeChartInstance.updateDataSync(dataId, null != data ? data : []);
      else {
        const dataBatch = [];
        for (const dataIdStr in dataId) {
          const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item) => {
            var _a2;
            return (null === (_a2 = null == item ? void 0 : item.data) || void 0 === _a2 ? void 0 : _a2.id) === dataIdStr;
          });
          dataBatch.push({
            id: dataIdStr,
            values: dataIdAndField ? null !== (_a = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _a ? _a : [] : null != data ? data : [],
            fields: null === (_b = null == series ? void 0 : series.data) || void 0 === _b ? void 0 : _b.fields
          }), activeChartInstance.updateFullDataSync || activeChartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_c = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _c ? _c : [] : null != data ? data : []);
        }
        null === (_d = activeChartInstance.updateFullDataSync) || void 0 === _d || _d.call(activeChartInstance, dataBatch);
      }
    } else table.internalProps.renderChartAsync ? (-1 === chartRenderKeys.indexOf(`${chart.parent.col}+${chart.parent.row}`) && (chartRenderKeys.push(`${chart.parent.col}+${chart.parent.row}`), chartRenderQueueList.push(chart)), IsHandlingChartQueue() || startRenderChartQueue(table)) : renderChart(chart);
  }
  draw(chart, renderService, drawContext, params2) {
    this._draw(chart, {}, false, drawContext, params2);
  }
};
DefaultCanvasChartRender = __decorate118([injectable()], DefaultCanvasChartRender);

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/image-contribution-render.js
var __decorate119 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var BeforeImageRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { shape } = image.attribute;
    if ("circle" === shape) {
      const { width = imageAttribute.width, height = imageAttribute.height } = image.attribute;
      context.beginPath(), context.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI), context.closePath(), context.save(), context.clip();
    }
  }
};
BeforeImageRenderContribution = __decorate119([injectable()], BeforeImageRenderContribution);
var AfterImageRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { shape } = image.attribute;
    "circle" === shape && context.restore();
  }
};
AfterImageRenderContribution = __decorate119([injectable()], AfterImageRenderContribution);
var BeforeGifImageRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { isGif } = image.attribute;
    isGif && image.playing && (image.attribute.opacity = 0);
  }
};
BeforeGifImageRenderContribution = __decorate119([injectable()], BeforeGifImageRenderContribution);
var AfterGifImageRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { isGif } = image.attribute;
    isGif && image.playing && (image.attribute.opacity = 1, context.globalAlpha = image.attribute.opacity, image.renderFrame(context, x, y));
  }
};
AfterGifImageRenderContribution = __decorate119([injectable()], AfterGifImageRenderContribution);

// node_modules/@visactor/vtable/es/state/hover/is-cell-hover.js
function getCellHoverColor(cellGroup, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  let colorKey, hoverStyle;
  if ("cell" === cellGroup.role && isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      const key = isCellHover(table.stateManager, col, row, cellGroup);
      !key || colorKey && "cellBgColor" !== key || (colorKey = key);
    }
  } else "cell" === cellGroup.role && (colorKey = isCellHover(table.stateManager, cellGroup.col, cellGroup.row, cellGroup));
  if (!colorKey) return;
  const layout = table.internalProps.layoutMap;
  layout.isCornerHeader(cellGroup.col, cellGroup.row) ? hoverStyle = (null === (_a = table.theme.cornerHeaderStyle) || void 0 === _a ? void 0 : _a.hover) || (null === (_b = table.theme.headerStyle) || void 0 === _b ? void 0 : _b.hover) : layout.isColumnHeader(cellGroup.col, cellGroup.row) ? hoverStyle = null === (_c = table.theme.headerStyle) || void 0 === _c ? void 0 : _c.hover : layout.isRowHeader(cellGroup.col, cellGroup.row) ? hoverStyle = null === (_d = table.theme.rowHeaderStyle) || void 0 === _d ? void 0 : _d.hover : layout.isBottomFrozenRow(cellGroup.col, cellGroup.row) ? hoverStyle = (null === (_e = table.theme.bottomFrozenStyle) || void 0 === _e ? void 0 : _e.hover) || (table.isListTable() ? null === (_f = table.theme.bodyStyle) || void 0 === _f ? void 0 : _f.hover : null === (_g = table.theme.headerStyle) || void 0 === _g ? void 0 : _g.hover) : layout.isRightFrozenColumn(cellGroup.col, cellGroup.row) ? hoverStyle = (null === (_h = table.theme.rightFrozenStyle) || void 0 === _h ? void 0 : _h.hover) || (table.isListTable() ? null === (_j = table.theme.bodyStyle) || void 0 === _j ? void 0 : _j.hover : null === (_k = table.theme.rowHeaderStyle) || void 0 === _k ? void 0 : _k.hover) : table.isHeader(cellGroup.col, cellGroup.row) || (hoverStyle = null === (_l = table.theme.bodyStyle) || void 0 === _l ? void 0 : _l.hover);
  return getProp2(colorKey, hoverStyle, cellGroup.col, cellGroup.row, table);
}
function isCellHover(state, col, row, cellGroup) {
  var _a;
  const { highlightScope, disableHeader, cellPos } = state.hover, table = state.table, isHeader = table.isHeader(col, row);
  if (isHeader && disableHeader) return;
  let hoverMode;
  if (highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row ? hoverMode = "cellBgColor" : highlightScope === HighlightScope.column && cellPos.col === col ? hoverMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineColumnBgColor" : highlightScope === HighlightScope.row && cellPos.row === row ? hoverMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineRowBgColor" : highlightScope === HighlightScope.cross && (cellPos.col === col && cellPos.row === row ? hoverMode = "cellBgColor" : cellPos.col === col ? hoverMode = "inlineColumnBgColor" : cellPos.row === row && (hoverMode = "inlineRowBgColor")), hoverMode) {
    let cellDisable;
    if (isHeader) {
      const define = table.getHeaderDefine(col, row);
      cellDisable = null == define ? void 0 : define.disableHeaderHover, cellGroup.firstChild && "axis" === cellGroup.firstChild.name && (null === (_a = table.options.hover) || void 0 === _a ? void 0 : _a.disableAxisHover) && (cellDisable = true);
    } else {
      const define = table.getBodyColumnDefine(col, row);
      cellDisable = null == define ? void 0 : define.disableHover;
    }
    cellDisable && (hoverMode = void 0);
  }
  return hoverMode;
}

// node_modules/@visactor/vtable/es/state/select/is-cell-select-highlight.js
function getCellSelectColor(cellGroup, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  let colorKey, selectStyle;
  if ("cell" === cellGroup.role && isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      const key = isCellSelected(table.stateManager, col, row, cellGroup);
      !key || colorKey && "cellBgColor" !== key || (colorKey = key);
    }
  } else "cell" === cellGroup.role && (colorKey = isCellSelected(table.stateManager, cellGroup.col, cellGroup.row, cellGroup));
  if (!colorKey) return;
  const layout = table.internalProps.layoutMap;
  layout.isCornerHeader(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_a = table.theme.cornerHeaderStyle) || void 0 === _a ? void 0 : _a.select) || (null === (_b = table.theme.headerStyle) || void 0 === _b ? void 0 : _b.select) : layout.isColumnHeader(cellGroup.col, cellGroup.row) ? selectStyle = null === (_c = table.theme.headerStyle) || void 0 === _c ? void 0 : _c.select : layout.isRowHeader(cellGroup.col, cellGroup.row) ? selectStyle = null === (_d = table.theme.rowHeaderStyle) || void 0 === _d ? void 0 : _d.select : layout.isBottomFrozenRow(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_e = table.theme.bottomFrozenStyle) || void 0 === _e ? void 0 : _e.select) || (table.isListTable() ? null === (_f = table.theme.bodyStyle) || void 0 === _f ? void 0 : _f.select : null === (_g = table.theme.headerStyle) || void 0 === _g ? void 0 : _g.select) : layout.isRightFrozenColumn(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_h = table.theme.rightFrozenStyle) || void 0 === _h ? void 0 : _h.select) || (table.isListTable() ? null === (_j = table.theme.bodyStyle) || void 0 === _j ? void 0 : _j.select : null === (_k = table.theme.rowHeaderStyle) || void 0 === _k ? void 0 : _k.select) : table.isHeader(cellGroup.col, cellGroup.row) || (selectStyle = null === (_l = table.theme.bodyStyle) || void 0 === _l ? void 0 : _l.select);
  return getProp2(colorKey, selectStyle, cellGroup.col, cellGroup.row, table);
}
function isSelectMultipleRange(range5) {
  return range5.start.col !== range5.end.col || range5.start.row !== range5.end.row;
}
function getSelectModeRange(state, col, row) {
  let selectMode;
  const { highlightScope, cellPos, ranges } = state.select, range5 = ranges[0], rangeColStart = Math.min(range5.start.col, range5.end.col), rangeColEnd = Math.max(range5.start.col, range5.end.col), rangeRowStart = Math.min(range5.start.row, range5.end.row), rangeRowEnd = Math.max(range5.start.row, range5.end.row);
  return highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : highlightScope === HighlightScope.column && col >= rangeColStart && col <= rangeColEnd ? selectMode = cellInRange(ranges[0], col, row) ? "cellBgColor" : "inlineColumnBgColor" : highlightScope === HighlightScope.row && row >= rangeRowStart && row <= rangeRowEnd ? selectMode = cellInRange(ranges[0], col, row) ? "cellBgColor" : "inlineRowBgColor" : highlightScope === HighlightScope.cross && (cellInRange(ranges[0], col, row) ? selectMode = "cellBgColor" : col >= rangeColStart && col <= rangeColEnd ? selectMode = "inlineColumnBgColor" : row >= rangeRowStart && row <= rangeRowEnd && (selectMode = "inlineRowBgColor")), selectMode;
}
function getSelectMode(state, col, row) {
  let selectMode;
  const { highlightScope, cellPos } = state.select;
  return highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : highlightScope === HighlightScope.column && cellPos.col === col ? selectMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineColumnBgColor" : highlightScope === HighlightScope.row && cellPos.row === row ? selectMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineRowBgColor" : highlightScope === HighlightScope.cross && (cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : cellPos.col === col ? selectMode = "inlineColumnBgColor" : cellPos.row === row && (selectMode = "inlineRowBgColor")), selectMode;
}
function isCellSelected(state, col, row, cellGroup) {
  const { highlightInRange, disableHeader, ranges } = state.select;
  let selectMode;
  const isSelectRange = 1 === ranges.length && isSelectMultipleRange(null == ranges ? void 0 : ranges[0]) && highlightInRange;
  if (isSelectRange ? 1 === (null == ranges ? void 0 : ranges.length) && ranges[0].start && ranges[0].end : 1 === (null == ranges ? void 0 : ranges.length) && ranges[0].end.col === ranges[0].start.col && ranges[0].end.row === ranges[0].start.row) {
    if (state.table.isHeader(col, row) && disableHeader) return;
    if (selectMode = isSelectRange ? getSelectModeRange(state, col, row) : getSelectMode(state, col, row), selectMode) {
      isCellDisableSelect(state.table, col, row) && (selectMode = void 0);
    }
  } else if ("replace" === state.table.theme.selectionStyle.selectionFillMode) for (let i = 0; i < ranges.length; i++) {
    const range5 = ranges[i], rangeColStart = Math.min(range5.start.col, range5.end.col), rangeColEnd = Math.max(range5.start.col, range5.end.col), rangeRowStart = Math.min(range5.start.row, range5.end.row), rangeRowEnd = Math.max(range5.start.row, range5.end.row);
    if (rangeColStart <= col && rangeRowStart <= row && rangeColEnd >= col && rangeRowEnd >= row) {
      selectMode = "cellBgColor";
      break;
    }
  }
  return selectMode;
}
function isCellDisableSelect(table, col, row) {
  var _a, _b;
  const globalDisableSelect = null === (_a = table.options.select) || void 0 === _a ? void 0 : _a.disableSelect;
  if ("function" == typeof globalDisableSelect ? globalDisableSelect(col, row, table) : globalDisableSelect) return true;
  if (table.isHeader(col, row)) {
    let cellDisable = null === (_b = table.options.select) || void 0 === _b ? void 0 : _b.disableHeaderSelect;
    if (cellDisable) return true;
    const columnDefine = table.getHeaderDefine(col, row);
    if (cellDisable = null == columnDefine ? void 0 : columnDefine.disableHeaderSelect, cellDisable) return true;
  } else {
    const columnDefine = table.getBodyColumnDefine(col, row), disableSelect = null == columnDefine ? void 0 : columnDefine.disableSelect;
    if ("function" == typeof disableSelect ? disableSelect(col, row, table) : disableSelect) return true;
  }
  return false;
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/group-contribution-render.js
var __decorate120 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SplitGroupBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = groupAttribute.stroke, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor } = group.attribute;
    stroke2 && (Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor)) && (doFillOrStroke.doStroke = false);
  }
};
SplitGroupBeforeRenderContribution = __decorate120([injectable()], SplitGroupBeforeRenderContribution);
var SplitGroupAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    var _a, _b;
    const { stroke: stroke2 = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth = groupAttribute.lineWidth, strokeColor = groupAttribute.stroke, cornerRadius = groupAttribute.cornerRadius } = group.attribute;
    let widthForStroke, heightForStroke, { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
    if (stroke2 && (Array.isArray(strokeArrayWidth) || 0 !== lineWidth) && (Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth))) {
      if ("number" == typeof lineWidth && 1 & lineWidth || Array.isArray(strokeArrayWidth) && strokeArrayWidth.some((width2) => 1 & width2)) {
        const table = group.stage.table;
        if (!table) return;
        const bottomRight = "bottom-right" === (null === (_a = null == table ? void 0 : table.theme) || void 0 === _a ? void 0 : _a.cellBorderClipDirection);
        if (bottomRight) {
          if (x = Math.floor(x) - 0.5, y = Math.floor(y) - 0.5, "cell" === group.role) {
            const col = group.col, row = group.row;
            0 === col && (x += 1), 0 === row && (y += 1);
          }
        } else x = Math.floor(x) + 0.5, y = Math.floor(y) + 0.5;
        (null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) && (width = Math.round(width), height = Math.round(height));
        const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
        widthForStroke = widthFroDraw, heightForStroke = heightFroDraw;
      } else widthForStroke = Math.ceil(width), heightForStroke = Math.ceil(height);
      0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? renderStroke(group, context, x, y, groupAttribute, stroke2, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke) : (context.beginPath(), createRectPath(context, x, y, widthForStroke, heightForStroke, cornerRadius, true, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
        renderStrokeWithCornerRadius(i, x1, y1, x2, y2, group, context, x, y, groupAttribute, stroke2, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke);
      })), context.stroke());
    }
  }
};
SplitGroupAfterRenderContribution = __decorate120([injectable()], SplitGroupAfterRenderContribution);
function getWidthInfo(widthArray) {
  if (!Array.isArray(widthArray)) return {
    isSplitDraw: false,
    width: widthArray
  };
  let temp2;
  for (let i = 0; i < widthArray.length; i++) {
    const width = widthArray[i];
    if (width) if (temp2) {
      if (width !== temp2) return {
        isSplitDraw: true
      };
    } else temp2 = width;
  }
  return {
    isSplitDraw: false,
    width: temp2
  };
}
function renderStroke(group, context, x, y, groupAttribute, stroke2, strokeArrayWidth, strokeArrayColor, width, height, isHighlight, part) {
  var _a, _b, _c, _d;
  const widthInfo = getWidthInfo(strokeArrayWidth), isWidthNumber = !Array.isArray(strokeArrayWidth), isStrokeTrue = !Array.isArray(stroke2), isPart = Array.isArray(part), isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;
  context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
  const { lineDash = groupAttribute.lineDash } = group.attribute;
  let isDash = false;
  lineDash.length && lineDash.some((dash) => Array.isArray(dash)) && (isDash = true), context.beginPath(), context.moveTo(x, y);
  const strokeTop = (isStrokeTrue || stroke2[0]) && (isWidthNumber || strokeArrayWidth[0]), strokeRight = (isStrokeTrue || stroke2[1]) && (isWidthNumber || strokeArrayWidth[1]), strokeBottom = (isStrokeTrue || stroke2[2]) && (isWidthNumber || strokeArrayWidth[2]), strokeLeft = (isStrokeTrue || stroke2[3]) && (isWidthNumber || strokeArrayWidth[3]);
  if (strokeTop) {
    const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2, deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
    isPart && Array.isArray(part[0]) ? (context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[0][0], y), context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[0][1] - part[0][0]), y), context.moveTo(x + width + deltaRight, y)) : (context.moveTo(x - deltaLeft, y), context.lineTo(x + width + deltaRight, y)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[0] ? context.strokeStyle = strokeArrayColor[0] : strokeArrayColor && !strokeArrayColor[0] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[0]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, isDash && context.setLineDash(null !== (_a = lineDash[0]) && void 0 !== _a ? _a : []), context.stroke(), context.beginPath(), context.moveTo(x + width, y));
  } else context.moveTo(x + width, y);
  if (strokeRight) {
    const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2, deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
    isPart && Array.isArray(part[1]) ? (context.moveTo(x + width, y - deltaTop + height * part[1][0]), context.lineTo(x + width, y - deltaTop + (height + deltaTop + deltaBottom) * (part[1][1] - part[1][0])), context.moveTo(x + width, y + height + deltaBottom)) : (context.moveTo(x + width, y - deltaTop), context.lineTo(x + width, y + height + deltaBottom)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[1] ? context.strokeStyle = strokeArrayColor[1] : strokeArrayColor && !strokeArrayColor[1] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[1]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, isDash && context.setLineDash(null !== (_b = lineDash[1]) && void 0 !== _b ? _b : []), context.stroke(), context.beginPath(), context.moveTo(x + width, y + height));
  } else context.moveTo(x + width, y + height);
  if (strokeBottom) {
    const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2, deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
    isPart && Array.isArray(part[2]) ? (context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[2][0], y + height), context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[2][1] - part[2][0]), y + height), context.moveTo(x - deltaLeft, y + height)) : (context.moveTo(x - deltaLeft, y + height), context.lineTo(x + width + deltaRight, y + height)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[2] ? context.strokeStyle = strokeArrayColor[2] : strokeArrayColor && !strokeArrayColor[2] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[2]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, isDash && context.setLineDash(null !== (_c = lineDash[2]) && void 0 !== _c ? _c : []), context.stroke(), context.beginPath(), context.moveTo(x, y + height));
  } else context.moveTo(x, y + height);
  if (strokeLeft) {
    const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2, deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
    isPart && Array.isArray(part[3]) ? (context.moveTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * part[3][0]), context.lineTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * (part[3][1] - part[3][0])), context.moveTo(x, y - deltaTop)) : (context.moveTo(x, y - deltaTop), context.lineTo(x, y + height + deltaBottom)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[3] ? context.strokeStyle = strokeArrayColor[3] : strokeArrayColor && !strokeArrayColor[3] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[3]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, isDash && context.setLineDash(null !== (_d = lineDash[3]) && void 0 !== _d ? _d : []), context.stroke(), context.beginPath(), context.moveTo(x, y));
  } else context.moveTo(x, y);
  isSplitDraw || isDash || (!isWidthNumber && widthInfo.width && (context.lineWidth = widthInfo.width), context.stroke()), context.lineDashOffset = 0, context.setLineDash([]);
}
var DashGroupBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    var _a;
    const { lineDash = groupAttribute.lineDash, stroke: stroke2 = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth } = group.attribute;
    stroke2 && Array.isArray(lineDash) && lineDash.length && (null === (_a = lineDash[0]) || void 0 === _a ? void 0 : _a.length) && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && (doFillOrStroke.doStroke = false);
  }
};
DashGroupBeforeRenderContribution = __decorate120([injectable()], DashGroupBeforeRenderContribution);
var DashGroupAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const { lineDash = groupAttribute.lineDash, stroke: stroke2 = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth = groupAttribute.lineWidth } = group.attribute;
    if (!stroke2 || !(Array.isArray(lineDash) && lineDash.length && (null === (_a = lineDash[0]) || void 0 === _a ? void 0 : _a.length)) || Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth)) return;
    const table = group.stage.table;
    if (!table) return;
    const splitLineDash = isArray_default(lineDash[0]) ? getQuadLineDash(lineDash) : [lineDash, lineDash, lineDash, lineDash];
    let widthForStroke, heightForStroke, { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
    if ((null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) ? (width = Math.round(width), height = Math.round(height)) : (width = Math.ceil(width), height = Math.ceil(height)), 1 & lineWidth) {
      const bottomRight = "bottom-right" === table.theme.cellBorderClipDirection, deltaWidth = 0, deltaHeight = 0;
      if (bottomRight) {
        if (x = Math.floor(x) - 0.5, y = Math.floor(y) - 0.5, "cell" === group.role) {
          0 === group.col && (x += 1), 0 === group.row && (y += 1);
        }
      } else x = Math.floor(x) + 0.5, y = Math.floor(y) + 0.5;
      const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width + deltaWidth), Math.ceil(height + deltaHeight), bottomRight);
      widthForStroke = widthFroDraw, heightForStroke = heightFroDraw;
    } else widthForStroke = Math.ceil(width), heightForStroke = Math.ceil(height);
    context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.beginPath(), context.moveTo(x, y), context.lineTo(x + widthForStroke, y), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, context.setLineDash(null !== (_c = splitLineDash[0]) && void 0 !== _c ? _c : []), context.stroke(), context.beginPath(), context.moveTo(x + widthForStroke, y), context.lineTo(x + widthForStroke, y + heightForStroke), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, context.setLineDash(null !== (_d = splitLineDash[1]) && void 0 !== _d ? _d : []), context.stroke(), context.beginPath(), context.moveTo(x, y + heightForStroke), context.lineTo(x + widthForStroke, y + heightForStroke), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, context.setLineDash(null !== (_e = splitLineDash[2]) && void 0 !== _e ? _e : []), context.stroke(), context.beginPath(), context.moveTo(x, y), context.lineTo(x, y + heightForStroke), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, context.setLineDash(null !== (_f = splitLineDash[3]) && void 0 !== _f ? _f : []), context.stroke(), context.lineDashOffset = 0, context.setLineDash([]);
  }
};
DashGroupAfterRenderContribution = __decorate120([injectable()], DashGroupAfterRenderContribution);
var AdjustPosGroupBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { lineWidth = groupAttribute.lineWidth, stroke: stroke2 = groupAttribute.stroke, lineDash = groupAttribute.lineDash, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos } = group.attribute;
    true !== notAdjustPos && stroke2 && Array.isArray(lineDash) && !lineDash.length && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && 1 & lineWidth && (doFillOrStroke.doStroke = false);
  }
};
AdjustPosGroupBeforeRenderContribution = __decorate120([injectable()], AdjustPosGroupBeforeRenderContribution);
var AdjustPosGroupAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    var _a, _b;
    const { lineWidth = groupAttribute.lineWidth, stroke: stroke2 = groupAttribute.stroke, lineDash = groupAttribute.lineDash, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos, cornerRadius = groupAttribute.cornerRadius } = group.attribute;
    let { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
    if (true !== notAdjustPos && stroke2 && Array.isArray(lineDash) && !lineDash.length && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && 1 & lineWidth) {
      const table = group.stage.table;
      if (!table) return;
      (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) && (width = Math.round(width), height = Math.round(height)), context.beginPath();
      const bottomRight = "bottom-right" === (null === (_b = null == table ? void 0 : table.theme) || void 0 === _b ? void 0 : _b.cellBorderClipDirection), deltaWidth = 0, deltaHeight = 0;
      if (bottomRight) {
        if (x = Math.floor(x) - 0.5, y = Math.floor(y) - 0.5, "cell" === group.role) {
          0 === group.col && (x += 1), 0 === group.row && (y += 1);
        }
      } else x = Math.floor(x) + 0.5, y = Math.floor(y) + 0.5;
      const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
      cornerRadius ? createRectPath(context, x, y, widthFroDraw + deltaWidth, heightFroDraw + deltaHeight, cornerRadius) : context.rect(x, y, widthFroDraw, heightFroDraw), context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.stroke();
    }
  }
};
AdjustPosGroupAfterRenderContribution = __decorate120([injectable()], AdjustPosGroupAfterRenderContribution);
var AdjustColorGroupBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    if ("cell" === group.role) {
      const table = group.stage.table;
      if (table) {
        const selectColor = getCellSelectColor(group, table);
        if (selectColor) group.attribute._vtableHightLightFill = selectColor;
        else if (table.stateManager.interactionState !== InteractionState.scrolling) {
          const hoverColor = getCellHoverColor(group, table);
          hoverColor && (group.attribute._vtableHightLightFill = hoverColor);
        }
      }
    }
  }
};
AdjustColorGroupBeforeRenderContribution = __decorate120([injectable()], AdjustColorGroupBeforeRenderContribution);
var AdjustColorGroupAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    if (group.attribute._vtableHightLightFill) {
      if (fillCb) ;
      else if (fVisible) {
        const oldColor = group.attribute.fill;
        group.attribute.fill = group.attribute._vtableHightLightFill, context.setCommonStyle(group, group.attribute, x, y, groupAttribute), context.fill(), group.attribute.fill = oldColor, group.attribute._vtableHightLightFill = void 0;
      }
    }
  }
};
AdjustColorGroupAfterRenderContribution = __decorate120([injectable()], AdjustColorGroupAfterRenderContribution);
var ClipBodyGroupBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, xOrigin, yOrigin, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    var _a, _b, _c, _d, _e, _f;
    const table = group.stage.table;
    if (table) {
      if ("body" === group.role) {
        drawClipRect(context, -(null !== (_a = group.attribute.x) && void 0 !== _a ? _a : 0) + table.getFrozenColsWidth(), -(null !== (_b = group.attribute.y) && void 0 !== _b ? _b : 0) + table.getFrozenRowsHeight(), group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
      } else if ("row-header" === group.role) {
        drawClipRect(context, 0, -(null !== (_c = group.attribute.y) && void 0 !== _c ? _c : 0) + table.getFrozenRowsHeight(), table.getFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
      } else if ("col-header" === group.role) {
        drawClipRect(context, -(null !== (_d = group.attribute.x) && void 0 !== _d ? _d : 0) + table.getFrozenColsWidth(), 0, group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), table.getFrozenRowsHeight());
      } else if ("right-frozen" === group.role) {
        drawClipRect(context, 0, -(null !== (_e = group.attribute.y) && void 0 !== _e ? _e : 0) + table.getFrozenRowsHeight(), table.getRightFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
      } else if ("bottom-frozen" === group.role) {
        drawClipRect(context, -(null !== (_f = group.attribute.x) && void 0 !== _f ? _f : 0) + table.getFrozenColsWidth(), 0, group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), table.getBottomFrozenRowsHeight());
      } else if ("corner-header" === group.role) {
        drawClipRect(context, 0, 0, table.getFrozenColsWidth(), table.getFrozenRowsHeight());
      } else if ("corner-right-top-header" === group.role) {
        drawClipRect(context, 0, 0, table.getRightFrozenColsWidth(), table.getFrozenRowsHeight());
      } else if ("corner-right-bottom-header" === group.role) {
        drawClipRect(context, 0, 0, table.getRightFrozenColsWidth(), table.getBottomFrozenRowsHeight());
      } else if ("corner-left-bottom-header" === group.role) {
        drawClipRect(context, 0, 0, table.getFrozenColsWidth(), table.getBottomFrozenRowsHeight());
      }
    }
  }
};
ClipBodyGroupBeforeRenderContribution = __decorate120([injectable()], ClipBodyGroupBeforeRenderContribution);
var precision = Math.pow(2, 24);
function drawClipRect(context, x, y, width, height) {
  context.beginPath();
  const matrix = context.applyedMatrix;
  Math.abs(matrix.f) > precision || Math.abs(matrix.g) > precision ? context.rect(x - precision, y - precision, width + 2 * precision, height + 2 * precision) : context.rect(x, y, width, height);
}
function getCellSizeForDraw(group, width, height, bottomRight) {
  const table = group.stage.table;
  if (!table) return {
    width,
    height
  };
  if ("cell" === group.role) {
    let col = group.col, row = group.row;
    const mergeInfo = getCellMergeInfo(table, col, row);
    mergeInfo && (col = mergeInfo.end.col, row = mergeInfo.end.row), col !== table.colCount - 1 || bottomRight ? (col === table.frozenColCount - 1 && table.scrollLeft && !bottomRight || 0 === col && bottomRight) && (width -= 1) : width -= 1, row !== table.rowCount - 1 || bottomRight ? (row === table.frozenRowCount - 1 && table.scrollTop && !bottomRight || 0 === row && bottomRight) && (height -= 1) : height -= 1;
  } else "corner-frozen" === group.role && (table.scrollLeft && !bottomRight && (width -= 1), table.scrollTop && !bottomRight && (height -= 1));
  return {
    width,
    height
  };
}
function getQuadLineDash(lineDash) {
  return 1 === lineDash.length ? [lineDash[0], lineDash[0], lineDash[0], lineDash[0]] : 2 === lineDash.length ? [lineDash[0], lineDash[1], lineDash[0], lineDash[1]] : lineDash;
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/rect-contribution-render.js
var __decorate121 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SplitRectBeforeRenderContribution2 = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = rectAttribute.stroke, strokeArrayWidth = rectAttribute.strokeArrayWidth, strokeArrayColor = rectAttribute.strokeArrayColor } = rect.attribute;
    stroke2 && (Array.isArray(stroke2) || Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor)) && (doFillOrStroke.doStroke = false);
  }
};
SplitRectBeforeRenderContribution2 = __decorate121([injectable()], SplitRectBeforeRenderContribution2);
var SplitRectAfterRenderContribution2 = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const { width = rectAttribute.width, height = rectAttribute.height, stroke: stroke2 = rectAttribute.stroke, strokeArrayColor = rectAttribute.strokeArrayColor, strokeArrayWidth = rectAttribute.strokeArrayWidth, lineWidth = rectAttribute.lineWidth, strokeColor = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    if (stroke2 && (Array.isArray(strokeArrayWidth) || 0 !== lineWidth) && (Array.isArray(stroke2) || Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth))) {
      const deltaWidth = 0, deltaHeight = 0;
      "border-rect" !== rect.name && "table-border-rect" !== rect.name && ("number" == typeof lineWidth && 1 & lineWidth || Array.isArray(strokeArrayWidth) && strokeArrayWidth.some((width2) => 1 & width2)) && (x = Math.floor(x) + 0.5, y = Math.floor(y) + 0.5), 0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? renderStroke(rect, context, x, y, rectAttribute, stroke2, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, "table-border-rect" !== rect.name ? Math.ceil(width + deltaWidth) : width + deltaWidth, "table-border-rect" !== rect.name ? Math.ceil(height + deltaHeight) : height + deltaHeight) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, true, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
        renderStrokeWithCornerRadius(i, x1, y1, x2, y2, rect, context, x, y, rectAttribute, stroke2, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, Math.ceil(width + deltaWidth), Math.ceil(height + deltaHeight));
      })), context.stroke());
    }
  }
};
SplitRectAfterRenderContribution2 = __decorate121([injectable()], SplitRectAfterRenderContribution2);
function renderStrokeWithCornerRadius(i, x1, y1, x2, y2, rect, context, x, y, rectAttribute, stroke2, strokeArrayWidth, strokeArrayColor, width, height) {
  var _a, _b, _c, _d;
  const group = rect, groupAttribute = rectAttribute, widthInfo = getWidthInfo(strokeArrayWidth), isWidthNumber = !Array.isArray(strokeArrayWidth), isStrokeTrue = !Array.isArray(stroke2), isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;
  context.stroke(), context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute);
  const { lineDash = groupAttribute.lineDash } = group.attribute;
  let isDash = false;
  lineDash.length && lineDash.some((dash) => Array.isArray(dash)) && (isDash = true), context.beginPath(), context.moveTo(x, y);
  const strokeTop = (isStrokeTrue || stroke2[0]) && (isWidthNumber || strokeArrayWidth[0]), strokeRight = (isStrokeTrue || stroke2[1]) && (isWidthNumber || strokeArrayWidth[1]), strokeBottom = (isStrokeTrue || stroke2[2]) && (isWidthNumber || strokeArrayWidth[2]), strokeLeft = (isStrokeTrue || stroke2[3]) && (isWidthNumber || strokeArrayWidth[3]);
  if (strokeTop && 0 === i) {
    isWidthNumber ? widthInfo.width : strokeArrayWidth[0], isWidthNumber ? widthInfo.width : strokeArrayWidth[0];
    context.moveTo(x1, y1), context.lineTo(x2, y2), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[0] ? context.strokeStyle = strokeArrayColor[0] : strokeArrayColor && !strokeArrayColor[0] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[0]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, isDash && context.setLineDash(null !== (_a = lineDash[0]) && void 0 !== _a ? _a : []), context.stroke(), context.beginPath());
  } else 0 === i && context.moveTo(x + width, y);
  if (strokeRight && 1 === i) {
    isWidthNumber ? widthInfo.width : strokeArrayWidth[1], isWidthNumber ? widthInfo.width : strokeArrayWidth[1];
    context.moveTo(x1, y1), context.lineTo(x2, y2), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[1] ? context.strokeStyle = strokeArrayColor[1] : strokeArrayColor && !strokeArrayColor[1] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[1]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, isDash && context.setLineDash(null !== (_b = lineDash[1]) && void 0 !== _b ? _b : []), context.stroke(), context.beginPath(), context.moveTo(x + width, y + height));
  } else 1 === i && context.moveTo(x + width, y + height);
  if (strokeBottom && 2 === i) {
    isWidthNumber ? widthInfo.width : strokeArrayWidth[2], isWidthNumber ? widthInfo.width : strokeArrayWidth[2];
    context.moveTo(x1, y1), context.lineTo(x2, y2), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[2] ? context.strokeStyle = strokeArrayColor[2] : strokeArrayColor && !strokeArrayColor[2] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[2]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, isDash && context.setLineDash(null !== (_c = lineDash[2]) && void 0 !== _c ? _c : []), context.stroke(), context.beginPath(), context.moveTo(x, y + height));
  } else 2 === i && context.moveTo(x, y + height);
  if (strokeLeft && 3 === i) {
    isWidthNumber ? widthInfo.width : strokeArrayWidth[3], isWidthNumber ? widthInfo.width : strokeArrayWidth[3];
    context.moveTo(x1, y1), context.lineTo(x2, y2), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[3] ? context.strokeStyle = strokeArrayColor[3] : strokeArrayColor && !strokeArrayColor[3] && (context.strokeStyle = "transparent"), isWidthNumber || (context.lineWidth = strokeArrayWidth[3]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, isDash && context.setLineDash(null !== (_d = lineDash[3]) && void 0 !== _d ? _d : []), context.stroke(), context.beginPath(), context.moveTo(x, y));
  } else 3 === i && context.moveTo(x, y);
  context.closePath(), isSplitDraw || isDash || (!isWidthNumber && widthInfo.width && (context.lineWidth = widthInfo.width), context.stroke()), context.lineDashOffset = 0, context.setLineDash([]), context.beginPath();
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/draw-interceptor.js
var __decorate122 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var loadingImage;
var VTableDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ImageDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return false;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
};
VTableDrawItemInterceptorContribution = __decorate122([injectable()], VTableDrawItemInterceptorContribution);
var ImageDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return "image" === graphic.type && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    const { image: url, gif } = graphic.attribute;
    if (gif && graphic.playing) return false;
    if (!url || !graphic.resources) return false;
    const res = graphic.resources.get(url);
    if (!res || "loading" !== res.state) return false;
    if (!loadingImage) {
      const regedIcons3 = get3(), svg = regedIcons3.loading_pic.svg, width2 = regedIcons3.loading_pic.width, height2 = regedIcons3.loading_pic.height;
      loadingImage = createImage({
        width: width2,
        height: height2,
        image: svg
      });
    }
    const { image: loadingUrl } = loadingImage.attribute;
    if (!url || !loadingImage.resources) return false;
    const loadingRes = loadingImage.resources.get(loadingUrl);
    if ("success" !== loadingRes.state) return false;
    const { context } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
    const b = graphic.AABBBounds, { width, height } = calcKeepAspectRatioSize(loadingRes.data.width, loadingRes.data.height, b.width(), b.height());
    return context.drawImage(loadingRes.data, b.x1 + (b.width() - width) / 2, b.y1 + (b.height() - height) / 2, width, height), context.highPerformanceRestore(), true;
  }
};

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/text-contribution-render.js
var __decorate123 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var SuffixTextBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    var _a, _b;
    const { text: str2, underline = textAttribute.underline, lineThrough = textAttribute.lineThrough, direction = textAttribute.direction, whiteSpace = textAttribute.whiteSpace, fontSize = textAttribute.fontSize, verticalMode = textAttribute.verticalMode, ellipsis = textAttribute.ellipsis, textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline, x: originX = textAttribute.x, y: originY = textAttribute.y } = text2.attribute;
    let isEmpty = false;
    if (Array.isArray(text2)) {
      const layoutData = null === (_a = text2.cache) || void 0 === _a ? void 0 : _a.layoutData;
      ellipsis && layoutData && layoutData.lines.every((line) => "" === line.str) && (isEmpty = true);
    } else {
      const { cache } = text2;
      ellipsis && cache && "" === cache.clipedText && 0 === cache.clipedWidth && (isEmpty = true);
    }
    if (!isEmpty) return;
    const textStr = isString_default(ellipsis) ? ellipsis : "...", lineHeight = null !== (_b = calculateLineHeight(text2.attribute.lineHeight, fontSize)) && void 0 !== _b ? _b : fontSize;
    let dy = 0;
    lineHeight !== fontSize && ("top" === textBaseline ? dy = (lineHeight - fontSize) / 2 : "middle" === textBaseline || "bottom" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), context.strokeText(textStr, originX, originY + dy))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute), context.fillText(textStr, originX, originY + dy), this.drawUnderLine(underline, lineThrough, text2, originX, originY + dy, 0, textAttribute, context, textStr)));
  }
  drawUnderLine(underline, lineThrough, text2, x, y, z, textAttribute, context, textStr) {
    if (lineThrough + underline <= 0) return;
    const { textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline, fontSize = textAttribute.fontSize, fontFamily = textAttribute.fontFamily, fontWeight = textAttribute.fontWeight, fontStyle = textAttribute.fontStyle, fill = textAttribute.fill, opacity = textAttribute.opacity, underlineOffset = textAttribute.underlineOffset, underlineDash = textAttribute.underlineDash, fillOpacity = textAttribute.fillOpacity } = text2.attribute;
    if (!underline && !lineThrough) return;
    const w = textMeasure.measureTextWidth(textStr, {
      fontSize,
      fontFamily,
      fontWeight,
      fontStyle
    }), offsetX = textDrawOffsetX(textAlign, w), offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, x, y, textAttribute), context.setLineDash(underlineDash), context.beginPath();
      const dy = y + offsetY + fontSize + underlineOffset;
      context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, x, y, textAttribute), context.beginPath();
      const dy = y + offsetY + fontSize / 2;
      context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
    }
  }
};
SuffixTextBeforeRenderContribution = __decorate123([injectable()], SuffixTextBeforeRenderContribution);

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/vchart-graphic-picker.js
var __decorate124 = function(decorators, target, key, desc) {
  var d, c2 = arguments.length, r = c2 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var VChartPicker = class {
  constructor() {
    this.type = "chart", this.numberType = CHART_NUMBER_TYPE;
  }
  contains(chart, point5, params2) {
    return !!chart.AABBBounds.containsPoint(point5);
  }
};
VChartPicker = __decorate124([injectable()], VChartPicker);

// node_modules/@visactor/vtable/es/scenegraph/graphic/contributions/index.js
var contributions_default = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(SplitRectBeforeRenderContribution) ? rebind(SplitRectBeforeRenderContribution).to(SplitRectBeforeRenderContribution2).inSingletonScope() : (bind(SplitRectBeforeRenderContribution2).toSelf().inSingletonScope(), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution2)), isBound(SplitRectAfterRenderContribution) ? rebind(SplitRectAfterRenderContribution).to(SplitRectAfterRenderContribution2).inSingletonScope() : (bind(SplitRectAfterRenderContribution2).toSelf().inSingletonScope(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution2)), bind(DefaultCanvasChartRender).toSelf().inSingletonScope(), bind(ChartRender).to(DefaultCanvasChartRender), bind(GraphicRender).to(DefaultCanvasChartRender), bind(VChartPicker).toSelf().inSingletonScope(), bind(CanvasPickerContribution).toService(VChartPicker), bind(BeforeImageRenderContribution).toSelf().inSingletonScope(), bind(ImageRenderContribution).toService(BeforeImageRenderContribution), bind(AfterImageRenderContribution).toSelf().inSingletonScope(), bind(ImageRenderContribution).toService(AfterImageRenderContribution), bind(BeforeGifImageRenderContribution).toSelf().inSingletonScope(), bind(ImageRenderContribution).toService(BeforeGifImageRenderContribution), bind(AfterGifImageRenderContribution).toSelf().inSingletonScope(), bind(ImageRenderContribution).toService(AfterGifImageRenderContribution), bind(AdjustColorGroupBeforeRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(AdjustColorGroupBeforeRenderContribution), bind(AdjustColorGroupAfterRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(AdjustColorGroupAfterRenderContribution), bind(SplitGroupAfterRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(SplitGroupAfterRenderContribution), bind(SplitGroupBeforeRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(SplitGroupBeforeRenderContribution), bind(DashGroupBeforeRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(DashGroupBeforeRenderContribution), bind(DashGroupAfterRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(DashGroupAfterRenderContribution), bind(AdjustPosGroupBeforeRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(AdjustPosGroupBeforeRenderContribution), bind(AdjustPosGroupAfterRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(AdjustPosGroupAfterRenderContribution), bind(ClipBodyGroupBeforeRenderContribution).toSelf().inSingletonScope(), bind(GroupRenderContribution).toService(ClipBodyGroupBeforeRenderContribution), bind(VTableDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(VTableDrawItemInterceptorContribution), bind(SuffixTextBeforeRenderContribution).toSelf().inSingletonScope(), bind(TextRenderContribution).toService(SuffixTextBeforeRenderContribution);
});

// node_modules/@visactor/vtable/es/scenegraph/layout/compute-col-width.js
function computeColsWidth(table, colStart, colEnd, update2) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  table.internalProps.columnWidthConfig && table._parseColumnWidthConfig(table.internalProps.columnWidthConfig), table.isPivotTable() && table.internalProps.columnWidthConfigForRowHeader && table._parseColumnWidthConfigForRowHeader(table.internalProps.columnWidthConfigForRowHeader), colStart = null != colStart ? colStart : 0, colEnd = null != colEnd ? colEnd : table.colCount - 1, 0 === colStart && colEnd === table.colCount - 1 && table._clearColRangeWidthsMap();
  const layoutMap = table.internalProps.layoutMap;
  table.isPivotTable() && (layoutMap.enableUseGetBodyCache(), layoutMap.enableUseHeaderPathCache());
  const oldColWidths = [], newWidths = [];
  if (update2) for (let col = 0; col < table.colCount; col++) oldColWidths[col] = table.getColWidth(col);
  for (let col = colStart; col <= colEnd; col++) {
    let maxWidth;
    if (table.internalProps.transpose || "only-header" !== (null === (_b = null === (_a = table.internalProps.layoutMap.columnObjects) || void 0 === _a ? void 0 : _a[col]) || void 0 === _b ? void 0 : _b.columnWidthComputeMode) && "only-header" !== table.columnWidthComputeMode || !("showHeader" in table.internalProps.layoutMap)) maxWidth = table.internalProps.transpose || "only-body" !== (null === (_d = null === (_c = table.internalProps.layoutMap.columnObjects) || void 0 === _c ? void 0 : _c[col]) || void 0 === _d ? void 0 : _d.columnWidthComputeMode) && "only-body" !== table.columnWidthComputeMode ? computeColWidth(col, 0, table.rowCount - 1, table) : computeColWidth(col, table.internalProps.layoutMap.getBodyRange().start.row, table.internalProps.layoutMap.getBodyRange().end.row, table);
    else {
      const temp2 = table.internalProps.layoutMap.showHeader;
      table.internalProps.layoutMap.showHeader = true, maxWidth = computeColWidth(col, 0, table.internalProps.layoutMap.headerLevelCount - 1, table), table.internalProps.layoutMap.showHeader = temp2;
    }
    table._setColContentWidth(col, maxWidth);
    table.getColWidth(col) !== maxWidth && table._clearColRangeWidthsMap(col), update2 ? newWidths[col] = Math.round(table._adjustColWidth(col, maxWidth)) : table._setColWidth(col, table._adjustColWidth(col, maxWidth), false, true);
  }
  if ("adaptive" === table.widthMode) {
    table._clearColRangeWidthsMap();
    const canvasWidth = table.tableNoFrameWidth;
    let actualHeaderWidth = 0, startCol = 0, endCol = table.colCount;
    if ("only-body" === table.widthAdaptiveMode) {
      for (let col = 0; col < table.colCount; col++) {
        const colWidth = update2 && null !== (_e = newWidths[col]) && void 0 !== _e ? _e : table.getColWidth(col);
        (col < table.rowHeaderLevelCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) && (actualHeaderWidth += colWidth);
      }
      startCol = table.rowHeaderLevelCount, endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
    }
    getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, update2, newWidths, table);
  } else if (table.autoFillWidth) {
    table._clearColRangeWidthsMap();
    const canvasWidth = table.tableNoFrameWidth;
    let actualHeaderWidth = 0, actualWidth = 0;
    for (let col = 0; col < table.colCount; col++) {
      const colWidth = update2 && null !== (_f = newWidths[col]) && void 0 !== _f ? _f : table.getColWidth(col);
      (col < table.rowHeaderLevelCount + table.leftRowSeriesNumberCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) && (actualHeaderWidth += colWidth), actualWidth += colWidth;
    }
    if (actualWidth < canvasWidth && actualWidth > actualHeaderWidth) {
      getAdaptiveWidth(canvasWidth - actualHeaderWidth, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount, update2, newWidths, table);
    }
  }
  if (update2) {
    for (let col = 0; col < table.colCount; col++) {
      const newColWidth = null !== (_h = null !== (_g = newWidths[col]) && void 0 !== _g ? _g : table.getColWidth(col)) && void 0 !== _h ? _h : table.getColWidth(col);
      newColWidth !== oldColWidths[col] && table._setColWidth(col, newColWidth, false, true);
    }
    table.stateManager.checkFrozen();
    for (let col = 0; col < table.colCount; col++) {
      const newColWidth = table.getColWidth(col);
      newColWidth !== oldColWidths[col] && table.scenegraph.updateColWidth(col, newColWidth - oldColWidths[col], true, true);
    }
    table.scenegraph.updateContainer(true);
  }
  table.isPivotTable() && (layoutMap.disableUseGetBodyCache(), layoutMap.disableUseHeaderPathCache());
}
function computeColWidth(col, startRow, endRow, table, forceCompute = false) {
  let width = getColWidthDefinedWidthResizedWidth(col, table);
  return table.internalProps.transpose && "auto" === width && ("only-header" === table.columnWidthComputeMode && col >= table.rowHeaderLevelCount || "only-body" === table.columnWidthComputeMode && col < table.rowHeaderLevelCount) && (width = table.getDefaultColumnWidth(col)), forceCompute && !table.internalProps.transpose ? computeAutoColWidth(width, col, startRow, endRow, forceCompute, table) : "number" == typeof width ? width : "auto" !== width && "string" == typeof width ? table._adjustColWidth(col, table._colWidthDefineToPxWidth(width)) : computeAutoColWidth(width, col, startRow, endRow, forceCompute, table);
}
function computeAutoColWidth(widthDeifne, col, startRow, endRow, forceCompute, table) {
  var _a, _b, _c, _d, _e;
  let maxWidth = 0, deltaRow = 1, prepareDeltaRow = 1;
  if (endRow - startRow > 5e3 && (prepareDeltaRow = Math.ceil((endRow - startRow) / 5e3)), table.isPivotChart() && col >= table.rowHeaderLevelCount && col < table.colCount - table.rightFrozenColCount) {
    if (table.internalProps.layoutMap.indicatorsAsCol) return table.defaultColWidth;
    {
      const optimunWidth = table.internalProps.layoutMap.getOptimunWidthForChart(col);
      if (optimunWidth > 0) return optimunWidth;
    }
  }
  for (let row = startRow; row <= endRow; row += deltaRow) {
    if (table.isPivotChart()) {
      const layout = table.internalProps.layoutMap, axisConfig = layout.getAxisConfigInPivotChart(col, row);
      if (axisConfig) {
        const axisWidth = Factory2.getFunction("computeAxisComponentWidth")(axisConfig, table);
        if ("number" == typeof axisWidth) {
          maxWidth = Math.max(axisWidth, maxWidth);
          continue;
        }
      } else if (layout.isLeftBottomCorner(col, row) || layout.isRightTopCorner(col, row) || layout.isRightBottomCorner(col, row)) continue;
    }
    const customWidth = computeCustomRenderWidth(col, row, table);
    if (customWidth && (maxWidth = Math.max(customWidth.width, maxWidth), !customWidth.renderDefault)) continue;
    const indicatorWidth = widthDeifne;
    if ("number" == typeof indicatorWidth && "standard" === table.widthMode && !forceCompute) {
      maxWidth = Math.max(indicatorWidth, maxWidth);
      continue;
    }
    const cellType = table.isHeader(col, row) ? null === (_a = table._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.headerType : table.getBodyColumnType(col, row);
    if (isValid_default(cellType) && "text" !== cellType && "link" !== cellType && "progressbar" !== cellType && "checkbox" !== cellType && "radio" !== cellType && "switch" !== cellType && "button" !== cellType) {
      maxWidth = Math.max(maxWidth, table.getColWidthDefinedNumber(col) || 0);
      continue;
    }
    let cellHierarchyIndent = 0;
    const layoutMap = table.internalProps.layoutMap;
    if (layoutMap.isHeader(col, row)) {
      const hd = layoutMap.getHeader(col, row);
      if ("only-body" === (null === (_b = null == hd ? void 0 : hd.define) || void 0 === _b ? void 0 : _b.columnWidthComputeMode)) continue;
      isValid_default(null == hd ? void 0 : hd.hierarchyLevel) && (cellHierarchyIndent = (null !== (_c = hd.hierarchyLevel) && void 0 !== _c ? _c : 0) * ("tree" === layoutMap.rowHierarchyType && null !== (_d = layoutMap.rowHierarchyIndent) && void 0 !== _d ? _d : 0), layoutMap.rowHierarchyTextStartAlignment && !table.internalProps.headerHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth()));
    } else if (table.isListTable()) {
      deltaRow = prepareDeltaRow;
      const define = table.getBodyColumnDefine(col, row);
      if (null == define ? void 0 : define.tree) {
        const indexArr = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row));
        cellHierarchyIndent = Array.isArray(indexArr) && table.getHierarchyState(col, row) !== HierarchyState.none ? (indexArr.length - 1) * (null !== (_e = layoutMap.hierarchyIndent) && void 0 !== _e ? _e : 0) : 0, layoutMap.hierarchyTextStartAlignment && !table.internalProps.bodyHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth());
      }
    }
    const textWidth = computeTextWidth(col, row, cellType, table);
    maxWidth = Math.max(textWidth + cellHierarchyIndent, maxWidth), deltaRow > 1 && table.bottomFrozenRowCount > 0 && row < table.rowCount - table.bottomFrozenRowCount && row + deltaRow >= table.rowCount - table.bottomFrozenRowCount && (row = table.rowCount - table.bottomFrozenRowCount - deltaRow, deltaRow = 1, prepareDeltaRow = 1);
  }
  const colMinWidth = table.getMinColWidth(col), colMaxWidth = table.getMaxColWidth(col);
  return maxWidth < colMinWidth ? colMinWidth : maxWidth > colMaxWidth ? colMaxWidth : (maxWidth <= 0 && (maxWidth = table.defaultColWidth), maxWidth);
}
function computeCustomRenderWidth(col, row, table) {
  var _a, _b, _c, _d, _e, _f, _g;
  const customRender = table.getCustomRender(col, row);
  let customLayout = table.getCustomLayout(col, row);
  if (customRender || customLayout) {
    let cellRange, spanCol = 1, width = 0, renderDefault = false, enableCellPadding = false;
    (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) && (cellRange = table.getCellRange(col, row), spanCol = cellRange.end.col - cellRange.start.col + 1);
    const arg = {
      col: null !== (_b = null == cellRange ? void 0 : cellRange.start.col) && void 0 !== _b ? _b : col,
      row: null !== (_c = null == cellRange ? void 0 : cellRange.start.row) && void 0 !== _c ? _c : row,
      dataValue: table.getCellOriginValue(col, row),
      value: table.getCellValue(col, row) || "",
      rect: getCellRect2(col, row, table),
      table,
      originCol: col,
      originRow: row,
      forComputation: true
    };
    if ("react-custom-layout" === customLayout && (customLayout = (null === (_d = table.reactCustomLayout) || void 0 === _d ? void 0 : _d.getCustomLayoutFunc(col, row)) || emptyCustomLayout), isFunction_default(customLayout)) {
      const customLayoutObj = customLayout(arg);
      if (customLayoutObj.rootContainer) {
        customLayoutObj.rootContainer = decodeReactDom(customLayoutObj.rootContainer), dealPercentCalc(customLayoutObj.rootContainer, 0, table.getRowHeight(row));
        const setedWidth = customLayoutObj.rootContainer.attribute.width;
        customLayoutObj.rootContainer.setStage(table.scenegraph.stage), width = setedWidth > 0 ? setedWidth : null !== (_e = customLayoutObj.rootContainer.AABBBounds.width()) && void 0 !== _e ? _e : 0, renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding;
      } else width = 0, renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding;
    } else if ("function" == typeof customRender) {
      const customRenderObj = customRender(arg);
      width = null !== (_f = null == customRenderObj ? void 0 : customRenderObj.expectedWidth) && void 0 !== _f ? _f : 0, renderDefault = null == customRenderObj ? void 0 : customRenderObj.renderDefault;
    } else width = null !== (_g = null == customRender ? void 0 : customRender.expectedWidth) && void 0 !== _g ? _g : 0, renderDefault = null == customRender ? void 0 : customRender.renderDefault;
    if (width = Math.ceil(width), enableCellPadding) {
      const actStyle = table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", actStyle, col, row, table));
      width += padding[1] + padding[3];
    }
    return {
      width: width / spanCol,
      renderDefault
    };
  }
}
function computeTextWidth(col, row, cellType, table) {
  var _a, _b, _c, _d;
  let maxWidth = 0;
  const cellValue = table.getCellValue(col, row), actStyle = table._getCellStyle(col, row);
  let iconWidth = 0, mayHaveIcon = false;
  if ("body" !== table.getCellLocation(col, row)) mayHaveIcon = true;
  else {
    const define = table.getBodyColumnDefine(col, row);
    mayHaveIcon = !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree) || (null == define ? void 0 : define.dragOrder);
  }
  if (mayHaveIcon) {
    const icons2 = table.getCellIcons(col, row);
    null == icons2 || icons2.forEach((icon2) => {
      var _a2, _b2, _c2;
      icon2.positionType !== IconPosition.absoluteRight && (iconWidth += (null !== (_a2 = icon2.width) && void 0 !== _a2 ? _a2 : 0) + (null !== (_b2 = icon2.marginLeft) && void 0 !== _b2 ? _b2 : 0) + (null !== (_c2 = icon2.marginRight) && void 0 !== _c2 ? _c2 : 0));
    });
  }
  let spanCol = 1;
  if (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) {
    const cellRange = table.getCellRange(col, row);
    spanCol = cellRange.end.col - cellRange.start.col + 1;
  }
  const padding = getQuadProps(getProp2("padding", actStyle, col, row, table)), paddingWidth = padding[1] + padding[3], fontSize = getProp2("fontSize", actStyle, col, row, table), fontFamily = getProp2("fontFamily", actStyle, col, row, table), fontWeight = getProp2("fontWeight", actStyle, col, row, table);
  let text2;
  if ("checkbox" === cellType) text2 = isObject_default(cellValue) ? cellValue.text : cellValue;
  else if ("radio" === cellType) if (isArray_default(cellValue)) {
    text2 = "";
    const define = table.getBodyColumnDefine(col, row), radioDirectionInCell = null !== (_b = null == define ? void 0 : define.radioDirectionInCell) && void 0 !== _b ? _b : "vertical";
    "vertical" === radioDirectionInCell ? cellValue.forEach((line) => {
      text2 += (isObject_default(line) ? line.text : line).toString() + "\n";
    }) : "horizontal" === radioDirectionInCell && cellValue.forEach((line) => {
      text2 += (isObject_default(line) ? line.text : line).toString();
    });
  } else text2 = isObject_default(cellValue) ? cellValue.text : cellValue;
  else if ("button" === cellType) {
    const define = table.getBodyColumnDefine(col, row), buttonTextValue = getOrApply(define.text, {
      col,
      row,
      table,
      context: null,
      value: cellValue,
      dataValue: table.getCellOriginValue(col, row)
    });
    text2 = null !== (_c = null != buttonTextValue ? buttonTextValue : cellValue) && void 0 !== _c ? _c : "";
  } else text2 = cellValue;
  const lines = breakString(text2, table).text;
  if (lines.length >= 1 && (1 !== lines.length || "" !== lines[0]) ? lines.forEach((line) => {
    const width = table.measureText(line, {
      fontSize,
      fontFamily,
      fontWeight
    }).width;
    maxWidth = Math.max((width + paddingWidth + 4 + iconWidth) / spanCol, maxWidth);
  }) : maxWidth = Math.max((paddingWidth + 4 + iconWidth) / spanCol, maxWidth), false !== table.internalProps.limitMaxAutoWidth && (maxWidth = Math.min("number" == typeof table.internalProps.limitMaxAutoWidth ? table.internalProps.limitMaxAutoWidth : 450, maxWidth)), "checkbox" === cellType) {
    const size = getProp2("size", actStyle, col, row, table);
    if (maxWidth += size, text2) {
      const spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", actStyle, col, row, table);
      maxWidth += spaceBetweenTextAndIcon;
    }
  } else if ("radio" === cellType) {
    const size = getProp2("size", actStyle, col, row, table), outerRadius = getProp2("outerRadius", actStyle, col, row, table), circleSize = isNumber_default(outerRadius) ? 2 * outerRadius : size, spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", actStyle, col, row, table);
    if (isArray_default(cellValue)) {
      const define = table.getBodyColumnDefine(col, row), spaceBetweenRadio = getProp2("spaceBetweenRadio", actStyle, col, row, table), radioDirectionInCell = null !== (_d = null == define ? void 0 : define.radioDirectionInCell) && void 0 !== _d ? _d : "vertical";
      "vertical" === radioDirectionInCell ? (maxWidth += circleSize, maxWidth += spaceBetweenTextAndIcon) : "horizontal" === radioDirectionInCell && (maxWidth += (circleSize + spaceBetweenTextAndIcon) * cellValue.length, maxWidth += spaceBetweenRadio * (cellValue.length - 1));
    } else maxWidth += circleSize, text2 && (maxWidth += spaceBetweenTextAndIcon);
  } else if ("switch" === cellType) {
    const boxWidth = getProp2("boxWidth", actStyle, col, row, table);
    maxWidth = boxWidth;
  } else if ("button" === cellType) {
    const buttonPadding = getProp2("buttonPadding", actStyle, col, row, table);
    maxWidth += 2 * buttonPadding;
  }
  return maxWidth;
}
function getCellRect2(col, row, table) {
  return {
    left: 0,
    top: 0,
    right: table.getColWidth(col),
    bottom: table.getRowHeight(row),
    width: null,
    height: null
  };
}
function getColWidthDefinedWidthResizedWidth(col, table) {
  const widthDefined = table.getColWidthDefined(col);
  return table.internalProps._widthResizedColMap.has(col) ? table.getColWidth(col) : widthDefined;
}
function getAdaptiveWidth(totalDrawWidth, startCol, endColPlus1, update2, newWidths, table, fromScenegraph) {
  var _a, _b, _c, _d;
  let actualWidth = 0;
  const adaptiveColumns = [], sparklineColumns = [];
  let totalSparklineAbleWidth = 0;
  for (let col = startCol; col < endColPlus1; col++) {
    const width = update2 && null !== (_a = newWidths[col]) && void 0 !== _a ? _a : table.getColWidth(col), maxWidth = table.getMaxColWidth(col), minWidth = table.getMinColWidth(col);
    if (width !== maxWidth && width !== minWidth ? (actualWidth += width, adaptiveColumns.push(col)) : totalDrawWidth -= width, null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.shrinkSparklineFirst) {
      "sparkline" === table.getBodyColumnType(col, 0) && (sparklineColumns.push({
        col,
        width
      }), totalSparklineAbleWidth += width - table.defaultColWidth);
    }
  }
  const factor = totalDrawWidth / actualWidth;
  if ((null === (_c = table.options.customConfig) || void 0 === _c ? void 0 : _c.shrinkSparklineFirst) && factor < 1 && actualWidth - totalDrawWidth < totalSparklineAbleWidth) for (let i = 0; i < sparklineColumns.length; i++) {
    const { col, width } = sparklineColumns[i], deltaWidth = (actualWidth - totalDrawWidth) / sparklineColumns.length, colWidth = Math.floor(width - deltaWidth);
    update2 ? newWidths[col] = table._adjustColWidth(col, colWidth) : fromScenegraph ? table.scenegraph.setColWidth(col, table._adjustColWidth(col, colWidth)) : table._setColWidth(col, table._adjustColWidth(col, colWidth), false, true);
  }
  else for (let i = 0; i < adaptiveColumns.length; i++) {
    const col = adaptiveColumns[i];
    let colWidth;
    colWidth = i === adaptiveColumns.length - 1 ? totalDrawWidth - adaptiveColumns.reduce((acr, cur, index) => {
      var _a2;
      return cur !== col ? acr + (update2 ? null !== (_a2 = newWidths[cur]) && void 0 !== _a2 ? _a2 : table.getColWidth(col) : table.getColWidth(cur)) : acr;
    }, 0) : Math.round((update2 && null !== (_d = newWidths[col]) && void 0 !== _d ? _d : table.getColWidth(col)) * factor), update2 ? newWidths[col] = table._adjustColWidth(col, colWidth) : fromScenegraph ? table.scenegraph.setColWidth(col, table._adjustColWidth(col, colWidth)) : table._setColWidth(col, table._adjustColWidth(col, colWidth), false, true);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/utils/empty-group.js
var emptyGroup = new Group2({});
emptyGroup.role = "empty";

// node_modules/@visactor/vtable/es/scenegraph/group-creater/column-helper.js
function createComplexColumn(columnGroup, col, colWidth, rowStart, rowEnd, mergeMap, defaultRowHeight, table, rowLimit) {
  var _a, _b;
  let padding, textAlign, textBaseline, y = 0;
  columnGroup.lastChild && columnGroup.lastChild.row === rowStart - 1 ? y = columnGroup.lastChild.attribute.y + columnGroup.lastChild.attribute.height : columnGroup.colHeight && (y = columnGroup.colHeight);
  for (let j = rowStart; j <= rowEnd; j++) {
    const row = j;
    let range5, isMerge, customStyle, customResult, cellLocation = table.getCellLocation(col, row), value = table.getCellValue(col, row), cellWidth = colWidth, cellHeight = table.getRowHeight(row), isCustomMerge = false;
    if (table.internalProps.customMergeCell) {
      const customMerge = table.getCustomMerge(col, row);
      if (customMerge) {
        const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout, customRender } = customMerge;
        if (range5 = customMergeRange, isMerge = range5.start.col !== range5.end.col || range5.start.row !== range5.end.row, isMerge) {
          const mergeSize = dealMerge(range5, mergeMap, table, rowStart > range5.start.row);
          cellWidth = mergeSize.cellWidth, cellHeight = mergeSize.cellHeight;
        }
        value = customMergeText, customStyle = customMergeStyle, (customLayout || customRender) && (customResult = dealWithCustom(customLayout, customRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range5, table)), isCustomMerge = true;
      }
    }
    let define, colForDefine = col, rowForDefine = row;
    range5 && (colForDefine = range5.start.col, rowForDefine = range5.start.row), !table.isPivotTable() && ("columnHeader" === cellLocation || "cornerHeader" === cellLocation) && row >= table.columnHeaderLevelCount && (cellLocation = "body"), define = !table.isPivotTable() && table.isSeriesNumberInBody(col, row) ? table.getBodyColumnDefine(colForDefine, rowForDefine) : "body" !== cellLocation ? table.getHeaderDefine(colForDefine, rowForDefine) : table.getBodyColumnDefine(colForDefine, rowForDefine);
    const isAggregation = "isAggregation" in table.internalProps.layoutMap && table.internalProps.layoutMap.isAggregation(col, row), isSeriesNumber = table.internalProps.layoutMap.isSeriesNumber(col, row);
    let mayHaveIcon = "body" !== cellLocation || ((null == define ? void 0 : define.dragOrder) || !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree)) && !(isAggregation && isSeriesNumber);
    if (!range5 && (table.internalProps.enableTreeNodeMerge || "body" !== cellLocation || (null == define ? void 0 : define.mergeCell)) && (range5 = table.getCellRange(col, row), isMerge = range5.start.col !== range5.end.col || range5.start.row !== range5.end.row, isMerge)) {
      const mergeSize = dealMerge(range5, mergeMap, table, rowStart > range5.start.row);
      cellWidth = mergeSize.cellWidth, cellHeight = mergeSize.cellHeight;
    }
    let isVtableMerge = false;
    if (table.internalProps.enableTreeNodeMerge && isMerge) {
      const rawRecord = table.getCellRawRecord(range5.start.col, range5.start.row), { vtableMergeName, vtableMerge } = null != rawRecord ? rawRecord : {};
      isVtableMerge = vtableMerge, vtableMerge && (mayHaveIcon = true, table.options.groupTitleCustomLayout && (customResult = dealWithCustom(table.options.groupTitleCustomLayout, void 0, range5.start.col, range5.start.row, table.getColsWidth(range5.start.col, range5.end.col), table.getRowsHeight(range5.start.row, range5.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range5, table)), table.options.groupTitleFieldFormat ? value = table.options.groupTitleFieldFormat(rawRecord, col, row, table) : vtableMergeName && (value = vtableMergeName));
    }
    const type = isVtableMerge || isCustomMerge ? "text" : null !== (_b = table.isHeader(col, row) ? null !== (_a = table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _a ? _a : "text" : table.getBodyColumnType(col, row)) && void 0 !== _b ? _b : "text";
    if (isPromise(value)) {
      createEmptyCellGroup(col, row, 0, y, cellWidth, cellHeight, columnGroup), dealPromiseData(value, table, callCreateCellForPromiseValue.bind(null, {
        type,
        value,
        define,
        table,
        col,
        row,
        colWidth,
        cellWidth,
        cellHeight,
        columnGroup,
        y,
        customStyle,
        mayHaveIcon,
        cellLocation,
        range: range5,
        customResult,
        defaultRowHeight
      })), columnGroup.updateColumnRowNumber(row);
      const height = table.getRowHeight(row);
      columnGroup.updateColumnHeight(height), y += height;
    } else {
      const cellStyle = customStyle || table._getCellStyle(range5 ? range5.start.col : col, range5 ? range5.start.row : row), cellTheme = getStyleTheme(cellStyle, table, range5 ? range5.start.col : col, range5 ? range5.start.row : row, getProp2).theme;
      cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table), cellTheme.group.width = colWidth, cellTheme.group.height = Array.isArray(defaultRowHeight) ? defaultRowHeight[row] : defaultRowHeight, cellTheme._vtable.padding && (padding = cellTheme._vtable.padding), cellTheme.text.textAlign && (textAlign = cellTheme.text.textAlign), cellTheme.text.textBaseline && (textBaseline = cellTheme.text.textBaseline), "body" === cellLocation || cellTheme.group.fill || (cellTheme.group.fill = "#fff");
      const cellGroup = createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range5, customResult);
      if (columnGroup.updateColumnRowNumber(row), isMerge) {
        const rangeHeight = table.getRowHeight(row), { width: contentWidth } = (table.getColWidth(col), cellGroup.attribute), { height: contentHeight } = cellGroup.attribute;
        cellGroup.contentWidth = contentWidth, cellGroup.contentHeight = contentHeight, dealWithMergeCellSize(range5, contentWidth, contentHeight, padding, textAlign, textBaseline, table), columnGroup.updateColumnHeight(rangeHeight), y += rangeHeight;
      } else columnGroup.updateColumnHeight(cellHeight), y += cellHeight;
    }
    if (rowLimit && row > rowLimit) break;
  }
  return columnGroup.setAttribute("width", colWidth), {
    width: colWidth,
    height: y
  };
}
function callCreateCellForPromiseValue(createCellArgs) {
  let padding, textAlign, textBaseline;
  const { type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, cellLocation, mayHaveIcon, customStyle, range: range5, customResult, defaultRowHeight } = createCellArgs, cellStyle = customStyle || table._getCellStyle(range5 ? range5.start.col : col, range5 ? range5.start.row : row), cellTheme = getStyleTheme(cellStyle, table, range5 ? range5.start.col : col, range5 ? range5.start.row : row, getProp2).theme;
  cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table), cellTheme.group.width = colWidth, cellTheme.group.height = Array.isArray(defaultRowHeight) ? defaultRowHeight[row] : defaultRowHeight, cellTheme._vtable.padding && (padding = cellTheme._vtable.padding), cellTheme.text.textAlign && (textAlign = cellTheme.text.textAlign), cellTheme.text.textBaseline && (textBaseline = cellTheme.text.textBaseline), "body" === cellLocation || cellTheme.group.fill || (cellTheme.group.fill = "#fff"), createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range5, customResult);
}
function dealMerge(range5, mergeMap, table, forceUpdate) {
  let cellWidth = 0, cellHeight = 0;
  const mergeResult = mergeMap.get(`${range5.start.col},${range5.start.row};${range5.end.col},${range5.end.row}`);
  if (!mergeResult || forceUpdate) {
    for (let col = range5.start.col; col <= range5.end.col; col++) cellWidth += table.getColWidth(col);
    for (let i = range5.start.row; i <= range5.end.row; i++) cellHeight += table.getRowHeight(i);
    mergeMap.set(`${range5.start.col},${range5.start.row};${range5.end.col},${range5.end.row}`, {
      cellWidth,
      cellHeight
    });
  } else cellWidth = mergeResult.cellWidth, cellHeight = mergeResult.cellHeight;
  return {
    cellWidth,
    cellHeight
  };
}
function createEmptyCellGroup(col, row, x, y, width, height, columnGroup) {
  const cellGroup = new Group2({
    x,
    y,
    width,
    height
  });
  cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, columnGroup.addChild(cellGroup);
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/column.js
function createColGroup(containerGroup, xOrigin, yOrigin, colStart, colEnd, rowStart, rowEnd, cellLocation, table, rowLimit) {
  if (colStart > colEnd || rowStart > rowEnd) return;
  const { layoutMap, defaultHeaderRowHeight, defaultColWidth } = table.internalProps, defaultRowHeight = table.defaultRowHeight;
  let x = 0, heightMax = 0;
  for (let i = colStart; i <= colEnd; i++) {
    const col = i, colWidth = table.getColWidth(col), columnGroup = new Group2({
      x: xOrigin + x,
      y: yOrigin,
      width: colWidth,
      height: 0,
      clip: false,
      pickable: false
    });
    columnGroup.role = "column", columnGroup.col = i, containerGroup.addChild(columnGroup);
    const { width: default2Width, height: default2Height } = createComplexColumn(columnGroup, col, colWidth, rowStart, rowEnd, table.scenegraph.mergeMap, "columnHeader" === cellLocation && isNumber_default(defaultHeaderRowHeight) ? defaultHeaderRowHeight : defaultRowHeight, table, rowLimit);
    x += default2Width, heightMax = Math.max(heightMax, default2Height);
  }
  containerGroup.setAttribute("width", x), containerGroup.setAttribute("height", heightMax);
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/create-group-for-first-screen.js
function createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin, proxy) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const { table } = proxy, { leftBottomCornerGroup, rightTopCornerGroup, rightBottomCornerGroup } = table.scenegraph;
  let distCol, distRow, distColForCompute, distRowForCompute;
  proxy.setParamsForRow(), proxy.setParamsForColumn(), "adaptive" === table.widthMode || table.options.autoWrapText && ("adaptive" === table.heightMode || table.isAutoRowHeight(table.columnHeaderLevelCount)) ? (distColForCompute = table.colCount - 1, distCol = Math.min(proxy.firstScreenColLimit - 1, table.colCount - 1)) : distCol = Math.min(proxy.firstScreenColLimit - 1, table.colCount - 1), "adaptive" === table.heightMode ? (distRowForCompute = table.rowCount - 1, distRow = Math.min(proxy.firstScreenRowLimit - 1, table.rowCount - 1)) : distRow = Math.min(proxy.firstScreenRowLimit - 1, table.rowCount - 1), 0 === table.internalProps._widthResizedColMap.size && computeColsWidth(table, 0, null != distColForCompute ? distColForCompute : distCol), 0 === table.internalProps._heightResizedRowMap.size && computeRowsHeight(table, 0, "auto" === table.options.canvasHeight ? table.rowCount - 1 : null != distRowForCompute ? distRowForCompute : distRow), distCol < table.colCount - table.rightFrozenColCount && table.colCount - table.rightFrozenColCount <= table.colCount - 1 && computeColsWidth(table, table.colCount - table.rightFrozenColCount, table.colCount - 1), distRow < table.rowCount - table.bottomFrozenRowCount && table.rowCount - table.bottomFrozenRowCount <= table.rowCount - 1 && computeRowsHeight(table, table.rowCount - table.bottomFrozenRowCount, table.rowCount - 1), table.scenegraph.colHeaderGroup.setAttribute("x", table.getFrozenColsWidth()), table.scenegraph.rowHeaderGroup.setAttribute("y", table.getFrozenRowsHeight()), table.scenegraph.bottomFrozenGroup.setAttribute("x", table.getFrozenColsWidth()), table.scenegraph.rightFrozenGroup.setAttribute("y", table.getFrozenRowsHeight()), table.scenegraph.bodyGroup.setAttributes({
    x: table.getFrozenColsWidth(),
    y: table.getFrozenRowsHeight()
  }), createColGroup(cornerHeaderGroup, xOrigin, yOrigin, 0, table.frozenColCount - 1, 0, table.frozenRowCount - 1, table.isListTable() ? "columnHeader" : "cornerHeader", table), distCol - table.rightFrozenColCount >= table.frozenColCount && createColGroup(colHeaderGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, 0, table.frozenRowCount - 1, "columnHeader", table), table.frozenColCount > 0 && (table.leftRowSeriesNumberCount > 0 && createColGroup(rowHeaderGroup, xOrigin, yOrigin, 0, table.leftRowSeriesNumberCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, "rowHeader", table), table.frozenColCount > table.leftRowSeriesNumberCount && createColGroup(rowHeaderGroup, xOrigin, yOrigin, table.leftRowSeriesNumberCount, Math.min(table.frozenColCount - 1, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount - 1), table.frozenRowCount, distRow - table.bottomFrozenRowCount, "rowHeader", table), table.frozenColCount > table.rowHeaderLevelCount + table.leftRowSeriesNumberCount && createColGroup(rowHeaderGroup, xOrigin, yOrigin, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, table.frozenColCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, "body", table)), table.bottomFrozenRowCount > 0 && (table.frozenColCount > 0 && (table.leftRowSeriesNumberCount > 0 && createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, 0, table.leftRowSeriesNumberCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, "rowHeader", table), table.rowHeaderLevelCount > 0 && createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, table.leftRowSeriesNumberCount, table.leftRowSeriesNumberCount + table.rowHeaderLevelCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, "rowHeader", table), table.frozenColCount > table.rowHeaderLevelCount + table.leftRowSeriesNumberCount && createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, table.frozenColCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, "body", table)), distCol - table.rightFrozenColCount >= table.frozenColCount && createColGroup(bottomFrozenGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, table.isPivotChart() ? "rowHeader" : "body", table)), table.rightFrozenColCount > 0 && (createColGroup(rightTopCornerGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, 0, table.frozenRowCount - 1, "columnHeader", table), createColGroup(rightFrozenGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, table.isPivotChart() ? "rowHeader" : "body", table)), table.bottomFrozenRowCount > 0 && table.rightFrozenColCount > 0 && createColGroup(rightBottomCornerGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, "body", table), distCol - table.rightFrozenColCount >= table.frozenColCount && createColGroup(bodyGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, table.frozenRowCount, distRow - table.bottomFrozenRowCount, "body", table), bodyGroup.firstChild || colHeaderGroup.firstChild || cornerHeaderGroup.firstChild || rowHeaderGroup.firstChild ? (proxy.currentRow = null !== (_d = null !== (_b = null === (_a = bodyGroup.firstChild) || void 0 === _a ? void 0 : _a.rowNumber) && void 0 !== _b ? _b : null === (_c = rowHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.rowNumber) && void 0 !== _d ? _d : proxy.totalRow, proxy.rowEnd = proxy.currentRow, proxy.rowUpdatePos = proxy.rowEnd + 1, proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), proxy.currentCol = null !== (_m = null !== (_k = null !== (_h = null !== (_f = null === (_e = bodyGroup.lastChild) || void 0 === _e ? void 0 : _e.col) && void 0 !== _f ? _f : null === (_g = colHeaderGroup.lastChild) || void 0 === _g ? void 0 : _g.col) && void 0 !== _h ? _h : null === (_j = rowHeaderGroup.lastChild) || void 0 === _j ? void 0 : _j.col) && void 0 !== _k ? _k : null === (_l = cornerHeaderGroup.lastChild) || void 0 === _l ? void 0 : _l.col) && void 0 !== _m ? _m : proxy.totalCol, proxy.colEnd = proxy.currentCol, proxy.colUpdatePos = proxy.colEnd + 1, proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2), proxy.progress()) : (proxy.currentRow = proxy.totalRow, proxy.rowEnd = proxy.currentRow, proxy.rowUpdatePos = proxy.rowEnd + 1, proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), proxy.currentCol = proxy.totalCol, proxy.colEnd = proxy.currentCol, proxy.colUpdatePos = proxy.colEnd + 1, proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2));
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/util.js
function getFirstChild(containerGroup) {
  let child = containerGroup.firstChild;
  for (; child && "group" !== child.type; ) child = child._next;
  return child;
}
function getLastChild(containerGroup) {
  let child = containerGroup.lastChild;
  for (; child && "group" !== child.type; ) child = child._prev;
  return child;
}
function getPrevGroup(group) {
  let child = group._prev;
  for (; child && "group" !== child.type; ) child = child._prev;
  return child;
}
function getNextGroup(group) {
  let child = group._next;
  for (; child && "group" !== child.type; ) child = child._next;
  return child;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/update-auto-column.js
function updateAutoColumn(colStart, colEnd, table, direction = "left") {
  for (let col = colStart; col <= colEnd; col++) {
    const bodyColGroup = table.scenegraph.getColGroup(col);
    bodyColGroup && moveColumnGroup(bodyColGroup, table, direction);
    const columnHeaderColGroup = table.scenegraph.getColGroup(col, true);
    columnHeaderColGroup && moveColumnGroup(columnHeaderColGroup, table, direction);
    const bottomColGroup = table.scenegraph.getColGroupInBottom(col);
    bottomColGroup && moveColumnGroup(bottomColGroup, table, direction);
  }
  const totalActualBodyColumnCount = Math.min(table.scenegraph.proxy.colLimit, table.scenegraph.proxy.bodyRightCol - table.scenegraph.proxy.bodyLeftCol + 1), totalBodyWidth = table.getColsWidth(table.frozenColCount, table.frozenColCount + totalActualBodyColumnCount), totalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
  table.scenegraph.proxy.xLimitLeft = totalBodyWidth / 2, table.scenegraph.proxy.xLimitRight = totalWidth - totalBodyWidth / 2;
}
function moveColumnGroup(colGroup, table, direction = "left") {
  if ("left" === direction) {
    let x;
    const prevCellGroup = getPrevGroup(colGroup);
    x = prevCellGroup ? prevCellGroup.attribute.x + table.getColWidth(colGroup._prev.col) : table.getColsWidth(table.frozenColCount, colGroup.col - 1), colGroup.setAttribute("x", x);
  } else {
    let x;
    const nextCellGroup = getNextGroup(colGroup);
    x = nextCellGroup ? nextCellGroup.attribute.x - table.getColWidth(colGroup.col) : table.getColsWidth(table.frozenColCount, colGroup.col - 1), colGroup.setAttribute("x", x);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/dynamic-set-x.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function dynamicSetX(x, screenLeft, isEnd, proxy) {
  return __awaiter9(this, void 0, void 0, function* () {
    if (!screenLeft) return;
    const screenLeftCol = screenLeft.col, screenLeftX = screenLeft.left;
    let deltaCol;
    if (deltaCol = isEnd ? proxy.bodyRightCol - proxy.colEnd : proxy.screenLeftCol - proxy.referenceCol, move(deltaCol, screenLeftCol, screenLeftX, x, proxy), isEnd) {
      const colGroup = proxy.table.scenegraph.getColGroup(proxy.colEnd);
      if (colGroup) {
        const deltaX = colGroup.attribute.x + colGroup.attribute.width - (proxy.table.tableNoFrameWidth - proxy.table.getFrozenColsWidth() - proxy.table.getRightFrozenColsWidth()) - x;
        proxy.deltaX = -deltaX, proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
      }
    }
    proxy.table.scenegraph.updateNextFrame();
  });
}
function move(deltaCol, screenLeftCol, screenLeftX, x, proxy) {
  deltaCol > 0 ? (moveColumn(deltaCol, "left", proxy.screenLeftCol, screenLeftX, x, proxy), proxy.updateDeltaX(x, screenLeftX, screenLeftCol), proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX)) : deltaCol < 0 ? (moveColumn(-deltaCol, "right", proxy.screenLeftCol, screenLeftX, x, proxy), proxy.updateDeltaX(x, screenLeftX, screenLeftCol), proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX)) : (proxy.updateDeltaX(x, screenLeftX, screenLeftCol), proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX));
}
function moveColumn(count, direction, screenLeftCol, screenLeftX, x, proxy) {
  return __awaiter9(this, void 0, void 0, function* () {
    if ("left" === direction && proxy.colEnd + count > proxy.bodyRightCol ? count = proxy.bodyRightCol - proxy.colEnd : "right" === direction && proxy.colStart - count < proxy.bodyLeftCol && (count = proxy.colStart - proxy.bodyLeftCol), 0 !== count) if (count < 0 && (direction = "left" === direction ? "right" : "left", count = -count), count < proxy.colEnd - proxy.colStart) {
      const startCol = "left" === direction ? proxy.colStart : proxy.colEnd - count + 1, endCol = "left" === direction ? proxy.colStart + count - 1 : proxy.colEnd, distStartCol = "left" === direction ? proxy.colEnd + 1 : proxy.colStart - count, distEndCol = "left" === direction ? proxy.colEnd + count : proxy.colStart - 1;
      computeColsWidth(proxy.table, distStartCol, distEndCol), updatePartColPosition(startCol, endCol, direction, proxy);
      const syncLeftCol = distStartCol, syncRightCol = distEndCol;
      proxy.colStart = "left" === direction ? proxy.colStart + count : proxy.colStart - count, proxy.colEnd = "left" === direction ? proxy.colEnd + count : proxy.colEnd - count, updateColContent(syncLeftCol, syncRightCol, proxy), updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, direction);
      const colGroup = proxy.table.scenegraph.getColGroup(screenLeftCol) || proxy.table.scenegraph.getColGroup(screenLeftCol, true), deltaX = screenLeftX - (colGroup.attribute.x + proxy.table.getFrozenColsWidth() + proxy.table.scenegraph.proxy.deltaX);
      proxy.table.scenegraph.proxy.deltaX += deltaX, proxy.currentCol = "left" === direction ? proxy.currentCol + count : proxy.currentCol - count, proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, "left" === direction ? proxy.totalCol + count : proxy.totalCol - count)), proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2), proxy.colUpdatePos = distStartCol, proxy.colUpdateDirection = direction, proxy.table.scenegraph.updateNextFrame();
    } else {
      const distStartCol = "left" === direction ? proxy.colStart + count : proxy.colStart - count, distEndCol = "left" === direction ? proxy.colEnd + count : proxy.colEnd - count;
      computeColsWidth(proxy.table, distStartCol, distEndCol);
      updateAllColPosition(proxy.table.getColsWidth(proxy.bodyLeftCol, distStartCol - 1), count, direction, proxy);
      const syncLeftCol = distStartCol, syncRightCol = distEndCol;
      proxy.colStart = distStartCol, proxy.colEnd = distEndCol, updateColContent(syncLeftCol, syncRightCol, proxy), updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left"), proxy.currentCol = "left" === direction ? proxy.currentCol + count : proxy.currentCol - count, proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, "left" === direction ? proxy.totalCol + count : proxy.totalCol - count)), proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2), proxy.colUpdatePos = proxy.colStart, proxy.colUpdateDirection = distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left", proxy.table.scenegraph.updateNextFrame();
    }
  });
}
function updateColGroupPosition(colGroup, newCol, x) {
  colGroup.col = newCol, colGroup.forEachChildren((cellGroup) => {
    cellGroup.col = newCol, cellGroup.needUpdate = true;
  }), colGroup.setAttribute("x", x), colGroup.needUpdate = true;
}
function updateColGroupContent(colGroup, proxy) {
  if (!colGroup) return;
  let cellGroup = colGroup.firstChild;
  for (; cellGroup; ) {
    cellGroup = proxy.updateCellGroupContent(cellGroup)._next;
  }
  colGroup.needUpdate = false, colGroup.setAttribute("width", proxy.table.getColWidth(colGroup.col));
}
function updateColGroupContentAsync(colGroup, proxy) {
  if (!colGroup) return;
  const screenTopRow = proxy.screenTopRow, topRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), bottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1);
  for (let row = topRow; row <= bottomRow; row++) {
    const cellGroup = proxy.highPerformanceGetCell(colGroup.col, row, true);
    proxy.updateCellGroupContent(cellGroup);
  }
  proxy.rowUpdatePos = proxy.rowStart, colGroup.needUpdate = false, colGroup.setAttribute("width", proxy.table.getColWidth(colGroup.col));
}
function updatePartColPosition(startCol, endCol, direction, proxy) {
  for (let col = startCol; col <= endCol; col++) proxy.table.scenegraph.bodyGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.bodyGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.bodyGroup, direction, proxy), proxy.table.scenegraph.colHeaderGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.colHeaderGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.colHeaderGroup, direction, proxy), proxy.table.scenegraph.bottomFrozenGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.bottomFrozenGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.bottomFrozenGroup, direction, proxy);
}
function updateColPosition(containerGroup, direction, proxy) {
  if ("left" === direction) {
    const colGroup = getFirstChild(containerGroup), lastChild = getLastChild(containerGroup);
    updateColGroupPosition(colGroup, lastChild.col + 1, lastChild.attribute.x + proxy.table.getColWidth(lastChild.col)), containerGroup.appendChild(colGroup), containerGroup.border && containerGroup.appendChild(containerGroup.border);
  } else {
    const colGroup = getLastChild(containerGroup), firstChild = getFirstChild(containerGroup);
    updateColGroupPosition(colGroup, firstChild.col - 1, firstChild.attribute.x - proxy.table.getColWidth(firstChild.col - 1)), containerGroup.insertBefore(colGroup, containerGroup.firstChild);
  }
}
function updateColContent(syncLeftCol, syncRightCol, proxy) {
  for (let col = syncLeftCol; col <= syncRightCol; col++) {
    const colHeaderColGroup = proxy.table.scenegraph.getColGroup(col, true);
    colHeaderColGroup && updateColGroupContent(colHeaderColGroup, proxy);
    const bottomColGroup = proxy.table.scenegraph.getColGroupInBottom(col);
    bottomColGroup && updateColGroupContent(bottomColGroup, proxy);
    const rightTopColGroup = proxy.table.scenegraph.getColGroupInRightTopCorner(col);
    rightTopColGroup && updateColGroupContent(rightTopColGroup, proxy);
    const rightBottomColGroup = proxy.table.scenegraph.getColGroupInRightBottomCorner(col);
    rightBottomColGroup && updateColGroupContent(rightBottomColGroup, proxy);
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    colGroup && updateColGroupContentAsync(colGroup, proxy);
  }
  updateColumnContainerWidth(proxy.table.scenegraph.colHeaderGroup), updateColumnContainerWidth(proxy.table.scenegraph.bottomFrozenGroup), updateColumnContainerWidth(proxy.table.scenegraph.bodyGroup), proxy.progress();
}
function updateAllColPosition(distStartColY, count, direction, proxy) {
  proxy.table.scenegraph.colHeaderGroup.forEachChildren((colGroup, index) => {
    "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
  }), proxy.table.scenegraph.bottomFrozenGroup.forEachChildren((colGroup, index) => {
    "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
  }), proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
    "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
  });
}
function updateColumnContainerWidth(containerGroup) {
  var _a, _b;
  const lastColGroup = getLastChild(containerGroup);
  if (lastColGroup && (containerGroup.setAttribute("width", lastColGroup.attribute.x + lastColGroup.attribute.width), containerGroup.border)) {
    const border = containerGroup.border;
    border.setAttribute("width", lastColGroup.attribute.x + lastColGroup.attribute.width - (null !== (_a = border.attribute.borderLeft) && void 0 !== _a ? _a : 0) / 2 - (null !== (_b = border.attribute.borderRight) && void 0 !== _b ? _b : 0) / 2);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/update-auto-row.js
function updateAutoRow(colStart, colEnd, rowStart, rowEnd, table, direction = "up", part) {
  var _a, _b;
  if ("up" === direction) for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
    const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
    if ("cell" !== cellGroup.role || !cellGroup.row) continue;
    let y;
    if (cellGroup._prev) y = (null === (_a = cellGroup._prev) || void 0 === _a ? void 0 : _a.attribute.y) + table.getRowHeight(cellGroup._prev.row);
    else if (part) {
      const baseRowIndex = rowEnd === table.rowCount - table.bottomFrozenRowCount - 1 ? rowEnd : rowEnd + 1;
      if (y = table.scenegraph.highPerformanceGetCell(col, baseRowIndex, true).attribute.y, isValid_default(y)) for (let r = row; r < baseRowIndex; r++) y -= table.getRowHeight(r);
    } else y = getEstimatePosition(cellGroup.row, table);
    isValid_default(y) && cellGroup.setAttribute("y", y);
  }
  else for (let col = colStart; col <= colEnd; col++) for (let row = rowEnd; row >= rowStart; row--) {
    const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
    if ("cell" !== cellGroup.role || !cellGroup.row) continue;
    let y;
    if (cellGroup._next) y = (null === (_b = cellGroup._next) || void 0 === _b ? void 0 : _b.attribute.y) - table.getRowHeight(cellGroup.row);
    else if (part) {
      const baseRowIndex = rowStart <= table.frozenRowCount ? table.frozenRowCount : rowStart - 1;
      if (rowStart <= table.frozenRowCount) y = 0;
      else {
        y = table.scenegraph.highPerformanceGetCell(col, baseRowIndex, true).attribute.y;
      }
      for (let r = baseRowIndex; r < row; r++) {
        y += table.getRowHeight(r);
      }
    } else y = getEstimatePosition(cellGroup.row, table);
    isValid_default(y) && cellGroup.setAttribute("y", y);
  }
  const totalActualBodyRowCount = Math.min(table.scenegraph.proxy.rowLimit, table.scenegraph.proxy.bodyBottomRow - table.scenegraph.proxy.bodyTopRow + 1), totalBodyHeight = table.getRowsHeight(table.frozenRowCount, table.frozenRowCount + totalActualBodyRowCount), totalHeight = table.getRowsHeight(table.frozenRowCount, table.rowCount - 1);
  table.scenegraph.proxy.yLimitTop = totalBodyHeight / 2, table.scenegraph.proxy.yLimitBottom = totalHeight - totalBodyHeight / 2;
}
function getEstimatePosition(row, table) {
  let y;
  return y = row < table.frozenRowCount ? table.getRowsHeight(0, row - 1) : row >= table.rowCount - table.bottomFrozenRowCount ? table.getRowsHeight(table.rowCount - table.bottomFrozenRowCount, row - 1) : table.getRowsHeight(table.frozenRowCount, row - 1), y;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/dynamic-set-y.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function dynamicSetY(y, screenTop, isEnd, proxy) {
  return __awaiter10(this, void 0, void 0, function* () {
    if (!screenTop) return;
    const screenTopRow = screenTop.row, screenTopY = screenTop.top;
    let deltaRow;
    if (deltaRow = isEnd ? proxy.bodyBottomRow - proxy.rowEnd : screenTopRow - proxy.referenceRow, move2(deltaRow, screenTopRow, screenTopY, y, proxy), isEnd) {
      const cellGroup = proxy.table.scenegraph.highPerformanceGetCell(proxy.colStart, proxy.rowEnd, true);
      if ("cell" === cellGroup.role) {
        const deltaY = cellGroup.attribute.y + cellGroup.attribute.height - (proxy.table.tableNoFrameHeight - proxy.table.getFrozenRowsHeight() - proxy.table.getBottomFrozenRowsHeight()) - y;
        proxy.deltaY = -deltaY, proxy.updateBody(y - proxy.deltaY);
      }
    }
  });
}
function move2(deltaRow, screenTopRow, screenTopY, y, proxy) {
  deltaRow > 0 ? (moveCell(deltaRow, "up", screenTopRow, screenTopY, y, proxy), proxy.updateDeltaY(y, screenTopY, screenTopRow), proxy.updateBody(y - proxy.deltaY)) : deltaRow < 0 ? (moveCell(-deltaRow, "down", screenTopRow, screenTopY, y, proxy), proxy.updateDeltaY(y, screenTopY, screenTopRow), proxy.updateBody(y - proxy.deltaY)) : (proxy.updateDeltaY(y, screenTopY, screenTopRow), proxy.updateBody(y - proxy.deltaY));
}
function moveCell(count, direction, screenTopRow, screenTopY, y, proxy) {
  return __awaiter10(this, void 0, void 0, function* () {
    if ("up" === direction && proxy.rowEnd + count > proxy.bodyBottomRow ? count = proxy.bodyBottomRow - proxy.rowEnd : "down" === direction && proxy.rowStart - count < proxy.bodyTopRow && (count = proxy.rowStart - proxy.bodyTopRow), 0 !== count) if (count < 0 && (direction = "up" === direction ? "down" : "up", count = -count), count < proxy.rowEnd - proxy.rowStart) {
      const startRow = "up" === direction ? proxy.rowStart : proxy.rowEnd - count + 1, endRow = "up" === direction ? proxy.rowStart + count - 1 : proxy.rowEnd, distStartRow = "up" === direction ? proxy.rowEnd + 1 : proxy.rowStart - count, distEndRow = "up" === direction ? proxy.rowEnd + count : proxy.rowStart - 1;
      let syncTopRow, syncBottomRow;
      if (proxy.table.isAutoRowHeight(startRow)) syncTopRow = distStartRow, syncBottomRow = distEndRow;
      else {
        syncTopRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), syncBottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1);
      }
      computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, false), updatePartRowPosition(startRow, endRow, direction, proxy), proxy.rowStart = "up" === direction ? proxy.rowStart + count : proxy.rowStart - count, proxy.rowEnd = "up" === direction ? proxy.rowEnd + count : proxy.rowEnd - count;
      const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, true);
      proxy.table.isAutoRowHeight(startRow) && (updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", true), updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", true), updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", true)), proxy.currentRow = "up" === direction ? proxy.currentRow + count : proxy.currentRow - count, proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, "up" === direction ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1)), proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), proxy.table.isAutoRowHeight(startRow) && sync ? proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, proxy.rowEnd + 1) : proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, distStartRow), proxy.rowUpdateDirection = direction, proxy.table.scenegraph.updateNextFrame(), yield proxy.progress();
    } else {
      const distStartRow = "up" === direction ? proxy.rowStart + count : proxy.rowStart - count, distEndRow = Math.min(proxy.table.rowCount - 1, "up" === direction ? proxy.rowEnd + count : proxy.rowEnd - count), distStartRowY = proxy.table.getRowsHeight(proxy.bodyTopRow, distStartRow - 1);
      let syncTopRow, syncBottomRow;
      proxy.table.isAutoRowHeight(distStartRow) ? (syncTopRow = distStartRow, syncBottomRow = distEndRow) : (syncTopRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), syncBottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1)), computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, false), updateAllRowPosition(distStartRowY, count, direction, proxy), proxy.rowStart = distStartRow, proxy.rowEnd = distEndRow;
      const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, true);
      proxy.table.isAutoRowHeight(distStartRow) && (updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up")), proxy.currentRow = "up" === direction ? proxy.currentRow + count : proxy.currentRow - count, proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, "up" === direction ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1)), proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), proxy.table.isAutoRowHeight(distStartRow) && sync ? proxy.rowUpdatePos = proxy.rowEnd + 1 : proxy.rowUpdatePos = proxy.rowStart, proxy.rowUpdateDirection = distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", proxy.table.scenegraph.updateNextFrame(), yield proxy.progress();
    }
  });
}
function updatePartRowPosition(startRow, endRow, direction, proxy) {
  for (let col = 0; col < proxy.table.frozenColCount; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
  }
  for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
  }
  for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
  }
}
function updateCellGroupPosition(colGroup, direction, proxy) {
  if (colGroup.childrenCount >= 1) if ("up" === direction) {
    const cellGroup = colGroup.firstChild;
    proxy.updateCellGroupPosition(cellGroup, colGroup.lastChild.row + 1, colGroup.lastChild.attribute.y + proxy.table.getRowHeight(colGroup.lastChild.row)), colGroup.appendChild(cellGroup);
  } else {
    const cellGroup = colGroup.lastChild;
    proxy.updateCellGroupPosition(cellGroup, colGroup.firstChild.row - 1, colGroup.firstChild.attribute.y - proxy.table.getRowHeight(cellGroup.row)), colGroup.insertBefore(cellGroup, colGroup.firstChild);
  }
}
function updateAllRowPosition(distStartRowY, count, direction, proxy) {
  for (let col = 0; col < proxy.table.frozenColCount; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    null == colGroup || colGroup.forEachChildren((cellGroup, index) => {
      proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
    });
  }
  for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    null == colGroup || colGroup.forEachChildren((cellGroup, index) => {
      proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
    });
  }
  for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
    const colGroup = proxy.table.scenegraph.getColGroup(col);
    null == colGroup || colGroup.forEachChildren((cellGroup, index) => {
      proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
    });
  }
}
function updateRowContent(syncTopRow, syncBottomRow, proxy, async = false) {
  for (let col = 0; col < proxy.table.frozenColCount; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
    const cellGroup = proxy.highPerformanceGetCell(col, row, true);
    proxy.updateCellGroupContent(cellGroup);
  }
  for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
    const cellGroup = proxy.highPerformanceGetCell(col, row);
    proxy.updateCellGroupContent(cellGroup);
  }
  let leftCol = proxy.bodyLeftCol, rightCol = proxy.bodyRightCol, sync = true;
  if (async) {
    const screenLeftCol = proxy.screenLeftCol;
    leftCol = Math.max(proxy.bodyLeftCol, screenLeftCol - 1 * proxy.screenColCount), rightCol = Math.min(proxy.bodyRightCol, screenLeftCol + 2 * proxy.screenColCount), leftCol === proxy.bodyLeftCol && rightCol === proxy.bodyRightCol || (sync = false);
  }
  for (let col = leftCol; col <= rightCol; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
    const cellGroup = proxy.highPerformanceGetCell(col, row);
    proxy.updateCellGroupContent(cellGroup);
  }
  return updateColumnContainerHeight(proxy.table.scenegraph.rowHeaderGroup), updateColumnContainerHeight(proxy.table.scenegraph.rightFrozenGroup), updateColumnContainerHeight(proxy.table.scenegraph.bodyGroup), proxy.table.scenegraph.updateNextFrame(), sync;
}
function updateColumnContainerHeight(containerGroup) {
  var _a, _b;
  const lastColGroup = getLastChild(containerGroup);
  if (!lastColGroup) return;
  const lastCellGroup = getLastChild(lastColGroup);
  if (lastCellGroup && (containerGroup.setAttribute("height", lastCellGroup.attribute.y + lastCellGroup.attribute.height), containerGroup.border)) {
    const border = containerGroup.border;
    border.setAttribute("height", lastCellGroup.attribute.y + lastCellGroup.attribute.height - (null !== (_a = border.attribute.borderTop) && void 0 !== _a ? _a : 0) / 2 - (null !== (_b = border.attribute.borderBottom) && void 0 !== _b ? _b : 0) / 2);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/sort-vertical.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function sortVertical(proxy) {
  var _a;
  return __awaiter11(this, void 0, void 0, function* () {
    let syncTopRow, syncBottomRow;
    proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
      "group" === colGroup.type && (colGroup.needUpdate = true, null == colGroup || colGroup.forEachChildren((cellGroup) => {
        cellGroup.needUpdate = true;
      }));
    }), proxy.table.isAutoRowHeight(proxy.rowStart) ? (syncTopRow = proxy.rowStart, syncBottomRow = proxy.rowEnd) : (syncTopRow = Math.max(proxy.bodyTopRow, proxy.screenTopRow - 1 * proxy.screenRowCount), syncBottomRow = Math.min(proxy.bodyBottomRow, proxy.screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1));
    const oldBodyHeight = proxy.table.getAllRowsHeight();
    computeRowsHeight(proxy.table, syncTopRow, syncBottomRow);
    const newBodyHeight = proxy.table.getAllRowsHeight();
    oldBodyHeight !== newBodyHeight && proxy.table.scenegraph.updateContainerHeight(proxy.table.frozenRowCount, newBodyHeight - oldBodyHeight);
    for (let col = 0; col < (null !== (_a = proxy.table.frozenColCount) && void 0 !== _a ? _a : 0); col++) {
      const columnGroup = proxy.table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
      for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
    }
    for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
      const columnGroup = proxy.table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
    }
    for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
      const columnGroup = proxy.table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
      for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
    }
    updateRowContent(syncTopRow, syncBottomRow, proxy), proxy.table.isAutoRowHeight(syncTopRow) && updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), proxy.rowUpdatePos = proxy.rowStart, proxy.rowUpdateDirection = proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", proxy.table.scenegraph.updateNextFrame(), proxy.table.isAutoRowHeight(proxy.rowStart) || (yield proxy.progress());
  });
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/update-position/sort-horizontal.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function sortHorizontal(proxy) {
  return __awaiter12(this, void 0, void 0, function* () {
    proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
      "group" === colGroup.type && (colGroup.needUpdate = true, null == colGroup || colGroup.forEachChildren((cellGroup) => {
        cellGroup.needUpdate = true;
      }));
    });
    const syncLeftCol = Math.max(proxy.bodyLeftCol, proxy.screenLeftCol - 1 * proxy.screenColCount), syncRightCol = Math.min(proxy.bodyRightCol, proxy.screenLeftCol + 2 * proxy.screenColCount);
    computeColsWidth(proxy.table, syncLeftCol, syncRightCol);
    for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
      const columnGroup = proxy.table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
    }
    for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
      const columnGroup = proxy.table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
      for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
    }
    updateColContent(syncLeftCol, syncRightCol, proxy), proxy.colUpdatePos = proxy.colStart, proxy.colUpdateDirection = proxy.colEnd > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left", proxy.table.scenegraph.updateNextFrame(), yield proxy.progress();
  });
}

// node_modules/@visactor/vtable/es/scenegraph/stick-text/index.js
function resetTextStick(table) {
  const { changedCells } = table.internalProps.stick;
  return changedCells.forEach((cellPos) => {
    table.scenegraph.getCell(cellPos.col, cellPos.row).forEachChildren((child) => {
      child.setAttributes({
        dx: cellPos.dx,
        dy: cellPos.dy
      });
    });
  }), changedCells.clear(), changedCells;
}
function handleTextStick(table) {
  const changedCells = resetTextStick(table), { scrollTop, scrollLeft, frozenRowCount, frozenColCount } = table, frozenRowsHeight = table.getFrozenRowsHeight(), frozenColsWidth = table.getFrozenColsWidth(), { row: rowTop } = table.getRowAt(scrollTop + frozenRowsHeight + 1), { col: colLeft } = table.getColAt(scrollLeft + frozenColsWidth + 1), rowStart = Math.max(rowTop, table.frozenRowCount), colStart = Math.max(colLeft, table.frozenColCount), rowEnd = table.getAllRowsHeight() > table.tableNoFrameHeight ? table.getRowAt(scrollTop + table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() - 1).row : table.rowCount - table.bottomFrozenRowCount - 1, colEnd = table.getAllColsWidth() > table.tableNoFrameWidth ? table.getColAt(scrollLeft + table.tableNoFrameWidth - table.getRightFrozenColsWidth() - 1).col : table.colCount - table.rightFrozenColCount - 1;
  if (!(colEnd < 0 || rowEnd < 0)) {
    for (let row = 0; row < frozenRowCount && !(colEnd < colStart); row++) [colStart, colEnd].forEach((col) => {
      const style2 = table._getCellStyle(col, row);
      if ((null == style2 ? void 0 : style2.textStick) && "vertical" !== (null == style2 ? void 0 : style2.textStick)) {
        adjustCellContentHorizontalLayout(table.scenegraph.getCell(col, row), frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, null == style2 ? void 0 : style2.textStickBaseOnAlign, table);
      }
    });
    for (let col = 0; col < frozenColCount && !(rowEnd < rowStart); col++) [rowStart, rowEnd].forEach((row) => {
      const style2 = table._getCellStyle(col, row);
      if ((null == style2 ? void 0 : style2.textStick) && "horizontal" !== (null == style2 ? void 0 : style2.textStick)) {
        adjustCellContentVerticalLayout(table.scenegraph.getCell(col, row), frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, null == style2 ? void 0 : style2.textStickBaseOnAlign, table);
      }
    });
    for (let col = colStart; col <= colEnd && !(rowEnd < rowStart); col++) [rowStart, rowEnd].forEach((row) => {
      const style2 = table._getCellStyle(col, row);
      if ((null == style2 ? void 0 : style2.textStick) && "horizontal" !== (null == style2 ? void 0 : style2.textStick)) {
        adjustCellContentVerticalLayout(table.scenegraph.getCell(col, row), frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, null == style2 ? void 0 : style2.textStickBaseOnAlign, table);
      }
    });
    for (let row = rowStart; row <= rowEnd && !(colEnd < colStart); row++) [colStart, colEnd].forEach((col) => {
      const style2 = table._getCellStyle(col, row);
      if ((null == style2 ? void 0 : style2.textStick) && "vertical" !== (null == style2 ? void 0 : style2.textStick)) {
        adjustCellContentHorizontalLayout(table.scenegraph.getCell(col, row), frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, null == style2 ? void 0 : style2.textStickBaseOnAlign, table);
      }
    });
  }
}
function adjustCellContentVerticalLayout(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign, table) {
  if (isNumber_default(cellGroup.mergeStartCol) && isNumber_default(cellGroup.mergeStartRow) && isNumber_default(cellGroup.mergeEndCol) && isNumber_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      const singleCellGroup = table.scenegraph.getCell(col, row);
      "cell" === singleCellGroup.role && dealVertical(singleCellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
    }
  } else dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
}
function dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
  const graphic = cellGroup.getChildByName("text", true) || cellGroup.getChildByName("image", true);
  if (!graphic) return;
  if ("image" === graphic.type) {
    const { image: url } = graphic.attribute;
    if (!url || !graphic.resources) return;
    if ("success" !== graphic.resources.get(url).state) return;
  }
  const textBaseline = null !== (_a = graphic.textBaseline) && void 0 !== _a ? _a : "top";
  graphic.AABBBounds.width();
  const textTop = graphic.globalAABBBounds.y1, textBottom = graphic.globalAABBBounds.y2;
  if ("middle" === textBaseline && textStickBaseOnAlign) {
    const cellTop = cellGroup.globalAABBBounds.y1 + (null !== (_c = null === (_b = cellGroup.firstChild) || void 0 === _b ? void 0 : _b.attribute.dy) && void 0 !== _c ? _c : 0), cellBottom = cellTop + (null !== (_e = null !== (_d = cellGroup.contentHeight) && void 0 !== _d ? _d : cellGroup.attribute.height) && void 0 !== _e ? _e : 0);
    if (cellTop < minTop || cellBottom > maxTop) {
      const visibleCellTop = Math.max(cellTop, minTop), visibleCellBottom = Math.min(cellBottom, maxTop), delta = graphic.globalTransMatrix.f - (visibleCellBottom + visibleCellTop) / 2 + graphic.AABBBounds.height() / 2;
      !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
        col: cellGroup.col,
        row: cellGroup.row,
        dx: null !== (_g = null === (_f = cellGroup.firstChild) || void 0 === _f ? void 0 : _f.attribute.dx) && void 0 !== _g ? _g : 0,
        dy: null !== (_j = null === (_h = cellGroup.firstChild) || void 0 === _h ? void 0 : _h.attribute.dy) && void 0 !== _j ? _j : 0
      }), cellGroup.forEachChildren((child) => {
        var _a2;
        child.setAttribute("dy", (null !== (_a2 = child.attribute.dy) && void 0 !== _a2 ? _a2 : 0) - delta + 2);
      });
    }
  } else if (textTop < minTop) {
    const deltaHeight = textTop - minTop;
    !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
      col: cellGroup.col,
      row: cellGroup.row,
      dx: null !== (_l = null === (_k = cellGroup.firstChild) || void 0 === _k ? void 0 : _k.attribute.dx) && void 0 !== _l ? _l : 0,
      dy: null !== (_o = null === (_m = cellGroup.firstChild) || void 0 === _m ? void 0 : _m.attribute.dy) && void 0 !== _o ? _o : 0
    }), cellGroup.forEachChildren((child) => {
      var _a2;
      child.setAttribute("dy", (null !== (_a2 = child.attribute.dy) && void 0 !== _a2 ? _a2 : 0) - deltaHeight + 2);
    });
  } else if (textBottom > maxTop) {
    const deltaHeight = textBottom - maxTop;
    !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
      col: cellGroup.col,
      row: cellGroup.row,
      dx: null !== (_q = null === (_p = cellGroup.firstChild) || void 0 === _p ? void 0 : _p.attribute.dx) && void 0 !== _q ? _q : 0,
      dy: null !== (_s = null === (_r = cellGroup.firstChild) || void 0 === _r ? void 0 : _r.attribute.dy) && void 0 !== _s ? _s : 0
    }), cellGroup.forEachChildren((child) => {
      var _a2;
      child.setAttribute("dy", (null !== (_a2 = child.attribute.dy) && void 0 !== _a2 ? _a2 : 0) - deltaHeight);
    });
  }
}
function adjustCellContentHorizontalLayout(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign, table) {
  if (isNumber_default(cellGroup.mergeStartCol) && isNumber_default(cellGroup.mergeStartRow) && isNumber_default(cellGroup.mergeEndCol) && isNumber_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
      const singleCellGroup = table.scenegraph.getCell(col, row);
      "cell" === singleCellGroup.role && dealHorizontal(singleCellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
    }
  } else dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
}
function dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const graphic = cellGroup.getChildByName("text", true) || cellGroup.getChildByName("image", true);
  if (!graphic) return;
  if ("image" === graphic.type) {
    const { image: url } = graphic.attribute;
    if (!url || !graphic.resources) return;
    if ("success" !== graphic.resources.get(url).state) return;
  }
  const textAlign = null !== (_b = null !== (_a = graphic.attribute.textAlign) && void 0 !== _a ? _a : graphic.textAlign) && void 0 !== _b ? _b : "left";
  graphic.AABBBounds.width();
  const textLeft = graphic.globalAABBBounds.x1, textRight = graphic.globalAABBBounds.x2;
  if ("center" === textAlign && textStickBaseOnAlign) {
    const cellLeft = cellGroup.globalAABBBounds.x1 + (null !== (_d = null === (_c = cellGroup.firstChild) || void 0 === _c ? void 0 : _c.attribute.dx) && void 0 !== _d ? _d : 0), cellRight = cellLeft + (null !== (_f = null !== (_e = cellGroup.contentWidth) && void 0 !== _e ? _e : cellGroup.attribute.width) && void 0 !== _f ? _f : 0);
    if (cellLeft < minLeft || cellRight > maxLeft) {
      const visibleCellLeft = Math.max(cellLeft, minLeft), visibleCellRight = Math.min(cellRight, maxLeft), delta = graphic.globalTransMatrix.e - (visibleCellRight + visibleCellLeft) / 2;
      !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
        col: cellGroup.col,
        row: cellGroup.row,
        dx: null !== (_h = null === (_g = cellGroup.firstChild) || void 0 === _g ? void 0 : _g.attribute.dx) && void 0 !== _h ? _h : 0,
        dy: null !== (_k = null === (_j = cellGroup.firstChild) || void 0 === _j ? void 0 : _j.attribute.dy) && void 0 !== _k ? _k : 0
      }), cellGroup.forEachChildren((child) => {
        var _a2;
        child.setAttribute("dx", (null !== (_a2 = child.attribute.dx) && void 0 !== _a2 ? _a2 : 0) - delta + 2);
      });
    }
  } else if (textLeft < minLeft) {
    const deltaWidth = textLeft - minLeft;
    !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
      col: cellGroup.col,
      row: cellGroup.row,
      dx: null !== (_m = null === (_l = cellGroup.firstChild) || void 0 === _l ? void 0 : _l.attribute.dx) && void 0 !== _m ? _m : 0,
      dy: null !== (_p = null === (_o = cellGroup.firstChild) || void 0 === _o ? void 0 : _o.attribute.dy) && void 0 !== _p ? _p : 0
    }), cellGroup.forEachChildren((child) => {
      var _a2;
      child.setAttribute("dx", (null !== (_a2 = child.attribute.dx) && void 0 !== _a2 ? _a2 : 0) - deltaWidth + 2);
    });
  } else if (textRight > maxLeft) {
    const deltaWidth = textRight - maxLeft;
    !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
      col: cellGroup.col,
      row: cellGroup.row,
      dx: null !== (_r = null === (_q = cellGroup.firstChild) || void 0 === _q ? void 0 : _q.attribute.dx) && void 0 !== _r ? _r : 0,
      dy: null !== (_t = null === (_s = cellGroup.firstChild) || void 0 === _s ? void 0 : _s.attribute.dy) && void 0 !== _t ? _t : 0
    }), cellGroup.forEachChildren((child) => {
      var _a2;
      child.setAttribute("dx", (null !== (_a2 = child.attribute.dx) && void 0 !== _a2 ? _a2 : 0) - deltaWidth);
    });
  }
}
function checkHaveTextStick(table) {
  var _a, _b;
  const headerObjects = table.internalProps.layoutMap.headerObjects, columnObjects = table.internalProps.layoutMap.columnObjects;
  for (let i = 0; i < headerObjects.length; i++) {
    const header = headerObjects[i];
    if (header && (null === (_a = header.style) || void 0 === _a ? void 0 : _a.textStick)) return true;
  }
  for (let i = 0; i < columnObjects.length; i++) {
    const column = columnObjects[i];
    if (column && (null === (_b = column.style) || void 0 === _b ? void 0 : _b.textStick)) return true;
  }
  return !!(table.theme.headerStyle.textStick || table.theme.rowHeaderStyle.textStick || table.theme.bodyStyle.textStick);
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/progress/proxy.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SceneProxy = class {
  constructor(table) {
    this.isRelease = false, this.mode = "column", this.rowLimit = 200, this.currentRow = 0, this.rowStart = 0, this.rowEnd = 0, this.referenceRow = 0, this.screenTopRow = 0, this.deltaY = 0, this.deltaHeight = 0, this.colLimit = 100, this.screenLeftCol = 0, this.deltaX = 0, this.deltaWidth = 0, this.cellCache = /* @__PURE__ */ new Map(), this.table = table, this.table.isPivotChart() ? (this.rowLimit = Math.max(100, Math.ceil(2 * table.tableNoFrameHeight / table.defaultRowHeight)), this.colLimit = Math.max(100, Math.ceil(2 * table.tableNoFrameWidth / table.defaultColWidth))) : this.table.isAutoRowHeight(table.columnHeaderLevelCount) ? this.rowLimit = Math.max(100, Math.ceil(2 * table.tableNoFrameHeight / table.defaultRowHeight)) : ("autoWidth" === this.table.widthMode || (this.rowLimit = Math.max(200, Math.ceil(2 * table.tableNoFrameHeight / table.defaultRowHeight))), this.colLimit = Math.max(100, Math.ceil(2 * table.tableNoFrameWidth / table.defaultColWidth))), this.table.internalProps.transpose ? this.mode = "row" : this.table.isPivotTable() && (this.mode = "pivot"), this.table.options.maintainedDataCount && (this.rowLimit = this.table.options.maintainedDataCount), this.table.options.maintainedColumnCount && (this.colLimit = this.table.options.maintainedColumnCount), "adaptive" === this.table.heightMode && (this.rowLimit = this.table.rowCount), "adaptive" === this.table.widthMode && (this.colLimit = this.table.colCount);
  }
  get bodyLeftCol() {
    return this.table.frozenColCount;
  }
  get bodyTopRow() {
    return this.table.frozenRowCount;
  }
  setParamsForColumn() {
    this.bodyRightCol = this.table.colCount - 1 - this.table.rightFrozenColCount;
    const totalActualBodyColCount = Math.min(this.colLimit, this.bodyRightCol - this.bodyLeftCol + 1);
    this.totalActualBodyColCount = totalActualBodyColCount, this.totalCol = this.bodyLeftCol + totalActualBodyColCount - 1, this.colStart = this.bodyLeftCol, this.colEnd = this.totalCol;
    const defaultColWidth = this.table.defaultColWidth;
    this.taskColCount = 1 * Math.ceil(this.table.tableNoFrameWidth / defaultColWidth);
    const totalBodyWidth = defaultColWidth * totalActualBodyColCount, totalWidth = defaultColWidth * (this.bodyRightCol - this.bodyLeftCol + 1);
    this.xLimitLeft = totalBodyWidth / 2, this.xLimitRight = totalWidth - totalBodyWidth / 2;
    const widthLimit = 5 * this.table.tableNoFrameWidth;
    this.screenColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth), this.firstScreenColLimit = Math.max(15, this.bodyLeftCol + Math.min(this.colLimit, Math.ceil(widthLimit / defaultColWidth))), this.colUpdatePos = this.bodyRightCol;
  }
  setParamsForRow() {
    this.bodyBottomRow = this.table.rowCount - 1 - this.table.bottomFrozenRowCount;
    const totalActualBodyRowCount = Math.min(this.rowLimit, this.bodyBottomRow - this.bodyTopRow + 1);
    this.totalActualBodyRowCount = totalActualBodyRowCount, this.totalRow = this.bodyTopRow + totalActualBodyRowCount - 1, this.rowStart = this.bodyTopRow, this.rowEnd = this.totalRow;
    const defaultRowHeight = this.table.defaultRowHeight;
    this.taskRowCount = 1 * Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight);
    const totalBodyHeight = defaultRowHeight * totalActualBodyRowCount, totalHeight = defaultRowHeight * (this.bodyBottomRow - this.bodyTopRow + 1);
    this.yLimitTop = totalBodyHeight / 2, this.yLimitBottom = totalHeight - totalBodyHeight / 2;
    const heightLimit = 5 * this.table.tableNoFrameHeight;
    this.screenRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight), this.firstScreenRowLimit = Math.max(30, this.bodyTopRow + Math.min(this.rowLimit, Math.ceil(heightLimit / defaultRowHeight))), this.rowUpdatePos = this.bodyBottomRow;
  }
  refreshRowCount() {
    this.bodyBottomRow = this.table.rowCount - 1 - this.table.bottomFrozenRowCount;
    const totalActualBodyRowCount = Math.min(this.rowLimit, this.bodyBottomRow - this.bodyTopRow + 1);
    this.totalActualBodyRowCount = totalActualBodyRowCount, this.totalRow = this.rowStart + totalActualBodyRowCount - 1;
  }
  refreshColCount() {
    this.bodyRightCol = this.table.colCount - 1 - this.table.rightFrozenColCount;
    const totalActualBodyColCount = Math.min(this.colLimit, this.bodyRightCol - this.bodyLeftCol + 1);
    this.totalActualBodyColCount = totalActualBodyColCount, this.totalCol = this.bodyLeftCol + totalActualBodyColCount - 1, this.colStart = this.bodyLeftCol, this.colEnd = this.totalCol;
  }
  resize() {
    const defaultColWidth = this.table.defaultColWidth;
    this.taskColCount = 1 * Math.ceil(this.table.tableNoFrameWidth / defaultColWidth);
    const widthLimit = 5 * this.table.tableNoFrameWidth;
    this.screenColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth), this.firstScreenColLimit = this.bodyLeftCol + Math.min(this.colLimit, Math.ceil(widthLimit / defaultColWidth));
    const defaultRowHeight = this.table.defaultRowHeight;
    this.taskRowCount = 1 * Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight);
    const heightLimit = 5 * this.table.tableNoFrameHeight;
    this.screenRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight), this.firstScreenRowLimit = this.bodyTopRow + Math.min(this.rowLimit, Math.ceil(heightLimit / defaultRowHeight));
  }
  createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin) {
    createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin, this);
  }
  progress() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (!this.isProgressing) return this.isProgressing = true, new Promise((resolve, reject) => {
        setTimeout(() => __awaiter13(this, void 0, void 0, function* () {
          this.isProgressing = false, this.isRelease || (this.colUpdatePos <= this.colEnd ? (yield this.updateColCellGroupsAsync(), yield this.progress()) : this.rowUpdatePos <= this.rowEnd ? (yield this.updateRowCellGroupsAsync(), yield this.progress()) : this.currentCol < this.totalCol ? (yield this.createCol(), yield this.progress()) : this.currentRow < this.totalRow && (yield this.createRow(), yield this.progress()), handleTextStick(this.table), this.table.scenegraph.updateNextFrame(), resolve());
        }), 16);
      });
    });
  }
  createRow() {
    return __awaiter13(this, void 0, void 0, function* () {
      this.taskRowCount && this.createRowCellGroup(this.taskRowCount);
    });
  }
  createCol() {
    return __awaiter13(this, void 0, void 0, function* () {
      this.taskColCount && this.createColGroup(this.taskRowCount);
    });
  }
  createRowCellGroup(onceCount) {
    const endRow = Math.min(this.totalRow, this.currentRow + onceCount);
    if ("adaptive" !== this.table.heightMode && computeRowsHeight(this.table, this.currentRow + 1, endRow, false), this.rowEnd = endRow, this.table.frozenColCount) {
      let maxHeight2 = 0;
      for (let col = 0; col < this.table.frozenColCount; col++) {
        const colGroup = this.table.scenegraph.getColGroup(col), { height } = (this.table.isListTable(), createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table));
        maxHeight2 = Math.max(maxHeight2, height), this.table.scenegraph.rowHeaderGroup.setAttribute("height", maxHeight2);
      }
    }
    if (this.table.rightFrozenColCount) {
      let maxHeight2 = 0;
      for (let col = this.table.colCount - this.table.rightFrozenColCount; col < this.table.colCount; col++) {
        const colGroup = this.table.scenegraph.getColGroup(col), { height } = (this.table.isPivotChart(), createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table));
        maxHeight2 = Math.max(maxHeight2, height), this.table.scenegraph.rightFrozenGroup.setAttribute("height", maxHeight2);
      }
    }
    let maxHeight = 0;
    for (let col = this.bodyLeftCol; col <= this.bodyRightCol; col++) {
      const colGroup = this.table.scenegraph.getColGroup(col);
      if (!colGroup) continue;
      this.table.rowHeaderLevelCount;
      const { height } = createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table);
      maxHeight = Math.max(maxHeight, height);
    }
    this.table.scenegraph.bodyGroup.setAttribute("height", maxHeight), this.currentRow = endRow, this.rowUpdatePos = this.rowEnd, this.table.scenegraph.updateContainer(), this.table.scenegraph.updateBorderSizeAndPosition();
  }
  createColGroup(onceCount) {
    const endCol = Math.min(this.totalCol, this.currentCol + onceCount);
    "adaptive" !== this.table.widthMode && computeColsWidth(this.table, this.currentCol + 1, endCol), this.colEnd = endCol;
    for (let row = 0; row < this.table.rowCount; row++) {
      const cellGroup = this.highPerformanceGetCell(this.currentCol, row);
      "cell" === cellGroup.role && isNumber_default(cellGroup.mergeStartCol) && cellGroup.mergeStartCol > this.currentCol && this.table.scenegraph.updateCellContent(cellGroup.col, cellGroup.row);
    }
    if (this.table.frozenRowCount) {
      const lastColumnGroup2 = this.table.scenegraph.colHeaderGroup.lastChild instanceof Group2 ? this.table.scenegraph.colHeaderGroup.lastChild : this.table.scenegraph.colHeaderGroup.lastChild._prev, xOrigin2 = lastColumnGroup2.attribute.x + lastColumnGroup2.attribute.width, yOrigin2 = lastColumnGroup2.attribute.y;
      createColGroup(this.table.scenegraph.colHeaderGroup, xOrigin2, yOrigin2, this.currentCol + 1, endCol, 0, this.table.frozenRowCount - 1, "columnHeader", this.table);
    }
    if (this.table.bottomFrozenRowCount) {
      const lastColumnGroup2 = this.table.scenegraph.bottomFrozenGroup.lastChild instanceof Group2 ? this.table.scenegraph.bottomFrozenGroup.lastChild : this.table.scenegraph.bottomFrozenGroup.lastChild._prev, xOrigin2 = lastColumnGroup2.attribute.x + lastColumnGroup2.attribute.width, yOrigin2 = lastColumnGroup2.attribute.y;
      createColGroup(this.table.scenegraph.bottomFrozenGroup, xOrigin2, yOrigin2, this.currentCol + 1, endCol, this.table.rowCount - this.table.bottomFrozenRowCount, this.table.rowCount - 1, "columnHeader", this.table);
    }
    let lastColumnGroup = this.table.scenegraph.bodyGroup.lastChild && (this.table.scenegraph.bodyGroup.lastChild instanceof Group2 ? this.table.scenegraph.bodyGroup.lastChild : this.table.scenegraph.bodyGroup.lastChild._prev);
    lastColumnGroup || (lastColumnGroup = this.table.scenegraph.colHeaderGroup.lastChild && (this.table.scenegraph.colHeaderGroup.lastChild instanceof Group2 ? this.table.scenegraph.colHeaderGroup.lastChild : this.table.scenegraph.colHeaderGroup.lastChild._prev));
    const xOrigin = lastColumnGroup.attribute.x + lastColumnGroup.attribute.width, yOrigin = lastColumnGroup.attribute.y;
    createColGroup(this.table.scenegraph.bodyGroup, xOrigin, yOrigin, this.currentCol + 1, endCol, this.rowStart, this.rowEnd, "body", this.table), this.currentCol = endCol, this.colUpdatePos = this.colEnd, this.table.scenegraph.updateContainer(), this.table.scenegraph.updateBorderSizeAndPosition();
  }
  setY(y, isEnd = false) {
    return __awaiter13(this, void 0, void 0, function* () {
      const yLimitTop = this.table.getRowsHeight(this.bodyTopRow, this.bodyTopRow + (this.rowEnd - this.rowStart + 1)) / 2, yLimitBottom = this.table.getAllRowsHeight() - yLimitTop, screenTop = this.table.getTargetRowAt(y + this.table.scenegraph.colHeaderGroup.attribute.height);
      screenTop && (this.screenTopRow = screenTop.row), y < yLimitTop && this.rowStart === this.bodyTopRow || y > yLimitBottom && this.rowEnd === this.bodyBottomRow ? (this.updateDeltaY(y), this.updateBody(y - this.deltaY)) : this.table.scenegraph.bodyGroup.firstChild && "group" === this.table.scenegraph.bodyGroup.firstChild.type && 0 !== this.table.scenegraph.bodyGroup.firstChild.childrenCount || this.table.scenegraph.rowHeaderGroup.firstChild && "group" === this.table.scenegraph.rowHeaderGroup.firstChild.type && 0 !== this.table.scenegraph.rowHeaderGroup.firstChild.childrenCount ? this.dynamicSetY(y, screenTop, isEnd) : (this.updateDeltaY(y), this.updateBody(y - this.deltaY));
    });
  }
  setX(x, isEnd = false) {
    return __awaiter13(this, void 0, void 0, function* () {
      const xLimitLeft = this.table.getColsWidth(this.bodyLeftCol, this.bodyLeftCol + (this.colEnd - this.colStart + 1)) / 2, xLimitRight = this.table.getAllColsWidth() - xLimitLeft, screenLeft = this.table.getTargetColAt(x + this.table.scenegraph.rowHeaderGroup.attribute.width);
      screenLeft && (this.screenLeftCol = screenLeft.col), x < xLimitLeft && this.colStart === this.bodyLeftCol || x > xLimitRight && this.colEnd === this.bodyRightCol || this.table.scenegraph.bodyGroup.firstChild && "group" === this.table.scenegraph.bodyGroup.firstChild.type && 0 === this.table.scenegraph.bodyGroup.firstChild.childrenCount ? (this.updateDeltaX(x), this.table.scenegraph.setBodyAndColHeaderX(-x + this.deltaX)) : this.dynamicSetX(x, screenLeft, isEnd);
    });
  }
  dynamicSetY(y, screenTop, isEnd = false) {
    return __awaiter13(this, void 0, void 0, function* () {
      dynamicSetY(y, screenTop, isEnd, this);
    });
  }
  dynamicSetX(x, screenLeft, isEnd = false) {
    return __awaiter13(this, void 0, void 0, function* () {
      dynamicSetX(x, screenLeft, isEnd, this);
    });
  }
  updateBody(y) {
    this.table.scenegraph.setBodyAndRowHeaderY(-y);
  }
  updateRowCellGroupsAsync() {
    return __awaiter13(this, void 0, void 0, function* () {
      this.updateCellGroups(this.taskRowCount);
    });
  }
  updateCellGroups(count) {
    const distRow = Math.min(this.bodyBottomRow, this.rowUpdatePos + count);
    this.table.isAutoRowHeight(this.rowUpdatePos) && computeRowsHeight(this.table, this.rowUpdatePos, distRow, false), updateRowContent(this.rowUpdatePos, distRow, this), this.table.isAutoRowHeight(this.rowUpdatePos) && (updateAutoRow(this.bodyLeftCol, this.bodyRightCol, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true), updateAutoRow(0, this.table.frozenColCount - 1, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true), updateAutoRow(this.table.colCount - this.table.rightFrozenColCount, this.table.colCount - 1, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true)), this.rowUpdatePos = distRow + 1;
  }
  updateBottomFrozenCellGroups() {
    const startRow = this.table.rowCount - this.table.bottomFrozenRowCount, endRow = this.table.rowCount - 1;
    this.table.isAutoRowHeight(startRow) && computeRowsHeight(this.table, startRow, endRow, false), updateRowContent(startRow, endRow, this), this.table.isAutoRowHeight(startRow) && (updateAutoRow(this.bodyLeftCol, this.bodyRightCol, startRow, endRow, this.table, this.rowUpdateDirection), updateAutoRow(0, this.table.frozenColCount - 1, startRow, endRow, this.table, this.rowUpdateDirection), updateAutoRow(this.table.colCount - this.table.rightFrozenColCount, this.table.colCount - 1, startRow, endRow, this.table, this.rowUpdateDirection));
  }
  updateRightFrozenCellGroups() {
    const startCol = this.table.colCount - this.table.rightFrozenColCount, endCol = this.table.colCount - 1;
    "autoWidth" === this.table.widthMode && computeColsWidth(this.table, startCol, endCol, false), updateColContent(startCol, endCol, this), this.table.isAutoRowHeight(this.rowStart) && updateAutoColumn(startCol, endCol, this.table, this.colUpdateDirection);
  }
  updateColCellGroupsAsync() {
    return __awaiter13(this, void 0, void 0, function* () {
      this.updateColGroups(this.taskRowCount);
    });
  }
  updateColGroups(count) {
    const distCol = Math.min(this.bodyRightCol, this.colUpdatePos + count);
    "autoWidth" === this.table.widthMode && computeColsWidth(this.table, this.colUpdatePos, distCol), updateColContent(this.colUpdatePos, distCol, this), this.colUpdatePos = distCol + 1;
  }
  updateCellGroupPosition(cellGroup, newRow, y) {
    cellGroup.row = newRow, cellGroup.mergeStartCol = void 0, cellGroup.mergeStartRow = void 0, cellGroup.mergeEndCol = void 0, cellGroup.mergeEndRow = void 0, cellGroup.setAttribute("y", y), cellGroup.needUpdate = true, cellGroup.needUpdateForAutoRowHeight = true;
  }
  updateCellGroupContent(cellGroup) {
    if (!cellGroup.needUpdate || "cell" !== cellGroup.role) return cellGroup;
    const newCellGroup = this.table.scenegraph.updateCellContent(cellGroup.col, cellGroup.row);
    return cellGroup.needUpdate = false, newCellGroup || cellGroup;
  }
  sortCellVertical() {
    return __awaiter13(this, void 0, void 0, function* () {
      yield sortVertical(this);
    });
  }
  sortCellHorizontal() {
    return __awaiter13(this, void 0, void 0, function* () {
      yield sortHorizontal(this);
    });
  }
  highPerformanceGetCell(col, row, getShadow) {
    if (row >= this.table.frozenRowCount && row < this.table.rowCount - this.table.bottomFrozenRowCount && (row < this.rowStart || row > this.rowEnd)) return emptyGroup;
    if (col >= this.table.frozenColCount && col < this.table.colCount - this.table.rightFrozenColCount && (col < this.colStart || col > this.colEnd)) return emptyGroup;
    if (this.cellCache.get(col)) {
      const cacheCellGoup = this.cellCache.get(col);
      if ((cacheCellGoup._next || cacheCellGoup._prev) && Math.abs(cacheCellGoup.row - row) < row) {
        let cellGroup3 = getCellByCache(cacheCellGoup, row);
        return cellGroup3 && (getShadow || "shadow-cell" !== cellGroup3.role) || (cellGroup3 = this.table.scenegraph.getCell(col, row, getShadow)), cellGroup3.row && this.cellCache.set(col, cellGroup3), cellGroup3;
      }
      const cellGroup2 = this.table.scenegraph.getCell(col, row, getShadow);
      return cellGroup2.col === col && cellGroup2.row && this.cellCache.set(col, cellGroup2), cellGroup2;
    }
    const cellGroup = this.table.scenegraph.getCell(col, row, getShadow);
    return cellGroup.col === col && cellGroup.row && this.cellCache.set(col, cellGroup), cellGroup;
  }
  updateDeltaY(y, screenTopY, screenTopRow) {
    if (this.rowStart === this.bodyTopRow) {
      const cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, this.rowStart, true);
      if ("cell" === cellGroup.role) {
        const deltaY = cellGroup.attribute.y;
        this.deltaY = -deltaY;
      }
    } else if (this.rowEnd === this.bodyBottomRow) {
      const cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, this.rowEnd, true);
      if ("cell" === cellGroup.role) {
        const deltaY = cellGroup.attribute.y + cellGroup.attribute.height - (this.table.getAllRowsHeight() - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight());
        this.deltaY = -deltaY;
      }
    } else if (isValid_default(screenTopY) && isValid_default(screenTopRow)) {
      let cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, screenTopRow, true);
      "cell" !== cellGroup.role && (cellGroup = this.table.scenegraph.highPerformanceGetCell(0, screenTopRow, true));
      const bodyY = y - this.deltaY, distRowYOffset = screenTopY - bodyY, currentRowYOffset = cellGroup.attribute.y - bodyY + this.table.getFrozenRowsHeight();
      this.deltaY = distRowYOffset - currentRowYOffset;
    }
  }
  updateDeltaX(x, screenLeftX, screenLeftCol) {
    if (this.colStart === this.bodyLeftCol) {
      const colGroup = this.table.scenegraph.getColGroup(this.colStart);
      if (colGroup) {
        const deltaX = colGroup.attribute.x;
        this.deltaX = -deltaX;
      }
    } else if (this.colEnd === this.bodyRightCol) {
      const colGroup = this.table.scenegraph.getColGroup(this.colEnd);
      if (colGroup) {
        const deltaX = colGroup.attribute.x + colGroup.attribute.width - (this.table.getAllColsWidth() - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth());
        this.deltaX = -deltaX;
      }
    } else if (isValid_default(screenLeftX) && isValid_default(screenLeftCol)) {
      const colGroup = this.table.scenegraph.getColGroup(screenLeftCol) || this.table.scenegraph.getColGroup(screenLeftCol, true), bodyX = x - this.deltaX, distColXOffset = screenLeftX - bodyX, currentColXOffset = colGroup.attribute.x - bodyX + this.table.getFrozenColsWidth();
      this.deltaX = distColXOffset - currentColXOffset;
    }
  }
  release() {
    this.isRelease = true;
  }
};
function getCellByCache(cacheCellGroup, row) {
  if (!cacheCellGroup) return null;
  if (cacheCellGroup.row === row) return cacheCellGroup;
  const prev = cacheCellGroup._prev, next = cacheCellGroup._next;
  return cacheCellGroup.row > row && prev && prev.row === cacheCellGroup.row - 1 ? getCellByCache(prev, row) : cacheCellGroup.row < row && next && next.row === cacheCellGroup.row + 1 ? getCellByCache(next, row) : null;
}

// node_modules/@visactor/vtable/es/scenegraph/layout/move-cell.js
function moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, table) {
  const scene = table.scenegraph;
  for (let col = updateColStart; col <= updateColEnd; col++) {
    const columnWidth = table.getColWidth(col), columnHeaderGroup = table.scenegraph.getColGroup(col, true), columnGroup = table.scenegraph.getColGroup(col), columnBottomGroup = table.scenegraph.getColGroupInBottom(col), columnLeftBottomGroup = table.scenegraph.getColGroupInLeftBottomCorner(col), columnRightBottomGroup = table.scenegraph.getColGroupInRightBottomCorner(col);
    columnHeaderGroup && (columnHeaderGroup.setAttribute("width", columnWidth), columnHeaderGroup.forEachChildren((child) => {
      child.setAttribute("width", columnWidth);
    })), columnGroup && (columnGroup.setAttribute("width", columnWidth), columnGroup.forEachChildren((child) => {
      child.setAttribute("width", columnWidth);
    })), columnBottomGroup && (columnBottomGroup.setAttribute("width", columnWidth), columnBottomGroup.forEachChildren((child) => {
      child.setAttribute("width", columnWidth);
    })), columnRightBottomGroup && (columnRightBottomGroup.setAttribute("width", columnWidth), columnRightBottomGroup.forEachChildren((child) => {
      child.setAttribute("width", columnWidth);
    })), columnLeftBottomGroup && (columnLeftBottomGroup.setAttribute("width", columnWidth), columnLeftBottomGroup.forEachChildren((child) => {
      child.setAttribute("width", columnWidth);
    }));
  }
  if (scene.updateContainer(), "column" === moveType) for (let col = updateColStart; col <= updateColEnd; col++) {
    const columnGroup = table.scenegraph.getColGroup(col);
    null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
    for (let row = 0; row <= table.frozenRowCount - 1; row++) scene.updateCellContent(col, row);
    for (let row = scene.bodyRowStart; row <= scene.bodyRowEnd; row++) scene.updateCellContent(col, row);
    for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) scene.updateCellContent(col, row);
  }
  else {
    for (let col = 0; col <= table.frozenColCount - 1; col++) {
      const columnGroup = table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
    }
    for (let col = scene.bodyColStart; col <= scene.bodyColEnd; col++) {
      const columnGroup = table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
    }
    for (let col = table.colCount - table.rightFrozenColCount; col <= table.colCount - 1; col++) {
      const columnGroup = table.scenegraph.getColGroup(col);
      null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
      for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
    }
  }
}

// node_modules/@visactor/vtable/es/scenegraph/select/update-select-border.js
function updateAllSelectComponent(scene) {
  scene.customSelectedRangeComponents.forEach((selectComp, key) => {
    updateComponent(selectComp, key, scene);
  }), scene.selectingRangeComponents.forEach((selectComp, key) => {
    updateComponent(selectComp, key, scene);
  }), scene.selectedRangeComponents.forEach((selectComp, key) => {
    updateComponent(selectComp, key, scene);
  });
}
function updateComponent(selectComp, key, scene) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const table = scene.table, [startColStr, startRowStr, endColStr, endRowStr] = key.split("-"), startCol = parseInt(startColStr, 10), startRow = parseInt(startRowStr, 10), endCol = parseInt(endColStr, 10), endRow = parseInt(endRowStr, 10);
  let visibleCellRange, computeRectCellRangeStartCol = startCol, computeRectCellRangeStartRow = startRow, computeRectCellRangeEndCol = endCol, computeRectCellRangeEndRow = endRow;
  switch (selectComp.role) {
    case "rowHeader":
      visibleCellRange = table.getBodyVisibleRowRange(), visibleCellRange && (computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1), computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1));
      break;
    case "columnHeader":
    case "bottomFrozen":
      visibleCellRange = table.getBodyVisibleCellRange(), visibleCellRange && (computeRectCellRangeStartCol = Math.max(startCol, visibleCellRange.colStart - 1), computeRectCellRangeEndCol = Math.min(endCol, visibleCellRange.colEnd + 1));
      break;
    case "cornerHeader":
    case "rightTopCorner":
    case "leftBottomCorner":
    case "rightBottomCorner":
      break;
    case "rightFrozen":
      visibleCellRange = table.getBodyVisibleCellRange(), visibleCellRange && (computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1), computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1));
      break;
    default:
      visibleCellRange = table.getBodyVisibleCellRange(), visibleCellRange && (computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1), computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1), computeRectCellRangeStartCol = Math.max(startCol, visibleCellRange.colStart - 1), computeRectCellRangeEndCol = Math.min(endCol, visibleCellRange.colEnd + 1));
  }
  const colsWidth = table.getColsWidth(computeRectCellRangeStartCol, computeRectCellRangeEndCol), rowsHeight = table.getRowsHeight(computeRectCellRangeStartRow, computeRectCellRangeEndRow), firstCellBound = scene.highPerformanceGetCell(computeRectCellRangeStartCol, computeRectCellRangeStartRow).globalAABBBounds;
  if (selectComp.rect.setAttributes({
    x: firstCellBound.x1 - scene.tableGroup.attribute.x,
    y: firstCellBound.y1 - scene.tableGroup.attribute.y,
    width: colsWidth,
    height: rowsHeight,
    visible: true
  }), selectComp.fillhandle) {
    const fillHandle = null === (_a = scene.table.options.excelOptions) || void 0 === _a ? void 0 : _a.fillHandle;
    let lastCellBound, visible = true;
    "function" == typeof fillHandle && (visible = fillHandle({
      selectRanges: scene.table.stateManager.select.ranges,
      table: scene.table
    })), lastCellBound = computeRectCellRangeEndCol < table.colCount - 1 ? scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeEndRow).globalAABBBounds : scene.highPerformanceGetCell(computeRectCellRangeStartCol - 1, computeRectCellRangeEndRow).globalAABBBounds;
    const handlerX = lastCellBound.x2 - scene.tableGroup.attribute.x - 3;
    lastCellBound = computeRectCellRangeEndRow < table.rowCount - 1 ? scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeEndRow).globalAABBBounds : scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeStartRow - 1).globalAABBBounds;
    const handlerY = lastCellBound.y2 - scene.tableGroup.attribute.y - 3;
    null === (_b = selectComp.fillhandle) || void 0 === _b || _b.setAttributes({
      x: handlerX,
      y: handlerY,
      width: 6,
      height: 6,
      visible
    });
  }
  let isNearRowHeader = !!table.frozenColCount && startCol === table.frozenColCount;
  if (!isNearRowHeader && table.frozenColCount && table.scrollLeft > 0 && startCol >= table.frozenColCount) {
    table.getColsWidth(0, startCol - 1) - table.scrollLeft < table.getFrozenColsWidth() && (isNearRowHeader = true);
  }
  let isNearRightRowHeader = !!table.rightFrozenColCount && (table.rightFrozenColCount > 0 && endCol === table.colCount - table.rightFrozenColCount - 1);
  if (!isNearRightRowHeader && table.rightFrozenColCount && endCol < table.colCount - table.rightFrozenColCount) {
    table.getColsWidth(0, endCol) - table.scrollLeft > table.tableNoFrameWidth - table.getRightFrozenColsWidth() && (isNearRightRowHeader = true);
  }
  let isNearColHeader = !table.frozenRowCount || startRow === table.frozenRowCount;
  if (!isNearColHeader && table.frozenRowCount && table.scrollTop > 0 && startRow >= table.frozenRowCount) {
    table.getRowsHeight(0, startRow - 1) - table.scrollTop < table.getFrozenRowsHeight() && (isNearColHeader = true);
  }
  let isNearBottomColHeader = !!table.bottomFrozenRowCount && endRow === table.rowCount - table.bottomFrozenRowCount - 1;
  if (!isNearBottomColHeader && table.bottomFrozenRowCount && endRow < table.rowCount - table.bottomFrozenRowCount) {
    table.getRowsHeight(0, endRow) - table.scrollTop > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() && (isNearBottomColHeader = true);
  }
  const { dynamicUpdateSelectionSize } = table.theme.selectionStyle;
  if (isNearRowHeader && (selectComp.rect.attribute.stroke[3] || dynamicUpdateSelectionSize) || isNearRightRowHeader && (selectComp.rect.attribute.stroke[1] || dynamicUpdateSelectionSize) || isNearColHeader && (selectComp.rect.attribute.stroke[0] || dynamicUpdateSelectionSize) || isNearBottomColHeader && (selectComp.rect.attribute.stroke[2] || dynamicUpdateSelectionSize)) {
    if (isNearRowHeader && selectComp.rect.attribute.stroke[3] && scene.tableGroup.insertAfter(selectComp.rect, "columnHeader" === selectComp.role ? scene.cornerHeaderGroup : "bottomFrozen" === selectComp.role ? scene.leftBottomCornerGroup : scene.rowHeaderGroup), isNearBottomColHeader && selectComp.rect.attribute.stroke[2] && scene.tableGroup.insertAfter(selectComp.rect, "rowHeader" === selectComp.role ? scene.leftBottomCornerGroup : "rightFrozen" === selectComp.role ? scene.rightBottomCornerGroup : scene.bottomFrozenGroup), isNearColHeader && selectComp.rect.attribute.stroke[0] && scene.tableGroup.insertAfter(selectComp.rect, "rowHeader" === selectComp.role ? scene.cornerHeaderGroup : "rightFrozen" === selectComp.role ? scene.rightTopCornerGroup : scene.colHeaderGroup), isNearRightRowHeader && selectComp.rect.attribute.stroke[1] && scene.tableGroup.insertAfter(selectComp.rect, "columnHeader" === selectComp.role ? scene.rightTopCornerGroup : "bottomFrozen" === selectComp.role ? scene.rightBottomCornerGroup : scene.rightFrozenGroup), selectComp.rect.attribute.x < table.getFrozenColsWidth() && table.scrollLeft > 0 && ("body" === selectComp.role || "columnHeader" === selectComp.role || "bottomFrozen" === selectComp.role)) {
      const width = selectComp.rect.attribute.width - (table.getFrozenColsWidth() - selectComp.rect.attribute.x);
      selectComp.rect.setAttributes({
        x: selectComp.rect.attribute.x + (table.getFrozenColsWidth() - selectComp.rect.attribute.x),
        width: width > 0 ? width : 0
      }), null === (_c = selectComp.fillhandle) || void 0 === _c || _c.setAttributes({
        visible: width > 0
      });
    }
    if (table.getRightFrozenColsWidth() > 0 && scene.rightFrozenGroup.attribute.height > 0 && selectComp.rect.attribute.x + selectComp.rect.attribute.width > scene.rightFrozenGroup.attribute.x && ("body" === selectComp.role || "columnHeader" === selectComp.role || "bottomFrozen" === selectComp.role)) {
      const width = scene.rightFrozenGroup.attribute.x - selectComp.rect.attribute.x;
      selectComp.rect.setAttributes({
        x: selectComp.rect.attribute.x,
        width: width > 0 ? width : 0
      }), null === (_d = selectComp.fillhandle) || void 0 === _d || _d.setAttributes({
        visible: width - colsWidth > 0
      });
    }
    if (selectComp.rect.attribute.y < scene.colHeaderGroup.attribute.height && table.scrollTop > 0 && ("body" === selectComp.role || "rowHeader" === selectComp.role || "rightFrozen" === selectComp.role)) {
      const height = selectComp.rect.attribute.height - (scene.colHeaderGroup.attribute.height - selectComp.rect.attribute.y);
      selectComp.rect.setAttributes({
        y: selectComp.rect.attribute.y + (scene.colHeaderGroup.attribute.height - selectComp.rect.attribute.y),
        height: height > 0 ? height : 0
      }), null === (_e = selectComp.fillhandle) || void 0 === _e || _e.setAttributes({
        visible: height > 0
      });
    }
    if (scene.bottomFrozenGroup.attribute.width > 0 && scene.bottomFrozenGroup.attribute.height > 0 && selectComp.rect.attribute.y + selectComp.rect.attribute.height > scene.bottomFrozenGroup.attribute.y && ("body" === selectComp.role || "rowHeader" === selectComp.role || "rightFrozen" === selectComp.role)) {
      const height = scene.bottomFrozenGroup.attribute.y - selectComp.rect.attribute.y;
      selectComp.rect.setAttributes({
        y: selectComp.rect.attribute.y,
        height: height > 0 ? height : 0
      }), null === (_f = selectComp.fillhandle) || void 0 === _f || _f.setAttributes({
        visible: height - rowsHeight > 0
      });
    }
  } else scene.tableGroup.insertAfter(selectComp.rect, "body" === selectComp.role ? scene.bodyGroup : "columnHeader" === selectComp.role ? scene.colHeaderGroup : "rowHeader" === selectComp.role ? scene.rowHeaderGroup : "cornerHeader" === selectComp.role ? scene.cornerHeaderGroup : "rightTopCorner" === selectComp.role ? scene.rightTopCornerGroup : "rightFrozen" === selectComp.role ? scene.rightFrozenGroup : "leftBottomCorner" === selectComp.role ? scene.leftBottomCornerGroup : "bottomFrozen" === selectComp.role ? scene.bottomFrozenGroup : scene.rightBottomCornerGroup);
  let diffSize = 0;
  "number" == typeof selectComp.rect.attribute.lineWidth && (diffSize = Math.ceil(selectComp.rect.attribute.lineWidth / 2)), endCol === table.colCount - 1 && (Array.isArray(selectComp.rect.attribute.lineWidth) && (diffSize = Math.ceil((null !== (_g = selectComp.rect.attribute.lineWidth[1]) && void 0 !== _g ? _g : 0) / 2)), selectComp.rect.setAttributes({
    width: selectComp.rect.attribute.width - diffSize
  })), 0 === startCol && (Array.isArray(selectComp.rect.attribute.lineWidth) && (diffSize = Math.ceil((null !== (_h = selectComp.rect.attribute.lineWidth[3]) && void 0 !== _h ? _h : 0) / 2)), selectComp.rect.setAttributes({
    x: selectComp.rect.attribute.x + diffSize,
    width: selectComp.rect.attribute.width - diffSize
  })), endRow === table.rowCount - 1 && (Array.isArray(selectComp.rect.attribute.lineWidth) && (diffSize = Math.ceil((null !== (_j = selectComp.rect.attribute.lineWidth[2]) && void 0 !== _j ? _j : 0) / 2)), selectComp.rect.setAttributes({
    height: selectComp.rect.attribute.height - diffSize
  })), 0 === startRow && (Array.isArray(selectComp.rect.attribute.lineWidth) && (diffSize = Math.ceil((null !== (_k = selectComp.rect.attribute.lineWidth[0]) && void 0 !== _k ? _k : 0) / 2)), selectComp.rect.setAttributes({
    y: selectComp.rect.attribute.y + diffSize,
    height: selectComp.rect.attribute.height - diffSize
  }));
}
function updateCellSelectBorder(scene, selectRange, ifExtendSelectRange = true) {
  const table = scene.table, newStartCol = selectRange.start.col, newStartRow = selectRange.start.row, newEndCol = selectRange.end.col, newEndRow = selectRange.end.row, skipBodyMerge = selectRange.skipBodyMerge;
  let startCol = Math.max(Math.min(newEndCol, newStartCol), 0), startRow = Math.max(Math.min(newEndRow, newStartRow), 0), endCol = Math.min(Math.max(newEndCol, newStartCol), table.colCount - 1), endRow = Math.min(Math.max(newEndRow, newStartRow), table.rowCount - 1);
  const extendSelectRange = () => {
    let isExtend = false;
    for (let col = startCol; col <= endCol; col++) {
      if (col === startCol) for (let row = startRow; row <= endRow; row++) {
        if (!table.isHeader(col, row) && skipBodyMerge) continue;
        const mergeInfo = getCellMergeInfo(table, col, row);
        if (mergeInfo && mergeInfo.start.col < startCol) {
          startCol = mergeInfo.start.col, isExtend = true;
          break;
        }
      }
      if (!isExtend && col === endCol) for (let row = startRow; row <= endRow; row++) {
        if (!table.isHeader(col, row) && skipBodyMerge) continue;
        const mergeInfo = getCellMergeInfo(table, col, row);
        if (mergeInfo && Math.min(mergeInfo.end.col, table.colCount - 1) > endCol) {
          endCol = mergeInfo.end.col, isExtend = true;
          break;
        }
      }
      if (isExtend) break;
    }
    if (!isExtend) for (let row = startRow; row <= endRow; row++) {
      if (row === startRow) for (let col = startCol; col <= endCol; col++) {
        if (!table.isHeader(col, row) && skipBodyMerge) continue;
        const mergeInfo = getCellMergeInfo(table, col, row);
        if (mergeInfo && mergeInfo.start.row < startRow) {
          startRow = mergeInfo.start.row, isExtend = true;
          break;
        }
      }
      if (!isExtend && row === endRow) for (let col = startCol; col <= endCol; col++) {
        if (!table.isHeader(col, row) && skipBodyMerge) continue;
        const mergeInfo = getCellMergeInfo(table, col, row);
        if (mergeInfo && Math.min(mergeInfo.end.row, table.rowCount - 1) > endRow) {
          endRow = mergeInfo.end.row, isExtend = true;
          break;
        }
      }
      if (isExtend) break;
    }
    isExtend && extendSelectRange();
  };
  ifExtendSelectRange && (extendSelectRange(), selectRange.start.col > selectRange.end.col ? (selectRange.start.col = Math.max(startCol, endCol), selectRange.end.col = Math.min(startCol, endCol)) : (selectRange.start.col = Math.min(startCol, endCol), selectRange.end.col = Math.max(startCol, endCol)), selectRange.start.row > selectRange.end.row ? (selectRange.start.row = Math.max(startRow, endRow), selectRange.end.row = Math.min(startRow, endRow)) : (selectRange.start.row = Math.min(startRow, endRow), selectRange.end.row = Math.max(startRow, endRow))), scene.selectingRangeComponents.forEach((selectComp, key) => {
    var _a;
    selectComp.rect.delete(), null === (_a = selectComp.fillhandle) || void 0 === _a || _a.delete();
  }), scene.selectingRangeComponents = /* @__PURE__ */ new Map();
  let needRowHeader = false, needRightRowHeader = false, needColumnHeader = false, needBottomColumnHeader = false, needBody = false, needCornerHeader = false, needRightTopCornerHeader = false, needRightBottomCornerHeader = false, needLeftBottomCornerHeader = false;
  if (startCol <= table.frozenColCount - 1 && startRow <= table.frozenRowCount - 1 && (needCornerHeader = true), endCol >= table.colCount - table.rightFrozenColCount && startRow <= table.frozenRowCount - 1 && (needRightTopCornerHeader = true), startCol <= table.frozenColCount - 1 && endRow >= table.rowCount - table.bottomFrozenRowCount && (needLeftBottomCornerHeader = true), endCol >= table.colCount - table.rightFrozenColCount && endRow >= table.rowCount - table.bottomFrozenRowCount && (needRightBottomCornerHeader = true), startCol <= table.frozenColCount - 1 && endRow >= table.frozenRowCount && startRow <= table.rowCount - table.bottomFrozenRowCount - 1 && (needRowHeader = true), endCol >= table.colCount - table.rightFrozenColCount && endRow >= table.frozenRowCount && startRow <= table.rowCount - table.bottomFrozenRowCount - 1 && (needRightRowHeader = true), startRow <= table.frozenRowCount - 1 && endCol >= table.frozenColCount && startCol <= table.colCount - table.rightFrozenColCount - 1 && (needColumnHeader = true), endRow >= table.rowCount - table.bottomFrozenRowCount && endCol >= table.frozenColCount && startCol <= table.colCount - table.rightFrozenColCount - 1 && (needBottomColumnHeader = true), startCol <= table.colCount - table.rightFrozenColCount - 1 && endCol >= table.frozenColCount && startRow <= table.rowCount - table.bottomFrozenRowCount - 1 && endRow >= table.frozenRowCount && (needBody = true), needCornerHeader) {
    const cornerEndCol = Math.min(endCol, table.frozenColCount - 1), cornerEndRow = Math.min(endRow, table.frozenRowCount - 1), strokeArray = [true, !needColumnHeader, !needRowHeader, true];
    scene.createCellSelectBorder(startCol, startRow, cornerEndCol, cornerEndRow, "cornerHeader", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needRightTopCornerHeader) {
    const cornerStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount), cornerEndRow = Math.min(endRow, table.frozenRowCount - 1), strokeArray = [true, true, !needRightRowHeader, !needColumnHeader];
    scene.createCellSelectBorder(cornerStartCol, startRow, endCol, cornerEndRow, "rightTopCorner", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needLeftBottomCornerHeader) {
    const cornerEndCol = Math.min(endCol, table.frozenColCount - 1), cornerStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount), strokeArray = [!needRowHeader, !needBottomColumnHeader, true, true];
    scene.createCellSelectBorder(startCol, cornerStartRow, cornerEndCol, endRow, "leftBottomCorner", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needRightBottomCornerHeader) {
    const cornerStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount), cornerStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount), strokeArray = [!needRightRowHeader, true, true, !needBottomColumnHeader];
    scene.createCellSelectBorder(cornerStartCol, cornerStartRow, endCol, endRow, "rightBottomCorner", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needColumnHeader) {
    const columnHeaderStartCol = Math.max(startCol, table.frozenColCount), columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1), columnHeaderEndRow = Math.min(endRow, table.frozenRowCount - 1), strokeArray = [true, !needRightTopCornerHeader, !needBody, !needCornerHeader];
    scene.createCellSelectBorder(columnHeaderStartCol, startRow, columnHeaderEndCol, columnHeaderEndRow, "columnHeader", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needBottomColumnHeader) {
    const columnHeaderStartCol = Math.max(startCol, table.frozenColCount), columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1), columnHeaderStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount), strokeArray = [!needBody, !needRightBottomCornerHeader, true, !needLeftBottomCornerHeader];
    scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, columnHeaderEndCol, endRow, "bottomFrozen", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needRowHeader) {
    const columnHeaderStartRow = Math.max(startRow, table.frozenRowCount), columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1), columnHeaderEndCol = Math.min(endCol, table.frozenColCount - 1), strokeArray = [!needCornerHeader, !needBody, !needLeftBottomCornerHeader, true];
    scene.createCellSelectBorder(startCol, columnHeaderStartRow, columnHeaderEndCol, columnHeaderEndRow, "rowHeader", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needRightRowHeader) {
    const columnHeaderStartRow = Math.max(startRow, table.frozenRowCount), columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1), columnHeaderStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount), strokeArray = [!needRightTopCornerHeader, true, !needRightBottomCornerHeader, !needBody];
    scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, endCol, columnHeaderEndRow, "rightFrozen", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
  if (needBody) {
    const columnHeaderStartCol = Math.max(startCol, table.frozenColCount), columnHeaderStartRow = Math.max(startRow, table.frozenRowCount), columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1), columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1), strokeArray = [!needColumnHeader, !needRightRowHeader, !needBottomColumnHeader, !needRowHeader];
    scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, columnHeaderEndCol, columnHeaderEndRow, "body", `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
  }
}
function hideCellSelectBorder(scene) {
  scene.selectingRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.setAttribute("opacity", 0);
  }), scene.selectedRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.setAttribute("opacity", 0);
  });
}
function restoreCellSelectBorder(scene) {
  scene.selectingRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.setAttribute("opacity", 1);
  }), scene.selectedRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.setAttribute("opacity", 1);
  });
}

// node_modules/@visactor/vtable/es/scenegraph/select/create-select-border.js
function createCellSelectBorder(scene, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  let isHasFillHandleRect = !!(null === (_a = scene.table.options.excelOptions) || void 0 === _a ? void 0 : _a.fillHandle);
  if ((null === (_b = scene.table.stateManager.select.ranges) || void 0 === _b ? void 0 : _b.length) > 1) isHasFillHandleRect = false, scene.removeFillHandleFromSelectComponents();
  else if (1 === (null === (_c = scene.table.stateManager.select.ranges) || void 0 === _c ? void 0 : _c.length)) {
    const maxRow = Math.max(scene.table.stateManager.select.ranges[0].start.row, scene.table.stateManager.select.ranges[0].end.row), maxCol = Math.max(scene.table.stateManager.select.ranges[0].start.col, scene.table.stateManager.select.ranges[0].end.col);
    scene.table.isHeader(maxCol, maxRow) && (isHasFillHandleRect = false);
  }
  !Array.isArray(strokes) || false !== strokes[1] && false !== strokes[2] || (isHasFillHandleRect = false);
  const startCol = Math.min(start_Col, end_Col), startRow = Math.min(start_Row, end_Row), endCol = Math.max(start_Col, end_Col), endRow = Math.max(start_Row, end_Row), firstCellBound = scene.highPerformanceGetCell(startCol, startRow).globalAABBBounds, lastCellBound = scene.highPerformanceGetCell(endCol, endRow).globalAABBBounds, theme4 = scene.table.theme, bodyClickBorderColor = null === (_d = theme4.selectionStyle) || void 0 === _d ? void 0 : _d.cellBorderColor, bodyClickLineWidth = null === (_e = theme4.selectionStyle) || void 0 === _e ? void 0 : _e.cellBorderLineWidth, rect = createRect({
    pickable: false,
    fill: "replace" !== (null === (_f = theme4.selectionStyle) || void 0 === _f ? void 0 : _f.selectionFillMode) && (null !== (_h = null === (_g = theme4.selectionStyle) || void 0 === _g ? void 0 : _g.cellBgColor) && void 0 !== _h ? _h : "rgba(0, 0, 255,0.1)"),
    lineWidth: bodyClickLineWidth,
    stroke: strokes.map((stroke2) => !!stroke2 && bodyClickBorderColor),
    x: firstCellBound.x1 - scene.tableGroup.attribute.x,
    y: firstCellBound.y1 - scene.tableGroup.attribute.y,
    width: 0,
    height: 0,
    visible: true,
    cornerRadius: getCornerRadius(selectRangeType, null === (_j = scene.table.theme.frameStyle) || void 0 === _j ? void 0 : _j.cornerRadius, start_Col, start_Row, end_Col, end_Row, scene.table)
  });
  let fillhandle;
  isHasFillHandleRect && (fillhandle = createRect({
    pickable: false,
    fill: bodyClickBorderColor,
    stroke: bodyClickBorderColor,
    x: lastCellBound.x2 - 3,
    y: lastCellBound.y2 - 3,
    width: 6,
    height: 6,
    visible: true
  })), scene.lastSelectId = selectId, scene.selectingRangeComponents.set(`${startCol}-${startRow}-${endCol}-${endRow}-${selectId}`, {
    rect,
    fillhandle,
    role: selectRangeType
  }), scene.tableGroup.insertAfter(rect, "body" === selectRangeType ? scene.bodyGroup : "columnHeader" === selectRangeType ? scene.colHeaderGroup : "rowHeader" === selectRangeType ? scene.rowHeaderGroup : "cornerHeader" === selectRangeType ? scene.cornerHeaderGroup : "rightTopCorner" === selectRangeType ? scene.rightTopCornerGroup : "rightFrozen" === selectRangeType ? scene.rightFrozenGroup : "leftBottomCorner" === selectRangeType ? scene.leftBottomCornerGroup : "bottomFrozen" === selectRangeType ? scene.bottomFrozenGroup : scene.rightBottomCornerGroup), isHasFillHandleRect && scene.tableGroup.insertAfter(fillhandle, "body" === selectRangeType ? scene.bodyGroup : "columnHeader" === selectRangeType ? scene.colHeaderGroup : "rowHeader" === selectRangeType ? scene.rowHeaderGroup : "cornerHeader" === selectRangeType ? scene.cornerHeaderGroup : "rightTopCorner" === selectRangeType ? scene.rightTopCornerGroup : "rightFrozen" === selectRangeType ? scene.rightFrozenGroup : "leftBottomCorner" === selectRangeType ? scene.leftBottomCornerGroup : "bottomFrozen" === selectRangeType ? scene.bottomFrozenGroup : scene.rightBottomCornerGroup);
}
function getCornerRadius(selectRangeType, cornerRadius, start_Col, start_Row, end_Col, end_Row, table) {
  if (!cornerRadius) return;
  const cornerRadiusArray = Array.isArray(cornerRadius) ? cornerRadius : [cornerRadius, cornerRadius, cornerRadius, cornerRadius], tableEndCol = table.colCount - 1, tableEndRow = table.rowCount - 1, result2 = [0, 0, 0, 0];
  let changed = false;
  return 0 === start_Col && 0 === start_Row ? (result2[0] = cornerRadiusArray[0], changed = true) : end_Col === tableEndCol && end_Row === tableEndRow ? (result2[2] = cornerRadiusArray[2], changed = true) : 0 === start_Col && end_Row === tableEndRow ? (result2[3] = cornerRadiusArray[3], changed = true) : end_Col === tableEndCol && 0 === start_Row && (result2[1] = cornerRadiusArray[1], changed = true), changed ? result2 : void 0;
}

// node_modules/@visactor/vtable/es/scenegraph/select/move-select-border.js
function moveSelectingRangeComponentsToSelectedRangeComponents(scene) {
  scene.selectingRangeComponents.forEach((rangeComponent, key) => {
    var _a;
    scene.selectedRangeComponents.get(key) && (scene.selectingRangeComponents.get(key).rect.delete(), null === (_a = scene.selectingRangeComponents.get(key).fillhandle) || void 0 === _a || _a.delete()), scene.selectedRangeComponents.set(key, rangeComponent);
  }), scene.selectingRangeComponents = /* @__PURE__ */ new Map(), scene.updateNextFrame();
}

// node_modules/@visactor/vtable/es/scenegraph/select/delete-select-border.js
function deleteLastSelectedRangeComponents(scene) {
  scene.selectedRangeComponents.forEach((selectComp, key) => {
    var _a;
    key.split("-")[4] === scene.lastSelectId && (selectComp.rect.delete(), null === (_a = selectComp.fillhandle) || void 0 === _a || _a.delete(), scene.selectedRangeComponents.delete(key));
  });
}
function deleteAllSelectBorder(scene) {
  scene.selectedRangeComponents.forEach((selectComp, key) => {
    var _a;
    selectComp.rect.delete(), null === (_a = selectComp.fillhandle) || void 0 === _a || _a.delete();
  }), scene.selectedRangeComponents = /* @__PURE__ */ new Map();
}
function deleteAllSelectingBorder(scene) {
  scene.selectingRangeComponents.forEach((selectComp, key) => {
    var _a;
    selectComp.rect.delete(), null === (_a = selectComp.fillhandle) || void 0 === _a || _a.delete();
  }), scene.selectingRangeComponents = /* @__PURE__ */ new Map();
}
function removeFillHandleFromSelectComponents(scene) {
  scene.selectedRangeComponents.forEach((selectComp, key) => {
    var _a;
    null === (_a = selectComp.fillhandle) || void 0 === _a || _a.delete(), selectComp.fillhandle = void 0;
  });
}

// node_modules/@visactor/vtable/es/scenegraph/layout/update-row.js
function updateRow(removeCells, addCells, updateCells, table, skipUpdateProxy) {
  var _a, _b;
  checkHaveTextStick(table) && resetTextStick(table);
  const scene = table.scenegraph, removeRows = deduplication(removeCells.map((cell) => cell.row)).sort((a2, b) => b - a2), addRows = deduplication(addCells.map((cell) => cell.row)).sort((a2, b) => a2 - b), updateRows = deduplication(updateCells.map((cell) => cell.row)).sort((a2, b) => a2 - b);
  let rowUpdatePos;
  if (updateRows.length) {
    rowUpdatePos = _getUpdateRowIndexUseCellNode(updateRows[0] - 1, updateRows[updateRows.length - 1] + 1, scene);
  }
  if (addRows.length) {
    const pos = _getUpdateRowIndexUseCellNode(addRows[0] - 1, addRows[addRows.length - 1] + 1, scene);
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos : pos;
  }
  if (removeRows.length) {
    const pos = _getUpdateRowIndexUseCellNode(removeRows[0] - 1, removeRows[removeRows.length - 1] + 1, scene);
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos : pos;
  }
  removeRows.forEach((row) => {
    removeRow(row, scene, skipUpdateProxy);
  });
  const rowHeightsMap = table.rowHeightsMap;
  if (removeRows.forEach((row) => {
    rowHeightsMap.delete(row);
  }), removeRows.length) {
    resetRowNumber(scene);
    const pos = _getUpdateRowIndex(removeRows[removeRows.length - 1] - 1, removeRows[0] - removeRows.length + 1, scene);
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos : pos;
  }
  let updateAfter;
  if (scene.table._clearRowRangeHeightsMap(), addRows.forEach((row) => {
    const needUpdateAfter = addRow(row, scene, skipUpdateProxy);
    updateAfter = null != updateAfter ? updateAfter : needUpdateAfter, rowHeightsMap.insert(row);
  }), resetRowNumberAndY(scene), addRows.length) {
    const pos = _getUpdateRowIndex(addRows[0] - 1, addRows[addRows.length - 1] + 1, scene);
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos : pos;
  }
  for (let col = 0; col < table.colCount; col++) updateRows.forEach((row) => {
    if (row < table.frozenRowCount) {
      const mergeInfo = getCellMergeInfo(scene.table, col, row);
      if (mergeInfo) for (let col2 = mergeInfo.start.col; col2 <= mergeInfo.end.col; col2++) for (let row2 = mergeInfo.start.row; row2 <= mergeInfo.end.row; row2++) updateCell(col2, row2, scene.table, false);
      else updateCell(col, row, scene.table, false);
    } else if (row > table.rowCount - 1 || row < scene.table.rowCount - scene.table.bottomFrozenRowCount && (row < scene.proxy.rowStart || row > scene.proxy.rowEnd)) removeCellGroup(row, scene);
    else {
      const mergeInfo = getCellMergeInfo(scene.table, col, row);
      if (mergeInfo) for (let col2 = mergeInfo.start.col; col2 <= mergeInfo.end.col; col2++) for (let row2 = mergeInfo.start.row; row2 <= mergeInfo.end.row; row2++) updateCell(col2, row2, scene.table, false);
      else updateCell(col, row, scene.table, false);
    }
  });
  if (updateRows.length) {
    const pos = _getUpdateRowIndex(updateRows[0] - 1, updateRows[updateRows.length - 1] + 1, scene);
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos : pos;
  }
  if (isNumber_default(updateAfter)) {
    for (let col = 0; col < Math.max(table.colCount, null !== (_a = table.internalProps._oldColCount) && void 0 !== _a ? _a : table.colCount); col++) for (let row = updateAfter; row < Math.max(table.rowCount, null !== (_b = table.internalProps._oldRowCount) && void 0 !== _b ? _b : table.rowCount); row++) {
      const cellGroup = scene.highPerformanceGetCell(col, row, true);
      cellGroup && (cellGroup.needUpdate = true);
    }
    rowUpdatePos = isValid_default(rowUpdatePos) ? isValid_default(updateAfter) ? Math.min(rowUpdatePos, updateAfter) : rowUpdatePos : updateAfter;
  }
  if (isNumber_default(rowUpdatePos) && (scene.proxy.rowUpdatePos = Math.min(scene.proxy.rowUpdatePos, rowUpdatePos)), addRows.length) {
    if (!isNumber_default(updateAfter)) {
      const minRow = Math.min(...addRows);
      scene.proxy.rowUpdatePos = Math.min(minRow, scene.proxy.rowUpdatePos);
    }
    scene.proxy.rowUpdateDirection = "up", scene.proxy.updateCellGroups(2 * scene.proxy.screenRowCount), updateBottomFrozeCellGroups();
  } else removeRows.length && (setRowSeriesNumberCellNeedUpdate(removeRows[removeRows.length - 1], scene), scene.proxy.updateCellGroups(2 * scene.proxy.screenRowCount), updateBottomFrozeCellGroups());
  scene.proxy.progress();
  const newTotalHeight = table.getRowsHeight(table.frozenRowCount, table.rowCount - 1 - table.bottomFrozenRowCount);
  function updateBottomFrozeCellGroups() {
    if ((null == addRows ? void 0 : addRows[(null == addRows ? void 0 : addRows.length) - 1]) >= table.rowCount - table.bottomFrozenRowCount || (null == updateRows ? void 0 : updateRows[(null == updateRows ? void 0 : updateRows.length) - 1]) >= table.rowCount - table.bottomFrozenRowCount || (null == removeRows ? void 0 : removeRows[0]) >= table.rowCount - table.bottomFrozenRowCount) {
      for (let col = 0; col < table.colCount; col++) for (let row = table.rowCount - table.bottomFrozenRowCount; row < table.rowCount; row++) {
        const cellGroup = scene.highPerformanceGetCell(col, row, true);
        cellGroup && (cellGroup.needUpdate = true);
      }
      scene.proxy.updateBottomFrozenCellGroups();
    }
  }
  scene.updateContainerHeight(scene.table.frozenRowCount, newTotalHeight - scene.bodyGroup.attribute.height);
}
function removeRow(row, scene, skipUpdateProxy) {
  const proxy = scene.proxy;
  if (row >= proxy.rowStart && row <= proxy.rowEnd && (removeCellGroup(row, scene), proxy.rowEnd--, proxy.currentRow--), !skipUpdateProxy) {
    proxy.bodyBottomRow--;
    const totalActualBodyRowCount = Math.min(proxy.rowLimit, proxy.bodyBottomRow - proxy.bodyTopRow + 1);
    proxy.totalActualBodyRowCount = totalActualBodyRowCount, proxy.totalRow = Math.min(proxy.table.rowCount - 1, proxy.rowStart + totalActualBodyRowCount - 1);
  }
}
function addRow(row, scene, skipUpdateProxy) {
  const proxy = scene.proxy;
  if (!skipUpdateProxy) {
    proxy.bodyBottomRow++;
    const totalActualBodyRowCount = Math.min(proxy.rowLimit, proxy.bodyBottomRow - proxy.bodyTopRow + 1);
    proxy.totalActualBodyRowCount = totalActualBodyRowCount, proxy.totalRow = proxy.rowStart + totalActualBodyRowCount - 1;
  }
  if (!(row < proxy.rowStart)) return row > proxy.rowEnd ? proxy.rowEnd - proxy.rowStart + 1 < proxy.rowLimit ? (proxy.rowEnd++, proxy.currentRow++, addRowCellGroup(row, scene), row) : void 0 : proxy.rowEnd - proxy.rowStart + 1 < proxy.rowLimit ? (proxy.rowEnd++, proxy.currentRow++, addRowCellGroup(row, scene), row) : row;
}
function resetRowNumber(scene) {
  function processCell(cellGroup, rowIndex) {
    cellGroup.row = rowIndex;
    const merge5 = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
    merge5 ? (cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeEndCol = merge5.end.col, cellGroup.mergeStartRow = merge5.start.row, cellGroup.mergeEndRow = merge5.end.row) : (cellGroup.mergeStartCol = void 0, cellGroup.mergeEndCol = void 0, cellGroup.mergeStartRow = void 0, cellGroup.mergeEndRow = void 0);
  }
  scene.bodyGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  }), scene.rowHeaderGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  }), scene.rightFrozenGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  }), scene.bottomFrozenGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  }), scene.leftBottomCornerGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  }), scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex), rowIndex++;
    });
  });
}
function resetRowNumberAndY(scene) {
  function processCell(cellGroup, rowIndex, y) {
    cellGroup.row = rowIndex, cellGroup.setAttribute("y", y);
    const merge5 = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
    merge5 ? (cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeEndCol = merge5.end.col, cellGroup.mergeStartRow = merge5.start.row, cellGroup.mergeEndRow = merge5.end.row) : (cellGroup.mergeStartCol = void 0, cellGroup.mergeEndCol = void 0, cellGroup.mergeStartRow = void 0, cellGroup.mergeEndRow = void 0);
  }
  scene.bodyGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart, y = scene.getCellGroupY(rowIndex);
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  }), scene.rowHeaderGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart, y = scene.getCellGroupY(rowIndex);
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  }), scene.rightFrozenGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.bodyRowStart, y = scene.getCellGroupY(rowIndex);
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  }), scene.bottomFrozenGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount, y = 0;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  }), scene.leftBottomCornerGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount, y = 0;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  }), scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
    let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount, y = 0;
    null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup, rowIndex, y), rowIndex++, y += cellGroup.attribute.height;
    });
  });
}
function addRowCellGroup(row, scene) {
  for (let col = 0; col < scene.table.colCount; col++) {
    const cellGroup = new Group2({
      x: 0,
      y: 0,
      width: scene.table.getColWidth(col),
      height: scene.table.getRowHeight(row)
    });
    if (cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, cellGroup.needUpdate = true, !cellGroup) continue;
    const colGroup = scene.getColGroup(col);
    if (colGroup) if (colGroup.firstChild && row < colGroup.firstChild.row) colGroup.insertBefore(cellGroup, colGroup.firstChild), colGroup.firstChild.row = colGroup.firstChild.row + 1;
    else if (colGroup.lastChild && row > colGroup.lastChild.row) colGroup.appendChild(cellGroup);
    else {
      const cellBefore = scene.highPerformanceGetCell(col, row, true);
      cellBefore !== cellGroup && (colGroup.insertBefore(cellGroup, cellBefore), cellBefore && (cellBefore.row = cellBefore.row + 1), cellBefore !== colGroup.lastChild && colGroup.lastChild && (colGroup.lastChild.row = colGroup.lastChild.row + 1));
    }
  }
}
function removeCellGroup(row, scene) {
  for (let col = 0; col < scene.table.colCount; col++) {
    const colGroup = scene.getColGroup(col, false);
    if (!colGroup) continue;
    let cellGroup;
    colGroup.forEachChildren((cell) => cell.row === row && (cellGroup = cell, true)), cellGroup && (colGroup.updateColumnHeight(-cellGroup.attribute.height), colGroup.removeChild(cellGroup));
  }
}
function _getUpdateRowIndex(beforeRow, afterRow, scene) {
  let updateRow2;
  for (let col = 0; col < scene.table.colCount; col++) {
    const rangeBefore = scene.table.getCellRange(col, beforeRow);
    let row;
    rangeBefore.start.row <= beforeRow + 1 && rangeBefore.end.row >= beforeRow + 1 && (addNeedUpdateTag(rangeBefore, scene), row = rangeBefore.start.row);
    const rangeAfter = scene.table.getCellRange(col, afterRow);
    rangeAfter.start.row <= afterRow + 1 && rangeAfter.end.row >= afterRow + 1 && (addNeedUpdateTag(rangeAfter, scene), row = rangeAfter.start.row), isValid_default(row) && (updateRow2 = isValid_default(updateRow2) ? Math.min(updateRow2, row) : row);
  }
  return updateRow2;
}
function _getUpdateRowIndexUseCellNode(beforeRow, afterRow, scene) {
  let updateRow2;
  for (let col = 0; col < scene.table.colCount; col++) {
    let row;
    const beforeCell = scene.highPerformanceGetCell(col, beforeRow);
    beforeCell.mergeStartRow && beforeCell.mergeEndRow && beforeCell.mergeEndRow > beforeRow && (addNeedUpdateTag({
      start: {
        row: beforeCell.mergeStartRow,
        col: scene.table.isAutoRowHeight(afterRow) ? 0 : beforeCell.mergeStartCol
      },
      end: {
        row: beforeCell.mergeEndRow,
        col: scene.table.isAutoRowHeight(afterRow) ? scene.table.colCount - 1 : beforeCell.mergeEndCol
      }
    }, scene), row = beforeCell.mergeStartRow);
    const afterCell = scene.highPerformanceGetCell(col, afterRow);
    afterCell.mergeStartRow && afterCell.mergeEndRow && afterCell.mergeStartRow < afterRow && (addNeedUpdateTag({
      start: {
        row: afterCell.mergeStartRow,
        col: scene.table.isAutoRowHeight(afterRow) ? 0 : afterCell.mergeStartCol
      },
      end: {
        row: afterCell.mergeEndRow,
        col: scene.table.isAutoRowHeight(afterRow) ? scene.table.colCount - 1 : afterCell.mergeEndCol
      }
    }, scene), row = afterCell.mergeStartRow), isValid_default(row) && (updateRow2 = isValid_default(updateRow2) ? Math.min(updateRow2, row) : row);
  }
  return updateRow2;
}
function addNeedUpdateTag(range5, scene) {
  const { start, end } = range5;
  for (let col = start.col; col <= end.col; col++) for (let row = start.row; row <= end.row; row++) {
    const cellGroup = scene.highPerformanceGetCell(col, row, true);
    cellGroup && (cellGroup.needUpdate = true);
  }
}
function setRowSeriesNumberCellNeedUpdate(startUpdateRow, scene) {
  if (scene.table.isHasSeriesNumber()) for (let row = startUpdateRow; row <= scene.table.rowCount - 1; row++) updateCell(0, row, scene.table, false);
}

// node_modules/@visactor/vtable/es/scenegraph/layout/frozen-react.js
function createReactContainer(table) {
  const { internalProps } = table;
  internalProps.bodyDomContainer = document.createElement("div"), internalProps.bodyDomContainer.id = "vtable-body-dom-container", internalProps.bodyDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.bodyDomContainer), internalProps.headerDomContainer = document.createElement("div"), internalProps.headerDomContainer.id = "vtable-header-dom-container", internalProps.headerDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.headerDomContainer), internalProps.frozenBodyDomContainer = document.createElement("div"), internalProps.frozenBodyDomContainer.id = "vtable-frozen-body-dom-container", internalProps.frozenBodyDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.frozenBodyDomContainer), internalProps.frozenHeaderDomContainer = document.createElement("div"), internalProps.frozenHeaderDomContainer.id = "vtable-frozen-header-dom-container", internalProps.frozenHeaderDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.frozenHeaderDomContainer), internalProps.rightFrozenBodyDomContainer = document.createElement("div"), internalProps.rightFrozenBodyDomContainer.id = "vtable-right-frozen-body-dom-container", internalProps.rightFrozenBodyDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.rightFrozenBodyDomContainer), internalProps.rightFrozenHeaderDomContainer = document.createElement("div"), internalProps.rightFrozenHeaderDomContainer.id = "vtable-right-frozen-header-dom-container", internalProps.rightFrozenHeaderDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.rightFrozenHeaderDomContainer), internalProps.frozenBottomDomContainer = document.createElement("div"), internalProps.frozenBottomDomContainer.id = "vtable-frozen-bottom-dom-container", internalProps.frozenBottomDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.frozenBottomDomContainer), internalProps.bottomDomContainer = document.createElement("div"), internalProps.bottomDomContainer.id = "vtable-bottom-dom-container", internalProps.bottomDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.bottomDomContainer), internalProps.rightFrozenBottomDomContainer = document.createElement("div"), internalProps.rightFrozenBottomDomContainer.id = "vtable-right-frozen-bottom-dom-container", internalProps.rightFrozenBottomDomContainer.classList.add("table-component-container"), internalProps.element.appendChild(internalProps.rightFrozenBottomDomContainer);
}
function updateReactContainer(table) {
  const { headerDomContainer, bodyDomContainer, frozenBodyDomContainer, frozenHeaderDomContainer, rightFrozenBodyDomContainer, rightFrozenHeaderDomContainer, bottomDomContainer, frozenBottomDomContainer, rightFrozenBottomDomContainer } = table.internalProps;
  if (!(headerDomContainer || bodyDomContainer || frozenBodyDomContainer || frozenHeaderDomContainer || rightFrozenBodyDomContainer || rightFrozenHeaderDomContainer || bottomDomContainer || frozenBottomDomContainer || rightFrozenBottomDomContainer)) return;
  const allColsWidth = table.getAllColsWidth(), tableNoFrameWidth = Math.min(allColsWidth, table.tableNoFrameWidth), frozenColsWidth = table.getFrozenColsWidth(), rightFrozenColsWidth = table.getRightFrozenColsWidth(), totalFrozenColsWidth = frozenColsWidth + rightFrozenColsWidth, bodyWidth = Math.min(allColsWidth - totalFrozenColsWidth, tableNoFrameWidth - totalFrozenColsWidth), allRowsHeight = table.getAllRowsHeight(), tableNoFrameHeight = Math.min(allRowsHeight, table.tableNoFrameHeight), frozenRowsHeight = table.getFrozenRowsHeight(), bottomFrozenRowsHeight = table.getBottomFrozenRowsHeight(), totalFrozenRowsHeight = frozenRowsHeight + bottomFrozenRowsHeight, bodyHeight = Math.min(allRowsHeight - totalFrozenRowsHeight, tableNoFrameHeight - totalFrozenRowsHeight);
  table.frozenColCount > 0 ? (headerDomContainer.style.left = `${table.tableX + frozenColsWidth}px`, bodyDomContainer.style.left = `${table.tableX + frozenColsWidth}px`, bottomDomContainer.style.left = `${table.tableX + frozenColsWidth}px`) : 0 === table.frozenColCount && (headerDomContainer.style.left = `${table.tableX}px`, bodyDomContainer.style.left = `${table.tableX}px`, bottomDomContainer.style.left = `${table.tableX}px`), frozenBodyDomContainer.style.left = `${table.tableX}px`, frozenHeaderDomContainer.style.left = `${table.tableX}px`, headerDomContainer.style.width = `${bodyWidth}px`, headerDomContainer.style.height = `${frozenRowsHeight}px`, bodyDomContainer.style.top = `${table.tableY}px`, bodyDomContainer.style.width = `${bodyWidth}px`, bodyDomContainer.style.height = `${bodyHeight}px`, bodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`, frozenBodyDomContainer.style.width = `${frozenColsWidth}px`, frozenBodyDomContainer.style.height = `${bodyHeight}px`, frozenBodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`, frozenHeaderDomContainer.style.width = `${frozenColsWidth}px`, frozenHeaderDomContainer.style.height = `${frozenRowsHeight}px`, frozenHeaderDomContainer.style.top = `${table.tableY}px`, rightFrozenBodyDomContainer.style.width = `${rightFrozenColsWidth}px`, rightFrozenBodyDomContainer.style.height = `${bodyHeight}px`, rightFrozenBodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`, rightFrozenBodyDomContainer.style.left = table.tableX + tableNoFrameWidth - rightFrozenColsWidth + "px", rightFrozenHeaderDomContainer.style.width = `${rightFrozenColsWidth}px`, rightFrozenHeaderDomContainer.style.height = `${frozenRowsHeight}px`, rightFrozenHeaderDomContainer.style.top = `${table.tableY}px`, rightFrozenHeaderDomContainer.style.left = table.tableX + tableNoFrameWidth - rightFrozenColsWidth + "px", bottomDomContainer.style.width = `${bodyWidth}px`, bottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`, bottomDomContainer.style.top = table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight + "px", frozenBottomDomContainer.style.width = `${frozenColsWidth}px`, frozenBottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`, frozenBottomDomContainer.style.top = table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight + "px", rightFrozenBottomDomContainer.style.width = `${rightFrozenColsWidth}px`, rightFrozenBottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`, rightFrozenBottomDomContainer.style.top = table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight + "px", rightFrozenBottomDomContainer.style.left = table.tableX + tableNoFrameWidth - rightFrozenColsWidth + "px";
}
function updateReactComponentContainer(scene) {
  if (!scene.table.reactCustomLayout) return;
  const { table, stage } = scene, plugin = stage.pluginService.findPluginsByName("ReactAttributePlugin")[0], { htmlMap, renderId: stageRenderId } = plugin;
  for (const key in htmlMap) {
    const item = htmlMap[key], { graphic, wrapContainer, renderId } = item;
    if (renderId !== stageRenderId) continue;
    let targetContainer;
    if (scene.frozenColCount > table.frozenColCount) {
      const targetCell = getTargetCell(graphic);
      if (!targetCell) continue;
      const { col, row } = targetCell;
      row >= table.rowCount - table.bottomFrozenRowCount && col < scene.frozenColCount && col >= table.frozenColCount && graphic.attribute.react.container === table.frozenBottomDomContainer ? targetContainer = table.bottomDomContainer : row >= table.frozenRowCount && col < scene.frozenColCount && col >= table.frozenColCount && graphic.attribute.react.container === table.frozenBodyDomContainer ? targetContainer = table.bodyDomContainer : row < table.frozenRowCount && col < scene.frozenColCount && col >= table.frozenColCount && graphic.attribute.react.container === table.frozenHeaderDomContainer && (targetContainer = table.headerDomContainer);
    } else if (scene.frozenColCount < table.frozenColCount) {
      const targetCell = getTargetCell(graphic);
      if (!targetCell) continue;
      const { col, row } = targetCell;
      row >= table.rowCount - table.bottomFrozenRowCount && col < table.frozenColCount && col >= scene.frozenColCount && graphic.attribute.react.container === table.bottomDomContainer ? targetContainer = table.frozenBottomDomContainer : row >= table.frozenRowCount && col < table.frozenColCount && col >= scene.frozenColCount && graphic.attribute.react.container === table.bodyDomContainer ? targetContainer = table.frozenBodyDomContainer : row < table.frozenRowCount && col < table.frozenColCount && col >= scene.frozenColCount && graphic.attribute.react.container === table.headerDomContainer && (targetContainer = table.frozenHeaderDomContainer);
    }
    targetContainer && (targetContainer.appendChild(wrapContainer), item.nativeContainer = targetContainer, item.container = targetContainer, graphic.attribute.react.container = targetContainer, plugin.updateStyleOfWrapContainer(graphic, stage, wrapContainer, targetContainer, graphic.attribute.react));
  }
}

// node_modules/@visactor/vtable/es/scenegraph/layout/frozen.js
function dealFrozen(scene) {
  var _a, _b, _c, _d;
  if (scene.table.frozenColCount > scene.table.rowHeaderLevelCount) {
    scene.rowHeaderGroup.setAttribute("height", scene.bodyGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.bodyGroup.attribute.y), scene.cornerHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height);
    for (let i = 0; i < scene.table.frozenColCount - scene.table.rowHeaderLevelCount; i++) moveColumnFromBodyToRowHeader(scene), moveColumnFromColHeaderToCornerHeader(scene), moveColumnFromBottomToLeftBottomCorner(scene);
  } else if (scene.table.frozenColCount < scene.table.rowHeaderLevelCount) {
    scene.bodyGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height), scene.bodyGroup.setAttribute("y", scene.rowHeaderGroup.attribute.y), scene.colHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height);
    for (let i = 0; i < scene.table.rowHeaderLevelCount - scene.table.frozenColCount; i++) moveColumnFromRowHeaderToBody(scene), moveColumnFromCornerHeaderToColHeader(scene), moveColumnFromLeftBottomCornerToBottom(scene);
  }
  scene.bodyGroup.setAttribute("x", scene.rowHeaderGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.cornerHeaderGroup.attribute.width), scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.isPivot || scene.table.transpose ? scene.table.options.frozenColCount ? scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1) : scene.table.options.frozenColCount && scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount) : (scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1), scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount)), scene.hasFrozen = true, scene.frozenColCount = scene.table.frozenColCount, scene.frozenRowCount = null !== (_d = null !== (_b = null === (_a = scene.colHeaderGroup.firstChild) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : null === (_c = scene.cornerHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.childrenCount) && void 0 !== _d ? _d : scene.table.frozenRowCount;
}
function resetFrozen(scene) {
  var _a, _b, _c, _d, _e, _f;
  if (scene.frozenColCount > scene.table.frozenColCount) {
    scene.bodyGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height), scene.bodyGroup.setAttribute("y", scene.rowHeaderGroup.attribute.y), scene.colHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height);
    for (let i = 0; i < scene.frozenColCount - scene.table.frozenColCount; i++) moveColumnFromRowHeaderToBody(scene), moveColumnFromCornerHeaderToColHeader(scene), moveColumnFromLeftBottomCornerToBottom(scene);
  } else if (scene.frozenColCount < scene.table.frozenColCount) {
    scene.rowHeaderGroup.setAttribute("height", scene.bodyGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.bodyGroup.attribute.y), scene.cornerHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height);
    for (let i = 0; i < scene.table.frozenColCount - scene.frozenColCount; i++) moveColumnFromBodyToRowHeader(scene), moveColumnFromColHeaderToCornerHeader(scene), moveColumnFromBottomToLeftBottomCorner(scene);
  }
  updateReactComponentContainer(scene), scene.recreateAllSelectRangeComponents(), scene.frozenColCount = scene.table.frozenColCount, scene.frozenRowCount = null !== (_d = null !== (_b = null === (_a = scene.colHeaderGroup.firstChild) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : null === (_c = scene.cornerHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.childrenCount) && void 0 !== _d ? _d : scene.table.frozenRowCount, scene.proxy.colStart = null !== (_f = null === (_e = scene.bodyGroup.firstChild) || void 0 === _e ? void 0 : _e.col) && void 0 !== _f ? _f : scene.table.frozenColCount, scene.bodyGroup.setAttribute("x", scene.rowHeaderGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.cornerHeaderGroup.attribute.width), scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.isPivot || scene.table.transpose ? scene.table.options.frozenColCount ? scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1) : scene.table.options.rightFrozenColCount && scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount) : (scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1), scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount)), scene.hasFrozen = true;
}
function moveColumnFromBodyToRowHeader(scene) {
  const column = scene.bodyGroup.firstChild instanceof Group2 ? scene.bodyGroup.firstChild : null;
  column && (scene.rowHeaderGroup.appendChild(column), scene.rowHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width + column.attribute.width), scene.bodyGroup.setAttribute("width", scene.bodyGroup.attribute.width - column.attribute.width));
}
function moveColumnFromColHeaderToCornerHeader(scene) {
  const headerColumn = scene.colHeaderGroup.firstChild instanceof Group2 ? scene.colHeaderGroup.firstChild : null;
  headerColumn && (scene.cornerHeaderGroup.appendChild(headerColumn), scene.cornerHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width + headerColumn.attribute.width), scene.colHeaderGroup.setAttribute("width", scene.colHeaderGroup.attribute.width - headerColumn.attribute.width));
}
function moveColumnFromRowHeaderToBody(scene) {
  var _a;
  const column = scene.rowHeaderGroup.lastChild instanceof Group2 ? scene.rowHeaderGroup.lastChild : null === (_a = scene.rowHeaderGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
  column && (insertBefore(scene.bodyGroup, column, scene.bodyGroup.firstChild), scene.bodyGroup.setAttribute("width", scene.bodyGroup.attribute.width + column.attribute.width), scene.rowHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width - column.attribute.width));
}
function moveColumnFromCornerHeaderToColHeader(scene) {
  var _a;
  const headerColumn = scene.cornerHeaderGroup.lastChild instanceof Group2 ? scene.cornerHeaderGroup.lastChild : null === (_a = scene.cornerHeaderGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
  headerColumn && (insertBefore(scene.colHeaderGroup, headerColumn, scene.colHeaderGroup.firstChild), scene.colHeaderGroup.setAttribute("width", scene.colHeaderGroup.attribute.width + headerColumn.attribute.width), scene.cornerHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width - headerColumn.attribute.width));
}
function moveColumnFromBottomToLeftBottomCorner(scene) {
  const column = scene.bottomFrozenGroup.firstChild instanceof Group2 ? scene.bottomFrozenGroup.firstChild : null;
  column && (scene.leftBottomCornerGroup.appendChild(column), scene.leftBottomCornerGroup.setAttribute("width", scene.leftBottomCornerGroup.attribute.width + column.attribute.width), scene.bottomFrozenGroup.setAttribute("width", scene.bottomFrozenGroup.attribute.width - column.attribute.width), scene.table.isPivotChart() && column.forEachChildren((child) => {
    child.setAttributes({
      stroke: false,
      fill: false
    });
  }));
}
function moveColumnFromLeftBottomCornerToBottom(scene) {
  var _a;
  const column = scene.leftBottomCornerGroup.lastChild instanceof Group2 ? scene.leftBottomCornerGroup.lastChild : null === (_a = scene.leftBottomCornerGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
  column && (insertBefore(scene.bottomFrozenGroup, column, scene.bottomFrozenGroup.firstChild), scene.bottomFrozenGroup.setAttribute("width", scene.bottomFrozenGroup.attribute.width + column.attribute.width), scene.leftBottomCornerGroup.setAttribute("width", scene.leftBottomCornerGroup.attribute.width - column.attribute.width), scene.table.isPivotChart() && column.forEachChildren((child) => {
    var _a2, _b, _c, _d;
    const cellStyle = scene.table._getCellStyle(child.col, child.row), range5 = scene.table.getCellRange(child.col, child.row), cellTheme = getStyleTheme(cellStyle, scene.table, range5 ? range5.start.col : child.col, range5 ? range5.start.row : child.row, getProp2).theme;
    child.setAttributes({
      fill: null !== (_b = null === (_a2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a2 ? void 0 : _a2.fill) && void 0 !== _b ? _b : void 0,
      stroke: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.stroke) && void 0 !== _d ? _d : void 0
    });
  }));
}
function dealRightFrozen(distRightFrozenCol, scene) {
  const { table, proxy, rightTopCornerGroup, rightFrozenGroup, rightBottomCornerGroup, bottomFrozenGroup, bodyGroup, colHeaderGroup } = scene, currentRightFrozenCol = scene.table.rightFrozenColCount;
  if (distRightFrozenCol > currentRightFrozenCol) {
    for (let col = table.colCount - currentRightFrozenCol - 1; col >= table.colCount - distRightFrozenCol; col--) {
      insertBefore(rightFrozenGroup, scene.getColGroup(col), rightFrozenGroup.firstChild);
      insertBefore(rightTopCornerGroup, scene.getColGroup(col, true), rightTopCornerGroup.firstChild);
      insertBefore(rightBottomCornerGroup, scene.getColGroupInBottom(col), rightBottomCornerGroup.firstChild);
    }
    let x = 0;
    rightFrozenGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    }), x = 0, rightTopCornerGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    }), x = 0, rightBottomCornerGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    });
  } else if (distRightFrozenCol < currentRightFrozenCol) {
    for (let col = table.colCount - currentRightFrozenCol; col < table.colCount - distRightFrozenCol; col++) {
      const colGroup = scene.getColGroup(col);
      colGroup.setAttribute("x", bodyGroup.lastChild.attribute.x + table.getColWidth(bodyGroup.lastChild.col)), bodyGroup.appendChild(colGroup);
      const headerColGroup = scene.getColGroupInRightTopCorner(col);
      headerColGroup.setAttribute("x", colHeaderGroup.lastChild.attribute.x + table.getColWidth(colHeaderGroup.lastChild.col)), colHeaderGroup.appendChild(headerColGroup);
      const bottomColGroup = scene.getColGroupInRightBottomCorner(col);
      bottomColGroup.setAttribute("x", bottomFrozenGroup.lastChild.attribute.x + table.getColWidth(bottomFrozenGroup.lastChild.col)), bottomFrozenGroup.appendChild(bottomColGroup);
    }
    let x = 0;
    rightFrozenGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    }), x = 0, rightTopCornerGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    }), x = 0, rightBottomCornerGroup.forEachChildren((columnGroup) => {
      columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
    });
  }
  rightFrozenGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), rightTopCornerGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), rightBottomCornerGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), table.internalProps.rightFrozenColCount = distRightFrozenCol, scene.updateContainer(), scene.component.updateScrollBar(), scene.updateNextFrame();
}
function dealBottomFrozen(distBottomFrozenRow, scene) {
  const { table, proxy, bottomFrozenGroup, leftBottomCornerGroup, rightBottomCornerGroup } = scene;
  bottomFrozenGroup.childrenCount || (proxy.table.isPivotChart() || (createColGroup(leftBottomCornerGroup, 0, 0, 0, table.frozenColCount - 1, 0, -1, "rowHeader", table), createColGroup(rightBottomCornerGroup, 0, 0, table.colCount - table.rightFrozenColCount, table.colCount - 1, 0, -1, "body", table)), createColGroup(bottomFrozenGroup, 0, 0, proxy.colStart, proxy.colEnd, 0, -1, "body", table));
  const currentBottomFrozenRow = scene.table.bottomFrozenRowCount;
  if (distBottomFrozenRow > currentBottomFrozenRow) {
    for (let col = 0; col < table.frozenColCount; col++) {
      const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
      for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
        insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, true), bottomFrozenColumnGroup.firstChild);
      }
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
    for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
      const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
      for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
        insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, true), bottomFrozenColumnGroup.firstChild);
      }
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
    if (table.rightFrozenColCount > 0) for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
      const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
      for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
        insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, true), bottomFrozenColumnGroup.firstChild);
      }
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
  } else if (distBottomFrozenRow < currentBottomFrozenRow) {
    for (let col = 0; col < table.rowHeaderLevelCount; col++) {
      const columnGroup = scene.getColGroup(col);
      for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
        const cellGroup = scene.getCell(col, row, true);
        cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), columnGroup.appendChild(cellGroup);
      }
      const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
    for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
      const columnGroup = scene.getColGroup(col);
      for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
        const cellGroup = scene.getCell(col, row, true);
        cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), columnGroup.appendChild(cellGroup);
      }
      const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
    if (table.rightFrozenColCount > 0) for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
      const columnGroup = scene.getColGroup(col);
      for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
        const cellGroup = scene.getCell(col, row, true);
        cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), columnGroup.appendChild(cellGroup);
      }
      const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
      let y = 0;
      bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
        cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
      });
    }
  }
  bottomFrozenGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), leftBottomCornerGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), rightBottomCornerGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), table.internalProps.bottomFrozenRowCount = distBottomFrozenRow, scene.updateContainer(), scene.component.updateScrollBar(), scene.updateNextFrame();
}
function insertBefore(container2, newNode, targetGroup) {
  newNode && container2 && (targetGroup ? container2.insertBefore(newNode, targetGroup) : container2.appendChild(newNode));
}
function resetRowFrozen(scene) {
  var _a, _b, _c, _d, _e;
  if (scene.frozenRowCount > scene.table.frozenRowCount) {
    scene.bodyGroup.setAttribute("width", scene.colHeaderGroup.attribute.width), scene.bodyGroup.setAttribute("x", scene.colHeaderGroup.attribute.x), scene.rowHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width);
    for (let i = 0; i < scene.frozenRowCount - scene.table.frozenRowCount; i++) moveRowFromColHeaderToBody(scene), moveRowFromCornerHeaderToRowHeader(scene), moveRowFromTopRightCornerToRight(scene);
  } else if (scene.frozenRowCount < scene.table.frozenRowCount) {
    scene.colHeaderGroup.setAttribute("width", scene.bodyGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.bodyGroup.attribute.x), scene.cornerHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width);
    for (let i = 0; i < scene.table.frozenRowCount - scene.frozenRowCount; i++) moveRowFromBodyToColHeader(scene), moveRowFromRowHeaderToCornerHeader(scene), moveRowFromRightToTopRightCorner(scene);
  }
  updateReactComponentContainer(scene), scene.recreateAllSelectRangeComponents(), scene.frozenRowCount = scene.table.frozenRowCount, scene.frozenColCount = null !== (_b = null === (_a = scene.rowHeaderGroup) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : 0, scene.proxy.rowStart = null !== (_e = null === (_d = null === (_c = scene.bodyGroup.firstChild) || void 0 === _c ? void 0 : _c.firstChild) || void 0 === _d ? void 0 : _d.row) && void 0 !== _e ? _e : scene.table.frozenRowCount, scene.bodyGroup.setAttribute("y", scene.colHeaderGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.cornerHeaderGroup.attribute.height), scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.hasFrozen = true;
}
function moveRowFromBodyToColHeader(scene) {
  var _a;
  let hasSetedHeight = false;
  for (let i = 0; i < scene.bodyGroup.childrenCount; i++) {
    const child = scene.bodyGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const rowCell = child.firstChild;
    null === (_a = scene.colHeaderGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), hasSetedHeight || (scene.colHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height + rowCell.attribute.height), scene.bodyGroup.setAttribute("height", scene.bodyGroup.attribute.height - rowCell.attribute.height), hasSetedHeight = true);
  }
}
function moveRowFromRowHeaderToCornerHeader(scene) {
  var _a;
  let hasSetedHeight = false;
  for (let i = 0; i < scene.rowHeaderGroup.childrenCount; i++) {
    const child = scene.rowHeaderGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const rowCell = child.firstChild;
    null === (_a = scene.cornerHeaderGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), hasSetedHeight || (scene.cornerHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height + rowCell.attribute.height), scene.rowHeaderGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height - rowCell.attribute.height), hasSetedHeight = true);
  }
}
function moveRowFromRightToTopRightCorner(scene) {
  var _a;
  let hasSetedHeight = false;
  for (let i = 0; i < scene.rightFrozenGroup.childrenCount; i++) {
    const child = scene.rightFrozenGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const rowCell = child.firstChild;
    null === (_a = scene.rightTopCornerGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), hasSetedHeight || (scene.rightTopCornerGroup.setAttribute("height", scene.rightTopCornerGroup.attribute.height + rowCell.attribute.height), scene.rightFrozenGroup.setAttribute("height", scene.rightFrozenGroup.attribute.height - rowCell.attribute.height), hasSetedHeight = true);
  }
}
function moveRowFromColHeaderToBody(scene) {
  let hasSetedHeight = false;
  for (let i = 0; i < scene.colHeaderGroup.childrenCount; i++) {
    const child = scene.colHeaderGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const target = scene.bodyGroup.children[i];
    if (!target) continue;
    const rowCell = child.lastChild;
    insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.colHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height - rowCell.attribute.height), scene.bodyGroup.setAttribute("height", scene.bodyGroup.attribute.height + rowCell.attribute.height), hasSetedHeight = true);
  }
}
function moveRowFromCornerHeaderToRowHeader(scene) {
  let hasSetedHeight = false;
  for (let i = 0; i < scene.cornerHeaderGroup.childrenCount; i++) {
    const child = scene.cornerHeaderGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const target = scene.rowHeaderGroup.children[i];
    if (!target) continue;
    const rowCell = child.lastChild;
    insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.cornerHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height - rowCell.attribute.height), scene.rowHeaderGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height + rowCell.attribute.height), hasSetedHeight = true);
  }
}
function moveRowFromTopRightCornerToRight(scene) {
  let hasSetedHeight = false;
  for (let i = 0; i < scene.rightTopCornerGroup.childrenCount; i++) {
    const child = scene.rightTopCornerGroup.children[i];
    if (!checkBeforeMove(child)) continue;
    const target = scene.rightFrozenGroup.children[i];
    if (!target) continue;
    const rowCell = child.lastChild;
    insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.rightTopCornerGroup.setAttribute("height", scene.rightTopCornerGroup.attribute.height - rowCell.attribute.height), scene.rightFrozenGroup.setAttribute("height", scene.rightFrozenGroup.attribute.height + rowCell.attribute.height), hasSetedHeight = true);
  }
}
function checkBeforeMove(child) {
  return child instanceof Group2 && "table-border-rect" !== (null == child ? void 0 : child.name);
}

// node_modules/@visactor/vtable/es/scenegraph/refresh-node/update-chart.js
function updateChartSizeForResizeColWidth(scenegraph, col) {
  const { table } = scenegraph, layout = table.internalProps.layoutMap, columnResizeType = -1 === col ? "all" : table.internalProps.columnResizeType;
  if ("column" === columnResizeType) {
    const columnGroup = scenegraph.getColGroup(col), columnHeaderGroup = scenegraph.getColGroup(col, true), columnBottomGroup = scenegraph.getColGroupInBottom(col, true);
    if (null == columnGroup || columnGroup.forEachChildren((cellNode) => {
      updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
    }), null == columnHeaderGroup || columnHeaderGroup.forEachChildren((cellNode) => {
      updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
    }), null == columnBottomGroup || columnBottomGroup.forEachChildren((cellNode) => {
      updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
    }), "adaptive" === table.widthMode && col < table.colCount - 1) {
      const columnGroup2 = scenegraph.getColGroup(col + 1), columnHeaderGroup2 = scenegraph.getColGroup(col + 1, true), columnBottomGroup2 = scenegraph.getColGroupInBottom(col + 1, true);
      null == columnGroup2 || columnGroup2.forEachChildren((cellNode) => {
        updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
      }), null == columnHeaderGroup2 || columnHeaderGroup2.forEachChildren((cellNode) => {
        updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
      }), null == columnBottomGroup2 || columnBottomGroup2.forEachChildren((cellNode) => {
        updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
      });
    }
  } else {
    let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue, startCol = table.rowHeaderLevelCount, endCol = table.colCount - 1;
    if ("indicator" === columnResizeType) if (layout.indicatorsAsCol) resizeIndicatorKey = layout.getIndicatorKey(col, table.columnHeaderLevelCount);
    else {
      const headerPaths = layout.getCellHeaderPaths(col, table.columnHeaderLevelCount - 1), headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
      resizeDimensionKey = headerPath.dimensionKey, resizeDimensionValue = headerPath.value;
    }
    else if ("indicatorGroup" === columnResizeType) {
      const layout2 = table.internalProps.layoutMap, headerPaths = layout2.getCellHeaderPaths(table.stateManager.columnResize.col, table.columnHeaderLevelCount), node = layout2.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1));
      startCol = node.startInTotal + table.frozenColCount, endCol = node.startInTotal + table.frozenColCount + node.size - 1;
    }
    for (let c2 = startCol; c2 <= endCol; c2++) {
      const columnGroup = scenegraph.getColGroup(c2), columnHeaderGroup = scenegraph.getColGroup(c2, true), columnBottomGroup = scenegraph.getColGroupInBottom(c2, true);
      if (columnGroup) {
        if ("indicator" === columnResizeType) {
          const indicatorKey = layout.getIndicatorKey(c2, table.columnHeaderLevelCount);
          if (layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) continue;
          if (!layout.indicatorsAsCol) {
            const headerPaths = layout.getCellHeaderPaths(c2, table.columnHeaderLevelCount - 1), headerPath = null == headerPaths ? void 0 : headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
            if (!headerPath || resizeDimensionKey !== headerPath.dimensionKey || resizeDimensionValue !== headerPath.value) continue;
          }
        }
        columnGroup.forEachChildren((cellNode) => {
          updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        }), null == columnHeaderGroup || columnHeaderGroup.forEachChildren((cellNode) => {
          updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        }), null == columnBottomGroup || columnBottomGroup.forEachChildren((cellNode) => {
          updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        });
      }
    }
  }
}
function updateChartSizeForResizeRowHeight(scenegraph, row) {
  var _a;
  const { table } = scenegraph, layout = table.internalProps.layoutMap, state = table.stateManager, rowResizeType = -1 === row ? "all" : table.internalProps.rowResizeType;
  let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue, startRow = table.columnHeaderLevelCount, endRow = table.rowCount - 1;
  if ("indicator" === rowResizeType) if (layout.indicatorsAsCol) {
    const headerPaths = layout.getCellHeaderPaths(table.rowHeaderLevelCount - 1, row), headerPath = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a[headerPaths.rowHeaderPaths.length - 1];
    resizeDimensionKey = null == headerPath ? void 0 : headerPath.dimensionKey, resizeDimensionValue = null == headerPath ? void 0 : headerPath.value;
  } else resizeIndicatorKey = layout.getIndicatorKey(table.rowHeaderLevelCount, row);
  else if ("indicatorGroup" === rowResizeType) {
    const layout2 = table.internalProps.layoutMap, headerPaths = layout2.getCellHeaderPaths(table.rowHeaderLevelCount, row), node = layout2.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1));
    startRow = node.startInTotal + table.frozenRowCount, endRow = node.startInTotal + table.frozenRowCount + node.size - 1;
  }
  const colsRange = [{
    startCol: scenegraph.proxy.colStart,
    endCol: scenegraph.proxy.colEnd
  }];
  table.frozenColCount && colsRange.push({
    startCol: 0,
    endCol: table.frozenColCount - 1
  }), table.rightFrozenColCount && colsRange.push({
    startCol: table.colCount - table.rightFrozenColCount,
    endCol: table.colCount - 1
  }), colsRange.forEach(({ startCol, endCol }) => {
    for (let col = startCol; col <= endCol; col++) if ("row" === rowResizeType) {
      const cellNode = scenegraph.highPerformanceGetCell(col, row);
      if ("cell" !== cellNode.role) continue;
      if (updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row)), "adaptive" === table.heightMode && row < table.rowCount - 1) {
        const cellNode2 = scenegraph.highPerformanceGetCell(col, row + 1);
        updateChartGraphicSize(cellNode2, table.getColWidth(cellNode2.col), table.getRowHeight(cellNode2.row));
      }
    } else for (let r = startRow; r <= endRow; r++) {
      if ("indicator" === rowResizeType) {
        const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, r);
        if (!layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) continue;
        if (layout.indicatorsAsCol) {
          const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, r), headerPath = null == headerPaths ? void 0 : headerPaths.rowHeaderPaths[headerPaths.rowHeaderPaths.length - 1];
          if (!headerPath || resizeDimensionKey !== headerPath.dimensionKey || resizeDimensionValue !== headerPath.value) continue;
        }
      }
      const cellNode = scenegraph.highPerformanceGetCell(col, r);
      if ("cell" !== cellNode.role) continue;
      updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
    }
  });
}
function clearChartCacheImage(scenegraph) {
  var _a;
  for (let c2 = scenegraph.proxy.colStart; c2 <= scenegraph.proxy.colEnd; c2++) {
    const columnGroup = scenegraph.getColGroup(c2);
    null === (_a = null == columnGroup ? void 0 : columnGroup.getChildren()) || void 0 === _a || _a.forEach((cellNode) => {
      cellNode.children.forEach((node) => {
        "chart" === node.type && (node.cacheCanvas = null, node.addUpdateBoundTag());
      });
    });
  }
}
function clearCellChartCacheImage(col, row, scenegraph) {
  scenegraph.getCell(col, row).children.forEach((node) => {
    "chart" === node.type && (node.cacheCanvas = null, node.addUpdateBoundTag());
  });
}
function updateChartData(scenegraph) {
  var _a;
  const table = scenegraph.table;
  for (let c2 = scenegraph.proxy.colStart; c2 <= scenegraph.proxy.colEnd; c2++) {
    const columnGroup = scenegraph.getColGroup(c2);
    null === (_a = null == columnGroup ? void 0 : columnGroup.getChildren()) || void 0 === _a || _a.forEach((cellNode) => {
      const col = cellNode.col, row = cellNode.row;
      cellNode.children.forEach((node) => {
        if ("chart" === node.type) {
          node.updateData(table.getCellValue(col, row));
          const chartSpec = node.attribute.spec, chartType = chartSpec.type;
          if ("gauge" !== chartType && "rose" !== chartType && "radar" !== chartType) {
            const newAxes = table.internalProps.layoutMap.getChartAxes(col, row);
            node.setAttribute("axes", newAxes), chartSpec.axes = newAxes;
          }
          node.setAttribute("spec", chartSpec);
        }
      });
    });
  }
  updateTableAxes(scenegraph.rowHeaderGroup, scenegraph.table), updateTableAxes(scenegraph.colHeaderGroup, scenegraph.table), updateTableAxes(scenegraph.rightFrozenGroup, scenegraph.table), updateTableAxes(scenegraph.bottomFrozenGroup, scenegraph.table);
}
function updateChartState(scenegraph, datum) {
  const table = scenegraph.table;
  if (table.isPivotChart()) {
    const preSelectItemsCount = table._selectedDataItemsInChart.length;
    if ((null === datum || 0 === (null == datum ? void 0 : datum.length) || 0 === Object.keys(datum).length) && 0 === preSelectItemsCount) return;
    const newSelectedDataItemsInChart = [];
    if (Array.isArray(datum)) datum.forEach((dataItem) => {
      if (dataItem && 0 !== dataItem.key && Object.keys(dataItem).length > 0) {
        const selectedState = {};
        for (const itemKey in dataItem) itemKey.startsWith("VGRAMMAR_") || itemKey.startsWith("__VCHART") || (selectedState[itemKey] = dataItem[itemKey]);
        newSelectedDataItemsInChart.push(selectedState);
      }
    });
    else if (datum && 0 !== datum.key && Object.keys(datum).length > 0) {
      const selectedState = {};
      for (const itemKey in datum) itemKey.startsWith("VGRAMMAR_") || itemKey.startsWith("__VCHART") || (selectedState[itemKey] = datum[itemKey]);
      newSelectedDataItemsInChart.push(selectedState);
    }
    isEqual(table._selectedDataItemsInChart, newSelectedDataItemsInChart) || (table._selectedDataItemsInChart = newSelectedDataItemsInChart, table.internalProps.layoutMap.updateDataStateToChartInstance(), clearChartCacheImage(scenegraph), table.scenegraph.updateNextFrame());
  }
}
function updateTableAxes(containerGroup, table) {
  containerGroup.forEachChildren((column) => {
    "column" === column.role && column.forEachChildren((cell) => {
      var _a;
      if ("cell" === cell.role) {
        let isAxisComponent = false;
        if (cell.forEachChildren((mark) => "axis" === mark.name && (isAxisComponent = true, true)), isAxisComponent) {
          const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(cell.col, cell.row), cellStyle = table._getCellStyle(cell.col, cell.row), padding = getQuadProps(getProp2("padding", cellStyle, cell.col, cell.row, table)), axis = new (Factory2.getComponent("axis"))(axisConfig, cell.attribute.width, cell.attribute.height, null !== (_a = axisConfig.__vtablePadding) && void 0 !== _a ? _a : padding, table);
          cell.clear(), cell.appendChild(axis.component), axis.overlap();
        }
      }
    });
  });
}
function updateChartGraphicSize(cellNode, width, height) {
  cellNode.forEachChildren((graphic) => {
    "chart" === graphic.type && (graphic.cacheCanvas = null, graphic.setAttributes({
      width: Math.ceil(width - graphic.attribute.cellPadding[3] - graphic.attribute.cellPadding[1]),
      height: Math.ceil(height - graphic.attribute.cellPadding[0] - graphic.attribute.cellPadding[2])
    }));
  });
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/init-scenegraph.js
function initSceneGraph(scene) {
  const width = scene.table.tableNoFrameWidth, height = scene.table.tableNoFrameHeight;
  scene.tableGroup = new Group2({
    x: 0,
    y: 0,
    width,
    height,
    clip: true,
    pickable: false
  }), scene.tableGroup.role = "table";
  const colHeaderGroup = createContainerGroup(0, 0, !scene.table.options.enableTreeStickCell);
  colHeaderGroup.role = "col-header", scene.colHeaderGroup = colHeaderGroup;
  const cornerHeaderGroup = createContainerGroup(0, 0, !scene.table.options.enableTreeStickCell);
  cornerHeaderGroup.role = "corner-header", scene.cornerHeaderGroup = cornerHeaderGroup;
  const rowHeaderGroup = createContainerGroup(0, 0, true);
  rowHeaderGroup.role = "row-header", scene.rowHeaderGroup = rowHeaderGroup;
  const bodyGroup = createContainerGroup(width, 0, true);
  bodyGroup.role = "body", scene.bodyGroup = bodyGroup;
  const rightFrozenGroup = createContainerGroup(0, 0, true);
  rightFrozenGroup.role = "right-frozen", scene.rightFrozenGroup = rightFrozenGroup;
  const bottomFrozenGroup = createContainerGroup(0, 0, true);
  bottomFrozenGroup.role = "bottom-frozen", scene.bottomFrozenGroup = bottomFrozenGroup;
  const componentGroup = createContainerGroup(0, 0);
  componentGroup.role = "component", scene.componentGroup = componentGroup;
  const rightTopCornerGroup = createContainerGroup(0, 0, true);
  rightTopCornerGroup.role = "corner-right-top-header", scene.rightTopCornerGroup = rightTopCornerGroup;
  const rightBottomCornerGroup = createContainerGroup(0, 0, true);
  rightBottomCornerGroup.role = "corner-right-bottom-header", scene.rightBottomCornerGroup = rightBottomCornerGroup;
  const leftBottomCornerGroup = createContainerGroup(0, 0, true);
  leftBottomCornerGroup.role = "corner-left-bottom-header", scene.leftBottomCornerGroup = leftBottomCornerGroup, scene.tableGroup.addChild(bodyGroup), scene.tableGroup.addChild(rowHeaderGroup), scene.tableGroup.addChild(bottomFrozenGroup), scene.tableGroup.addChild(colHeaderGroup), scene.tableGroup.addChild(rightFrozenGroup), scene.tableGroup.addChild(rightBottomCornerGroup), scene.tableGroup.addChild(rightTopCornerGroup), scene.tableGroup.addChild(leftBottomCornerGroup), scene.tableGroup.addChild(cornerHeaderGroup), scene.tableGroup.addChild(componentGroup);
}
function createContainerGroup(width, height, clip) {
  return new Group2({
    x: 0,
    y: 0,
    width,
    height,
    clip: null != clip && clip,
    pickable: false
  });
}

// node_modules/@visactor/vtable/es/scenegraph/utils/update-container.js
function updateContainerChildrenX(containerGroup, x) {
  return containerGroup.forEachChildrenSkipChild((column, index) => {
    column.setAttribute("x", x), x += column.attribute.width;
  }), x;
}

// node_modules/@visactor/vtable/es/scenegraph/icon/icon-update.js
function hideHoverIcon(col, row, scene) {
  -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon2) => "mouseenter_cell" === icon2.attribute.visibleTime, (icon2) => {
    icon2.setAttribute("opacity", 0);
    const iconBack = icon2.parent.getChildByName("icon-back");
    iconBack && iconBack.setAttribute("visible", false);
  }, scene), scene.updateNextFrame());
}
function showHoverIcon(col, row, scene) {
  -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon2) => "mouseenter_cell" === icon2.attribute.visibleTime, (icon2) => {
    icon2.setAttribute("opacity", 1);
  }, scene), scene.updateNextFrame());
}
function hideClickIcon(col, row, scene) {
  -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon2) => "click_cell" === icon2.attribute.visibleTime, (icon2) => {
    icon2.setAttribute("opacity", 0);
  }, scene), scene.updateNextFrame());
}
function showClickIcon(col, row, scene) {
  -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon2) => "click_cell" === icon2.attribute.visibleTime, (icon2) => {
    icon2.setAttribute("opacity", 1);
  }, scene), scene.updateNextFrame());
}
function getIconByXY(col, row, x, y, scene) {
  let pickMark;
  return scene.getCell(col, row).forEachChildren((mark) => {
    mark.role && mark.role.startsWith("icon") && mark.containsPoint(x, y, IContainPointMode.GLOBAL) && (pickMark = mark);
  }), pickMark;
}
function setIconHoverStyle(baseIcon, col, row, cellGroup, scene) {
  var _a, _b;
  if ((baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon2) => icon2.name === baseIcon.name, (icon2) => {
    var _a2, _b2, _c, _d, _e, _f, _g, _h;
    if (icon2.attribute.backgroundColor) {
      let iconBack = icon2.parent.getChildByName("icon-back");
      iconBack ? iconBack.setAttributes({
        x: (null !== (_a2 = icon2.attribute.x) && void 0 !== _a2 ? _a2 : 0) + (icon2.AABBBounds.width() - icon2.backgroundWidth) / 2,
        y: (null !== (_b2 = icon2.attribute.y) && void 0 !== _b2 ? _b2 : 0) + (icon2.AABBBounds.height() - icon2.backgroundHeight) / 2,
        dx: null !== (_c = icon2.attribute.dx) && void 0 !== _c ? _c : 0,
        dy: null !== (_d = icon2.attribute.dy) && void 0 !== _d ? _d : 0,
        width: icon2.backgroundWidth,
        height: icon2.backgroundHeight,
        fill: icon2.attribute.backgroundColor,
        cornerRadius: 5,
        visible: true
      }) : (iconBack = createRect({
        x: (null !== (_e = icon2.attribute.x) && void 0 !== _e ? _e : 0) + (icon2.AABBBounds.width() - icon2.backgroundWidth) / 2,
        y: (null !== (_f = icon2.attribute.y) && void 0 !== _f ? _f : 0) + (icon2.AABBBounds.height() - icon2.backgroundHeight) / 2,
        dx: null !== (_g = icon2.attribute.dx) && void 0 !== _g ? _g : 0,
        dy: null !== (_h = icon2.attribute.dy) && void 0 !== _h ? _h : 0,
        width: icon2.backgroundWidth,
        height: icon2.backgroundHeight,
        fill: icon2.attribute.backgroundColor,
        cornerRadius: 5,
        pickable: false,
        visible: true
      }), iconBack.name = "icon-back"), icon2.parent.insertBefore(iconBack, icon2);
    }
    icon2.attribute.hoverImage && icon2.attribute.image !== icon2.attribute.hoverImage && (icon2.image = icon2.attribute.hoverImage);
  }, scene), baseIcon.tooltip) {
    const { x1: left, x2: right, y1: top, y2: bottom } = baseIcon.globalAABBBounds, tooltipOptions = {
      content: baseIcon.tooltip.title,
      referencePosition: {
        rect: {
          left,
          right,
          top,
          bottom,
          width: baseIcon.globalAABBBounds.width(),
          height: baseIcon.globalAABBBounds.height()
        },
        placement: baseIcon.tooltip.placement
      },
      disappearDelay: baseIcon.tooltip.disappearDelay,
      style: Object.assign({}, null === (_a = scene.table.internalProps.theme) || void 0 === _a ? void 0 : _a.tooltipStyle, null === (_b = baseIcon.tooltip) || void 0 === _b ? void 0 : _b.style)
    };
    scene.table.internalProps.tooltipHandler.isBinded(tooltipOptions) || scene.table.showTooltip(col, row, tooltipOptions);
  }
}
function setIconNormalStyle(baseIcon, col, row, scene) {
  (baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon2) => icon2.name === baseIcon.name, (icon2) => {
    const iconBack = icon2.parent.getChildByName("icon-back");
    iconBack && iconBack.setAttribute("visible", false), icon2.attribute.hoverImage && icon2.attribute.image !== icon2.attribute.originImage && (icon2.image = icon2.attribute.originImage);
  }, scene);
}
function updateIcon(baseIcon, iconConfig, col, row, scene) {
  const iconName = baseIcon.name;
  updateCellRangeIcon(col, row, (icon2) => icon2.name === iconName, (icon2) => {
    dealWithIcon(iconConfig, icon2), icon2.name = iconConfig.name;
  }, scene), scene.updateNextFrame();
}
function resetSortIcon(oldSortCol, oldSortRow, iconConfig, scene) {
  const oldSortCell = scene.getCell(oldSortCol, oldSortRow);
  if (isValid_default(oldSortCell.mergeStartCol) && isValid_default(oldSortCell.mergeStartRow) && isValid_default(oldSortCell.mergeEndCol) && isValid_default(oldSortCell.mergeEndRow)) for (let col = oldSortCell.mergeStartCol; col <= oldSortCell.mergeEndCol; col++) for (let row = oldSortCell.mergeStartRow; row <= oldSortCell.mergeEndRow; row++) {
    let oldIconMark;
    scene.getCell(col, row).forEachChildren((mark) => "sort" === mark.attribute.funcType && (oldIconMark = mark, true)), oldIconMark && (dealWithIcon(iconConfig, oldIconMark), oldIconMark.name = iconConfig.name);
  }
  else {
    let oldIconMark;
    traverseObject(oldSortCell, "children", (mark) => "sort" === mark.attribute.funcType && (oldIconMark = mark, true)), oldIconMark && (dealWithIcon(iconConfig, oldIconMark), oldIconMark.name = iconConfig.name);
  }
}
function checkSameCell(col1, row1, col2, row2, table) {
  const range1 = table.getCellRange(col1, row1), range22 = table.getCellRange(col2, row2);
  return range1.start.col === range22.start.col && range1.start.row === range22.start.row && range1.end.col === range22.end.col && range1.end.row === range22.end.row;
}
function updateSortIcon(options) {
  const { col, row, iconMark, order, oldSortCol, oldSortRow, oldIconMark, scene } = options, icon2 = scene.table.internalProps.headerHelper.getSortIcon(order, scene.table, col, row);
  if (iconMark && updateIcon(iconMark, icon2, col, row, scene), !checkSameCell(col, row, oldSortCol, oldSortRow, scene.table)) {
    const oldIcon = scene.table.internalProps.headerHelper.getSortIcon("normal", scene.table, oldSortCol, oldSortRow);
    oldIconMark ? updateIcon(oldIconMark, oldIcon, oldSortCol, oldSortRow, scene) : resetSortIcon(oldSortCol, oldSortRow, oldIcon, scene);
  }
}
function updateFrozenIcon(scene) {
  for (let col = 0; col < scene.table.colCount; col++) for (let row = 0; row < scene.table.columnHeaderLevelCount; row++) updateCellRangeIcon(col, row, (icon2) => "frozen" === icon2.attribute.funcType, (icon2) => {
    const iconConfig = scene.table.internalProps.headerHelper.getFrozenIcon(col, row);
    dealWithIcon(iconConfig, icon2), icon2.name = iconConfig.name;
  }, scene);
}
function updateHierarchyIcon(col, row, scene) {
  let iconConfig;
  iconConfig = scene.table.isHeader(col, row) ? scene.table.internalProps.headerHelper.getHierarchyIcon(col, row) : scene.table.internalProps.bodyHelper.getHierarchyIcon(col, row), updateCellRangeIcon(col, row, (icon2) => icon2.attribute.funcType === IconFuncTypeEnum.collapse || icon2.attribute.funcType === IconFuncTypeEnum.expand, (icon2) => {
    dealWithIcon(iconConfig, icon2), icon2.name = iconConfig.name;
  }, scene);
}
function updateCellGroupIcon(cellGroup, filter2, dealer) {
  cellGroup && "empty" !== cellGroup.role && cellGroup.forEachChildren((child) => {
    "group" === child.type ? updateCellGroupIcon(child, filter2, dealer) : filter2(child) && dealer(child);
  });
}
function updateCellRangeIcon(col, row, filter2, dealer, scene) {
  const cellGroup = scene.getCell(col, row);
  if ("cell" === cellGroup.role && isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, scene);
    for (let col2 = colStart; col2 <= colEnd; col2++) for (let row2 = rowStart; row2 <= rowEnd; row2++) updateCellGroupIcon(scene.highPerformanceGetCell(col2, row2), filter2, dealer);
  } else updateCellGroupIcon(cellGroup, filter2, dealer);
}
function residentHoverIcon(col, row, scene) {
  updateCellRangeIcon(col, row, (icon2) => icon2.attribute.funcType === IconFuncTypeEnum.dropDown, (icon2) => {
    icon2.oldVisibleTime = icon2.attribute.visibleTime, icon2.setAttribute("visibleTime", "always"), icon2.setAttribute("opacity", 1);
  }, scene);
}
function resetResidentHoverIcon(col, row, scene) {
  updateCellRangeIcon(col, row, (icon2) => icon2.attribute.funcType === IconFuncTypeEnum.dropDown, (icon2) => {
    icon2.oldVisibleTime && icon2.setAttribute("visibleTime", icon2.oldVisibleTime), icon2.setAttribute("opacity", "always" === icon2.attribute.visibleTime ? 1 : 0);
  }, scene);
}

// node_modules/@visactor/vtable/es/scenegraph/style/corner-cell.js
function createCornerCell(cellGroup, frameTheme) {
  const { bgColor, borderColor, borderLineWidth, borderLineDash } = frameTheme, rectAttributes = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    visible: false,
    pickable: true,
    fill: bgColor
  };
  return rectAttributes.stroke = getStroke(borderColor, void 0), rectAttributes.lineWidth = borderLineWidth, borderLineDash && (rectAttributes.lineDash = borderLineDash), rectAttributes.lineCap = "butt", Array.isArray(borderColor) && (rectAttributes.strokeArrayColor = getQuadProps(borderColor)), Array.isArray(borderLineWidth) && (rectAttributes.strokeArrayWidth = getQuadProps(borderLineWidth), rectAttributes.lineWidth = 1), cellGroup.setAttributes(rectAttributes), cellGroup.role = "corner-frozen", cellGroup;
}

// node_modules/@visactor/vtable/es/scenegraph/layout/update-col.js
function updateCol(removeCells, addCells, updateCells, table) {
  var _a, _b;
  checkHaveTextStick(table) && resetTextStick(table);
  const scene = table.scenegraph, removeCols = deduplication2(removeCells.map((cell) => cell.col)).sort((a2, b) => b - a2), addCols = deduplication2(addCells.map((cell) => cell.col)).sort((a2, b) => a2 - b), updateCols = deduplication2(updateCells.map((cell) => cell.col)).sort((a2, b) => a2 - b);
  removeCols.forEach((col) => {
    removeCol(col, scene);
  });
  const colWidthsMap = table.colWidthsMap;
  let updateAfter;
  if (removeCols.forEach((col) => {
    colWidthsMap.delAndReorder(col);
  }), removeCols.length && resetColNumber(scene), scene.table._clearColRangeWidthsMap(), addCols.forEach((col) => {
    const needUpdateAfter = addCol(col, scene);
    resetColNumber(scene), updateAfter = null != updateAfter ? updateAfter : needUpdateAfter, colWidthsMap.addAndReorder(col);
  }), resetColNumberAndX(scene), updateCols.forEach((col) => {
    for (let row = 0; row < table.rowCount; row++) {
      const mergeInfo = getCellMergeInfo(scene.table, col, row);
      if (mergeInfo) for (let col2 = mergeInfo.start.col; col2 <= mergeInfo.end.col; col2++) for (let col3 = mergeInfo.start.col; col3 <= mergeInfo.end.col; col3++) updateCell(col3, row, scene.table, false);
      else updateCell(col, row, scene.table, false);
    }
  }), isNumber_default(updateAfter)) {
    for (let col = updateAfter; col < Math.max(table.colCount, null !== (_a = table.internalProps._oldColCount) && void 0 !== _a ? _a : table.colCount); col++) for (let row = 0; row < Math.max(table.rowCount, null !== (_b = table.internalProps._oldRowCount) && void 0 !== _b ? _b : table.rowCount); row++) {
      const cellGroup = scene.highPerformanceGetCell(col, row, true);
      cellGroup && (cellGroup.needUpdate = true);
    }
    scene.proxy.colUpdatePos = updateAfter;
  }
  if (addCols.length) {
    if (!isNumber_default(updateAfter)) {
      const minCol = Math.min(...addCols);
      scene.proxy.colUpdatePos = minCol;
    }
    scene.proxy.colUpdateDirection = "left", scene.proxy.updateColGroups(2 * scene.proxy.screenColCount), updateRightFrozeCellGroups(), scene.proxy.progress();
  } else removeCols.length && (scene.proxy.updateColGroups(2 * scene.proxy.screenColCount), updateRightFrozeCellGroups(), scene.proxy.progress());
  const newTotalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
  function updateRightFrozeCellGroups() {
    if ((null == addCols ? void 0 : addCols[(null == addCols ? void 0 : addCols.length) - 1]) >= table.colCount - table.rightFrozenColCount || (null == updateCols ? void 0 : updateCols[(null == updateCols ? void 0 : updateCols.length) - 1]) >= table.colCount - table.rightFrozenColCount || (null == removeCols ? void 0 : removeCols[0]) >= table.colCount - table.rightFrozenColCount) {
      for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) for (let row = 0; row < table.rowCount; row++) {
        const cellGroup = scene.highPerformanceGetCell(col, row, true);
        cellGroup && (cellGroup.needUpdate = true);
      }
      scene.proxy.updateRightFrozenCellGroups();
    }
  }
  scene.updateContainerWidth(scene.table.frozenColCount, newTotalWidth - scene.bodyGroup.attribute.width);
}
function removeCol(col, scene) {
  const proxy = scene.proxy;
  if (col >= scene.table.rowHeaderLevelCount) if (col >= scene.table.colCount - scene.table.rightFrozenColCount) ;
  else {
    const colGroup = scene.getColGroup(col, false);
    colGroup && colGroup.parent === scene.bodyGroup && scene.bodyGroup.removeChild(colGroup);
    const bottomColGroup = scene.getColGroupInBottom(col);
    bottomColGroup && bottomColGroup.parent === scene.bottomFrozenGroup && scene.bottomFrozenGroup.removeChild(bottomColGroup);
    const headerColGroup = scene.getColGroup(col, true);
    headerColGroup && headerColGroup.parent === scene.colHeaderGroup && scene.colHeaderGroup.removeChild(headerColGroup);
  }
  col >= proxy.colStart && col <= proxy.colEnd && (proxy.colEnd--, proxy.currentCol--), proxy.bodyRightCol--;
  const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
  proxy.totalActualBodyColCount = totalActualBodyColCount, proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1;
}
function addCol(col, scene) {
  const proxy = scene.proxy;
  proxy.bodyRightCol++;
  const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
  if (proxy.totalActualBodyColCount = totalActualBodyColCount, proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1, !(col < proxy.colStart)) return col > proxy.colEnd ? proxy.colEnd - proxy.colStart + 1 < proxy.colLimit ? (proxy.colEnd++, proxy.currentCol++, addColGroup(col, scene), col) : void 0 : proxy.colEnd - proxy.colStart + 1 < proxy.colLimit ? (proxy.colEnd++, proxy.currentCol++, addColGroup(col, scene), col) : col;
}
function deduplication2(array4) {
  const result2 = [];
  for (let i = 0; i < array4.length; i++) -1 === result2.indexOf(array4[i]) && result2.push(array4[i]);
  return result2;
}
function resetColNumber(scene) {
  let colIndex = scene.bodyColStart;
  function processCell(cellGroup) {
    cellGroup.col = colIndex;
    const merge5 = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
    merge5 && (cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeEndCol = merge5.end.col, cellGroup.mergeEndCol = merge5.end.col), cellGroup.role;
  }
  scene.bodyGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colIndex++;
  }), colIndex = scene.bodyColStart, scene.colHeaderGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colIndex++;
  }), colIndex = scene.bodyColStart, scene.bottomFrozenGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colIndex++;
  });
}
function resetColNumberAndX(scene) {
  let colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex);
  function processCell(cellGroup) {
    cellGroup.col = colIndex;
    const merge5 = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
    merge5 && (cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeStartCol = merge5.start.col, cellGroup.mergeEndCol = merge5.end.col, cellGroup.mergeEndCol = merge5.end.col), cellGroup.role;
  }
  scene.bodyGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  }), colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex), scene.colHeaderGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  }), colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex), scene.bottomFrozenGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  }), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightFrozenGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  }), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightTopCornerGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  }), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
    colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup) => {
      processCell(cellGroup);
    }), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
  });
}
function addColGroup(col, scene) {
  if (scene.colHeaderGroup && scene.table.columnHeaderLevelCount > 0) {
    const columnGroup = new Group2({
      x: 0,
      y: 0,
      width: scene.table.getColWidth(col),
      height: 0,
      clip: false,
      pickable: false
    });
    columnGroup.role = "column", columnGroup.col = col;
    const colAfter = scene.getColGroup(col, true);
    colAfter ? scene.colHeaderGroup.insertBefore(columnGroup, colAfter) : scene.colHeaderGroup.appendChild(columnGroup), generateCellGroup(columnGroup, col, 0, scene.table.columnHeaderLevelCount - 1);
  }
  if (scene.bodyGroup) {
    const columnGroup = new Group2({
      x: 0,
      y: 0,
      width: scene.table.getColWidth(col),
      height: 0,
      clip: false,
      pickable: false
    });
    columnGroup.role = "column", columnGroup.col = col;
    const colAfter = scene.getColGroup(col, false);
    colAfter ? scene.bodyGroup.insertBefore(columnGroup, colAfter) : scene.bodyGroup.appendChild(columnGroup), generateCellGroup(columnGroup, col, scene.bodyRowStart, scene.bodyRowEnd);
  }
  if (scene.bottomFrozenGroup && scene.table.bottomFrozenRowCount > 0) {
    const columnGroup = new Group2({
      x: 0,
      y: 0,
      width: scene.table.getColWidth(col),
      height: 0,
      clip: false,
      pickable: false
    });
    columnGroup.role = "column", columnGroup.col = col;
    const colAfter = scene.getColGroupInBottom(col);
    colAfter ? scene.bottomFrozenGroup.insertBefore(columnGroup, colAfter) : scene.bottomFrozenGroup.appendChild(columnGroup), generateCellGroup(columnGroup, col, scene.table.rowCount - scene.table.bottomFrozenRowCount, scene.table.rowCount - 1);
  }
  function generateCellGroup(group, col2, rowStart, rowEnd) {
    for (let row = rowStart; row <= rowEnd; row++) {
      const cellGroup = new Group2({
        x: 0,
        y: 0,
        width: scene.table.getColWidth(col2),
        height: scene.table.getRowHeight(row)
      });
      cellGroup.role = "cell", cellGroup.col = col2, cellGroup.row = row, cellGroup.needUpdate = true, group.appendChild(cellGroup);
    }
  }
}

// node_modules/@visactor/vtable/es/scenegraph/animation/appear.js
function dealWithAnimationAppear(table) {
  var _a, _b, _c, _d;
  if (!table.options.animationAppear) return;
  let duration, delay, type, direction;
  true === table.options.animationAppear ? (duration = 500, delay = 0, type = "one-by-one", direction = "column") : (duration = null !== (_a = table.options.animationAppear.duration) && void 0 !== _a ? _a : 500, delay = null !== (_b = table.options.animationAppear.delay) && void 0 !== _b ? _b : 0, type = null !== (_c = table.options.animationAppear.type) && void 0 !== _c ? _c : "one-by-one", direction = null !== (_d = table.options.animationAppear.direction) && void 0 !== _d ? _d : "row");
  const { scenegraph: scene, frozenColCount, frozenRowCount } = table, { colStart, colEnd, rowStart, rowEnd } = scene.proxy;
  for (let col = 0; col <= colEnd; col++) for (let row = 0; row <= rowEnd; row++) {
    const cellGroup = scene.highPerformanceGetCell(col, row);
    cellGroup && "cell" === cellGroup.role && cellGroup.forEachChildren((child) => {
      child.setAttribute("opacity", 0), child.animate().wait("one-by-one" === type ? ("row" === direction ? row : col) * (duration - delay) : delay).to({
        opacity: 1
      }, duration, "linear");
    });
  }
}

// node_modules/@visactor/vtable/es/scenegraph/select/update-select-style.js
function temporarilyUpdateSelectRectStyle(rectAttribute, scene) {
  const { selectedRangeComponents } = scene;
  selectedRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.setAttributes(rectAttribute);
  }), scene.updateNextFrame();
}

// node_modules/@visactor/vtable/es/scenegraph/scenegraph.js
registerForVrender(), container.load(contributions_default), container.load(text_measure_default);
var Scenegraph = class {
  constructor(table) {
    let width, height;
    this._needUpdateContainer = false, this.table = table, this.hasFrozen = false, this.clear = true, this.mergeMap = /* @__PURE__ */ new Map(), setPoptipTheme(this.table.theme.textPopTipStyle), "node" === Env.mode ? (vglobal.setEnv("node", table.options.modeParams), width = table.canvasWidth, height = table.canvasHeight) : table.options.canvas && table.options.viewBox ? (vglobal.setEnv("browser"), width = table.options.viewBox.x2 - table.options.viewBox.x1, height = table.options.viewBox.y2 - table.options.viewBox.y1) : (vglobal.setEnv("browser"), width = table.canvas.width, height = table.canvas.height), this.stage = createStage(Object.assign({
      canvas: table.canvas,
      width,
      height,
      disableDirtyBounds: false,
      background: table.theme.underlayBackgroundColor,
      dpr: table.internalProps.pixelRatio,
      enableLayout: true,
      beforeRender: (stage) => {
        this.table.options.beforeRender && this.table.options.beforeRender(stage), this.table.animationManager.ticker.start();
      },
      afterRender: (stage) => {
        this.table.options.afterRender && this.table.options.afterRender(stage), this.table.fireListeners("after_render", null);
      },
      canvasControled: !table.options.canvas,
      viewBox: table.options.viewBox
    }, table.options.renderOption)), this.stage.defaultLayer.setTheme({
      group: {
        boundsPadding: 0,
        strokeBoundsBuffer: 0,
        lineJoin: "round"
      },
      text: {
        ignoreBuf: true
      }
    }), this.initSceneGraph(), this.stage.defaultLayer.add(this.tableGroup), this.stage.table = this.table, this.createComponent();
  }
  get width() {
    var _a, _b;
    return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : 0;
  }
  get height() {
    var _a, _b;
    return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.height) && void 0 !== _b ? _b : 0;
  }
  get x() {
    var _a, _b;
    return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : 0;
  }
  get y() {
    var _a, _b;
    return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : 0;
  }
  get bodyRowStart() {
    var _a;
    return null !== (_a = this.proxy.rowStart) && void 0 !== _a ? _a : 0;
  }
  get bodyRowEnd() {
    var _a;
    return null !== (_a = this.proxy.rowEnd) && void 0 !== _a ? _a : this.table.rowCount - 1;
  }
  get bodyColStart() {
    var _a;
    return null !== (_a = this.proxy.colStart) && void 0 !== _a ? _a : 0;
  }
  get bodyColEnd() {
    var _a;
    return null !== (_a = this.proxy.colEnd) && void 0 !== _a ? _a : this.table.colCount - 1;
  }
  initSceneGraph() {
    this.isPivot = this.table.isPivotTable(), initSceneGraph(this);
  }
  clearCells() {
    var _a, _b;
    this.table.animationManager.clear(), (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) && this.stage.pluginService.findPluginsByName("poptipForText").forEach((plugin) => {
      plugin.deactivate(this.stage.pluginService);
    }), this.clear = true, this.hasFrozen = false, this.mergeMap.clear(), this.colHeaderGroup.clear(), delete this.colHeaderGroup.border, this.rowHeaderGroup.clear(), delete this.rowHeaderGroup.border, this.cornerHeaderGroup.clear(), delete this.cornerHeaderGroup.border, this.bodyGroup.clear(), delete this.bodyGroup.border, this.bottomFrozenGroup.clear(), delete this.bottomFrozenGroup.border, this.rightFrozenGroup.clear(), delete this.rightFrozenGroup.border, this.rightTopCornerGroup.clear(), delete this.rightTopCornerGroup.border, this.rightBottomCornerGroup.clear(), delete this.rightBottomCornerGroup.border, this.leftBottomCornerGroup.clear(), delete this.leftBottomCornerGroup.border, this.colHeaderGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.rowHeaderGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.cornerHeaderGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.bodyGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.rightFrozenGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.bottomFrozenGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }), this.rightTopCornerGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      visible: false
    }), this.leftBottomCornerGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      visible: false
    }), this.rightBottomCornerGroup.setAttributes({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      visible: false
    }), this.tableGroup.setAttributes({
      x: this.table.tableX,
      y: this.table.tableY,
      width: 0,
      height: 0
    }), this.tableGroup.border && (this.tableGroup.parent.removeChild(this.tableGroup.border), delete this.tableGroup.border), null === (_a = this.proxy) || void 0 === _a || _a.release(), null === (_b = this.table.reactCustomLayout) || void 0 === _b || _b.clearCache();
  }
  updateStageBackground() {
    this.stage.background = this.table.theme.underlayBackgroundColor, this.stage.renderNextFrame();
  }
  createComponent() {
    this.component = new TableComponent(this.table), this.component.addToGroup(this.componentGroup), this.selectedRangeComponents = /* @__PURE__ */ new Map(), this.selectingRangeComponents = /* @__PURE__ */ new Map(), this.customSelectedRangeComponents = /* @__PURE__ */ new Map();
  }
  updateComponent() {
    this.component.updateStyle();
  }
  createSceneGraph(skipRowHeightClear = false) {
    skipRowHeightClear || (this.table.rowHeightsMap.clear(), this.table.internalProps.layoutMap.clearCellRangeMap()), (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) && this.stage.pluginService.autoEnablePlugins.getContributions().forEach((p) => {
      "poptipForText" === p.name && this.stage.pluginService.register(p);
    }), this.clear = false, this.frozenColCount = this.table.frozenColCount, this.frozenRowCount = this.table.frozenRowCount, this.proxy = new SceneProxy(this.table), createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, void 0, true), this.table.isPivotChart() && (createCornerCell(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle || this.table.theme.cornerHeaderStyle || {}), createCornerCell(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle || this.table.theme.cornerHeaderStyle || {}), createCornerCell(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle || this.table.theme.cornerHeaderStyle || {})), this.proxy.createGroupForFirstScreen(this.cornerHeaderGroup, this.colHeaderGroup, this.rowHeaderGroup, this.rightFrozenGroup, this.bottomFrozenGroup, this.bodyGroup, 0, 0), this.afterScenegraphCreated();
  }
  renderSceneGraph() {
    this.stage.render();
  }
  getCell(col, row, getShadow) {
    var _a, _b, _c, _d, _e, _f;
    let cell;
    if (cell = this.table.rightFrozenColCount > 0 && col >= this.table.colCount - this.table.rightFrozenColCount && row < this.table.frozenRowCount ? null === (_a = this.rightTopCornerGroup.getColGroup(col)) || void 0 === _a ? void 0 : _a.getRowGroup(row) : this.table.bottomFrozenRowCount > 0 && row >= this.table.rowCount - this.table.bottomFrozenRowCount && col < this.table.frozenColCount ? null === (_b = this.leftBottomCornerGroup.getColGroup(col)) || void 0 === _b ? void 0 : _b.getRowGroup(row) : this.table.rightFrozenColCount > 0 && this.table.bottomFrozenRowCount > 0 && col >= this.table.colCount - this.table.rightFrozenColCount && row >= this.table.rowCount - this.table.bottomFrozenRowCount ? null === (_c = this.rightBottomCornerGroup.getColGroup(col)) || void 0 === _c ? void 0 : _c.getRowGroup(row) : this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? null === (_d = this.rightFrozenGroup.getColGroup(col)) || void 0 === _d ? void 0 : _d.getRowGroup(row) : this.table.bottomFrozenRowCount > 0 && row > this.table.rowCount - 1 - this.table.bottomFrozenRowCount ? null === (_e = this.bottomFrozenGroup.getColGroup(col)) || void 0 === _e ? void 0 : _e.getRowGroup(row) : null === (_f = this.getColGroup(col, row < this.frozenRowCount)) || void 0 === _f ? void 0 : _f.getRowGroup(row), cell && "shadow-cell" === cell.role && !getShadow) {
      const range5 = this.table.getCellRange(col, row);
      range5.start.col === col && range5.start.row === row || (cell = this.getCell(range5.start.col, range5.start.row));
    }
    return cell || emptyGroup;
  }
  highPerformanceGetCell(col, row, getShadow) {
    return this.proxy.highPerformanceGetCell(col, row, getShadow);
  }
  getColGroup(col, isCornerOrColHeader = false) {
    let element;
    return element = col < this.frozenColCount && isCornerOrColHeader ? this.cornerHeaderGroup.getColGroup(col) : col < this.frozenColCount ? this.rowHeaderGroup.getColGroup(col) : isCornerOrColHeader && this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? this.rightTopCornerGroup.getColGroup(col) : !isCornerOrColHeader && this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? this.rightFrozenGroup.getColGroup(col) : isCornerOrColHeader ? this.colHeaderGroup.getColGroup(col) : this.bodyGroup.getColGroup(col), element || void 0;
  }
  getColGroupInBottom(col, isCornerOrColHeader = false) {
    var _a;
    if (isCornerOrColHeader) {
      const element = null !== (_a = this.getColGroupInLeftBottomCorner(col)) && void 0 !== _a ? _a : this.getColGroupInRightBottomCorner(col);
      if (element) return element;
    }
    if (this.table.bottomFrozenRowCount > 0) return this.bottomFrozenGroup.getColGroup(col);
  }
  getColGroupInLeftBottomCorner(col) {
    if (this.table.bottomFrozenRowCount > 0) return this.leftBottomCornerGroup.getColGroup(col);
  }
  getColGroupInRightTopCorner(col) {
    if (this.table.rightFrozenColCount > 0) return this.rightTopCornerGroup.getColGroup(col);
  }
  getColGroupInRightBottomCorner(col) {
    if (this.table.rightFrozenColCount > 0 && this.table.bottomFrozenRowCount > 0) return this.rightBottomCornerGroup.getColGroup(col);
  }
  getCellSize(col, row) {
    const cell = this.getCell(col, row), mergeInfo = getCellMergeInfo(this.table, col, row);
    let width = cell.attribute.width, height = cell.attribute.height;
    return mergeInfo && (width /= mergeInfo.end.col - mergeInfo.start.col + 1, height /= mergeInfo.end.row - mergeInfo.start.row + 1), {
      width,
      height
    };
  }
  updateNextFrame() {
    this.updateContainerSync(), this.resetAllSelectComponent(), this.stage.renderNextFrame();
  }
  resetAllSelectComponent() {
    var _a, _b, _c, _d;
    ((null === (_b = null === (_a = this.table.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 || (null === (_d = null === (_c = this.table.stateManager.select) || void 0 === _c ? void 0 : _c.customSelectRanges) || void 0 === _d ? void 0 : _d.length) > 0) && updateAllSelectComponent(this);
  }
  hideHoverIcon(col, row) {
    hideHoverIcon(col, row, this);
  }
  showHoverIcon(col, row) {
    showHoverIcon(col, row, this);
  }
  hideClickIcon(col, row) {
    hideClickIcon(col, row, this);
  }
  showClickIcon(col, row) {
    showClickIcon(col, row, this);
  }
  getIcon(col, row, x, y) {
    return getIconByXY(col, row, x, y, this);
  }
  setIconHoverStyle(icon2, col, row, cellGroup) {
    setIconHoverStyle(icon2, col, row, cellGroup, this);
  }
  updateSortIcon(options) {
    const { col, row, iconMark, order, oldSortCol, oldSortRow, oldIconMark } = options;
    updateSortIcon({
      col,
      row,
      iconMark,
      order,
      oldSortCol,
      oldSortRow,
      oldIconMark,
      scene: this
    });
  }
  updateFrozenIcon(col, oldFrozenCol) {
    updateFrozenIcon(this);
  }
  updateHierarchyIcon(col, row) {
    updateHierarchyIcon(col, row, this);
  }
  setIconNormalStyle(icon2, col, row) {
    setIconNormalStyle(icon2, col, row, this);
  }
  residentHoverIcon(col, row) {
    residentHoverIcon(col, row, this);
  }
  resetResidentHoverIcon(col, row) {
    resetResidentHoverIcon(col, row, this);
  }
  deactivateChart(col, row) {
    var _a, _b;
    if (-1 === col || -1 === row) return;
    const cellGroup = this.getCell(col, row);
    null === (_b = null === (_a = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _a ? void 0 : _a.deactivate) || void 0 === _b || _b.call(_a);
  }
  activateChart(col, row) {
    var _a, _b, _c;
    if (-1 === col || -1 === row) return;
    const cellGroup = this.getCell(col, row);
    return null === (_b = null === (_a = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _a ? void 0 : _a.activate) || void 0 === _b || _b.call(_a, this.table), null === (_c = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _c ? void 0 : _c.activeChartInstance;
  }
  removeInteractionBorder(col, row) {
    const cellGroup = this.getCell(col, row);
    cellGroup.setAttribute("highlightStroke", void 0), cellGroup.setAttribute("highlightStrokeArrayWidth", void 0), cellGroup.setAttribute("highlightStrokeArrayColor", void 0);
  }
  createCellSelectBorder(start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
    createCellSelectBorder(this, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes);
  }
  moveSelectingRangeComponentsToSelectedRangeComponents() {
    moveSelectingRangeComponentsToSelectedRangeComponents(this);
  }
  deleteLastSelectedRangeComponents() {
    deleteLastSelectedRangeComponents(this);
  }
  deleteAllSelectBorder() {
    deleteAllSelectBorder(this), deleteAllSelectingBorder(this);
  }
  updateCellSelectBorder(selectRange, extendSelectRange = true) {
    updateCellSelectBorder(this, selectRange, extendSelectRange);
  }
  removeFillHandleFromSelectComponents() {
    removeFillHandleFromSelectComponents(this);
  }
  recreateAllSelectRangeComponents() {
    deleteAllSelectBorder(this), this.table.stateManager.select.ranges.forEach((cellRange) => {
      updateCellSelectBorder(this, cellRange), moveSelectingRangeComponentsToSelectedRangeComponents(this);
    });
  }
  updateColWidth(col, detaX, skipUpdateContainer, skipTableWidthMap) {
    updateColWidth(this, col, Math.round(detaX), skipTableWidthMap), skipUpdateContainer || this.updateContainer(true);
  }
  updateChartSizeForResizeColWidth(col) {
    updateChartSizeForResizeColWidth(this, col);
  }
  updateChartSizeForResizeRowHeight(row) {
    updateChartSizeForResizeRowHeight(this, row);
  }
  updateChartState(datum) {
    this.table.isPivotChart() && updateChartState(this, datum);
  }
  updateCheckboxCellState(col, row, checked) {
    var _a, _b;
    if (this.table.transpose) null === (_a = this.bodyGroup.children) || void 0 === _a || _a.forEach((columnGroup) => {
      var _a2;
      null === (_a2 = columnGroup.getChildAt(row)) || void 0 === _a2 || _a2.getChildren().forEach((node) => {
        "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", true), node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), node.setAttribute("checked", checked)));
      });
    });
    else {
      const columnGroup = this.getColGroup(col);
      null === (_b = null == columnGroup ? void 0 : columnGroup.children) || void 0 === _b || _b.forEach((cellNode) => {
        cellNode.getChildren().find((node) => {
          "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", true), node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), node.setAttribute("checked", checked)));
        });
      });
    }
  }
  updateHeaderCheckboxCellState(col, row, checked) {
    var _a, _b;
    if (this.table.transpose) null === (_a = this.rowHeaderGroup.children) || void 0 === _a || _a.forEach((columnGroup) => {
      columnGroup.getChildAt(row).getChildren().forEach((node) => {
        "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", true), node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), node.setAttribute("checked", checked)));
      });
    });
    else {
      null === (_b = this.getColGroup(col, true).children) || void 0 === _b || _b.forEach((cellNode) => {
        cellNode.getChildren().find((node) => {
          "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", true), node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), node.setAttribute("checked", checked)));
        });
      });
    }
  }
  updateAutoColWidth(col) {
    this.table.internalProps._widthResizedColMap.delete(col);
    const oldWidth = this.table.getColWidth(col), newWidth = computeColWidth(col, 0, this.table.rowCount - 1, this.table, true);
    newWidth !== oldWidth && this.updateColWidth(col, newWidth - oldWidth);
  }
  recalculateColWidths() {
    const table = this.table;
    "adaptive" === table.widthMode || table.autoFillWidth || table.internalProps.transpose ? computeColsWidth(this.table, 0, this.table.colCount - 1, true) : (table._clearColRangeWidthsMap(), table.frozenColCount > 0 && computeColsWidth(this.table, 0, table.frozenColCount - 1, true), table.rightFrozenColCount > 0 && computeColsWidth(this.table, table.rightFrozenColCount, table.colCount - 1, true), computeColsWidth(table, this.proxy.colStart, this.proxy.colEnd, true));
  }
  recalculateRowHeights() {
    const table = this.table;
    table.internalProps.useOneRowHeightFillAll = false, "adaptive" === table.heightMode || table.autoFillHeight ? computeRowsHeight(this.table, 0, this.table.rowCount - 1, true, true) : (table.frozenRowCount > 0 && computeRowsHeight(this.table, 0, table.frozenRowCount - 1, true, true), table.bottomFrozenRowCount > 0 && computeRowsHeight(this.table, table.bottomFrozenRowCount, table.rowCount - 1, true, true), computeRowsHeight(table, this.proxy.rowStart, this.proxy.rowEnd, true, true));
  }
  resize() {
    this.proxy.resize(), ("adaptive" === this.table.widthMode || this.table.autoFillWidth) && (0 === this.table.internalProps._widthResizedColMap.size ? this.recalculateColWidths() : this.dealWidthMode()), "adaptive" === this.table.heightMode ? 0 === this.table.internalProps._heightResizedRowMap.size ? this.recalculateRowHeights() : this.dealHeightMode() : this.table.autoFillHeight && this.dealHeightMode(), this.resetFrozen(), this.updateTableSize(), this.updateBorderSizeAndPosition(), this.component.updateScrollBar(), ("adaptive" === this.table.widthMode || "adaptive" === this.table.heightMode || this.table.autoFillWidth || this.table.autoFillHeight) && this.updateChartSizeForResizeColWidth(-1), this.proxy.progress(), this.updateNextFrame();
  }
  updateTableSize() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    if (this.tableGroup.setAttributes({
      x: this.table.tableX,
      y: this.table.tableY,
      width: Math.min(this.table.tableNoFrameWidth, Math.max(this.colHeaderGroup.attribute.width, this.bodyGroup.attribute.width, this.bottomFrozenGroup.attribute.width, 0) + Math.max(this.cornerHeaderGroup.attribute.width, this.rowHeaderGroup.attribute.width, this.leftBottomCornerGroup.attribute.width, 0) + Math.max(this.rightTopCornerGroup.attribute.width, this.rightFrozenGroup.attribute.width, this.rightBottomCornerGroup.attribute.width, 0)),
      height: Math.min(this.table.tableNoFrameHeight, Math.max(this.colHeaderGroup.attribute.height, this.cornerHeaderGroup.attribute.height, this.rightTopCornerGroup.attribute.height, 0) + Math.max(this.rowHeaderGroup.attribute.height, this.bodyGroup.attribute.height, this.rightFrozenGroup.attribute.height, 0) + Math.max(this.leftBottomCornerGroup.attribute.height, this.bottomFrozenGroup.attribute.height, this.rightBottomCornerGroup.attribute.height, 0))
    }), this.tableGroup.border) {
      const rectAttributes = null === (_a = this.tableGroup.border) || void 0 === _a ? void 0 : _a.attribute;
      let borderTop, borderRight, borderBottom, borderLeft;
      (null == rectAttributes ? void 0 : rectAttributes.strokeArrayWidth) ? (borderTop = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[0] : null !== (_b = rectAttributes.lineWidth) && void 0 !== _b ? _b : 0, borderRight = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[1] : null !== (_c = rectAttributes.lineWidth) && void 0 !== _c ? _c : 0, borderBottom = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[2] : null !== (_d = rectAttributes.lineWidth) && void 0 !== _d ? _d : 0, borderLeft = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[3] : null !== (_e = rectAttributes.lineWidth) && void 0 !== _e ? _e : 0) : (borderTop = null !== (_f = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _f ? _f : 0, borderRight = null !== (_g = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _g ? _g : 0, borderBottom = null !== (_h = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _h ? _h : 0, borderLeft = null !== (_j = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _j ? _j : 0), "rect" === this.tableGroup.border.type ? (null === (_k = this.table.theme.frameStyle) || void 0 === _k ? void 0 : _k.innerBorder) ? this.tableGroup.border.setAttributes({
        x: this.table.tableX + borderLeft / 2,
        y: this.table.tableY + borderTop / 2,
        width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
        height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
      }) : this.tableGroup.border.setAttributes({
        x: this.table.tableX - borderLeft / 2,
        y: this.table.tableY - borderTop / 2,
        width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
        height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
      }) : "group" === this.tableGroup.border.type && ((null === (_l = this.table.theme.frameStyle) || void 0 === _l ? void 0 : _l.innerBorder) ? (this.tableGroup.border.setAttributes({
        x: this.table.tableX + borderLeft / 2,
        y: this.table.tableY + borderTop / 2,
        width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
        height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
      }), null === (_m = this.tableGroup.border.firstChild) || void 0 === _m || _m.setAttributes({
        x: 0,
        y: 0,
        width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
        height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
      })) : (this.tableGroup.border.setAttributes({
        x: this.table.tableX - borderLeft / 2,
        y: this.table.tableY - borderTop / 2,
        width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
        height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
      }), null === (_o = this.tableGroup.border.firstChild) || void 0 === _o || _o.setAttributes({
        x: borderLeft / 2,
        y: borderTop / 2,
        width: this.tableGroup.attribute.width,
        height: this.tableGroup.attribute.height
      })));
    }
    this.table.bottomFrozenRowCount > 0 && (this.bottomFrozenGroup.setAttribute("y", this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight()), this.leftBottomCornerGroup.setAttributes({
      visible: true,
      y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
      height: this.table.getBottomFrozenRowsHeight(),
      width: this.table.getFrozenColsWidth()
    }), this.rightBottomCornerGroup.setAttributes({
      visible: true,
      y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
      height: this.table.getBottomFrozenRowsHeight()
    })), this.table.rightFrozenColCount > 0 && (this.rightFrozenGroup.setAttribute("x", this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth()), this.rightTopCornerGroup.setAttributes({
      visible: true,
      x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
      width: this.table.getRightFrozenColsWidth(),
      height: this.table.getFrozenRowsHeight()
    }), this.rightBottomCornerGroup.setAttributes({
      visible: true,
      x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
      width: this.table.getRightFrozenColsWidth()
    })), this.updateDomContainer();
  }
  updateRowHeight(row, detaY, skipTableHeightMap) {
    detaY = Math.round(detaY), updateRowHeight(this, row, detaY, skipTableHeightMap), this.updateContainerHeight(row, detaY);
  }
  updateRowsHeight(rows, detaYs, skipTableHeightMap) {
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (row >= this.proxy.rowStart && row <= this.proxy.rowEnd) {
        const detaY = detaYs[i];
        updateRowHeight(this, row, Math.round(detaY), skipTableHeightMap), this._updateContainerHeight(row, detaY);
      }
    }
    this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame();
  }
  updateContainerWidth(col, detaX) {
    col < this.frozenColCount ? (this.rowHeaderGroup.setDeltaWidth(detaX), this.cornerHeaderGroup.setDeltaWidth(detaX), this.colHeaderGroup.setDeltaX(detaX), this.bodyGroup.setDeltaX(detaX)) : (this.colHeaderGroup.setDeltaWidth(detaX), this.bodyGroup.setDeltaWidth(detaX)), this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame();
  }
  _updateContainerHeight(row, detaY) {
    row < this.table.frozenRowCount ? (this.colHeaderGroup.setDeltaHeight(detaY), this.cornerHeaderGroup.setDeltaHeight(detaY), this.rowHeaderGroup.setDeltaY(detaY), this.bodyGroup.setDeltaY(detaY), this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaY(detaY)) : row >= this.table.rowCount - this.table.bottomFrozenRowCount ? (this.leftBottomCornerGroup.setDeltaHeight(detaY), this.bottomFrozenGroup.setDeltaHeight(detaY), this.table.rightFrozenColCount && this.rightBottomCornerGroup.setDeltaHeight(detaY)) : (this.rowHeaderGroup.setDeltaHeight(detaY), this.bodyGroup.setDeltaHeight(detaY), this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaHeight(detaY));
  }
  updateContainerHeight(row, detaY) {
    this._updateContainerHeight(row, detaY), this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame();
  }
  setColWidth(col, width) {
    const oldWidth = this.table.getColWidth(col);
    oldWidth !== width && (this.updateColWidth(col, width - oldWidth), this.table._clearColRangeWidthsMap(col));
  }
  setRowHeight(row, height) {
    const oldHeight = this.table.getRowHeight(row);
    oldHeight !== height && ((row >= this.proxy.rowStart && row <= this.proxy.rowEnd || row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1 || row < this.table.frozenRowCount) && this.updateRowHeight(row, height - oldHeight), this.table._clearRowRangeHeightsMap(row));
  }
  setX(x, isEnd = false) {
    this.table.scenegraph.proxy.setX(-x, isEnd);
  }
  setY(y, isEnd = false) {
    this.table.scenegraph.proxy.setY(-y, isEnd);
  }
  setBodyAndRowHeaderY(y) {
    var _a, _b, _c, _d, _e, _f;
    const firstBodyCell = null !== (_b = null === (_a = this.bodyGroup.firstChild) || void 0 === _a ? void 0 : _a.firstChild) && void 0 !== _b ? _b : null === (_c = this.rowHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.firstChild, lastBodyCell = null !== (_e = null === (_d = this.bodyGroup.firstChild) || void 0 === _d ? void 0 : _d.lastChild) && void 0 !== _e ? _e : null === (_f = this.rowHeaderGroup.firstChild) || void 0 === _f ? void 0 : _f.lastChild;
    0 === y && firstBodyCell && firstBodyCell.row === this.table.frozenRowCount && firstBodyCell.attribute.y + y < 0 ? y = -firstBodyCell.attribute.y : lastBodyCell && this.table.tableNoFrameHeight < this.table.getAllRowsHeight() && lastBodyCell.row === this.table.rowCount - this.table.bottomFrozenRowCount - 1 && lastBodyCell.attribute.y + lastBodyCell.attribute.height + y < this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() && (y = this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() - lastBodyCell.attribute.y - lastBodyCell.attribute.height), this.colHeaderGroup.attribute.height + y !== this.bodyGroup.attribute.y && (this.bodyGroup.setAttribute("y", this.colHeaderGroup.attribute.height + y), this.rowHeaderGroup.setAttribute("y", this.cornerHeaderGroup.attribute.height + y), this.table.rightFrozenColCount > 0 && this.rightFrozenGroup.setAttribute("y", this.rightTopCornerGroup.attribute.height + y), this.updateNextFrame());
  }
  setBodyAndColHeaderX(x) {
    const firstBodyCol = this.bodyGroup.firstChild, lastBodyCol = this.bodyGroup.lastChild;
    0 === x && firstBodyCol && firstBodyCol.col === this.table.frozenColCount && firstBodyCol.attribute.x + x < 0 ? x = -firstBodyCol.attribute.x : lastBodyCol && this.table.tableNoFrameWidth < this.table.getAllColsWidth() && lastBodyCol.col === this.table.colCount - this.table.rightFrozenColCount - 1 && lastBodyCol.attribute.x + lastBodyCol.attribute.width + x < this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() && (x = this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() - lastBodyCol.attribute.x - lastBodyCol.attribute.width), this.table.getFrozenColsWidth() + x !== this.bodyGroup.attribute.x && (this.bodyGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), this.colHeaderGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), this.table.bottomFrozenRowCount > 0 && this.bottomFrozenGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), this.updateNextFrame());
  }
  afterScenegraphCreated() {
    this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount ? this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : this.component.setFrozenColumnShadow(-1) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), this.table.stateManager.checkFrozen(), this.updateContainer(), this.createFrameBorder(), this.updateBorderSizeAndPosition(), this.component.updateScrollBar(), handleTextStick(this.table), this.table.options.animationAppear && dealWithAnimationAppear(this.table), this.updateNextFrame();
  }
  dealWidthMode() {
    const table = this.table;
    if ("adaptive" === table.widthMode) {
      table._clearColRangeWidthsMap();
      const canvasWidth = table.tableNoFrameWidth;
      let actualHeaderWidth = 0, startCol = 0, endCol = table.colCount;
      if ("only-body" === table.widthAdaptiveMode) {
        for (let col = 0; col < table.colCount; col++) if (col < table.rowHeaderLevelCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) {
          actualHeaderWidth += table.getColWidth(col);
        }
        startCol = table.rowHeaderLevelCount, endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
      }
      getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, false, [], table, true);
    } else if (table.autoFillWidth) {
      table._clearColRangeWidthsMap();
      const canvasWidth = table.tableNoFrameWidth;
      let actualHeaderWidth = 0, actualWidth = 0;
      for (let col = 0; col < table.colCount; col++) {
        const colWidth = table.getColWidth(col);
        (col < table.rowHeaderLevelCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) && (actualHeaderWidth += colWidth), actualWidth += colWidth;
      }
      if (actualWidth < canvasWidth && actualWidth > actualHeaderWidth) {
        const startCol = table.rowHeaderLevelCount, endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
        getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, false, [], table, true);
      }
    }
    let bodyWidth = 0;
    this.bodyGroup.forEachChildrenSkipChild((column) => {
      bodyWidth += column.attribute.width;
    }), this.bodyGroup.setAttribute("width", bodyWidth);
    let colHeaderWidth = 0;
    this.colHeaderGroup.forEachChildrenSkipChild((column) => {
      colHeaderWidth += column.attribute.width;
    }), this.colHeaderGroup.setAttribute("width", colHeaderWidth);
    let rowHeaderWidth = 0;
    this.rowHeaderGroup.forEachChildrenSkipChild((column) => {
      rowHeaderWidth += column.attribute.width;
    }), this.rowHeaderGroup.setAttribute("width", rowHeaderWidth);
    let cornerHeaderWidth = 0;
    this.cornerHeaderGroup.forEachChildrenSkipChild((column) => {
      cornerHeaderWidth += column.attribute.width;
    }), this.cornerHeaderGroup.setAttribute("width", cornerHeaderWidth), this.colHeaderGroup.setAttribute("x", this.cornerHeaderGroup.attribute.width), this.rowHeaderGroup.setAttribute("y", this.cornerHeaderGroup.attribute.height), this.bodyGroup.setAttributes({
      x: this.rowHeaderGroup.attribute.width,
      y: this.colHeaderGroup.attribute.height
    });
  }
  dealHeightMode() {
    var _a;
    const table = this.table;
    if ("adaptive" === table.heightMode) {
      table._clearRowRangeHeightsMap();
      const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1), bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0, totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight, startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
      let actualHeight = 0;
      for (let row = startRow; row < endRow; row++) actualHeight += table.getRowHeight(row);
      const factor = totalDrawHeight / actualHeight;
      for (let row = startRow; row < endRow; row++) {
        let rowHeight;
        rowHeight = row === endRow - 1 ? totalDrawHeight - table.getRowsHeight(startRow, endRow - 2) : Math.round(table.getRowHeight(row) * factor), this.setRowHeight(row, rowHeight);
      }
    } else if (table.autoFillHeight) {
      table._clearRowRangeHeightsMap();
      const canvasHeight = table.tableNoFrameHeight;
      let actualHeight = 0, actualHeaderHeight = 0;
      for (let row = 0; row < table.rowCount; row++) {
        const rowHeight = table.getRowHeight(row);
        (row < table.columnHeaderLevelCount || table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount) && (actualHeaderHeight += rowHeight), actualHeight += rowHeight;
      }
      if ((null !== (_a = this._dealAutoFillHeightOriginRowsHeight) && void 0 !== _a ? _a : actualHeight) < canvasHeight && actualHeight - actualHeaderHeight > 0) {
        const startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount, factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
        for (let row = startRow; row < endRow; row++) {
          let rowHeight;
          rowHeight = row === endRow - 1 ? canvasHeight - actualHeaderHeight - table.getRowsHeight(startRow, endRow - 2) : Math.round(table.getRowHeight(row) * factor), this.setRowHeight(row, rowHeight);
        }
      }
    }
  }
  dealFrozen() {
    dealFrozen(this);
  }
  resetFrozen() {
    resetFrozen(this);
  }
  resetRowFrozen() {
    resetRowFrozen(this);
  }
  updateCellLayoutWidthCertainWidth(columnGroup, detaRow, col) {
    const width = columnGroup.attribute.width;
    let isUpdate = false;
    return columnGroup.forEachChildren((cellGroup, row) => {
      row += detaRow;
      const mergeInfo = getCellMergeInfo(this.table, col, row);
      mergeInfo ? cellGroup = this.getCell(mergeInfo.start.col, mergeInfo.start.row) : cellGroup.setAttribute("width", width);
      const headerStyle = this.table._getCellStyle(col, row), padding = getQuadProps(getProp2("padding", headerStyle, col, row, this.table)), text2 = cellGroup.getChildByName("text");
      let oldCellHeight = 0, newCellHeight = 0;
      if (text2) oldCellHeight = text2.AABBBounds.height() + (padding[0] + padding[2]), text2.setAttribute("maxLineWidth", width - (padding[1] + padding[3])), newCellHeight = text2.AABBBounds.height() + (padding[0] + padding[2]);
      else {
        const group = cellGroup.getChildAt(1);
        oldCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]), group._cellWidth = width - (padding[1] + padding[3]), group.layout(), newCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]);
      }
      const rowHeight = this.table.getRowHeight(row);
      cellGroup.attribute.height !== newCellHeight && (cellGroup.setAttribute("height", newCellHeight), (rowHeight === oldCellHeight || newCellHeight > rowHeight) && (isUpdate = true));
    }), isUpdate;
  }
  updateHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType) {
    moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, this.table);
  }
  updateContainerAttrWidthAndX() {
    var _a, _b, _c;
    const cornerX = updateContainerChildrenX(this.cornerHeaderGroup, 0), rowHeaderX = updateContainerChildrenX(this.rowHeaderGroup, 0), colHeaderX = this.colHeaderGroup.hasChildNodes() && this.colHeaderGroup.firstChild ? updateContainerChildrenX(this.colHeaderGroup, this.colHeaderGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_a = this.table.frozenColCount) && void 0 !== _a ? _a : 0, this.colHeaderGroup.firstChild.col - 1) : 0) : 0, bodyX = this.bodyGroup.hasChildNodes() && this.bodyGroup.firstChild ? updateContainerChildrenX(this.bodyGroup, this.bodyGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_b = this.table.frozenColCount) && void 0 !== _b ? _b : 0, this.bodyGroup.firstChild.col - 1) : 0) : 0, rightX = updateContainerChildrenX(this.rightFrozenGroup.childrenCount > 0 ? this.rightFrozenGroup : this.rightTopCornerGroup, 0);
    this.bottomFrozenGroup.hasChildNodes() && this.bottomFrozenGroup.firstChild && updateContainerChildrenX(this.bottomFrozenGroup, this.bottomFrozenGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_c = this.table.frozenColCount) && void 0 !== _c ? _c : 0, this.bottomFrozenGroup.firstChild.col - 1) : 0), updateContainerChildrenX(this.leftBottomCornerGroup, 0), updateContainerChildrenX(this.rightTopCornerGroup, 0), updateContainerChildrenX(this.rightBottomCornerGroup, 0), this.cornerHeaderGroup.setDeltaWidth(cornerX - this.cornerHeaderGroup.attribute.width), this.leftBottomCornerGroup.setDeltaWidth(cornerX - this.leftBottomCornerGroup.attribute.width), this.colHeaderGroup.setDeltaWidth(colHeaderX - this.colHeaderGroup.attribute.width), this.rowHeaderGroup.setDeltaWidth(rowHeaderX - this.rowHeaderGroup.attribute.width), this.bottomFrozenGroup.setDeltaWidth(colHeaderX - this.bottomFrozenGroup.attribute.width), this.rightFrozenGroup.setDeltaWidth(rightX - this.rightFrozenGroup.attribute.width), this.rightTopCornerGroup.setDeltaWidth(rightX - this.rightTopCornerGroup.attribute.width), this.rightBottomCornerGroup.setDeltaWidth(rightX - this.rightBottomCornerGroup.attribute.width), this.bodyGroup.setDeltaWidth(bodyX - this.bodyGroup.attribute.width), this.colHeaderGroup.setAttribute("x", this.cornerHeaderGroup.attribute.width), this.bottomFrozenGroup.setAttribute("x", this.table.getFrozenColsWidth()), this.bodyGroup.setAttribute("x", this.rowHeaderGroup.attribute.width);
  }
  updateContainer(async = false) {
    async ? this._needUpdateContainer || (this._needUpdateContainer = true, setTimeout(() => {
      this.updateContainerSync();
    }, 0)) : (this._needUpdateContainer = true, this.updateContainerSync());
  }
  updateContainerSync() {
    this._needUpdateContainer && (this._needUpdateContainer = false, this.updateContainerAttrWidthAndX(), this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame());
  }
  updateCellContentWhileResize(col, row) {
    var _a;
    const type = (null === (_a = this.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge) ? "text" : this.table.isHeader(col, row) ? this.table._getHeaderLayoutMap(col, row).headerType : this.table.getBodyColumnType(col, row), cellGroup = this.getCell(col, row);
    "image" !== type && "video" !== type || updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, this.table);
  }
  createFrameBorder() {
    var _a, _b, _c, _d, _e;
    this.updateTableSize();
    const isListTableWithFrozen = !this.isPivot && !this.table.internalProps.transpose;
    createFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle, this.bodyGroup.role, isListTableWithFrozen ? [true, true, true, false] : void 0), createFrameBorder(this.rowHeaderGroup, this.isPivot || this.table.internalProps.transpose ? this.table.theme.rowHeaderStyle.frameStyle : this.table.theme.bodyStyle.frameStyle, this.rowHeaderGroup.role, isListTableWithFrozen ? [true, false, true, true] : void 0), createFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle, this.colHeaderGroup.role, isListTableWithFrozen ? [true, true, true, false] : void 0), createFrameBorder(this.cornerHeaderGroup, this.isPivot ? this.table.theme.cornerHeaderStyle.frameStyle : this.table.theme.headerStyle.frameStyle, this.cornerHeaderGroup.role, isListTableWithFrozen ? [true, false, true, true] : void 0), (null === (_a = this.table.theme.cornerLeftBottomCellStyle) || void 0 === _a ? void 0 : _a.frameStyle) && createFrameBorder(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle.frameStyle, this.leftBottomCornerGroup.role, isListTableWithFrozen ? [true, false, true, true] : void 0), (null === (_b = this.table.theme.bottomFrozenStyle) || void 0 === _b ? void 0 : _b.frameStyle) && createFrameBorder(this.bottomFrozenGroup, this.table.theme.bottomFrozenStyle.frameStyle, this.bottomFrozenGroup.role, isListTableWithFrozen ? [true, true, true, false] : void 0), (null === (_c = this.table.theme.rightFrozenStyle) || void 0 === _c ? void 0 : _c.frameStyle) && createFrameBorder(this.rightFrozenGroup, this.table.theme.rightFrozenStyle.frameStyle, this.rightFrozenGroup.role, void 0), (null === (_d = this.table.theme.cornerRightTopCellStyle) || void 0 === _d ? void 0 : _d.frameStyle) && createFrameBorder(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle.frameStyle, this.rightTopCornerGroup.role, void 0), (null === (_e = this.table.theme.cornerRightBottomCellStyle) || void 0 === _e ? void 0 : _e.frameStyle) && createFrameBorder(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle.frameStyle, this.rightBottomCornerGroup.role, void 0), createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, void 0);
  }
  getResizeColAt(abstractX, abstractY, cellGroup) {
    const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
    let cell;
    if (!cellGroup) {
      const drawRange = this.table.getDrawRange();
      return abstractY >= drawRange.top && abstractY <= drawRange.bottom && (cell = this.table.getCellAtRelativePosition(abstractX - offset, abstractY), cell.col === this.table.colCount - 1) ? cell : {
        col: -1,
        row: -1
      };
    }
    return cellGroup.stage ? (abstractX < cellGroup.globalAABBBounds.x1 + offset ? cell = {
      col: cellGroup.col - 1,
      row: cellGroup.row,
      x: cellGroup.globalAABBBounds.x1
    } : cellGroup.globalAABBBounds.x2 - offset < abstractX && (cell = {
      col: cellGroup.col,
      row: cellGroup.row,
      x: cellGroup.globalAABBBounds.x2
    }), cell && this.table.rightFrozenColCount > 0 && cell.col >= this.table.colCount - this.table.rightFrozenColCount - 1 && this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() + this.table.scrollLeft < this.bodyGroup.attribute.width && (cell.col = cell.col + 1, cell.rightFrozen = true), cell || {
      col: -1,
      row: -1
    }) : {
      col: -1,
      row: -1
    };
  }
  getResizeRowAt(abstractX, abstractY, cellGroup) {
    const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
    if (cellGroup) {
      let cell;
      if (abstractY < cellGroup.globalAABBBounds.y1 + offset ? cell = {
        col: cellGroup.col,
        row: cellGroup.row - 1,
        y: cellGroup.globalAABBBounds.y1
      } : cellGroup.globalAABBBounds.y2 - offset < abstractY && (cell = {
        col: cellGroup.col,
        row: cellGroup.row,
        y: cellGroup.globalAABBBounds.y2
      }), cell && this.table.bottomFrozenRowCount > 0 && cell.row >= this.table.rowCount - this.table.bottomFrozenRowCount - 1 && this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() + this.table.scrollTop < this.bodyGroup.attribute.height && (cell.row = cell.row + 1, cell.bottomFrozen = true), cell) return cell;
    } else ;
    return {
      col: -1,
      row: -1
    };
  }
  updateFrozen() {
    this.clear || (this.resetFrozen(), this.component.updateScrollBar());
  }
  updateRowFrozen() {
    this.clear || (this.resetRowFrozen(), this.component.updateScrollBar());
  }
  dealWidthRightFrozen(rightFrozenColCount) {
    this.clear ? this.table.internalProps.rightFrozenColCount = rightFrozenColCount : dealRightFrozen(rightFrozenColCount, this);
  }
  dealWidthBottomFrozen(bottomFrozenRowCount) {
    this.clear ? this.table.internalProps.bottomFrozenRowCount = bottomFrozenRowCount : dealBottomFrozen(bottomFrozenRowCount, this);
  }
  updateBorderSizeAndPosition() {
    this.bodyGroup.border && (this.bodyGroup.appendChild(this.bodyGroup.border), updateFrameBorderSize(this.bodyGroup), this.rowHeaderGroup.attribute.width, updateFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle)), this.colHeaderGroup.border && (this.colHeaderGroup.appendChild(this.colHeaderGroup.border), updateFrameBorderSize(this.colHeaderGroup), this.cornerHeaderGroup.attribute.width, updateFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle)), this.rowHeaderGroup.border && (this.rowHeaderGroup.appendChild(this.rowHeaderGroup.border), updateFrameBorderSize(this.rowHeaderGroup)), this.cornerHeaderGroup.border && (this.cornerHeaderGroup.appendChild(this.cornerHeaderGroup.border), updateFrameBorderSize(this.cornerHeaderGroup)), this.leftBottomCornerGroup.border && (this.leftBottomCornerGroup.appendChild(this.leftBottomCornerGroup.border), updateFrameBorderSize(this.leftBottomCornerGroup)), this.bottomFrozenGroup.border && (this.bottomFrozenGroup.appendChild(this.bottomFrozenGroup.border), updateFrameBorderSize(this.bottomFrozenGroup)), this.rightFrozenGroup.border && (this.rightFrozenGroup.appendChild(this.rightFrozenGroup.border), updateFrameBorderSize(this.rightFrozenGroup)), this.rightTopCornerGroup.border && (this.rightTopCornerGroup.appendChild(this.rightTopCornerGroup.border), updateFrameBorderSize(this.rightTopCornerGroup)), this.rightBottomCornerGroup.border && (this.rightBottomCornerGroup.appendChild(this.rightBottomCornerGroup.border), updateFrameBorderSize(this.rightBottomCornerGroup)), updateCornerRadius(this.table);
  }
  sortCell() {
    this.isPivot || (this.table.transpose ? this.proxy.sortCellHorizontal() : this.proxy.sortCellVertical());
  }
  getCellOverflowText(col, row) {
    const text2 = this.getCell(col, row).getChildByName("text", true);
    if (text2 && "text" === text2.type) {
      if (text2.attribute.moreThanMaxCharacters) return this.table.getCellValue(col, row);
      if (text2.cliped) return this.table.getCellValue(col, row);
    } else if (text2 && "richtext" === text2.type) {
      const richtext = text2;
      if (richtext.attribute.ellipsis && richtext._frameCache && richtext.attribute.height < richtext._frameCache.actualHeight) {
        richtext.attribute.textConfig.find((item) => item.text);
        return this.table.getCellValue(col, row);
      }
    }
    return null;
  }
  updateDrill(visible, x, y, drillDown, drillUp) {
    this.component.drillIcon.update(visible, x, y, drillDown, drillUp, this);
  }
  updateCellContent(col, row, forceFastUpdate = false) {
    if (!this.clear) return updateCell(col, row, this.table, void 0, void 0, forceFastUpdate);
  }
  setPixelRatio(pixelRatio) {
    this.stage.disableDirtyBounds(), this.stage.window.setDpr(pixelRatio), this.stage.render(), this.stage.enableDirtyBounds();
  }
  updateRow(removeCells, addCells, updateCells = [], recalculateColWidths = true, skipUpdateProxy) {
    this.table.internalProps.layoutMap.clearCellRangeMap(), this.table.internalProps.useOneRowHeightFillAll = false;
    const addRows = deduplication(addCells.map((cell) => cell.row)).sort((a2, b) => a2 - b), updateRows = deduplication(updateCells.map((cell) => cell.row)).sort((a2, b) => a2 - b), isNotFillHeight = this.table.getAllRowsHeight() - [...addRows, ...updateRows].reduce((tolHeight, rowNumber) => tolHeight + this.table.getRowHeight(rowNumber), 0) <= this.table.tableNoFrameHeight;
    if (updateRow(removeCells, addCells, updateCells, this.table, skipUpdateProxy), recalculateColWidths && this.recalculateColWidths(), "adaptive" === this.table.heightMode || this.table.autoFillHeight && (this.table.getAllRowsHeight() <= this.table.tableNoFrameHeight || isNotFillHeight)) this.table.scenegraph.recalculateRowHeights();
    else if (this.table.isAutoRowHeight(this.table.columnHeaderLevelCount)) for (let i = 0; i < updateRows.length; i++) {
      const row = updateRows[i], oldHeight = this.table.getRowHeight(row), newHeight = computeRowHeight(row, 0, this.table.colCount - 1, this.table);
      (row >= this.proxy.rowStart && row <= this.proxy.rowEnd || row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1) && this.table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
    }
    this.table.stateManager.checkFrozen(), this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount && this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), this.component.updateScrollBar(), this.updateNextFrame();
  }
  updateCol(removeCells, addCells, updateCells = []) {
    updateCol(removeCells, addCells, updateCells, this.table), this.recalculateColWidths(), this.recalculateRowHeights(), this.table.stateManager.checkFrozen(), this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount && this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), this.component.updateScrollBar(), this.updateNextFrame();
  }
  updateCornerHeaderCells() {
    for (let col = 0; col < this.table.frozenColCount; col++) for (let row = 0; row < this.table.frozenRowCount; row++) updateCell(col, row, this.table, false);
  }
  updateRowHeaderCells() {
    for (let col = 0; col < this.table.frozenColCount; col++) for (let row = this.table.frozenRowCount; row < this.table.rowCount; row++) updateCell(col, row, this.table, false);
  }
  updateColumnHeaderCells() {
    for (let row = 0; row < this.table.frozenRowCount; row++) for (let col = this.table.frozenColCount; col < this.table.colCount; col++) updateCell(col, row, this.table, false);
  }
  getColumnGroupX(col) {
    return col < this.table.rowHeaderLevelCount ? this.table.getColsWidth(0, col - 1) : col < this.table.colCount - this.table.rightFrozenColCount ? this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1) : col < this.table.colCount ? this.table.getColsWidth(this.table.colCount - this.table.bottomFrozenRowCount, col - 1) : 0;
  }
  getCellGroupY(row) {
    return row < this.table.frozenRowCount ? this.table.getRowsHeight(0, row - 1) : row < this.table.rowCount - this.table.bottomFrozenRowCount ? this.table.getRowsHeight(this.table.frozenRowCount, row - 1) : row < this.table.rowCount ? this.table.getRowsHeight(this.table.rowCount - this.table.bottomFrozenRowCount, row - 1) : 0;
  }
  getCellGroupX(col) {
    return col < this.table.rowHeaderLevelCount ? this.table.getColsWidth(0, col - 1) : col < this.table.colCount - this.table.rightFrozenColCount ? this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1) : col < this.table.colCount ? this.table.getColsWidth(this.table.colCount - this.table.rightFrozenColCount, col - 1) : 0;
  }
  updateDomContainer() {
    updateReactContainer(this.table);
  }
  setLoadingHierarchyState(col, row) {
    const cellGroup = this.getCell(col, row), iconGraphic = cellGroup.getChildByName("collapse", true) || cellGroup.getChildByName("expand", true);
    if (iconGraphic) {
      const loadingIcon = get3()[InternalIconName.loadingIconName];
      loadingIcon && dealWithIcon(loadingIcon, iconGraphic, col, row);
    }
  }
  temporarilyUpdateSelectRectStyle(rectAttribute) {
    temporarilyUpdateSelectRectStyle(rectAttribute, this);
  }
  resetSelectRectStyle() {
    this.recreateAllSelectRangeComponents();
  }
};

// node_modules/@visactor/vtable/es/state/common/check-in-select.js
function checkCellInSelect(col, row, cellRanges) {
  for (let i = 0; i < cellRanges.length; i++) {
    const range5 = cellRanges[i];
    if (cellInRange(range5, col, row)) return true;
  }
  return false;
}
function checkMultiCellInSelect(cellPosStart, cellPosEnd, selectRangs, selectMode) {
  for (let i = 0; i < selectRangs.length; i++) {
    const range5 = selectRangs[i];
    if (rangeIntersected(range5, {
      start: cellPosStart,
      end: cellPosEnd
    })) return true;
  }
  return false;
}

// node_modules/@visactor/vtable/es/state/hover/update-cell.js
function updateCell2(scenegraph, col, row) {
  const cellGroup = scenegraph.highPerformanceGetCell(col, row);
  if ("cell" === cellGroup.role && isValid_default(cellGroup.mergeStartCol) && isValid_default(cellGroup.mergeStartRow) && isValid_default(cellGroup.mergeEndCol) && isValid_default(cellGroup.mergeEndRow)) {
    const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, scenegraph);
    for (let col2 = colStart; col2 <= colEnd; col2++) for (let row2 = rowStart; row2 <= rowEnd; row2++) {
      const mergeCell = scenegraph.highPerformanceGetCell(col2, row2);
      "cell" === mergeCell.role && mergeCell.addUpdateBoundTag();
    }
  } else cellGroup.addUpdateBoundTag();
}

// node_modules/@visactor/vtable/es/state/hover/col.js
function clearColHover(scenegraph, col, rowOrigin, selectRanges, selectMode) {
  const table = scenegraph.table;
  for (let row = 0; row < table.columnHeaderLevelCount; row++) updateCell2(scenegraph, col, row);
  const cellGroup = scenegraph.getColGroup(col);
  return null == cellGroup || cellGroup.addUpdateBoundTag(), true;
}
function updateColHover(scenegraph, col, rowOrigin, selectRanges, selectMode, singleStyle) {
  const table = scenegraph.table;
  for (let row = 0; row < table.columnHeaderLevelCount; row++) updateCell2(scenegraph, col, row);
  const cellGroup = scenegraph.getColGroup(col);
  return null == cellGroup || cellGroup.addUpdateBoundTag(), true;
}

// node_modules/@visactor/vtable/es/state/hover/row.js
function clearRowHover(scenegraph, colOrigin, row, selectRanges, selectMode) {
  const table = scenegraph.table;
  for (let col = 0; col < table.colCount; col++) updateCell2(scenegraph, col, row);
  return true;
}
function updateRowHover(scenegraph, colOrigin, row, selectRanges, selectMode, singleStyle) {
  const table = scenegraph.table;
  for (let col = 0; col < table.colCount; col++) updateCell2(scenegraph, col, row);
  return true;
}

// node_modules/@visactor/vtable/es/state/hover/single.js
function clearSingleHover(scenegraph, col, row, selectRanges, selectMode) {
  return updateCell2(scenegraph, col, row), true;
}
function updateSingleHover(scenegraph, col, row, selectRanges, selectMode) {
  return updateCell2(scenegraph, col, row), true;
}

// node_modules/@visactor/vtable/es/state/hover/update-position.js
function updateHoverPosition(state, col, row) {
  var _a;
  const { table } = state, { scenegraph } = table, { highlightScope, singleStyle, disableHeader, cellPos, cellPosContainHeader } = state.hover, prevHoverCellCol = cellPos.col, prevHoverCellRow = cellPos.row;
  if (highlightScope === HighlightScope.none || disableHeader && (cellPosContainHeader.col !== col || cellPosContainHeader.row !== row)) {
    const prevHoverCellCol2 = cellPosContainHeader.col, prevHoverCellRow2 = cellPosContainHeader.row;
    scenegraph.hideHoverIcon(prevHoverCellCol2, prevHoverCellRow2), scenegraph.showHoverIcon(col, row), cellPosContainHeader.col = col, cellPosContainHeader.row = row;
  }
  if ((disableHeader && table.isHeader(col, row) || highlightScope === HighlightScope.none) && (col = -1, row = -1), prevHoverCellCol === col && prevHoverCellRow === row) return;
  (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a.disableBuildInChartActive) || (scenegraph.deactivateChart(prevHoverCellCol, prevHoverCellRow), scenegraph.activateChart(col, row));
  let updateScenegraph = false;
  const { ranges, highlightScope: selectMode } = state.select;
  if (-1 !== prevHoverCellCol && -1 !== prevHoverCellRow && (updateScenegraph = clearHover(scenegraph, prevHoverCellCol, prevHoverCellRow, ranges, singleStyle, highlightScope, selectMode), disableHeader || scenegraph.hideHoverIcon(prevHoverCellCol, prevHoverCellRow)), -1 === col || -1 === row) return cellPos.col = -1, cellPos.row = -1, void (!updateScenegraph || prevHoverCellCol === col && prevHoverCellRow === row || state.table.scenegraph.updateNextFrame());
  highlightScope === HighlightScope.single ? updateScenegraph = !!updateSingleHover(scenegraph, col, row, ranges, selectMode) || updateScenegraph : highlightScope === HighlightScope.row ? updateScenegraph = !!updateRowHover(scenegraph, col, row, ranges, selectMode, singleStyle) || updateScenegraph : highlightScope === HighlightScope.column ? updateScenegraph = !!updateColHover(scenegraph, col, row, ranges, selectMode, singleStyle) || updateScenegraph : highlightScope === HighlightScope.cross && (updateScenegraph = !!updateRowHover(scenegraph, col, row, ranges, selectMode, singleStyle) || updateScenegraph, updateScenegraph = !!updateColHover(scenegraph, col, row, ranges, selectMode, singleStyle) || updateScenegraph), highlightScope === HighlightScope.none || disableHeader || scenegraph.showHoverIcon(col, row), cellPos.col = col, cellPos.row = row, updateScenegraph && state.table.scenegraph.updateNextFrame();
}
function clearHover(scenegraph, col, row, selectRanges, singleStyle, mode, selectMode) {
  let updateScenegraph = false;
  return mode === HighlightScope.single ? updateScenegraph = !!clearSingleHover(scenegraph, col, row, selectRanges, selectMode) || updateScenegraph : mode === HighlightScope.row ? updateScenegraph = !!clearRowHover(scenegraph, col, row, selectRanges, selectMode) || updateScenegraph : mode === HighlightScope.column ? updateScenegraph = !!clearColHover(scenegraph, col, row, selectRanges, selectMode) || updateScenegraph : mode === HighlightScope.cross && (updateScenegraph = !!clearRowHover(scenegraph, col, row, selectRanges, selectMode) || updateScenegraph, updateScenegraph = !!clearColHover(scenegraph, col, row, selectRanges, selectMode) || updateScenegraph), updateScenegraph;
}

// node_modules/@visactor/vtable/es/state/frozen/index.js
function dealFreeze(col, row, table) {
  table.frozenColCount > 0 ? col !== table.frozenColCount - 1 ? table.setFrozenColCount(col + 1) : table.setFrozenColCount(0) : table.setFrozenColCount(col + 1);
}

// node_modules/@visactor/vtable/es/state/sort/index.js
function dealSort(col, row, table, event2) {
  var _a;
  let tableState, range1 = null, isTargetCell = false;
  if (Array.isArray(table.sortState)) for (let i = 0; i < table.sortState.length && (tableState = table.sortState[i], tableState && (range1 = table._getHeaderCellBySortState(tableState)), range1 && (isTargetCell = isTarget(col, row, range1.col, range1.row, table)), !isTargetCell); i++) ;
  else tableState = table.sortState, tableState && (range1 = table._getHeaderCellBySortState(tableState)), range1 && (isTargetCell = isTarget(col, row, range1.col, range1.row, table));
  const headerC = table.getHeaderDefine(col, row);
  tableState && isTargetCell && (null == headerC ? void 0 : headerC.sort) ? tableState.order = "asc" === tableState.order ? "desc" : "desc" === tableState.order ? "normal" : "asc" : (null == headerC ? void 0 : headerC.sort) ? tableState = {
    field: table.getHeaderField(col, row),
    order: "asc"
  } : isTargetCell && (null == headerC ? void 0 : headerC.showSort) || (tableState = {
    field: table.getHeaderField(col, row),
    order: "normal"
  }), tableState.event = event2;
  if (table.fireListeners(TABLE_EVENT_TYPE.SORT_CLICK, tableState).includes(false)) return;
  let isArraySortState = false, sortState = table.internalProps.sortState ? Array.isArray(table.internalProps.sortState) && (isArraySortState = true) ? table.internalProps.sortState : [table.internalProps.sortState] : [];
  if (Array.isArray(sortState)) {
    const index = sortState.findIndex((item) => item.field === tableState.field);
    index >= 0 ? sortState[index] = tableState : sortState.push(tableState);
  }
  sortState = sortState.filter((item) => "normal" !== item.order), sortState = table.internalProps.multipleSort && (isArraySortState = true) ? sortState : sortState.splice(-1), sortState = isArraySortState && sortState.length ? sortState : sortState[0], table.internalProps.sortState = sortState, table.stateManager.setSortState(sortState), (null == headerC ? void 0 : headerC.sort) && executeSort(sortState, table, headerC), table.internalProps.useOneRowHeightFillAll = false, table.internalProps.layoutMap.clearCellRangeMap(), table.scenegraph.sortCell();
  const isHasSelected = !!(null === (_a = table.stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
  table.stateManager.updateSelectPos(-1, -1), table.stateManager.endSelectCells(true, isHasSelected);
}
function executeSort(newState, table, headerDefine) {
  newState = Array.isArray(newState) || !newState ? newState : [newState], table.dataSource.sort((newState || []).map((item) => {
    var _a, _b;
    const hd = table.internalProps.layoutMap.headerObjects.find((col) => col && col.field === item.field);
    return {
      field: item.field,
      order: item.order || "asc",
      orderFn: "function" == typeof (null === (_a = null == hd ? void 0 : hd.define) || void 0 === _a ? void 0 : _a.sort) ? null === (_b = null == hd ? void 0 : hd.define) || void 0 === _b ? void 0 : _b.sort : defaultOrderFn
    };
  }));
}
function isTarget(col, row, range1Col, range1Row, table) {
  return table._getLayoutCellId(col, row) === table._getLayoutCellId(range1Col, range1Row);
}

// node_modules/@visactor/vtable/es/state/select/update-position.js
function updateSelectPosition(state, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible = true, skipBodyMerge = false) {
  var _a, _b;
  const { table, interactionState } = state, { scenegraph } = table, { highlightScope, disableHeader, cellPos, disableCtrlMultiSelect } = state.select;
  if (-1 !== col && -1 !== row && makeSelectCellVisible && table._makeVisibleCell(col, row), -1 !== col && -1 !== row && makeSelectCellVisible) if (interactionState === InteractionState.grabing && state.select.ranges.length > 0) {
    const currentRange = state.select.ranges[state.select.ranges.length - 1];
    col > currentRange.start.col && col > currentRange.end.col && table._makeVisibleCell(col + 1, row), row > currentRange.start.row && row > currentRange.end.row && table._makeVisibleCell(col, row + 1), col < currentRange.start.col && col < currentRange.end.col && table._makeVisibleCell(col - 1, row), row < currentRange.start.row && row < currentRange.end.row && table._makeVisibleCell(col, row - 1);
  } else table._makeVisibleCell(col, row);
  if (isSelectAll) {
    state.select.ranges = [], scenegraph.deleteAllSelectBorder();
    let _startCol = 0, _startRow = 0;
    const { disableHeaderSelect, disableRowSeriesNumberSelect } = (null === (_a = table.options.keyboardOptions) || void 0 === _a ? void 0 : _a.selectAllOnCtrlA) || {};
    disableHeaderSelect && (_startCol = table.rowHeaderLevelCount, _startRow = table.columnHeaderLevelCount), (disableRowSeriesNumberSelect || disableHeaderSelect && table.transpose) && table.options.rowSeriesNumber && (_startCol += 1), state.select.ranges.push({
      start: {
        col: _startCol,
        row: _startRow
      },
      end: {
        col: table.colCount - 1,
        row: table.rowCount - 1
      }
    });
    const currentRange = state.select.ranges[state.select.ranges.length - 1];
    scenegraph.updateCellSelectBorder(currentRange, false);
  } else if (-1 === cellPos.col || -1 === cellPos.row || -1 !== col && -1 !== row) if (interactionState !== InteractionState.default || table.eventManager.isDraging || table.stateManager.isResizeCol()) {
    if ((interactionState === InteractionState.grabing || table.eventManager.isDraging) && !table.stateManager.isResizeCol()) {
      let extendSelectRange = true;
      -1 === cellPos.col && (cellPos.col = col), -1 === cellPos.row && (cellPos.row = row), cellPos.col = col, cellPos.row = row;
      const currentRange = state.select.ranges[state.select.ranges.length - 1];
      if (currentRange) {
        if (table.internalProps.layoutMap.isSeriesNumberInBody(currentRange.start.col, currentRange.start.row)) extendSelectRange = false, currentRange.end = {
          col: table.colCount - 1,
          row
        };
        else if (state.fillHandle.isFilling) {
          if ("top" === state.fillHandle.direction) if (row === state.fillHandle.beforeFillMinRow && row === state.fillHandle.beforeFillMaxRow) currentRange.start.row = currentRange.end.row = row;
          else if (row <= state.fillHandle.beforeFillMinRow) {
            if (currentRange.start.row < currentRange.end.row) {
              const temp2 = currentRange.start.row;
              currentRange.start.row = currentRange.end.row, currentRange.end.row = temp2;
            }
            currentRange.end.row = row;
          } else row === state.fillHandle.beforeFillMaxRow && (currentRange.start.row > currentRange.end.row ? currentRange.start.row = row : currentRange.end.row = row);
          else if ("bottom" === state.fillHandle.direction) {
            if (row >= state.fillHandle.beforeFillMaxRow) {
              if (currentRange.start.row > currentRange.end.row) {
                const temp2 = currentRange.start.row;
                currentRange.start.row = currentRange.end.row, currentRange.end.row = temp2;
              }
              currentRange.end.row = row;
            }
          } else if ("left" === state.fillHandle.direction) if (col === state.fillHandle.beforeFillMinCol && col === state.fillHandle.beforeFillMaxCol) currentRange.start.col = currentRange.end.col = col;
          else if (col <= state.fillHandle.beforeFillMinCol) {
            if (currentRange.start.col < currentRange.end.col) {
              const temp2 = currentRange.start.col;
              currentRange.start.col = currentRange.end.col, currentRange.end.col = temp2;
            }
            currentRange.end.col = col;
          } else col === state.fillHandle.beforeFillMaxCol && (currentRange.start.col > currentRange.end.col ? currentRange.start.col = col : currentRange.end.col = col);
          else if ("right" === state.fillHandle.direction && col >= state.fillHandle.beforeFillMaxCol) {
            if (currentRange.start.col > currentRange.end.col) {
              const temp2 = currentRange.start.col;
              currentRange.start.col = currentRange.end.col, currentRange.end.col = temp2;
            }
            currentRange.end.col = col;
          }
        } else {
          currentRange.end = {
            col,
            row
          };
          const cellRange = skipBodyMerge ? {
            start: {
              col,
              row
            },
            end: {
              col,
              row
            }
          } : table.getCellRange(col, row);
          currentRange.start.col < cellRange.end.col ? currentRange.end.col = cellRange.end.col : currentRange.start.col > cellRange.start.col && (currentRange.end.col = cellRange.start.col), currentRange.start.row < cellRange.end.row ? currentRange.end.row = cellRange.end.row : currentRange.start.row > cellRange.start.row && (currentRange.end.row = cellRange.start.row), "body" === state.select.headerSelectMode && (table.isRowHeader(col, row) ? (currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, currentRange.end.col = table.colCount - 1) : table.isColumnHeader(col, row) ? (currentRange.start.row = table.columnHeaderLevelCount, currentRange.end.row = table.rowCount - 1) : table.internalProps.layoutMap.isSeriesNumberInBody(col, row) ? (currentRange.start.col = table.leftRowSeriesNumberCount, currentRange.end.col = table.colCount - 1) : table.isCornerHeader(col, row) ? (currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, currentRange.start.row = table.columnHeaderLevelCount, currentRange.end.col = table.colCount - 1, currentRange.end.row = table.rowCount - 1) : table.isSeriesNumber(col, row) && (currentRange.start.col = table.leftRowSeriesNumberCount, currentRange.start.row = table.columnHeaderLevelCount, currentRange.end.col = table.colCount - 1, currentRange.end.row = table.rowCount - 1)), skipBodyMerge && (currentRange.skipBodyMerge = true);
        }
        currentRange && currentRange.start.row <= table.rowCount - 1 && currentRange.end.row <= table.rowCount - 1 && currentRange.start.col <= table.colCount - 1 && currentRange.end.col <= table.colCount - 1 && scenegraph.updateCellSelectBorder(currentRange, extendSelectRange);
      }
    }
  } else {
    const currentRange = state.select.ranges[state.select.ranges.length - 1];
    if (isShift && currentRange) {
      if (isCtrl && !disableCtrlMultiSelect || (cellPos.col = col, cellPos.row = row), "cell" !== state.select.headerSelectMode && table.isColumnHeader(col, row)) {
        const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = Math.max(currentRange.start.col, currentRange.end.col, col), startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = table.rowCount - 1;
        "body" === state.select.headerSelectMode ? (currentRange.start = {
          col: startCol,
          row: table.columnHeaderLevelCount
        }, currentRange.end = {
          col: endCol,
          row: table.rowCount - 1
        }) : (currentRange.start = {
          col: startCol,
          row: startRow
        }, currentRange.end = {
          col: endCol,
          row: endRow
        });
      } else if ("cell" !== state.select.headerSelectMode && table.isRowHeader(col, row)) {
        const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = table.colCount - 1, startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
        "body" === state.select.headerSelectMode ? (currentRange.start = {
          col: table.leftRowSeriesNumberCount + table.rowHeaderLevelCount,
          row: startRow
        }, currentRange.end = {
          col: table.colCount - 1,
          row: endRow
        }) : (currentRange.start = {
          col: startCol,
          row: startRow
        }, currentRange.end = {
          col: endCol,
          row: endRow
        });
      } else if ("cell" !== state.select.headerSelectMode && table.isSeriesNumberInBody(col, row)) {
        const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = table.colCount - 1, startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
        "body" === state.select.headerSelectMode ? (currentRange.start = {
          col: table.leftRowSeriesNumberCount,
          row: startRow
        }, currentRange.end = {
          col: table.colCount - 1,
          row: endRow
        }) : (currentRange.start = {
          col: startCol,
          row: startRow
        }, currentRange.end = {
          col: endCol,
          row: endRow
        });
      } else currentRange.end = {
        col,
        row
      };
      scenegraph.deleteLastSelectedRangeComponents(), scenegraph.updateCellSelectBorder(currentRange);
    } else {
      let extendSelectRange = true;
      if (-1 === cellPos.col || -1 === cellPos.row || isCtrl && !disableCtrlMultiSelect || (state.select.ranges = [], scenegraph.deleteAllSelectBorder()), "cell" !== state.select.headerSelectMode && table.isColumnHeader(col, row)) {
        const cellRange = table.getCellRange(col, row);
        "body" === state.select.headerSelectMode ? state.select.ranges.push({
          start: {
            col: cellRange.start.col,
            row: table.columnHeaderLevelCount
          },
          end: {
            col: cellRange.end.col,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        }) : state.select.ranges.push({
          start: {
            col: cellRange.start.col,
            row: cellRange.start.row
          },
          end: {
            col: cellRange.end.col,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        });
      } else if ("cell" !== state.select.headerSelectMode && table.isRowHeader(col, row)) {
        const cellRange = table.getCellRange(col, row);
        "body" === state.select.headerSelectMode ? state.select.ranges.push({
          start: {
            col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount,
            row: cellRange.start.row
          },
          end: {
            col: table.colCount - 1,
            row: cellRange.end.row
          },
          skipBodyMerge: true
        }) : state.select.ranges.push({
          start: {
            col: cellRange.start.col,
            row: cellRange.start.row
          },
          end: {
            col: table.colCount - 1,
            row: cellRange.end.row
          },
          skipBodyMerge: true
        });
      } else if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
        extendSelectRange = false;
        const { cornerHeaderSelectMode } = state.select;
        if ("body" === cornerHeaderSelectMode) state.select.ranges.push({
          start: {
            col: table.leftRowSeriesNumberCount,
            row: table.columnHeaderLevelCount
          },
          end: {
            col: table.colCount - 1,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        });
        else if ("inline" === cornerHeaderSelectMode) {
          const cellRange = skipBodyMerge ? {
            start: {
              col,
              row
            },
            end: {
              col,
              row
            }
          } : table.getCellRange(col, row);
          state.select.ranges.push({
            start: {
              col: cellRange.start.col,
              row: cellRange.start.row
            },
            end: {
              col: cellRange.end.col,
              row: table.rowCount - 1
            },
            skipBodyMerge: true
          });
        } else if ("cell" === cornerHeaderSelectMode) {
          const cellRange = skipBodyMerge ? {
            start: {
              col,
              row
            },
            end: {
              col,
              row
            }
          } : table.getCellRange(col, row);
          state.select.ranges.push({
            start: {
              col: cellRange.start.col,
              row: cellRange.start.row
            },
            end: {
              col: cellRange.end.col,
              row: cellRange.end.row
            },
            skipBodyMerge: skipBodyMerge || void 0
          });
        } else state.select.ranges.push({
          start: {
            col: 0,
            row: 0
          },
          end: {
            col: table.colCount - 1,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        });
      } else if (table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) extendSelectRange = false, "body" === state.select.headerSelectMode ? state.select.ranges.push({
        start: {
          col: table.leftRowSeriesNumberCount,
          row
        },
        end: {
          col: table.colCount - 1,
          row
        },
        skipBodyMerge: true
      }) : state.select.ranges.push({
        start: {
          col,
          row
        },
        end: {
          col: table.colCount - 1,
          row
        },
        skipBodyMerge: true
      });
      else if (table.internalProps.layoutMap.isCornerHeader(col, row)) {
        extendSelectRange = false;
        const { cornerHeaderSelectMode } = state.select;
        if ("body" === cornerHeaderSelectMode) state.select.ranges.push({
          start: {
            col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount,
            row: table.columnHeaderLevelCount
          },
          end: {
            col: table.colCount - 1,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        });
        else if ("cell" === cornerHeaderSelectMode) {
          const cellRange = skipBodyMerge ? {
            start: {
              col,
              row
            },
            end: {
              col,
              row
            }
          } : table.getCellRange(col, row);
          state.select.ranges.push({
            start: {
              col: cellRange.start.col,
              row: cellRange.start.row
            },
            end: {
              col: cellRange.end.col,
              row: cellRange.end.row
            },
            skipBodyMerge: skipBodyMerge || void 0
          });
        } else if ("inline" === cornerHeaderSelectMode) {
          const cellRange = skipBodyMerge ? {
            start: {
              col,
              row
            },
            end: {
              col,
              row
            }
          } : table.getCellRange(col, row);
          state.select.ranges.push({
            start: {
              col: cellRange.start.col,
              row: cellRange.start.row
            },
            end: {
              col: cellRange.end.col,
              row: table.rowCount - 1
            },
            skipBodyMerge: true
          });
        } else state.select.ranges.push({
          start: {
            col: table.leftRowSeriesNumberCount,
            row: 0
          },
          end: {
            col: table.colCount - 1,
            row: table.rowCount - 1
          },
          skipBodyMerge: true
        });
      } else if (col >= 0 && row >= 0) {
        const cellRange = skipBodyMerge ? {
          start: {
            col,
            row
          },
          end: {
            col,
            row
          }
        } : table.getCellRange(col, row);
        state.select.ranges.push({
          start: {
            col: cellRange.start.col,
            row: cellRange.start.row
          },
          end: {
            col: cellRange.end.col,
            row: cellRange.end.row
          },
          skipBodyMerge: skipBodyMerge || void 0
        });
      }
      cellPos.col = col, cellPos.row = row;
      const currentRange2 = null === (_b = state.select.ranges) || void 0 === _b ? void 0 : _b[state.select.ranges.length - 1];
      currentRange2 && currentRange2.start.row <= table.rowCount - 1 && currentRange2.end.row <= table.rowCount - 1 && currentRange2.start.col <= table.colCount - 1 && currentRange2.end.col <= table.colCount - 1 && scenegraph.updateCellSelectBorder(currentRange2, extendSelectRange);
    }
  }
  else cellPos.col = -1, cellPos.row = -1, state.select.ranges = [], scenegraph.deleteAllSelectBorder();
  scenegraph.updateNextFrame();
}
function selectEnd(scenegraph) {
  scenegraph.moveSelectingRangeComponentsToSelectedRangeComponents();
}

// node_modules/@visactor/vtable/es/ts-types/pivot-table/PIVOT_TABLE_EVENT_TYPE.js
var PIVOT_TABLE_EVENT_TYPE = extend(TABLE_EVENT_TYPE, {
  PIVOT_SORT_CLICK: "pivot_sort_click",
  DRILLMENU_CLICK: "drillmenu_click"
});
var PIVOT_CHART_EVENT_TYPE = extend(TABLE_EVENT_TYPE, {
  VCHART_EVENT_TYPE: "vchart_event_type"
});

// node_modules/@visactor/vtable/es/state/drill/index.js
function updateDrill(col, row, drillDown, drillUp, table) {
  const headerType = table.getCellLocation(col, row);
  let x = 0, y = 0, visible = false;
  "columnHeader" === headerType ? (x = table.getColsWidth(0, table.rowHeaderLevelCount - 1) - (0 === table.frozenColCount ? table.scrollLeft : 0), y = table.getRowsHeight(0, row - 1) + table.getRowHeight(row) / 2, visible = true) : "rowHeader" === headerType && (y = table.getRowsHeight(0, table.columnHeaderLevelCount - 1), x = table.getColsWidth(0, col - 1) + table.getColWidth(col) / 2, visible = true), table.scenegraph.updateDrill(visible, x, y, drillDown, drillUp);
}

// node_modules/@visactor/vtable/es/state/spark-line/index.js
function clearChartHover(col, row, table) {
  const sparkline = table.scenegraph.getCell(col, row).getChildByName("sparkline"), highlightLine = null == sparkline ? void 0 : sparkline.getChildByName("highlight-line"), highlightSymbol = null == sparkline ? void 0 : sparkline.getChildByName("highlight-symbol");
  highlightLine && highlightLine.setAttributes({
    visible: false,
    pickable: false
  }), highlightSymbol && highlightSymbol.setAttributes({
    visible: false,
    pickable: false
  }), table.scenegraph.updateNextFrame();
}
function updateChartHover(col, row, x, y, table) {
  var _a, _b;
  const sparkline = table.scenegraph.getCell(col, row).getChildByName("sparkline"), line = null == sparkline ? void 0 : sparkline.getChildByName("sparkline-line"), symbol = null == sparkline ? void 0 : sparkline.getChildByName("sparkline-symbol-group");
  if (!line) return false;
  const bandwidth = line.bandwidth, min2 = line.min, max2 = line.max, points = line.attribute.points;
  let chartPoint;
  x -= sparkline.globalAABBBounds.x1, sparkline.globalAABBBounds.y1;
  for (let i = 0; i < points.length; i++) {
    const { x: pointX, y: pointY, defined, rawData } = points[i];
    if (Math.abs(x - pointX) < bandwidth / 2 && (chartPoint = {
      point: points[i],
      points,
      pointsBandWidth: bandwidth,
      pointData: rawData
    }, defined)) {
      const highlightLine = sparkline.getChildByName("highlight-line");
      if (highlightLine) highlightLine.setAttributes({
        points: [{
          x: pointX,
          y: max2
        }, {
          x: pointX,
          y: min2
        }],
        visible: true,
        pickable: true
      });
      else {
        const highlightLine2 = createLine({
          points: [{
            x: pointX,
            y: max2
          }, {
            x: pointX,
            y: min2
          }],
          lineWidth: null === (_a = line.hover) || void 0 === _a ? void 0 : _a.strokeWidth,
          stroke: null === (_b = line.hover) || void 0 === _b ? void 0 : _b.stroke
        });
        highlightLine2.name = "highlight-line", sparkline.addChild(highlightLine2);
      }
      const highlightSymbol = sparkline.getChildByName("highlight-symbol");
      if (highlightSymbol) highlightSymbol.setAttributes({
        x: pointX,
        y: pointY,
        visible: true,
        pickable: true
      });
      else {
        const highlightSymbol2 = createSymbol({
          x: pointX,
          y: pointY,
          stroke: symbol.hover.stroke,
          lineWidth: symbol.hover.strokeWidth,
          fill: symbol.hover.fill,
          size: 2 * symbol.hover.size,
          symbolType: "circle"
        });
        highlightSymbol2.name = "highlight-symbol", sparkline.addChild(highlightSymbol2);
      }
      break;
    }
  }
  if (table.scenegraph.updateNextFrame(), chartPoint) {
    const eventInfo = {
      col,
      row,
      field: table.getHeaderField(col, row),
      value: table.getCellValue(col, row),
      dataValue: table.getCellOriginValue(col, row),
      cellHeaderPaths: table.internalProps.layoutMap.getCellHeaderPaths(col, row),
      title: table.getBodyColumnDefine(col, row).title,
      cellRange: table.getCellRelativeRect(col, row),
      sparkline: {
        pointData: chartPoint.pointData
      },
      scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth
    };
    table.fireListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL, eventInfo);
  }
  return true;
}

// node_modules/@visactor/vtable/es/state/cell-move/adjust-header.js
function adjustMoveHeaderTarget(source, target, table) {
  const sourceCellRange = table.getCellRange(source.col, source.row);
  if (table.isColumnHeader(source.col, source.row)) {
    const targetCellRange = table.getCellRange(target.col, sourceCellRange.start.row);
    target.row >= table.columnHeaderLevelCount && (target.row = table.columnHeaderLevelCount - 1), target.col >= source.col ? target.col = targetCellRange.end.col : target.col = targetCellRange.start.col;
  } else if (table.isRowHeader(source.col, source.row)) {
    const layoutMap = table.internalProps.layoutMap, targetCellRange = table.getCellRange(sourceCellRange.start.col, target.row);
    if (target.col >= table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount && (target.col = table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount - 1), "tree" === layoutMap.rowHierarchyType) {
      const sourceRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths, targetRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths;
      if (sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
        const targetPathNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1];
        targetPathNode && (target.row >= source.row ? target.row = targetPathNode.startInTotal + targetPathNode.size - 1 + table.columnHeaderLevelCount : target.row = targetPathNode.startInTotal + table.columnHeaderLevelCount);
      }
    } else target.row >= source.row ? target.row = targetCellRange.end.row : target.row = targetCellRange.start.row;
  }
  return target;
}

// node_modules/@visactor/vtable/es/state/cell-move/index.js
function startMoveCol(col, row, x, y, state, event2) {
  var _a;
  if (!("canMoveHeaderPosition" in state.table.internalProps.layoutMap)) return;
  state.columnMove.moving = true, state.columnMove.colSource = col, state.columnMove.rowSource = row, state.columnMove.x = x - state.table.tableX, state.columnMove.y = y - state.table.tableY;
  const cellLocation = state.table.getCellLocation(col, row), delta = "columnHeader" === cellLocation ? state.columnMove.x : "rowHeader" === cellLocation || state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row) ? state.columnMove.y : 0, { backX, lineX, backY, lineY } = state.table.scenegraph.component.showMoveCol(col, row, delta);
  state.table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_START, {
    col,
    row,
    x,
    y,
    backX,
    lineX,
    backY,
    lineY,
    event: event2
  });
  const isHasSelected = !!(null === (_a = state.select.ranges) || void 0 === _a ? void 0 : _a.length);
  state.table.stateManager.updateSelectPos(-1, -1), state.table.stateManager.endSelectCells(true, isHasSelected), state.table.scenegraph.updateNextFrame();
}
function updateMoveCol(col, row, x, y, state, event2) {
  if (!("canMoveHeaderPosition" in state.table.internalProps.layoutMap)) return;
  const targetCell = adjustMoveHeaderTarget({
    col: state.columnMove.colSource,
    row: state.columnMove.rowSource
  }, {
    col,
    row
  }, state.table);
  if (state.table.internalProps.layoutMap.canMoveHeaderPosition({
    col: state.columnMove.colSource,
    row: state.columnMove.rowSource
  }, {
    col: targetCell.col,
    row: targetCell.row
  })) {
    let lineX, backX, lineY, backY;
    state.columnMove.x = x - state.table.tableX, state.columnMove.y = y - state.table.tableY, state.columnMove.colTarget = targetCell.col, state.columnMove.rowTarget = targetCell.row, state.updateCursor("grabbing");
    const cellLocation = state.table.getCellLocation(state.columnMove.colSource, state.columnMove.rowSource);
    "columnHeader" === cellLocation ? (backX = state.columnMove.x, lineX = state.table.isLeftFrozenColumn(col) ? state.columnMove.colTarget >= state.columnMove.colSource ? state.table.getColsWidth(0, state.columnMove.colTarget) : state.table.getColsWidth(0, state.columnMove.colTarget - 1) : state.table.isRightFrozenColumn(col) ? state.table.tableNoFrameWidth - state.table.getColsWidth(targetCell.col + 1, state.table.colCount - 1) : (state.columnMove.colTarget >= state.columnMove.colSource ? state.table.getColsWidth(0, state.columnMove.colTarget) : state.table.getColsWidth(0, state.columnMove.colTarget - 1)) - state.table.stateManager.scroll.horizontalBarPos) : ("rowHeader" === cellLocation || state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) && (backY = state.columnMove.y, lineY = state.table.isFrozenRow(row) ? state.columnMove.rowTarget >= state.columnMove.rowSource ? state.table.getRowsHeight(0, state.columnMove.rowTarget) : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1) : state.table.isBottomFrozenRow(row) ? state.table.tableNoFrameHeight - state.table.getRowsHeight(targetCell.row + 1, state.table.rowCount - 1) : (state.columnMove.rowTarget >= state.columnMove.rowSource ? state.table.getRowsHeight(0, state.columnMove.rowTarget) : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1)) - state.table.stateManager.scroll.verticalBarPos), state.table.scenegraph.component.updateMoveCol(backX, lineX, backY, lineY), state.table.fireListeners(TABLE_EVENT_TYPE.CHANGING_HEADER_POSITION, {
      col,
      row,
      x,
      y,
      backX,
      lineX,
      backY,
      lineY,
      event: event2
    }), state.table.scenegraph.updateNextFrame();
  } else state.updateCursor("not-allowed"), state.columnMove.colTarget = state.columnMove.colSource, state.columnMove.rowTarget = state.columnMove.rowSource;
}
function endMoveCol(state) {
  var _a, _b;
  let moveColResult = false;
  if ("canMoveHeaderPosition" in state.table.internalProps.layoutMap && state.columnMove.moving && state.columnMove.colSource >= 0 && state.columnMove.rowSource >= 0 && state.columnMove.colTarget >= 0 && state.columnMove.rowTarget >= 0 && true !== (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a.notUpdateInColumnRowMove)) {
    const oldSourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource), oldTargetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget), moveContext = state.table._moveHeaderPosition({
      col: state.columnMove.colSource,
      row: state.columnMove.rowSource
    }, {
      col: state.columnMove.colTarget,
      row: state.columnMove.rowTarget
    });
    if (!moveContext || moveContext.targetIndex === moveContext.sourceIndex) return state.updateCursor(), state.columnMove.moving = false, delete state.columnMove.colSource, delete state.columnMove.rowSource, delete state.columnMove.colTarget, delete state.columnMove.rowTarget, state.table.scenegraph.component.hideMoveCol(), state.table.scenegraph.updateNextFrame(), false;
    {
      state.table.internalProps.useOneRowHeightFillAll = false, state.table.internalProps.layoutMap.clearCellRangeMap();
      const sourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource), targetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget), colMin = Math.min(sourceMergeInfo.start.col, targetMergeInfo.start.col, oldSourceMergeInfo.start.col, oldTargetMergeInfo.start.col), colMax = Math.max(sourceMergeInfo.end.col, targetMergeInfo.end.col, oldSourceMergeInfo.end.col, oldTargetMergeInfo.end.col), rowMin = Math.min(sourceMergeInfo.start.row, targetMergeInfo.start.row, oldSourceMergeInfo.start.row, oldTargetMergeInfo.start.row);
      let rowMax = Math.max(sourceMergeInfo.end.row, targetMergeInfo.end.row, oldSourceMergeInfo.end.row, oldTargetMergeInfo.end.row);
      "row" === moveContext.moveType && "tree" === state.table.internalProps.layoutMap.rowHierarchyType && (rowMax = moveContext.targetIndex > moveContext.sourceIndex ? rowMax + moveContext.targetSize - 1 : rowMax + moveContext.sourceSize - 1), !state.table.transpose && state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource) && (state.table.changeRecordOrder(moveContext.sourceIndex, moveContext.targetIndex), state.changeCheckboxAndRadioOrder(moveContext.sourceIndex, moveContext.targetIndex)), "column" === moveContext.moveType ? clearWidthsAndHeightsCache(colMin, colMax, 0, -1, state.table) : clearWidthsAndHeightsCache(0, -1, rowMin, rowMax, state.table), state.table.clearCellStyleCache(), state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource) ? state.table.scenegraph.updateHeaderPosition(state.table.scenegraph.proxy.colStart, state.table.scenegraph.proxy.colEnd, state.table.scenegraph.proxy.rowStart, state.table.scenegraph.proxy.rowEnd, moveContext.moveType) : "column" === moveContext.moveType ? state.table.scenegraph.updateHeaderPosition(colMin, colMax, 0, -1, moveContext.moveType) : state.table.scenegraph.updateHeaderPosition(0, -1, rowMin, rowMax, moveContext.moveType), "adjustFrozenCount" === state.table.internalProps.frozenColDragHeaderMode && state.table.isListTable() && (state.table.isLeftFrozenColumn(state.columnMove.colTarget) && !state.table.isLeftFrozenColumn(state.columnMove.colSource) ? state.table.frozenColCount += sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1 : state.table.isLeftFrozenColumn(state.columnMove.colSource) && !state.table.isLeftFrozenColumn(state.columnMove.colTarget) && (state.table.frozenColCount -= sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1), state.table.isRightFrozenColumn(state.columnMove.colTarget) && !state.table.isRightFrozenColumn(state.columnMove.colSource) ? state.table.rightFrozenColCount += sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1 : state.table.isRightFrozenColumn(state.columnMove.colSource) && !state.table.isRightFrozenColumn(state.columnMove.colTarget) && (state.table.rightFrozenColCount -= sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1)), moveColResult = true;
    }
  }
  return state.columnMove.moving = false, setTimeout(() => {
    delete state.columnMove.colSource, delete state.columnMove.rowSource, delete state.columnMove.colTarget, delete state.columnMove.rowTarget;
  }, 0), state.table.scenegraph.component.hideMoveCol(), state.columnResize.col < state.table.frozenColCount && !state.table.isPivotTable() && !state.table.transpose ? (state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen), state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount)) : state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount && !state.table.isPivotTable() && !state.table.transpose ? state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount) : state.table.options.frozenColCount ? state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1) : state.table.options.rightFrozenColCount && state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount), state.table.scenegraph.updateNextFrame(), true === (null === (_b = state.table.options.customConfig) || void 0 === _b ? void 0 : _b.notUpdateInColumnRowMove) || moveColResult;
}
function clearWidthsAndHeightsCache(colMin, colMax, rowMin, rowMax, table) {
  for (let col = colMin; col <= colMax; col++) table._clearColRangeWidthsMap(col);
  for (let row = rowMin; row <= rowMax; row++) table._clearRowRangeHeightsMap(row);
}

// node_modules/@visactor/vtable/es/scenegraph/utils/icon.js
function getIconAndPositionFromTarget(target) {
  var _a;
  if (!target) return;
  const icon2 = (null === (_a = target.role) || void 0 === _a ? void 0 : _a.startsWith("icon")) ? target : "richtext" === target.type ? target._currentHoverIcon : void 0;
  return icon2 ? "richtext" === target.type ? {
    icon: icon2,
    position: {
      left: target.globalAABBBounds.x1 + icon2.globalAABBBounds.x1,
      right: target.globalAABBBounds.x1 + icon2.globalAABBBounds.x2,
      top: target.globalAABBBounds.y1 + icon2.globalAABBBounds.y1,
      bottom: target.globalAABBBounds.y1 + icon2.globalAABBBounds.y2,
      width: icon2.globalAABBBounds.x2 - icon2.globalAABBBounds.x1,
      height: icon2.globalAABBBounds.y2 - icon2.globalAABBBounds.y1
    },
    type: "richtext-icon"
  } : {
    icon: icon2,
    position: {
      left: icon2.globalAABBBounds.x1,
      right: icon2.globalAABBBounds.x2,
      top: icon2.globalAABBBounds.y1,
      bottom: icon2.globalAABBBounds.y2,
      width: icon2.globalAABBBounds.x2 - icon2.globalAABBBounds.x1,
      height: icon2.globalAABBBounds.y2 - icon2.globalAABBBounds.y1
    },
    type: "icon"
  } : void 0;
}

// node_modules/@visactor/vtable/es/state/resize/update-resize-column.js
function updateResizeColumn(xInTable, yInTable, state) {
  xInTable = Math.ceil(xInTable), yInTable = Math.ceil(yInTable);
  let detaX = state.columnResize.isRightFrozen ? state.columnResize.x - xInTable : xInTable - state.columnResize.x;
  if (Math.abs(detaX) < 1) return;
  const widthCache = state.table.getColWidth(state.columnResize.col);
  let width = widthCache;
  width += detaX;
  const minWidth = state.table.getMinColWidth(state.columnResize.col), maxWidth = state.table.getMaxColWidth(state.columnResize.col);
  if (width < minWidth || width > maxWidth) {
    if (widthCache === minWidth || widthCache === maxWidth) return;
    detaX = widthCache - minWidth > maxWidth - widthCache ? maxWidth - widthCache : minWidth - widthCache;
  }
  let afterSize = state.table.getColWidth(state.columnResize.col) + detaX;
  if (afterSize < state.table.internalProps.limitMinWidth && (afterSize = state.table.internalProps.limitMinWidth, detaX = afterSize - state.table.getColWidth(state.columnResize.col)), "adaptive" === state.table.widthMode && state.columnResize.col < state.table.colCount - 1) {
    const rightColWidthCache = state.table.getColWidth(state.columnResize.col + 1), rightColMinWidth = state.table.getMinColWidth(state.columnResize.col + 1), rightColMaxWidth = state.table.getMaxColWidth(state.columnResize.col + 1);
    let rightColWidth = rightColWidthCache;
    if (rightColWidth -= detaX, rightColWidth < rightColMinWidth || rightColWidth > rightColMaxWidth) {
      if (rightColWidthCache === rightColMinWidth || rightColWidthCache === rightColMaxWidth) return;
      detaX = rightColWidthCache - rightColMinWidth > rightColMaxWidth - rightColWidthCache ? rightColMaxWidth - rightColWidthCache : rightColMinWidth - rightColWidthCache;
    }
    rightColWidth - detaX < state.table.internalProps.limitMinWidth && (detaX = rightColWidth - state.table.internalProps.limitMinWidth);
  }
  detaX = Math.ceil(detaX), state.columnResize.col < state.table.rowHeaderLevelCount || state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount ? updateResizeColForColumn(detaX, state) : "indicator" === state.table.internalProps.columnResizeType ? updateResizeColForIndicator(detaX, state) : "indicatorGroup" === state.table.internalProps.columnResizeType ? updateResizeColForIndicatorGroup(detaX, state) : "all" === state.table.internalProps.columnResizeType ? updateResizeColForAll(detaX, state) : updateResizeColForColumn(detaX, state), state.columnResize.x = xInTable, state.table.scenegraph.component.updateResizeCol(state.columnResize.col, yInTable, state.columnResize.isRightFrozen), state.columnResize.col < state.table.frozenColCount && !state.table.isPivotTable() && !state.table.transpose ? state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen) : state.table.options.frozenColCount && state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1), (state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount && !state.table.isPivotTable() && !state.table.transpose || state.table.options.rightFrozenColCount) && state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount), state.table.scenegraph.updateNextFrame();
}
function updateResizeColForColumn(detaX, state) {
  "adaptive" === state.table.widthMode && state.columnResize.col < state.table.colCount - 1 ? (state.table.scenegraph.updateColWidth(state.columnResize.col, detaX), state.table.scenegraph.updateColWidth(state.columnResize.col + 1, -detaX), state.table.internalProps._widthResizedColMap.add(state.columnResize.col), state.table.internalProps._widthResizedColMap.add(state.columnResize.col + 1)) : (state.table.scenegraph.updateColWidth(state.columnResize.col, detaX), state.table.internalProps._widthResizedColMap.add(state.columnResize.col));
}
function updateResizeColForAll(detaX, state) {
  const layout = state.table.internalProps.layoutMap;
  for (let col = state.table.frozenColCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
    if (!(state.table.internalProps.transpose || state.table.isPivotTable() && !layout.indicatorsAsCol)) {
      const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
      if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) continue;
    }
    state.table.scenegraph.updateColWidth(col, detaX), state.table.internalProps._widthResizedColMap.add(col);
  }
}
function updateResizeColForIndicator(detaX, state) {
  const layout = state.table.internalProps.layoutMap;
  let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue;
  if (layout.indicatorsAsCol) resizeIndicatorKey = layout.getIndicatorKey(state.columnResize.col, state.table.columnHeaderLevelCount);
  else {
    const headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount - 1), headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
    resizeDimensionKey = headerPath.dimensionKey, resizeDimensionValue = headerPath.value;
  }
  for (let col = state.table.rowHeaderLevelCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
    const indicatorKey = layout.getIndicatorKey(col, state.table.columnHeaderLevelCount);
    if (layout.indicatorsAsCol && indicatorKey === resizeIndicatorKey) state.table.scenegraph.updateColWidth(col, detaX), state.table.internalProps._widthResizedColMap.add(col);
    else if (!layout.indicatorsAsCol) {
      const headerPaths = layout.getCellHeaderPaths(col, state.table.columnHeaderLevelCount - 1), headerPath = null == headerPaths ? void 0 : headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
      headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value && (state.table.scenegraph.updateColWidth(col, detaX), state.table.internalProps._widthResizedColMap.add(col));
    }
  }
}
function updateResizeColForIndicatorGroup(detaX, state) {
  const layout = state.table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1)), startCol = node.startInTotal + state.table.frozenColCount, endCol = node.startInTotal + state.table.frozenColCount + node.size - 1, totalColWidth = state.table.getColsWidth(startCol, endCol), moveX = detaX;
  for (let col = startCol; col <= endCol; col++) {
    if (!(state.table.internalProps.transpose || state.table.isPivotTable() && !layout.indicatorsAsCol)) {
      const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
      if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) continue;
    }
    let deltaWidth = state.table.getColWidth(col) / totalColWidth * moveX;
    deltaWidth > 0 && deltaWidth < 0.5 ? deltaWidth = 0.5 : deltaWidth < 0 && deltaWidth >= -0.5 && (deltaWidth = -0.5), state.table.scenegraph.updateColWidth(col, deltaWidth), state.table.internalProps._widthResizedColMap.add(col);
  }
}

// node_modules/@visactor/vtable/es/state/radio/radio.js
function setRadioState(col, row, field, type, indexInCell, state) {
  const recordIndex = state.table.getRecordShowIndexByCell(col, row);
  if (recordIndex >= 0) {
    const dataIndex = state.table.dataSource.getIndexKey(recordIndex);
    "column" === type ? isNumber_default(indexInCell) ? (state.radioState[field] = {}, state.radioState[field][dataIndex] = indexInCell) : state.radioState[field] = dataIndex : (state.radioState[field] || (state.radioState[field] = {}), isNumber_default(indexInCell) ? state.radioState[field][dataIndex] = indexInCell : state.radioState[field][dataIndex] = true);
  }
}
function getCellRadioState(col, row, table) {
  var _a;
  const define = table.getBodyColumnDefine(col, row), field = null == define ? void 0 : define.field, cellType = table.getCellType(col, row);
  if (isValid_default(field) && "radio" === cellType) {
    const dataIndex = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row)), columnState = null === (_a = table.stateManager.radioState) || void 0 === _a ? void 0 : _a[field];
    if (isNumber_default(columnState)) {
      if (columnState === dataIndex) return true;
    } else if (isObject_default(columnState)) {
      const cellState = columnState[dataIndex];
      if (isNumber_default(cellState)) return cellState;
    }
  }
  return false;
}
function syncRadioState(col, row, field, type, indexInCell, isChecked, state) {
  var _a, _b, _c, _d, _e;
  const recordIndex = state.table.getRecordShowIndexByCell(col, row);
  if (recordIndex >= 0) {
    const dataIndex = state.table.dataSource.getIndexKey(recordIndex);
    if ("column" === type) {
      if (!isValid_default(state.radioState[field]) && isChecked) return isNumber_default(indexInCell) ? (state.radioState[field] = {}, state.radioState[field][dataIndex] = indexInCell) : state.radioState[field] = dataIndex, true;
      if (isNumber_default(state.radioState[field]) && !isNumber_default(indexInCell)) return state.radioState[field] === dataIndex;
      if (isNumber_default(state.radioState[field]) && isNumber_default(indexInCell)) return false;
      if (isObject_default(state.radioState[field]) && !isNumber_default(indexInCell)) return false;
      if (isObject_default(state.radioState[field]) && isNumber_default(indexInCell)) return state.radioState[field][dataIndex] === indexInCell;
    } else if ("cell" === type) {
      if (!isValid_default(state.radioState[field]) && isChecked) return state.radioState[field] = {}, isNumber_default(indexInCell) ? state.radioState[field][dataIndex] = indexInCell : state.radioState[field][dataIndex] = true, true;
      if (!isValid_default(null === (_a = state.radioState[field]) || void 0 === _a ? void 0 : _a[dataIndex]) && isChecked) return isNumber_default(indexInCell) ? state.radioState[field][dataIndex] = indexInCell : state.radioState[field][dataIndex] = true, true;
      if (isBoolean_default(null === (_b = state.radioState[field]) || void 0 === _b ? void 0 : _b[dataIndex]) && !isNumber_default(indexInCell)) return state.radioState[field][dataIndex];
      if (isBoolean_default(null === (_c = state.radioState[field]) || void 0 === _c ? void 0 : _c[dataIndex]) && isNumber_default(indexInCell)) return false;
      if (isNumber_default(null === (_d = state.radioState[field]) || void 0 === _d ? void 0 : _d[dataIndex]) && !isNumber_default(indexInCell)) return false;
      if (isNumber_default(null === (_e = state.radioState[field]) || void 0 === _e ? void 0 : _e[dataIndex]) && isNumber_default(indexInCell)) return state.radioState[field][dataIndex] === indexInCell;
    }
  }
  return isChecked;
}
function setCellRadioState(col, row, index, table) {
  const cellGoup = table.scenegraph.getCell(col, row);
  if (cellGoup) if (isNumber_default(index)) {
    const radio = cellGoup.getChildAt(index);
    null == radio || radio._handlePointerUp();
  } else {
    const radio = cellGoup.getChildByName("radio");
    null == radio || radio._handlePointerUp();
  }
}
function changeRadioOrder(sourceIndex, targetIndex, state) {
  const { radioState, table } = state;
  if (table.internalProps.transpose ? (sourceIndex = table.getRecordShowIndexByCell(sourceIndex, 0), targetIndex = table.getRecordShowIndexByCell(targetIndex, 0)) : (sourceIndex = table.getRecordShowIndexByCell(0, sourceIndex), targetIndex = table.getRecordShowIndexByCell(0, targetIndex)), sourceIndex > targetIndex) {
    const sourceRecord = radioState[sourceIndex];
    for (let i = sourceIndex; i > targetIndex; i--) radioState[i] = radioState[i - 1];
    radioState[targetIndex] = sourceRecord;
  } else if (sourceIndex < targetIndex) {
    const sourceRecord = radioState[sourceIndex];
    for (let i = sourceIndex; i < targetIndex; i++) radioState[i] = radioState[i + 1];
    radioState[targetIndex] = sourceRecord;
  }
}

// node_modules/@visactor/vtable/es/state/checkbox/checkbox.js
function setCheckedState(col, row, field, checked, state) {
  const cellRange = state.table.getCellRange(col, row);
  if (cellRange.start.col !== cellRange.end.col || cellRange.start.row !== cellRange.end.row) for (let i = cellRange.start.col; i <= cellRange.end.col; i++) for (let j = cellRange.start.row; j <= cellRange.end.row; j++) setSingleCheckedState(i, j, field, checked, state);
  else setSingleCheckedState(col, row, field, checked, state);
}
function setSingleCheckedState(col, row, field, checked, state) {
  const recordIndex = state.table.getRecordShowIndexByCell(col, row);
  if (recordIndex >= 0) {
    const dataIndex = state.table.dataSource.getIndexKey(recordIndex).toString();
    state.checkedState.get(dataIndex) ? state.checkedState.get(dataIndex)[field] = checked : state.checkedState.set(dataIndex, {
      [field]: checked
    });
  }
}
function setHeaderCheckedState(field, checked, state) {
  var _a;
  state.headerCheckedState[field] = checked, null === (_a = state.checkedState) || void 0 === _a || _a.forEach((recordCheckState) => {
    recordCheckState[field] = checked;
  });
}
function syncCheckedState(col, row, field, checked, state) {
  var _a, _b;
  if (state.table.isHeader(col, row)) {
    if (isValid_default(state.headerCheckedState[field])) return state.headerCheckedState[field];
    if ("function" == typeof checked) return;
    if (isValid_default(checked)) state.headerCheckedState[field] = checked;
    else if ((null === (_a = state.checkedState) || void 0 === _a ? void 0 : _a.size) > 0) {
      return state.updateHeaderCheckedState(field, col, row);
    }
    return state.headerCheckedState[field];
  }
  const recordIndex = state.table.getRecordShowIndexByCell(col, row);
  if (recordIndex >= 0) {
    const dataIndex = state.table.dataSource.getIndexKey(recordIndex).toString();
    if (isValid_default(null === (_b = state.checkedState.get(dataIndex)) || void 0 === _b ? void 0 : _b[field])) return state.checkedState.get(dataIndex)[field];
    if (state.checkedState.get(dataIndex)) state.checkedState.get(dataIndex)[field] = checked;
    else if (dataIndex.includes(",")) {
      const parentDataIndex = dataIndex.split(",").slice(0, -1).join(",");
      state.checkedState.has(parentDataIndex) && true === state.checkedState.get(parentDataIndex)[field] ? state.checkedState.set(dataIndex, {
        [field]: true
      }) : state.checkedState.set(dataIndex, {
        [field]: checked
      });
    } else state.checkedState.set(dataIndex, {
      [field]: checked
    });
  }
  return checked;
}
function initCheckedState(records, state) {
  state.checkedState.clear(), state.headerCheckedState = {}, state.radioState = {};
  let isNeedInitHeaderCheckedStateFromRecord = false;
  if (state._checkboxCellTypeFields = [], state._headerCheckFuncs = {}, state.table.internalProps.layoutMap.headerObjects.forEach((hd, index) => {
    if ("checkbox" === hd.headerType) {
      const headerChecked = hd.define.checked;
      null == headerChecked || "function" == typeof headerChecked ? (isNeedInitHeaderCheckedStateFromRecord = true, "function" == typeof headerChecked && (state._headerCheckFuncs[hd.field] = headerChecked)) : state.headerCheckedState[hd.field] = headerChecked, "checkbox" !== hd.define.cellType && !isFunction_default(hd.define.cellType) || hd.fieldFormat || state._checkboxCellTypeFields.push(hd.field);
    }
  }), 1 === state.table.leftRowSeriesNumberCount) state.headerCheckedState._vtable_rowSeries_number = false, state._checkboxCellTypeFields.push("_vtable_rowSeries_number"), isNeedInitHeaderCheckedStateFromRecord = true;
  else if (state.table.leftRowSeriesNumberCount > 1) {
    for (let i = 0; i < state.table.leftRowSeriesNumberCount; i++) state.headerCheckedState[`_vtable_rowSeries_number_${i}`] = false, state._checkboxCellTypeFields.push(`_vtable_rowSeries_number_${i}`);
    isNeedInitHeaderCheckedStateFromRecord = true;
  }
  isNeedInitHeaderCheckedStateFromRecord && initRecordCheckState(records, state);
}
function updateHeaderCheckedState(field, state, col, row) {
  let allChecked = true, allUnChecked = true, hasChecked = false;
  return state.checkedState.forEach((check_state, index) => {
    var _a, _b;
    index = index.includes(",") ? index.split(",").map((item) => Number(item)) : Number(index);
    const tableIndex = state.table.getTableIndexByRecordIndex(index), mergeCell = state.table.transpose ? state.table.getCustomMerge(tableIndex, row) : state.table.getCustomMerge(col, tableIndex), data = null === (_a = state.table.dataSource) || void 0 === _a ? void 0 : _a.get(index);
    mergeCell || !(null === (_b = state.table.internalProps.rowSeriesNumber) || void 0 === _b ? void 0 : _b.enableTreeCheckbox) && (null == data ? void 0 : data.vtableMerge) || (true !== (null == check_state ? void 0 : check_state[field]) ? allChecked = false : (allUnChecked = false, hasChecked = true));
  }), allChecked ? (state.headerCheckedState[field] = true, allChecked) : allUnChecked ? (state.headerCheckedState[field] = false, false) : !!hasChecked && (state.headerCheckedState[field] = "indeterminate", "indeterminate");
}
function initLeftRecordsCheckState(records, state) {
  for (let index = state.checkedState.size; index < records.length; index++) {
    const record = records[index];
    state._checkboxCellTypeFields.forEach((field) => {
      const value = record[field];
      let isChecked;
      isObject_default(value) ? isChecked = value.checked : "boolean" == typeof value && (isChecked = value);
      const dataIndex = index.toString();
      state.checkedState.get(dataIndex) || state.checkedState.set(dataIndex, {}), state.checkedState.get(dataIndex)[field] = isChecked;
    });
  }
}
function setCellCheckboxState(col, row, checked, table) {
  const cellGroup = table.scenegraph.getCell(col, row), checkbox = null == cellGroup ? void 0 : cellGroup.getChildByName("checkbox");
  if (!checkbox) {
    const field = table.getHeaderField(col, row);
    if (table.isHeader(col, row)) {
      table.stateManager.setHeaderCheckedState(field, checked);
      "checkbox" === table.getCellType(col, row) && table.scenegraph.updateCheckboxCellState(col, row, checked);
    } else {
      table.stateManager.setCheckedState(col, row, field, checked);
      if ("checkbox" === table.getCellType(col, row)) {
        const oldHeaderCheckedState = table.stateManager.headerCheckedState[field], newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(field, col, row);
        oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
      }
    }
    return;
  }
  const { checked: oldChecked, indeterminate } = checkbox.attribute;
  indeterminate ? (checked || checkbox._handlePointerUp(), checkbox._handlePointerUp()) : oldChecked ? checked || checkbox._handlePointerUp() : checked && checkbox._handlePointerUp();
}
function setCellCheckboxStateByAttribute(col, row, checked, table) {
  const cellGroup = table.scenegraph.getCell(col, row), checkbox = null == cellGroup ? void 0 : cellGroup.getChildByName("checkbox");
  checkbox && ("indeterminate" === checked ? (checkbox.setAttribute("indeterminate", true), checkbox.setAttribute("checked", void 0)) : (checkbox.setAttribute("indeterminate", void 0), checkbox.setAttribute("checked", checked)));
}
function changeCheckboxOrder(sourceIndex, targetIndex, state) {
  const { checkedState, table } = state;
  let source, target;
  if (table.internalProps.transpose ? (sourceIndex = table.getRecordShowIndexByCell(sourceIndex, 0), targetIndex = table.getRecordShowIndexByCell(targetIndex, 0)) : (source = table.isPivotTable() ? void 0 : table.getRecordIndexByCell(0, sourceIndex), target = table.isPivotTable() ? void 0 : table.getRecordIndexByCell(0, targetIndex)), isNumber_default(source) && isNumber_default(target)) {
    if ((sourceIndex = source) > (targetIndex = target)) {
      const sourceRecord = checkedState.get(sourceIndex.toString());
      for (let i = sourceIndex; i > targetIndex; i--) checkedState.set(i.toString(), checkedState.get((i - 1).toString()));
      checkedState.set(targetIndex.toString(), sourceRecord);
    } else if (sourceIndex < targetIndex) {
      const sourceRecord = checkedState.get(sourceIndex.toString());
      for (let i = sourceIndex; i < targetIndex; i++) checkedState.set(i.toString(), checkedState.get((i + 1).toString()));
      checkedState.set(targetIndex.toString(), sourceRecord);
    }
  } else if (isArray_default(source) && isArray_default(target)) {
    if ((sourceIndex = source[source.length - 1]) > (targetIndex = target[target.length - 1])) {
      const sourceRecord = checkedState.get(source.toString());
      for (let i = sourceIndex; i > targetIndex; i--) {
        const now = [...source];
        now[now.length - 1] = i;
        const last2 = [...source];
        last2[last2.length - 1] = i - 1, checkedState.set(now.toString(), checkedState.get(last2.toString()));
      }
      checkedState.set(target.toString(), sourceRecord);
    } else if (sourceIndex < targetIndex) {
      const sourceRecord = checkedState.get(source.toString());
      for (let i = sourceIndex; i < targetIndex; i++) {
        const now = [...source];
        now[now.length - 1] = i;
        const next = [...source];
        next[next.length - 1] = i + 1, checkedState.set(now.toString(), checkedState.get(next.toString()));
      }
      checkedState.set(target.toString(), sourceRecord);
    }
  }
}
function getGroupCheckboxState(table) {
  const result2 = [], dataSource = table.dataSource, groupKeyLength = dataSource.dataConfig.groupByRules.length + 1;
  return dataSource.currentIndexedData.forEach((indexArr, index) => {
    if (isArray_default(indexArr) && indexArr.length === groupKeyLength) {
      const vtableOriginIndex = dataSource.getOriginRecordIndexForGroup(indexArr);
      result2[vtableOriginIndex] = table.stateManager.checkedState.get(indexArr.toString());
    }
  }), result2;
}
function initRecordCheckState(records, state) {
  const table = state.table, start = table.isPivotTable() ? 0 : table.internalProps.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, end = table.isPivotTable() ? isArray_default(records) ? records.length : 0 : table.internalProps.transpose ? table.colCount : table.rowCount;
  for (let index = 0; index + start < end; index++) {
    const record = table.isPivotTable() ? records[index] : table.dataSource.get(index);
    state._checkboxCellTypeFields.forEach((field) => {
      const value = record && record[field];
      let isChecked;
      if (isObject_default(value) ? isChecked = value.checked : "boolean" == typeof value && (isChecked = value), null == isChecked) {
        const headerCheckFunc = state._headerCheckFuncs[field];
        if (headerCheckFunc) {
          const cellAddr = state.table.getCellAddrByFieldRecord(field, index);
          isChecked = getOrApply(headerCheckFunc, {
            col: cellAddr.col,
            row: cellAddr.row,
            table: state.table,
            context: null,
            value
          });
        }
      }
      const dataIndex = table.isPivotTable() ? index.toString() : state.table.dataSource.getIndexKey(index).toString();
      state.checkedState.get(dataIndex) || state.checkedState.set(dataIndex, {}), state.checkedState.get(dataIndex)[field] = isChecked;
    });
  }
}

// node_modules/@visactor/vtable/es/state/resize/update-resize-row.js
function updateResizeRow(xInTable, yInTable, state) {
  xInTable = Math.ceil(xInTable), yInTable = Math.ceil(yInTable);
  let detaY = state.rowResize.isBottomFrozen ? state.rowResize.y - yInTable : yInTable - state.rowResize.y;
  if (Math.abs(detaY) < 1) return;
  let height = state.table.getRowHeight(state.rowResize.row);
  height += detaY;
  let afterSize = state.table.getRowHeight(state.rowResize.row) + detaY;
  if (afterSize < state.table.internalProps.limitMinHeight && (afterSize = state.table.internalProps.limitMinHeight, detaY = afterSize - state.table.getRowHeight(state.rowResize.row)), "adaptive" === state.table.heightMode && state.rowResize.row < state.table.rowCount - 1) {
    let bottomRowHeight = state.table.getRowHeight(state.rowResize.row + 1);
    bottomRowHeight -= detaY, bottomRowHeight - detaY < state.table.internalProps.limitMinHeight && (detaY = bottomRowHeight - state.table.internalProps.limitMinHeight);
  }
  detaY = Math.ceil(detaY), state.rowResize.row < state.table.columnHeaderLevelCount || state.rowResize.row >= state.table.rowCount - state.table.bottomFrozenRowCount ? updateResizeColForRow(detaY, state) : "indicator" === state.table.internalProps.rowResizeType ? updateResizeColForIndicator2(detaY, state) : "indicatorGroup" === state.table.internalProps.rowResizeType ? updateResizeColForIndicatorGroup2(detaY, state) : "all" === state.table.internalProps.rowResizeType ? updateResizeColForAll2(detaY, state) : updateResizeColForRow(detaY, state), state.rowResize.y = yInTable, state.table.scenegraph.component.updateResizeRow(state.rowResize.row, xInTable, state.rowResize.isBottomFrozen), state.table.scenegraph.updateNextFrame();
}
function updateResizeColForRow(detaY, state) {
  "adaptive" === state.table.heightMode && state.rowResize.row < state.table.rowCount - 1 ? (state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY), state.table.scenegraph.updateRowHeight(state.rowResize.row + 1, -detaY), state.table.internalProps._heightResizedRowMap.add(state.rowResize.row), state.table.internalProps._heightResizedRowMap.add(state.rowResize.row + 1)) : (state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY), state.table.internalProps._heightResizedRowMap.add(state.rowResize.row));
}
function updateResizeColForAll2(detaY, state) {
  for (let row = state.table.frozenRowCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) state.table.scenegraph.updateRowHeight(row, detaY), state.table.internalProps._heightResizedRowMap.add(row);
}
function updateResizeColForIndicator2(detaY, state) {
  var _a, _b;
  const layout = state.table.internalProps.layoutMap;
  let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue;
  if (layout.indicatorsAsCol) {
    const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, state.rowResize.row), headerPath = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a[headerPaths.rowHeaderPaths.length - 1];
    resizeDimensionKey = null == headerPath ? void 0 : headerPath.dimensionKey, resizeDimensionValue = null == headerPath ? void 0 : headerPath.value;
  } else resizeIndicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, state.rowResize.row);
  for (let row = state.table.columnHeaderLevelCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) {
    const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, row);
    if (layout.indicatorsAsCol || indicatorKey !== resizeIndicatorKey) {
      if (layout.indicatorsAsCol) {
        const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, row), headerPath = null === (_b = null == headerPaths ? void 0 : headerPaths.rowHeaderPaths) || void 0 === _b ? void 0 : _b[headerPaths.rowHeaderPaths.length - 1];
        headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value && (state.table.scenegraph.updateRowHeight(row, detaY), state.table.internalProps._heightResizedRowMap.add(row));
      }
    } else state.table.scenegraph.updateRowHeight(row, detaY), state.table.internalProps._heightResizedRowMap.add(row);
  }
}
function updateResizeColForIndicatorGroup2(detaY, state) {
  const layout = state.table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount, state.rowResize.row), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1)), startRow = node.startInTotal + state.table.frozenRowCount, endRow = node.startInTotal + state.table.frozenRowCount + node.size - 1, totalRowHeight = state.table.getRowsHeight(startRow, endRow), moveY = detaY;
  for (let row = startRow; row <= endRow; row++) {
    let deltaHeight = state.table.getRowHeight(row) / totalRowHeight * moveY;
    deltaHeight > 0 && deltaHeight < 0.5 ? deltaHeight = 0.5 : deltaHeight < 0 && deltaHeight >= -0.5 && (deltaHeight = -0.51), state.table.scenegraph.updateRowHeight(row, deltaHeight), state.table.internalProps._heightResizedRowMap.add(row);
  }
}

// node_modules/@visactor/vtable/es/state/select/custom-select.js
function deletaCustomSelectRanges(state) {
  const { customSelectedRangeComponents } = state.table.scenegraph;
  customSelectedRangeComponents.forEach((selectComp, key) => {
    selectComp.rect.delete();
  }), customSelectedRangeComponents.clear(), state.select.customSelectRanges = [];
}
function addCustomSelectRanges(customSelectRanges, state) {
  const { customSelectedRangeComponents } = state.table.scenegraph;
  customSelectRanges.forEach((customRange) => {
    var _a, _b, _c, _d;
    const { range: range5, style: style2 } = customRange, rect = createRect({
      fill: null !== (_a = style2.cellBgColor) && void 0 !== _a && _a,
      stroke: null !== (_b = style2.cellBorderColor) && void 0 !== _b && _b,
      lineWidth: null !== (_c = style2.cellBorderLineWidth) && void 0 !== _c ? _c : 0,
      lineDash: null !== (_d = style2.cellBorderLineDash) && void 0 !== _d ? _d : [],
      pickable: false
    });
    customSelectedRangeComponents.set(`${range5.start.col}-${range5.start.row}-${range5.end.col}-${range5.end.row}`, {
      rect,
      role: "body"
    });
  }), state.select.customSelectRanges = customSelectRanges, updateAllSelectComponent(state.table.scenegraph), state.table.scenegraph.updateNextFrame();
}

// node_modules/@visactor/vtable/es/state/state.js
var StateManager = class {
  constructor(table) {
    this.fastScrolling = false, this.checkedState = /* @__PURE__ */ new Map(), this.headerCheckedState = {}, this._checkboxCellTypeFields = [], this._headerCheckFuncs = {}, this.radioState = {}, this.resetInteractionState = debounce((state) => {
      this.updateInteractionState(null != state ? state : InteractionState.default);
    }, 100), this.table = table, this.initState(), this.updateVerticalScrollBar = this.updateVerticalScrollBar.bind(this), this.updateHorizontalScrollBar = this.updateHorizontalScrollBar.bind(this);
  }
  initState() {
    this._initState(), this.setHoverState(), this.setSelectState(), this.setFrozenState();
  }
  updateOptionSetState() {
    this._updateOptionSetState(), this.setHoverState(), this.setSelectState(), this.setFrozenState();
  }
  _updateOptionSetState() {
    this.interactionState = InteractionState.default, this.hoverIcon = {
      col: -1,
      row: -1,
      icon: null
    }, this.columnResize = {
      col: -1,
      x: 0,
      resizing: false
    }, this.rowResize = {
      row: -1,
      y: 0,
      resizing: false
    }, this.columnMove = {
      colSource: -1,
      colTarget: -1,
      rowSource: -1,
      rowTarget: -1,
      x: 0,
      y: 0,
      moving: false
    }, this.menu = {
      x: -1,
      y: -1,
      isShow: false,
      itemList: [],
      bounds: new Bounds(),
      highlightIndex: -1,
      dropDownMenuHighlight: []
    }, this.sort = [{
      col: -1,
      row: -1,
      order: "normal"
    }], this.frozen = {
      col: -1,
      row: -1
    }, this.tablePosition = {
      absoluteX: 0,
      absoluteY: 0
    }, this.drill = {
      col: -1,
      row: -1
    }, this.sparkLine = {
      col: -1,
      row: -1
    };
  }
  _initState() {
    this.interactionState = InteractionState.default, this.select = {
      highlightScope: HighlightScope.single,
      ranges: [],
      cellPos: {
        col: -1,
        row: -1
      },
      selecting: false
    }, this.fillHandle = {
      isFilling: false,
      startX: void 0,
      startY: void 0
    }, this.hover = {
      highlightScope: HighlightScope.single,
      cellPos: {
        col: -1,
        row: -1
      }
    }, this.hoverIcon = {
      col: -1,
      row: -1,
      icon: null
    }, this.columnResize = {
      col: -1,
      x: 0,
      resizing: false
    }, this.rowResize = {
      row: -1,
      y: 0,
      resizing: false
    }, this.columnMove = {
      colSource: -1,
      colTarget: -1,
      rowSource: -1,
      rowTarget: -1,
      x: 0,
      y: 0,
      moving: false
    }, this.menu = {
      x: -1,
      y: -1,
      isShow: false,
      itemList: [],
      bounds: new Bounds(),
      highlightIndex: -1,
      dropDownMenuHighlight: []
    }, this.sort = [{
      col: -1,
      row: -1,
      order: "normal"
    }], this.frozen = {
      col: -1,
      row: -1
    }, this.scroll = {
      horizontalBarPos: 0,
      verticalBarPos: 0
    }, this.tablePosition = {
      absoluteX: 0,
      absoluteY: 0
    }, this.drill = {
      col: -1,
      row: -1
    }, this.sparkLine = {
      col: -1,
      row: -1
    };
  }
  setHoverState() {
    var _a;
    const { highlightMode, disableHover, disableHeaderHover } = null !== (_a = this.table.options.hover) && void 0 !== _a ? _a : {
      highlightMode: "cell"
    };
    disableHover ? this.hover.highlightScope = HighlightScope.none : "cross" === highlightMode ? this.hover.highlightScope = HighlightScope.cross : "row" === highlightMode ? this.hover.highlightScope = HighlightScope.row : "column" === highlightMode ? this.hover.highlightScope = HighlightScope.column : "cell" === highlightMode && (this.hover.highlightScope = HighlightScope.single), this.hover.singleStyle = !disableHover, this.hover.disableHeader = disableHeaderHover, (this.hover.highlightScope === HighlightScope.none || disableHeaderHover) && (this.hover.cellPosContainHeader = {
      col: -1,
      row: -1
    });
  }
  setSelectState() {
    var _a, _b, _c, _d, _e;
    const { headerSelectMode, disableSelect, disableHeaderSelect, highlightMode, highlightInRange } = Object.assign({}, {
      headerSelectMode: "inline",
      disableSelect: false,
      disableHeaderSelect: false,
      highlightMode: "cell",
      highlightInRange: false
    }, this.table.options.select), cornerHeaderSelectMode = (null === (_a = this.table.options.select) || void 0 === _a ? void 0 : _a.cornerHeaderSelectMode) ? null === (_b = this.table.options.select) || void 0 === _b ? void 0 : _b.cornerHeaderSelectMode : "body" === (null === (_c = this.table.options.select) || void 0 === _c ? void 0 : _c.headerSelectMode) ? null === (_d = this.table.options.select) || void 0 === _d ? void 0 : _d.headerSelectMode : "all";
    this.select.highlightScope = true === disableSelect ? HighlightScope.none : "cross" === highlightMode ? HighlightScope.cross : "row" === highlightMode ? HighlightScope.row : "column" === highlightMode ? HighlightScope.column : HighlightScope.single, this.select.singleStyle = !disableSelect, this.select.disableHeader = disableHeaderSelect, this.select.headerSelectMode = headerSelectMode, this.select.cornerHeaderSelectMode = cornerHeaderSelectMode, this.select.highlightInRange = highlightInRange, this.select.disableCtrlMultiSelect = false === (null === (_e = this.table.options.keyboardOptions) || void 0 === _e ? void 0 : _e.ctrlMultiSelect);
  }
  isSelected(col, row) {
    let seled = false;
    return this.select.ranges.forEach((range5) => {
      cellInRange(range5, col, row) && (seled = true);
    }), seled;
  }
  setSortState(sortState) {
    const state = this;
    const sort2 = (sortState = !sortState || Array.isArray(sortState) ? sortState : [sortState]) && sortState.reduce((prev, item) => {
      var _a, _b, _c;
      const column = null === (_a = function(columns) {
        const result2 = [];
        return function flatten2(cols, parentStartIndex = 0) {
          cols.forEach((col) => {
            var _a2;
            const startIndex = col.startInTotal ? null !== (_a2 = col.startInTotal + state.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _a2 ? _a2 : 0 : parentStartIndex;
            col.columns ? flatten2(col.columns, startIndex) : result2.push(Object.assign(Object.assign({}, col), {
              startIndex
            }));
          });
        }(columns), result2;
      }(this.table.internalProps.columns)) || void 0 === _a ? void 0 : _a.find((column2) => (null == column2 ? void 0 : column2.field) === (null == item ? void 0 : item.field));
      return this.table.internalProps.transpose ? prev.push({
        field: item.field,
        order: item.order,
        row: null !== (_b = (null == column ? void 0 : column.startInTotal) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _b ? _b : 0,
        col: null == column ? void 0 : column.level
      }) : prev.push({
        field: item.field,
        order: item.order,
        col: null !== (_c = (null == column ? void 0 : column.startInTotal) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _c ? _c : 0,
        row: null == column ? void 0 : column.level
      }), prev;
    }, []);
    this.sort = sort2 || [];
  }
  setFrozenState() {
    this.frozen.col = this.table.frozenColCount - 1;
  }
  updateInteractionState(mode) {
    if (this.interactionState === mode) return;
    mode === InteractionState.scrolling && (this.interactionStateBeforeScroll = this.interactionState);
    const oldState = this.interactionState;
    this.interactionState = mode, oldState === InteractionState.scrolling && InteractionState.default;
  }
  updateHoverhighlightScope(mode) {
    this.hover.highlightScope !== mode && (this.hover.highlightScope = mode);
  }
  updateHoverPos(col, row) {
    updateHoverPosition(this, col, row);
  }
  updateSelectPos(col, row, isShift = false, isCtrl = false, isSelectAll = false, makeSelectCellVisible = true, skipBodyMerge = false) {
    -1 !== row && -1 !== row && (this.select.selecting = true), col < 0 && (col = -1), row < 0 && (row = -1), col > this.table.colCount - 1 && (col = this.table.colCount - 1), row > this.table.rowCount - 1 && (row = this.table.rowCount - 1), updateSelectPosition(this, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible, skipBodyMerge);
  }
  checkCellRangeInSelect(cellPosStart, cellPosEnd) {
    return checkMultiCellInSelect(cellPosStart, cellPosEnd, this.select.ranges, this.select.highlightScope);
  }
  updateHoverIcon(col, row, target, cellGroup) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if ((null === (_a = this.residentHoverIcon) || void 0 === _a ? void 0 : _a.icon) && target === (null === (_b = this.residentHoverIcon) || void 0 === _b ? void 0 : _b.icon)) return;
    const iconInfo = getIconAndPositionFromTarget(target);
    if (iconInfo) if ("richtext-icon" === iconInfo.type) {
      const inlineIcon = iconInfo.icon;
      if (this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_d = this.residentHoverIcon) || void 0 === _d ? void 0 : _d.icon) && (this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), this.hoverIcon.col = -1, this.hoverIcon.col = -1, this.hoverIcon.icon = null, this.table.scenegraph.updateNextFrame()), inlineIcon.attribute.tooltip) {
        const tooltipOptions = {
          content: inlineIcon.attribute.tooltip.title,
          referencePosition: {
            rect: iconInfo.position,
            placement: inlineIcon.attribute.tooltip.placement
          },
          style: Object.assign({}, null === (_e = this.table.internalProps.theme) || void 0 === _e ? void 0 : _e.tooltipStyle, null === (_f = inlineIcon.tooltip) || void 0 === _f ? void 0 : _f.style, null === (_h = null === (_g = inlineIcon.attribute) || void 0 === _g ? void 0 : _g.tooltip) || void 0 === _h ? void 0 : _h.style),
          disappearDelay: inlineIcon.attribute.tooltip.disappearDelay
        };
        this.table.internalProps.tooltipHandler.isBinded(tooltipOptions) || this.table.showTooltip(col, row, tooltipOptions);
      }
    } else {
      const icon2 = iconInfo.icon;
      icon2 !== this.hoverIcon.icon && (this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_j = this.residentHoverIcon) || void 0 === _j ? void 0 : _j.icon) && this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), this.hoverIcon.col = col, this.hoverIcon.row = row, this.hoverIcon.icon = icon2, this.table.scenegraph.setIconHoverStyle(icon2, col, row, cellGroup), this.table.scenegraph.updateNextFrame());
    }
    else this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_c = this.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) && (this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), this.hoverIcon.col = -1, this.hoverIcon.col = -1, this.hoverIcon.icon = null, this.table.scenegraph.updateNextFrame());
  }
  isResizeCol() {
    return this.columnResize.resizing;
  }
  isResizeRow() {
    return this.rowResize.resizing;
  }
  isFillHandle() {
    return this.fillHandle.isFilling;
  }
  isSelecting() {
    return this.select.selecting;
  }
  endSelectCells(fireListener = true, fireClear = true) {
    if (this.select.selecting) {
      if (this.select.selecting = false, 0 === this.select.ranges.length) return;
      const currentRange = this.select.ranges[this.select.ranges.length - 1];
      this.table.isSeriesNumber(this.select.cellPos.col, this.select.cellPos.row) || this.table.isHeader(this.select.cellPos.col, this.select.cellPos.row) || expendCellRange(currentRange, this.table);
      let isSame = false;
      for (let i = 0; i < this.select.ranges.length - 1; i++) {
        const range5 = this.select.ranges[i];
        if (range5 && range5.start.col === currentRange.start.col && range5.start.row === currentRange.start.row && range5.end.col === currentRange.end.col && range5.end.row === currentRange.end.row) {
          isSame = true;
          break;
        }
      }
      isSame ? (this.select.ranges.pop(), deleteAllSelectingBorder(this.table.scenegraph), this.table.scenegraph.selectingRangeComponents.clear()) : selectEnd(this.table.scenegraph);
      const lastCol = this.select.ranges[this.select.ranges.length - 1].end.col, lastRow = this.select.ranges[this.select.ranges.length - 1].end.row;
      fireListener && this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CELL, {
        ranges: this.select.ranges,
        col: lastCol,
        row: lastRow
      });
    } else fireClear && 0 === this.select.ranges.length && this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CLEAR, {});
  }
  endResizeCol() {
    setTimeout(() => {
      this.columnResize.resizing = false;
    }, 0), this.table.scenegraph.updateChartSizeForResizeColWidth(this.columnResize.col), this.checkFrozen(), this.table.scenegraph.component.hideResizeCol(), this.table.scenegraph.updateNextFrame();
  }
  startResizeCol(col, x, y, isRightFrozen) {
    this.columnResize.resizing = true, this.columnResize.col = col, this.columnResize.x = x, this.columnResize.isRightFrozen = isRightFrozen, this.table.scenegraph.component.showResizeCol(col, y, isRightFrozen), this.table.scenegraph.updateNextFrame();
  }
  updateResizeCol(xInTable, yInTable) {
    updateResizeColumn(xInTable, yInTable, this);
  }
  endResizeRow() {
    setTimeout(() => {
      this.rowResize.resizing = false;
    }, 0), this.table.scenegraph.updateChartSizeForResizeRowHeight(this.rowResize.row), this.table.scenegraph.component.hideResizeRow(), this.table.scenegraph.updateNextFrame();
  }
  startResizeRow(row, x, y, isBottomFrozen) {
    this.rowResize.resizing = true, this.rowResize.row = row, this.rowResize.y = y, this.rowResize.isBottomFrozen = isBottomFrozen, this.table.scenegraph.component.showResizeRow(row, x, isBottomFrozen), this.table.scenegraph.updateNextFrame();
  }
  updateResizeRow(xInTable, yInTable) {
    updateResizeRow(xInTable, yInTable, this);
  }
  startFillSelect(x, y) {
    this.fillHandle.isFilling = true, this.fillHandle.startX = x, this.fillHandle.startY = y;
    const currentRange = this.select.ranges[this.select.ranges.length - 1];
    this.fillHandle.beforeFillMinCol = Math.min(currentRange.start.col, currentRange.end.col), this.fillHandle.beforeFillMinRow = Math.min(currentRange.start.row, currentRange.end.row), this.fillHandle.beforeFillMaxCol = Math.max(currentRange.start.col, currentRange.end.col), this.fillHandle.beforeFillMaxRow = Math.max(currentRange.start.row, currentRange.end.row), this.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_FILL_HANDLE, {});
  }
  endFillSelect() {
    this.fillHandle.isFilling = false, this.fillHandle.startX = void 0, this.fillHandle.startY = void 0, this.fillHandle.directionRow = void 0;
    const currentMinCol = Math.min(this.select.ranges[0].start.col, this.select.ranges[0].end.col), currentMinRow = Math.min(this.select.ranges[0].start.row, this.select.ranges[0].end.row), currentMaxCol = Math.max(this.select.ranges[0].start.col, this.select.ranges[0].end.col), currentMaxRow = Math.max(this.select.ranges[0].start.row, this.select.ranges[0].end.row);
    this.fillHandle.beforeFillMinCol === currentMinCol && this.fillHandle.beforeFillMinRow === currentMinRow && this.fillHandle.beforeFillMaxCol === currentMaxCol && this.fillHandle.beforeFillMaxRow === currentMaxRow || this.table.eventManager.isDraging && this.table.fireListeners(TABLE_EVENT_TYPE.DRAG_FILL_HANDLE_END, {
      direction: this.fillHandle.direction
    }), this.fillHandle.beforeFillMaxCol = void 0, this.fillHandle.beforeFillMaxRow = void 0, this.fillHandle.beforeFillMinCol = void 0, this.fillHandle.beforeFillMinRow = void 0;
  }
  startMoveCol(col, row, x, y, event2) {
    startMoveCol(col, row, x, y, this, event2);
  }
  updateMoveCol(col, row, x, y, event2) {
    updateMoveCol(col, row, x, y, this, event2);
  }
  isMoveCol() {
    return this.columnMove.moving;
  }
  endMoveCol() {
    return endMoveCol(this);
  }
  checkFrozen() {
    var _a;
    let originalFrozenColCount = this.table.options.frozenColCount ? this.table.options.frozenColCount : this.table.isPivotTable() || this.table.isListTable() && this.table.internalProps.transpose ? (null !== (_a = this.table.rowHeaderLevelCount) && void 0 !== _a ? _a : 0) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount : 0;
    if (originalFrozenColCount) {
      originalFrozenColCount > this.table.colCount && (originalFrozenColCount = this.table.colCount);
      const maxFrozenWidth = this.table._getMaxFrozenWidth();
      if (this.table.getColsWidth(0, originalFrozenColCount - 1) > maxFrozenWidth) if (this.table.internalProps.unfreezeAllOnExceedsMaxWidth) this.table._setFrozenColCount(0), this.setFrozenCol(-1);
      else {
        const computedFrozenColCount = this.table._getComputedFrozenColCount(originalFrozenColCount);
        this.table._setFrozenColCount(computedFrozenColCount), this.setFrozenCol(computedFrozenColCount);
      }
      else this.table.frozenColCount !== originalFrozenColCount && (this.table._setFrozenColCount(originalFrozenColCount), this.setFrozenCol(originalFrozenColCount));
    }
  }
  setFrozenCol(col) {
    col !== this.frozen.col ? (this.frozen.col = col, this.table.scenegraph.updateFrozen(), this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1)) : this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1);
  }
  setFrozenRow(row) {
    row !== this.frozen.row && (this.frozen.row = row, this.table.scenegraph.updateRowFrozen());
  }
  checkVerticalScrollBarEnd() {
    var _a, _b;
    const totalHeight = this.table.getAllRowsHeight(), scrollTop = this.scroll.verticalBarPos, viewHeight = this.table.tableNoFrameHeight;
    scrollTop + viewHeight >= totalHeight && this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL_VERTICAL_END, {
      scrollTop,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
      scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
      viewHeight,
      viewWidth: this.table.tableNoFrameWidth
    });
  }
  checkHorizontalScrollBarEnd() {
    var _a, _b;
    const totalWidth = this.table.getAllColsWidth(), scrollLeft = this.scroll.horizontalBarPos, viewWidth = this.table.tableNoFrameWidth;
    scrollLeft + viewWidth >= totalWidth && this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL_HORIZONTAL_END, {
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft,
      scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
      scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth
    });
  }
  updateVerticalScrollBar(yRatio) {
    var _a, _b, _c, _d;
    const totalHeight = this.table.getAllRowsHeight(), oldVerticalBarPos = this.scroll.verticalBarPos;
    let verticalBarPos = Math.ceil(yRatio * (totalHeight - this.table.scenegraph.height));
    isValid_default(verticalBarPos) && !isNaN(verticalBarPos) || (verticalBarPos = 0);
    const dy = verticalBarPos - this.table.scenegraph.proxy.deltaY - oldVerticalBarPos;
    if (this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
      event: void 0,
      scrollTop: verticalBarPos - this.table.scenegraph.proxy.deltaY,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
      scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "vertical",
      scrollRatioY: yRatio,
      dy
    }).some((value) => false === value)) {
      const yRatio2 = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
      this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio2);
    } else this.scroll.verticalBarPos = verticalBarPos, this.table.scenegraph.setY(-this.scroll.verticalBarPos, 1 === yRatio), this.scroll.verticalBarPos -= this.table.scenegraph.proxy.deltaY, this.table.scenegraph.proxy.deltaY = 0, this.updateHoverPos(-1, -1), this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
      event: void 0,
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_c = this.table.theme.scrollStyle) || void 0 === _c ? void 0 : _c.width,
      scrollWidth: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "vertical",
      scrollRatioY: yRatio,
      dy
    }), oldVerticalBarPos !== this.scroll.verticalBarPos && this.checkVerticalScrollBarEnd();
  }
  updateHorizontalScrollBar(xRatio) {
    var _a, _b, _c, _d;
    const totalWidth = this.table.getAllColsWidth(), oldHorizontalBarPos = this.scroll.horizontalBarPos;
    let horizontalBarPos = Math.ceil(xRatio * (totalWidth - this.table.scenegraph.width));
    isValid_default(horizontalBarPos) && !isNaN(horizontalBarPos) || (horizontalBarPos = 0);
    const dx = horizontalBarPos - this.table.scenegraph.proxy.deltaX - oldHorizontalBarPos;
    if (this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
      event: void 0,
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft: horizontalBarPos - this.table.scenegraph.proxy.deltaX,
      scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
      scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "horizontal",
      scrollRatioX: xRatio,
      dx
    }).some((value) => false === value)) {
      const xRatio2 = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
      this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio2);
    } else this.scroll.horizontalBarPos = horizontalBarPos, this.table.scenegraph.setX(-this.scroll.horizontalBarPos, 1 === xRatio), this.scroll.horizontalBarPos -= this.table.scenegraph.proxy.deltaX, this.table.scenegraph.proxy.deltaX = 0, this.updateHoverPos(-1, -1), this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
      event: void 0,
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_c = this.table.theme.scrollStyle) || void 0 === _c ? void 0 : _c.width,
      scrollWidth: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "horizontal",
      scrollRatioX: xRatio,
      dx
    }), oldHorizontalBarPos !== this.scroll.horizontalBarPos && this.checkHorizontalScrollBarEnd();
  }
  setScrollTop(top, event2, triggerEvent = true) {
    var _a, _b, _c, _d, _e, _f, _g;
    const totalHeight = this.table.getAllRowsHeight(), sizeTolerance = (null === (_a = this.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0;
    top = Math.max(0, Math.min(top, totalHeight - this.table.scenegraph.height - sizeTolerance)), top = Math.ceil(top);
    const oldVerticalBarPos = this.scroll.verticalBarPos, yRatio = top / (totalHeight - this.table.scenegraph.height);
    if ((oldVerticalBarPos !== top || true === (null === (_c = null === (_b = this.table.options) || void 0 === _b ? void 0 : _b.customConfig) || void 0 === _c ? void 0 : _c.scrollEventAlwaysTrigger)) && triggerEvent) {
      let verticalBarPos = top;
      isValid_default(verticalBarPos) && !isNaN(verticalBarPos) || (verticalBarPos = 0);
      const dy2 = verticalBarPos - oldVerticalBarPos;
      if (this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
        event: null == event2 ? void 0 : event2.nativeEvent,
        scrollTop: verticalBarPos,
        scrollLeft: this.scroll.horizontalBarPos,
        scrollHeight: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
        scrollWidth: null === (_e = this.table.theme.scrollStyle) || void 0 === _e ? void 0 : _e.width,
        viewHeight: this.table.tableNoFrameHeight,
        viewWidth: this.table.tableNoFrameWidth,
        scrollDirection: "vertical",
        scrollRatioY: yRatio,
        dy: dy2
      }).some((value) => false === value)) {
        const yRatio2 = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
        return void this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio2);
      }
    }
    (top !== this.scroll.verticalBarPos || this.table.isPivotChart()) && this.updateHoverPos(-1, -1), this.scroll.verticalBarPos = top, isValid_default(this.scroll.verticalBarPos) && !isNaN(this.scroll.verticalBarPos) || (this.scroll.verticalBarPos = 0), this.table.scenegraph.setY(-top), this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
    const dy = this.scroll.verticalBarPos - oldVerticalBarPos;
    this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
      event: null == event2 ? void 0 : event2.nativeEvent,
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_f = this.table.theme.scrollStyle) || void 0 === _f ? void 0 : _f.width,
      scrollWidth: null === (_g = this.table.theme.scrollStyle) || void 0 === _g ? void 0 : _g.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "vertical",
      scrollRatioY: yRatio,
      dy
    }), oldVerticalBarPos !== top && triggerEvent && this.checkVerticalScrollBarEnd();
  }
  setScrollLeft(left, event2, triggerEvent = true) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.table.scrollLeft;
    const totalWidth = this.table.getAllColsWidth(), sizeTolerance = (this.table.getFrozenColsWidth(), (null === (_a = this.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0);
    left = Math.max(0, Math.min(left, totalWidth - this.table.scenegraph.width - sizeTolerance)), left = Math.ceil(left);
    const oldHorizontalBarPos = this.scroll.horizontalBarPos, xRatio = left / (totalWidth - this.table.scenegraph.width);
    if ((oldHorizontalBarPos !== left || true === (null === (_c = null === (_b = this.table.options) || void 0 === _b ? void 0 : _b.customConfig) || void 0 === _c ? void 0 : _c.scrollEventAlwaysTrigger)) && triggerEvent) {
      let horizontalBarPos = left;
      isValid_default(horizontalBarPos) && !isNaN(horizontalBarPos) || (horizontalBarPos = 0);
      const dx2 = horizontalBarPos - oldHorizontalBarPos;
      if (this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
        event: null == event2 ? void 0 : event2.nativeEvent,
        scrollTop: this.scroll.verticalBarPos,
        scrollLeft: horizontalBarPos,
        scrollHeight: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
        scrollWidth: null === (_e = this.table.theme.scrollStyle) || void 0 === _e ? void 0 : _e.width,
        viewHeight: this.table.tableNoFrameHeight,
        viewWidth: this.table.tableNoFrameWidth,
        scrollDirection: "horizontal",
        scrollRatioX: xRatio,
        dx: dx2
      }).some((value) => false === value)) {
        const xRatio2 = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
        return void this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio2);
      }
    }
    left !== this.scroll.horizontalBarPos && this.updateHoverPos(-1, -1), this.scroll.horizontalBarPos = left, isValid_default(this.scroll.horizontalBarPos) && !isNaN(this.scroll.horizontalBarPos) || (this.scroll.horizontalBarPos = 0), this.table.scenegraph.setX(-left), this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
    const dx = this.scroll.horizontalBarPos - oldHorizontalBarPos;
    this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
      event: null == event2 ? void 0 : event2.nativeEvent,
      scrollTop: this.scroll.verticalBarPos,
      scrollLeft: this.scroll.horizontalBarPos,
      scrollHeight: null === (_f = this.table.theme.scrollStyle) || void 0 === _f ? void 0 : _f.width,
      scrollWidth: null === (_g = this.table.theme.scrollStyle) || void 0 === _g ? void 0 : _g.width,
      viewHeight: this.table.tableNoFrameHeight,
      viewWidth: this.table.tableNoFrameWidth,
      scrollDirection: "horizontal",
      scrollRatioX: xRatio,
      dx
    }), oldHorizontalBarPos !== left && triggerEvent && this.checkHorizontalScrollBarEnd();
  }
  hideVerticalScrollBar() {
    this.table.scenegraph.component.hideVerticalScrollBar();
  }
  showVerticalScrollBar(autoHide2) {
    this.table.scenegraph.component.showVerticalScrollBar(), autoHide2 && (clearTimeout(this._clearVerticalScrollBar), this._clearVerticalScrollBar = setTimeout(() => {
      var _a;
      null === (_a = this.table.scenegraph) || void 0 === _a || _a.component.hideVerticalScrollBar();
    }, 1e3));
  }
  hideHorizontalScrollBar() {
    this.table.scenegraph.component.hideHorizontalScrollBar();
  }
  showHorizontalScrollBar(autoHide2) {
    var _a;
    this.table.scenegraph.component.showHorizontalScrollBar(), null === (_a = this.table.scenegraph) || void 0 === _a || _a.component.showFrozenColumnShadow(), autoHide2 && (clearTimeout(this._clearHorizontalScrollBar), this._clearHorizontalScrollBar = setTimeout(() => {
      var _a2, _b;
      null === (_a2 = this.table.scenegraph) || void 0 === _a2 || _a2.component.hideFrozenColumnShadow(), null === (_b = this.table.scenegraph) || void 0 === _b || _b.component.hideHorizontalScrollBar();
    }, 1e3));
  }
  triggerContextMenu(col, row, x, y) {
    this.menu.isShow && this.menu.x === x && this.menu.y === y ? this.hideMenu() : this.showContextMenu(col, row, x, y);
  }
  showContextMenu(col, row, x, y) {
    var _a;
    (null === (_a = this.table.internalProps.menu) || void 0 === _a ? void 0 : _a.contextMenuItems) && ("html" === this.table.internalProps.menu.renderMode ? this.menu.isShow = true : (this.menu.isShow = true, this.menu.x = x, this.menu.y = y, this.table.scenegraph.component.menu.attach(x, y, col, row, MenuType.contextmenu)), this.table.fireListeners(TABLE_EVENT_TYPE.SHOW_MENU, {
      x,
      y,
      col,
      row,
      type: "contextmenu"
    }));
  }
  triggerDropDownMenu(col, row, x, y, event2) {
    this.table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_ICON_CLICK, {
      col,
      row,
      event: event2
    }), this.menu.isShow ? this.hideMenu() : this.showDropDownMenu(col, row, x, y);
  }
  showDropDownMenu(col, row, x, y) {
    "html" === this.table.internalProps.menu.renderMode ? this.menu.isShow = true : (this.menu.isShow = true, this.table.scenegraph.component.menu.attach(x, y, col, row, MenuType.dropDown), this.menu.bounds = this.table.scenegraph.component.menu.bounds), this.table.fireListeners(TABLE_EVENT_TYPE.SHOW_MENU, {
      x,
      y,
      col,
      row,
      type: "dropDown"
    }), this.residentHoverIcon && this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row);
    const cellGroup = this.table.scenegraph.getCell(col, row);
    let icon2;
    cellGroup.forEachChildren((child) => child.attribute.funcType === IconFuncTypeEnum.dropDown && (icon2 = child, true)), icon2 && (this.residentHoverIcon = {
      col,
      row,
      icon: icon2
    }, this.table.scenegraph.setIconHoverStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row, cellGroup), this.table.scenegraph.residentHoverIcon(col, row));
  }
  hideMenu() {
    this.menu.isShow && (this.table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), this.table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null), this.menu.isShow = false, this.table.scenegraph.component.menu.detach(), this.residentHoverIcon && (this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row), this.table.scenegraph.resetResidentHoverIcon(this.residentHoverIcon.col, this.residentHoverIcon.row), this.residentHoverIcon = null));
  }
  setDropDownMenuHighlight(dropDownMenuInfo) {
    this.menu.dropDownMenuHighlight = dropDownMenuInfo;
    for (let i = 0; i < dropDownMenuInfo.length; i++) {
      const { col, row } = dropDownMenuInfo[i], range5 = this.table.getCellRange(col, row);
      if (range5) for (let col2 = range5.start.col; col2 <= range5.end.col; col2++) for (let row2 = range5.start.row; row2 <= range5.end.row; row2++) this.table.scenegraph.updateCellContent(col2, row2);
    }
  }
  dropDownMenuIsHighlight(colNow, rowNow, index) {
    const highlights = this.menu.dropDownMenuHighlight;
    if (Array.isArray(highlights)) for (let i = 0; i < highlights.length; i++) {
      const highlight = highlights[i];
      let { col, row } = highlight;
      const { field, menuKey } = highlight;
      if ("number" != typeof col || "number" != typeof row) if (this.table.isPivotTable() && (Array.isArray(field), 1)) {
        const cellAddress = this.table.internalProps.layoutMap.getPivotCellAdress(field);
        if (!cellAddress) continue;
        col = cellAddress.col, row = cellAddress.row;
      } else {
        const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(field);
        if (!cellAddress) continue;
        col = cellAddress.col, row = cellAddress.row;
      }
      if (isValid_default(col) && isValid_default(row) && this.table.isCellRangeEqual(colNow, rowNow, col, row)) {
        let dropDownMenu = this.table._getHeaderLayoutMap(null != col ? col : colNow, null != row ? row : rowNow).dropDownMenu || this.table.globalDropDownMenu;
        if ("function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
          row,
          col,
          table: this.table
        })), dropDownMenu) for (let i2 = 0; i2 < dropDownMenu.length; i2++) {
          const item = dropDownMenu[i2];
          if (isObject_default(item) && (item.menuKey || item.text) === (menuKey || "") && i2 === index) return true;
          if (isString_default(item) && item === menuKey && i2 === index) return true;
        }
      }
    }
    return false;
  }
  triggerSort(col, row, iconMark, event2) {
    if (this.table.isPivotTable()) {
      const sortState = this.table.getPivotSortState(col, row), order = sortState ? sortState.toUpperCase() : "NORMAL", new_order = "ASC" === order ? "DESC" : "DESC" === order ? "NORMAL" : "ASC";
      return this.table.sort(col, row, new_order), void this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.PIVOT_SORT_CLICK, {
        col,
        row,
        order: order || "normal",
        dimensionInfo: this.table.internalProps.layoutMap.getPivotDimensionInfo(col, row),
        cellLocation: this.table.getCellLocation(col, row),
        event: event2
      });
    }
    const previousSort = [...this.sort], previousSortItem = this.table.internalProps.multipleSort || !previousSort.length ? null : this.sort[this.sort.length - 1];
    dealSort(col, row, this.table, event2);
    const range5 = this.table.getCellRange(col, row), currentSortItem = this.sort.find((item) => item.col === range5.start.col && item.row === range5.start.row), oldSortCol = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.col, oldSortRow = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.row, currentSortItemIndex = previousSort.findIndex((item) => item.col === col && item.row === row);
    currentSortItemIndex >= 0 && previousSort.splice(currentSortItemIndex, 1), this.table.scenegraph.updateSortIcon({
      col,
      row,
      iconMark,
      order: null == currentSortItem ? void 0 : currentSortItem.order,
      oldSortCol,
      oldSortRow,
      oldIconMark: null == previousSortItem ? void 0 : previousSortItem.icon
    }), currentSortItem && (currentSortItem.icon = iconMark), this.table.internalProps.multipleSort || previousSort.forEach((sortItem) => {
      this.table.scenegraph.updateSortIcon({
        col: null,
        row: null,
        iconMark: null,
        order: "normal",
        oldSortCol: sortItem.col,
        oldSortRow: sortItem.row,
        oldIconMark: null
      });
    }), this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.AFTER_SORT, {
      order: null == currentSortItem ? void 0 : currentSortItem.order,
      field: this.table.getHeaderField(col, row),
      event: event2
    });
  }
  updateSortState(sortState) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    sortState = Array.isArray(sortState) ? sortState : [sortState];
    for (let index = 0; index < sortState.length; index++) {
      if (sortState[index].field === (null === (_a = this.sort[index]) || void 0 === _a ? void 0 : _a.field) && sortState[sortState.length - 1].order === (null === (_b = this.sort[index]) || void 0 === _b ? void 0 : _b.order)) return;
      const oldSortCol = this.table.internalProps.multipleSort ? null : (null === (_c = this.sort[index]) || void 0 === _c ? void 0 : _c.col) || null, oldSortRow = this.table.internalProps.multipleSort ? null : (null === (_d = this.sort[index]) || void 0 === _d ? void 0 : _d.row) || null;
      "asc" === (null === (_e = this.sort[index]) || void 0 === _e ? void 0 : _e.order) || (null === (_f = this.sort[index]) || void 0 === _f || _f.order);
      this.setSortState(sortState.slice(0, index + 1));
      const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(sortState[index].field);
      this.sort[index].col = cellAddress.col, this.sort[index].row = cellAddress.row;
      const cellGroup = this.table.scenegraph.getCell(this.sort[index].col, this.sort[index].row);
      let iconMark;
      traverseObject(cellGroup, "children", (mark) => "sort" === mark.attribute.funcType && (iconMark = mark, true)), this.table.scenegraph.updateSortIcon({
        col: this.sort[index].col,
        row: this.sort[index].row,
        iconMark,
        order: this.sort[index].order,
        oldSortCol,
        oldSortRow,
        oldIconMark: null === (_g = this.sort[index]) || void 0 === _g ? void 0 : _g.icon
      });
    }
    const normalHeaders = [];
    this.table.internalProps.layoutMap.columnTree.tree.children.forEach((item) => {
      sortState.some((state) => state.field === item.field) || normalHeaders.push(item);
    });
    for (let index = 0; index < normalHeaders.length; index++) {
      const column = normalHeaders[index];
      this.table.scenegraph.updateSortIcon({
        col: null,
        row: null,
        iconMark: null,
        order: null,
        oldSortCol: null !== (_h = column.startInTotal + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _h ? _h : 0,
        oldSortRow: column.level,
        oldIconMark: null
      });
    }
  }
  triggerFreeze(col, row, iconMark) {
    if (!this.table.isPivotTable() && !this.table.transpose) {
      if (dealFreeze(col, row, this.table), this.table.hasListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK)) {
        const fields2 = this.table.internalProps.layoutMap.columnObjects.slice(0, col + 1);
        this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK, {
          col,
          row,
          fields: fields2.reduce((pre, cur) => pre.concat(cur.field), []),
          colCount: this.table.frozenColCount
        });
      }
      this.frozen.icon = iconMark;
    }
  }
  updateCursor(mode = "default") {
    this.table.getElement().style.cursor = mode;
  }
  updateDrillState(dimensionKey, title, drillDown, drillUp, col, row) {
    this.drill.dimensionKey = dimensionKey, this.drill.title = title, this.drill.drillDown = drillDown, this.drill.drillUp = drillUp, this.drill.col = col, this.drill.row = row, updateDrill(col, row, drillDown, drillUp, this.table);
  }
  updateSparklineHoverPose(col, row, x, y) {
    -1 !== this.sparkLine.col && -1 !== this.sparkLine.row && clearChartHover(this.sparkLine.col, this.sparkLine.row, this.table);
    let isUpdated = false;
    -1 !== col && -1 !== row && (isUpdated = updateChartHover(col, row, x, y, this.table)), isUpdated ? (this.sparkLine.col = col, this.sparkLine.row = row) : (this.sparkLine.col = -1, this.sparkLine.row = -1);
  }
  setCheckedState(col, row, field, checked) {
    return setCheckedState(col, row, field, checked, this);
  }
  setHeaderCheckedState(field, checked) {
    return setHeaderCheckedState(field, checked, this);
  }
  syncCheckedState(col, row, field, checked) {
    return syncCheckedState(col, row, field, checked, this);
  }
  initCheckedState(records) {
    return initCheckedState(records, this);
  }
  updateHeaderCheckedState(field, col, row) {
    return updateHeaderCheckedState(field, this, col, row);
  }
  initLeftRecordsCheckState(records) {
    return initLeftRecordsCheckState(records, this);
  }
  setRadioState(col, row, field, radioType, indexInCell) {
    setRadioState(col, row, field, radioType, indexInCell, this);
  }
  syncRadioState(col, row, field, radioType, indexInCell, isChecked) {
    return syncRadioState(col, row, field, radioType, indexInCell, isChecked, this);
  }
  changeCheckboxAndRadioOrder(sourceIndex, targetIndex) {
    this.checkedState.size && changeCheckboxOrder(sourceIndex, targetIndex, this), this.radioState.length && changeRadioOrder(sourceIndex, targetIndex, this);
  }
  setCustomSelectRanges(customSelectRanges) {
    deletaCustomSelectRanges(this), addCustomSelectRanges(customSelectRanges, this);
  }
};

// node_modules/@visactor/vtable/es/event/media-click.js
function bindMediaClick(table) {
  "browser" === Env.mode && table.on(TABLE_EVENT_TYPE.CLICK_CELL, (e) => {
    const { col, row } = e;
    if ("image" === e.target.type && e.target.role && e.target.role.startsWith("icon")) return;
    let cellType;
    cellType = table.internalProps.layoutMap.isHeader(col, row) ? table.isPivotTable() ? table._getHeaderLayoutMap(col, row).headerType : table.getHeaderDefine(col, row).headerType : table.getBodyColumnType(col, row);
    const columnDefine = table.isHeader(col, row) ? table.getHeaderDefine(col, row) : table.getBodyColumnDefine(col, row), cellValue = table.getCellValue(col, row), cellOriginValue = table.getCellOriginValue(col, row);
    if ("link" === cellType) {
      let linkJump = getOrApply(columnDefine.linkJump, {
        col,
        row,
        table,
        value: cellValue,
        dataValue: cellOriginValue,
        cellHeaderPaths: void 0
      });
      if (linkJump = false !== linkJump, !linkJump) return;
      const templateLink = columnDefine.templateLink;
      let url, linkDetect = getOrApply(columnDefine.linkDetect, {
        col,
        row,
        table,
        value: cellValue,
        dataValue: cellOriginValue,
        cellHeaderPaths: void 0
      });
      if (linkDetect = false !== linkDetect, templateLink) {
        const rowData = table.getCellOriginRecord(col, row);
        if (rowData && rowData.vtableMerge) return;
        const data = Object.assign({
          __value: cellValue,
          __dataValue: cellOriginValue
        }, rowData);
        if (isFunction_default(templateLink)) url = templateLink(data, col, row, table);
        else {
          const re = /\{\s*(\S+?)\s*\}/g;
          url = templateLink.replace(re, (matchs, key) => data[key]);
        }
      } else if (linkDetect) {
        if (!regUrl.test(cellValue)) return;
        url = cellValue;
      } else url = cellValue;
      if (!url) return;
      const linkTarget = columnDefine.linkTarget, linkWindowFeatures = columnDefine.linkWindowFeatures;
      window.open(url, linkTarget, linkWindowFeatures);
    } else if ("image" === cellType) {
      const { clickToPreview } = columnDefine;
      if (false === clickToPreview) return;
      const overlay = document.createElement("div");
      overlay.style.width = "100%", overlay.style.height = "100%", overlay.style.position = "absolute", overlay.style.top = "0", overlay.style.left = "0", overlay.style.backgroundColor = "rgba(30, 30, 30, 0.4)", overlay.style.display = "flex", overlay.style.justifyContent = "center", overlay.style.alignItems = "center", overlay.style.overflow = "hidden", overlay.style.zIndex = "9999", overlay.addEventListener("click", (e3) => {
        e3.target === overlay && document.body.removeChild(overlay);
      });
      const image = new Image();
      image.src = cellValue, image.style.maxWidth = "80%", image.style.maxHeight = "80%", overlay.appendChild(image), document.body.appendChild(overlay);
    } else if ("video" === cellType) {
      const { clickToPreview } = columnDefine;
      if (false === clickToPreview) return;
      const overlay = document.createElement("div");
      overlay.style.width = "100%", overlay.style.height = "100%", overlay.style.position = "absolute", overlay.style.top = "0", overlay.style.left = "0", overlay.style.backgroundColor = "rgba(30, 30, 30, 0.4)", overlay.style.display = "flex", overlay.style.justifyContent = "center", overlay.style.alignItems = "center", overlay.style.overflow = "hidden", overlay.style.zIndex = "9999", overlay.addEventListener("click", (e3) => {
        e3.target === overlay && document.body.removeChild(overlay);
      });
      const video = document.createElement("video");
      video.src = cellValue, video.style.maxWidth = "80%", video.style.maxHeight = "80%", video.setAttribute("preload", "auto"), video.setAttribute("controls", "true"), overlay.appendChild(video), document.body.appendChild(overlay);
    }
  });
}

// node_modules/@visactor/vtable/es/event/drill.js
function bindDrillEvent(table) {
  table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, (e) => {
    const { col, row } = e;
    if (-1 === col || -1 === row) return;
    const dimension = table.internalProps.layoutMap.getHeaderDimension(col, row);
    (null == dimension ? void 0 : dimension.drillDown) || (null == dimension ? void 0 : dimension.drillUp) ? table.stateManager.updateDrillState(dimension.dimensionKey, dimension.title, dimension.drillDown, dimension.drillUp, col, row) : table.stateManager.updateDrillState(void 0, void 0, false, false, -1, -1);
  }), table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, (e) => {
    table.stateManager.updateDrillState(void 0, void 0, false, false, -1, -1);
  });
}
function drillClick(table) {
  table.fireListeners(PIVOT_TABLE_EVENT_TYPE.DRILLMENU_CLICK, table.stateManager.drill);
}
function checkHaveDrill(table) {
  const rowsDefine = table.internalProps.layoutMap.rowsDefine, columnsDefine = table.internalProps.layoutMap.columnsDefine;
  for (let i = 0; i < rowsDefine.length; i++) {
    const row = rowsDefine[i];
    if ("string" != typeof row && (row.drillDown || row.drillUp)) return true;
  }
  for (let i = 0; i < columnsDefine.length; i++) {
    const column = columnsDefine[i];
    if ("string" != typeof column && (column.drillDown || column.drillUp)) return true;
  }
  return false;
}

// node_modules/@visactor/vtable/es/event/sparkline-event.js
function bindSparklineHoverEvent(table) {
  if (table.eventManager.bindSparklineHoverEvent) return;
  let hasSparkLine = false;
  if (table.isPivotTable()) {
    hasSparkLine = table.internalProps.layoutMap.indicatorsDefine.some((indicator) => "string" != typeof indicator && "sparkline" === indicator.cellType);
  } else {
    hasSparkLine = table.internalProps.layoutMap.columnObjects.some((column) => "sparkline" === column.cellType || "function" == typeof column.cellType);
  }
  hasSparkLine && (table.eventManager.bindSparklineHoverEvent = true, table.on(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, (e) => {
    const { col, row, x, y } = e;
    "sparkline" !== table.getBodyColumnType(col, row) && table.stateManager.updateSparklineHoverPose(-1, -1, 0, 0), table.stateManager.updateSparklineHoverPose(col, row, x, y);
  }), table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, (e) => {
    table.stateManager.updateSparklineHoverPose(-1, -1, 0, 0);
  }));
}

// node_modules/@visactor/vtable/es/event/scroll.js
function handleWhell(event2, state, isWheelEvent = true) {
  var _a;
  let { deltaX, deltaY } = event2;
  event2.shiftKey && event2.deltaY && (deltaX = deltaY, deltaY = 0);
  const [optimizedDeltaX, optimizedDeltaY] = optimizeScrollXY(deltaX, deltaY, {
    horizontal: 1,
    vertical: 1
  });
  (optimizedDeltaX || optimizedDeltaY) && state.interactionState !== InteractionState.scrolling && state.updateInteractionState(InteractionState.scrolling), optimizedDeltaX && (state.setScrollLeft(state.scroll.horizontalBarPos + optimizedDeltaX, event2), state.showHorizontalScrollBar(true)), optimizedDeltaY && (state.setScrollTop(state.scroll.verticalBarPos + optimizedDeltaY, event2), state.showVerticalScrollBar(true)), isWheelEvent && state.resetInteractionState(state.interactionStateBeforeScroll), (null === (_a = event2.nativeEvent) || void 0 === _a ? void 0 : _a.cancelable) && ("none" === state.table.internalProps.overscrollBehavior || Math.abs(deltaY) >= Math.abs(deltaX) && 0 !== deltaY && isVerticalScrollable(deltaY, state) || Math.abs(deltaY) <= Math.abs(deltaX) && 0 !== deltaX && isHorizontalScrollable(deltaX, state)) && event2.nativeEvent.preventDefault();
}
function optimizeScrollXY(x, y, ratio) {
  var _a, _b;
  const angle2 = Math.abs(x / y), deltaX = angle2 <= 0.5 ? 0 : x, deltaY = angle2 > 2 ? 0 : y;
  return [Math.ceil(deltaX * (null !== (_a = ratio.horizontal) && void 0 !== _a ? _a : 0)), Math.ceil(deltaY * (null !== (_b = ratio.vertical) && void 0 !== _b ? _b : 0))];
}
function isVerticalScrollable(deltaY, state) {
  return 0 != state.table.getAllRowsHeight() - state.table.scenegraph.height && (!isScrollToTop(deltaY, state) && !isScrollToBottom(deltaY, state));
}
function isHorizontalScrollable(deltaX, state) {
  return 0 != state.table.getAllColsWidth() - state.table.scenegraph.width && (!isScrollToLeft(deltaX, state) && !isScrollToRight(deltaX, state));
}
function isScrollToTop(deltaY, state) {
  return 0 !== state.table.getAllRowsHeight() - state.table.scenegraph.height && deltaY <= 0 && state.scroll.verticalBarPos < 1;
}
function isScrollToBottom(deltaY, state) {
  var _a;
  const sizeTolerance = (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0, totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;
  return 0 !== totalHeight && deltaY >= 0 && Math.abs(state.scroll.verticalBarPos - totalHeight) < 1 + sizeTolerance;
}
function isScrollToLeft(deltaX, state) {
  return 0 !== state.table.getAllColsWidth() - state.table.scenegraph.width && deltaX <= 0 && state.scroll.horizontalBarPos < 1;
}
function isScrollToRight(deltaX, state) {
  var _a;
  const sizeTolerance = (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0, totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;
  return 0 !== totalWidth && deltaX >= 0 && Math.abs(state.scroll.horizontalBarPos - totalWidth) < 1 + sizeTolerance;
}
var InertiaScroll = class {
  constructor(stateManager) {
    this.stateManager = stateManager;
  }
  setScrollHandle(scrollHandle) {
    this.scrollHandle = scrollHandle;
  }
  startInertia(speedX, speedY, friction) {
    this.lastTime = Date.now(), this.speedX = speedX, this.speedY = speedY, this.friction = friction, this.runingId || (this.runingId = requestAnimationFrame(this.inertia.bind(this)));
  }
  inertia() {
    var _a;
    const now = Date.now(), dffTime = now - this.lastTime;
    let stopped = true;
    const f = Math.pow(this.friction, dffTime / 16), newSpeedX = f * this.speedX, newSpeedY = f * this.speedY;
    let dx = 0, dy = 0;
    Math.abs(newSpeedX) > 0.05 && (stopped = false, dx = (this.speedX + newSpeedX) / 2 * dffTime), Math.abs(newSpeedY) > 0.05 && (stopped = false, dy = (this.speedY + newSpeedY) / 2 * dffTime), null === (_a = this.scrollHandle) || void 0 === _a || _a.call(this, dx, dy), stopped ? this.runingId = null : (this.lastTime = now, this.speedX = newSpeedX, this.speedY = newSpeedY, this.runingId = requestAnimationFrame(this.inertia.bind(this)));
  }
  endInertia() {
    cancelAnimationFrame(this.runingId), this.runingId = null;
  }
  isInertiaScrolling() {
    return !!this.runingId;
  }
};

// node_modules/@visactor/vtable/es/event/helper.js
function fireMoveColEventListeners(table, endMoveColSuccess, e) {
  var _a, _b, _c, _d;
  endMoveColSuccess && -1 !== (null === (_a = table.stateManager.columnMove) || void 0 === _a ? void 0 : _a.colSource) && -1 !== (null === (_b = table.stateManager.columnMove) || void 0 === _b ? void 0 : _b.rowSource) && -1 !== (null === (_c = table.stateManager.columnMove) || void 0 === _c ? void 0 : _c.colTarget) && -1 !== (null === (_d = table.stateManager.columnMove) || void 0 === _d ? void 0 : _d.rowTarget) ? table.hasListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION) && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION, {
    target: {
      col: table.stateManager.columnMove.colTarget,
      row: table.stateManager.columnMove.rowTarget
    },
    source: {
      col: table.stateManager.columnMove.colSource,
      row: table.stateManager.columnMove.rowSource
    },
    event: e
  }) : endMoveColSuccess || table.hasListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_FAIL) && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_FAIL, {
    target: {
      col: table.stateManager.columnMove.colTarget,
      row: table.stateManager.columnMove.rowTarget
    },
    source: {
      col: table.stateManager.columnMove.colSource,
      row: table.stateManager.columnMove.rowSource
    },
    event: e
  });
}

// node_modules/@visactor/vtable/es/event/listener/table-group.js
function bindTableGroupListener(eventManager) {
  const table = eventManager.table, stateManager = table.stateManager;
  table.scenegraph.tableGroup.addEventListener("pointermove", (e) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const lastX = null !== (_b = null === (_a = table.eventManager.LastPointerXY) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : e.x, lastY = null !== (_d = null === (_c = table.eventManager.LastPointerXY) || void 0 === _c ? void 0 : _c.y) && void 0 !== _d ? _d : e.y;
    table.eventManager.LastPointerXY = {
      x: e.x,
      y: e.y
    }, eventManager.touchSetTimeout && (clearTimeout(eventManager.touchSetTimeout), eventManager.touchSetTimeout = void 0);
    const eventArgsSet = getCellEventArgsSet(e);
    if (eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE, {
      col: eventArgsSet.eventArgs.col,
      row: eventArgsSet.eventArgs.row,
      x: eventArgsSet.abstractPos.x,
      y: eventArgsSet.abstractPos.y,
      event: e.nativeEvent,
      target: null === (_e = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _e ? void 0 : _e.target,
      mergeCellInfo: null === (_f = eventArgsSet.eventArgs) || void 0 === _f ? void 0 : _f.mergeInfo
    }), stateManager.interactionState === InteractionState.grabing && !(null === (_g = table.editorManager) || void 0 === _g ? void 0 : _g.editingEditor)) return void (Math.abs(lastX - e.x) + Math.abs(lastY - e.y) >= 1 && (stateManager.isResizeCol() || stateManager.isResizeRow() || (stateManager.isMoveCol() ? eventManager.dealColumnMover(eventArgsSet) : stateManager.isFillHandle() ? eventManager.dealFillSelect(eventArgsSet, true) : (null === (_h = table.options.select) || void 0 === _h ? void 0 : _h.disableDragSelect) || eventManager.dealTableSelect(eventArgsSet, true))));
    !(null === (_j = table.options.select) || void 0 === _j ? void 0 : _j.disableDragSelect) && table.eventManager.isDraging && stateManager.isSelecting() && !(null === (_k = table.editorManager) || void 0 === _k ? void 0 : _k.editingEditor) && eventManager.dealTableSelect(eventArgsSet, true);
    const cellGoup = e.path.find((node) => "cell" === node.role);
    if (table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL) && (-1 === table.stateManager.hover.cellPos.col || -1 === table.stateManager.hover.cellPos.row || (null == cellGoup ? void 0 : cellGoup.col) === table.stateManager.hover.cellPos.col && (null == cellGoup ? void 0 : cellGoup.row) === table.stateManager.hover.cellPos.row || table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
      col: table.stateManager.hover.cellPos.col,
      row: table.stateManager.hover.cellPos.row,
      cellRange: table.getCellRangeRelativeRect({
        col: table.stateManager.hover.cellPos.col,
        row: table.stateManager.hover.cellPos.row
      }),
      scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
      event: e.nativeEvent,
      target: null === (_l = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _l ? void 0 : _l.target
    })), table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL) && ("cell" !== (null == cellGoup ? void 0 : cellGoup.role) || !isValid_default(cellGoup.col) || !isValid_default(cellGoup.row) || cellGoup.col === table.stateManager.hover.cellPos.col && cellGoup.row === table.stateManager.hover.cellPos.row || cellGoup.col === (null === (_m = table.stateManager.hover.cellPosContainHeader) || void 0 === _m ? void 0 : _m.col) && cellGoup.row === (null === (_o = table.stateManager.hover.cellPosContainHeader) || void 0 === _o ? void 0 : _o.row) || table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
      col: cellGoup.col,
      row: cellGoup.row,
      cellRange: table.getCellRangeRelativeRect({
        col: cellGoup.col,
        row: cellGoup.row
      }),
      scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
      event: e.nativeEvent,
      target: null === (_p = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _p ? void 0 : _p.target,
      mergeCellInfo: null === (_q = eventArgsSet.eventArgs) || void 0 === _q ? void 0 : _q.mergeInfo
    })), eventManager.dealIconHover(eventArgsSet), eventManager.dealTableHover(eventArgsSet), table.theme.columnResize.visibleOnHover && eventManager.checkColumnResize(eventArgsSet, true), eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL)) {
      let icon2, position;
      if (null === (_r = eventArgsSet.eventArgs) || void 0 === _r ? void 0 : _r.target) {
        const iconInfo = getIconAndPositionFromTarget(null === (_s = eventArgsSet.eventArgs) || void 0 === _s ? void 0 : _s.target);
        iconInfo && (icon2 = iconInfo.icon, position = iconInfo.position);
      }
      table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, {
        col: eventArgsSet.eventArgs.col,
        row: eventArgsSet.eventArgs.row,
        x: eventArgsSet.abstractPos.x,
        y: eventArgsSet.abstractPos.y,
        event: e.nativeEvent,
        targetIcon: icon2 ? {
          name: icon2.name,
          position,
          funcType: icon2.attribute.funcType
        } : void 0,
        target: null === (_t = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _t ? void 0 : _t.target,
        mergeCellInfo: null === (_u = eventArgsSet.eventArgs) || void 0 === _u ? void 0 : _u.mergeInfo
      });
    }
  }), table.scenegraph.tableGroup.addEventListener("pointerout", (e) => {
    var _a;
    const eventArgsSet = getCellEventArgsSet(e), cellGoup = null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target;
    "table" === (null == cellGoup ? void 0 : cellGoup.role) && eventManager.dealTableHover();
  }), table.scenegraph.tableGroup.addEventListener("pointerover", (e) => {
    var _a, _b;
    const eventArgsSet = getCellEventArgsSet(e), cellGoup = null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target;
    if (cellGoup && table.hasListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL) && "symbol" === cellGoup.type) {
      const cellGroup = e.composedPath().find((p) => "cell" === p.roll);
      if (cellGroup) {
        const { col, row } = cellGroup, eventInfo = {
          col,
          row,
          field: table.getHeaderField(col, row),
          value: table.getCellValue(col, row),
          dataValue: table.getCellOriginValue(col, row),
          cellHeaderPaths: table.internalProps.layoutMap.getCellHeaderPaths(col, row),
          title: table.getBodyColumnDefine(col, row).title,
          cellRange: table.getCellRelativeRect(col, row),
          event: e.nativeEvent,
          sparkline: {
            pointData: void 0
          },
          scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
          target: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target
        };
        table.fireListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL, eventInfo);
      }
    }
  }), table.scenegraph.tableGroup.addEventListener("pointerenter", (e) => {
    (table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.horizontalVisible || !table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.showHorizontalScrollBar(), (table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.verticalVisible || !table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.showVerticalScrollBar(), table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE, {
      event: e.nativeEvent
    });
  }), table.scenegraph.tableGroup.addEventListener("pointerleave", (e) => {
    stateManager.isResizeCol() || stateManager.isResizeRow() || stateManager.isMoveCol() || stateManager.isSelecting() || (stateManager.updateInteractionState(InteractionState.default), stateManager.updateCursor()), (table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.horizontalVisible || !table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.hideHorizontalScrollBar(), (table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.verticalVisible || !table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.hideVerticalScrollBar(), table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL) && -1 !== table.stateManager.hover.cellPos.col && -1 !== table.stateManager.hover.cellPos.row && table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
      col: table.stateManager.hover.cellPos.col,
      row: table.stateManager.hover.cellPos.row,
      cellRange: table.getCellRangeRelativeRect({
        col: table.stateManager.hover.cellPos.col,
        row: table.stateManager.hover.cellPos.row
      }),
      scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
      event: e.nativeEvent,
      target: void 0
    }), eventManager.dealTableHover();
    const target = e.target;
    target && !target.isDescendantsOf(table.scenegraph.tableGroup) && table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, {
      event: e.nativeEvent
    });
  }), table.scenegraph.tableGroup.addEventListener("pointerdown", (e) => {
    var _a, _b, _c, _d, _e;
    if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
      event: e.nativeEvent
    }), table.eventManager.isDown = true, table.eventManager.LastBodyPointerXY = {
      x: e.x,
      y: e.y
    }, table.eventManager.LastPointerXY = {
      x: e.x,
      y: e.y
    }, 0 !== e.button) return;
    const eventArgsSet = getCellEventArgsSet(e);
    if (eventManager.downIcon = void 0, stateManager.interactionState !== InteractionState.default) return;
    if (table.isPivotChart() && "chart" !== (null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target.type) && table.scenegraph.updateChartState(null), (null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target) !== (null === (_c = stateManager.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) && stateManager.hideMenu(), "chart" === (null === (_d = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.target.type)) return;
    const isCompleteEdit = null === (_e = table.editorManager) || void 0 === _e ? void 0 : _e.completeEdit(e.nativeEvent);
    getPromiseValue(isCompleteEdit, (isCompleteEdit2) => {
      var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l;
      if (false === isCompleteEdit2) return;
      const hitIcon = (null === (_c2 = null === (_b2 = null === (_a2 = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a2 ? void 0 : _a2.target) || void 0 === _b2 ? void 0 : _b2.role) || void 0 === _c2 ? void 0 : _c2.startsWith("icon")) ? eventArgsSet.eventArgs.target : (null === (_d2 = e.target.role) || void 0 === _d2 ? void 0 : _d2.startsWith("icon")) ? e.target : void 0;
      if (eventManager.downIcon = hitIcon, hitIcon && false !== hitIcon.attribute.interactive) hitIcon.attribute.funcType === IconFuncTypeEnum.dragReorder && (stateManager.startMoveCol(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_k = null === (_j = eventArgsSet.eventArgs) || void 0 === _j ? void 0 : _j.event) || void 0 === _k ? void 0 : _k.nativeEvent), stateManager.updateInteractionState(InteractionState.grabing));
      else {
        if (eventManager.cellIsHeaderCheck(eventArgsSet)) return;
        if ("touch" === e.pointerType) {
          if (eventManager.touchEnd = false, eventManager.touchSetTimeout = setTimeout(() => {
            eventManager.isTouchdown = false, eventManager.isLongTouch = true, (eventManager.touchEnd || !eventManager.checkColumnResize(eventArgsSet, true) && !eventManager.checkRowResize(eventArgsSet, true)) && (eventManager.touchEnd || !eventManager.checkColumnMover(eventArgsSet)) ? eventManager.dealTableSelect(eventArgsSet) && !eventManager.touchEnd && stateManager.updateInteractionState(InteractionState.grabing) : stateManager.updateInteractionState(InteractionState.grabing);
          }, 500), table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL)) {
            const cellGoup = e.path.find((node) => "cell" === node.role);
            "cell" !== (null == cellGoup ? void 0 : cellGoup.role) || !isValid_default(cellGoup.col) || !isValid_default(cellGoup.row) || cellGoup.col === table.stateManager.hover.cellPos.col && cellGoup.row === table.stateManager.hover.cellPos.row || cellGoup.col === (null === (_e2 = table.stateManager.hover.cellPosContainHeader) || void 0 === _e2 ? void 0 : _e2.col) && cellGoup.row === (null === (_f = table.stateManager.hover.cellPosContainHeader) || void 0 === _f ? void 0 : _f.row) || table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
              col: cellGoup.col,
              row: cellGoup.row,
              cellRange: table.getCellRangeRelativeRect({
                col: cellGoup.col,
                row: cellGoup.row
              }),
              scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
              event: e.nativeEvent,
              target: null === (_g = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _g ? void 0 : _g.target,
              mergeCellInfo: null === (_h = eventArgsSet.eventArgs) || void 0 === _h ? void 0 : _h.mergeInfo
            });
          }
          eventManager.dealTableHover(eventArgsSet);
        } else {
          if (!eventManager.checkCellFillhandle(eventArgsSet) && (eventManager.checkColumnResize(eventArgsSet, true) || eventManager.checkRowResize(eventArgsSet, true))) return table.scenegraph.updateChartState(null), void stateManager.updateInteractionState(InteractionState.grabing);
          if (eventManager.checkColumnMover(eventArgsSet)) return void stateManager.updateInteractionState(InteractionState.grabing);
          if (eventManager.checkCellFillhandle(eventArgsSet, true) && eventManager.dealFillSelect(eventArgsSet)) return void stateManager.updateInteractionState(InteractionState.grabing);
          eventManager.dealTableSelect(eventArgsSet) && stateManager.updateInteractionState(InteractionState.grabing);
        }
      }
      if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL)) {
        const eventArgsSet2 = getCellEventArgsSet(e);
        eventArgsSet2.eventArgs && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL, {
          col: eventArgsSet2.eventArgs.col,
          row: eventArgsSet2.eventArgs.row,
          event: e.nativeEvent,
          target: null === (_l = null == eventArgsSet2 ? void 0 : eventArgsSet2.eventArgs) || void 0 === _l ? void 0 : _l.target,
          mergeCellInfo: eventArgsSet2.eventArgs.mergeInfo
        });
      }
    });
  }), table.scenegraph.tableGroup.addEventListener("pointerup", (e) => {
    var _a, _b, _c, _d;
    if (0 === e.button) {
      if ("grabing" === stateManager.interactionState) {
        if (stateManager.updateInteractionState(InteractionState.default), stateManager.isResizeCol()) endResizeCol(table);
        else if (stateManager.isResizeRow()) endResizeRow(table);
        else if (stateManager.isMoveCol()) {
          const endMoveColSuccess = table.stateManager.endMoveCol();
          fireMoveColEventListeners(table, endMoveColSuccess, e.nativeEvent);
        } else if (stateManager.isSelecting()) {
          table.stateManager.endSelectCells(), table.stateManager.isFillHandle() && table.stateManager.endFillSelect();
          const eventArgsSet = getCellEventArgsSet(e);
          if (table.eventManager.isDraging && eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END)) {
            const cellsEvent = {
              event: e.nativeEvent,
              cells: [],
              col: eventArgsSet.eventArgs.target.col,
              row: eventArgsSet.eventArgs.target.row,
              scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
              target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
              mergeCellInfo: null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo
            };
            cellsEvent.cells = table.getSelectedCellInfos(), table.fireListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END, cellsEvent);
          }
        }
      } else stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
      if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL)) {
        const eventArgsSet = getCellEventArgsSet(e);
        eventArgsSet.eventArgs && table.fireListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL, {
          col: eventArgsSet.eventArgs.col,
          row: eventArgsSet.eventArgs.row,
          event: e.nativeEvent,
          target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
          mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
        });
      }
      setTimeout(() => {
        eventManager.isTouchdown = false, eventManager.isTouchMove = false, eventManager.isDraging = false, eventManager.touchMovePoints = [];
      }, 0);
    }
  }), table.scenegraph.tableGroup.addEventListener("rightdown", (e) => {
    var _a, _b, _c, _d;
    const eventArgsSet = getCellEventArgsSet(e);
    if (eventArgsSet.eventArgs) {
      stateManager.triggerContextMenu(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y);
      const { col, row } = eventArgsSet.eventArgs;
      if (table.hasListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL)) {
        const cellInfo = table.getCellInfo(col, row);
        let icon2, position;
        if (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) {
          const iconInfo = getIconAndPositionFromTarget(null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target);
          iconInfo && (icon2 = iconInfo.icon, position = iconInfo.position);
        }
        const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
          event: e.nativeEvent,
          cells: [],
          targetIcon: icon2 ? {
            name: icon2.name,
            position,
            funcType: icon2.attribute.funcType
          } : void 0,
          target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
          mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
        });
        cellInRanges(table.stateManager.select.ranges, col, row) ? cellsEvent.cells = table.getSelectedCellInfos() : cellsEvent.cells = [[cellInfo]], table.fireListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, cellsEvent);
      }
    }
  }), table.scenegraph.tableGroup.addEventListener("pointertap", (e) => {
    var _a, _b, _c, _d, _e;
    if (table.stateManager.columnResize.resizing) return;
    const eventArgsSet = getCellEventArgsSet(e);
    if (!eventManager.isTouchMove && 0 === e.button && eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.CLICK_CELL)) {
      const { col, row } = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row);
      let icon2, position;
      if (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) {
        const iconInfo = getIconAndPositionFromTarget(null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target);
        iconInfo && (icon2 = iconInfo.icon, position = iconInfo.position);
      }
      const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
        event: e.nativeEvent,
        federatedEvent: e,
        cells: [],
        targetIcon: icon2 ? {
          name: icon2.name,
          position,
          funcType: icon2.attribute.funcType
        } : void 0,
        target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
        mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
      });
      table.fireListeners(TABLE_EVENT_TYPE.CLICK_CELL, cellsEvent);
    }
    if (!table.stateManager.columnResize.resizing && !table.stateManager.columnMove.moving && (eventManager.dealIconClick(e, eventArgsSet), (null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) && eventManager.touchSetTimeout && "touch" === e.pointerType)) {
      const eventArgsSet2 = getCellEventArgsSet(e);
      if (eventManager.touchSetTimeout) {
        clearTimeout(eventManager.touchSetTimeout);
        const isHasSelected = !!(null === (_e = stateManager.select.ranges) || void 0 === _e ? void 0 : _e.length);
        eventManager.dealTableSelect(eventArgsSet2), stateManager.endSelectCells(true, isHasSelected), eventManager.touchSetTimeout = void 0;
      }
    }
  }), table.scenegraph.stage.addEventListener("pointerdown", (e) => {
    var _a, _b, _c, _d;
    const eventArgsSet = getCellEventArgsSet(e);
    (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) && (null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target) === (null === (_c = stateManager.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) || stateManager.hideMenu();
    const isCompleteEdit = null === (_d = table.editorManager) || void 0 === _d ? void 0 : _d.completeEdit(e.nativeEvent);
    getPromiseValue(isCompleteEdit, (isCompleteEdit2) => {
      var _a2;
      if (false === isCompleteEdit2) return;
      const hitIcon = (null === (_a2 = e.target.role) || void 0 === _a2 ? void 0 : _a2.startsWith("icon")) ? e.target : void 0;
      if (eventManager.downIcon = hitIcon, "touch" === e.pointerType || hitIcon || eventManager.checkCellFillhandle(eventArgsSet) || stateManager.columnResize.resizing || !eventManager.checkColumnResize(eventArgsSet, true)) ;
      else {
        table.scenegraph.updateChartState(null), stateManager.updateInteractionState(InteractionState.grabing);
        const { eventArgs } = eventArgsSet;
        if (!(null == eventArgs ? void 0 : eventArgs.targetCell)) {
          table.getCellAt(eventArgsSet.abstractPos.x - table.theme.columnResize.resizeHotSpotSize / 2, eventArgsSet.abstractPos.y) && table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
            event: e.nativeEvent
          });
        }
      }
    });
  }), table.scenegraph.stage.addEventListener("pointerup", (e) => {
    "grabing" === stateManager.interactionState && (stateManager.updateInteractionState(InteractionState.default), stateManager.isResizeCol() ? endResizeCol(table) : stateManager.isResizeRow() && endResizeRow(table));
  }), table.scenegraph.stage.addEventListener("pointertap", (e) => {
    var _a, _b, _c;
    const target = e.target;
    if (table.eventManager.isDraging || !target || !target.isDescendantsOf(table.scenegraph.stage) && target.stage !== target || target.isDescendantsOf(table.scenegraph.tableGroup)) table.eventManager.isDraging && stateManager.isSelecting() && stateManager.endSelectCells();
    else {
      stateManager.updateInteractionState(InteractionState.default), eventManager.dealTableHover();
      const isHasSelected = !!(null === (_a = stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
      (null === (_c = null === (_b = table.options.select) || void 0 === _b ? void 0 : _b.blankAreaClickDeselect) || void 0 === _c || _c) && eventManager.dealTableSelect(), stateManager.endSelectCells(true, isHasSelected), stateManager.updateCursor(), table.scenegraph.updateChartState(null);
    }
  }), table.scenegraph.stage.addEventListener("pointermove", (e) => {
    const eventArgsSet = getCellEventArgsSet(e);
    stateManager.isResizeCol() || eventManager.checkColumnResize(eventArgsSet) ? table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet) ? stateManager.updateCursor("crosshair") : stateManager.updateCursor("col-resize") : stateManager.isResizeRow() || eventManager.checkRowResize(eventArgsSet) ? table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet) ? stateManager.updateCursor("crosshair") : stateManager.updateCursor("row-resize") : stateManager.isMoveCol() || stateManager.updateCursor();
  }), table.scenegraph.tableGroup.addEventListener("checkbox_state_change", (e) => {
    var _a, _b;
    const eventArgsSet = getCellEventArgsSet(e), { col, row } = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), mergeRange = getCellMergeInfo(table, col, row);
    if (mergeRange) for (let col2 = mergeRange.start.col; col2 <= mergeRange.end.col; col2++) for (let row2 = mergeRange.start.row; row2 <= mergeRange.end.row; row2++) {
      table.scenegraph.getCell(col2, row2).forEachChildren((checkbox) => {
        "checkbox" === checkbox.name && checkbox.setAttributes({
          checked: e.target.attribute.checked,
          indeterminate: e.target.attribute.indeterminate
        });
      });
    }
    const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
      event: e.nativeEvent,
      target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
      mergeCellInfo: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo,
      checked: e.detail.checked
    });
    if (table.isHeader(col, row)) {
      table.stateManager.setHeaderCheckedState(cellInfo.field, e.detail.checked);
      "checkbox" === table.getCellType(col, row) && table.scenegraph.updateCheckboxCellState(col, row, e.detail.checked);
    } else {
      table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked);
      if ("checkbox" === table.getCellType(col, row)) {
        const oldHeaderCheckedState = table.stateManager.headerCheckedState[cellInfo.field], newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(cellInfo.field, col, row);
        oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
      }
    }
    table.fireListeners(TABLE_EVENT_TYPE.CHECKBOX_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
  }), table.scenegraph.tableGroup.addEventListener("radio_checked", (e) => {
    var _a, _b, _c;
    const eventArgsSet = getCellEventArgsSet(e), { col, row, target } = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), indexInCell = null === (_a = regIndexReg.exec(target.id)) || void 0 === _a ? void 0 : _a[1], mergeRange = getCellMergeInfo(table, col, row);
    if (mergeRange) for (let col2 = mergeRange.start.col; col2 <= mergeRange.end.col; col2++) for (let row2 = mergeRange.start.row; row2 <= mergeRange.end.row; row2++) {
      table.scenegraph.getCell(col2, row2).forEachChildren((radio) => {
        "radio" === radio.name && radio.id === target.id && radio.setAttributes({
          checked: true
        });
      });
    }
    const radioCheckType = table.getBodyColumnDefine(col, row).radioCheckType || "column";
    if ("cell" === radioCheckType) if (mergeRange) for (let col2 = mergeRange.start.col; col2 <= mergeRange.end.col; col2++) for (let row2 = mergeRange.start.row; row2 <= mergeRange.end.row; row2++) {
      table.scenegraph.getCell(col2, row2).forEachChildren((radio) => {
        "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
          checked: false
        });
      });
    }
    else {
      table.scenegraph.getCell(col, row).forEachChildren((radio) => {
        "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
          checked: false
        });
      });
    }
    else if ("column" === radioCheckType) {
      table.scenegraph.getColGroup(col).forEachChildren((cellGroup) => {
        cellGroup.forEachChildren((radio) => {
          "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
            checked: false
          });
        });
      });
    }
    const radioIndexInCell = indexInCell ? Number(indexInCell) : void 0;
    table.stateManager.setRadioState(col, row, cellInfo.field, radioCheckType, radioIndexInCell);
    const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
      event: e.nativeEvent,
      target: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target,
      mergeCellInfo: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.mergeInfo,
      radioIndexInCell
    });
    table.fireListeners(TABLE_EVENT_TYPE.RADIO_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
  }), table.scenegraph.tableGroup.addEventListener("switch_state_change", (e) => {
    var _a, _b;
    const eventArgsSet = getCellEventArgsSet(e), { col, row, target } = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), mergeRange = getCellMergeInfo(table, col, row);
    if (mergeRange) for (let col2 = mergeRange.start.col; col2 <= mergeRange.end.col; col2++) for (let row2 = mergeRange.start.row; row2 <= mergeRange.end.row; row2++) {
      table.scenegraph.getCell(col2, row2).forEachChildren((switchComponent) => {
        "switch" === switchComponent.name && switchComponent.setAttributes({
          checked: e.target.attribute.checked
        });
      });
    }
    const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
      event: e.nativeEvent,
      target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
      mergeCellInfo: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo,
      checked: e.detail.checked
    });
    table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked), table.fireListeners(TABLE_EVENT_TYPE.SWITCH_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
  }), table.scenegraph.stage.addEventListener("wheel", (e) => {
    var _a;
    e.path.find((node) => "legend" === node.name) || (null === (_a = table.editorManager) || void 0 === _a || _a.completeEdit(), table.eventManager._enableTableScroll && handleWhell(e, stateManager));
  });
}
function bindGesture(eventManager) {
  const table = eventManager.table;
  eventManager.gesture = new Gesture(table.scenegraph.tableGroup, {
    tap: {
      interval: 300
    }
  }), eventManager.gesture.on("doubletap", (e) => {
    dblclickHandler(e, table);
  });
}
function endResizeCol(table) {
  table.stateManager.endResizeCol();
  const columns = [];
  for (let col = 0; col < table.colCount; col++) columns.push(table.getColWidth(col));
  table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
    col: table.stateManager.columnResize.col,
    colWidths: columns
  });
}
function endResizeRow(table) {
  table.stateManager.endResizeRow(), table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW_END, {
    row: table.stateManager.rowResize.row,
    rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
  });
}
function dblclickHandler(e, table) {
  var _a, _b, _c, _d, _e, _f;
  const eventArgsSet = getCellEventArgsSet(e);
  let col = -1, row = -1;
  eventArgsSet.eventArgs && (col = eventArgsSet.eventArgs.col, row = eventArgsSet.eventArgs.row);
  const value = table.getCellValue(col, row), bounds = null === (_b = null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.targetCell) || void 0 === _b ? void 0 : _b.globalAABBBounds;
  if (bounds && table.internalProps.focusControl.setFocusRect(new Rect2(bounds.x1 + table.scrollLeft, bounds.y1 + table.scrollTop, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1), value), table.hasListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL)) {
    const cellInfo = table.getCellInfo(col, row);
    let icon2, position;
    if (null === (_c = eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target) {
      const iconInfo = getIconAndPositionFromTarget(null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.target);
      iconInfo && (icon2 = iconInfo.icon, position = iconInfo.position);
    }
    const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
      event: e.nativeEvent,
      federatedEvent: e,
      cells: [],
      targetIcon: icon2 ? {
        name: icon2.name,
        position,
        funcType: icon2.attribute.funcType
      } : void 0,
      target: null === (_e = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _e ? void 0 : _e.target,
      mergeCellInfo: null === (_f = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _f ? void 0 : _f.mergeInfo
    });
    table.fireListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL, cellsEvent);
  }
}

// node_modules/@visactor/vtable/es/event/listener/scroll-bar.js
function bindScrollBarListener(eventManager) {
  const table = eventManager.table, stateManager = table.stateManager, scenegraph = table.scenegraph;
  scenegraph.component.vScrollBar.addEventListener("pointerover", (e) => {
    stateManager.showVerticalScrollBar();
  }), scenegraph.component.hScrollBar.addEventListener("pointerover", (e) => {
    stateManager.showHorizontalScrollBar();
  }), scenegraph.component.vScrollBar.addEventListener("pointerout", (e) => {
    stateManager.interactionState !== InteractionState.scrolling && stateManager.hideVerticalScrollBar();
  }), scenegraph.component.hScrollBar.addEventListener("pointerout", (e) => {
    stateManager.interactionState !== InteractionState.scrolling && stateManager.hideHorizontalScrollBar();
  }), scenegraph.component.vScrollBar.addEventListener("pointermove", (e) => {
    scenegraph.table.stateManager.updateCursor("default"), e.stopPropagation();
  }), scenegraph.component.vScrollBar.addEventListener("pointerdown", (e) => {
    e.stopPropagation(), scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
      event: e.nativeEvent
    });
  }), scenegraph.component.vScrollBar.addEventListener("scrollDown", (e) => {
    var _a;
    scenegraph.table.eventManager.LastBodyPointerXY = {
      x: e.x,
      y: e.y
    }, scenegraph.table.eventManager.isDown = true, stateManager.interactionState !== InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.scrolling), scenegraph.table.stateManager.hideMenu(), null === (_a = scenegraph.table.editorManager) || void 0 === _a || _a.completeEdit(), scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
      event: e.nativeEvent
    });
  }), scenegraph.component.vScrollBar.addEventListener("pointerup", () => {
    stateManager.fastScrolling = false, scenegraph.table.eventManager.isDraging = false, stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
  }), scenegraph.component.vScrollBar.addEventListener("pointerupoutside", () => {
    stateManager.fastScrolling = false, stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
  }), scenegraph.component.vScrollBar.addEventListener("scrollUp", (e) => {
    scenegraph.table.eventManager.isDraging = false;
  }), scenegraph.component.hScrollBar.addEventListener("pointermove", (e) => {
    scenegraph.table.stateManager.updateCursor("default"), e.stopPropagation();
  }), scenegraph.component.hScrollBar.addEventListener("pointerdown", (e) => {
    e.stopPropagation(), scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
      event: e.nativeEvent
    });
  }), scenegraph.component.hScrollBar.addEventListener("scrollDown", (e) => {
    var _a;
    scenegraph.table.eventManager.LastBodyPointerXY = {
      x: e.x,
      y: e.y
    }, scenegraph.table.eventManager.isDown = true, stateManager.interactionState !== InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.scrolling), scenegraph.table.stateManager.hideMenu(), null === (_a = scenegraph.table.editorManager) || void 0 === _a || _a.completeEdit(), scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
      event: e.nativeEvent
    });
  }), scenegraph.component.hScrollBar.addEventListener("pointerup", () => {
    stateManager.fastScrolling = false, scenegraph.table.eventManager.isDraging = false, stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
  }), scenegraph.component.hScrollBar.addEventListener("pointerupoutside", () => {
    stateManager.fastScrolling = false, stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
  }), scenegraph.component.hScrollBar.addEventListener("scrollUp", (e) => {
    scenegraph.table.eventManager.isDraging = false;
  });
  const throttleVerticalWheel = throttle(stateManager.updateVerticalScrollBar, 20), throttleHorizontalWheel = throttle(stateManager.updateHorizontalScrollBar, 20);
  scenegraph.component.vScrollBar.addEventListener("scrollDrag", (e) => {
    scenegraph.table.eventManager.isDown && (scenegraph.table.eventManager.isDraging = true), stateManager.fastScrolling = true, stateManager.interactionState !== InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.scrolling);
    const ratio = e.detail.value[0] / (1 - e.detail.value[1] + e.detail.value[0]);
    throttleVerticalWheel(ratio, e);
  }), scenegraph.component.hScrollBar.addEventListener("scrollDrag", (e) => {
    scenegraph.table.eventManager.isDown && (scenegraph.table.eventManager.isDraging = true), stateManager.fastScrolling = true, stateManager.interactionState !== InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.scrolling);
    const ratio = e.detail.value[0] / (1 - e.detail.value[1] + e.detail.value[0]);
    throttleHorizontalWheel(ratio);
  });
}

// node_modules/@visactor/vtable/es/tools/pixel-ratio.js
var defaultPixelRatio = 1;
function getPixelRatio() {
  return isNode ? defaultPixelRatio = 1 : (defaultPixelRatio = Math.ceil(window.devicePixelRatio || 1), defaultPixelRatio > 1 && defaultPixelRatio % 2 != 0 && (defaultPixelRatio += 1)), defaultPixelRatio;
}
getPixelRatio();

// node_modules/@visactor/vtable/es/event/listener/container-dom.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function bindContainerDomListener(eventManager) {
  const table = eventManager.table, stateManager = table.stateManager, handler = table.internalProps.handler;
  function handleKeydownListener(e) {
    var _a;
    if (table.hasListeners(TABLE_EVENT_TYPE.KEYDOWN)) {
      const cellsEvent = {
        keyCode: null !== (_a = e.keyCode) && void 0 !== _a ? _a : e.which,
        code: e.code,
        event: e,
        scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth
      };
      table.fireListeners(TABLE_EVENT_TYPE.KEYDOWN, cellsEvent);
    }
  }
  handler.on(table.getElement(), "blur", (e) => {
    eventManager.dealTableHover();
  }), handler.on(table.getElement(), "keydown", (e) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    const beforeKeydownEvent = {
      keyCode: null !== (_a = e.keyCode) && void 0 !== _a ? _a : e.which,
      code: e.code,
      event: e
    };
    if (table.fireListeners(TABLE_EVENT_TYPE.BEFORE_KEYDOWN, beforeKeydownEvent), "a" === e.key && (e.ctrlKey || e.metaKey)) (null === (_b = table.keyboardOptions) || void 0 === _b ? void 0 : _b.selectAllOnCtrlA) && (e.preventDefault(), eventManager.deelTableSelectAll());
    else if (stateManager.select.cellPos.col >= 0 && stateManager.select.cellPos.row >= 0 && ("ArrowUp" === e.key || "ArrowDown" === e.key || "ArrowLeft" === e.key || "ArrowRight" === e.key)) {
      if ((null === (_d = null === (_c = table.options.keyboardOptions) || void 0 === _c ? void 0 : _c.moveEditCellOnArrowKeys) || void 0 === _d || !_d) && (null === (_e = table.editorManager) || void 0 === _e ? void 0 : _e.editingEditor) || false === (null === (_f = table.options.keyboardOptions) || void 0 === _f ? void 0 : _f.moveSelectedCellOnArrowKeys)) return;
      let targetCol, targetRow;
      if (e.preventDefault(), e.stopPropagation(), "ArrowUp" === e.key ? e.ctrlKey || e.metaKey ? (targetCol = stateManager.select.cellPos.col, targetRow = 0) : (e.shiftKey, targetCol = stateManager.select.cellPos.col, targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row - 1))) : "ArrowDown" === e.key ? e.ctrlKey || e.metaKey ? (targetCol = stateManager.select.cellPos.col, targetRow = table.rowCount - 1) : (e.shiftKey, targetCol = stateManager.select.cellPos.col, targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1))) : "ArrowLeft" === e.key ? e.ctrlKey || e.metaKey ? (targetCol = 0, targetRow = stateManager.select.cellPos.row) : (e.shiftKey, targetRow = stateManager.select.cellPos.row, targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col - 1))) : "ArrowRight" === e.key && (e.ctrlKey || e.metaKey ? (targetCol = table.colCount - 1, targetRow = stateManager.select.cellPos.row) : (e.shiftKey, targetRow = stateManager.select.cellPos.row, targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col + 1)))), isCellDisableSelect(table, targetCol, targetRow)) return;
      table.selectCell(targetCol, targetRow, e.shiftKey), null !== (_h = null === (_g = table.options.keyboardOptions) || void 0 === _g ? void 0 : _g.moveEditCellOnArrowKeys) && void 0 !== _h && _h && (null === (_j = table.editorManager) || void 0 === _j ? void 0 : _j.editingEditor) && (table.editorManager.completeEdit(), table.getElement().focus(), table.getEditor(targetCol, targetRow) && table.editorManager.startEditCell(targetCol, targetRow));
    } else if ("Escape" === e.key) null === (_k = table.editorManager) || void 0 === _k || _k.cancelEdit(), table.getElement().focus();
    else if ("Enter" === e.key) {
      if (null === (_l = table.editorManager) || void 0 === _l ? void 0 : _l.editingEditor) {
        if (handleKeydownListener(e), table.editorManager.completeEdit(), table.getElement().focus(), true === (null === (_m = table.options.keyboardOptions) || void 0 === _m ? void 0 : _m.moveFocusCellOnEnter)) {
          const targetCol = stateManager.select.cellPos.col, targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
          if (isCellDisableSelect(table, targetCol, targetRow)) return;
          table.selectCell(targetCol, targetRow, e.shiftKey);
        }
        return;
      }
      if (true === (null === (_o = table.options.keyboardOptions) || void 0 === _o ? void 0 : _o.moveFocusCellOnEnter)) {
        const targetCol = stateManager.select.cellPos.col, targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
        if (isCellDisableSelect(table, targetCol, targetRow)) return;
        table.selectCell(targetCol, targetRow, e.shiftKey);
      } else if ((null === (_q = null === (_p = table.options.keyboardOptions) || void 0 === _p ? void 0 : _p.editCellOnEnter) || void 0 === _q || _q) && 1 === (null !== (_s = null === (_r = table.stateManager.select.ranges) || void 0 === _r ? void 0 : _r.length) && void 0 !== _s ? _s : 0)) {
        const startCol = table.stateManager.select.ranges[0].start.col, startRow = table.stateManager.select.ranges[0].start.row, endCol = table.stateManager.select.ranges[0].end.col, endRow = table.stateManager.select.ranges[0].end.row;
        startCol === endCol && startRow === endRow && table.getEditor(startCol, startRow) && table.editorManager.startEditCell(startCol, startRow);
      }
    } else if ("Tab" === e.key) {
      if ((null === (_u = null === (_t = table.options.keyboardOptions) || void 0 === _t ? void 0 : _t.moveFocusCellOnTab) || void 0 === _u || _u) && stateManager.select.cellPos.col >= 0 && stateManager.select.cellPos.row >= 0) {
        if (stateManager.select.cellPos.col === table.colCount - 1 && stateManager.select.cellPos.row === table.rowCount - 1) return;
        let targetCol, targetRow;
        if (e.preventDefault(), stateManager.select.cellPos.col === table.colCount - 1 ? (targetRow = Math.min(table.rowCount - 1, stateManager.select.cellPos.row + 1), targetCol = table.rowHeaderLevelCount) : (targetRow = stateManager.select.cellPos.row, targetCol = stateManager.select.cellPos.col + 1), isCellDisableSelect(table, targetCol, targetRow)) return;
        table.selectCell(targetCol, targetRow), (null === (_v = table.editorManager) || void 0 === _v ? void 0 : _v.editingEditor) && (table.editorManager.completeEdit(), table.getElement().focus(), table.getEditor(targetCol, targetRow) && table.editorManager.startEditCell(targetCol, targetRow));
      }
    } else if (!e.ctrlKey && !e.metaKey) {
      const editCellTrigger = table.options.editCellTrigger;
      if (("keydown" === editCellTrigger || Array.isArray(editCellTrigger) && editCellTrigger.includes("keydown")) && !(null === (_w = table.editorManager) || void 0 === _w ? void 0 : _w.editingEditor)) {
        const allowedKeys = /^[a-zA-Z0-9+\-*\/%=.,\s]$/;
        e.key.match(allowedKeys) && (table.editorManager.beginTriggerEditCellMode = "keydown", table.editorManager.startEditCell(stateManager.select.cellPos.col, stateManager.select.cellPos.row, ""));
      }
    }
    handleKeydownListener(e);
  }), handler.on(table.getElement(), "copy", (e) => __awaiter14(this, void 0, void 0, function* () {
    var _a, _b;
    if (null === (_a = table.keyboardOptions) || void 0 === _a ? void 0 : _a.copySelected) {
      const data = table.getCopyValue();
      if (isValid_default(data)) {
        e.preventDefault();
        const permissionState = yield navigator.permissions.query({
          name: "clipboard-write"
        });
        if ((null === (_b = navigator.clipboard) || void 0 === _b ? void 0 : _b.write) && "granted" === permissionState.state) {
          const setDataToHTML = (data2) => {
            const result2 = ["<table>"], META_HEAD = ['<meta name="author" content="Visactor"/>', '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join(""), rows = data2.split("\r\n");
            return rows.forEach(function(rowCells, rowIndex) {
              const cells = rowCells.split("	"), rowValues = [];
              0 === rowIndex && result2.push("<tbody>"), cells.forEach(function(cell, cellIndex) {
                const parsedCellData = cell ? cell.toString().replace(/&/g, "&amp;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20{2,}/gi, (substring) => `<span style="mso-spacerun: yes">${"&nbsp;".repeat(substring.length - 1)} </span>`).replace(/\t/gi, "&#9;") : " ";
                rowValues.push(`<td>${parsedCellData}</td>`);
              }), result2.push("<tr>", ...rowValues, "</tr>"), rowIndex === rows.length - 1 && result2.push("</tbody>");
            }), result2.push("</table>"), [META_HEAD, result2.join("")].join("");
          }, dataHTML = setDataToHTML(data);
          navigator.clipboard.write([new ClipboardItem({
            "text/html": new Blob([dataHTML], {
              type: "text/html"
            }),
            "text/plain": new Blob([data], {
              type: "text/plain"
            })
          })]);
        } else browser2.IE ? window.clipboardData.setData("Text", data) : e.clipboardData.setData("text/plain", data);
        table.fireListeners(TABLE_EVENT_TYPE.COPY_DATA, {
          cellRange: table.stateManager.select.ranges,
          copyData: data
        });
      }
    }
  })), handler.on(table.getElement(), "paste", (e) => {
    var _a, _b, _c, _d;
    if ((null === (_a = table.keyboardOptions) || void 0 === _a ? void 0 : _a.pasteValueToCell) && table.changeCellValues) {
      if (null === (_b = table.editorManager) || void 0 === _b ? void 0 : _b.editingEditor) return;
      if ((null === (_c = table.stateManager.select.ranges) || void 0 === _c ? void 0 : _c.length) > 0) if (null === (_d = navigator.clipboard) || void 0 === _d ? void 0 : _d.read) navigator.clipboard.read().then((clipboardItems) => {
        for (const item of clipboardItems) item.types.includes("text/html") ? pasteHtmlToTable(item) : 1 === item.types.length && "text/plain" === item.types[0] && pasteTextToTable(item);
      });
      else {
        const ranges = table.stateManager.select.ranges, col = Math.min(ranges[0].start.col, ranges[0].end.col), row = Math.min(ranges[0].start.row, ranges[0].end.row), rows = (e.clipboardData || window.Clipboard).getData("text").split("\n"), values = [];
        rows.forEach(function(rowCells, rowIndex) {
          const cells = rowCells.split("	"), rowValues = [];
          values.push(rowValues), cells.forEach(function(cell, cellIndex) {
            cellIndex === cells.length - 1 && (cell = cell.trim()), rowValues.push(cell);
          });
        }), table.changeCellValues(col, row, values);
      }
    }
  }), handler.on(table.getElement(), "contextmenu", (e) => {
    var _a;
    false !== (null === (_a = table.eventOptions) || void 0 === _a ? void 0 : _a.preventDefaultContextMenu) ? e.preventDefault() : globalPointerupCallback(e);
  }), table.options.canvas || handler.on(table.getContainer(), "resize", (e) => {
    var _a;
    table.isReleased || 0 === e.width && 0 === e.height || ((table.autoFillWidth || table.autoFillHeight) && (null === (_a = table.editorManager) || void 0 === _a || _a.completeEdit()), isValid_default(table.options.pixelRatio) || table.setPixelRatio(getPixelRatio()), e.windowSizeNotChange || table.resize());
  });
  const regex = /<tr[^>]*>([\s\S]*?)<\/tr>/g, cellRegex = /<td[^>]*>([\s\S]*?)<\/td>/g;
  function pasteHtmlToTable(item) {
    const ranges = table.stateManager.select.ranges, selectRangeLength = ranges.length, col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row), maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
    let pasteValuesColCount = 0, pasteValuesRowCount = 0, values = [];
    item.getType("text/html").then((blob) => {
      blob.text().then((pastedData) => {
        var _a, _b;
        if (pastedData && /(<table)|(<TABLE)/g.test(pastedData)) {
          const matches = Array.from(pastedData.matchAll(regex));
          for (const match of matches) {
            const rowContent = match[1], rowValues = Array.from(rowContent.matchAll(cellRegex)).map((cellMatch) => cellMatch[1].replace(/(<(?!br)([^>]+)>)/gi, "").replace(/<br(\s*|\/)>[\r\n]?/gim, "\n").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#9;/gi, "	").replace(/&nbsp;/g, " "));
            values.push(rowValues), pasteValuesColCount = Math.max(pasteValuesColCount, null !== (_a = null == rowValues ? void 0 : rowValues.length) && void 0 !== _a ? _a : 0);
          }
          pasteValuesRowCount = null !== (_b = values.length) && void 0 !== _b ? _b : 0, values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1), table.changeCellValues(col, row, values, true);
        } else navigator.clipboard.read().then((clipboardItems) => {
          for (const item2 of clipboardItems) item2.types.includes("text/plain") && item2.getType("text/plain").then((blob2) => {
            blob2.text().then(_pasteValue);
          });
        });
      });
    });
  }
  function _pasteValue(pastedData) {
    var _a;
    const ranges = table.stateManager.select.ranges, selectRangeLength = ranges.length, col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row), maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
    let pasteValuesColCount = 0, pasteValuesRowCount = 0, values = [];
    pastedData.split("\n").forEach(function(rowCells, rowIndex) {
      var _a2;
      const cells = rowCells.split("	"), rowValues = [];
      values.push(rowValues), cells.forEach(function(cell, cellIndex) {
        cellIndex === cells.length - 1 && (cell = cell.trim()), rowValues.push(cell);
      }), pasteValuesColCount = Math.max(pasteValuesColCount, null !== (_a2 = null == rowValues ? void 0 : rowValues.length) && void 0 !== _a2 ? _a2 : 0);
    }), pasteValuesRowCount = null !== (_a = values.length) && void 0 !== _a ? _a : 0, values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1), table.changeCellValues(col, row, values, true);
  }
  function pasteTextToTable(item) {
    const ranges = table.stateManager.select.ranges, selectRangeLength = ranges.length, col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row), maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col), maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
    let pasteValuesColCount = 0, pasteValuesRowCount = 0;
    item.getType("text/plain").then((blob) => {
      blob.text().then((pastedData) => {
        var _a;
        const rows = pastedData.replace(/\r(?!\n)/g, "\r\n").split("\r\n");
        let values = [];
        rows.length > 1 && "" === rows[rows.length - 1] && rows.pop(), rows.forEach(function(rowCells, rowIndex) {
          var _a2;
          const cells = rowCells.split("	"), rowValues = [];
          values.push(rowValues), cells.forEach(function(cell, cellIndex) {
            cell.includes("\n") && (cell = cell.replace(/^"(.*)"$/, "$1").replace(/["]*/g, (match) => new Array(Math.floor(match.length / 2)).fill('"').join(""))), rowValues.push(cell);
          }), pasteValuesColCount = Math.max(pasteValuesColCount, null !== (_a2 = null == rowValues ? void 0 : rowValues.length) && void 0 !== _a2 ? _a2 : 0);
        }), pasteValuesRowCount = null !== (_a = values.length) && void 0 !== _a ? _a : 0, values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1), table.changeCellValues(col, row, values, true);
      });
    });
  }
  function handlePasteValues(values, rowCount, colCount, selectedRowCount, selectedColCount) {
    if (selectedColCount > colCount || selectedRowCount > rowCount) {
      if (selectedColCount % colCount == 0 && selectedRowCount % rowCount == 0) {
        const toPasteValues = [];
        for (let i = 0; i < selectedRowCount; i++) {
          const rowPasteValue = [];
          toPasteValues.push(rowPasteValue);
          for (let j = 0; j < selectedColCount; j++) {
            const copiedRow = i % rowCount, copiedCol = j % colCount;
            rowPasteValue.push(values[copiedRow][copiedCol]);
          }
        }
        return toPasteValues;
      }
      return values;
    }
    return values;
  }
  const globalPointerdownCallback = (e) => {
    var _a;
    if (table.isReleased) return;
    table.eventManager.LastBodyPointerXY = {
      x: e.x,
      y: e.y
    }, table.eventManager.isDown = true;
    const target = e.target;
    if (!table.getElement().contains(target) && !table.internalProps.menuHandler.containElement(target)) {
      const isCompleteEdit = null === (_a = table.editorManager) || void 0 === _a ? void 0 : _a.completeEdit(e);
      getPromiseValue(isCompleteEdit, (isCompleteEdit2) => {
        var _a2, _b;
        if (false !== isCompleteEdit2 && (null === (_a2 = table.options.select) || void 0 === _a2 ? void 0 : _a2.outsideClickDeselect)) {
          const isHasSelected = !!(null === (_b = stateManager.select.ranges) || void 0 === _b ? void 0 : _b.length);
          eventManager.dealTableSelect(), stateManager.endSelectCells(true, isHasSelected);
        }
      });
    }
  };
  eventManager.globalEventListeners.push({
    name: "pointerdown",
    env: "vglobal",
    callback: globalPointerdownCallback
  }), vglobal.addEventListener("pointerdown", globalPointerdownCallback);
  const globalPointerupCallback = (e) => {
    var _a;
    if (table.isReleased) return;
    const target = e.target;
    if (target !== table.canvas && ((e3) => {
      var _a2, _b;
      if (stateManager.menu.isShow && setTimeout(() => {
        table.internalProps.menuHandler.pointInMenuElement(e3.clientX, e3.clientY) || stateManager.menu.isShow && stateManager.hideMenu();
      }, 0), stateManager.isResizeCol()) endResizeCol(table);
      else if (stateManager.isResizeRow()) endResizeRow(table);
      else if (stateManager.isMoveCol()) {
        const endMoveColSuccess = table.stateManager.endMoveCol();
        fireMoveColEventListeners(table, endMoveColSuccess, e3);
      } else if (stateManager.isSelecting() && (null === (_b = null === (_a2 = table.stateManager.select) || void 0 === _a2 ? void 0 : _a2.ranges) || void 0 === _b ? void 0 : _b.length)) {
        const lastCol = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end.col, lastRow = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end.row;
        if (table.stateManager.endSelectCells(), table.hasListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END)) {
          const cellsEvent = {
            event: e3,
            cells: [],
            col: lastCol,
            row: lastRow,
            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
            target: void 0
          };
          cellsEvent.cells = table.getSelectedCellInfos(), table.fireListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END, cellsEvent);
        }
      }
    })(e), table.eventManager.LastBodyPointerXY = null, table.eventManager.isDown = false, table.eventManager.isDraging = false, table.eventManager.inertiaScroll.endInertia(), "grabing" === stateManager.interactionState && stateManager.isResizeCol()) endResizeCol(table);
    else if ("grabing" === stateManager.interactionState && stateManager.isResizeRow()) endResizeRow(table);
    else if (stateManager.isMoveCol()) {
      const endMoveColSuccess = table.stateManager.endMoveCol();
      fireMoveColEventListeners(table, endMoveColSuccess, e);
    } else if (table.editorManager.editingEditor && !table.getElement().contains(target)) {
      const isCompleteEdit = null === (_a = table.editorManager) || void 0 === _a ? void 0 : _a.completeEdit(e);
      getPromiseValue(isCompleteEdit, (isCompleteEdit2) => {
        false !== isCompleteEdit2 && (stateManager.updateInteractionState(InteractionState.default), eventManager.dealTableHover());
      });
    }
  };
  eventManager.globalEventListeners.push({
    name: "pointerup",
    env: "vglobal",
    callback: globalPointerupCallback
  }), vglobal.addEventListener("pointerup", globalPointerupCallback);
  const globalPointermoveCallback = (e) => {
    var _a, _b, _c, _d, _e;
    if (table.eventManager.isDown && table.eventManager.LastBodyPointerXY) {
      const lastX = null !== (_b = null === (_a = table.eventManager.LastBodyPointerXY) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : e.x, lastY = null !== (_d = null === (_c = table.eventManager.LastBodyPointerXY) || void 0 === _c ? void 0 : _c.y) && void 0 !== _d ? _d : e.y;
      (Math.abs(lastX - e.x) > 1 || Math.abs(lastY - e.y) > 1) && (table.eventManager.isDraging = true);
    }
    const { x, y } = table._getMouseAbstractPoint(e);
    stateManager.interactionState === InteractionState.grabing && (stateManager.isResizeCol() ? (eventManager.dealColumnResize(x, y), table.hasListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN) && table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN, {
      col: table.stateManager.columnResize.col,
      colWidth: table.getColWidth(table.stateManager.columnResize.col)
    })) : stateManager.isResizeRow() && (eventManager.dealRowResize(x, y), table.hasListeners(TABLE_EVENT_TYPE.RESIZE_ROW) && table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW, {
      row: table.stateManager.rowResize.row,
      rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
    })));
    const isSelecting = table.stateManager.isSelecting();
    if (eventManager._enableTableScroll && eventManager.isDraging && isSelecting && (null === (_e = table.stateManager.select.ranges) || void 0 === _e ? void 0 : _e.length) > 0) {
      const drawRange = table.getDrawRange(), topFrozenRowHeight = table.getFrozenRowsHeight(), bottomFrozenRowHeight = table.getBottomFrozenRowsHeight(), leftFrozenColsWidth = table.getFrozenColsWidth(), rightFrozenColsWidth = table.getRightFrozenColsWidth(), startCell = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].start;
      if (table.isSeriesNumber(startCell.col, startCell.row)) return;
      const endCell = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end, canScrollY = (false === table.isFrozenRow(startCell.row) || false === table.isFrozenRow(endCell.row)) && table.getAllRowsHeight() > table.tableNoFrameHeight, canScrollX = (false === table.isFrozenColumn(startCell.col) || false === table.isFrozenColumn(endCell.col)) && table.getAllColsWidth() > table.tableNoFrameWidth;
      if ((y > drawRange.bottom - bottomFrozenRowHeight || y < drawRange.top + topFrozenRowHeight) && canScrollY || (x > drawRange.right - rightFrozenColsWidth || x < drawRange.left + leftFrozenColsWidth) && canScrollX) {
        table.eventManager.scrollXSpeed = 0, table.eventManager.scrollYSpeed = 0;
        let bottom = false, top = false, right = false, left = false;
        y > drawRange.bottom - bottomFrozenRowHeight && canScrollY && table.scrollTop + table.tableNoFrameHeight < table.getAllRowsHeight() ? (bottom = true, table.eventManager.scrollYSpeed = -(y - drawRange.bottom + bottomFrozenRowHeight) / 50) : y < drawRange.top + topFrozenRowHeight && canScrollY && table.scrollTop > 0 && (top = true, table.eventManager.scrollYSpeed = -(y - drawRange.top - topFrozenRowHeight) / 50), x > drawRange.right - rightFrozenColsWidth && canScrollX && table.scrollLeft + table.tableNoFrameWidth < table.getAllColsWidth() ? (right = true, table.eventManager.scrollXSpeed = -(x - drawRange.right + rightFrozenColsWidth) / 50) : x < drawRange.left + leftFrozenColsWidth && canScrollX && table.scrollLeft > 0 && (left = true, table.eventManager.scrollXSpeed = -(x - drawRange.left - leftFrozenColsWidth) / 50), table.eventManager.inertiaScroll.startInertia(table.eventManager.scrollXSpeed, table.eventManager.scrollYSpeed, 1), table.eventManager.inertiaScroll.setScrollHandle((dx, dy) => {
          var _a2;
          let selectX, selectY;
          handleWhell({
            deltaX: -dx,
            deltaY: -dy
          }, table.stateManager, false), bottom ? selectY = table.scrollTop + drawRange.height - bottomFrozenRowHeight - 20 : top && (selectY = table.scrollTop + topFrozenRowHeight + 20), right ? selectX = table.scrollLeft + drawRange.width - rightFrozenColsWidth - 20 : left && (selectX = table.scrollLeft + leftFrozenColsWidth + 20);
          let considerFrozenY = false, considerFrozenX = false;
          right || left || (x > table.tableNoFrameWidth - table.getRightFrozenColsWidth() && x < table.tableNoFrameWidth || x > 0 && x < table.getFrozenColsWidth() ? (selectX = x, considerFrozenX = true) : selectX = table.scrollLeft + x), bottom || top || (y > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() && y < table.tableNoFrameHeight || y > 0 && y < table.getFrozenRowsHeight() ? (selectY = y, considerFrozenY = true) : selectY = table.scrollTop + y), table.stateManager.updateInteractionState(InteractionState.grabing);
          const targetCol = table.getTargetColAtConsiderRightFrozen(selectX, considerFrozenX), targetRow = table.getTargetRowAtConsiderBottomFrozen(selectY, considerFrozenY);
          !(null === (_a2 = table.options.select) || void 0 === _a2 ? void 0 : _a2.disableDragSelect) && isValid_default(targetCol) && isValid_default(targetRow) && table.stateManager.updateSelectPos(targetCol.col, targetRow.row, false, false, false, false);
        });
      } else table.eventManager.inertiaScroll.isInertiaScrolling() ? table.eventManager.inertiaScroll.endInertia() : table.eventManager.scrollYSpeed = 0;
    }
  };
  eventManager.globalEventListeners.push({
    name: "pointermove",
    env: "vglobal",
    callback: globalPointermoveCallback
  }), vglobal.addEventListener("pointermove", globalPointermoveCallback);
}

// node_modules/@visactor/vtable/es/event/listener/touch.js
function bindTouchListener(eventManager) {
  const table = eventManager.table, stateManager = table.stateManager, scenegraph = table.scenegraph;
  if (false === vglobal.envContribution.supportsTouchEvents) return;
  vglobal.addEventListener("contextmenu", (e) => {
    e.stopPropagation(), e.preventDefault();
  }, {
    capture: true
  }), eventManager.touchMovePoints = [], table.scenegraph.tableGroup.addEventListener("touchstart", (e) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (e.target.isChildOf(scenegraph.component.vScrollBar) || e.target.isChildOf(scenegraph.component.vScrollBar)) return;
    eventManager.isTouchdown = true;
    const touchEvent = e.nativeEvent;
    eventManager.touchMovePoints.push({
      x: table.rotateDegree ? null !== (_c = null === (_b = null === (_a = touchEvent.changedTouches) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b._canvasX) && void 0 !== _c ? _c : null === (_d = e.canvas) || void 0 === _d ? void 0 : _d.x : e.page.x,
      y: table.rotateDegree ? null !== (_g = null === (_f = null === (_e = touchEvent.changedTouches) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f._canvasY) && void 0 !== _g ? _g : null === (_h = e.canvas) || void 0 === _h ? void 0 : _h.y : e.page.y,
      timestamp: Date.now()
    });
  });
  const globalTouchMoveCallback = (e) => {
    var _a, _b;
    if (eventManager.isLongTouch && e.preventDefault(), eventManager.isTouchdown && isTouchEvent2(e)) {
      if (eventManager.isTouchMove = true, (null === (_b = null === (_a = eventManager.downIcon) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.funcType) === IconFuncTypeEnum.dragReorder) e.preventDefault();
      else if (eventManager.touchMovePoints.length > 4 && eventManager.touchMovePoints.shift(), eventManager.touchMovePoints.push({
        x: table.rotateDegree ? e.changedTouches[0]._canvasX : e.changedTouches[0].pageX,
        y: table.rotateDegree ? e.changedTouches[0]._canvasY : e.changedTouches[0].pageY,
        timestamp: Date.now()
      }), eventManager._enableTableScroll) {
        const deltaX = -eventManager.touchMovePoints[eventManager.touchMovePoints.length - 1].x + eventManager.touchMovePoints[eventManager.touchMovePoints.length - 2].x, deltaY = -eventManager.touchMovePoints[eventManager.touchMovePoints.length - 1].y + eventManager.touchMovePoints[eventManager.touchMovePoints.length - 2].y;
        handleWhell({
          deltaX,
          deltaY
        }, stateManager), e.cancelable && ("none" === table.internalProps.overscrollBehavior || Math.abs(deltaY) >= Math.abs(deltaX) && 0 !== deltaY && isVerticalScrollable(deltaY, stateManager) || Math.abs(deltaY) <= Math.abs(deltaX) && 0 !== deltaX && isHorizontalScrollable(deltaX, stateManager)) && e.preventDefault();
      }
    }
  };
  vglobal.addEventListener("touchmove", globalTouchMoveCallback, {
    passive: false
  }), eventManager.globalEventListeners.push({
    name: "touchmove",
    env: "vglobal",
    callback: globalTouchMoveCallback
  });
  const globalTouchEndCallback = (e) => {
    var _a, _b, _c, _d;
    if (eventManager.touchEnd = true, eventManager.isLongTouch = false, eventManager.isTouchdown && isTouchEvent2(e)) {
      if ((null === (_b = null === (_a = eventManager.downIcon) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.funcType) === IconFuncTypeEnum.dragReorder) e.preventDefault();
      else if ((null === (_c = eventManager.touchMovePoints) || void 0 === _c ? void 0 : _c.length) && (eventManager.touchMovePoints.length > 4 && eventManager.touchMovePoints.shift(), eventManager.touchMovePoints.push({
        x: table.rotateDegree ? e.changedTouches[0]._canvasX : e.changedTouches[0].pageX,
        y: table.rotateDegree ? e.changedTouches[0]._canvasY : e.changedTouches[0].pageY,
        timestamp: Date.now()
      }), eventManager._enableTableScroll)) {
        const firstPoint = eventManager.touchMovePoints[0], lastPoint = eventManager.touchMovePoints[(null === (_d = eventManager.touchMovePoints) || void 0 === _d ? void 0 : _d.length) - 1], vX = (lastPoint.x - firstPoint.x) / (lastPoint.timestamp - firstPoint.timestamp), vY = (lastPoint.y - firstPoint.y) / (lastPoint.timestamp - firstPoint.timestamp);
        eventManager.inertiaScroll.startInertia(vX, vY, 0.95), table.eventManager.inertiaScroll.setScrollHandle((dx, dy) => {
          handleWhell({
            deltaX: -dx,
            deltaY: -dy
          }, table.stateManager);
        });
      }
      eventManager.isTouchdown = false, eventManager.isTouchMove = false, eventManager.isDraging = false, eventManager.touchMovePoints = [];
    }
  };
  vglobal.addEventListener("touchend", globalTouchEndCallback), eventManager.globalEventListeners.push({
    name: "touchend",
    env: "vglobal",
    callback: globalTouchEndCallback
  });
  const globalTouchCancelCallback = (e) => {
    eventManager.touchEnd = true, eventManager.isLongTouch = false, eventManager.isTouchdown && (eventManager.isTouchdown = false, eventManager.isTouchMove = false, eventManager.touchMovePoints = [], eventManager.isDraging = false);
  };
  vglobal.addEventListener("touchcancel", globalTouchCancelCallback), eventManager.globalEventListeners.push({
    name: "touchcancel",
    env: "vglobal",
    callback: globalTouchCancelCallback
  });
}
function isTouchEvent2(e) {
  return !!e.changedTouches;
}

// node_modules/@visactor/vtable/es/event/self-event-listener/pivot-chart/axis-click.js
function bindAxisClickEvent(table) {
  table.isPivotChart() && table.scenegraph.tableGroup.addEventListener("click", (e) => {
    var _a;
    if (!table.stateManager.columnMove.moving && !table.stateManager.columnResize.resizing) {
      if ("axis-label" === e.target.name) {
        const eventArgsSet = getCellEventArgsSet(e), { col, row } = eventArgsSet.eventArgs, layout = table.internalProps.layoutMap;
        let dimensionKey, dimensions;
        layout.indicatorsAsCol ? (dimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row), dimensions = layout.getCellHeaderPaths(layout.rowHeaderLevelCount - 2, row).rowHeaderPaths) : (dimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount), dimensions = layout.getCellHeaderPaths(col, layout.columnHeaderLevelCount - 1).colHeaderPaths);
        const filter2 = dimensions.map((dimension) => ({
          key: dimension.dimensionKey,
          value: dimension.value
        })).filter((dimension) => dimension.key);
        if (filter2.push({
          key: dimensionKey,
          value: e.target.attribute.text
        }), table._selectedDimensionInChart.length && isSameSelectedDimension(table._selectedDimensionInChart, filter2)) return;
        table._selectedDimensionInChart = filter2, layout.updateDataStateToChartInstance(), clearChartCacheImage(table.scenegraph), table.scenegraph.updateNextFrame();
      } else if (null === (_a = table._selectedDimensionInChart) || void 0 === _a ? void 0 : _a.length) {
        table._selectedDimensionInChart.length = 0;
        table.internalProps.layoutMap.updateDataStateToChartInstance(), clearChartCacheImage(table.scenegraph), table.scenegraph.updateNextFrame();
      }
    }
  });
}
function isSameSelectedDimension(dimensions1, dimensions2) {
  if (dimensions1.length !== dimensions2.length) return false;
  for (let i = 0; i < dimensions1.length; i++) if (dimensions1[i].key !== dimensions2[i].key || dimensions1[i].value !== dimensions2[i].value) return false;
  return true;
}

// node_modules/@visactor/vtable/es/event/self-event-listener/pivot-chart/axis-hover.js
function bindAxisHoverEvent(table) {
  table.isPivotChart() && (table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, (e) => {
    table.scenegraph.getCell(e.col, e.row).forEachChildren((child) => {
      if ("axis" === child.name) {
        const position = getAxisPosition(e.col, e.row, table.internalProps.layoutMap);
        e.axisPosition = position, table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_AXIS, e);
      }
    });
  }), table.on(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, (e) => {
    table.scenegraph.getCell(e.col, e.row).forEachChildren((child) => {
      if ("axis" === child.name) {
        const position = getAxisPosition(e.col, e.row, table.internalProps.layoutMap);
        e.axisPosition = position, table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_AXIS, e);
      }
    });
  }));
}
function getAxisPosition(col, row, layout) {
  if (layout.indicatorsAsCol) {
    if (layout.hasTwoIndicatorAxes && row === layout.columnHeaderLevelCount - 1 && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return "top";
    if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return "bottom";
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.rowHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return "left";
  } else {
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return "left";
    if (col === layout.colCount - layout.rightFrozenColCount && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return "right";
    if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return "bottom";
  }
  return "bottom";
}

// node_modules/@visactor/vtable/es/event/self-event-listener/list-table/checkbox.js
function bindGroupTitleCheckboxChange(table) {
  table.on("checkbox_state_change", (args) => {
    var _a, _b;
    const { col, row, checked, field } = args;
    if ("_vtable_rowSeries_number" !== field || true !== (null === (_a = table.internalProps.rowSeriesNumber) || void 0 === _a ? void 0 : _a.enableTreeCheckbox)) return;
    if (table.isHeader(col, row)) return;
    const record = table.getCellOriginRecord(col, row), indexedData = table.dataSource.currentPagerIndexedData, titleShowIndex = table.getRecordShowIndexByCell(col, row);
    let titleIndex = indexedData[titleShowIndex];
    if (isNumber_default(titleIndex) && (titleIndex = [titleIndex]), record.vtableMerge || (null === (_b = record.children) || void 0 === _b ? void 0 : _b.length)) if (checked) getHierarchyState(table, col, row) === HierarchyState.collapse ? updateChildrenCheckboxState(true, titleIndex, table) : setAllChildrenCheckboxState(true, titleShowIndex, titleIndex, indexedData, table), updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
    else {
      getHierarchyState(table, col, row) === HierarchyState.collapse ? updateChildrenCheckboxState(false, titleIndex, table) : setAllChildrenCheckboxState(false, titleShowIndex, titleIndex, indexedData, table), updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
      const oldHeaderCheckedState = table.stateManager.headerCheckedState._vtable_rowSeries_number, newHeaderCheckedState = table.stateManager.updateHeaderCheckedState("_vtable_rowSeries_number", col, row);
      oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
    }
    else updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
  });
}
function setAllChildrenCheckboxState(state, titleShowIndex, titleIndex, indexedData, table) {
  var _a;
  let i = titleShowIndex + 1;
  for (; isArray_default(indexedData[i]) && (null === (_a = indexedData[i]) || void 0 === _a ? void 0 : _a.length) > titleIndex.length; ) {
    const row = table.columnHeaderLevelCount + i;
    table.stateManager.setCheckedState(0, row, "_vtable_rowSeries_number", state), setCellCheckboxStateByAttribute(0, row, state, table), i++;
  }
}
function updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table) {
  var _a;
  let parentLength = titleIndex.length - 1;
  if (parentLength > 0) {
    let i = titleShowIndex - 1;
    for (; parentLength > 0 && i >= 0; ) {
      if (isArray_default(indexedData[i]) && (null === (_a = indexedData[i]) || void 0 === _a ? void 0 : _a.length) === parentLength || 1 === parentLength && isNumber_default(indexedData[i])) {
        updateParentCheckboxState(0, table.columnHeaderLevelCount + i, indexedData[i], table), parentLength--;
      }
      i--;
    }
  }
}
function updateParentCheckboxState(col, row, currentIndex, table) {
  const { checkedState } = table.stateManager, key = currentIndex.toString(), currentIndexLength = isArray_default(currentIndex) ? currentIndex.length : 1;
  let start = false;
  const result2 = [], keys2 = Array.from(checkedState.keys()).sort((a2, b) => {
    var _a, _b;
    const aArr = a2.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
    for (let i = 0; i < maxLength; i++) {
      const a3 = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b2 = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
      if (a3 !== b2) return a3 - b2;
    }
    return 0;
  }), stateArr = keys2.map((key2) => checkedState.get(key2));
  if (stateArr.forEach((state, i) => {
    const index = keys2[i], value = state;
    if (start) {
      index.split(",").length === currentIndexLength ? start = false : result2.push(value._vtable_rowSeries_number);
    }
    index === key && (start = true);
  }), 0 === result2.length) return;
  const allChecked = result2.every((item) => !!item), allUnChecked = result2.every((item) => !item);
  allChecked ? (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", true), setCellCheckboxStateByAttribute(col, row, true, table)) : allUnChecked ? (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", false), setCellCheckboxStateByAttribute(col, row, false, table)) : (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", "indeterminate"), setCellCheckboxStateByAttribute(col, row, "indeterminate", table));
}
function updateChildrenCheckboxState(parentState, currentIndex, table) {
  const { checkedState } = table.stateManager, key = currentIndex.toString(), currentIndexLength = isArray_default(currentIndex) ? currentIndex.length : 1;
  let start = false;
  const keys2 = Array.from(checkedState.keys()).sort((a2, b) => {
    var _a, _b;
    const aArr = a2.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
    for (let i = 0; i < maxLength; i++) {
      const a3 = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b2 = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
      if (a3 !== b2) return a3 - b2;
    }
    return 0;
  }), stateArr = keys2.map((key2) => checkedState.get(key2));
  stateArr.forEach((state, i) => {
    const index = keys2[i], value = state;
    if (start) {
      index.split(",").length === currentIndexLength ? start = false : value._vtable_rowSeries_number = parentState;
    }
    index === key && (start = true);
  });
}
function bindHeaderCheckboxChange(table) {
  table.on("checkbox_state_change", (args) => {
    const { col, row, checked, field } = args;
    if (table.isHeader(col, row)) {
      table.stateManager.setHeaderCheckedState(field, checked);
      "checkbox" === table.getCellType(col, row) && table.scenegraph.updateCheckboxCellState(col, row, checked);
    } else {
      table.stateManager.setCheckedState(col, row, field, checked);
      if ("checkbox" === table.getCellType(col, row)) {
        const oldHeaderCheckedState = table.stateManager.headerCheckedState[field], newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(field, col, row);
        oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
      }
    }
  });
}
function getHierarchyState(table, col, row) {
  const index = table.getRecordShowIndexByCell(col, row);
  return table.dataSource.getHierarchyState(index);
}

// node_modules/@visactor/vtable/es/event/component/button.js
function bindButtonClickEvent(table) {
  table.on(TABLE_EVENT_TYPE.CLICK_CELL, (e) => {
    const { col, row, target } = e;
    "button" !== target.name || target.attribute.disable || table.hasListeners(TABLE_EVENT_TYPE.BUTTON_CLICK) && table.fireListeners(TABLE_EVENT_TYPE.BUTTON_CLICK, {
      col,
      row,
      event: e.event
    });
  });
}

// node_modules/@visactor/vtable/es/event/self-event-listener/base-table/icon.js
function bindIconClickEvent(table) {
  table.on(TABLE_EVENT_TYPE.ICON_CLICK, (iconInfo) => {
    var _a;
    const { col, row, x, y, funcType, icon: icon2, event: event2 } = iconInfo, { stateManager } = table;
    if (funcType === IconFuncTypeEnum.dropDown) stateManager.triggerDropDownMenu(col, row, x, y, event2);
    else if (funcType === IconFuncTypeEnum.sort) stateManager.triggerSort(col, row, icon2, event2);
    else if (funcType === IconFuncTypeEnum.frozen) stateManager.triggerFreeze(col, row, icon2);
    else if (funcType === IconFuncTypeEnum.drillDown) drillClick(table);
    else if (funcType === IconFuncTypeEnum.collapse || funcType === IconFuncTypeEnum.expand) {
      const isHasSelected = !!(null === (_a = stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
      stateManager.updateSelectPos(-1, -1), stateManager.endSelectCells(true, isHasSelected), table.toggleHierarchyState(col, row);
    }
  });
}

// node_modules/@visactor/vtable/es/event/self-event-listener/base-table/dropdown-menu.js
function bindDropdownMenuClickEvent(table) {
  table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, () => {
    table.stateManager.hideMenu();
  });
}

// node_modules/@visactor/vtable/es/event/self-event-listener/base-table/dbclick-auto-column-width.js
function bindDBClickAutoColumnWidthEvent(table) {
  table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, (e) => {
    var _a, _b, _c;
    if (e.federatedEvent) {
      const eventArgsSet = getCellEventArgsSet(e.federatedEvent), resizeCol = table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.targetCell), disableDblclickAutoResizeColWidth = null !== (_b = table.options.disableDblclickAutoResizeColWidth) && void 0 !== _b ? _b : null === (_c = table.options.resize) || void 0 === _c ? void 0 : _c.disableDblclickAutoResizeColWidth;
      if (table.eventManager.checkCellFillhandle(eventArgsSet)) table.fireListeners(TABLE_EVENT_TYPE.DBLCLICK_FILL_HANDLE, {});
      else if (table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0 && !disableDblclickAutoResizeColWidth) {
        table.scenegraph.updateAutoColWidth(resizeCol.col), table.internalProps._widthResizedColMap.add(resizeCol.col), table.scenegraph.updateChartSizeForResizeColWidth(resizeCol.col);
        const state = table.stateManager;
        state.columnResize.col < state.table.frozenColCount && !state.table.isPivotTable() && !state.table.transpose && state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen);
        const colWidths = [];
        for (let col = 0; col < table.colCount; col++) colWidths.push(table.getColWidth(col));
        table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
          col: resizeCol.col,
          colWidths
        });
      }
    }
  });
}

// node_modules/@visactor/vtable/es/event/self-event-listener/base-table/right-button-click.js
function rightButtonClickEvent(table) {
  table.on(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, (e) => {
    const { col, row } = e, ranges = table.getSelectedCellRanges();
    let cellInRange2 = false;
    if (ranges.length > 0) for (let i = 0; i < ranges.length; i++) {
      const range5 = ranges[i];
      if (col >= range5.start.col && col <= range5.end.col && row >= range5.start.row && row <= range5.end.row) {
        cellInRange2 = true;
        break;
      }
    }
    cellInRange2 || table.selectCell(col, row);
  });
}

// node_modules/@visactor/vtable/es/event/event.js
var EventManager2 = class {
  constructor(table) {
    this.isDown = false, this.isDraging = false, this.globalEventListeners = [], this._enableTableScroll = true, this.table = table, this.handleTextStickBindId = [], this.inertiaScroll = new InertiaScroll(table.stateManager), "node" === Env.mode || table.options.disableInteraction || (this.bindOuterEvent(), setTimeout(() => {
      this.bindSelfEvent();
    }, 0));
  }
  bindOuterEvent() {
    bindTableGroupListener(this), bindContainerDomListener(this), bindScrollBarListener(this), bindTouchListener(this), bindGesture(this);
  }
  updateEventBinder() {
    setTimeout(() => {
      var _a;
      this.table.isReleased || (checkHaveTextStick(this.table) && 0 === (null === (_a = this.handleTextStickBindId) || void 0 === _a ? void 0 : _a.length) ? (this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.SCROLL, (e) => {
        handleTextStick(this.table);
      })), this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, (e) => {
        handleTextStick(this.table);
      })), this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.RESIZE_ROW_END, (e) => {
        handleTextStick(this.table);
      }))) : !checkHaveTextStick(this.table) && this.handleTextStickBindId && (this.handleTextStickBindId.forEach((id) => {
        this.table.off(id);
      }), this.handleTextStickBindId = []), bindSparklineHoverEvent(this.table));
    }, 0);
  }
  bindSelfEvent() {
    this.table.isReleased || (bindIconClickEvent(this.table), bindDropdownMenuClickEvent(this.table), this.updateEventBinder(), bindMediaClick(this.table), bindDBClickAutoColumnWidthEvent(this.table), this.table.isPivotTable() && checkHaveDrill(this.table) && bindDrillEvent(this.table), bindSparklineHoverEvent(this.table), bindAxisClickEvent(this.table), bindAxisHoverEvent(this.table), bindGroupTitleCheckboxChange(this.table), bindHeaderCheckboxChange(this.table), bindButtonClickEvent(this.table), rightButtonClickEvent(this.table));
  }
  dealTableHover(eventArgsSet) {
    if (!eventArgsSet) return void this.table.stateManager.updateHoverPos(-1, -1);
    const { eventArgs } = eventArgsSet;
    eventArgs ? this.table.stateManager.updateHoverPos(eventArgs.col, eventArgs.row) : this.table.stateManager.updateHoverPos(-1, -1);
  }
  dealIconHover(eventArgsSet) {
    const { eventArgs } = eventArgsSet;
    eventArgs ? this.table.stateManager.updateHoverIcon(eventArgs.col, eventArgs.row, eventArgs.target, eventArgs.targetCell) : this.table.stateManager.updateHoverIcon(-1, -1, void 0, void 0);
  }
  dealMenuHover(eventArgsSet) {
  }
  dealTableSelect(eventArgsSet, isSelectMoving) {
    var _a, _b, _c, _d, _e;
    if (!eventArgsSet) return this.table.stateManager.updateSelectPos(-1, -1), false;
    const { eventArgs } = eventArgsSet;
    if (eventArgs) {
      if ("checkbox" === eventArgs.target.name || "radio" === eventArgs.target.name || "switch" === eventArgs.target.name || "button" === eventArgs.target.name) return false;
      if (this.table.isHeader(eventArgs.col, eventArgs.row) && isCellDisableSelect(this.table, eventArgs.col, eventArgs.row)) return isSelectMoving || this.table.stateManager.updateSelectPos(-1, -1), false;
      if (!this.table.isHeader(eventArgs.col, eventArgs.row) && isCellDisableSelect(this.table, eventArgs.col, eventArgs.row)) {
        if (!isSelectMoving) {
          const isHasSelected = !!(null === (_a = this.table.stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
          this.table.stateManager.updateSelectPos(-1, -1), isHasSelected && this.table.stateManager.endSelectCells(true, isHasSelected);
        }
        return false;
      }
      return !this.table.isPivotChart() || "axis-label" !== (null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target.name) && "chart" !== (null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target.type) ? (this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, !isSelectMoving && (null === (_e = null === (_d = this.table.options.select) || void 0 === _d ? void 0 : _d.makeSelectCellVisible) || void 0 === _e || _e)), true) : (this.table.stateManager.updateSelectPos(-1, -1), false);
    }
    return false;
  }
  dealFillSelect(eventArgsSet, isSelectMoving) {
    var _a, _b;
    const { eventArgs } = eventArgsSet;
    if (eventArgs) {
      if ((null === (_b = null === (_a = this.table.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) && this.table.stateManager.isFillHandle()) {
        let updateRow2, updateCol2;
        const currentRange = this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1];
        isSelectMoving && (isValid_default(this.table.stateManager.fillHandle.directionRow) || (Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >= Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x) ? this.table.stateManager.fillHandle.directionRow = true : this.table.stateManager.fillHandle.directionRow = false), Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >= Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x) ? this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y > 0 ? this.table.stateManager.fillHandle.direction = "top" : this.table.stateManager.fillHandle.direction = "bottom" : this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x > 0 ? this.table.stateManager.fillHandle.direction = "left" : this.table.stateManager.fillHandle.direction = "right", this.table.stateManager.fillHandle.directionRow ? (updateRow2 = eventArgs.row, updateCol2 = currentRange.end.col) : (updateRow2 = currentRange.end.row, updateCol2 = eventArgs.col)), this.table.stateManager.updateSelectPos(isSelectMoving ? updateCol2 : currentRange.end.col, isSelectMoving ? updateRow2 : currentRange.end.row, true, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, !isSelectMoving);
      } else this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, !isSelectMoving);
      return true;
    }
    return false;
  }
  deelTableSelectAll() {
    this.table.stateManager.updateSelectPos(-1, -1, false, false, true), this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CELL, {
      ranges: this.table.stateManager.select.ranges,
      col: 0,
      row: 0
    });
  }
  dealMenuSelect(eventArgsSet) {
  }
  checkColumnResize(eventArgsSet, update2) {
    const { eventArgs } = eventArgsSet;
    if (this.table.options.enableTreeStickCell && !eventArgs) return false;
    const resizeCol = this.table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null == eventArgs ? void 0 : eventArgs.targetCell);
    return this.table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0 ? (update2 && this.table.stateManager.startResizeCol(resizeCol.col, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeCol.rightFrozen), true) : (this.table.stateManager.isResizeCol() && this.table.stateManager.endResizeCol(), false);
  }
  checkRowResize(eventArgsSet, update2) {
    const { eventArgs } = eventArgsSet;
    if (eventArgs) {
      const resizeRow = this.table.scenegraph.getResizeRowAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs.targetCell);
      if (this.table._canResizeRow(resizeRow.col, resizeRow.row) && resizeRow.row >= 0) return update2 && this.table.stateManager.startResizeRow(resizeRow.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeRow.bottomFrozen), true;
    }
    return false;
  }
  cellIsHeaderCheck(eventArgsSet, update2) {
    const { eventArgs } = eventArgsSet, { col, row, target } = eventArgs;
    if (!this.table.isHeader(col, row)) return false;
    return "checkbox" === this.table.getCellType(eventArgs.col, eventArgs.row) && "checkbox" === target.name;
  }
  checkCellFillhandle(eventArgsSet, update2) {
    var _a, _b, _c, _d, _e;
    let isFillHandle = false;
    if (isFillHandle = "function" == typeof (null === (_a = this.table.options.excelOptions) || void 0 === _a ? void 0 : _a.fillHandle) ? this.table.options.excelOptions.fillHandle({
      selectRanges: this.table.stateManager.select.ranges,
      table: this.table
    }) : null === (_b = this.table.options.excelOptions) || void 0 === _b ? void 0 : _b.fillHandle, isFillHandle) {
      const { eventArgs } = eventArgsSet;
      if (eventArgs && (null === (_d = null === (_c = this.table.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length)) {
        const lastCol = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col), lastRow = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row), startCol = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col), startRow = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row);
        let lastCellBound;
        lastCellBound = lastCol < this.table.colCount - 1 ? this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds : this.table.scenegraph.highPerformanceGetCell(startCol - 1, lastRow).globalAABBBounds;
        const distanceX = Math.abs(eventArgsSet.abstractPos.x - lastCellBound.x2);
        lastCellBound = lastRow < this.table.rowCount - 1 ? this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds : this.table.scenegraph.highPerformanceGetCell(lastCol, startRow - 1).globalAABBBounds;
        const distanceY = Math.abs(eventArgsSet.abstractPos.y - lastCellBound.y2), squareSize = 18;
        if ((null === (_e = this.table.stateManager.fillHandle) || void 0 === _e ? void 0 : _e.isFilling) || distanceX <= squareSize / 2 && distanceY <= squareSize / 2) return update2 && this.table.stateManager.startFillSelect(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y), true;
      }
    }
    return false;
  }
  dealColumnResize(xInTable, yInTable) {
    this.table.stateManager.updateResizeCol(xInTable, yInTable);
  }
  dealRowResize(xInTable, yInTable) {
    this.table.stateManager.updateResizeRow(xInTable, yInTable);
  }
  checkColumnMover(eventArgsSet) {
    var _a;
    const { eventArgs } = eventArgsSet;
    return !(!eventArgs || !this.table._canDragHeaderPosition(eventArgs.col, eventArgs.row)) && (this.table.stateManager.startMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = null == eventArgs ? void 0 : eventArgs.event) || void 0 === _a ? void 0 : _a.nativeEvent), true);
  }
  dealColumnMover(eventArgsSet) {
    var _a;
    const { eventArgs } = eventArgsSet;
    isValid_default(eventArgs.col) && isValid_default(eventArgs.row) && this.table.stateManager.updateMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = null == eventArgs ? void 0 : eventArgs.event) || void 0 === _a ? void 0 : _a.nativeEvent);
  }
  startColumnResize(eventArgsSet) {
  }
  dealIconClick(e, eventArgsSet) {
    const { eventArgs } = eventArgsSet, { target, event: event2, col, row } = eventArgs || {
      target: e.target,
      event: e,
      col: -1,
      row: -1
    }, icon2 = target;
    if (icon2.role && icon2.role.startsWith("icon-")) return this.table.fireListeners(TABLE_EVENT_TYPE.ICON_CLICK, {
      name: icon2.name,
      x: (icon2.globalAABBBounds.x1 + icon2.globalAABBBounds.x2) / 2,
      y: icon2.globalAABBBounds.y2,
      col,
      row,
      funcType: icon2.attribute.funcType,
      icon: icon2,
      event: event2
    }), true;
    if (target instanceof RichText) {
      const icon3 = target.pickIcon(event2.global);
      if (icon3) return this.table.fireListeners(TABLE_EVENT_TYPE.ICON_CLICK, {
        name: icon3.attribute.id,
        x: icon3.globalX + icon3.globalAABBBounds.width() / 2,
        y: icon3.globalY + icon3.AABBBounds.height(),
        col,
        row,
        funcType: icon3.attribute.funcType,
        icon: icon3,
        event: event2
      }), true;
    }
    return false;
  }
  release() {
    this.gesture.release(), this.globalEventListeners.forEach((item) => {
      "document" === item.env ? document.removeEventListener(item.name, item.callback) : "body" === item.env ? document.body.removeEventListener(item.name, item.callback) : "window" === item.env ? window.removeEventListener(item.name, item.callback) : "vglobal" === item.env && vglobal.removeEventListener(item.name, item.callback);
    }), this.globalEventListeners = [];
  }
  enableScroll() {
    this._enableTableScroll = true;
  }
  disableScroll() {
    this._enableTableScroll = false;
  }
};

// node_modules/@visactor/vtable/es/body-helper/style/ProgressBarStyle.js
var defaultStyle8;
var DEFAULT_BAR_COLOR = (args) => {
  const num = args.value;
  return Number(num) > 80 ? "#20a8d8" : Number(num) > 50 ? "#4dbd74" : Number(num) > 20 ? "#ffc107" : "#f86c6b";
};
var ProgressBarStyle = class _ProgressBarStyle extends Style {
  static get DEFAULT() {
    return defaultStyle8 || (defaultStyle8 = new _ProgressBarStyle());
  }
  constructor(style2 = {}, bodyStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    super(style2, bodyStyle), this._showBar = null === (_a = style2.showBar) || void 0 === _a || _a, this._barColor = null !== (_b = style2.barColor) && void 0 !== _b ? _b : DEFAULT_BAR_COLOR, this._barPositiveColor = null !== (_c = style2.barPositiveColor) && void 0 !== _c ? _c : "#4dbd74", this._barNegativeColor = null !== (_d = style2.barNegativeColor) && void 0 !== _d ? _d : "#f86c6b", this._barAxisColor = null !== (_e = style2.barAxisColor) && void 0 !== _e ? _e : "black", this._barBgColor = style2.barBgColor, this._barHeight = null !== (_f = style2.barHeight) && void 0 !== _f ? _f : 3, this._barHeight = null !== (_g = style2.barHeight) && void 0 !== _g ? _g : 3, this._barBottom = null !== (_h = style2.barBottom) && void 0 !== _h ? _h : 0, this._barPadding = null !== (_j = style2.barPadding) && void 0 !== _j ? _j : [0, 0, 0, 0], this._showBarMark = null !== (_k = style2.showBarMark) && void 0 !== _k && _k, this._barMarkPositiveColor = null !== (_l = style2.barMarkPositiveColor) && void 0 !== _l ? _l : "#4dbd74", this._barMarkNegativeColor = null !== (_m = style2.barMarkNegativeColor) && void 0 !== _m ? _m : "#f86c6b", this._barMarkWidth = null !== (_o = style2.barMarkWidth) && void 0 !== _o ? _o : 2, this._barMarkPosition = null !== (_p = style2.barMarkPosition) && void 0 !== _p ? _p : "right", this._barRightToLeft = null !== (_q = style2.barRightToLeft) && void 0 !== _q && _q, this._barMarkInBar = null === (_r = style2.barMarkInBar) || void 0 === _r || _r;
  }
  get showBar() {
    return this._showBar;
  }
  set showBar(value) {
    this._showBar = value;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(barColor) {
    this._barColor = barColor;
  }
  get barBgColor() {
    return this._barBgColor;
  }
  set barBgColor(barBgColor) {
    this._barBgColor = barBgColor;
  }
  get barHeight() {
    return this._barHeight;
  }
  set barHeight(barHeight) {
    this._barHeight = barHeight;
  }
  get barBottom() {
    return this._barBottom;
  }
  set barBottom(barBottom) {
    this._barBottom = barBottom;
  }
  get barPositiveColor() {
    return this._barPositiveColor;
  }
  set barPositiveColor(barPositiveColor) {
    this._barPositiveColor = barPositiveColor;
  }
  get barNegativeColor() {
    return this._barNegativeColor;
  }
  set barNegativeColor(barNegativeColor) {
    this._barNegativeColor = barNegativeColor;
  }
  get barAxisColor() {
    return this._barAxisColor;
  }
  set barAxisColor(barAxisColor) {
    this._barAxisColor = barAxisColor;
  }
  get barPadding() {
    return this._barPadding;
  }
  set barPadding(barPadding) {
    this._barPadding = barPadding;
  }
  get showBarMark() {
    return this._showBarMark;
  }
  set showBarMark(value) {
    this._showBarMark = value;
  }
  get barMarkPositiveColor() {
    return this._barMarkPositiveColor;
  }
  set barMarkPositiveColor(value) {
    this._barMarkPositiveColor = value;
  }
  get barMarkNegativeColor() {
    return this._barMarkNegativeColor;
  }
  set barMarkNegativeColor(value) {
    this._barMarkNegativeColor = value;
  }
  get barMarkWidth() {
    return this._barMarkWidth;
  }
  set barMarkWidth(value) {
    this._barMarkWidth = value;
  }
  get barMarkPosition() {
    return this._barMarkPosition;
  }
  set barMarkPosition(value) {
    this._barMarkPosition = value;
  }
  get barRightToLeft() {
    return this._barRightToLeft;
  }
  set barRightToLeft(value) {
    this._barRightToLeft = value;
  }
  get barMarkInBar() {
    return this._barMarkInBar;
  }
  set barMarkInBar(value) {
    this._barMarkInBar = value;
  }
  clone() {
    return new _ProgressBarStyle(this, null);
  }
};

// node_modules/@visactor/vtable/es/tools/icons.js
var ICON_PROP_KEYS = ["type", "content", "style", "color", "width", "height", "marginRight", "marginLeft", "src", "svg", "name", "path", "positionType", "tooltip", "hover", "cursor", "shape", "interactive", "isGif"];
var iconPropKeys = ICON_PROP_KEYS;

// node_modules/@visactor/vtable/es/body-helper/body-helper.js
var BodyHelper = class {
  constructor(_table) {
    this._table = _table;
    const regedIcons3 = get3();
    this.expandIcon = regedIcons3[InternalIconName.expandIconName], this.collapseIcon = regedIcons3[InternalIconName.collapseIconName];
  }
  getIcons(col, row, cellValue, dataValue, context) {
    const iconArr = [], hierarchyIcon = this.getHierarchyIcon(col, row);
    hierarchyIcon && iconArr.push(hierarchyIcon);
    const { icon: iconDefine } = this._table.getBodyColumnDefine(col, row);
    if (iconDefine) {
      let iconResults;
      if ("function" == typeof iconDefine) {
        iconResults = iconDefine({
          col,
          row,
          value: cellValue,
          dataValue,
          table: this._table
        });
      } else iconResults = iconDefine;
      const regedIcons3 = get3(), addIcon = (columnIcon) => {
        let icon2;
        icon2 = "string" == typeof columnIcon ? regedIcons3[columnIcon] : columnIcon, icon2 && iconArr.push(icon2);
      };
      Array.isArray(iconResults) ? iconResults.forEach((columnIcon, index) => {
        addIcon(columnIcon);
      }) : addIcon(iconResults);
    }
    return context && iconArr.forEach((i, index) => {
      (i.content || i.src) && (iconArr[index] = this.getCellIconFromRecordValue(i, col, row));
    }), iconArr;
  }
  getStyleClass(cellType) {
    switch (cellType) {
      case "text":
      case "link":
        return TextStyle;
      case "image":
      case "video":
        return ImageStyle;
      case "chart":
      case "sparkline":
        return Style;
      case "progressbar":
        return ProgressBarStyle;
      case "checkbox":
        return CheckboxStyle;
      case "radio":
        return RadioStyle;
      case "switch":
        return SwitchStyle;
      case "button":
        return ButtonStyle;
    }
    return TextStyle;
  }
  getCellIconFromRecordValue(icon2, col, row) {
    if (Array.isArray(icon2)) return icon2.map((i) => this.getCellIconFromRecordValue(i, col, row));
    if (!obj.isObject(icon2) || "function" == typeof icon2) return this._table.getFieldData(icon2, col, row);
    const retIcon = {}, iconOpt = icon2;
    return iconPropKeys.forEach((k2) => {
      var _a, _b;
      if (void 0 !== iconOpt[k2]) {
        const f = this._table.getFieldData(iconOpt[k2], col, row);
        isValid_default(f) ? retIcon[k2] = f : (null === (_b = (_a = this._table)._hasField) || void 0 === _b ? void 0 : _b.call(_a, iconOpt[k2], col, row)) || (retIcon[k2] = iconOpt[k2]);
      }
    }), retIcon;
  }
  getHierarchyIcon(col, row) {
    const hierarchyState = this._table.getHierarchyState(col, row);
    return hierarchyState === HierarchyState.expand ? this.expandIcon : hierarchyState === HierarchyState.collapse ? this.collapseIcon : void 0;
  }
  getHierarchyIconWidth() {
    var _a, _b;
    return this.expandIcon.width + (null !== (_a = this.expandIcon.marginLeft) && void 0 !== _a ? _a : 0) + (null !== (_b = this.expandIcon.marginRight) && void 0 !== _b ? _b : 0);
  }
};

// node_modules/@visactor/vtable/es/tools/dom.js
function createElement(tagName, classNames) {
  const element = document.createElement(tagName);
  return classNames && element.classList.add(...classNames), element;
}

// node_modules/@visactor/vtable/es/components/menu/dom/logic/MenuElementStyle.js
function importStyle2() {
  if ("node" === Env.mode) return;
  const styleElement = document.createElement("style");
  styleElement.id = "vtable-menu-styleSheet", styleElement.textContent = "\n@keyframes vtable__menu-element--shown-animation {\n	0% {\n		opacity: 0;\n	}\n	100% {\n		opacity: 1;\n	}\n}\n.vtable__menu-element {\n	position: absolute;\n	box-sizing: border-box;\n	border-radius: 4px;\n	background-color: #fff;\n	padding: 6px 0;\n	/* pointer-events: none; */\n	user-select: none;\n	color: #000;\n	max-width: 300px;\n	z-index: 99999;\n	border: #CCC 0.5px solid;\n	cursor: default;\n	width: max-content;\n	box-shadow: 0px 8px 16px rgba(27, 31, 35, 0.12);\n  max-height: 100%;\n  overflow-y: auto;\n}\n.vtable__menu-element--hidden {\n	opacity: 0;\n	/* transform: translate(-50%, -50%); */\n	transition: opacity 75ms linear;\n	z-index: -9999;\n}\n.vtable__menu-element--shown {\n	opacity: 1;\n	/* transform: translate(-50%, -50%); */\n	animation: vtable__menu-element--shown-animation 150ms ease-out;\n}\n.vtable__menu-element__content {\n	font-family: Roboto;\n	font-size: 12px;\n	overflow: hidden;\n	display: inline-block;\n	/* height: 100%; */\n	line-height: 30px;\n}\n.vtable__menu-element__item {\n	height: 32px;\n	padding: 0px 12px;\n	cursor: pointer;\n	position: relative;\n	display: flex;\n	align-items: center;\n	justify-content: flex-start;\n}\n.vtable__menu-element__item:hover {\n	background-color: rgba(27, 31, 35, 0.06);\n}\n.vtable__menu-element__icon{\n	/* vertical-align: top; */\n	display: flex;\n	/* line-height: 30px; */\n	margin-right: 6px;\n}\n.vtable__menu-element__no-event {\n	pointer-events: none;\n}\n.vtable__menu-element--select {\n	color: #2E68CF;\n}\n.vtable__menu-element--normal {\n	color: rgba(20, 20, 20, 0.9);;\n}\n.vtable__menu-element__item-disabled {\n    color: rgba(0, 0, 0, 0.25);\n    cursor: not-allowed;\n	  background-color: #fff;\n}\n.vtable__menu-element__item-disabled:hover {\n	  background-color: #fff;\n}\n.vtable__menu-element__split {\n	height: 0px;\n	border: 1px solid rgb(209, 213, 218);\n	margin: 5px 0;\n}\n.vtable__menu-element__title {\n	color: rgb(149, 149, 149);\n}\n.vtable__menu-element__arrow {\n	position: absolute;\n	right: 3px;\n	font-weight: bold;\n	margin-top: 1px;\n}\n.vtable__menu-element__item-text {\n	margin-right: 15px;\n}\n", document.head.appendChild(styleElement);
}

// node_modules/@visactor/vtable/es/components/menu/dom/logic/MenuElement.js
importStyle2();
var CLASSNAME = "vtable__menu-element";
var ITEM_CLASSNAME = `${CLASSNAME}__item`;
var CONTENT_CLASSNAME = `${CLASSNAME}__content`;
var HIDDEN_CLASSNAME = `${CLASSNAME}--hidden`;
var SHOWN_CLASSNAME = `${CLASSNAME}--shown`;
var NORAML_CLASSNAME = `${CLASSNAME}--normal`;
var SELECT_CLASSNAME = `${CLASSNAME}--select`;
var ICOM_CLASSNAME = `${CLASSNAME}__icon`;
var SPLIT_CLASSNAME = `${CLASSNAME}__split`;
var TITLE_CLASSNAME = `${CLASSNAME}__title`;
var ARROW_CLASSNAME = `${CLASSNAME}__arrow`;
var NOEVENT_CLASSNAME = `${CLASSNAME}__no-event`;
var ITEMTEXT_CLASSNAME = `${CLASSNAME}__item-text`;
var ITEM_DISABLED_CLASSNAME = `${CLASSNAME}__item-disabled`;
function createMenuDomElement() {
  return createElement("div", [CLASSNAME, HIDDEN_CLASSNAME]);
}
function isMenuHighlight(_table, cells, menuKeyCurrent, colCurrent, rowCurrent, index) {
  const cellRange = _table.getCellRange(colCurrent, rowCurrent);
  for (let i = 0; i < cells.length; i++) {
    const highlight = cells[i];
    let { col, row } = highlight;
    const { field, menuKey } = highlight;
    if ("number" != typeof col || "number" != typeof row) if (_table.isPivotTable() && (Array.isArray(field), 1)) {
      const cellAddress = _table.internalProps.layoutMap.getPivotCellAdress(field);
      if (!cellAddress) continue;
      col = cellAddress.col, row = cellAddress.row;
    } else {
      const cellAddress = _table.internalProps.layoutMap.getHeaderCellAddressByField(field);
      if (!cellAddress) continue;
      col = cellAddress.col, row = cellAddress.row;
    }
    if (isValid_default(col) && isValid_default(row) && cellInRange(cellRange, col, row) && menuKeyCurrent === menuKey) return true;
  }
  return false;
}
var MenuElement = class {
  constructor(table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    this._handler = new EventHandler(), this._rootElement = createMenuDomElement(), this._secondElement = createMenuDomElement(), this._secondElement.sub = true, this._showChildrenIndex = -1, this._rootElement.addEventListener("wheel", (e) => {
      e.stopPropagation();
    }), null === (_a = this._rootElement) || void 0 === _a || _a.addEventListener("mousedown", (e) => {
      e.stopPropagation(), e.preventDefault();
    }), null === (_b = this._rootElement) || void 0 === _b || _b.addEventListener("contextmenu", (e) => {
      e.stopPropagation(), e.preventDefault();
    }), null === (_c = this._rootElement) || void 0 === _c || _c.addEventListener("touchend", (e) => {
      if (e.stopPropagation(), e.preventDefault(), e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) return;
      if (this._rootElement.classList.contains(HIDDEN_CLASSNAME)) return;
      const { col, row, dropDownIndex, menuKey, text: text2, hasChildren } = e.target;
      if ("number" != typeof dropDownIndex || hasChildren) return void e.stopPropagation();
      const field = table.isPivotTable() ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row) : table.getHeaderField(col, row), highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
      table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
        col,
        row,
        field,
        menuKey,
        text: text2,
        highlight,
        cellLocation: table.getCellLocation(col, row),
        event: e
      }), table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null), e.stopPropagation();
    }), null === (_d = this._rootElement) || void 0 === _d || _d.addEventListener("click", (e) => {
      if (e.stopPropagation(), e.preventDefault(), e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) return;
      if (this._rootElement.classList.contains(HIDDEN_CLASSNAME)) return;
      const { col, row, dropDownIndex, menuKey, text: text2, hasChildren } = e.target;
      if ("number" != typeof dropDownIndex || hasChildren) return void e.stopPropagation();
      const field = table.isPivotTable() ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row) : table.getHeaderField(col, row), highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
      table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
        col,
        row,
        field,
        menuKey,
        text: text2,
        highlight,
        cellLocation: table.getCellLocation(col, row),
        event: e
      }), table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null), e.stopPropagation();
    }), null === (_e = this._rootElement) || void 0 === _e || _e.addEventListener("mousemove", (e) => {
      var _a2, _b2;
      if (this._rootElement.classList.contains(HIDDEN_CLASSNAME)) return;
      e.stopPropagation();
      const { hasChildren, dropDownIndex, col, row, sub } = e.target;
      if (hasChildren) {
        this._showChildrenIndex = dropDownIndex;
        const secondElement = this._secondElement;
        null == secondElement || secondElement.classList.remove(HIDDEN_CLASSNAME), null == secondElement || secondElement.classList.add(SHOWN_CLASSNAME), secondElement.innerHTML = "";
        const children = null === (_a2 = this._menuInstanceInfo.content[dropDownIndex]) || void 0 === _a2 ? void 0 : _a2.children;
        for (let i = 0; i < children.length; i++) {
          const menuItem = children[i], item = createItem(menuItem, !!table.stateManager.menu.dropDownMenuHighlight && isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, "object" == typeof menuItem ? (null == menuItem ? void 0 : menuItem.menuKey) || (null == menuItem ? void 0 : menuItem.text) : menuItem, col, row, i));
          item.col = col, item.row = row, item.dropDownIndex = i, "string" == typeof menuItem ? (item.text = menuItem, item.menuKey = menuItem) : "object" == typeof menuItem && (item.text = menuItem.text, item.menuKey = menuItem.menuKey || menuItem.text), item.sub = true, item.sub = true, secondElement.appendChild(item);
        }
        const rect = e.target.getBoundingClientRect();
        this._bindSecondElement(table, col, row, rect.right, rect.top);
      } else if (hasChildren && this._showChildrenIndex === dropDownIndex) {
        const secondElement = this._secondElement;
        null == secondElement || secondElement.classList.remove(HIDDEN_CLASSNAME), null == secondElement || secondElement.classList.add(SHOWN_CLASSNAME);
      } else !sub && (null === (_b2 = this._secondElement) || void 0 === _b2 ? void 0 : _b2.classList.contains(SHOWN_CLASSNAME)) && setTimeout(() => {
        if (true !== this._mouseEnterSecondElement) {
          this._showChildrenIndex = -1;
          const secondElement = this._secondElement;
          null == secondElement || secondElement.classList.remove(SHOWN_CLASSNAME), null == secondElement || secondElement.classList.add(HIDDEN_CLASSNAME);
        }
      }, 300);
    }), null === (_f = this._secondElement) || void 0 === _f || _f.addEventListener("wheel", (e) => {
      e.stopPropagation();
    }), null === (_g = this._secondElement) || void 0 === _g || _g.addEventListener("mousemove", (e) => {
      this._rootElement.classList.contains(HIDDEN_CLASSNAME) || e.stopPropagation();
    }), null === (_h = this._secondElement) || void 0 === _h || _h.addEventListener("mouseenter", (e) => {
      this._mouseEnterSecondElement = true;
    }), null === (_j = this._secondElement) || void 0 === _j || _j.addEventListener("mouseleave", (e) => {
      this._mouseEnterSecondElement = false;
    }), null === (_k = this._secondElement) || void 0 === _k || _k.addEventListener("mousedown", (e) => {
      e.stopPropagation(), e.preventDefault();
    }), null === (_l = this._secondElement) || void 0 === _l || _l.addEventListener("click", (e) => {
      if (e.stopPropagation(), e.preventDefault(), e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) return;
      if (this._secondElement.classList.contains(HIDDEN_CLASSNAME)) return;
      const { col, row, dropDownIndex, menuKey, text: text2, hasChildren } = e.target;
      if ("number" != typeof dropDownIndex || hasChildren) return void e.stopPropagation();
      const field = table.isPivotTable() ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row) : table.getHeaderField(col, row);
      let highlight = false;
      this._menuInstanceInfo.content.forEach((menu, i) => {
        if ("object" == typeof menu && menu.children && menu.children.length) for (let j = 0; j < menu.children.length; j++) {
          const childItem = menu.children[j];
          if (isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, "object" == typeof childItem ? null == childItem ? void 0 : childItem.menuKey : childItem, col, row, -1) && menuKey === ("object" == typeof childItem ? null == childItem ? void 0 : childItem.menuKey : childItem)) return void (highlight = true);
        }
      }), table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
        col,
        row,
        field,
        cellHeaderPaths: table.isPivotTable() ? table.getCellHeaderPaths(col, row) : void 0,
        menuKey,
        text: text2,
        highlight,
        cellLocation: table.getCellLocation(col, row),
        event: e
      }), table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null), e.stopPropagation();
    });
  }
  get rootElement() {
    return this._rootElement;
  }
  release() {
    this.unbindFromCell();
    const rootElement = this._rootElement;
    (null == rootElement ? void 0 : rootElement.parentElement) && rootElement.parentElement.removeChild(rootElement), this._handler.release(), delete this._rootElement;
  }
  bindToCell(table, col, row, menuInstanceInfo) {
    var _a, _b;
    const rootElement = this._rootElement, secondElement = this._secondElement;
    if (this._menuInstanceInfo = menuInstanceInfo, null == rootElement || rootElement.classList.remove(SHOWN_CLASSNAME), null == rootElement || rootElement.classList.add(HIDDEN_CLASSNAME), null == secondElement || secondElement.classList.remove(SHOWN_CLASSNAME), null == secondElement || secondElement.classList.add(HIDDEN_CLASSNAME), this._canBindToCell(table, col, row)) {
      if (rootElement.innerHTML = "", Array.isArray(menuInstanceInfo.content)) {
        const menuListItem = menuInstanceInfo.content;
        for (let i = 0; null !== (_a = i < (null == menuListItem ? void 0 : menuListItem.length)) && void 0 !== _a && _a; i++) {
          const menuItem = menuListItem[i];
          let isHighlight = !!table.stateManager.menu.dropDownMenuHighlight && isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, "object" == typeof menuItem ? (null == menuItem ? void 0 : menuItem.menuKey) || (null == menuItem ? void 0 : menuItem.text) : menuItem, col, row, i);
          if (table.stateManager.menu.dropDownMenuHighlight && "object" == typeof menuItem && Array.isArray(menuItem.children) && menuItem.children.length) for (let i2 = 0; i2 < menuItem.children.length; i2++) {
            const childItem = menuItem.children[i2];
            if (isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, "object" == typeof childItem ? (null == childItem ? void 0 : childItem.menuKey) || (null == childItem ? void 0 : childItem.text) : childItem, col, row, i2)) {
              isHighlight = true;
              break;
            }
          }
          const item = createItem(menuItem, isHighlight);
          item.col = col, item.row = row, item.dropDownIndex = i, "string" == typeof menuItem ? (item.text = menuItem, item.menuKey = menuItem) : "object" == typeof menuItem && (item.text = menuItem.text, item.menuKey = menuItem.menuKey || menuItem.text, (null === (_b = menuItem.children) || void 0 === _b ? void 0 : _b.length) && (item.hasChildren = true)), rootElement.appendChild(item);
        }
      }
      if (this._bindToCell(table, col, row, menuInstanceInfo.position, menuInstanceInfo.referencePosition)) return null == rootElement || rootElement.classList.add(SHOWN_CLASSNAME), null == rootElement || rootElement.classList.remove(HIDDEN_CLASSNAME), true;
    } else this.unbindFromCell();
    return false;
  }
  unbindFromCell() {
    const rootElement = this._rootElement, secondElement = this._secondElement;
    this._menuInstanceInfo = void 0, (null == rootElement ? void 0 : rootElement.parentElement) && (rootElement.classList.remove(SHOWN_CLASSNAME), rootElement.classList.add(HIDDEN_CLASSNAME)), (null == secondElement ? void 0 : secondElement.parentElement) && (secondElement.classList.remove(SHOWN_CLASSNAME), secondElement.classList.add(HIDDEN_CLASSNAME));
  }
  _canBindToCell(table, col, row) {
    var _a;
    const rect = table.getCellRangeRelativeRect({
      col,
      row
    }), element = null !== (_a = table.internalProps.menu.parentElement) && void 0 !== _a ? _a : table.getElement(), { top, bottom, left, right } = rect;
    if (table.isFrozenCell(col, row)) return true;
    if (bottom < table.getFrozenRowsHeight() || right < table.getFrozenColsWidth() || left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() || top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) return false;
    const { offsetHeight, offsetWidth } = element;
    return !(offsetHeight < top) && !(offsetWidth < left);
  }
  _bindToCell(table, col, row, position, referencePosition) {
    var _a;
    const rootElement = this._rootElement, element = null !== (_a = table.internalProps.menu.parentElement) && void 0 !== _a ? _a : table.getElement(), { width: containerWidth, height: containerHeight, left: containerLeft, top: containerTop } = element.getBoundingClientRect();
    if (rootElement) {
      rootElement.parentElement !== element && element.appendChild(rootElement), rootElement.style.left = "0px";
      const maxWidth = 0.8 * containerWidth;
      rootElement.style.maxWidth = `${maxWidth}px`;
      const rootElementWidth = rootElement.offsetWidth, rootElementHeight = rootElement.offsetHeight;
      let rootElementLeft, rootElementTop;
      position ? (rootElementLeft = position.x, rootElementTop = position.y) : referencePosition && (rootElementLeft = referencePosition.rect.right - rootElementWidth, rootElementTop = referencePosition.rect.bottom);
      const rect = element.getBoundingClientRect(), scaleX = rect.width / element.offsetWidth, scaleY = rect.height / element.offsetHeight;
      rootElementTop * scaleY + rootElementHeight > containerHeight && (rootElementTop = (containerHeight - rootElementHeight) / scaleY), rootElementTop < 0 && (rootElementTop /= 2);
      let deltaTop = 0, deltaLeft = 0;
      if (table.getElement() !== element) {
        const { left, top } = table.getElement().getBoundingClientRect();
        deltaTop = top - containerTop, deltaLeft = left - containerLeft;
      }
      return rootElement.style.top = `${rootElementTop + deltaTop}px`, rootElementLeft < 0 ? rootElementLeft = 0 : rootElementLeft * scaleX + rootElementWidth > containerWidth && (rootElementLeft = (containerWidth - rootElementWidth) / scaleX), rootElement.style.left = `${rootElementLeft + deltaLeft}px`, true;
    }
    return false;
  }
  _bindSecondElement(table, col, row, x, y) {
    var _a;
    const secondElement = this._secondElement, rootElement = this._rootElement, element = null !== (_a = table.internalProps.menu.parentElement) && void 0 !== _a ? _a : table.getElement(), { width: containerWidth, left: containerLeft, top: containerTop } = element.getBoundingClientRect(), { x: rootLeft, y: rootTop, width: rootWidth } = rootElement.getBoundingClientRect();
    if (secondElement) {
      secondElement.parentElement !== element && element.appendChild(secondElement), secondElement.style.left = "0px";
      const maxWidth = 0.8 * containerWidth;
      secondElement.style.maxWidth = `${maxWidth}px`;
      const secondElementWidth = secondElement.clientWidth, secondElementTop = y - 4 - containerTop, secondElementLeft = x - containerLeft;
      secondElement.style.top = `${secondElementTop}px`;
      let leftStyle = secondElementLeft;
      return leftStyle + secondElementWidth > containerWidth ? leftStyle = leftStyle - secondElementWidth - rootWidth : leftStyle += 4, secondElement.style.left = `${leftStyle}px`, true;
    }
    return false;
  }
  pointInMenuElement(x, y) {
    const rootElement = this._rootElement, { x: rootLeft, y: rootTop, width: rootWidth, height: rootHeight } = rootElement.getBoundingClientRect();
    if (x > rootLeft - 5 && x < rootLeft + rootWidth + 5 && y > rootTop - 5 && y < rootTop + rootHeight + 5) return true;
    const secondElement = this._secondElement;
    if (secondElement) {
      const { x: secondLeft, y: secondTop, width: secondWidth, height: secondHeight } = secondElement.getBoundingClientRect();
      if (x > secondLeft - 5 && x < secondLeft + secondWidth + 5 && y > secondTop - 5 && y < secondTop + secondHeight + 5) return true;
    }
    return false;
  }
};
function createItem(info, isHighlight) {
  var _a, _b, _c;
  const itemContainer = createElement("div", [ITEM_CLASSNAME, isHighlight ? SELECT_CLASSNAME : NORAML_CLASSNAME]);
  if ("object" == typeof info && info.disabled && itemContainer.classList.add(ITEM_DISABLED_CLASSNAME), "string" == typeof info) {
    const item = createElement("span", [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ITEMTEXT_CLASSNAME]);
    item.innerHTML = info, itemContainer.appendChild(item);
  } else if ("object" == typeof info) {
    const type = null !== (_a = info.type) && void 0 !== _a ? _a : "item";
    if ("split" === type) return null == itemContainer || itemContainer.classList.add(SPLIT_CLASSNAME), itemContainer;
    if (null === (_b = null == info ? void 0 : info.icon) || void 0 === _b ? void 0 : _b.svg) if (regUrl.test(info.icon.svg)) {
      const image = new Image();
      info.icon.width ? image.style.width = info.icon.width.toString() + "px" : image.style.width = "16px", info.icon.height ? image.style.height = info.icon.height.toString() + "px" : image.style.height = "16px", image.src = info.icon.svg, itemContainer.appendChild(image);
    } else {
      const svg = createElement("span", [ICOM_CLASSNAME, NOEVENT_CLASSNAME]);
      svg.innerHTML = isHighlight && info.selectedIcon && info.selectedIcon.svg ? info.selectedIcon.svg : info.icon.svg, info.icon.width && svg.children[0].setAttribute("width", info.icon.width.toString()), info.icon.height && svg.children[0].setAttribute("height", info.icon.height.toString()), itemContainer.appendChild(svg);
    }
    const item = createElement("span", [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ITEMTEXT_CLASSNAME]);
    if (item.innerHTML = info.text, itemContainer.appendChild(item), "title" === type) null == itemContainer || itemContainer.classList.add(NOEVENT_CLASSNAME, TITLE_CLASSNAME);
    else if (null === (_c = null == info ? void 0 : info.children) || void 0 === _c ? void 0 : _c.length) {
      const arrow2 = createElement("span", [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ARROW_CLASSNAME]);
      arrow2.innerHTML = isHighlight ? '<svg width="8" height="12" viewBox="0 0 10 17" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: baseline"><path d="M1.78186 16.7729L0.300378 15.2915L6.8189 8.77295L0.300377 2.25443L1.78186 0.77295L9.78186 8.77295L1.78186 16.7729Z" fill="#2E68CF" fill-opacity="0.65"></path></svg>' : '<svg width="8" height="12" viewBox="0 0 10 17" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: baseline"><path d="M1.78186 16.7729L0.300378 15.2915L6.8189 8.77295L0.300377 2.25443L1.78186 0.77295L9.78186 8.77295L1.78186 16.7729Z" fill="#141414" fill-opacity="0.65"></path></svg>', itemContainer.appendChild(arrow2);
    }
  }
  return itemContainer;
}

// node_modules/@visactor/vtable/es/header-helper/style/Style.js
var defaultStyle9;
var EVENT_TYPE3 = {
  CHANGE_STYLE: "change_style"
};
var Style2 = class _Style extends EventTarget3 {
  static get EVENT_TYPE() {
    return EVENT_TYPE3;
  }
  static get DEFAULT() {
    return defaultStyle9 || (defaultStyle9 = new _Style());
  }
  constructor(style2 = {}, headerStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
    super(), this._defaultPadding = [10, 16, 10, 16], this._color = null !== (_a = style2.color) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.color, this._strokeColor = null !== (_b = null == style2 ? void 0 : style2.strokeColor) && void 0 !== _b ? _b : null == headerStyle ? void 0 : headerStyle.strokeColor, this._fontSize = null !== (_c = style2.fontSize) && void 0 !== _c ? _c : null == headerStyle ? void 0 : headerStyle.fontSize, this._fontFamily = null !== (_d = style2.fontFamily) && void 0 !== _d ? _d : null == headerStyle ? void 0 : headerStyle.fontFamily, this._fontWeight = null !== (_e = style2.fontWeight) && void 0 !== _e ? _e : null == headerStyle ? void 0 : headerStyle.fontWeight, this._fontVariant = null !== (_f = style2.fontVariant) && void 0 !== _f ? _f : null == headerStyle ? void 0 : headerStyle.fontVariant, this._fontStyle = null !== (_g = style2.fontStyle) && void 0 !== _g ? _g : null == headerStyle ? void 0 : headerStyle.fontStyle, this._textOverflow = (null !== (_h = style2.textOverflow) && void 0 !== _h ? _h : null == headerStyle ? void 0 : headerStyle.textOverflow) || "ellipsis", this._textStick = null !== (_k = null !== (_j = style2.textStick) && void 0 !== _j ? _j : null == headerStyle ? void 0 : headerStyle.textStick) && void 0 !== _k && _k, this._textStickBaseOnAlign = null !== (_m = null !== (_l = style2.textStickBaseOnAlign) && void 0 !== _l ? _l : null == headerStyle ? void 0 : headerStyle.textStickBaseOnAlign) && void 0 !== _m && _m, this._marked = null !== (_p = null !== (_o = style2.marked) && void 0 !== _o ? _o : null == headerStyle ? void 0 : headerStyle.marked) && void 0 !== _p && _p, this._textAlign = (null !== (_q = style2.textAlign) && void 0 !== _q ? _q : null == headerStyle ? void 0 : headerStyle.textAlign) || "left", this._textBaseline = (null !== (_r = style2.textBaseline) && void 0 !== _r ? _r : null == headerStyle ? void 0 : headerStyle.textBaseline) || "middle", this._bgColor = null !== (_s = style2.bgColor) && void 0 !== _s ? _s : null == headerStyle ? void 0 : headerStyle.bgColor, this._padding = null !== (_u = null !== (_t = style2.padding) && void 0 !== _t ? _t : null == headerStyle ? void 0 : headerStyle.padding) && void 0 !== _u ? _u : this._defaultPadding, this._borderColor = null !== (_v = style2.borderColor) && void 0 !== _v ? _v : null == headerStyle ? void 0 : headerStyle.borderColor, this._lineHeight = null !== (_w = style2.lineHeight) && void 0 !== _w ? _w : null == headerStyle ? void 0 : headerStyle.lineHeight, this._underline = null !== (_x = style2.underline) && void 0 !== _x ? _x : null == headerStyle ? void 0 : headerStyle.underline, this._underlineColor = null !== (_y = style2.underlineColor) && void 0 !== _y ? _y : null == headerStyle ? void 0 : headerStyle.underlineColor, this._underlineDash = null !== (_z = style2.underlineDash) && void 0 !== _z ? _z : null == headerStyle ? void 0 : headerStyle.underlineDash, this._underlineOffset = null !== (_0 = style2.underlineOffset) && void 0 !== _0 ? _0 : null == headerStyle ? void 0 : headerStyle.underlineOffset, this._lineThrough = null !== (_1 = style2.lineThrough) && void 0 !== _1 ? _1 : null == headerStyle ? void 0 : headerStyle.lineThrough, this._lineThroughColor = null !== (_2 = style2.lineThroughColor) && void 0 !== _2 ? _2 : null == headerStyle ? void 0 : headerStyle.lineThroughColor, this._lineThroughDash = null !== (_3 = style2.lineThroughDash) && void 0 !== _3 ? _3 : null == headerStyle ? void 0 : headerStyle.lineThroughDash, this._linkColor = null !== (_4 = style2.linkColor) && void 0 !== _4 ? _4 : null == headerStyle ? void 0 : headerStyle.linkColor, this._cursor = null !== (_5 = style2.cursor) && void 0 !== _5 ? _5 : null == headerStyle ? void 0 : headerStyle.cursor, this._borderLineWidth = null !== (_6 = style2.borderLineWidth) && void 0 !== _6 ? _6 : null == headerStyle ? void 0 : headerStyle.borderLineWidth, this._borderLineDash = null !== (_7 = style2.borderLineDash) && void 0 !== _7 ? _7 : null == headerStyle ? void 0 : headerStyle.borderLineDash;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(bgColor) {
    this._bgColor = bgColor;
  }
  get color() {
    return this._color;
  }
  set color(color) {
    this._color = color;
  }
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(strokeColor) {
    this._strokeColor = strokeColor;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    this._fontSize = fontSize;
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    this._fontFamily = fontFamily;
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    this._fontWeight = fontWeight;
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    this._fontVariant = fontVariant;
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    this._fontStyle = fontStyle;
  }
  get textOverflow() {
    return this._textOverflow;
  }
  set textOverflow(textOverflow) {
    this._textOverflow = textOverflow;
  }
  get padding() {
    var _a;
    return null !== (_a = this._padding) && void 0 !== _a ? _a : this._defaultPadding;
  }
  set padding(padding) {
    this._padding = padding;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(borderColor) {
    this._borderColor = borderColor;
  }
  get textStick() {
    return this._textStick;
  }
  set textStick(textStick) {
    this._textStick = textStick;
  }
  get textStickBaseOnAlign() {
    return this._textStickBaseOnAlign;
  }
  set textStickBaseOnAlign(textStickBaseOnAlign) {
    this._textStickBaseOnAlign = textStickBaseOnAlign;
  }
  get marked() {
    return this._marked;
  }
  set marked(marked) {
    this._marked = marked;
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(textAlign) {
    this._textAlign = textAlign;
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    this._textBaseline = textBaseline;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    this._lineHeight = lineHeight;
  }
  get underline() {
    return this._underline;
  }
  set underline(underline) {
    this._underline = underline;
  }
  get underlineColor() {
    return this._underlineColor;
  }
  set underlineColor(underlineColor) {
    this._underlineColor = underlineColor;
  }
  get underlineDash() {
    return this._underlineDash;
  }
  set underlineDash(underlineDash) {
    this._underlineDash = underlineDash;
  }
  get underlineOffset() {
    return this._underlineOffset;
  }
  set underlineOffset(underlineOffset) {
    this._underlineOffset = underlineOffset;
  }
  get lineThrough() {
    return this._lineThrough;
  }
  set lineThrough(lineThrough) {
    this._lineThrough = lineThrough;
  }
  get lineThroughColor() {
    return this._lineThroughColor;
  }
  set lineThroughColor(lineThroughColor) {
    this._lineThroughColor = lineThroughColor;
  }
  get lineThroughDash() {
    return this._lineThroughDash;
  }
  set lineThroughDash(lineThroughDash) {
    this._lineThroughDash = lineThroughDash;
  }
  get linkColor() {
    return this._linkColor;
  }
  set linkColor(linkColor) {
    this._linkColor = linkColor;
  }
  get cursor() {
    return this._cursor;
  }
  set cursor(cursor) {
    this._cursor = cursor;
  }
  get borderLineWidth() {
    return this._borderLineWidth;
  }
  set borderLineWidth(borderLineWidth) {
    this._borderLineWidth = borderLineWidth;
  }
  get borderLineDash() {
    return this._borderLineDash;
  }
  set borderLineDash(borderLineDash) {
    this._borderLineDash = borderLineDash;
  }
  clone() {
    return new _Style(this);
  }
};

// node_modules/@visactor/vtable/es/header-helper/style/ImageStyle.js
var defaultStyle10;
var ImageStyle2 = class _ImageStyle extends Style2 {
  static get DEFAULT() {
    return defaultStyle10 || (defaultStyle10 = new _ImageStyle());
  }
  constructor(style2 = {}, headerStyle = {}) {
    var _a;
    super(style2, headerStyle), this.textAlign = (null !== (_a = style2.textAlign) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.textAlign) || "center";
  }
  clone() {
    return new _ImageStyle(this);
  }
};

// node_modules/@visactor/vtable/es/header-helper/style/MultilineTextHeaderStyle.js
var defaultStyle11;
var TextHeaderStyle = class _TextHeaderStyle extends Style2 {
  static get DEFAULT() {
    return defaultStyle11 || (defaultStyle11 = new _TextHeaderStyle());
  }
  constructor(style2 = {}, headerStyle = null) {
    var _a, _b;
    super(style2, headerStyle), this._autoWrapText = null !== (_a = null == style2 ? void 0 : style2.autoWrapText) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.autoWrapText, this._lineClamp = null !== (_b = null == style2 ? void 0 : style2.lineClamp) && void 0 !== _b ? _b : null == headerStyle ? void 0 : headerStyle.lineClamp;
  }
  clone() {
    return new _TextHeaderStyle(this, null);
  }
  get lineClamp() {
    return this._lineClamp;
  }
  set lineClamp(lineClamp) {
    this._lineClamp = lineClamp;
  }
  get autoWrapText() {
    return this._autoWrapText;
  }
  set autoWrapText(autoWrapText) {
    this._autoWrapText = autoWrapText;
  }
};

// node_modules/@visactor/vtable/es/header-helper/style/CheckboxStyle.js
var defaultStyle12;
var CheckboxStyle2 = class _CheckboxStyle extends Style2 {
  static get DEFAULT() {
    return defaultStyle12 || (defaultStyle12 = new _CheckboxStyle());
  }
  constructor(style2 = {}, headerStyle = {}, checkboxThemeStyle = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    super(style2, headerStyle), this._size = (null !== (_b = null !== (_a = null == style2 ? void 0 : style2.size) && void 0 !== _a ? _a : null == headerStyle ? void 0 : headerStyle.size) && void 0 !== _b ? _b : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.size) || 14, this._spaceBetweenTextAndIcon = (null !== (_d = null !== (_c = null == style2 ? void 0 : style2.spaceBetweenTextAndIcon) && void 0 !== _c ? _c : null == headerStyle ? void 0 : headerStyle.spaceBetweenTextAndIcon) && void 0 !== _d ? _d : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.spaceBetweenTextAndIcon) || 8, this._defaultFill = null !== (_f = null === (_e = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _e ? void 0 : _e.defaultFill) && void 0 !== _f ? _f : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.defaultFill, this._defaultStroke = null !== (_h = null === (_g = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _g ? void 0 : _g.defaultStroke) && void 0 !== _h ? _h : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.defaultStroke, this._disableFill = null !== (_k = null === (_j = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _j ? void 0 : _j.disableFill) && void 0 !== _k ? _k : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableFill, this._checkedFill = null !== (_m = null === (_l = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _l ? void 0 : _l.checkedFill) && void 0 !== _m ? _m : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkedFill, this._checkedStroke = null !== (_p = null === (_o = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _o ? void 0 : _o.checkedStroke) && void 0 !== _p ? _p : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkedStroke, this._disableCheckedFill = null !== (_r = null === (_q = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _q ? void 0 : _q.disableCheckedFill) && void 0 !== _r ? _r : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableCheckedFill, this._disableCheckedStroke = null !== (_t = null === (_s = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _s ? void 0 : _s.disableCheckedStroke) && void 0 !== _t ? _t : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.disableCheckedStroke, this._checkIconImage = null !== (_v = null === (_u = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _u ? void 0 : _u.checkIconImage) && void 0 !== _v ? _v : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.checkIconImage, this._indeterminateIconImage = null !== (_x = null === (_w = null == style2 ? void 0 : style2.checkboxStyle) || void 0 === _w ? void 0 : _w.indeterminateIconImage) && void 0 !== _x ? _x : null == checkboxThemeStyle ? void 0 : checkboxThemeStyle.indeterminateIconImage;
  }
  get size() {
    return this._size;
  }
  set size(size) {
    this._size = size;
  }
  get spaceBetweenTextAndIcon() {
    return this._spaceBetweenTextAndIcon;
  }
  set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
    this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
  }
  get defaultFill() {
    return this._defaultFill;
  }
  set defaultFill(defaultFill) {
    this._defaultFill = defaultFill;
  }
  get defaultStroke() {
    return this._defaultStroke;
  }
  set defaultStroke(defaultStroke) {
    this._defaultStroke = defaultStroke;
  }
  get disableFill() {
    return this._disableFill;
  }
  set disableFill(disableFill) {
    this._disableFill = disableFill;
  }
  get checkedFill() {
    return this._checkedFill;
  }
  set checkedFill(checkedFill) {
    this._checkedFill = checkedFill;
  }
  get checkedStroke() {
    return this._checkedStroke;
  }
  set checkedStroke(checkedStroke) {
    this._checkedStroke = checkedStroke;
  }
  get disableCheckedFill() {
    return this._disableCheckedFill;
  }
  set disableCheckedFill(disableCheckedFill) {
    this._disableCheckedFill = disableCheckedFill;
  }
  get disableCheckedStroke() {
    return this._disableCheckedStroke;
  }
  set disableCheckedStroke(disableCheckedStroke) {
    this._disableCheckedStroke = disableCheckedStroke;
  }
  get checkIconImage() {
    return this._checkIconImage;
  }
  set checkIconImage(checkIconImage) {
    this._checkIconImage = checkIconImage;
  }
  get indeterminateIconImage() {
    return this._indeterminateIconImage;
  }
  set indeterminateIconImage(indeterminateIconImage) {
    this._indeterminateIconImage = indeterminateIconImage;
  }
  getStyle(style2) {
    return new _CheckboxStyle(style2, this);
  }
  clone() {
    return new _CheckboxStyle(this);
  }
};

// node_modules/@visactor/vtable/es/header-helper/style.js
function of3(headerStyle, defaultHeaderStyle, styleArg, StyleClass, globalAutoWrapText, theme4) {
  var _a;
  return headerStyle || defaultHeaderStyle ? headerStyle instanceof Style2 ? headerStyle : "function" == typeof headerStyle ? of3(headerStyle(styleArg), defaultHeaderStyle, styleArg, StyleClass, globalAutoWrapText, theme4) : (headerStyle || (headerStyle = {}), globalAutoWrapText && !isValid_default(headerStyle.autoWrapText) && (headerStyle.autoWrapText = true), StyleClass === CheckboxStyle2 ? new CheckboxStyle2(null != headerStyle ? headerStyle : {}, null != defaultHeaderStyle ? defaultHeaderStyle : {}, null !== (_a = theme4.checkboxStyle) && void 0 !== _a ? _a : {}) : new StyleClass(null != headerStyle ? headerStyle : {}, null != defaultHeaderStyle ? defaultHeaderStyle : {})) : StyleClass.DEFAULT;
}

// node_modules/@visactor/vtable/es/header-helper/header-helper.js
var HeaderHelper = class {
  constructor(_table) {
    this._table = _table;
    const regedIcons3 = get3();
    this.freezeIcon = regedIcons3[InternalIconName.freezeIconName], this.frozenIcon = regedIcons3[InternalIconName.frozenIconName], this.frozenCurrentIcon = regedIcons3[InternalIconName.frozenCurrentIconName], this.normalIcon = regedIcons3[InternalIconName.normalIconName], this.upIcon = regedIcons3[InternalIconName.upwardIconName], this.downIcon = regedIcons3[InternalIconName.downwardIconName], this.dropDownAbsoluteIcon = regedIcons3[InternalIconName.dropdownIconName], this.expandIcon = regedIcons3[InternalIconName.expandIconName], this.collapseIcon = regedIcons3[InternalIconName.collapseIconName];
  }
  getIcons(col, row) {
    const icons2 = [];
    if (this._table.isPivotTable()) {
      const { showSort, sort: sort2 } = this._table.internalProps.layoutMap.getHeader(col, row);
      let _showSort;
      if (_showSort = "function" == typeof showSort ? showSort({
        col,
        row,
        table: this._table
      }) : showSort, _showSort) {
        let order = this._table.getPivotSortState(col, row);
        order && (order = order.toUpperCase());
        const sortIcon = "ASC" === order ? this.upIcon : "DESC" === order ? this.downIcon : this.normalIcon;
        sortIcon && icons2.push(sortIcon);
      } else if (sort2) {
        const sortIcon = this.getSortIconForPivotTable(this._table.getPivotSortState(col, row), this._table, col, row);
        sortIcon && icons2.push(sortIcon);
      }
    } else {
      const states = this._table.sortState;
      let order;
      order = void 0;
      const range5 = this._table.getCellRange(col, row);
      if (states) if (Array.isArray(states)) for (let i = 0; i < states.length; i++) {
        const state = states[i], stateRange = this._table._getHeaderCellBySortState(state);
        if (stateRange && cellInRange(range5, stateRange.col, stateRange.row)) {
          ({ order } = state);
          break;
        }
      }
      else {
        const stateRange = this._table._getHeaderCellBySortState(states);
        stateRange && cellInRange(range5, stateRange.col, stateRange.row) && ({ order } = states);
      }
      const sortIcon = this.getSortIcon(order, this._table, col, row);
      sortIcon && icons2.push(sortIcon);
    }
    if (this._table.showFrozenIcon && col < this._table.allowFrozenColCount) {
      const pinInline = this.getFrozenIcon(col, row);
      pinInline && icons2.push(pinInline);
    }
    if (this.checkDropDownIcon(this._table, col, row)) {
      const dropDownMenuIcon = this.dropDownAbsoluteIcon;
      icons2.push(dropDownMenuIcon);
    }
    const dropDownStateIcons = this.getDropDownStateIcons(this._table, col, row);
    dropDownStateIcons.length && icons2.push(...dropDownStateIcons);
    const { headerIcon } = this._table._getHeaderLayoutMap(col, row), hierarchyIcon = this.getHierarchyIcon(col, row);
    if (hierarchyIcon && icons2.push(hierarchyIcon), headerIcon) {
      let headerIconStrs;
      if ("function" == typeof headerIcon) {
        headerIconStrs = headerIcon({
          col,
          row,
          value: this._table.getCellValue(col, row),
          dataValue: this._table.getCellOriginValue(col, row),
          table: this._table
        });
      } else headerIconStrs = headerIcon;
      const regedIcons3 = get3(), addIcon = (headerIcon2) => {
        let icon2;
        icon2 = "string" == typeof headerIcon2 ? regedIcons3[headerIcon2] : headerIcon2, icon2 && icons2.push(icon2);
      };
      Array.isArray(headerIconStrs) ? headerIconStrs.forEach((columnIcon, index) => {
        addIcon(columnIcon);
      }) : addIcon(headerIconStrs);
    }
    return icons2;
  }
  getFrozenIcon(col, row) {
    if (this._table.isPivotTable() || this._table.transpose) return null;
    if (this._table.rightFrozenColCount && col >= this._table.colCount - this._table.rightFrozenColCount) return null;
    const headerC = this._table.getHeaderDefine(col, row);
    if (headerC.columns && headerC.columns.length > 0) return null;
    let frozen = this.freezeIcon;
    return this._table.options.frozenColCount - 1 > col ? frozen = this.frozenIcon : this._table.options.frozenColCount - 1 === col && (frozen = this.frozenCurrentIcon), frozen;
  }
  getSortIcon(order, _table, col, row) {
    const icon2 = "asc" === order ? this.upIcon : "desc" === order ? this.downIcon : this.normalIcon, headerC = _table.getHeaderDefine(col, row);
    let _showSort;
    return headerC && (_showSort = "function" == typeof headerC.showSort ? headerC.showSort({
      col,
      row,
      table: this._table
    }) : headerC.showSort), !headerC || false === _showSort || !isValid_default(_showSort) && !headerC.sort || headerC.columns && headerC.columns.length > 0 ? null : icon2;
  }
  getSortIconForPivotTable(order, _table, col, row) {
    const headerC = _table.getHeaderDefine(col, row);
    let _showSort;
    if (headerC && (_showSort = "function" == typeof headerC.showSort ? headerC.showSort({
      col,
      row,
      table: this._table
    }) : headerC.showSort), !headerC || false === _showSort || !isValid_default(_showSort) && !headerC.sort || headerC.columns && headerC.columns.length > 0) return null;
    return "ASC" === (null == order ? void 0 : order.toUpperCase()) ? this.upIcon : "DESC" === (null == order ? void 0 : order.toUpperCase()) ? this.downIcon : this.normalIcon;
  }
  getDropDownStateIcons(_table, col, row) {
    var _a, _b, _c;
    const headerC = _table.getHeaderDefine(col, row), headerL = _table._getHeaderLayoutMap(col, row);
    let { dropDownMenu } = headerL;
    "function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
      row,
      col,
      table: _table
    }));
    let globalDropDownMenu = _table.globalDropDownMenu;
    "function" == typeof globalDropDownMenu && (globalDropDownMenu = globalDropDownMenu({
      row,
      col,
      table: _table
    }));
    const results = [];
    if (Array.isArray(dropDownMenu) && dropDownMenu.length || Array.isArray(globalDropDownMenu) && globalDropDownMenu.length && !(null === (_a = null == headerC ? void 0 : headerC.columns) || void 0 === _a ? void 0 : _a.length)) {
      const menus = dropDownMenu || globalDropDownMenu;
      let highlightIndex = -1, subHighlightIndex = -1;
      for (let i = 0; i < menus.length; i++) {
        const menu = menus[i];
        if ("object" == typeof menu && menu.children && menu.children.length) for (let j = 0; j < menu.children.length; j++) {
          const childItem = menu.children[j];
          if ((null === (_b = _table.stateManager.menu) || void 0 === _b ? void 0 : _b.dropDownMenuHighlight) && isMenuHighlight(_table, null === (_c = _table.stateManager.menu) || void 0 === _c ? void 0 : _c.dropDownMenuHighlight, "object" == typeof childItem ? null == childItem ? void 0 : childItem.menuKey : childItem, col, row, i)) {
            highlightIndex = i, subHighlightIndex = j;
            break;
          }
        }
        if (_table._dropDownMenuIsHighlight(col, row, i)) {
          highlightIndex = i;
          break;
        }
      }
      if (-1 !== highlightIndex) {
        let menu;
        menu = -1 !== subHighlightIndex ? menus[highlightIndex].children[subHighlightIndex] : menus[highlightIndex], menu.stateIcon && (menu.stateIcon.svg ? results.push({
          type: "svg",
          name: menu.stateIcon.src || menu.stateIcon.svg,
          width: menu.stateIcon.width || 22,
          height: menu.stateIcon.height || 22,
          svg: menu.stateIcon.svg,
          positionType: IconPosition.right,
          marginRight: 0,
          funcType: IconFuncTypeEnum.dropDownState,
          interactive: false
        }) : menu.stateIcon.src && results.push({
          type: "image",
          name: menu.stateIcon.src || menu.stateIcon.svg,
          width: menu.stateIcon.width || 22,
          height: menu.stateIcon.height || 22,
          src: menu.stateIcon.src,
          positionType: IconPosition.right,
          marginRight: 0,
          funcType: IconFuncTypeEnum.dropDownState,
          interactive: false
        }));
      }
    }
    return results;
  }
  getDropDownIconRect(cellRect, marginTop, baseline) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const iconW = null !== (_d = null !== (_b = null === (_a = this.downIcon.hover) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : null === (_c = this.downIcon) || void 0 === _c ? void 0 : _c.width) && void 0 !== _d ? _d : 0, iconH = null !== (_h = null !== (_f = null === (_e = this.downIcon.hover) || void 0 === _e ? void 0 : _e.height) && void 0 !== _f ? _f : null === (_g = this.downIcon) || void 0 === _g ? void 0 : _g.height) && void 0 !== _h ? _h : 0, left = cellRect.right - 2 - iconW, right = cellRect.right - 2;
    let top;
    top = "middle" === baseline ? cellRect.top + cellRect.height / 2 - iconW / 2 : "top" === baseline ? cellRect.top + marginTop / 2 : "bottom" === baseline ? cellRect.bottom - 2 * marginTop : cellRect.top;
    return {
      left,
      right,
      top,
      bottom: iconH + top,
      width: iconW,
      height: iconH
    };
  }
  getHierarchyIcon(col, row) {
    const { hierarchyState } = this._table._getHeaderLayoutMap(col, row);
    if (hierarchyState) {
      if (hierarchyState === HierarchyState.expand) return this.expandIcon;
      if (hierarchyState === HierarchyState.collapse) return this.collapseIcon;
    }
  }
  getHierarchyIconWidth() {
    var _a, _b;
    return this.expandIcon.width + (null !== (_a = this.expandIcon.marginLeft) && void 0 !== _a ? _a : 0) + (null !== (_b = this.expandIcon.marginRight) && void 0 !== _b ? _b : 0);
  }
  checkDropDownIcon(_table, col, row) {
    var _a;
    if (_table.isPivotTable()) {
      let dropDownMenu = _table._getHeaderLayoutMap(col, row).dropDownMenu;
      if ("function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
        row,
        col,
        table: _table
      })), Array.isArray(dropDownMenu) && dropDownMenu.length) return true;
    } else {
      const headerC = _table.getHeaderDefine(col, row), dropDownMenu = headerC.dropDownMenu;
      let globalDropDownMenu = _table.globalDropDownMenu;
      if ("function" == typeof globalDropDownMenu && (globalDropDownMenu = globalDropDownMenu({
        row,
        col,
        table: _table
      })), Array.isArray(dropDownMenu) && dropDownMenu.length || (!Array.isArray(headerC.dropDownMenu) || 0 !== headerC.dropDownMenu.length) && Array.isArray(globalDropDownMenu) && globalDropDownMenu.length && !(null === (_a = null == headerC ? void 0 : headerC.columns) || void 0 === _a ? void 0 : _a.length)) return true;
    }
    return false;
  }
  getStyleClass(headerType) {
    switch (headerType) {
      case "text":
      case "link":
        return TextHeaderStyle;
      case "image":
      case "video":
        return ImageStyle2;
      case "checkbox":
        return CheckboxStyle2;
    }
  }
  setTableColumnsEditor() {
    const setEditor = (colDefines, setColumns) => {
      null == colDefines || colDefines.forEach((colDefine, index) => {
        colDefine.editor && (setColumns[index].editor = colDefine.editor), colDefine.columns && setEditor(colDefine.columns, setColumns[index].columns);
      });
    };
    setEditor(this._table.options.columns, this._table.internalProps.columns);
  }
};

// node_modules/@visactor/vtable/es/core/FouseInput.js
var FocusInput = class extends EventTarget {
  constructor(table, parentElement) {
    if (super(), this._table = table, "node" === Env.mode) return;
    const div = document.createElement("div");
    div.style.opacity = "0", div.dataset.vtable = "vtable", div.style.pointerEvents = "none", div.classList.add("input-container");
    const input = this._input = document.createElement("input");
    div.appendChild(input), input.classList.add("table-focus-control"), input.dataset.vtable = "vtable", input.readOnly = true, parentElement.appendChild(div), this._container = div;
  }
  focus() {
    this._input.focus({
      preventScroll: true
    });
  }
  setFocusRect(rect, value) {
    const input = this._input;
    input.value = value, input.select();
    const top = rect.top - this._table.scrollTop, left = rect.left - this._table.scrollLeft;
    input.style.top = `${top.toFixed()}px`, input.style.left = `${left.toFixed()}px`, input.style.width = `${rect.width.toFixed()}px`, input.style.height = `${rect.height.toFixed()}px`;
  }
  get input() {
    return this._input;
  }
  release() {
    var _a;
    null === (_a = this._container.parentElement) || void 0 === _a || _a.removeChild(this._container);
  }
};

// node_modules/@visactor/vtable/es/layout/row-height-map.js
var NumberRangeMap = class {
  constructor(table) {
    this.isUpdate = false, this._keys = [], this._sorted = false, this.data = /* @__PURE__ */ new Map(), this._keys.length = 0, this.cumulativeSum = /* @__PURE__ */ new Map(), this.difference = /* @__PURE__ */ new Map(), this.totalSum = 0, this.table = table;
  }
  get length() {
    return this.data.size;
  }
  clear() {
    this._keys = [], this.data.clear(), this.cumulativeSum.clear(), this.difference.clear(), this.totalSum = 0;
  }
  clearRange() {
    this.cumulativeSum.clear(), this.difference.clear();
  }
  add(position, value) {
    if (!isValid_default(value)) return;
    const defaultValue = this.table.getRowHeight(position);
    this.data.has(position) || (this._keys.push(position), this._sorted = false), this.data.set(position, value), this.totalSum += value, this.updateDifference(position, value - defaultValue);
  }
  remove(position) {
    if (this.data.has(position)) {
      const value = this.data.get(position);
      this.data.delete(position);
      const index = this._keys.indexOf(position);
      -1 !== index && this._keys.splice(index, 1), this.totalSum -= value;
      const defaultValue = this.table.getRowHeight(position);
      this.updateDifference(position, defaultValue - value);
    }
  }
  put(position, newValue) {
    if (isValid_default(newValue)) if (this.data.has(position)) {
      const oldValue = this.data.get(position);
      if (oldValue === newValue) return;
      this.data.set(position, newValue);
      const difference = newValue - oldValue;
      this.totalSum += difference, this.updateDifference(position, difference);
    } else this.add(position, newValue);
  }
  get(position) {
    return this.data.get(position);
  }
  has(position) {
    return this.data.has(position);
  }
  _sort() {
    const { _keys: keys2 } = this;
    this._sorted || (keys2.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0), this._sorted = true);
  }
  updateDifference(position, difference) {
    var _a;
    const oldDifference = null !== (_a = this.difference.get(position)) && void 0 !== _a ? _a : 0;
    this.difference.set(position, oldDifference + difference), this.update();
  }
  getSumInRange(start, end) {
    return this.calculatePrefixSum(end) - this.calculatePrefixSum(start - 1);
  }
  updateCumulativeSum(position, difference) {
    for (const [pos, sum] of this.cumulativeSum) pos >= position && this.cumulativeSum.set(pos, sum + difference);
  }
  calculatePrefixSum(position) {
    if (position < 0) return 0;
    if (this.cumulativeSum.has(position)) {
      let cache = this.cumulativeSum.get(position);
      for (const [pos, difference] of this.difference) pos <= position && (cache += difference);
      return cache;
    }
    return this.dealDiffenence(), this.getCumulativeSum(position);
  }
  getCumulativeSum(position) {
    var _a;
    let sum = 0;
    for (let i = position; i >= 0; i--) {
      if (this.cumulativeSum.has(i)) {
        sum += this.cumulativeSum.get(i);
        break;
      }
      sum += null !== (_a = this.data.get(i)) && void 0 !== _a ? _a : this.table.getRowHeight(i);
    }
    return this.cumulativeSum.set(position, sum), sum;
  }
  update() {
    this.isUpdate || (this.isUpdate = true, setTimeout(() => {
      this.dealDiffenence(), this.isUpdate = false;
    }, 0));
  }
  dealDiffenence() {
    for (const [sumPos] of this.cumulativeSum) for (const [difPos, difference] of this.difference) if (sumPos >= difPos) {
      const oldSum = this.cumulativeSum.get(sumPos);
      this.cumulativeSum.set(sumPos, oldSum + difference);
    }
    this.difference.clear();
  }
  insert(position, value) {
    for (let i = position; i <= this.getLastIndex(); i++) this.cumulativeSum.delete(i);
    const lastIndex = this.getLastIndex() + 1;
    this.adjustOrder(position, position + 1, lastIndex - position), isValid_default(value) && this.put(position, value);
  }
  getLastIndex() {
    return this._sort(), this._keys[this._keys.length - 1];
  }
  delLast() {
    const lastIndex = this.getLastIndex();
    this.remove(lastIndex);
  }
  delete(position) {
    if (!this.has(position)) return;
    for (let i = position; i <= this.getLastIndex(); i++) this.cumulativeSum.delete(i);
    const lastIndex = this.getLastIndex();
    this.adjustOrder(position + 1, position, lastIndex - position), this.delLast();
  }
  adjustOrder(sourceIndex, targetIndex, moveCount) {
    this.clearRange(), this._sort();
    const { _keys: keys2 } = this;
    if (sourceIndex > targetIndex) {
      const sourceVals = [];
      for (let i = indexFirst2(keys2, sourceIndex + moveCount - 1); i >= 0; i--) {
        const key = keys2[i];
        if (key >= sourceIndex) sourceVals.push(this.get(key));
        else if (targetIndex <= key && key < sourceIndex) this.put(key + moveCount, this.get(key));
        else if (key < targetIndex) break;
      }
      for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[moveCount - 1 - i]);
    }
    const { length: length2 } = keys2;
    if (sourceIndex < targetIndex) {
      const sourceVals = [];
      for (let i = indexFirst2(keys2, sourceIndex); i < length2; i++) {
        const key = keys2[i];
        if (key >= sourceIndex && key < sourceIndex + moveCount) sourceVals.push(this.get(key));
        else if (sourceIndex + moveCount <= key && key <= targetIndex) this.put(key - moveCount, this.get(key));
        else if (key > targetIndex) break;
      }
      for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[i]);
    }
  }
  exchangeOrder(sourceIndex, sourceCount, targetIndex, targetCount, insertIndex) {
    const { _keys: keys2 } = this;
    if (this._sorted || (keys2.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0), this._sorted = true), sourceIndex > targetIndex) {
      const targetVals = [], sourceVals = [];
      for (let i = indexFirst2(keys2, targetIndex); i < indexFirst2(keys2, sourceIndex) + sourceCount; i++) {
        const key = keys2[i];
        key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
      }
      for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
      for (let i = 0; i < targetVals.length; i++) this.put(insertIndex + sourceCount + i, targetVals[i]);
    } else {
      const targetVals = [], sourceVals = [];
      for (let i = indexFirst2(keys2, sourceIndex); i < indexFirst2(keys2, targetIndex) + targetCount; i++) {
        const key = keys2[i];
        key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
      }
      for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
      for (let i = 0; i < targetVals.length; i++) this.put(sourceIndex + i, targetVals[i]);
    }
  }
};
function indexFirst2(arr, elm) {
  let low = 0, high = arr.length - 1;
  for (; low <= high; ) {
    const i = Math.floor((low + high) / 2);
    if (arr[i] === elm) return i;
    arr[i] > elm ? high = i - 1 : low = i + 1;
  }
  return high < 0 ? 0 : high;
}

// node_modules/@visactor/vtable/es/core/row-series-number-helper.js
var RowSeriesNumberHelper = class {
  constructor(_table) {
    this._table = _table;
    const regedIcons3 = get3();
    this.dragReorderIconName = regedIcons3[InternalIconName.dragReorderIconName];
  }
  getIcons(col, row) {
    return [this.dragReorderIconName];
  }
};

// node_modules/@visactor/vtable/es/layout/tree-helper.js
var DimensionTree = class {
  constructor(tree, sharedVar, hierarchyType = "grid", rowExpandLevel = void 0) {
    this.hasHideNode = false, this.sizeIncludeParent = false, this.tree = {
      id: 0,
      dimensionKey: "",
      value: "",
      children: [],
      level: -1,
      afterSpanLevel: -1,
      levelSpan: 1,
      startIndex: 0,
      size: 0,
      startInTotal: 0,
      hierarchyState: void 0
    }, this.totalLevel = 0, this.expandedMaxLevel = 0, this.dimensionKeys = new NumberMap(), this.dimensionKeysIncludeVirtual = new NumberMap(), this.cache = /* @__PURE__ */ new Map(), this.sizeIncludeParent = null != rowExpandLevel, this.setExpandLevel = rowExpandLevel, this.hierarchyType = hierarchyType, this.sharedVar = sharedVar, this.reset(tree);
  }
  reset(tree) {
    this.totalLevel = 0, this.expandedMaxLevel = 0, this.hasHideNode = false, this.cache.clear(), this.dimensionKeys = new NumberMap(), this.dimensionKeysIncludeVirtual = new NumberMap(), this.tree.children = tree, this.setTreeNode(this.tree, 0, this.tree);
  }
  setTreeNode(node, startIndex, parent) {
    var _a, _b, _c, _d;
    node.startIndex = startIndex, node.startInTotal = (null !== (_a = parent.startInTotal) && void 0 !== _a ? _a : 0) + node.startIndex, node.hide && (this.hasHideNode = true), (null !== (_b = node.dimensionKey) && void 0 !== _b ? _b : node.indicatorKey) && (node.virtual || this.dimensionKeys.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey) || this.dimensionKeys.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey), this.dimensionKeysIncludeVirtual.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey) || this.dimensionKeysIncludeVirtual.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey), node.id || (node.id = ++this.sharedVar.seqId));
    let size = node.dimensionKey && this.sizeIncludeParent ? 1 : 0;
    const children = node.children || node.columns;
    return "grid" === this.hierarchyType || null === this.hierarchyType ? (null == children ? void 0 : children.length) >= 1 ? children.forEach((n) => {
      var _a2, _b2, _c2;
      n.level = (null !== (_a2 = node.level) && void 0 !== _a2 ? _a2 : 0) + 1, "grid" === this.hierarchyType && (n.afterSpanLevel = (null !== (_b2 = node.afterSpanLevel) && void 0 !== _b2 ? _b2 : 0) + (null !== (_c2 = node.levelSpan) && void 0 !== _c2 ? _c2 : 1)), this.totalLevel = Math.max(this.totalLevel, n.level + 1), size += this.setTreeNode(n, size, node);
    }) : size = -1 === node.level ? 0 : 1 : node.hierarchyState === HierarchyState.expand && (null == children ? void 0 : children.length) >= 1 ? children.forEach((n) => {
      var _a2;
      n.level = (null !== (_a2 = node.level) && void 0 !== _a2 ? _a2 : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1), size += this.setTreeNode(n, size, node);
    }) : node.hierarchyState === HierarchyState.collapse && (null == children ? void 0 : children.length) >= 1 ? children.forEach((n) => {
      var _a2;
      n.level = (null !== (_a2 = node.level) && void 0 !== _a2 ? _a2 : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), this.setTreeNode(n, size, node);
    }) : !node.hierarchyState && node.level + 1 < this.setExpandLevel && ((null == children ? void 0 : children.length) >= 1 || true === children) ? ((null === (_c = children[0]) || void 0 === _c ? void 0 : _c.indicatorKey) && "grid-tree" === this.hierarchyType || (node.hierarchyState = HierarchyState.expand), (null == children ? void 0 : children.length) >= 1 && children.forEach((n) => {
      var _a2;
      n.level = (null !== (_a2 = node.level) && void 0 !== _a2 ? _a2 : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1), size += this.setTreeNode(n, size, node);
    })) : (null == children ? void 0 : children.length) >= 1 || true === children ? ((null === (_d = children[0]) || void 0 === _d ? void 0 : _d.indicatorKey) && "grid-tree" === this.hierarchyType || (node.hierarchyState = HierarchyState.collapse), (null == children ? void 0 : children.length) >= 1 && children.forEach((n) => {
      var _a2;
      n.level = (null !== (_a2 = node.level) && void 0 !== _a2 ? _a2 : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), this.setTreeNode(n, size, node);
    })) : (node.hierarchyState = HierarchyState.none, size = -1 === node.level ? 0 : 1), node.size = size, size;
  }
  getTreePath(index, maxDeep = 30) {
    const path = [];
    return this.searchPath(index, this.tree, path, maxDeep), path.shift(), path;
  }
  findNodeById(nodes, id) {
    return nodes.find((node) => node.id === id);
  }
  searchPath(index, node, path, maxDeep) {
    if (!node) return;
    if (index < node.startIndex || index >= node.startIndex + node.size) return;
    if (path.push(node), !node.children || 0 === node.children.length || node.level >= maxDeep) return;
    const cIndex = index - node.startIndex;
    if (this.cache.has(node.level + 1)) {
      const cacheNode = this.cache.get(node.level + 1);
      if (cIndex >= cacheNode.startIndex && cIndex < cacheNode.startIndex + cacheNode.size) return void this.searchPath(cIndex, cacheNode, path, maxDeep);
    }
    let left = 0, right = node.children.length - 1;
    for (; left <= right; ) {
      const middle = Math.floor((left + right) / 2), element = node.children[middle];
      if (cIndex >= element.startIndex && cIndex < element.startIndex + element.size) {
        this.cache.set(element.level, element);
        const deleteLevels = [];
        this.cache.forEach((node2, key) => {
          key > element.level && deleteLevels.push(key);
        }), deleteLevels.forEach((key) => {
          this.cache.delete(key);
        }), this.searchPath(cIndex, element, path, maxDeep);
        break;
      }
      cIndex < element.startIndex ? right = middle - 1 : left = middle + 1;
    }
  }
  movePosition(level, sourceIndex, targetIndex) {
    let parNode, sourceSubIndex, targetSubIndex;
    const findTargetNode = (node, subIndex) => {
      if (void 0 !== sourceSubIndex && void 0 !== targetSubIndex) return;
      node.level === level && (node.startInTotal === sourceIndex && (sourceSubIndex = subIndex), node.startInTotal <= targetIndex && targetIndex <= node.startInTotal + node.size - 1 && (targetSubIndex = subIndex));
      const children2 = node.children || node.columns;
      if (children2 && node.level < level) {
        parNode = node;
        for (let i = 0; i < children2.length; i++) (sourceIndex >= children2[i].startInTotal && sourceIndex <= children2[i].startInTotal + children2[i].size || targetIndex >= children2[i].startInTotal && targetIndex <= children2[i].startInTotal + children2[i].size) && findTargetNode(children2[i], i);
      }
    };
    findTargetNode(this.tree, 0);
    const children = parNode.children || parNode.columns, sourceColumns = children.splice(sourceSubIndex, 1);
    sourceColumns.unshift(targetSubIndex, 0), Array.prototype.splice.apply(children, sourceColumns);
  }
  getCopiedTree() {
    const children = cloneDeep(this.tree.children);
    return clearNode(children), children;
  }
};
function generateLayoutTree(tree, children) {
  null == children || children.forEach((node) => {
    var _a, _b;
    const diemnsonNode = {
      dimensionKey: node.dimensionKey,
      indicatorKey: node.indicatorKey,
      value: node.value,
      hierarchyState: node.hierarchyState,
      children: void 0,
      virtual: null !== (_a = node.virtual) && void 0 !== _a && _a,
      levelSpan: null !== (_b = node.levelSpan) && void 0 !== _b ? _b : 1
    };
    tree.push(diemnsonNode), node.children && (diemnsonNode.children = [], generateLayoutTree(diemnsonNode.children, node.children));
  });
}
function countLayoutTree(children, countParentNode) {
  let count = 0;
  return null == children || children.forEach((node) => {
    countParentNode ? count++ : node.children && 0 !== node.children.length || count++, node.children && (count += countLayoutTree(node.children, countParentNode));
  }), count;
}
function dealHeader(hd, _headerCellIds, results, roots2, row, layoutMap) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  const id = hd.id, dimensionInfo = null !== (_b = null === (_a = layoutMap.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey)) && void 0 !== _b ? _b : null === (_c = layoutMap.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey), indicatorInfo = null === (_d = layoutMap.indicatorsDefine) || void 0 === _d ? void 0 : _d.find((indicator) => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value && !hd.dimensionKey)), cell = {
    id,
    title: null !== (_e = hd.value) && void 0 !== _e ? _e : null == indicatorInfo ? void 0 : indicatorInfo.title,
    field: hd.dimensionKey,
    style: "function" == typeof (null === (_f = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _f ? void 0 : _f.headerStyle) ? null === (_g = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _g ? void 0 : _g.headerStyle : Object.assign({}, null === (_h = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _h ? void 0 : _h.headerStyle),
    headerType: null !== (_k = null !== (_j = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _j ? _j : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _k ? _k : "text",
    headerIcon: null !== (_l = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _l ? _l : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
    define: Object.assign({}, hd, null != indicatorInfo ? indicatorInfo : Object.assign({}, dimensionInfo, {
      sort: void 0
    })),
    fieldFormat: null !== (_m = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _m ? _m : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
    dropDownMenu: null !== (_o = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _o ? _o : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
    pivotInfo: {
      value: hd.value,
      dimensionKey: hd.dimensionKey,
      isPivotCorner: false
    },
    width: null == dimensionInfo ? void 0 : dimensionInfo.width,
    minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
    maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
    showSort: null !== (_p = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _p ? _p : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
    sort: null == indicatorInfo ? void 0 : indicatorInfo.sort,
    description: null == dimensionInfo ? void 0 : dimensionInfo.description
  };
  indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), isValid_default(null === (_q = layoutMap._indicators) || void 0 === _q ? void 0 : _q.find((indicator) => indicator.indicatorKey === indicatorInfo.indicatorKey)) || null === (_r = layoutMap._indicators) || void 0 === _r || _r.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: indicatorInfo.indicatorKey,
    field: indicatorInfo.indicatorKey,
    fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
    cellType: null !== (_t = null !== (_s = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _s ? _s : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _t ? _t : "text",
    chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
    chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
    noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
    sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
    style: null == indicatorInfo ? void 0 : indicatorInfo.style,
    icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
    define: Object.assign({}, hd, indicatorInfo, {
      dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
    }),
    width: null == indicatorInfo ? void 0 : indicatorInfo.width,
    minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
    maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
    disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
  })) : hd.indicatorKey && (isValid_default(null === (_u = layoutMap._indicators) || void 0 === _u ? void 0 : _u.find((indicator) => indicator.indicatorKey === hd.indicatorKey)) || null === (_v = layoutMap._indicators) || void 0 === _v || _v.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: hd.indicatorKey,
    field: hd.indicatorKey,
    cellType: "text",
    define: Object.assign({}, hd)
  })), results[id] = cell, layoutMap._headerObjects[id] = cell;
  for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots2[r];
  if (_headerCellIds[row][layoutMap.colIndex] = id, hd.levelSpan > 1) for (let i = 1; i < hd.levelSpan; i++) {
    if (!_headerCellIds[row + i]) {
      _headerCellIds[row + i] = [];
      for (let col = 0; col < layoutMap.colIndex; col++) _headerCellIds[row + i][col] = _headerCellIds[row][col];
    }
    _headerCellIds[row + i][layoutMap.colIndex] = id;
  }
  if ((null === (_w = hd.children) || void 0 === _w ? void 0 : _w.length) >= 1) layoutMap._addHeaders(_headerCellIds, row + (null !== (_x = hd.levelSpan) && void 0 !== _x ? _x : 1), null !== (_y = hd.children) && void 0 !== _y ? _y : [], [...roots2, ...Array(null !== (_z = hd.levelSpan) && void 0 !== _z ? _z : 1).fill(id)], results);
  else {
    for (let r = row + 1; r < _headerCellIds.length; r++) _headerCellIds[r][layoutMap.colIndex] = id;
    layoutMap.colIndex++;
  }
}
function dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots2, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, indicatorsAsCol, layoutMap) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14;
  const id = hd.id, dimensionInfo = null !== (_b = null === (_a = layoutMap.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey)) && void 0 !== _b ? _b : null === (_c = layoutMap.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey), indicatorInfo = null === (_d = layoutMap.indicatorsDefine) || void 0 === _d ? void 0 : _d.find((indicator) => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value && !hd.dimensionKey)), cell = {
    id,
    title: null !== (_e = hd.value) && void 0 !== _e ? _e : null == indicatorInfo ? void 0 : indicatorInfo.title,
    field: hd.dimensionKey,
    style: "function" == typeof (null === (_f = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _f ? void 0 : _f.headerStyle) ? null === (_g = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _g ? void 0 : _g.headerStyle : Object.assign({}, null === (_h = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _h ? void 0 : _h.headerStyle),
    headerType: null !== (_k = null !== (_j = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _j ? _j : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _k ? _k : "text",
    headerIcon: null !== (_l = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _l ? _l : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
    define: Object.assign(hd, {
      linkJump: null === (_m = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _m ? void 0 : _m.linkJump,
      linkDetect: null === (_o = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _o ? void 0 : _o.linkDetect,
      templateLink: null === (_p = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _p ? void 0 : _p.templateLink,
      keepAspectRatio: null !== (_r = null === (_q = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _q ? void 0 : _q.keepAspectRatio) && void 0 !== _r && _r,
      imageAutoSizing: null === (_s = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _s ? void 0 : _s.imageAutoSizing,
      headerCustomRender: null === (_t = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _t ? void 0 : _t.headerCustomRender,
      headerCustomLayout: null === (_u = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _u ? void 0 : _u.headerCustomLayout,
      dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader,
      disableHeaderHover: !!(null === (_v = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _v ? void 0 : _v.disableHeaderHover),
      disableHeaderSelect: !!(null === (_w = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _w ? void 0 : _w.disableHeaderSelect),
      showSort: null !== (_x = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _x ? _x : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
      hide: null == indicatorInfo ? void 0 : indicatorInfo.hide
    }),
    fieldFormat: null !== (_y = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _y ? _y : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
    dropDownMenu: null !== (_z = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _z ? _z : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
    pivotInfo: {
      value: hd.value,
      dimensionKey: hd.dimensionKey,
      isPivotCorner: false
    },
    hierarchyLevel: hd.level,
    dimensionTotalLevel: totalLevel,
    hierarchyState: hd.hierarchyState,
    width: null == dimensionInfo ? void 0 : dimensionInfo.width,
    minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
    maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
    showSort: null !== (_0 = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _0 ? _0 : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
    sort: null == indicatorInfo ? void 0 : indicatorInfo.sort,
    description: null == dimensionInfo ? void 0 : dimensionInfo.description,
    parentCellId: roots2[roots2.length - 1]
  };
  indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), isValid_default(null === (_1 = layoutMap._indicators) || void 0 === _1 ? void 0 : _1.find((indicator) => indicator.indicatorKey === indicatorInfo.indicatorKey)) || null === (_2 = layoutMap._indicators) || void 0 === _2 || _2.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: indicatorInfo.indicatorKey,
    field: indicatorInfo.indicatorKey,
    fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
    cellType: null !== (_4 = null !== (_3 = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _3 ? _3 : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _4 ? _4 : "text",
    chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
    chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
    noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
    sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
    style: null == indicatorInfo ? void 0 : indicatorInfo.style,
    icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
    define: Object.assign({}, hd, indicatorInfo, {
      dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
    }),
    width: null == indicatorInfo ? void 0 : indicatorInfo.width,
    minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
    maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
    disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
  })) : hd.indicatorKey && (isValid_default(null === (_5 = layoutMap._indicators) || void 0 === _5 ? void 0 : _5.find((indicator) => indicator.indicatorKey === hd.indicatorKey)) || null === (_6 = layoutMap._indicators) || void 0 === _6 || _6.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: hd.indicatorKey,
    field: hd.indicatorKey,
    cellType: "text",
    define: Object.assign({}, hd)
  })), results[id] = cell, layoutMap._headerObjects[id] = cell;
  for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots2[r];
  _headerCellIds[row][layoutMap.colIndex] = id;
  const span = Math.min((isRowTree ? indicatorsAsCol : !indicatorsAsCol) ? expandedMaxLevel : expandedMaxLevel - 1, null !== (_7 = hd.levelSpan) && void 0 !== _7 ? _7 : 1e3);
  if (span > 0) for (let r = row + 1; r < span; r++) {
    if (!_headerCellIds[r]) {
      _headerCellIds[r] = [];
      for (let col = 0; col < layoutMap.colIndex; col++) _headerCellIds[r][col] = _headerCellIds[row][col];
    }
    _headerCellIds[r][layoutMap.colIndex] = id;
  }
  if ((null === (_8 = (hd.hierarchyState === HierarchyState.expand && hd).children) || void 0 === _8 ? void 0 : _8.length) >= 1) layoutMap._addHeadersForGridTreeMode(_headerCellIds, row + (null !== (_9 = hd.levelSpan) && void 0 !== _9 ? _9 : 1), null !== (_10 = hd.children) && void 0 !== _10 ? _10 : [], [...roots2, ...Array(null !== (_11 = hd.levelSpan) && void 0 !== _11 ? _11 : 1).fill(id)], totalLevel, expandedMaxLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results, isRowTree);
  else {
    const needSupplementLength = (isRowTree ? indicatorsAsCol : !indicatorsAsCol) ? expandedMaxLevel : expandedMaxLevel - 1;
    for (let r = row + 1; r < needSupplementLength; r++) _headerCellIds[r] || (_headerCellIds[r] = []), _headerCellIds[r][layoutMap.colIndex] = id;
    if (row <= needSupplementLength - 1 && (isRowTree && false === indicatorsAsCol || !isRowTree && true === indicatorsAsCol)) {
      let lastIndidcatorChildren = hd;
      const levelSpan = needSupplementLength - row;
      for (; lastIndidcatorChildren && !(null === (_12 = lastIndidcatorChildren.children) || void 0 === _12 ? void 0 : _12[0].indicatorKey); ) lastIndidcatorChildren = lastIndidcatorChildren.children[0];
      layoutMap._addHeadersForGridTreeMode(_headerCellIds, expandedMaxLevel - 1, null !== (_13 = lastIndidcatorChildren.children) && void 0 !== _13 ? _13 : [], [...roots2, ...Array(Math.max(levelSpan, null !== (_14 = hd.levelSpan) && void 0 !== _14 ? _14 : 1)).fill(id)], totalLevel, expandedMaxLevel, true, dimensions, results, isRowTree);
    } else layoutMap.colIndex++;
  }
}
function dealHeaderForTreeMode(hd, _headerCellIds, results, roots2, row, totalLevel, show, dimensions, layoutMap) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
  const id = hd.id, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey), indicatorInfo = null === (_a = layoutMap.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator) => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value)), cell = {
    id,
    title: null !== (_b = hd.value) && void 0 !== _b ? _b : indicatorInfo.title,
    field: hd.dimensionKey,
    style: hd.level + 1 === totalLevel || "function" == typeof (null === (_c = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _c ? void 0 : _c.headerStyle) ? null === (_d = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _d ? void 0 : _d.headerStyle : Object.assign({}, null === (_e = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _e ? void 0 : _e.headerStyle, {
      textAlign: "left"
    }),
    headerType: null !== (_g = null !== (_f = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _f ? _f : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _g ? _g : "text",
    headerIcon: null !== (_h = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _h ? _h : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
    define: Object.assign(hd, {
      linkJump: null === (_j = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _j ? void 0 : _j.linkJump,
      linkDetect: null === (_k = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _k ? void 0 : _k.linkDetect,
      templateLink: null === (_l = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _l ? void 0 : _l.templateLink,
      keepAspectRatio: null !== (_o = null === (_m = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _m ? void 0 : _m.keepAspectRatio) && void 0 !== _o && _o,
      imageAutoSizing: null === (_p = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _p ? void 0 : _p.imageAutoSizing,
      headerCustomRender: null === (_q = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _q ? void 0 : _q.headerCustomRender,
      headerCustomLayout: null === (_r = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _r ? void 0 : _r.headerCustomLayout,
      dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader,
      disableHeaderHover: !!(null === (_s = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _s ? void 0 : _s.disableHeaderHover),
      disableHeaderSelect: !!(null === (_t = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _t ? void 0 : _t.disableHeaderSelect),
      showSort: null !== (_u = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _u ? _u : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
      hide: null == indicatorInfo ? void 0 : indicatorInfo.hide
    }),
    fieldFormat: null !== (_v = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _v ? _v : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
    dropDownMenu: null !== (_w = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _w ? _w : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
    pivotInfo: {
      value: hd.value,
      dimensionKey: hd.dimensionKey,
      isPivotCorner: false
    },
    hierarchyLevel: hd.level,
    dimensionTotalLevel: totalLevel,
    hierarchyState: hd.hierarchyState,
    width: null == dimensionInfo ? void 0 : dimensionInfo.width,
    minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
    maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
    parentCellId: roots2[roots2.length - 1]
  };
  indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), isValid_default(null === (_x = layoutMap._indicators) || void 0 === _x ? void 0 : _x.find((indicator) => indicator.indicatorKey === indicatorInfo.indicatorKey)) || null === (_y = layoutMap._indicators) || void 0 === _y || _y.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: indicatorInfo.indicatorKey,
    field: indicatorInfo.indicatorKey,
    fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
    cellType: null !== (_0 = null !== (_z = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _z ? _z : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _0 ? _0 : "text",
    chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
    chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
    noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
    sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
    style: null == indicatorInfo ? void 0 : indicatorInfo.style,
    icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
    define: Object.assign({}, hd, indicatorInfo, {
      dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
    }),
    width: null == indicatorInfo ? void 0 : indicatorInfo.width,
    minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
    maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
    disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
  })) : hd.indicatorKey && (isValid_default(null === (_1 = layoutMap._indicators) || void 0 === _1 ? void 0 : _1.find((indicator) => indicator.indicatorKey === hd.indicatorKey)) || null === (_2 = layoutMap._indicators) || void 0 === _2 || _2.push({
    id: ++layoutMap.sharedVar.seqId,
    indicatorKey: hd.indicatorKey,
    field: hd.indicatorKey,
    cellType: "text",
    define: Object.assign({}, hd)
  })), results[id] = cell, layoutMap._headerObjects[id] = cell, _headerCellIds[row][layoutMap.colIndex] = id;
  for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots2[r];
  if (hd.hierarchyState === HierarchyState.expand && (null === (_3 = hd.children) || void 0 === _3 ? void 0 : _3.length) >= 1) show && layoutMap.colIndex++, layoutMap._addHeadersForTreeMode(_headerCellIds, row, null !== (_4 = hd.children) && void 0 !== _4 ? _4 : [], [...roots2, id], totalLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results);
  else {
    show && layoutMap.colIndex++;
    for (let r = row + 1; r < _headerCellIds.length; r++) _headerCellIds[r][layoutMap.colIndex] = id;
  }
}
function clearNode(children) {
  for (let i = 0; i < children.length; i++) {
    const node = children[i];
    delete node.level, delete node.startIndex, delete node.id, delete node.levelSpan, delete node.size, delete node.startInTotal;
    const childrenNew = node.children || node.columns;
    childrenNew && clearNode(childrenNew);
  }
}
function deleteTreeHideNode(tree_children, dimensionPath, indicators, hasHideNode, table) {
  var _a;
  for (let i = tree_children.length - 1; i >= 0; i--) {
    const node = tree_children[i];
    if (dimensionPath.push(node), hasHideNode && node.hide) tree_children.splice(i, 1);
    else if (node.indicatorKey) {
      const hide = null === (_a = null == indicators ? void 0 : indicators.find((indicator) => indicator.indicatorKey === node.indicatorKey)) || void 0 === _a ? void 0 : _a.hide;
      "function" == typeof hide ? hide({
        dimensionPaths: dimensionPath,
        table
      }) && tree_children.splice(i, 1) : hide && tree_children.splice(i, 1);
    } else node.children && node.children.length > 0 && deleteTreeHideNode(node.children, dimensionPath, indicators, hasHideNode, table);
    dimensionPath.pop();
  }
}

// node_modules/@visactor/vtable/es/layout/layout-helper.js
function checkHasAggregation(layoutMap) {
  const columnObjects = layoutMap.columnObjects;
  for (let i = 0; i < columnObjects.length; i++) {
    const column = columnObjects[i];
    if (null == column ? void 0 : column.aggregation) return true;
  }
  return false;
}
function checkHasAggregationOnTop(layoutMap) {
  const columnObjects = layoutMap.columnObjects;
  let count = 0;
  for (let i = 0; i < columnObjects.length; i++) {
    const column = columnObjects[i];
    (null == column ? void 0 : column.aggregation) && (Array.isArray(null == column ? void 0 : column.aggregation) ? count = Math.max(count, column.aggregation.filter((item) => item.showOnTop).length) : column.aggregation.showOnTop && (count = Math.max(count, 1)));
  }
  return count;
}
function checkHasAggregationOnBottom(layoutMap) {
  const columnObjects = layoutMap.columnObjects;
  let count = 0;
  for (let i = 0; i < columnObjects.length; i++) {
    const column = columnObjects[i];
    (null == column ? void 0 : column.aggregation) && (Array.isArray(null == column ? void 0 : column.aggregation) ? count = Math.max(count, column.aggregation.filter((item) => !item.showOnTop).length) : column.aggregation.showOnTop || (count = Math.max(count, 1)));
  }
  return count;
}
function checkHasTreeDefine(layoutMap) {
  if (layoutMap._table.options.groupBy) return true;
  const { columns } = layoutMap._table.options;
  if (isArray_default(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    if (!isString_default(column) && column.tree) return true;
  }
  return false;
}
function hasAutoImageColumn(table) {
  const { columns, rows, indicators } = table.options;
  if (table.isPivotTable()) {
    if (isArray_default(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
      const column = columns[i];
      if (!isString_default(column) && (("image" === column.headerType || "video" === column.headerType || "function" == typeof column.headerType) && column.imageAutoSizing)) return true;
    }
    if (isArray_default(rows) && rows.length > 0) for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!isString_default(row) && (("image" === row.headerType || "video" === row.headerType || "function" == typeof row.headerType) && row.imageAutoSizing)) return true;
    }
    if (isArray_default(indicators) && indicators.length > 0) for (let i = 0; i < indicators.length; i++) {
      const indicator = indicators[i];
      if (!isString_default(indicator) && (("image" === indicator.cellType || "video" === indicator.cellType || "function" == typeof indicator.cellType) && indicator.imageAutoSizing || ("image" === indicator.headerType || "video" === indicator.headerType || "function" == typeof indicator.headerType) && indicator.imageAutoSizing)) return true;
    }
  } else if (isArray_default(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    if (("image" === column.cellType || "video" === column.cellType || "function" == typeof column.cellType) && column.imageAutoSizing || ("image" === column.headerType || "video" === column.headerType || "function" == typeof column.headerType) && column.imageAutoSizing) return true;
  }
  return false;
}
function parseColKeyRowKeyForPivotTable(table, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  let columnDimensionTree, rowDimensionTree;
  options.columnTree && (false !== table.options.indicatorsAsCol && false !== table.options.supplementIndicatorNodes && (table.internalProps.columnTree = supplementIndicatorNodesForCustomTree(table.internalProps.columnTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_a = table.internalProps.columnTree) && void 0 !== _a ? _a : [], table.layoutNodeId, table.options.columnHierarchyType, "grid" !== table.options.columnHierarchyType ? null !== (_b = table.options.columnExpandLevel) && void 0 !== _b ? _b : 1 : void 0)), options.rowTree && (false === table.options.indicatorsAsCol && false !== table.options.supplementIndicatorNodes && (table.internalProps.rowTree = supplementIndicatorNodesForCustomTree(table.internalProps.rowTree, options.indicators)), rowDimensionTree = new DimensionTree(null !== (_c = table.internalProps.rowTree) && void 0 !== _c ? _c : [], table.layoutNodeId, table.options.rowHierarchyType, "grid" !== table.options.rowHierarchyType ? null !== (_d = table.options.rowExpandLevel) && void 0 !== _d ? _d : 1 : void 0));
  const rowKeys = (null === (_e = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _e ? void 0 : _e.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_g = null === (_f = options.rows) || void 0 === _f ? void 0 : _f.reduce((keys2, rowObj) => ("string" == typeof rowObj ? keys2.push(rowObj) : keys2.push(rowObj.dimensionKey), keys2), [])) && void 0 !== _g ? _g : [], columnKeys = (null === (_h = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _h ? void 0 : _h.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_k = null === (_j = options.columns) || void 0 === _j ? void 0 : _j.reduce((keys2, columnObj) => ("string" == typeof columnObj ? keys2.push(columnObj) : keys2.push(columnObj.dimensionKey), keys2), [])) && void 0 !== _k ? _k : [], indicatorKeys = null !== (_m = null === (_l = options.indicators) || void 0 === _l ? void 0 : _l.reduce((keys2, indicatorObj) => {
    var _a2;
    return "string" == typeof indicatorObj ? keys2.push(indicatorObj) : (keys2.push(indicatorObj.indicatorKey), (indicatorObj.chartSpec || indicatorObj.sparklineSpec) && ((null === (_a2 = table.internalProps.dataConfig) || void 0 === _a2 ? void 0 : _a2.aggregationRules) ? table.internalProps.dataConfig.aggregationRules.find((aggregation) => aggregation.indicatorKey === indicatorObj.indicatorKey) || table.internalProps.dataConfig.aggregationRules.push({
      field: indicatorObj.indicatorKey,
      indicatorKey: indicatorObj.indicatorKey,
      aggregationType: AggregationType.NONE
    }) : table.internalProps.dataConfig ? table.internalProps.dataConfig.aggregationRules = [{
      field: indicatorObj.indicatorKey,
      indicatorKey: indicatorObj.indicatorKey,
      aggregationType: AggregationType.NONE
    }] : table.internalProps.dataConfig = {
      aggregationRules: [{
        field: indicatorObj.indicatorKey,
        indicatorKey: indicatorObj.indicatorKey,
        aggregationType: AggregationType.NONE
      }]
    })), keys2;
  }, [])) && void 0 !== _m ? _m : [];
  return "grid" !== options.rowHierarchyType && (null !== (_p = null === (_o = options.extensionRows) || void 0 === _o ? void 0 : _o.length) && void 0 !== _p ? _p : 0) >= 1 && (null === (_q = options.extensionRows) || void 0 === _q || _q.forEach((extensionRow) => {
    const extension_rowKeys = [];
    extensionRow.rows.forEach((row) => {
      "string" == typeof row ? extension_rowKeys.push(row) : extension_rowKeys.push(row.dimensionKey);
    }), rowKeys.push(...extension_rowKeys);
  })), {
    rowKeys,
    columnKeys,
    indicatorKeys,
    columnDimensionTree,
    rowDimensionTree
  };
}
function supplementIndicatorNodesForCustomTree(customTree, indicators) {
  const checkNode = (nodes, isHasIndicator) => {
    nodes.forEach((node) => {
      var _a;
      node.indicatorKey || isHasIndicator || (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && node.children ? node.children && Array.isArray(node.children) && checkNode(node.children, isHasIndicator || !!node.indicatorKey) : node.children = null == indicators ? void 0 : indicators.map((indicator) => {
        var _a2;
        return "string" == typeof indicator ? {
          indicatorKey: indicator,
          value: indicator
        } : {
          indicatorKey: indicator.indicatorKey,
          value: null !== (_a2 = indicator.title) && void 0 !== _a2 ? _a2 : indicator.indicatorKey
        };
      });
    });
  };
  return (null == customTree ? void 0 : customTree.length) ? checkNode(customTree, false) : customTree = null == indicators ? void 0 : indicators.map((indicator) => {
    var _a;
    return "string" == typeof indicator ? {
      indicatorKey: indicator,
      value: indicator
    } : {
      indicatorKey: indicator.indicatorKey,
      value: null !== (_a = indicator.title) && void 0 !== _a ? _a : indicator.indicatorKey
    };
  }), customTree;
}
function deleteHideIndicatorNode(treeNodeChildren, indicators, hasHideNode, table) {
  const hasHideSettingIndicators = [];
  for (let i = 0; i < (null == indicators ? void 0 : indicators.length); i++) {
    const indicator = indicators[i];
    (null == indicator ? void 0 : indicator.hide) && hasHideSettingIndicators.push(indicator);
  }
  (hasHideSettingIndicators.length || hasHideNode) && deleteTreeHideNode(treeNodeChildren, [], hasHideSettingIndicators, hasHideNode, table);
}

// node_modules/@visactor/vtable/es/core/utils/get-cell-position.js
function getRowAt(absoluteY, _this) {
  var _a;
  const frozen = _getTargetFrozenRowAt(_this, absoluteY);
  return frozen || (null !== (_a = getTargetRowAt(absoluteY, _this)) && void 0 !== _a ? _a : {
    top: -1,
    row: -1,
    bottom: -1,
    height: -1
  });
}
function getColAt(absoluteX, _this) {
  var _a;
  const frozen = _getTargetFrozenColAt(_this, absoluteX);
  return frozen || (null !== (_a = getTargetColAt(absoluteX, _this)) && void 0 !== _a ? _a : {
    left: -1,
    col: -1,
    right: -1,
    width: 1
  });
}
function getCellAt(absoluteX, absoluteY, _this) {
  const rowInfo = getRowAt(absoluteY, _this), { row, top, bottom, height } = rowInfo, colInfo = getColAt(absoluteX, _this), { col, left, right, width } = colInfo;
  return {
    row,
    col,
    rect: {
      left,
      right,
      top,
      bottom,
      width,
      height
    }
  };
}
function getTargetColAt(absoluteX, _this) {
  if (0 === absoluteX) return {
    left: 0,
    col: 0,
    right: 0,
    width: 0
  };
  const candCol = computeTargetColByX(absoluteX, _this), right = _this.getColsWidth(0, candCol);
  return absoluteX >= right ? ((startCol, startRight) => {
    let left = startRight - _this.getColWidth(startCol);
    const { colCount } = _this.internalProps;
    for (let col = startCol; col < colCount; col++) {
      const width = _this.getColWidth(col), right2 = left + width;
      if (Math.round(left) <= Math.round(absoluteX) && Math.round(absoluteX) < Math.round(right2)) return {
        left,
        col,
        right: right2,
        width
      };
      left = right2;
    }
    return null;
  })(candCol, right) : ((startCol, startRight) => {
    let right2 = startRight;
    for (let col = startCol; col >= 0; col--) {
      const width = _this.getColWidth(col), left = right2 - width;
      if (Math.round(left) <= Math.round(absoluteX) && Math.round(absoluteX) < Math.round(right2)) return {
        left,
        col,
        right: right2,
        width
      };
      right2 = left;
    }
    return null;
  })(candCol, right);
}
function getTargetRowAt(absoluteY, _this) {
  var _a;
  if (0 === absoluteY) return {
    top: 0,
    row: 0,
    bottom: 0,
    height: 0
  };
  const floorOrRound = true === (null === (_a = _this.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? Math.floor : Math.round, candRow = computeTargetRowByY(absoluteY, _this), bottom = _this.getRowsHeight(0, candRow);
  return absoluteY >= bottom ? ((startRow, startBottom) => {
    let top = startBottom - _this.getRowHeight(startRow);
    const { rowCount } = _this.internalProps;
    for (let row = startRow; row < rowCount; row++) {
      const height = _this.getRowHeight(row), bottom2 = top + height;
      if (floorOrRound(top) <= floorOrRound(absoluteY) && floorOrRound(absoluteY) < floorOrRound(bottom2)) return {
        top,
        row,
        bottom: bottom2,
        height
      };
      top = bottom2;
    }
    return null;
  })(candRow, bottom) : ((startRow, startBottom) => {
    let bottom2 = startBottom;
    for (let row = startRow; row >= 0; row--) {
      const height = _this.getRowHeight(row), top = bottom2 - height;
      if (floorOrRound(top) <= floorOrRound(absoluteY) && floorOrRound(absoluteY) < floorOrRound(bottom2)) return {
        top,
        row,
        bottom: bottom2,
        height
      };
      bottom2 = top;
    }
    return null;
  })(candRow, bottom);
}
function getTargetColAtConsiderRightFrozen(absoluteX, isConsider, _this) {
  if (0 === absoluteX) return {
    left: 0,
    col: 0,
    right: 0,
    width: 0
  };
  if (absoluteX -= _this.tableX, isConsider && absoluteX > _this.tableNoFrameWidth - _this.getRightFrozenColsWidth() && absoluteX < _this.tableNoFrameWidth && absoluteX <= _this.getAllColsWidth()) {
    for (let i = 0; i < _this.rightFrozenColCount; i++) if (absoluteX > _this.tableNoFrameWidth - _this.getColsWidth(_this.colCount - i - 1, _this.colCount - 1)) return {
      col: _this.colCount - i - 1,
      left: void 0,
      right: void 0,
      width: void 0
    };
  }
  return getTargetColAt(absoluteX, _this);
}
function getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider, _this) {
  if (0 === absoluteY) return {
    top: 0,
    row: 0,
    bottom: 0,
    height: 0
  };
  if (absoluteY -= _this.tableY, isConsider && absoluteY > _this.tableNoFrameHeight - _this.getBottomFrozenRowsHeight() && absoluteY < _this.tableNoFrameHeight) {
    for (let i = 0; i < _this.rightFrozenColCount; i++) if (absoluteY > _this.tableNoFrameHeight - _this.getRowsHeight(_this.rowCount - i - 1, _this.rowCount - 1)) return {
      row: _this.rowCount - i - 1,
      top: void 0,
      bottom: void 0,
      height: void 0
    };
  }
  return getTargetRowAt(absoluteY, _this);
}
function computeTargetRowByY(absoluteY, _this) {
  let defaultRowHeight = _this.defaultRowHeight;
  return _this._rowRangeHeightsMap.get("$0$" + (_this.rowCount - 1)) && (defaultRowHeight = _this._rowRangeHeightsMap.get("$0$" + (_this.rowCount - 1)) / _this.rowCount), Math.min(Math.ceil(absoluteY / defaultRowHeight), _this.rowCount - 1);
}
function computeTargetColByX(absoluteX, _this) {
  if (_this._colRangeWidthsMap.get("$0$" + (_this.colCount - 1))) {
    let startCol = 0, endCol = _this.colCount - 1;
    for (; endCol - startCol > 1; ) {
      const midCol = Math.floor((startCol + endCol) / 2);
      if (absoluteX < _this._colRangeWidthsMap.get(`$0$${midCol}`)) endCol = midCol;
      else {
        if (!(absoluteX > _this._colRangeWidthsMap.get(`$0$${midCol}`))) return midCol;
        startCol = midCol;
      }
    }
    return endCol;
  }
  return Math.min(Math.ceil(absoluteX / _this.internalProps.defaultColWidth), _this.colCount - 1);
}
function getCellAtRelativePosition(x, y, _this) {
  x -= _this.tableX;
  let topFrozen = false;
  (y -= _this.tableY) > 0 && y < _this.getFrozenRowsHeight() && (topFrozen = true);
  let leftFrozen = false;
  x > 0 && x < _this.getFrozenColsWidth() && (leftFrozen = true);
  let bottomFrozen = false;
  y > _this.tableNoFrameHeight - _this.getBottomFrozenRowsHeight() && y < _this.tableNoFrameHeight && y <= _this.getAllRowsHeight() && (bottomFrozen = true);
  let rightFrozen = false;
  x > _this.tableNoFrameWidth - _this.getRightFrozenColsWidth() && x < _this.tableNoFrameWidth && x <= _this.getAllColsWidth() && (rightFrozen = true);
  const colInfo = getTargetColAtConsiderRightFrozen((leftFrozen || rightFrozen ? x : x + _this.scrollLeft) + _this.tableX, rightFrozen, _this), rowInfo = getTargetRowAtConsiderBottomFrozen((topFrozen || bottomFrozen ? y : y + _this.scrollTop) + _this.tableY, bottomFrozen, _this);
  if (colInfo && rowInfo) {
    const { row, top, bottom, height } = rowInfo, { col, left, right, width } = colInfo;
    return {
      row,
      col,
      rect: {
        left,
        right,
        top,
        bottom,
        width,
        height
      }
    };
  }
  return {
    col: -1,
    row: -1
  };
}

// node_modules/@visactor/vtable/es/layout/chart-helper/zero-align.js
function isValidAlignDomain(domain) {
  return 2 === domain.length && isValidNumber_default(domain[0]) && isValidNumber_default(domain[1]) && domain[1] >= domain[0];
}
function getScaleInfo(domain) {
  const total = domain[1] - domain[0], includeZero = domain[1] * domain[0] < 0;
  let negative = domain[0] <= 0 ? 0 - domain[0] : 0, positive = domain[1] > 0 ? domain[1] - 0 : 0;
  return 0 === total ? domain[0] < 0 ? (negative = 1, positive = 0) : domain[0] > 0 && (negative = 0, positive = 1) : (negative /= total, positive /= total), {
    total,
    negative,
    positive,
    includeZero,
    domain,
    extendable_min: true,
    extendable_max: true
  };
}
function inDifferentCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, domain: domain2 } = info2;
  if (positive2 > 0) {
    if (!s2Extendable_min) return false;
    let comp = negative1 / positive1;
    s1Extendable_max && (comp = negative1 / Math.max(positive1, positive2), domain1[1] = -domain1[0] / comp), domain2[0] = -domain2[1] * comp;
  } else if (negative2 > 0) {
    if (!s2Extendable_max) return false;
    let comp = positive1 / negative1;
    s1Extendable_min && (comp = positive1 / Math.max(negative1, negative1), domain1[0] = -domain1[1] / comp), domain2[1] = -domain2[0] * comp;
  }
  return true;
}
function inOnlyZeroDomain(info1, info2) {
  const { extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, domain: domain2 } = info2;
  return (0 !== positive2 || 0 !== negative2) && (!(positive2 > 0 && !s1Extendable_max) && (!(negative2 > 0 && !s1Extendable_min) && (domain1[0] = domain2[0], domain1[1] = domain2[1], true)));
}
function inAllCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, domain: domain2 } = info2;
  if (s1Extendable_max && s2Extendable_min) {
    const comp = Math.max(negative1, negative2) / Math.max(positive1, positive2);
    domain1[1] = -domain1[0] / comp, domain2[0] = -domain2[1] * comp;
  } else if (s2Extendable_min) {
    const comp = negative1 / positive1;
    domain2[0] = -domain2[1] * comp;
  } else {
    if (!s1Extendable_max) return false;
    {
      const comp = negative2 / positive2;
      domain1[1] = -domain1[0] / comp;
    }
  }
  return true;
}
function inNoCrossDifferentSide(info1, info2) {
  const { extendable_min: s1Extendable_min, domain: domain1 } = info1, { extendable_max: s2Extendable_max, domain: domain2 } = info2;
  return !(!s1Extendable_min || !s2Extendable_max) && (domain1[0] = -domain1[1], domain2[1] = -domain2[0], true);
}
function getNewRangeToAlign(range1, range22) {
  const domain1 = [range1.min, range1.max], domain2 = [range22.min, range22.max];
  if (!isValidAlignDomain(domain1) || !isValidAlignDomain(domain2)) return;
  const info1 = getScaleInfo(domain1), info2 = getScaleInfo(domain2), { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, includeZero: includeZero1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, includeZero: includeZero2 } = info2;
  if (0 === positive1 && 0 === negative1) {
    if (!inOnlyZeroDomain(info1, info2)) return;
  } else if (0 === positive2 && 0 === negative2) {
    if (!inOnlyZeroDomain(info2, info1)) return;
  } else if (includeZero1 || includeZero2) if (includeZero1 && !includeZero2) {
    if (!inDifferentCrossZero(info1, info2)) return;
  } else if (includeZero2 && !includeZero1) {
    if (!inDifferentCrossZero(info2, info1)) return;
  } else {
    if (negative1 === negative2) return;
    if (negative1 > negative2) {
      if (!inAllCrossZero(info1, info2)) return;
    } else if (!inAllCrossZero(info2, info1)) return;
  }
  else {
    if (0 === negative1 && 0 === positive2) {
      if (!inNoCrossDifferentSide(info1, info2)) return;
    } else if (0 === negative2 && 0 === positive1 && !inNoCrossDifferentSide(info2, info1)) return;
    if (0 === negative1 && 0 === negative2) if (0 === domain1[0] && domain2[0] > 0) {
      if (!s2Extendable_min) return;
      domain2[0] = 0;
    } else {
      if (!(0 === domain2[0] && domain1[0] > 0)) return;
      if (!s1Extendable_min) return;
      domain1[0] = 0;
    }
    if (0 === positive1 && 0 === positive2) if (0 === domain1[1] && domain2[1] > 0) {
      if (!s2Extendable_max) return;
      domain2[1] = 0;
    } else {
      if (!(0 === domain2[1] && domain1[1] > 0)) return;
      if (!s1Extendable_max) return;
      domain1[1] = 0;
    }
  }
  return {
    range1: domain1,
    range2: domain2
  };
}

// node_modules/@visactor/vtable/es/layout/chart-helper/tick-align.js
function getZeroAlignTickAlignTicks(targetRange, col, row, index, position, layout) {
  const getAxisDomainRangeAndLabels2 = Factory2.getFunction("getAxisDomainRangeAndLabels"), { axisOption, isZeroAlign } = getAxisOption(col, row, 0 === index ? "right" : "left", layout), { ticks: ticks6 } = getAxisDomainRangeAndLabels2(targetRange.min, targetRange.max, axisOption, isZeroAlign, "bottom" === position || "top" === position ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight);
  return ticks6;
}
function getTickModeFunction(targetTicks, targetRange, range5, indicatorIndex) {
  return 0 !== indicatorIndex && targetTicks ? () => targetTicks.map((value) => {
    const percent = (value - targetRange.min) / (targetRange.max - targetRange.min), tick = (range5.max - range5.min) * percent + range5.min;
    return Math.round(100 * tick) / 100;
  }) : void 0;
}

// node_modules/@visactor/vtable/es/layout/chart-helper/get-axis-config.js
function getAxisConfigInPivotChart(col, row, layout) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (layout._table.isPivotChart()) if (layout.indicatorsAsCol) {
    if (layout.hasTwoIndicatorAxes && row === layout.columnHeaderLevelCount - 1 && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) {
      const axisRange = getRange("top", col, row + 1, col, layout.columnHeaderLevelCount - 1, col, row, 1, layout);
      if (!axisRange) return;
      const chartCellStyle = layout._table._getCellStyle(col, row + 1), padding = getQuadProps(getProp2("padding", chartCellStyle, col, row + 1, layout._table)), { range: range5, ticks: ticks6, axisOption, targetTicks, targetRange, index, theme: theme4 } = axisRange;
      return isNumber_default(null == axisOption ? void 0 : axisOption.min) && (range5.min = axisOption.min, range5.min > 0 && (axisOption.zero = false)), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (range5.max = axisOption.max, range5.max < 0 && (axisOption.zero = false)), merge({
        range: range5
      }, axisOption, {
        orient: "top",
        type: (null == axisOption ? void 0 : axisOption.type) || "linear",
        label: {
          flush: true
        },
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        __ticksForVTable: ticks6,
        __vtableChartTheme: theme4,
        __vtablePadding: padding
      });
    }
    if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) {
      const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
      let indicatorInfo = null;
      null == indicatorKeys || indicatorKeys.forEach((key) => {
        const info = layout.getIndicatorInfo(key);
        info && (indicatorInfo = info);
      });
      const axisRange = getRange("bottom", col, row - 1, col, row, col, row, 0, layout);
      if (!axisRange) return;
      const chartCellStyle = layout._table._getCellStyle(col, row - 1), padding = getQuadProps(getProp2("padding", chartCellStyle, col, row - 1, layout._table)), { range: range5, ticks: ticks6, axisOption, index, targetTicks, targetRange, theme: theme4 } = axisRange;
      return isNumber_default(null == axisOption ? void 0 : axisOption.min) && (range5.min = axisOption.min, range5.min > 0 && (axisOption.zero = false)), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (range5.max = axisOption.max, range5.max < 0 && (axisOption.zero = false)), merge({
        title: {
          visible: true,
          text: null == indicatorInfo ? void 0 : indicatorInfo.title
        },
        range: range5
      }, axisOption, {
        orient: "bottom",
        type: (null == axisOption ? void 0 : axisOption.type) || "linear",
        label: {
          flush: true
        },
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        __ticksForVTable: ticks6,
        __vtableChartTheme: theme4,
        __vtablePadding: padding
      });
    }
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) {
      let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
      isArray_default(rowDimensionKey) && (rowDimensionKey = rowDimensionKey[0]);
      const data = null !== (_a = layout.dataset.collectedValues[rowDimensionKey]) && void 0 !== _a ? _a : [], rowPath = layout.getRowKeysPath(col, row), domain = null !== (_b = data[null != rowPath ? rowPath : ""]) && void 0 !== _b ? _b : [], { axisOption, theme: theme4, chartType } = getAxisOption(col + 1, row, "left", layout);
      if (false === (null == axisOption ? void 0 : axisOption.visible)) return;
      const chartCellStyle = layout._table._getCellStyle(col + 1, row), padding = getQuadProps(getProp2("padding", chartCellStyle, col + 1, row, layout._table)), spec = layout.getRawChartSpec(col + 1, row);
      return merge({
        domain: "linear" === (null == axisOption ? void 0 : axisOption.type) ? void 0 : Array.from(domain),
        range: "linear" === (null == axisOption ? void 0 : axisOption.type) ? domain : void 0,
        title: {
          autoRotate: true
        }
      }, axisOption, {
        orient: "left",
        type: null !== (_c = null == axisOption ? void 0 : axisOption.type) && void 0 !== _c ? _c : "band",
        __vtableChartTheme: theme4,
        inverse: transformInverse(axisOption, "horizontal" === (null !== (_d = null == spec ? void 0 : spec.direction) && void 0 !== _d ? _d : "scatter" === chartType ? "vertical" : "horizontal")),
        __vtablePadding: padding
      });
    }
  } else {
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) {
      const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
      let indicatorInfo = null;
      null == indicatorKeys || indicatorKeys.forEach((key) => {
        const info = layout.getIndicatorInfo(key);
        info && (indicatorInfo = info);
      });
      const axisRange = getRange("left", col + 1, row, col, row, col, row, 0, layout);
      if (!axisRange) return;
      const chartCellStyle = layout._table._getCellStyle(col + 1, row), padding = getQuadProps(getProp2("padding", chartCellStyle, col + 1, row, layout._table)), { range: range5, ticks: ticks6, axisOption, index, targetTicks, targetRange, theme: theme4 } = axisRange;
      return isNumber_default(null == axisOption ? void 0 : axisOption.min) && (range5.min = axisOption.min, range5.min > 0 && (axisOption.zero = false)), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (range5.max = axisOption.max, range5.max < 0 && (axisOption.zero = false)), merge({
        title: {
          visible: true,
          text: null == indicatorInfo ? void 0 : indicatorInfo.title,
          autoRotate: true
        },
        range: range5
      }, axisOption, {
        orient: "left",
        type: (null == axisOption ? void 0 : axisOption.type) || "linear",
        label: {
          flush: true
        },
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        __ticksForVTable: ticks6,
        __vtableChartTheme: theme4,
        __vtablePadding: padding
      });
    }
    if (col === layout.colCount - layout.rightFrozenColCount && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) {
      const axisRange = getRange("right", col - 1, row, layout.rowHeaderLevelCount - 1, row, col, row, 1, layout);
      if (!axisRange) return;
      const chartCellStyle = layout._table._getCellStyle(col - 1, row), padding = getQuadProps(getProp2("padding", chartCellStyle, col - 1, row, layout._table)), { range: range5, ticks: ticks6, axisOption, index, targetTicks, targetRange, theme: theme4 } = axisRange;
      return isNumber_default(null == axisOption ? void 0 : axisOption.min) && (range5.min = axisOption.min, range5.min > 0 && (axisOption.zero = false)), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (range5.max = axisOption.max, range5.max < 0 && (axisOption.zero = false)), merge({
        range: range5,
        title: {
          autoRotate: true
        }
      }, axisOption, {
        orient: "right",
        type: (null == axisOption ? void 0 : axisOption.type) || "linear",
        label: {
          flush: true
        },
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        __ticksForVTable: ticks6,
        __vtableChartTheme: theme4,
        __vtablePadding: padding
      });
    }
    if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) {
      let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
      isArray_default(columnDimensionKey) && (columnDimensionKey = columnDimensionKey[0]);
      const data = null !== (_e = layout.dataset.collectedValues[columnDimensionKey]) && void 0 !== _e ? _e : [], colPath = layout.getColKeysPath(col, row), domain = null !== (_f = null == data ? void 0 : data[null != colPath ? colPath : ""]) && void 0 !== _f ? _f : [], { axisOption, isPercent: isPercent2, theme: theme4, chartType } = getAxisOption(col, row - 1, "bottom", layout);
      if (false === (null == axisOption ? void 0 : axisOption.visible)) return;
      const chartCellStyle = layout._table._getCellStyle(col, row - 1), padding = getQuadProps(getProp2("padding", chartCellStyle, col, row - 1, layout._table));
      return merge({
        domain: "linear" === (null == axisOption ? void 0 : axisOption.type) ? void 0 : Array.from(domain),
        range: "linear" === (null == axisOption ? void 0 : axisOption.type) ? domain : void 0
      }, axisOption, {
        orient: "bottom",
        type: null !== (_g = null == axisOption ? void 0 : axisOption.type) && void 0 !== _g ? _g : "band",
        __vtableChartTheme: theme4,
        __vtablePadding: padding
      });
    }
  }
}
function getAxisOption(col, row, orient, layout) {
  var _a, _b;
  const spec = layout.getRawChartSpec(col, row), axes = null !== (_a = spec.axes) && void 0 !== _a ? _a : [];
  if (layout._table.pivotChartAxes.forEach((axis) => {
    -1 === axes.findIndex((a2) => axis.orient === a2.orient) && axes.push(axis);
  }), spec && isArray_default(axes)) {
    const axisOption2 = axes.find((axis) => axis.orient === orient);
    if (axisOption2) {
      const { seriesIndex, seriesId } = axisOption2;
      let seriesIndice, seriesSpec;
      isValid_default(seriesId) && isArray_default(spec.series) ? seriesIndice = (isArray_default(seriesId) ? seriesId : [seriesId]).map((id) => {
        const index = spec.series.findIndex((s2) => s2.id === id);
        return index >= 0 && (seriesSpec = spec.series[index]), index;
      }) : isValid_default(seriesIndex) && isArray_default(spec.series) && (seriesIndice = seriesIndex);
      const { isZeroAlign: isZeroAlign2, isTickAlign: isTickAlign2 } = checkZeroAlign(spec, orient, layout);
      return {
        axisOption: axisOption2,
        isPercent: spec.percent,
        isZeroAlign: isZeroAlign2,
        isTickAlign: isTickAlign2,
        seriesIndice,
        theme: spec.theme,
        chartType: null !== (_b = null == seriesSpec ? void 0 : seriesSpec.type) && void 0 !== _b ? _b : spec.type
      };
    }
  }
  const axisOption = layout._table.pivotChartAxes.find((axisOption2) => axisOption2.orient === orient), { isZeroAlign, isTickAlign } = checkZeroAlign(spec, orient, layout);
  return {
    axisOption,
    isPercent: false,
    isZeroAlign,
    isTickAlign,
    theme: spec.theme,
    chartType: spec.type
  };
}
function checkZeroAlign(spec, orient, layout) {
  const orients = [];
  let axesSpec;
  "left" === orient || "right" === orient ? orients.push("left", "right") : "top" !== orient && "bottom" !== orient || orients.push("top", "bottom"), axesSpec = spec && isArray_default(spec.axes) ? spec.axes : layout._table.pivotChartAxes;
  let isZeroAlign = false, isTickAlign = false;
  if (isArray_default(axesSpec)) {
    const axes = [];
    axesSpec.forEach((axis) => {
      orients.includes(axis.orient) && axes.push(axis);
    });
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      axis.sync && axis.sync.axisId && axes.find((axisSync) => axisSync.id === axis.sync.axisId) && (isZeroAlign = isZeroAlign || axis.sync.zeroAlign, isTickAlign = isTickAlign || axis.sync.tickAlign);
    }
  }
  return {
    isZeroAlign,
    isTickAlign
  };
}
function getAxisRange(collectedValues, indicatorKeys, isZeroAlign, colPath, seriesId) {
  var _a;
  if (isArray_default(seriesId)) {
    const range6 = {
      min: 1 / 0,
      max: -1 / 0
    };
    for (let i = 0; i < seriesId.length; i++) {
      const singleRange = getAxisRange(collectedValues, indicatorKeys, isZeroAlign, colPath, seriesId[i]);
      singleRange && (range6.min = Math.min(range6.min, singleRange.min), range6.max = Math.max(range6.max, singleRange.max));
    }
    return isFinite(range6.min) && isFinite(range6.max) ? range6 : null;
  }
  let defaultKey = null == indicatorKeys ? void 0 : indicatorKeys[seriesId];
  if (isArray_default(defaultKey) && (defaultKey = defaultKey[0]), !defaultKey) return null;
  const data = collectedValues[defaultKey], range5 = merge({}, null !== (_a = null == data ? void 0 : data[null != colPath ? colPath : ""]) && void 0 !== _a ? _a : {
    min: 0,
    max: 1
  });
  return range5.positiveMax && range5.positiveMax > range5.max && (range5.max = range5.positiveMax), range5.negativeMin && range5.negativeMin < range5.min && (range5.min = range5.negativeMin), range5.min === range5.max && (range5.min > 0 ? range5.min = 0 : range5.max = 0), range5;
}
function isTopOrBottomAxis(col, row, layout) {
  if (!layout._table.isPivotChart()) return false;
  if (layout.indicatorsAsCol) {
    if (layout.hasTwoIndicatorAxes && row === layout.columnHeaderLevelCount - 1 && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return true;
    if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return true;
  } else if (row === layout.rowCount - layout.bottomFrozenRowCount && col >= layout.rowHeaderLevelCount && col < layout.colCount - layout.rightFrozenColCount) return true;
  return false;
}
function isLeftOrRightAxis(col, row, layout) {
  if (!layout._table.isPivotChart()) return false;
  if (layout.indicatorsAsCol) {
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return true;
  } else {
    if (col === layout.rowHeaderLevelCount - 1 && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return true;
    if (col === layout.colCount - layout.rightFrozenColCount && row >= layout.columnHeaderLevelCount && row < layout.rowCount - layout.bottomFrozenRowCount) return true;
  }
  return false;
}
var Direction3;
function transformInverse(spec, isHorizontal2) {
  let inverse = null == spec ? void 0 : spec.inverse;
  return isHorizontal2 && !isXAxis(null == spec ? void 0 : spec.orient) && (inverse = !isValid_default(null == spec ? void 0 : spec.inverse) || !(null == spec ? void 0 : spec.inverse)), inverse;
}
function isXAxis(orient) {
  return "bottom" === orient || "top" === orient;
}
!function(Direction4) {
  Direction4.vertical = "vertical", Direction4.horizontal = "horizontal";
}(Direction3 || (Direction3 = {}));
function hasLinearAxis(spec, tableAxesConfig, isHorizontal2, isThisXAxis) {
  if (!isArray_default(spec.axes) || 0 === spec.axes.length) return isHorizontal2 && isThisXAxis || !isHorizontal2 && !isThisXAxis;
  for (let i = 0; i < spec.axes.length; i++) {
    const axisSpec = spec.axes[i];
    if (!isHorizontal2 && isThisXAxis && "bottom" === axisSpec.orient && "linear" === axisSpec.type) return true;
    if (isHorizontal2 && isThisXAxis && "bottom" === axisSpec.orient && "linear" !== axisSpec.type) return true;
    if (!isHorizontal2 && !isThisXAxis && "left" === axisSpec.orient && "linear" !== axisSpec.type) return true;
    if (isHorizontal2 && !isThisXAxis && "left" === axisSpec.orient && "linear" === axisSpec.type) return true;
  }
  if (isArray_default(tableAxesConfig) && tableAxesConfig.length > 0) for (let i = 0; i < tableAxesConfig.length; i++) {
    const axisSpec = tableAxesConfig[i];
    if (!isHorizontal2 && isThisXAxis && "bottom" === axisSpec.orient && "linear" === axisSpec.type) return true;
    if (isHorizontal2 && isThisXAxis && "bottom" === axisSpec.orient && "linear" !== axisSpec.type) return true;
    if (!isHorizontal2 && !isThisXAxis && "left" === axisSpec.orient && "linear" !== axisSpec.type) return true;
    if (isHorizontal2 && !isThisXAxis && "left" === axisSpec.orient && "linear" === axisSpec.type) return true;
  }
  return isHorizontal2 && isThisXAxis || !isHorizontal2 && !isThisXAxis;
}
function getRange(position, colForAxisOption, rowForAxisOption, colForIndicatorKey, rowForIndicatorKey, col, row, defaultSeriesIndice, layout) {
  const indicatorKeys = layout.getIndicatorKeyInChartSpec(colForIndicatorKey, rowForIndicatorKey);
  let path;
  path = "top" === position || "bottom" === position ? layout.getColKeysPath(col, row) : layout.getRowKeysPath(col, row);
  const rangeConfig = getChartAxisRange(colForAxisOption, rowForAxisOption, defaultSeriesIndice, position, indicatorKeys, path, layout);
  if (!rangeConfig) return;
  const subAxisPosition = "bottom" === position ? "top" : "top" === position ? "bottom" : "left" === position ? "right" : "left", { targetRange, targetTicks } = getTargetRangeAndTicks(colForAxisOption, rowForAxisOption, rangeConfig.index, rangeConfig.isZeroAlign, rangeConfig.isTickAlign, rangeConfig.range, indicatorKeys, subAxisPosition, path, layout);
  if (0 !== rangeConfig.index && targetTicks) {
    const getAxisDomainRangeAndLabels2 = Factory2.getFunction("getAxisDomainRangeAndLabels"), { range: newRange, ticks: newTicks } = getAxisDomainRangeAndLabels2(rangeConfig.range.min, rangeConfig.range.max, rangeConfig.axisOption, rangeConfig.isZeroAlign, "bottom" === position || "top" === position ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight, {
      targetTicks,
      targetRange
    });
    rangeConfig.range.min = newRange[0], rangeConfig.range.max = newRange[1], rangeConfig.ticks = newTicks;
  }
  return rangeConfig.targetRange = targetRange, rangeConfig.targetTicks = targetTicks, rangeConfig;
}
function getChartAxisRange(col, row, index, position, indicatorKeys, path, layout) {
  const { axisOption, isPercent: isPercent2, isZeroAlign, isTickAlign, seriesIndice, theme: theme4, chartType } = getAxisOption(col, row, position, layout), range5 = getAxisRange(layout.dataset.collectedValues, indicatorKeys, isZeroAlign, path, null != seriesIndice ? seriesIndice : index);
  if (!range5) return;
  isPercent2 && (range5.min = range5.min < 0 ? -1 : 0, range5.max = range5.max > 0 ? 1 : 0), ((null == axisOption ? void 0 : axisOption.zero) || range5.min === range5.max) && (range5.min = Math.min(range5.min, 0), range5.max = Math.max(range5.max, 0));
  const getAxisDomainRangeAndLabels2 = Factory2.getFunction("getAxisDomainRangeAndLabels"), { range: axisRange, ticks: selfTicks } = getAxisDomainRangeAndLabels2(range5.min, range5.max, axisOption, isZeroAlign, "bottom" === position || "top" === position ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight);
  (null == axisOption ? void 0 : axisOption.nice) && (range5.min = axisRange[0], range5.max = axisRange[1]);
  const ticks6 = selfTicks;
  return isNumber_default(null == axisOption ? void 0 : axisOption.min) && (range5.min = axisOption.min), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (range5.max = axisOption.max), {
    index: null != seriesIndice ? seriesIndice : index,
    range: range5,
    ticks: ticks6,
    isZeroAlign,
    isTickAlign,
    axisOption,
    theme: theme4,
    chartType
  };
}
function getAxisRangeAndTicks(col, row, index, position, subAxisPosition, indicatorKeys, path, layout) {
  const { range: range5, isZeroAlign, isTickAlign, axisOption } = getChartAxisRange(col, row, index, position, indicatorKeys, path, layout), { targetRange, targetTicks } = getTargetRangeAndTicks(col, row, index, isZeroAlign, isTickAlign, range5, indicatorKeys, subAxisPosition, path, layout);
  if (0 !== index && targetTicks) {
    const getAxisDomainRangeAndLabels2 = Factory2.getFunction("getAxisDomainRangeAndLabels"), { range: newRange, ticks: newTicks } = getAxisDomainRangeAndLabels2(range5.min, range5.max, merge({}, axisOption, {
      nice: true,
      tick: {
        forceTickCount: targetTicks.length
      }
    }), isZeroAlign, "bottom" === position || "top" === position ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight, {
      targetTicks,
      targetRange
    });
    range5.min = newRange[0], range5.max = newRange[1];
  }
  return {
    axisOption,
    range: range5,
    targetTicks,
    targetRange
  };
}
function getTargetRangeAndTicks(col, row, index, isZeroAlign, isTickAlign, range5, indicatorKeys, subAxisPosition, path, layout) {
  let targetTicks, targetRange;
  if (!isZeroAlign && !isTickAlign) return {
    targetTicks,
    targetRange
  };
  const subAxisRange = getChartAxisRange(col, row, indicatorKeys.length - 1 - index, subAxisPosition, indicatorKeys, path, layout);
  if (subAxisRange) {
    const { range: subRange, ticks: subTicks } = subAxisRange;
    if (targetRange = subRange, isZeroAlign) {
      const align = getNewRangeToAlign(range5, subRange);
      align && (range5.min = align.range1[0], range5.max = align.range1[1], targetRange.min = align.range2[0], targetRange.max = align.range2[1]);
    }
    isTickAlign && (targetTicks = isZeroAlign ? getZeroAlignTickAlignTicks(targetRange, col, row, index, subAxisPosition, layout) : subTicks);
  }
  return {
    targetTicks,
    targetRange
  };
}

// node_modules/@visactor/vtable/es/plugins/custom-cell-style.js
var CustomCellStylePlugin = class {
  constructor(table, customCellStyle, customCellStyleArrangement) {
    this.table = table, this.customCellStyle = customCellStyle, this.customCellStyleArrangement = customCellStyleArrangement;
  }
  getCustomCellStyle(col, row) {
    const customStyleIds = this.getCustomCellStyleIds(col, row);
    if (customStyleIds.length) {
      const styles = [];
      return customStyleIds.forEach((customStyleId) => {
        const styleOption = this.getCustomCellStyleOption(customStyleId);
        if (isFunction_default(null == styleOption ? void 0 : styleOption.style)) {
          const style2 = styleOption.style({
            col,
            row,
            table: this.table,
            value: this.table.getCellValue(col, row),
            dataValue: this.table.getCellOriginValue(col, row),
            cellHeaderPaths: this.table.getCellHeaderPaths(col, row)
          });
          styles.push(style2);
        } else (null == styleOption ? void 0 : styleOption.style) && styles.push(styleOption.style);
      }), merge({}, ...styles);
    }
  }
  getCustomCellStyleIds(col, row) {
    const customStyleIds = [], range5 = this.table.getCellRange(col, row);
    for (let c2 = range5.start.col; c2 <= range5.end.col; c2++) for (let r = range5.start.row; r <= range5.end.row; r++) this.customCellStyleArrangement.forEach((style2) => {
      style2.cellPosition.range ? style2.cellPosition.range.start.col <= c2 && style2.cellPosition.range.end.col >= c2 && style2.cellPosition.range.start.row <= r && style2.cellPosition.range.end.row >= r && customStyleIds.push(style2.customStyleId) : style2.cellPosition.col === c2 && style2.cellPosition.row === r && customStyleIds.push(style2.customStyleId);
    });
    return customStyleIds;
  }
  getCustomCellStyleOption(customStyleId) {
    return this.customCellStyle.find((style2) => style2.id === customStyleId);
  }
  registerCustomCellStyle(customStyleId, customStyle) {
    const index = this.customCellStyle.findIndex((style2) => style2.id === customStyleId);
    -1 === index ? this.customCellStyle.push({
      id: customStyleId,
      style: customStyle
    }) : this.customCellStyle[index] = {
      id: customStyleId,
      style: customStyle
    }, this.customCellStyleArrangement.forEach((cellStyle) => {
      const cellPos = cellStyle.cellPosition;
      if (cellStyle.customStyleId === customStyleId) if (cellPos.range) for (let col = Math.max(0, cellPos.range.start.col); col <= Math.min(this.table.colCount - 1, cellPos.range.end.col); col++) for (let row = Math.max(0, cellPos.range.start.row); row <= Math.min(this.table.rowCount - 1, cellPos.range.end.row); row++) this.table.scenegraph.updateCellContent(col, row);
      else this.table.scenegraph.updateCellContent(cellPos.col, cellPos.row);
    }), this.table.scenegraph.updateNextFrame();
  }
  arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate) {
    var _a;
    const index = this.customCellStyleArrangement.findIndex((style3) => style3.cellPosition.range && cellPos.range ? style3.cellPosition.range.start.col === cellPos.range.start.col && style3.cellPosition.range.start.row === cellPos.range.start.row && style3.cellPosition.range.end.col === cellPos.range.end.col && style3.cellPosition.range.end.row === cellPos.range.end.row : style3.cellPosition.col === cellPos.col && style3.cellPosition.row === cellPos.row);
    if (-1 === index && !customStyleId) return;
    if (-1 === index && customStyleId) this.customCellStyleArrangement.push({
      cellPosition: {
        col: cellPos.col,
        row: cellPos.row,
        range: cellPos.range
      },
      customStyleId
    });
    else {
      if (this.customCellStyleArrangement[index].customStyleId === customStyleId) return;
      customStyleId ? this.customCellStyleArrangement[index].customStyleId = customStyleId : this.customCellStyleArrangement.splice(index, 1);
    }
    const style2 = null === (_a = this.getCustomCellStyleOption(customStyleId)) || void 0 === _a ? void 0 : _a.style;
    if (style2) {
      forceFastUpdate = true;
      for (const key in style2) if (-1 === cellStyleKeys.indexOf(key)) {
        forceFastUpdate = false;
        break;
      }
    }
    if (cellPos.range) for (let col = Math.max(0, cellPos.range.start.col); col <= Math.min(this.table.colCount - 1, cellPos.range.end.col); col++) for (let row = Math.max(0, cellPos.range.start.row); row <= Math.min(this.table.rowCount - 1, cellPos.range.end.row); row++) {
      const range5 = this.table.getCellRange(col, row);
      for (let c2 = range5.start.col; c2 <= range5.end.col; c2++) for (let r = range5.start.row; r <= range5.end.row; r++) this.table.scenegraph.updateCellContent(c2, r, forceFastUpdate);
    }
    else this.table.scenegraph.updateCellContent(cellPos.col, cellPos.row, forceFastUpdate);
    this.table.scenegraph.updateNextFrame();
  }
  updateCustomCell(customCellStyle, customCellStyleArrangement) {
    this.customCellStyle.length = 0, this.customCellStyleArrangement.length = 0, customCellStyle.forEach((cellStyle) => {
      this.registerCustomCellStyle(cellStyle.id, cellStyle.style);
    }), customCellStyleArrangement.forEach((cellStyle) => {
      this.arrangeCustomCellStyle(cellStyle.cellPosition, cellStyle.customStyleId);
    });
  }
  hasCustomCellStyle(customStyleId) {
    return this.customCellStyle.some((style2) => style2.id === customStyleId);
  }
};
function mergeStyle(cacheStyle, customCellStyle) {
  cacheStyle = cacheStyle.clone();
  for (const key in customCellStyle) {
    const value = customCellStyle[key];
    isValid_default(value) && (cacheStyle[`_${key}`] = value);
  }
  return cacheStyle;
}
var registerCustomCellStylePlugin = () => {
  Factory2.registerComponent("customCellStylePlugin", CustomCellStylePlugin);
};

// node_modules/@visactor/vtable/es/core/style-helper.js
var EMPTY_STYLE = {};
function getCellStyle(col, row, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const customCellStyle = null === (_a = table.customCellStylePlugin) || void 0 === _a ? void 0 : _a.getCustomCellStyle(col, row), { layoutMap } = table.internalProps;
  if (layoutMap.isHeader(col, row)) {
    let cacheKey2;
    if (!table.isPivotTable() || table.isBottomFrozenRow(row) || table.isRightFrozenColumn(col)) cacheKey2 = `${col}-${row}`;
    else {
      const define = table.getHeaderDefine(col, row), isCorner = table.isCornerHeader(col, row);
      cacheKey2 = (null == define ? void 0 : define.dimensionKey) ? isCorner ? `dim-cor-${define.dimensionKey}` : `dim-${define.dimensionKey}` : (null == define ? void 0 : define.indicatorKey) ? `ind-${define.indicatorKey}` : `${col}-${row}`;
    }
    let cacheStyle2 = table.headerStyleCache.get(cacheKey2);
    if (cacheStyle2) return customCellStyle ? mergeStyle(cacheStyle2, customCellStyle) : cacheStyle2;
    const hd = layoutMap.getHeader(col, row);
    let paddingForAxis;
    if (table.isPivotChart() && isTopOrBottomAxis(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
      paddingForAxis = null !== (_c = null === (_b = layoutMap.getBody(col, table.rowHeaderLevelCount).style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : table.theme.bodyStyle.padding;
    } else if (table.isPivotChart() && isLeftOrRightAxis(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
      paddingForAxis = null !== (_e = null === (_d = layoutMap.getBody(table.columnHeaderLevelCount, row).style) || void 0 === _d ? void 0 : _d.padding) && void 0 !== _e ? _e : table.theme.bodyStyle.padding;
    }
    if ((!hd || hd.isEmpty) && (layoutMap.isLeftBottomCorner(col, row) || layoutMap.isRightBottomCorner(col, row) || layoutMap.isCornerHeader(col, row) || layoutMap.isRightTopCorner(col, row))) return EMPTY_STYLE;
    const styleClass2 = table.internalProps.headerHelper.getStyleClass((null == hd ? void 0 : hd.headerType) || "text");
    if (layoutMap.isBottomFrozenRow(col, row) && table.theme.bottomFrozenStyle) cacheStyle2 = of3(paddingForAxis ? {
      padding: paddingForAxis
    } : {}, table.theme.bottomFrozenStyle, {
      col,
      row,
      table,
      value: table.getCellValue(col, row),
      dataValue: table.getCellOriginValue(col, row),
      cellHeaderPaths: table.getCellHeaderPaths(col, row)
    }, styleClass2, table.options.autoWrapText, table.theme);
    else if (layoutMap.isRightFrozenColumn(col, row) && table.theme.rightFrozenStyle) cacheStyle2 = of3(paddingForAxis ? {
      padding: paddingForAxis
    } : {}, table.theme.rightFrozenStyle, {
      col,
      row,
      table,
      value: table.getCellValue(col, row),
      dataValue: table.getCellOriginValue(col, row),
      cellHeaderPaths: table.getCellHeaderPaths(col, row)
    }, styleClass2, table.options.autoWrapText, table.theme);
    else {
      const style3 = (null == hd ? void 0 : hd.style) || {};
      paddingForAxis && (style3.padding = paddingForAxis), cacheStyle2 = of3(style3, layoutMap.isColumnHeader(col, row) || layoutMap.isBottomFrozenRow(col, row) ? table.theme.headerStyle : layoutMap.isRowHeader(col, row) || layoutMap.isRightFrozenColumn(col, row) ? table.theme.rowHeaderStyle : table.theme.cornerHeaderStyle, {
        col,
        row,
        table,
        value: table.getCellValue(col, row),
        dataValue: table.getCellOriginValue(col, row),
        cellHeaderPaths: table.getCellHeaderPaths(col, row)
      }, styleClass2, table.options.autoWrapText, table.theme);
    }
    return table.headerStyleCache.set(cacheKey2, cacheStyle2), customCellStyle ? mergeStyle(cacheStyle2, customCellStyle) : cacheStyle2;
  }
  let bgColorFunc, cacheKey;
  (null === (_g = null === (_f = table.internalProps) || void 0 === _f ? void 0 : _f.dataConfig) || void 0 === _g ? void 0 : _g.mappingRules) && !table.isHeader(col, row) && (null === (_k = null === (_j = null === (_h = table.internalProps) || void 0 === _h ? void 0 : _h.dataConfig) || void 0 === _j ? void 0 : _j.mappingRules) || void 0 === _k || _k.forEach((mappingRule, i) => {
    mappingRule.bgColor && table.internalProps.layoutMap.getIndicatorKey(col, row) === mappingRule.bgColor.indicatorKey && (bgColorFunc = mappingRule.bgColor.mapping);
  }));
  const cellType = table.getCellType(col, row), rawRecord = table.getCellOriginRecord(col, row);
  let cacheStyle;
  if (cacheKey = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? "merge-title" : table.isSeriesNumberInBody(col, row) ? `${col}-series-` + cellType : table.isListTable() && !table.transpose || table.isPivotTable() && table.internalProps.layoutMap.indicatorsAsCol ? col + cellType : row + cellType, cacheStyle = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? table.bodyMergeTitleCache.get(cacheKey) : layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.get(cacheKey) : table.bodyStyleCache.get(cacheKey), cacheStyle) return customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
  const column = layoutMap.getBody(col, row), styleClass = table.internalProps.bodyHelper.getStyleClass(table.getCellType(col, row)), style2 = null == column ? void 0 : column.style;
  return cacheStyle = of(style2, (null == rawRecord ? void 0 : rawRecord.vtableMerge) && table.theme.groupTitleStyle ? table.theme.groupTitleStyle : layoutMap.isBottomFrozenRow(row) && table.theme.bottomFrozenStyle ? table.theme.bottomFrozenStyle : layoutMap.isRightFrozenColumn(col) && table.theme.rightFrozenStyle ? table.theme.rightFrozenStyle : table.theme.bodyStyle, {
    col,
    row,
    table,
    value: table.getCellValue(col, row),
    dataValue: table.getCellOriginValue(col, row),
    cellHeaderPaths: table.getCellHeaderPaths(col, row)
  }, styleClass, table.options.autoWrapText, table.theme), bgColorFunc && (cacheStyle = mergeStyle(cacheStyle, {
    bgColor: bgColorFunc
  })), isFunction_default(style2) || (layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.set(cacheKey, cacheStyle) : table.bodyStyleCache.set(cacheKey, cacheStyle)), customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
}

// node_modules/@visactor/vtable/es/core/animation.js
function isInteger(value) {
  return Math.floor(value) === value;
}
var Animateaaa = class extends ACustomAnimate {
  onUpdate(end, ratio, out) {
    if (this.from.x !== this.to.x) {
      const x = end ? this.to.x : this.from.x + Math.floor((this.to.x - this.from.x) * ratio);
      this.params.table.scrollLeft = x;
    }
    if (this.from.y !== this.to.y) {
      const y = end ? this.to.y : this.from.y + Math.floor((this.to.y - this.from.y) * ratio);
      this.params.table.scrollTop = y;
    }
  }
};
var TableAnimationManager = class {
  constructor(table) {
    this.table = table, this.timeline = new DefaultTimeline(), this.ticker = new DefaultTicker(), this.ticker.addTimeline(this.timeline);
    this.ticker.setFPS(60), this.tempGraphic = createRect({});
  }
  scrollTo(position, animationOption) {
    var _a, _b;
    const from = {
      x: this.table.scrollLeft,
      y: this.table.scrollTop
    }, { col, row } = position;
    let colDecimal, rowDecimal, colInt = col, rowInt = row;
    isNumber_default(col) && !isInteger(col) && (colInt = Math.floor(col), colDecimal = col - colInt), isNumber_default(row) && !isInteger(row) && (rowInt = Math.floor(row), rowDecimal = row - rowInt);
    const cellRect = this.table.getCellRect(null != colInt ? colInt : 0, null != rowInt ? rowInt : 0);
    let { left, top } = cellRect;
    colDecimal && (left += colDecimal * cellRect.width), rowDecimal && (top += rowDecimal * cellRect.height);
    const to = {
      x: isNumber_default(col) ? left - this.table.getFrozenColsWidth() : this.table.scrollLeft,
      y: isNumber_default(row) ? top - this.table.getFrozenRowsHeight() : this.table.scrollTop
    }, duration = isBoolean_default(animationOption) ? animationOption ? 3e3 : 0 : null !== (_a = null == animationOption ? void 0 : animationOption.duration) && void 0 !== _a ? _a : 3e3, easing = isBoolean_default(animationOption) ? animationOption ? "linear" : "" : null !== (_b = null == animationOption ? void 0 : animationOption.easing) && void 0 !== _b ? _b : "linear";
    new Animate(Generator.GenAutoIncrementId(), this.timeline).bind(this.tempGraphic).play(new Animateaaa(from, to, duration, easing, {
      graphic: this.tempGraphic,
      table: this.table
    }));
    this.ticker.start();
  }
  clear() {
    this.timeline.clear(), this.ticker.stop();
  }
};

// node_modules/@visactor/vtable/es/core/utils/get-custom-merge-cell-func.js
function getCustomMergeCellFunc(customMergeCell) {
  return isFunction_default(customMergeCell) ? customMergeCell : isArray_default(customMergeCell) ? (col, row) => customMergeCell.find((item) => item.range.start.col <= col && item.range.end.col >= col && item.range.start.row <= row && item.range.end.row >= row) : void 0;
}

// node_modules/@visactor/vtable/es/plugins/plugin-manager.js
var PluginManager = class {
  constructor(table, options) {
    var _a;
    this.plugins = /* @__PURE__ */ new Map(), this.table = table, null === (_a = options.plugins) || void 0 === _a || _a.map((plugin) => {
      this.register(plugin), this._bindTableEventForPlugin(plugin);
    });
  }
  register(plugin) {
    this.plugins.set(plugin.id, plugin);
  }
  registerAll(plugins) {
    plugins.forEach((plugin) => this.register(plugin));
  }
  getPlugin(id) {
    return this.plugins.get(id);
  }
  getPluginByName(name) {
    return Array.from(this.plugins.values()).find((plugin) => plugin.name === name);
  }
  _bindTableEventForPlugin(plugin) {
    var _a;
    null === (_a = plugin.runTime) || void 0 === _a || _a.forEach((runTime) => {
      this.table.on(runTime, (...args) => {
        var _a2;
        null === (_a2 = plugin.run) || void 0 === _a2 || _a2.call(plugin, ...args, runTime, this.table);
      });
    });
  }
  updatePlugins(plugins) {
    Array.from(this.plugins.values()).filter((plugin) => !(null == plugins ? void 0 : plugins.some((p) => p.id === plugin.id))).forEach((plugin) => {
      this.release(), this.plugins.delete(plugin.id);
    }), this.plugins.forEach((plugin) => {
      plugin.update && plugin.update();
    });
    const addedPlugins = null == plugins ? void 0 : plugins.filter((plugin) => !this.plugins.has(plugin.id));
    null == addedPlugins || addedPlugins.forEach((plugin) => {
      this.register(plugin), this._bindTableEventForPlugin(plugin);
    });
  }
  release() {
    this.plugins.forEach((plugin) => {
      var _a;
      null === (_a = plugin.release) || void 0 === _a || _a.call(plugin, this.table);
    });
  }
};

// node_modules/@visactor/vtable/es/core/BaseTable.js
var { toBoxArray: toBoxArray2 } = style;
var { isTouchEvent: isTouchEvent3 } = event;
var rangeReg = /^\$(\d+)\$(\d+)$/;
importStyle();
var BaseTable = class extends EventTarget3 {
  static get EVENT_TYPE() {
    return TABLE_EVENT_TYPE;
  }
  constructor(container2, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    if (super(), this.showFrozenIcon = true, this.version = "1.18.3", this.id = `VTable${Date.now()}`, this.isReleased = false, this._chartEventMap = {}, this.throttleInvalidate = throttle2(this.render.bind(this), 200), "node" === Env.mode ? (options = container2, container2 = null) : container2 instanceof HTMLElement || (options = container2, container2 = container2.container ? container2.container : null), !container2 && "node" !== options.mode && !options.canvas) throw new Error("vtable's container is undefined");
    this.pluginManager = new PluginManager(this, options), this.fireListeners(TABLE_EVENT_TYPE.BEFORE_INIT, {
      options,
      container: container2
    }), container2 = options.container && options.container instanceof HTMLElement ? options.container : container2, false === (null === (_a = options.customConfig) || void 0 === _a ? void 0 : _a.imageAnonymous) && (vglobal.isImageAnonymous = false);
    const { frozenColCount = 0, unfreezeAllOnExceedsMaxWidth, frozenRowCount, defaultRowHeight = 40, defaultHeaderRowHeight, defaultColWidth = 80, defaultHeaderColWidth, widthMode = "standard", heightMode = "standard", autoFillWidth = false, autoFillHeight = false, widthAdaptiveMode = "only-body", heightAdaptiveMode = "only-body", keyboardOptions, eventOptions, rowSeriesNumber, columnResizeMode, rowResizeMode = "none", resize, dragHeaderMode, dragOrder, showFrozenIcon, allowFrozenColCount, padding, hover, menu, select: click, customRender, pixelRatio = defaultPixelRatio, renderChartAsync, renderChartAsyncBatchCount, mode, modeParams, canvasWidth, canvasHeight, overscrollBehavior, limitMinWidth, limitMinHeight, clearDOM = true } = options;
    this.container = container2, this.options = options, this._widthMode = widthMode, this._heightMode = heightMode, this._widthAdaptiveMode = widthAdaptiveMode, this._heightAdaptiveMode = heightAdaptiveMode, this._autoFillWidth = autoFillWidth, this._autoFillHeight = autoFillHeight, this.customRender = customRender, this.padding = {
      top: 0,
      right: 0,
      left: 0,
      bottom: 0
    }, padding && ("number" == typeof padding ? (this.padding.top = padding, this.padding.left = padding, this.padding.bottom = padding, this.padding.right = padding) : (padding.top && (this.padding.top = padding.top), padding.bottom && (this.padding.bottom = padding.bottom), padding.left && (this.padding.left = padding.left), padding.right && (this.padding.right = padding.right))), (isValid_default(canvasHeight) || isValid_default(canvasWidth)) && (this.canvasSizeSeted = true), this.tableNoFrameWidth = 0, this.tableNoFrameHeight = 0, this.canvasWidth = isNumber_default(canvasWidth) ? canvasWidth : void 0, this.canvasHeight = isNumber_default(canvasHeight) ? canvasHeight : void 0, this.columnWidthComputeMode = null !== (_b = options.columnWidthComputeMode) && void 0 !== _b ? _b : "normal";
    const internalProps = this.internalProps = {};
    void 0 !== showFrozenIcon && (this.showFrozenIcon = showFrozenIcon), "number" == typeof allowFrozenColCount && allowFrozenColCount <= 0 && (this.showFrozenIcon = false), this.options.canvas ? ("node" !== Env.mode && (internalProps.element = this.options.canvas.parentElement, internalProps.element.style.position = "relative"), internalProps.focusControl = new FocusInput(this, internalProps.element), internalProps.canvas = this.options.canvas, internalProps.context = internalProps.canvas.getContext("2d")) : "node" !== Env.mode && (internalProps.element = createRootElement(this.padding), internalProps.focusControl = new FocusInput(this, internalProps.element), internalProps.canvas = document.createElement("canvas"), internalProps.element.appendChild(internalProps.canvas), internalProps.context = internalProps.canvas.getContext("2d"), (null === (_c = options.customConfig) || void 0 === _c ? void 0 : _c.createReactContainer) && createReactContainer(this)), internalProps.handler = new EventHandler(), isNumber_default(this.options.resizeTime) && (internalProps.handler.resizeTime = this.options.resizeTime), internalProps.pixelRatio = pixelRatio, internalProps.frozenColCount = frozenColCount, internalProps.frozenRowCount = frozenRowCount, internalProps.unfreezeAllOnExceedsMaxWidth = null == unfreezeAllOnExceedsMaxWidth || unfreezeAllOnExceedsMaxWidth, internalProps.defaultRowHeight = defaultRowHeight, internalProps.defaultHeaderRowHeight = null != defaultHeaderRowHeight ? defaultHeaderRowHeight : defaultRowHeight, internalProps.defaultColWidth = defaultColWidth, internalProps.defaultHeaderColWidth = null != defaultHeaderColWidth ? defaultHeaderColWidth : defaultColWidth, internalProps.keyboardOptions = keyboardOptions, internalProps.eventOptions = eventOptions, internalProps.rowSeriesNumber = rowSeriesNumber, internalProps.columnResizeMode = null !== (_d = null == resize ? void 0 : resize.columnResizeMode) && void 0 !== _d ? _d : columnResizeMode, internalProps.rowResizeMode = null !== (_e = null == resize ? void 0 : resize.rowResizeMode) && void 0 !== _e ? _e : rowResizeMode, internalProps.dragHeaderMode = null !== (_g = null !== (_f = null == dragOrder ? void 0 : dragOrder.dragHeaderMode) && void 0 !== _f ? _f : dragHeaderMode) && void 0 !== _g ? _g : "none", internalProps.renderChartAsync = renderChartAsync, setBatchRenderChartCount(renderChartAsyncBatchCount), internalProps.overscrollBehavior = null != overscrollBehavior ? overscrollBehavior : "auto", internalProps._rowHeightsMap = new NumberRangeMap(this), internalProps._rowRangeHeightsMap = /* @__PURE__ */ new Map(), internalProps._colRangeWidthsMap = /* @__PURE__ */ new Map(), internalProps._widthResizedColMap = /* @__PURE__ */ new Set(), internalProps._heightResizedRowMap = /* @__PURE__ */ new Set(), this.colWidthsMap = new NumberMap(), this.colContentWidthsMap = new NumberMap(), this.colWidthsLimit = {};
    const that = this;
    if (internalProps.calcWidthContext = {
      _: internalProps,
      get full() {
        var _a2;
        return "node" === Env.mode ? that.canvasWidth / (null != pixelRatio ? pixelRatio : 1) : this._.canvas.width / (null !== (_a2 = this._.context.pixelRatio) && void 0 !== _a2 ? _a2 : window.devicePixelRatio);
      }
    }, internalProps.cellTextOverflows = {}, internalProps.focusedTable = false, internalProps.theme = themes_default.of(null !== (_h = options.theme) && void 0 !== _h ? _h : themes_default.DEFAULT), internalProps.theme.isPivot = this.isPivotTable(), setIconColor(internalProps.theme.functionalIconsStyle), container2 ? (clearDOM && (container2.innerHTML = ""), container2.appendChild(internalProps.element), this._updateSize()) : this._updateSize(), internalProps.bodyHelper = new BodyHelper(this), internalProps.headerHelper = new HeaderHelper(this), internalProps.rowSeriesNumberHelper = new RowSeriesNumberHelper(this), internalProps.autoWrapText = options.autoWrapText, internalProps.enableLineBreak = options.enableLineBreak, internalProps.allowFrozenColCount = null !== (_j = options.allowFrozenColCount) && void 0 !== _j ? _j : 0, internalProps.limitMaxAutoWidth = null !== (_k = options.limitMaxAutoWidth) && void 0 !== _k ? _k : 450, internalProps.limitMinWidth = null != limitMinWidth ? "number" == typeof limitMinWidth ? limitMinWidth : limitMinWidth ? 10 : 0 : 10, internalProps.limitMinHeight = null != limitMinHeight ? "number" == typeof limitMinHeight ? limitMinHeight : limitMinHeight ? 10 : 0 : 10, this.scenegraph = new Scenegraph(this), this.stateManager = new StateManager(this), this.eventManager = new EventManager2(this), this.animationManager = new TableAnimationManager(this), options.legends) {
      internalProps.legends = [];
      const createLegend2 = Factory2.getFunction("createLegend");
      if (Array.isArray(options.legends)) {
        for (let i = 0; i < options.legends.length; i++) internalProps.legends.push(createLegend2(options.legends[i], this));
        this.scenegraph.tableGroup.setAttributes({
          x: this.tableX,
          y: this.tableY
        });
      } else internalProps.legends.push(createLegend2(options.legends, this)), this.scenegraph.tableGroup.setAttributes({
        x: this.tableX,
        y: this.tableY
      });
    }
    if (internalProps.tooltip = Object.assign({
      parentElement: this.getElement(),
      renderMode: "html",
      isShowOverflowTextTooltip: false,
      confine: true,
      position: Placement.bottom
    }, options.tooltip), "html" === internalProps.tooltip.renderMode) {
      const TooltipHandler2 = Factory2.getComponent("tooltipHandler");
      TooltipHandler2 && (internalProps.tooltipHandler = new TooltipHandler2(this, internalProps.tooltip.confine));
    }
    if (internalProps.menu = Object.assign({
      renderMode: "html"
    }, options.menu), Array.isArray(null === (_l = options.menu) || void 0 === _l ? void 0 : _l.dropDownMenuHighlight) && this.setDropDownMenuHighlight(null === (_m = options.menu) || void 0 === _m ? void 0 : _m.dropDownMenuHighlight), (Array.isArray(null === (_o = options.menu) || void 0 === _o ? void 0 : _o.defaultHeaderMenuItems) || "function" == typeof (null === (_p = options.menu) || void 0 === _p ? void 0 : _p.defaultHeaderMenuItems)) && (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems), "html" === internalProps.menu.renderMode) {
      const MenuHandler3 = Factory2.getComponent("menuHandler");
      internalProps.menuHandler = new MenuHandler3(this);
    }
    this.headerStyleCache = /* @__PURE__ */ new Map(), this.bodyStyleCache = /* @__PURE__ */ new Map(), this.bodyMergeTitleCache = /* @__PURE__ */ new Map(), this.bodyBottomStyleCache = /* @__PURE__ */ new Map(), internalProps.stick = {
      changedCells: /* @__PURE__ */ new Map()
    }, internalProps.customMergeCell = getCustomMergeCellFunc(options.customMergeCell);
    const CustomCellStylePlugin2 = Factory2.getComponent("customCellStylePlugin");
    CustomCellStylePlugin2 && (this.customCellStylePlugin = new CustomCellStylePlugin2(this, null !== (_q = options.customCellStyle) && void 0 !== _q ? _q : [], null !== (_r = options.customCellStyleArrangement) && void 0 !== _r ? _r : [])), this._adjustCanvasSizeByOption();
  }
  _adjustCanvasSizeByOption() {
    "auto" !== this.options.canvasHeight && "auto" !== this.options.canvasWidth || setTimeout(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
      let canvasWidth, canvasHeight;
      if ("auto" === this.options.canvasHeight) {
        let borderWidth = 0;
        if (null === (_a = this.theme.frameStyle) || void 0 === _a ? void 0 : _a.innerBorder) {
          borderWidth += null !== (_d = toBoxArray2(null !== (_c = null === (_b = this.internalProps.theme.frameStyle) || void 0 === _b ? void 0 : _b.shadowBlur) && void 0 !== _c ? _c : [0])[1]) && void 0 !== _d ? _d : 0;
        } else if (this.theme.frameStyle) {
          const lineWidths = toBoxArray2(null !== (_f = null === (_e = this.internalProps.theme.frameStyle) || void 0 === _e ? void 0 : _e.borderLineWidth) && void 0 !== _f ? _f : [null]), shadowWidths = toBoxArray2(null !== (_h = null === (_g = this.internalProps.theme.frameStyle) || void 0 === _g ? void 0 : _g.shadowBlur) && void 0 !== _h ? _h : [0]);
          borderWidth += (null !== (_j = lineWidths[0]) && void 0 !== _j ? _j : 0) + (null !== (_k = shadowWidths[0]) && void 0 !== _k ? _k : 0) + ((null !== (_l = lineWidths[2]) && void 0 !== _l ? _l : 0) + (null !== (_m = shadowWidths[2]) && void 0 !== _m ? _m : 0));
        }
        canvasHeight = Math.min(this.options.maxCanvasHeight ? this.options.maxCanvasHeight - borderWidth : 2e4, this.getAllRowsHeight()) + borderWidth;
      } else canvasHeight = this.canvasHeight;
      if ("auto" === this.options.canvasWidth) {
        let borderWidth = 0;
        if (null === (_o = this.theme.frameStyle) || void 0 === _o ? void 0 : _o.innerBorder) {
          borderWidth += null !== (_r = toBoxArray2(null !== (_q = null === (_p = this.internalProps.theme.frameStyle) || void 0 === _p ? void 0 : _p.shadowBlur) && void 0 !== _q ? _q : [0])[2]) && void 0 !== _r ? _r : 0;
        } else if (this.theme.frameStyle) {
          const lineWidths = toBoxArray2(null !== (_t = null === (_s = this.internalProps.theme.frameStyle) || void 0 === _s ? void 0 : _s.borderLineWidth) && void 0 !== _t ? _t : [null]), shadowWidths = toBoxArray2(null !== (_v = null === (_u = this.internalProps.theme.frameStyle) || void 0 === _u ? void 0 : _u.shadowBlur) && void 0 !== _v ? _v : [0]);
          borderWidth += (null !== (_w = lineWidths[1]) && void 0 !== _w ? _w : 0) + (null !== (_x = shadowWidths[1]) && void 0 !== _x ? _x : 0) + ((null !== (_y = lineWidths[3]) && void 0 !== _y ? _y : 0) + (null !== (_z = shadowWidths[3]) && void 0 !== _z ? _z : 0));
        }
        canvasWidth = Math.min(this.options.maxCanvasWidth ? this.options.maxCanvasWidth - borderWidth : 2e4, this.getAllColsWidth()) + borderWidth;
      } else canvasWidth = this.canvasWidth;
      this.setCanvasSize(canvasWidth, canvasHeight);
    }, 0);
  }
  getContainer() {
    return this.container;
  }
  getElement() {
    return this.internalProps.element;
  }
  get canvas() {
    return this.internalProps.canvas;
  }
  setCanvasSize(canvasWidth, canvasHeight) {
    this.canvasWidth = canvasWidth, this.canvasHeight = canvasHeight, this.options.canvasHeight = canvasHeight, this.options.canvasWidth = canvasWidth, this.resize();
  }
  resize() {
    var _a;
    this._updateSize(), null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend) => {
      null == legend || legend.resize();
    }), this.internalProps.title && this.internalProps.title.resize(), this.internalProps.emptyTip && this.internalProps.emptyTip.resize(), this.scenegraph.resize();
  }
  get rowCount() {
    return this.internalProps.rowCount;
  }
  set rowCount(rowCount) {
    this.internalProps.rowCount = rowCount;
  }
  get colCount() {
    var _a;
    return null !== (_a = this.internalProps.colCount) && void 0 !== _a ? _a : 0;
  }
  set colCount(colCount) {
    this.internalProps.colCount = colCount;
  }
  get frozenColCount() {
    var _a, _b, _c, _d, _e;
    return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.frozenColCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.frozenColCount) && void 0 !== _e ? _e : 0;
  }
  set frozenColCount(frozenColCount) {
    frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount, this.options.frozenColCount = frozenColCount;
    const maxFrozenWidth = this._getMaxFrozenWidth();
    if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) if (this.internalProps.unfreezeAllOnExceedsMaxWidth) this.internalProps.frozenColCount = 0;
    else {
      const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
      this.internalProps.frozenColCount = computedFrozenColCount;
    }
    this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
  }
  setFrozenColCount(frozenColCount) {
    frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount, this.options.frozenColCount = frozenColCount;
    const maxFrozenWidth = this._getMaxFrozenWidth();
    if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) if (this.internalProps.unfreezeAllOnExceedsMaxWidth) this.internalProps.frozenColCount = 0;
    else {
      const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
      this.internalProps.frozenColCount = computedFrozenColCount;
    }
    this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
  }
  _setFrozenColCount(frozenColCount) {
    frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount;
  }
  _resetFrozenColCount() {
    this.options.frozenColCount && (this.tableNoFrameWidth - this.getColsWidth(0, this.options.frozenColCount - 1) <= 120 ? this._setFrozenColCount(0) : this.frozenColCount !== this.options.frozenColCount && this._setFrozenColCount(this.options.frozenColCount));
  }
  get frozenRowCount() {
    var _a, _b, _c, _d, _e;
    return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.frozenRowCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.frozenRowCount) && void 0 !== _e ? _e : 0;
  }
  set frozenRowCount(frozenRowCount) {
    this.internalProps.frozenRowCount = frozenRowCount, this.stateManager.setFrozenRow(this.internalProps.frozenRowCount);
  }
  get rightFrozenColCount() {
    var _a, _b, _c, _d, _e;
    return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.rightFrozenColCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.rightFrozenColCount) && void 0 !== _e ? _e : 0;
  }
  set rightFrozenColCount(rightFrozenColCount) {
    this.scenegraph.dealWidthRightFrozen(rightFrozenColCount);
  }
  get bottomFrozenRowCount() {
    var _a, _b, _c, _d, _e;
    return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.bottomFrozenRowCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.bottomFrozenRowCount) && void 0 !== _e ? _e : 0;
  }
  set bottomFrozenRowCount(bottomFrozenRowCount) {
    this.scenegraph.dealWidthBottomFrozen(bottomFrozenRowCount);
  }
  get defaultRowHeight() {
    return isNumber_default(this.internalProps.defaultRowHeight) ? this.internalProps.defaultRowHeight : 40;
  }
  set defaultRowHeight(defaultRowHeight) {
    this.internalProps.defaultRowHeight = defaultRowHeight, this.options.defaultRowHeight = defaultRowHeight;
  }
  get defaultHeaderRowHeight() {
    return this.internalProps.defaultHeaderRowHeight;
  }
  set defaultHeaderRowHeight(defaultHeaderRowHeight) {
    this.internalProps.defaultHeaderRowHeight = defaultHeaderRowHeight, this.options.defaultHeaderRowHeight = defaultHeaderRowHeight;
  }
  get defaultColWidth() {
    return this.internalProps.defaultColWidth;
  }
  set defaultColWidth(defaultColWidth) {
    this.internalProps.defaultColWidth = defaultColWidth, this.options.defaultColWidth = defaultColWidth;
  }
  get defaultHeaderColWidth() {
    return this.internalProps.defaultHeaderColWidth;
  }
  set defaultHeaderColWidth(defaultHeaderColWidth) {
    this.internalProps.defaultHeaderColWidth = defaultHeaderColWidth, this.options.defaultHeaderColWidth = defaultHeaderColWidth;
  }
  get colWidthsMap() {
    return this.internalProps._colWidthsMap;
  }
  set colWidthsMap(colWidthsMap) {
    this.internalProps._colWidthsMap = colWidthsMap;
  }
  get colContentWidthsMap() {
    return this.internalProps._colContentWidthsMap;
  }
  set colContentWidthsMap(colContentWidthsMap) {
    this.internalProps._colContentWidthsMap = colContentWidthsMap;
  }
  get _colRangeWidthsMap() {
    return this.internalProps._colRangeWidthsMap;
  }
  set _colRangeWidthsMap(_colRangeWidthsMap) {
    this.internalProps._colRangeWidthsMap = _colRangeWidthsMap;
  }
  get _rowRangeHeightsMap() {
    return this.internalProps._rowRangeHeightsMap;
  }
  set _rowRangeHeightsMap(_rowRangeHeightsMap) {
    this.internalProps._rowRangeHeightsMap = _rowRangeHeightsMap;
  }
  get rowHeightsMap() {
    return this.internalProps._rowHeightsMap;
  }
  set rowHeightsMap(rowHeightsMap) {
    this.internalProps._rowHeightsMap = rowHeightsMap;
  }
  get colWidthsLimit() {
    return this.internalProps._colWidthsLimit;
  }
  set colWidthsLimit(colWidthsLimit) {
    this.internalProps._colWidthsLimit = colWidthsLimit;
  }
  get keyboardOptions() {
    var _a;
    return null !== (_a = this.internalProps.keyboardOptions) && void 0 !== _a ? _a : null;
  }
  set keyboardOptions(keyboardOptions) {
    this.internalProps.keyboardOptions = null != keyboardOptions ? keyboardOptions : void 0;
  }
  get eventOptions() {
    var _a;
    return null !== (_a = this.internalProps.eventOptions) && void 0 !== _a ? _a : null;
  }
  set eventOptions(eventOptions) {
    this.internalProps.eventOptions = null != eventOptions ? eventOptions : void 0;
  }
  get widthMode() {
    return this._widthMode;
  }
  set widthMode(widthMode) {
    widthMode !== this._widthMode && (this._widthMode = widthMode, this.options.widthMode = widthMode);
  }
  get heightMode() {
    return this._heightMode;
  }
  set heightMode(heightMode) {
    heightMode !== this._heightMode && (this._heightMode = heightMode, this.options.heightMode = heightMode);
  }
  get autoFillWidth() {
    return this._autoFillWidth;
  }
  set autoFillWidth(autoFillWidth) {
    autoFillWidth !== this._autoFillWidth && (this._autoFillWidth = autoFillWidth);
  }
  get autoFillHeight() {
    return this._autoFillHeight;
  }
  set autoFillHeight(autoFillHeight) {
    autoFillHeight !== this._autoFillHeight && (this._autoFillHeight = autoFillHeight);
  }
  get widthAdaptiveMode() {
    return this._widthAdaptiveMode;
  }
  set widthAdaptiveMode(widthAdaptiveMode) {
    widthAdaptiveMode !== this._widthAdaptiveMode && (this._widthAdaptiveMode = widthAdaptiveMode);
  }
  get heightAdaptiveMode() {
    return this._heightAdaptiveMode;
  }
  set heightAdaptiveMode(heightAdaptiveMode) {
    heightAdaptiveMode !== this._heightAdaptiveMode && (this._heightAdaptiveMode = heightAdaptiveMode);
  }
  _colWidthDefineToPxWidth(width) {
    return "auto" === width ? 0 : _toPxWidth(this, width);
  }
  _getMaxFrozenWidth() {
    var _a;
    const maxFrozenWidth = null !== (_a = this.options.maxFrozenWidth) && void 0 !== _a ? _a : "80%";
    return _toPxWidth(this, maxFrozenWidth);
  }
  _getComputedFrozenColCount(frozenColCount) {
    const maxFrozenWidth = this._getMaxFrozenWidth();
    let computedfrozenColCount = frozenColCount;
    for (; this.getColsWidth(0, computedfrozenColCount - 1) > maxFrozenWidth && (computedfrozenColCount--, !(computedfrozenColCount <= 0)); ) ;
    return computedfrozenColCount;
  }
  _getColWidthLimits(col) {
    const limit = this.colWidthsLimit[col];
    if (!limit) return null;
    const result2 = {};
    return limit.min && (result2.min = _toPxWidth(this, limit.min), result2.minDef = limit.min), limit.max && (result2.max = _toPxWidth(this, limit.max), result2.maxDef = limit.max), result2;
  }
  _adjustColWidth(col, orgWidth) {
    const limits = this._getColWidthLimits(col);
    return Math.max(_applyColWidthLimits(limits, orgWidth), 0);
  }
  get pixelRatio() {
    return this.internalProps.pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    var _a;
    if (pixelRatio !== (null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.pixelRatio)) {
      this.internalProps.pixelRatio = pixelRatio;
      const canvasWidth = this.canvasWidth;
      this.internalProps.calcWidthContext = {
        _: this.internalProps,
        get full() {
          var _a2;
          return "node" === Env.mode ? canvasWidth / (null != pixelRatio ? pixelRatio : 1) : this._.canvas.width / (null !== (_a2 = this._.context.pixelRatio) && void 0 !== _a2 ? _a2 : window.devicePixelRatio);
        }
      }, this.scenegraph.setPixelRatio(pixelRatio);
    }
  }
  _updateSize() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
    const { padding } = this;
    let widthP = 0, heightP = 0;
    if (this.tableX = 0, this.tableY = 0, this.options.canvas && this.options.viewBox) widthP = this.options.viewBox.x2 - this.options.viewBox.x1, heightP = this.options.viewBox.y2 - this.options.viewBox.y1, (null === (_a = null == this ? void 0 : this.scenegraph) || void 0 === _a ? void 0 : _a.stage) && (this.options.viewBox ? this.scenegraph.stage.setViewBox(this.options.viewBox, false) : this.scenegraph.stage.resize(widthP, heightP));
    else if ("browser" === Env.mode) {
      const element = this.getElement();
      let widthWithoutPadding = 0, heightWithoutPadding = 0;
      const isDefWidth = isValid_default(this.canvasWidth), isDefHeight = isValid_default(this.canvasHeight);
      this.canvasSizeSeted && (isDefWidth && (widthWithoutPadding = this.canvasWidth), isDefHeight && (heightWithoutPadding = this.canvasHeight));
      if ((!isDefWidth || !isDefHeight) && element.parentElement) {
        const computedStyle = element.parentElement.style || window.getComputedStyle(element.parentElement);
        isDefWidth || (widthWithoutPadding = element.parentElement.offsetWidth - (parseInt(computedStyle.paddingLeft, 10) || 0) - (parseInt(computedStyle.paddingRight, 10) || 0)), isDefHeight || (heightWithoutPadding = element.parentElement.offsetHeight - parseInt(computedStyle.paddingTop || "0px", 10) - parseInt(computedStyle.paddingBottom || "0px", 20)), widthWithoutPadding = (null != widthWithoutPadding ? widthWithoutPadding : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), heightWithoutPadding = (null != heightWithoutPadding ? heightWithoutPadding : 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
      }
      element.style.width = widthWithoutPadding && widthWithoutPadding - padding.left - padding.right + "px" || "0px", element.style.height = heightWithoutPadding && heightWithoutPadding - padding.top - padding.bottom + "px" || "0px";
      const { canvas } = this.internalProps;
      widthP = (null !== (_c = null === (_b = canvas.parentElement) || void 0 === _b ? void 0 : _b.offsetWidth) && void 0 !== _c ? _c : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), heightP = (null !== (_e = null === (_d = canvas.parentElement) || void 0 === _d ? void 0 : _d.offsetHeight) && void 0 !== _e ? _e : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), (null === (_f = null == this ? void 0 : this.scenegraph) || void 0 === _f ? void 0 : _f.stage) ? (null === (_g = this.options) || void 0 === _g ? void 0 : _g.viewBox) && !(null === (_h = this.options) || void 0 === _h ? void 0 : _h.canvas) && this.scenegraph.stage.resize(widthP, heightP) : (canvas.style.width = "", canvas.style.height = "", canvas.width = widthP, canvas.height = heightP, canvas.style.width = `${widthP}px`, canvas.style.height = `${heightP}px`), (null === (_j = this.options) || void 0 === _j ? void 0 : _j.viewBox) && (widthP = this.options.viewBox.x2 - this.options.viewBox.x1, heightP = this.options.viewBox.y2 - this.options.viewBox.y1), (null === (_k = null == this ? void 0 : this.scenegraph) || void 0 === _k ? void 0 : _k.stage) && (this.options.viewBox ? this.scenegraph.stage.setViewBox(this.options.viewBox, false) : this.scenegraph.stage.resize(widthP, heightP));
    } else "node" === Env.mode && (widthP = this.canvasWidth - 1, heightP = this.canvasHeight - 1);
    const width = Math.floor(widthP - getVerticalScrollBarSize(this.getTheme().scrollStyle)), height = Math.floor(heightP - getHorizontalScrollBarSize(this.getTheme().scrollStyle));
    if (null === (_l = this.internalProps.theme) || void 0 === _l ? void 0 : _l.frameStyle) {
      const lineWidths = toBoxArray2(null !== (_o = null === (_m = this.internalProps.theme.frameStyle) || void 0 === _m ? void 0 : _m.borderLineWidth) && void 0 !== _o ? _o : [null]), shadowWidths = toBoxArray2(null !== (_q = null === (_p = this.internalProps.theme.frameStyle) || void 0 === _p ? void 0 : _p.shadowBlur) && void 0 !== _q ? _q : [0]);
      (null === (_r = this.theme.frameStyle) || void 0 === _r ? void 0 : _r.innerBorder) ? (this.tableX = 0, this.tableY = 0, this.tableNoFrameWidth = width - (null !== (_s = shadowWidths[1]) && void 0 !== _s ? _s : 0), this.tableNoFrameHeight = height - (null !== (_t = shadowWidths[2]) && void 0 !== _t ? _t : 0)) : (this.tableX = (null !== (_u = lineWidths[3]) && void 0 !== _u ? _u : 0) + (null !== (_v = shadowWidths[3]) && void 0 !== _v ? _v : 0), this.tableY = (null !== (_w = lineWidths[0]) && void 0 !== _w ? _w : 0) + (null !== (_x = shadowWidths[0]) && void 0 !== _x ? _x : 0), this.tableNoFrameWidth = width - ((null !== (_y = lineWidths[1]) && void 0 !== _y ? _y : 0) + (null !== (_z = shadowWidths[1]) && void 0 !== _z ? _z : 0)) - ((null !== (_0 = lineWidths[3]) && void 0 !== _0 ? _0 : 0) + (null !== (_1 = shadowWidths[3]) && void 0 !== _1 ? _1 : 0)), this.tableNoFrameHeight = height - ((null !== (_2 = lineWidths[0]) && void 0 !== _2 ? _2 : 0) + (null !== (_3 = shadowWidths[0]) && void 0 !== _3 ? _3 : 0)) - ((null !== (_4 = lineWidths[2]) && void 0 !== _4 ? _4 : 0) + (null !== (_5 = shadowWidths[2]) && void 0 !== _5 ? _5 : 0)));
    }
    this._clearColRangeWidthsMap(), this._clearRowRangeHeightsMap();
  }
  updateViewBox(newViewBox) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const oldWidth = (null !== (_c = null === (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.viewBox) || void 0 === _b ? void 0 : _b.x2) && void 0 !== _c ? _c : 0) - (null !== (_f = null === (_e = null === (_d = this.options) || void 0 === _d ? void 0 : _d.viewBox) || void 0 === _e ? void 0 : _e.x1) && void 0 !== _f ? _f : 0), oldHeight = (null !== (_j = null === (_h = null === (_g = this.options) || void 0 === _g ? void 0 : _g.viewBox) || void 0 === _h ? void 0 : _h.y2) && void 0 !== _j ? _j : 0) - (null !== (_m = null === (_l = null === (_k = this.options) || void 0 === _k ? void 0 : _k.viewBox) || void 0 === _l ? void 0 : _l.y1) && void 0 !== _m ? _m : 0), newWidth = newViewBox.x2 - newViewBox.x1, newHeight = newViewBox.y2 - newViewBox.y1;
    this.options.viewBox = newViewBox, oldWidth !== newWidth || oldHeight !== newHeight ? this.resize() : this.scenegraph.stage.setViewBox(this.options.viewBox, true);
  }
  setViewBoxTransform(a2, b, c2, d, e, f) {
    this.internalProps.modifiedViewBoxTransform = true, this.scenegraph.stage.window.setViewBoxTransform(a2, b, c2, d, e, f);
  }
  get rowHierarchyType() {
    return this.dataSource.rowHierarchyType;
  }
  getColsWidth(startCol, endCol) {
    var _a;
    if (startCol > endCol) return 0;
    startCol = Math.max(startCol, 0), endCol = Math.min(endCol, (null !== (_a = this.colCount) && void 0 !== _a ? _a : 1 / 0) - 1);
    const cachedColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol}`);
    if (null != cachedColWidth) return cachedColWidth;
    const cachedLowerColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol - 1}`);
    if (null != cachedLowerColWidth) {
      const addWidth = cachedLowerColWidth + this.getColWidth(endCol);
      return startCol >= 0 && endCol >= 0 && !Number.isNaN(addWidth) && this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(addWidth)), Math.round(addWidth);
    }
    let w = 0;
    for (let col = startCol; col <= endCol; col++) w += this.getColWidth(col);
    return startCol >= 0 && endCol >= 0 && this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(w)), Math.round(w);
  }
  getRowHeight(row) {
    var _a;
    if (isValid_default(this.rowHeightsMap.get(row))) {
      if (null === (_a = this.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) {
        const height = this.rowHeightsMap.get(row);
        let heightRange;
        return heightRange = row < this.frozenRowCount ? this.rowHeightsMap.getSumInRange(0, row) : row >= this.rowCount - this.bottomFrozenRowCount ? this.rowHeightsMap.getSumInRange(row, this.rowCount - 1) : this.rowHeightsMap.getSumInRange(this.frozenRowCount, row), heightRange = Number(heightRange.toFixed(2)), Number.isInteger(heightRange) ? Math.ceil(height) : Math.floor(height);
      }
      return this.rowHeightsMap.get(row);
    }
    const defaultHeight = this.getDefaultRowHeight(row);
    return isNumber_default(defaultHeight) ? defaultHeight : this.defaultRowHeight;
  }
  getDefaultColumnWidth(col) {
    var _a, _b;
    return this.isRowHeader(col, 0) || this.isCornerHeader(col, 0) ? Array.isArray(this.defaultHeaderColWidth) ? null !== (_a = this.defaultHeaderColWidth[col]) && void 0 !== _a ? _a : this.defaultColWidth : this.defaultHeaderColWidth : this.isRightFrozenColumn(col, this.columnHeaderLevelCount) && this.isPivotTable() ? Array.isArray(this.defaultHeaderColWidth) ? null !== (_b = this.defaultHeaderColWidth[this.rowHeaderLevelCount - this.rightFrozenColCount]) && void 0 !== _b ? _b : this.defaultColWidth : this.defaultHeaderColWidth : this.defaultColWidth;
  }
  getDefaultRowHeight(row) {
    var _a, _b;
    return this.isColumnHeader(0, row) || this.isCornerHeader(0, row) || this.isSeriesNumberInHeader(0, row) ? Array.isArray(this.defaultHeaderRowHeight) ? null !== (_a = this.defaultHeaderRowHeight[row]) && void 0 !== _a ? _a : this.internalProps.defaultRowHeight : this.defaultHeaderRowHeight : this.isBottomFrozenRow(row) ? Array.isArray(this.defaultHeaderRowHeight) ? null !== (_b = this.defaultHeaderRowHeight[this.columnHeaderLevelCount > 0 ? this.columnHeaderLevelCount - this.bottomFrozenRowCount : 0]) && void 0 !== _b ? _b : this.internalProps.defaultRowHeight : this.defaultHeaderRowHeight : this.internalProps.defaultRowHeight;
  }
  _setRowHeight(row, height, clearCache) {
    var _a;
    this.rowHeightsMap.put(row, (null === (_a = this.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? height : Math.round(height)), clearCache && this._clearRowRangeHeightsMap(row);
  }
  setRowHeight(row, height) {
    this.scenegraph.setRowHeight(row, height), this.scenegraph.updateChartSizeForResizeRowHeight(row), this.internalProps._heightResizedRowMap.add(row);
  }
  getRowsHeight(startRow, endRow) {
    var _a, _b;
    if (startRow > endRow || 0 === this.rowCount) return 0;
    startRow = Math.max(startRow, 0), endRow = Math.min(endRow, (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 1 / 0) - 1);
    let h = 0;
    const isDefaultRowHeightIsAuto = "auto" === this.options.defaultRowHeight;
    if ("standard" !== this.heightMode || this.options.customComputeRowHeight || this.autoFillHeight || !this.internalProps.layoutMap || this.hasAutoImageColumn() || isDefaultRowHeightIsAuto || 0 !== this.internalProps._heightResizedRowMap.size) {
      if (null === (_b = this.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) {
        const tempH = this.rowHeightsMap.getSumInRange(startRow, endRow);
        let heightRange;
        return heightRange = endRow < this.frozenRowCount ? this.rowHeightsMap.getSumInRange(0, endRow) : endRow >= this.rowCount - this.bottomFrozenRowCount ? this.rowHeightsMap.getSumInRange(endRow, this.rowCount - 1) : this.rowHeightsMap.getSumInRange(this.frozenRowCount, endRow), heightRange = Number(heightRange.toFixed(2)), Number.isInteger(heightRange) ? Math.ceil(tempH) : Math.floor(tempH);
      }
      h = this.rowHeightsMap.getSumInRange(startRow, endRow);
    } else {
      for (let i = startRow; i < Math.min(endRow + 1, this.columnHeaderLevelCount); i++) h += this.getRowHeight(i);
      endRow >= this.columnHeaderLevelCount && (h += this.defaultRowHeight * (Math.min(endRow, this.rowCount - this.bottomFrozenRowCount - 1) - Math.max(this.columnHeaderLevelCount, startRow) + 1));
      for (let i = this.rowCount - this.bottomFrozenRowCount; i < endRow + 1; i++) h += this.getRowHeight(i);
    }
    return Math.round(h);
  }
  getColWidthDefined(col) {
    var _a;
    const { layoutMap } = this.internalProps;
    if ("autoWidth" === this.widthMode) return "auto";
    const { width } = null !== (_a = null == layoutMap ? void 0 : layoutMap.getColumnWidthDefined(col)) && void 0 !== _a ? _a : {};
    return "number" == typeof width && width <= 0 ? 0 : width || this.getDefaultColumnWidth(col);
  }
  getColWidthDefinedNumber(col) {
    const width = this.getColWidthDefined(col);
    return this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
  }
  isAutoRowHeight(row) {
    return "autoHeight" === this.heightMode || (!!this.options.customComputeRowHeight || (row >= 0 && row < this.columnHeaderLevelCount ? "auto" === this.getDefaultRowHeight(row) : "auto" === this.internalProps.defaultRowHeight));
  }
  getColWidth(col) {
    var _a;
    const width = null !== (_a = this.colWidthsMap.get(col)) && void 0 !== _a ? _a : this.getDefaultColumnWidth(col);
    return "adaptive" === this.widthMode && "number" == typeof width || this.transpose && "number" == typeof width ? this._colWidthDefineToPxWidth(width) : this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
  }
  _setColWidth(col, width, clearCache, skipCheckFrozen) {
    this.colWidthsMap.put(col, "number" == typeof width ? Math.round(width) : width), clearCache && this._clearColRangeWidthsMap(col), skipCheckFrozen || this.stateManager.checkFrozen();
  }
  setColWidth(col, width) {
    this.scenegraph.setColWidth(col, width), this.scenegraph.updateChartSizeForResizeColWidth(col), this.internalProps._widthResizedColMap.add(col);
  }
  _clearColRangeWidthsMap(col) {
    if ("number" != typeof col) this._colRangeWidthsMap.clear();
    else {
      const keys2 = this._colRangeWidthsMap.keys();
      for (const key of keys2) {
        const reg = rangeReg.exec(key);
        if (reg) {
          const start = Number(reg[1]), end = Number(reg[2]);
          col >= start && col <= end && this._colRangeWidthsMap.delete(key);
        }
      }
    }
  }
  _clearRowRangeHeightsMap(row) {
    this.rowHeightsMap.clearRange();
  }
  _getColContentWidth(col) {
    return Number(this.colContentWidthsMap.get(col));
  }
  _setColContentWidth(col, width) {
    this.colContentWidthsMap.put(col, width);
  }
  getAllRowsHeight() {
    if (this.internalProps.rowCount <= 0) return 0;
    return this.getRowsHeight(0, this.internalProps.rowCount - 1);
  }
  getAllColsWidth() {
    if (this.internalProps.colCount <= 0) return 0;
    return this.getColsWidth(0, this.internalProps.colCount - 1);
  }
  getColsWidths() {
    const maxCount = this.colCount, widths = [];
    for (let col = 0; col < maxCount; col++) widths.push(this.getColWidth(col));
    return widths;
  }
  getMaxColWidth(col) {
    var _a;
    const obj2 = this.colWidthsLimit[col];
    let max2 = null !== (_a = obj2 && obj2.max) && void 0 !== _a ? _a : 1 / 0;
    return "string" == typeof max2 && (max2 = _toPxWidth(this, max2)), max2;
  }
  setMaxColWidth(col, maxwidth) {
    (this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {})).max = maxwidth;
  }
  getMinColWidth(col) {
    var _a;
    const obj2 = this.colWidthsLimit[col];
    let min2 = null !== (_a = obj2 && obj2.min) && void 0 !== _a ? _a : 0;
    return "string" == typeof min2 && (min2 = _toPxWidth(this, min2)), min2;
  }
  setMinColWidth(col, minwidth) {
    (this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {})).min = minwidth;
  }
  getCellRect(col, row) {
    var _a, _b;
    const isFrozenCell = this.isFrozenCell(col, row);
    let absoluteLeft;
    const width = this.getColWidth(col);
    let absoluteTop;
    absoluteLeft = isFrozenCell && isFrozenCell.col && this.isRightFrozenColumn(col, row) ? this.getAllColsWidth() <= this.tableNoFrameWidth ? this.getColsWidth(0, col - 1) || 0 : this.tableNoFrameWidth - (null !== (_a = this.getColsWidth(col, this.colCount - 1)) && void 0 !== _a ? _a : 0) : this.getColsWidth(0, col - 1) || 0;
    const height = this.getRowHeight(row);
    return absoluteTop = isFrozenCell && isFrozenCell.row && this.isBottomFrozenRow(col, row) ? this.getAllRowsHeight() <= this.tableNoFrameHeight ? this.getRowsHeight(0, row - 1) : this.tableNoFrameHeight - (null !== (_b = this.getRowsHeight(row, this.rowCount - 1)) && void 0 !== _b ? _b : 0) : this.getRowsHeight(0, row - 1), new Rect2(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
  }
  getMergeCellRect(col, row) {
    const cellRange = this.getCellRange(col, row), absoluteLeft = this.getColsWidth(0, cellRange.start.col - 1) || 0, width = this.getColsWidth(cellRange.start.col, cellRange.end.col), absoluteTop = this.getRowsHeight(0, cellRange.start.row - 1) || 0, height = this.getRowsHeight(cellRange.start.row, cellRange.end.row);
    return new Rect2(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
  }
  getCellRelativeRect(col, row) {
    const isFrozenCell = this.isFrozenCell(col, row);
    let relativeX = true, relativeY = true;
    (null == isFrozenCell ? void 0 : isFrozenCell.col) && (null == isFrozenCell ? void 0 : isFrozenCell.row) ? (relativeX = false, relativeY = false) : (null == isFrozenCell ? void 0 : isFrozenCell.col) ? relativeX = false : (null == isFrozenCell ? void 0 : isFrozenCell.row) && (relativeY = false);
    const cellRect = this.getCellRect(col, row);
    return this._toRelativeRect(cellRect, relativeX, relativeY);
  }
  getCellRangeRelativeRect(range5) {
    if (range5.start) {
      const isFrozenCell2 = this.isFrozenCell(range5.start.col, range5.start.row);
      let relativeX2 = true, relativeY2 = true;
      return (null == isFrozenCell2 ? void 0 : isFrozenCell2.col) && (null == isFrozenCell2 ? void 0 : isFrozenCell2.row) ? (relativeX2 = false, relativeY2 = false) : (null == isFrozenCell2 ? void 0 : isFrozenCell2.col) ? relativeX2 = false : (null == isFrozenCell2 ? void 0 : isFrozenCell2.row) && (relativeY2 = false), this._toRelativeRect(this.getCellsRect(range5.start.col, range5.start.row, range5.end.col, range5.end.row), relativeX2, relativeY2);
    }
    const cellRange = this.getCellRange(range5.col, range5.row), isFrozenCell = this.isFrozenCell(range5.col, range5.row);
    let relativeX = true, relativeY = true;
    return (null == isFrozenCell ? void 0 : isFrozenCell.col) && (null == isFrozenCell ? void 0 : isFrozenCell.row) ? (relativeX = false, relativeY = false) : (null == isFrozenCell ? void 0 : isFrozenCell.col) ? relativeX = false : (null == isFrozenCell ? void 0 : isFrozenCell.row) && (relativeY = false), this._toRelativeRect(this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row), relativeX, relativeY);
  }
  getVisibleCellRangeRelativeRect(range5) {
    let cellRange;
    return cellRange = range5.start ? range5 : this.getCellRange(range5.col, range5.row), this._getVisiableRect(this.getCellRangeRelativeRect(range5), cellRange);
  }
  _getVisiableRect(relativeRectObj, cellRange) {
    const targetLeft = cellRange.start.col >= this.frozenColCount ? Math.max(relativeRectObj.left, this.frozenColCount >= 1 ? this.getColsWidth(0, this.frozenColCount - 1) : 0) : relativeRectObj.left, targetRight = Math.min(relativeRectObj.right, this.tableNoFrameWidth), rect = relativeRectObj.copy();
    rect.left = targetLeft, rect.right = targetRight;
    const targetTop = cellRange.start.row >= this.frozenRowCount ? Math.max(relativeRectObj.top, this.frozenRowCount >= 1 ? this.getRowsHeight(0, this.frozenRowCount - 1) : 0) : relativeRectObj.top, targetBottom = Math.min(relativeRectObj.bottom, this.tableNoFrameHeight);
    return rect.top = targetTop, rect.bottom = targetBottom, rect;
  }
  getCellsRect(startCol, startRow, endCol, endRow) {
    var _a, _b, _c, _d, _e, _f;
    let absoluteLeft = this.getColsWidth(0, startCol - 1) || 0, width = this.getColsWidth(startCol, endCol);
    const scrollLeft = this.scrollLeft, tableWidth = Math.min(this.tableNoFrameWidth, this.getAllColsWidth()), tableHeight = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
    this.isLeftFrozenColumn(startCol) && this.isRightFrozenColumn(endCol) ? width = this.tableNoFrameWidth - (null !== (_a = this.getColsWidth(startCol + 1, this.colCount - 1)) && void 0 !== _a ? _a : 0) - absoluteLeft : this.isLeftFrozenColumn(startCol) && !this.isLeftFrozenColumn(endCol) ? width = Math.max(width - scrollLeft, this.getColsWidth(startCol, this.frozenColCount - 1)) : !this.isRightFrozenColumn(startCol) && this.isRightFrozenColumn(endCol) ? (absoluteLeft = Math.min(absoluteLeft - scrollLeft, tableWidth - this.getRightFrozenColsWidth()), width = tableWidth - (null !== (_b = this.getColsWidth(startCol + 1, this.colCount - 1)) && void 0 !== _b ? _b : 0) - absoluteLeft) : this.isRightFrozenColumn(startCol) && (absoluteLeft = tableWidth - (null !== (_c = this.getColsWidth(startCol, this.colCount - 1)) && void 0 !== _c ? _c : 0));
    let absoluteTop = this.getRowsHeight(0, startRow - 1), height = this.getRowsHeight(startRow, endRow);
    const scrollTop = this.scrollTop;
    return this.isTopFrozenRow(startRow) && this.isBottomFrozenRow(endRow) ? height = this.tableNoFrameHeight - (null !== (_d = this.getRowsHeight(startRow + 1, this.rowCount - 1)) && void 0 !== _d ? _d : 0) - absoluteTop : this.isTopFrozenRow(startRow) && !this.isTopFrozenRow(endRow) ? height = Math.max(height - scrollTop, this.getRowsHeight(startRow, this.frozenRowCount - 1)) : !this.isBottomFrozenRow(startRow) && this.isBottomFrozenRow(endRow) ? (absoluteTop = Math.min(absoluteTop - scrollTop, tableHeight - this.getBottomFrozenRowsHeight()), height = tableHeight - (null !== (_e = this.getRowsHeight(startRow + 1, this.rowCount - 1)) && void 0 !== _e ? _e : 0) - absoluteTop) : this.isBottomFrozenRow(startRow) && (absoluteTop = tableHeight - (null !== (_f = this.getRowsHeight(startRow, this.rowCount - 1)) && void 0 !== _f ? _f : 0)), new Rect2(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
  }
  getCellsRectWidth(startCol, startRow, endCol, endRow) {
    const isFrozenStartCell = this.isFrozenCell(startCol, startRow), isFrozenEndCell = this.isFrozenCell(endCol, endRow);
    let width = this.getColsWidth(startCol, endCol);
    if (isFrozenStartCell && isFrozenStartCell.col) {
      const scrollLeft = this.scrollLeft;
      isFrozenEndCell && isFrozenEndCell.col || (width -= scrollLeft, width = Math.max(width, this.getColsWidth(startCol, this.frozenColCount - 1)));
    }
    return width;
  }
  getCellRangeRect(range5) {
    if (range5.start) return this.getCellsRect(range5.start.col, range5.start.row, range5.end.col, range5.end.row);
    const cellRange = this.getCellRange(range5.col, range5.row);
    return this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
  }
  getCellRangeRectWidth(range5) {
    if (range5.start) return this.getCellsRectWidth(range5.start.col, range5.start.row, range5.end.col, range5.end.row);
    const cellRange = this.getCellRange(range5.col, range5.row);
    return this.getCellsRectWidth(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
  }
  isFrozenCell(col, row) {
    const isFrozenRow = this.isFrozenRow(row), isFrozenCol = this.isFrozenColumn(col);
    return isFrozenRow || isFrozenCol ? {
      row: isFrozenRow,
      col: isFrozenCol
    } : null;
  }
  getRowAt(absoluteY) {
    return getRowAt(absoluteY, this);
  }
  getColAt(absoluteX) {
    return getColAt(absoluteX, this);
  }
  getCellAt(absoluteX, absoluteY) {
    return getCellAt(absoluteX, absoluteY, this);
  }
  getCellAtRelativePosition(relativeX, relativeY) {
    return getCellAtRelativePosition(relativeX, relativeY, this);
  }
  _checkRowCol(col, row) {
    return col >= 0 && col < this.colCount && row >= 0 && row < this.rowCount;
  }
  _makeVisibleCell(col, row) {
    if (this._checkRowCol(col, row)) {
      const isFrozenCell = this.isFrozenCell(col, row);
      if (isFrozenCell && isFrozenCell.col && isFrozenCell.row) return;
      const rect = this.getCellRect(col, row), visibleRect = _getScrollableVisibleRect(this);
      if (visibleRect.contains(rect)) return;
      isFrozenCell && isFrozenCell.col || this.getColsWidth(0, this.frozenColCount - 1) + rect.width > this.canvas.width || (rect.left < visibleRect.left ? this.scrollLeft -= visibleRect.left - rect.left : visibleRect.right < rect.right && (this.scrollLeft -= visibleRect.right - rect.right)), isFrozenCell && isFrozenCell.row || this.getRowsHeight(0, this.frozenRowCount - 1) + rect.height > this.canvas.height || (rect.top < visibleRect.top ? this.scrollTop -= visibleRect.top - rect.top : visibleRect.bottom < rect.bottom && (this.scrollTop -= visibleRect.bottom - rect.bottom));
    }
  }
  render() {
    this.scenegraph.renderSceneGraph();
  }
  renderAsync() {
    return this.scenegraph.updateNextFrame(), new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve();
      }, 0);
    });
  }
  _toRelativeRect(absoluteRect, relativeX = true, relativeY = true) {
    var _a, _b, _c, _d;
    const rect = absoluteRect.copy(), visibleRect = this.getVisibleRect();
    return rect.offsetLeft(this.tableX - (relativeX ? visibleRect.left : 0)), rect.offsetTop(this.tableY - (relativeY ? visibleRect.top : 0)), rect.offsetLeft(null !== (_b = null === (_a = this.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0), rect.offsetTop(null !== (_d = null === (_c = this.options.viewBox) || void 0 === _c ? void 0 : _c.y1) && void 0 !== _d ? _d : 0), rect;
  }
  getVisibleRect() {
    const { scrollTop, scrollLeft } = this, width = this.tableNoFrameWidth, height = this.tableNoFrameHeight;
    return new Rect2(scrollLeft, scrollTop, width, height);
  }
  get visibleRowCount() {
    const { frozenRowCount } = this, visibleRect = this.getVisibleRect(), visibleTop = frozenRowCount > 0 ? visibleRect.top + this.getRowsHeight(0, frozenRowCount - 1) : visibleRect.top, initRow = this.getTargetRowAt(visibleTop);
    if (!initRow) return 0;
    const startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);
    let absoluteTop = this.getRowsHeight(0, startRow - 1), count = 0;
    const { rowCount } = this;
    for (let row = startRow; row < rowCount; row++) {
      const bottom = absoluteTop + this.getRowHeight(row);
      if (visibleRect.bottom < bottom) break;
      count++, absoluteTop = bottom;
    }
    return count;
  }
  getBodyVisibleCellRange() {
    const { scrollTop, scrollLeft } = this, frozenRowsHeight = this.getFrozenRowsHeight(), frozenColsWidth = this.getFrozenColsWidth(), bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight(), rightFrozenColsWidth = this.getRightFrozenColsWidth(), { row: rowStart } = this.getRowAt(scrollTop + frozenRowsHeight + 1), { col: colStart } = this.getColAt(scrollLeft + frozenColsWidth + 1), rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row : this.rowCount - 1, colEnd = this.getAllColsWidth() > this.tableNoFrameWidth ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col : this.colCount - 1;
    return colEnd < 0 || rowEnd < 0 ? null : {
      rowStart,
      colStart,
      rowEnd,
      colEnd
    };
  }
  getBodyVisibleRowRange() {
    const { scrollTop } = this, frozenRowsHeight = this.getFrozenRowsHeight(), bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight(), { row: rowStart } = this.getRowAt(scrollTop + frozenRowsHeight + 1), rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row : this.rowCount - 1;
    return rowEnd < 0 ? null : {
      rowStart,
      rowEnd
    };
  }
  getBodyVisibleColRange() {
    const { scrollLeft } = this, frozenColsWidth = this.getFrozenColsWidth(), rightFrozenColsWidth = this.getRightFrozenColsWidth(), { col: colStart } = this.getColAt(scrollLeft + frozenColsWidth + 1), colEnd = this.getAllColsWidth() > this.tableNoFrameWidth ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col : this.colCount - 1;
    return colEnd < 0 ? null : {
      colStart,
      colEnd
    };
  }
  get visibleColCount() {
    const { frozenColCount } = this, visibleRect = this.getVisibleRect(), visibleLeft = frozenColCount > 0 ? visibleRect.left + this.getColsWidth(0, frozenColCount - 1) : visibleRect.left, initCol = this.getTargetColAt(visibleLeft);
    if (!initCol) return 0;
    const startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);
    let absoluteLeft = this.getColsWidth(0, startCol - 1), count = 0;
    const { colCount } = this;
    for (let col = startCol; col < colCount; col++) {
      const right = absoluteLeft + this.getColWidth(col);
      if (visibleRect.right < right) break;
      count++, absoluteLeft = right;
    }
    return count;
  }
  get scrollTop() {
    return this.stateManager.scroll.verticalBarPos;
  }
  set scrollTop(scrollTop) {
    this.stateManager.setScrollTop(scrollTop);
  }
  get scrollLeft() {
    return this.stateManager.scroll.horizontalBarPos;
  }
  set scrollLeft(scrollLeft) {
    this.stateManager.setScrollLeft(scrollLeft);
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  getScrollTop() {
    return this.scrollTop;
  }
  setScrollLeft(num) {
    this.scrollLeft = Math.ceil(num);
  }
  setScrollTop(num) {
    this.scrollTop = Math.ceil(num);
  }
  getCellOverflowText(col, row) {
    return this.scenegraph.getCellOverflowText(col, row);
  }
  addReleaseObj(releaseObj) {
    if (!releaseObj || !releaseObj.release || "function" != typeof releaseObj.release) throw new Error("not releaseObj!");
    (this.internalProps.releaseList = this.internalProps.releaseList || []).push(releaseObj);
  }
  dispose() {
    this.release();
  }
  release() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const internalProps = this.internalProps;
    if (this.isReleased) return;
    null === (_b = null === (_a = internalProps.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), null === (_d = null === (_c = internalProps.menuHandler) || void 0 === _c ? void 0 : _c.release) || void 0 === _d || _d.call(_c), null === (_e = super.release) || void 0 === _e || _e.call(this), null === (_g = null === (_f = internalProps.handler) || void 0 === _f ? void 0 : _f.release) || void 0 === _g || _g.call(_f), this.eventManager.release(), null === (_j = null === (_h = internalProps.focusControl) || void 0 === _h ? void 0 : _h.release) || void 0 === _j || _j.call(_h), null === (_k = internalProps.legends) || void 0 === _k || _k.forEach((legend) => {
      null == legend || legend.release();
    }), null === (_l = internalProps.title) || void 0 === _l || _l.release(), internalProps.title = null, null === (_m = internalProps.emptyTip) || void 0 === _m || _m.release(), internalProps.emptyTip = null, internalProps.layoutMap.release(), internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj) => {
      var _a2;
      return null === (_a2 = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a2 ? void 0 : _a2.call(releaseObj);
    }), internalProps.releaseList = null), this.scenegraph.stage.release(), this.scenegraph.proxy.release(), internalProps.focusControl.release();
    const { parentElement } = internalProps.element;
    parentElement && !this.options.canvas && parentElement.removeChild(internalProps.element), null === (_q = null === (_p = null === (_o = this.editorManager) || void 0 === _o ? void 0 : _o.editingEditor) || void 0 === _p ? void 0 : _p.onEnd) || void 0 === _q || _q.call(_p), this.isReleased = true, this.scenegraph = null, this.internalProps = null, null === (_r = this.reactCustomLayout) || void 0 === _r || _r.clearCache(), this.pluginManager.release(), clearChartRenderQueue();
  }
  fireListeners(type, event2) {
    return super.fireListeners(type, event2);
  }
  updateOption(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    null === (_a = this.editorManager) || void 0 === _a || _a.cancelEdit(), this.options = options, this._hasAutoImageColumn = void 0;
    const { frozenColCount = 0, unfreezeAllOnExceedsMaxWidth, defaultRowHeight = 40, defaultHeaderRowHeight, defaultColWidth = 80, defaultHeaderColWidth = 80, keyboardOptions, eventOptions, rowSeriesNumber, columnResizeMode, rowResizeMode = "none", resize, dragHeaderMode, dragOrder, showFrozenIcon, allowFrozenColCount, padding, hover, menu, select: click, pixelRatio, widthMode, heightMode, autoFillWidth, autoFillHeight, widthAdaptiveMode, heightAdaptiveMode, customRender, renderChartAsync, renderChartAsyncBatchCount, canvasWidth, canvasHeight, overscrollBehavior, limitMinWidth, limitMinHeight } = options;
    pixelRatio && pixelRatio !== this.internalProps.pixelRatio && (this.internalProps.pixelRatio = pixelRatio), padding && ("number" == typeof padding ? (this.padding.top = padding, this.padding.left = padding, this.padding.bottom = padding, this.padding.right = padding) : (padding.top && (this.padding.top = padding.top), padding.bottom && (this.padding.bottom = padding.bottom), padding.left && (this.padding.left = padding.left), padding.right && (this.padding.right = padding.right))), this.showFrozenIcon = "boolean" != typeof showFrozenIcon || showFrozenIcon, "number" == typeof allowFrozenColCount && allowFrozenColCount <= 0 && (this.showFrozenIcon = false), this.widthMode = null != widthMode ? widthMode : "standard", this.heightMode = null != heightMode ? heightMode : "standard", this._widthAdaptiveMode = null != widthAdaptiveMode ? widthAdaptiveMode : "only-body", this._heightAdaptiveMode = null != heightAdaptiveMode ? heightAdaptiveMode : "only-body", this.autoFillWidth = null != autoFillWidth && autoFillWidth, this.autoFillHeight = null != autoFillHeight && autoFillHeight, this.customRender = customRender, this.canvasWidth = isNumber_default(canvasWidth) ? canvasWidth : void 0, this.canvasHeight = isNumber_default(canvasHeight) ? canvasHeight : void 0;
    const internalProps = this.internalProps;
    if ("node" === Env.mode || options.canvas || updateRootElementPadding(internalProps.element, this.padding), this.columnWidthComputeMode = null !== (_b = options.columnWidthComputeMode) && void 0 !== _b ? _b : "normal", internalProps.frozenColCount = frozenColCount, internalProps.unfreezeAllOnExceedsMaxWidth = null == unfreezeAllOnExceedsMaxWidth || unfreezeAllOnExceedsMaxWidth, internalProps.defaultRowHeight = defaultRowHeight, internalProps.defaultHeaderRowHeight = null != defaultHeaderRowHeight ? defaultHeaderRowHeight : defaultRowHeight, internalProps.defaultColWidth = defaultColWidth, internalProps.defaultHeaderColWidth = null != defaultHeaderColWidth ? defaultHeaderColWidth : defaultColWidth, internalProps.keyboardOptions = keyboardOptions, internalProps.eventOptions = eventOptions, internalProps.rowSeriesNumber = rowSeriesNumber, internalProps.columnResizeMode = null !== (_c = null == resize ? void 0 : resize.columnResizeMode) && void 0 !== _c ? _c : columnResizeMode, internalProps.rowResizeMode = null !== (_d = null == resize ? void 0 : resize.rowResizeMode) && void 0 !== _d ? _d : rowResizeMode, internalProps.dragHeaderMode = null !== (_f = null !== (_e = null == dragOrder ? void 0 : dragOrder.dragHeaderMode) && void 0 !== _e ? _e : dragHeaderMode) && void 0 !== _f ? _f : "none", internalProps.renderChartAsync = renderChartAsync, setBatchRenderChartCount(renderChartAsyncBatchCount), internalProps.overscrollBehavior = null != overscrollBehavior ? overscrollBehavior : "auto", internalProps.cellTextOverflows = {}, internalProps._rowHeightsMap = new NumberRangeMap(this), internalProps._rowRangeHeightsMap = /* @__PURE__ */ new Map(), internalProps._colRangeWidthsMap = /* @__PURE__ */ new Map(), internalProps._widthResizedColMap = /* @__PURE__ */ new Set(), internalProps._heightResizedRowMap = /* @__PURE__ */ new Set(), this.colWidthsMap = new NumberMap(), this.colContentWidthsMap = new NumberMap(), this.colWidthsLimit = {}, internalProps.stick.changedCells.clear(), internalProps.theme = themes_default.of(null !== (_g = options.theme) && void 0 !== _g ? _g : themes_default.DEFAULT), internalProps.theme.isPivot = this.isPivotTable(), setIconColor(internalProps.theme.functionalIconsStyle), this.scenegraph.updateStageBackground(), internalProps.autoWrapText = options.autoWrapText, internalProps.enableLineBreak = options.enableLineBreak, internalProps.allowFrozenColCount = null !== (_h = options.allowFrozenColCount) && void 0 !== _h ? _h : 0, internalProps.limitMaxAutoWidth = null !== (_j = options.limitMaxAutoWidth) && void 0 !== _j ? _j : 450, internalProps.limitMinWidth = null != limitMinWidth ? "number" == typeof limitMinWidth ? limitMinWidth : limitMinWidth ? 10 : 0 : 10, internalProps.limitMinHeight = null != limitMinHeight ? "number" == typeof limitMinHeight ? limitMinHeight : limitMinHeight ? 10 : 0 : 10, null === (_k = internalProps.legends) || void 0 === _k || _k.forEach((legend) => {
      null == legend || legend.release();
    }), null === (_l = internalProps.title) || void 0 === _l || _l.release(), internalProps.title = null, null === (_m = internalProps.emptyTip) || void 0 === _m || _m.release(), internalProps.emptyTip = null, internalProps.layoutMap.release(), clearChartRenderQueue(), this.scenegraph.clearCells(), this.scenegraph.updateComponent(), this.stateManager.updateOptionSetState(), this._updateSize(), this.eventManager.updateEventBinder(), options.legends) {
      internalProps.legends = [];
      const createLegend2 = Factory2.getFunction("createLegend");
      if (Array.isArray(options.legends)) {
        for (let i = 0; i < options.legends.length; i++) internalProps.legends.push(createLegend2(options.legends[i], this));
        this.scenegraph.tableGroup.setAttributes({
          x: this.tableX,
          y: this.tableY
        });
      } else internalProps.legends.push(createLegend2(options.legends, this)), this.scenegraph.tableGroup.setAttributes({
        x: this.tableX,
        y: this.tableY
      });
    }
    if (internalProps.tooltip = Object.assign({
      parentElement: this.getElement(),
      renderMode: "html",
      isShowOverflowTextTooltip: false,
      confine: true,
      position: Placement.bottom
    }, options.tooltip), "html" === internalProps.tooltip.renderMode && !internalProps.tooltipHandler) {
      const TooltipHandler2 = Factory2.getComponent("tooltipHandler");
      internalProps.tooltipHandler = new TooltipHandler2(this, internalProps.tooltip.confine);
    }
    if (internalProps.menu = Object.assign({
      renderMode: "html"
    }, options.menu), Array.isArray(null === (_o = options.menu) || void 0 === _o ? void 0 : _o.dropDownMenuHighlight) && this.setDropDownMenuHighlight(null === (_p = options.menu) || void 0 === _p ? void 0 : _p.dropDownMenuHighlight), (Array.isArray(null === (_q = options.menu) || void 0 === _q ? void 0 : _q.defaultHeaderMenuItems) || "function" == typeof (null === (_r = options.menu) || void 0 === _r ? void 0 : _r.defaultHeaderMenuItems)) && (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems), "html" === internalProps.menu.renderMode && !internalProps.menuHandler) {
      const MenuHandler3 = Factory2.getComponent("menuHandler");
      internalProps.menuHandler = new MenuHandler3(this);
    }
    this.clearCellStyleCache(), this.clearColWidthCache(), this.clearRowHeightCache(), internalProps.customMergeCell = getCustomMergeCellFunc(options.customMergeCell), null === (_s = this.customCellStylePlugin) || void 0 === _s || _s.updateCustomCell(null !== (_t = options.customCellStyle) && void 0 !== _t ? _t : [], null !== (_u = options.customCellStyleArrangement) && void 0 !== _u ? _u : []), this._adjustCanvasSizeByOption();
  }
  renderWithRecreateCells() {
    this.internalProps.stick.changedCells.clear();
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.render();
  }
  getFrozenRowsHeight() {
    return this.getRowsHeight(0, this.frozenRowCount - 1);
  }
  getFrozenColsWidth() {
    return this.getColsWidth(0, this.frozenColCount - 1);
  }
  getBottomFrozenRowsHeight() {
    if (this.bottomFrozenRowCount > 0) {
      let height = 0;
      for (let row = this.rowCount - this.bottomFrozenRowCount; row <= this.rowCount - 1; row++) height += this.getRowHeight(row);
      return height;
    }
    return 0;
  }
  getRightFrozenColsWidth() {
    if (this.rightFrozenColCount > 0) {
      let width = 0;
      for (let col = this.colCount - this.rightFrozenColCount; col <= this.colCount - 1; col++) width += this.getColWidth(col);
      return width;
    }
    return 0;
  }
  getDrawRange() {
    const width = Math.min(this.tableNoFrameWidth, this.getAllColsWidth()), height = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
    return new Rect2(this.tableX, this.tableY, width, height);
  }
  _getMouseAbstractPoint(evt) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let e;
    if (!evt) return {
      inTable: false,
      x: void 0,
      y: void 0
    };
    e = isTouchEvent3(evt) ? evt.changedTouches[0] : evt;
    const clientX = e.clientX || e.pageX + window.scrollX, clientY = e.clientY || e.pageY + window.scrollY, rect = this.internalProps.canvas.getBoundingClientRect();
    let inTable = true;
    rect.right <= clientX && (inTable = false), rect.bottom <= clientY && (inTable = false);
    const currentWidth = rect.width, widthRatio = currentWidth / ((90 === this.rotateDegree ? this.canvas.offsetHeight : this.canvas.offsetWidth) || currentWidth), currentHeight = rect.height, heightRatio = currentHeight / ((90 === this.rotateDegree ? this.canvas.offsetWidth : this.canvas.offsetHeight) || currentHeight), rotateTablePlugin = this.pluginManager.getPluginByName("Rotate Table");
    if (rotateTablePlugin && 90 === this.rotateDegree) {
      const point6 = {
        x: clientX / widthRatio - (null !== (_b = null === (_a = this.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0),
        y: clientY / heightRatio - (null !== (_d = null === (_c = this.options.viewBox) || void 0 === _c ? void 0 : _c.y1) && void 0 !== _d ? _d : 0),
        inTable
      };
      return rotateTablePlugin.matrix.transformPoint(point6, point6), point6;
    }
    const point5 = {
      x: (clientX - rect.left) / widthRatio - (null !== (_f = null === (_e = this.options.viewBox) || void 0 === _e ? void 0 : _e.x1) && void 0 !== _f ? _f : 0),
      y: (clientY - rect.top) / heightRatio - (null !== (_h = null === (_g = this.options.viewBox) || void 0 === _g ? void 0 : _g.y1) && void 0 !== _h ? _h : 0),
      inTable
    };
    if (this.internalProps.modifiedViewBoxTransform && this.scenegraph.stage.window.getViewBoxTransform()) {
      return this.scenegraph.stage.window.getViewBoxTransform().transformPoint(point5, point5), point5;
    }
    return point5;
  }
  getTheme() {
    return this.internalProps.theme;
  }
  getTargetColAt(absoluteX) {
    return getTargetColAt(absoluteX, this);
  }
  getTargetRowAt(absoluteY) {
    const targetRow = getTargetRowAt(absoluteY, this);
    return targetRow && (targetRow.row = Math.min(targetRow.row, this.rowCount - 1)), targetRow;
  }
  getTargetColAtConsiderRightFrozen(absoluteX, isConsider) {
    return getTargetColAtConsiderRightFrozen(absoluteX, isConsider, this);
  }
  getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider) {
    return getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider, this);
  }
  clearSelected() {
    this.stateManager.updateSelectPos(-1, -1);
  }
  selectCell(col, row, isShift, isCtrl, makeSelectCellVisible, skipBodyMerge = false) {
    var _a, _b, _c;
    const isHasSelected = !!(null === (_a = this.stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
    this.stateManager.updateSelectPos(col, row, isShift, isCtrl, false, null === (_c = null != makeSelectCellVisible ? makeSelectCellVisible : null === (_b = this.options.select) || void 0 === _b ? void 0 : _b.makeSelectCellVisible) || void 0 === _c || _c, skipBodyMerge), this.stateManager.endSelectCells(true, isHasSelected);
  }
  selectCells(cellRanges) {
    const { scrollLeft, scrollTop } = this;
    cellRanges.forEach((cellRange, index) => {
      var _a, _b, _c, _d, _e, _f;
      cellRange.start.col === cellRange.end.col && cellRange.start.row === cellRange.end.row ? this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, false, index >= 1, false, null === (_b = null === (_a = this.options.select) || void 0 === _a ? void 0 : _a.makeSelectCellVisible) || void 0 === _b || _b, true) : (this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, false, index >= 1, false, null === (_d = null === (_c = this.options.select) || void 0 === _c ? void 0 : _c.makeSelectCellVisible) || void 0 === _d || _d, true), this.stateManager.updateInteractionState(InteractionState.grabing), this.stateManager.updateSelectPos(cellRange.end.col, cellRange.end.row, false, index >= 1, false, null === (_f = null === (_e = this.options.select) || void 0 === _e ? void 0 : _e.makeSelectCellVisible) || void 0 === _f || _f, true)), this.stateManager.endSelectCells(false, false), this.stateManager.updateInteractionState(InteractionState.default);
    }), this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft);
  }
  get recordsCount() {
    var _a;
    return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
  }
  get allowFrozenColCount() {
    return this.internalProps.allowFrozenColCount;
  }
  get rowHeaderLevelCount() {
    return this.internalProps.layoutMap.rowHeaderLevelCount;
  }
  get columnHeaderLevelCount() {
    return this.internalProps.layoutMap.columnHeaderLevelCount;
  }
  get records() {
    return this.internalProps.records;
  }
  get dataSource() {
    return this.internalProps.dataSource;
  }
  set dataSource(dataSource) {
    this.scenegraph.clearCells(), _setDataSource(this, dataSource), this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render();
  }
  get autoWrapText() {
    return this.internalProps.autoWrapText;
  }
  set autoWrapText(autoWrapText) {
    this.internalProps.autoWrapText = autoWrapText, this.options.autoWrapText = autoWrapText;
  }
  get enableLineBreak() {
    return this.internalProps.enableLineBreak;
  }
  set enableLineBreak(enableLineBreak) {
    this.internalProps.enableLineBreak = enableLineBreak, this.options.enableLineBreak = enableLineBreak;
  }
  updateAutoWrapText(autoWrapText) {
    this.internalProps.autoWrapText !== autoWrapText && (this.internalProps.autoWrapText = autoWrapText, this.options.autoWrapText = autoWrapText, this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.render());
  }
  get theme() {
    return this.internalProps.theme;
  }
  set theme(theme4) {
    this.internalProps.theme = themes_default.of(null != theme4 ? theme4 : themes_default.DEFAULT), this.internalProps.theme.isPivot = this.isPivotTable(), this.options.theme = theme4, setIconColor(this.internalProps.theme.functionalIconsStyle);
  }
  updateTheme(theme4) {
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    this.internalProps.theme = themes_default.of(null != theme4 ? theme4 : themes_default.DEFAULT), this.internalProps.theme.isPivot = this.isPivotTable(), setIconColor(this.internalProps.theme.functionalIconsStyle), this.options.theme = theme4, this.scenegraph.updateComponent(), this.scenegraph.updateStageBackground(), this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.render();
  }
  getBodyField(col, row) {
    return this.internalProps.layoutMap.getBody(col, row).field;
  }
  getBodyColumnDefine(col, row) {
    const body = this.internalProps.layoutMap.getBody(col, row);
    return null == body ? void 0 : body.define;
  }
  getBodyColumnType(col, row) {
    var _a, _b;
    const cellType = null !== (_b = null === (_a = this.internalProps.layoutMap.getBody(col, row)) || void 0 === _a ? void 0 : _a.cellType) && void 0 !== _b ? _b : "text";
    return getProp2("cellType", {
      cellType
    }, col, row, this);
  }
  getCellType(col, row) {
    let cellType;
    return this.isSeriesNumberInHeader(col, row) ? this.internalProps.layoutMap.getSeriesNumberHeader(col, row).cellType : (cellType = this.isHeader(col, row) ? this.internalProps.layoutMap.getHeader(col, row).headerType : this.internalProps.layoutMap.getBody(col, row).cellType, getProp2("cellType", {
      cellType
    }, col, row, this));
  }
  getHeaderField(col, row) {
    return this.internalProps.layoutMap.getHeaderField(col, row);
  }
  getHeaderDefine(col, row) {
    const hd = this.internalProps.layoutMap.getHeader(col, row);
    return null == hd ? void 0 : hd.define;
  }
  getCellLocation(col, row) {
    return this.internalProps.layoutMap.getCellLocation(col, row);
  }
  getCellHeaderPaths(col, row) {
    return this.internalProps.layoutMap.getCellHeaderPaths(col, row);
  }
  getHeadersDefine(col, row) {
    const headers = [];
    for (; ; ) {
      const header = this.getHeaderDefine(col, row);
      if (!header || !header.field && !header.columns) break;
      headers.push(header), row++;
    }
    return headers;
  }
  _getHeaderLayoutMap(col, row) {
    return this.internalProps.layoutMap.getHeader(col, row);
  }
  _getBodyLayoutMap(col, row) {
    return this.internalProps.layoutMap.getBody(col, row);
  }
  getContext() {
    return this.internalProps.context;
  }
  getRecordByCell(col, row) {
    if (!this.internalProps.layoutMap.isHeader(col, row)) return this.getCellOriginRecord(col, row);
  }
  getRecordByRowCol(col, row) {
    return this.getRecordByCell(col, row);
  }
  getRecordStartRowByRecordIndex(index) {
    return this.internalProps.layoutMap.getRecordStartRowByRecordIndex(index);
  }
  _getHeaderCellBySortState(sortState) {
    const { layoutMap } = this.internalProps, hd = layoutMap.headerObjects.find((col) => col && col.field === sortState.field);
    if (hd) {
      return layoutMap.getHeaderCellAdressById(hd.id);
    }
  }
  getCellRange(col, row) {
    var _a;
    if (this.internalProps.customMergeCell) {
      const customMerge = this.internalProps.customMergeCell(col, row, this);
      if (customMerge && customMerge.range && (isValid_default(customMerge.text) || customMerge.customLayout || customMerge.customRender)) {
        return {
          start: {
            col: Math.max(customMerge.range.start.col, 0),
            row: Math.max(customMerge.range.start.row, 0)
          },
          end: {
            col: Math.min(customMerge.range.end.col, this.colCount - 1),
            row: Math.min(customMerge.range.end.row, this.rowCount - 1)
          },
          isCustom: true
        };
      }
    }
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.getCellRange(col, row);
  }
  hasCustomMerge() {
    return !!this.internalProps.customMergeCell;
  }
  getCustomMerge(col, row) {
    if (this.internalProps.customMergeCell) {
      const customMerge = this.internalProps.customMergeCell(col, row, this);
      if (customMerge && customMerge.range && (isValid_default(customMerge.text) || customMerge.customLayout || this.customRender)) {
        if (customMerge.style) {
          const styleClass = this.internalProps.bodyHelper.getStyleClass("text"), style2 = customMerge.style, fullStyle = of(style2, this.theme.bodyStyle, {
            col,
            row,
            table: this,
            value: customMerge.text,
            dataValue: this.getCellOriginValue(col, row),
            cellHeaderPaths: this.getCellHeaderPaths(col, row)
          }, styleClass, this.options.autoWrapText, this.theme);
          customMerge.style = fullStyle;
        }
        return customMerge.range = {
          start: {
            col: Math.max(customMerge.range.start.col, 0),
            row: Math.max(customMerge.range.start.row, 0)
          },
          end: {
            col: Math.min(customMerge.range.end.col, this.colCount - 1),
            row: Math.min(customMerge.range.end.row, this.rowCount - 1)
          },
          isCustom: true
        }, customMerge;
      }
    }
  }
  isCellRangeEqual(col, row, targetCol, targetRow) {
    return this.internalProps.layoutMap.isCellRangeEqual(col, row, targetCol, targetRow);
  }
  _getLayoutCellId(col, row) {
    return this.internalProps.layoutMap.getCellId(col, row);
  }
  getHeaderDescription(col, row) {
    var _a;
    const field = this._getHeaderLayoutMap(col, row), fieldDef = null == field ? void 0 : field.define, description = null !== (_a = null == fieldDef ? void 0 : fieldDef.description) && void 0 !== _a ? _a : null == field ? void 0 : field.description;
    if ("function" == typeof description) {
      return description({
        col,
        row,
        value: this.getCellValue(col, row),
        dataValue: this.getCellOriginValue(col, row)
      });
    }
    return description;
  }
  setDropDownMenuHighlight(cells) {
    this.stateManager.setDropDownMenuHighlight(cells);
  }
  _dropDownMenuIsHighlight(colNow, rowNow, index) {
    return this.stateManager.dropDownMenuIsHighlight(colNow, rowNow, index);
  }
  isSeriesNumberInBody(col, row) {
    return this.internalProps.layoutMap && this.internalProps.layoutMap.isSeriesNumberInBody(col, row);
  }
  isSeriesNumberInHeader(col, row) {
    return this.internalProps.layoutMap && this.internalProps.layoutMap.isSeriesNumberInHeader(col, row);
  }
  isHeader(col, row) {
    return this.internalProps.layoutMap && this.internalProps.layoutMap.isHeader(col, row);
  }
  isColumnHeader(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isColumnHeader(col, row);
  }
  isRowHeader(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isRowHeader(col, row);
  }
  isCornerHeader(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isCornerHeader(col, row);
  }
  isFrozenColumn(col, row) {
    return this.isLeftFrozenColumn(col, row) || this.isRightFrozenColumn(col, row);
  }
  isLeftFrozenColumn(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isFrozenColumn(col, row);
  }
  isRightFrozenColumn(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isRightFrozenColumn(col, row);
  }
  isFrozenRow(col, row) {
    return this.isTopFrozenRow(col, row) || this.isBottomFrozenRow(col, row);
  }
  isTopFrozenRow(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isFrozenRow(col, row);
  }
  isBottomFrozenRow(col, row) {
    var _a;
    return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isBottomFrozenRow(col, row);
  }
  getCellInfo(col, row) {
    if (col >= 0 && row >= 0) {
      const colDef = this.isHeader(col, row) ? this.getHeaderDefine(col, row) : this.getBodyColumnDefine(col, row);
      return {
        col,
        row,
        field: this.getHeaderField(col, row),
        cellHeaderPaths: this.internalProps.layoutMap.getCellHeaderPaths(col, row),
        title: null == colDef ? void 0 : colDef.title,
        cellType: this.getCellType(col, row),
        originData: this.getCellOriginRecord(col, row),
        cellRange: this.getCellRangeRelativeRect({
          col,
          row
        }),
        value: this.getCellValue(col, row),
        dataValue: this.getCellOriginValue(col, row),
        cellLocation: this.getCellLocation(col, row),
        scaleRatio: this.canvas.getBoundingClientRect().width / this.canvas.offsetWidth
      };
    }
  }
  _hasField(field, col, row) {
    var _a;
    if (null === field) return false;
    if (this.internalProps.layoutMap.isHeader(col, row)) return false;
    const index = this.getRecordShowIndexByCell(col, row);
    return null === (_a = this.internalProps.dataSource) || void 0 === _a ? void 0 : _a.hasField(index, field);
  }
  _getCellStyle(col, row) {
    return getCellStyle(col, row, this);
  }
  clearCellStyleCache() {
    this.headerStyleCache.clear(), this.bodyStyleCache.clear(), this.bodyMergeTitleCache.clear(), this.bodyBottomStyleCache.clear();
  }
  clearRowHeightCache() {
    this.internalProps._rowHeightsMap.clear(), this._clearRowRangeHeightsMap();
  }
  clearColWidthCache() {
    this.internalProps._colWidthsMap.clear(), this._clearColRangeWidthsMap();
  }
  _canResizeColumn(col, row) {
    if (!(col >= 0 && row >= 0)) return false;
    if (this.isCellRangeEqual(col, row, col + 1, row)) return false;
    if ("none" === this.internalProps.columnResizeMode) return false;
    if ("header" === this.internalProps.columnResizeMode) {
      if (!this.isHeader(col, row)) return false;
    } else if ("body" === this.internalProps.columnResizeMode && this.isHeader(col, row)) return false;
    const limit = this.colWidthsLimit[col];
    return !(limit && limit.min && limit.max) || limit.max !== limit.min;
  }
  _canResizeRow(col, row) {
    if (!(col >= 0 && row >= 0)) return false;
    if (this.isCellRangeEqual(col, row, col, row + 1)) return false;
    if ("none" === this.internalProps.rowResizeMode) return false;
    if ("header" === this.internalProps.rowResizeMode) {
      if (!this.isHeader(col, row)) return false;
    } else if ("body" === this.internalProps.rowResizeMode && this.isHeader(col, row)) return false;
    return true;
  }
  _canDragHeaderPosition(col, row) {
    var _a;
    if (this.isHeader(col, row) && (this.stateManager.isSelected(col, row) || "body" === (null === (_a = this.options.select) || void 0 === _a ? void 0 : _a.headerSelectMode) && checkCellInSelect(col, row, [this.getCellRange(this.stateManager.select.cellPos.col, this.stateManager.select.cellPos.row)]) || isCellDisableSelect(this, col, row))) {
      if ("disabled" === this.internalProps.frozenColDragHeaderMode && this.isFrozenColumn(col)) return false;
      if (this.stateManager.isSelected(col, row)) {
        const selectRange = this.stateManager.select.ranges[0];
        if (this.isColumnHeader(col, row)) {
          if (selectRange.end.row !== this.rowCount - 1) return false;
        } else {
          if (!this.isRowHeader(col, row)) return false;
          if (selectRange.end.col !== this.colCount - 1) return false;
        }
      }
      const define = this.getHeaderDefine(col, row);
      if (!define) return false;
      if (void 0 === define.dragHeader) {
        if ("all" === this.internalProps.dragHeaderMode) return true;
        if ("column" === this.internalProps.dragHeaderMode) {
          if (this.isColumnHeader(col, row)) return true;
        } else if ("row" === this.internalProps.dragHeaderMode && this.isRowHeader(col, row)) return true;
        return false;
      }
      return define.dragHeader;
    }
    return false;
  }
  getCellIcons(col, row) {
    var _a, _b, _c;
    let icons2;
    if (this.isHeader(col, row)) icons2 = this.internalProps.headerHelper.getIcons(col, row);
    else if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
      if (!this.options.groupBy || !(null === (_a = this.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge)) {
        (null === (_c = null === (_b = this.internalProps.layoutMap.getSeriesNumberBody(col, row)) || void 0 === _b ? void 0 : _b.define) || void 0 === _c ? void 0 : _c.dragOrder) && (icons2 = this.internalProps.rowSeriesNumberHelper.getIcons(col, row));
      }
      const cellValue = this.getCellValue(col, row), dataValue = this.getCellOriginValue(col, row), ctx = this.internalProps.context, cellIcon = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
      (null == icons2 ? void 0 : icons2.length) > 0 ? icons2 = icons2.concat(cellIcon) : (null == cellIcon ? void 0 : cellIcon.length) > 0 && (icons2 = cellIcon);
    } else {
      const cellValue = this.getCellValue(col, row), dataValue = this.getCellOriginValue(col, row), ctx = this.internalProps.context;
      icons2 = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
    }
    return icons2;
  }
  showDropDownMenu(col, row, dropDownMenuOptions) {
    let menuType = "dropdown-menu";
    dropDownMenuOptions && (menuType = Array.isArray(dropDownMenuOptions.content) ? "dropdown-menu" : "container"), "html" === this.internalProps.menu.renderMode && (this.stateManager.menu.isShow = true, this.internalProps.menuHandler._bindToCell(col, row, menuType, dropDownMenuOptions));
  }
  showTooltip(col, row, tooltipOptions) {
    "html" === this.internalProps.tooltip.renderMode && this.internalProps.tooltipHandler._bindToCell(col, row, tooltipOptions);
  }
  getCellStyle(col, row) {
    const actStyle = this._getCellStyle(col, row), theme4 = getStyleTheme(actStyle, this, col, row, getProp2).theme, { autoWrapText, lineClamp, textOverflow } = actStyle;
    return {
      textAlign: theme4.text.textAlign,
      textBaseline: theme4.text.textBaseline,
      bgColor: isBoolean_default(theme4.group.fill) ? getProp2("bgColor", actStyle, col, row, this) : theme4.group.fill,
      color: isBoolean_default(theme4.text.fill) ? getProp2("color", actStyle, col, row, this) : theme4.text.fill,
      strokeColor: isBoolean_default(theme4.text.stroke) ? getProp2("strokeColor", actStyle, col, row, this) : theme4.text.stroke,
      fontFamily: theme4.text.fontFamily,
      fontSize: theme4.text.fontSize,
      fontWeight: theme4.text.fontWeight,
      fontVariant: theme4.text.fontVariant,
      fontStyle: theme4.text.fontStyle,
      lineHeight: theme4.text.lineHeight,
      autoWrapText: null != autoWrapText && autoWrapText,
      lineClamp: null != lineClamp ? lineClamp : "auto",
      textOverflow,
      borderColor: isBoolean_default(theme4.group.stroke) ? getProp2("borderColor", actStyle, col, row, this) : theme4.group.stroke,
      borderLineWidth: theme4.group.lineWidth,
      borderLineDash: theme4.group.lineDash,
      underline: !!theme4.text.underline,
      underlineDash: theme4.text.underlineDash,
      underlineOffset: theme4.text.underlineOffset,
      lineThrough: !!theme4.text.lineThrough,
      padding: theme4._vtable.padding,
      underlineWidth: theme4.text.underline,
      lineThroughLineWidth: theme4.text.lineThrough,
      _strokeArrayWidth: theme4.group.strokeArrayWidth,
      _strokeArrayColor: theme4.group.strokeArrayColor,
      _linkColor: getProp2("linkColor", actStyle, col, row, this)
    };
  }
  getAllBodyCells(colMaxCount, rowMaxCount) {
    const start_col = this.rowHeaderLevelCount, start_row = this.columnHeaderLevelCount, end_col = this.colCount - 1, end_row = this.rowCount - 1;
    return Array(Math.min(null != rowMaxCount ? rowMaxCount : 2e3, end_row - start_row + 1, this.rowCount)).fill(0).map((_, i) => Array(Math.min(null != colMaxCount ? colMaxCount : 2e3, end_col - start_col + 1, this.colCount)).fill(0).map((_2, j) => this.getCellInfo(j + start_col, i + start_row)));
  }
  getAllCells(colMaxCount, rowMaxCount) {
    const start_col = 0, start_row = 0, end_col = this.colCount - 1, end_row = this.rowCount - 1;
    return Array(Math.min(null != rowMaxCount ? rowMaxCount : 2e3, end_row - start_row + 1, this.rowCount)).fill(0).map((_, i) => Array(Math.min(null != colMaxCount ? colMaxCount : 2e3, end_col - start_col + 1, this.colCount)).fill(0).map((_2, j) => this.getCellInfo(j + start_col, i + start_row)));
  }
  getAllColumnHeaderCells() {
    const start_col = this.rowHeaderLevelCount, start_row = 0, end_col = this.colCount - 1, end_row = this.columnHeaderLevelCount - 1;
    return Array(end_row - start_row + 1).fill(0).map((_, i) => Array(end_col - start_col + 1).fill(0).map((_2, j) => this.getCellInfo(j + start_col, i + start_row)));
  }
  getAllRowHeaderCells() {
    const start_col = 0, start_row = this.columnHeaderLevelCount, end_col = this.rowHeaderLevelCount - 1, end_row = this.rowCount - 1;
    return Array(end_row - start_row + 1).fill(0).map((_, i) => Array(end_col - start_col + 1).fill(0).map((_2, j) => this.getCellInfo(j + start_col, i + start_row)));
  }
  getCopyValue() {
    var _a, _b, _c;
    if ((null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0) {
      const ranges = this.stateManager.select.ranges;
      let minCol = Math.min(ranges[0].start.col, ranges[0].end.col), maxCol = Math.max(ranges[0].start.col, ranges[0].end.col), minRow = Math.min(ranges[0].start.row, ranges[0].end.row), maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
      ranges.forEach((a2) => {
        minCol = Math.min(minCol, a2.start.col, a2.end.col), maxCol = Math.max(maxCol, a2.start.col, a2.end.col), minRow = Math.min(minRow, a2.start.row, a2.end.row), maxRow = Math.max(maxRow, a2.start.row, a2.end.row);
      });
      const isExistDataInRow = (r) => {
        let isExist = false;
        return ranges.forEach((range5) => {
          const minRow2 = Math.min(range5.start.row, range5.end.row), maxRow2 = Math.max(range5.start.row, range5.end.row);
          minRow2 <= r && maxRow2 >= r && (isExist = true);
        }), isExist;
      }, isExistDataInCol = (c2) => {
        let isExist = false;
        return ranges.forEach((range5) => {
          const minCol2 = Math.min(range5.start.col, range5.end.col), maxCol2 = Math.max(range5.start.col, range5.end.col);
          minCol2 <= c2 && maxCol2 >= c2 && (isExist = true);
        }), isExist;
      }, getRangeExistDataInCell = (c2, r) => {
        let isExistRange;
        return ranges.forEach((range5) => {
          const minRow2 = Math.min(range5.start.row, range5.end.row), maxRow2 = Math.max(range5.start.row, range5.end.row), minCol2 = Math.min(range5.start.col, range5.end.col), maxCol2 = Math.max(range5.start.col, range5.end.col);
          minCol2 <= c2 && maxCol2 >= c2 && minRow2 <= r && maxRow2 >= r && (isExistRange = range5);
        }), isExistRange;
      }, getCopyCellValue = (col, row, range5) => {
        const cellRange = this.getCellRange(col, row);
        let copyStartCol = cellRange.start.col, copyStartRow = cellRange.start.row;
        if (range5) {
          const rangeMinCol = Math.min(range5.start.col, range5.end.col), rangeMinRow = Math.min(range5.start.row, range5.end.row);
          copyStartCol = Math.max(rangeMinCol, cellRange.start.col), copyStartRow = Math.max(rangeMinRow, cellRange.start.row);
        }
        if (copyStartCol !== col || copyStartRow !== row) return "";
        return this.getCellValue(col, row);
      };
      let copyValue = "";
      for (let r = minRow; r <= maxRow; r++) {
        if (isExistDataInRow(r)) {
          for (let c2 = minCol; c2 <= maxCol; c2++) {
            if (isExistDataInCol(c2)) {
              const range5 = getRangeExistDataInCell(c2, r);
              if (range5) {
                const copyCellValue = getCopyCellValue(c2, r, range5);
                if ("undefined" != typeof Promise && copyCellValue instanceof Promise) ;
                else {
                  const strCellValue = isValid_default(copyCellValue) ? `${copyCellValue}` : "";
                  /^\[object .*\]$/.exec(strCellValue) || (copyValue += strCellValue);
                }
                (c2 < range5.end.col || c2 < maxCol) && (copyValue += "	");
              } else copyValue += "	";
            }
          }
          r < maxRow && (copyValue += "\r\n");
        }
      }
      return (null === (_c = this.options) || void 0 === _c ? void 0 : _c.formatCopyValue) && (copyValue = this.options.formatCopyValue(copyValue)), copyValue;
    }
    return "";
  }
  getSelectedCellInfos() {
    var _a;
    if (!(null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges)) return null;
    const ranges = this.stateManager.select.ranges;
    if (!ranges.length) return [];
    let minCol = Math.min(ranges[0].start.col, ranges[0].end.col), maxCol = Math.max(ranges[0].start.col, ranges[0].end.col), minRow = Math.min(ranges[0].start.row, ranges[0].end.row), maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
    ranges.forEach((a2) => {
      minCol = Math.min(minCol, a2.start.col, a2.end.col), maxCol = Math.max(maxCol, a2.start.col, a2.end.col), minRow = Math.min(minRow, a2.start.row, a2.end.row), maxRow = Math.max(maxRow, a2.start.row, a2.end.row);
    });
    const isExistDataInRow = (r) => {
      let isExist = false;
      return ranges.forEach((range5) => {
        const minRow2 = Math.min(range5.start.row, range5.end.row), maxRow2 = Math.max(range5.start.row, range5.end.row);
        minRow2 <= r && maxRow2 >= r && (isExist = true);
      }), isExist;
    }, isExistDataInCol = (c2) => {
      let isExist = false;
      return ranges.forEach((range5) => {
        const minCol2 = Math.min(range5.start.col, range5.end.col), maxCol2 = Math.max(range5.start.col, range5.end.col);
        minCol2 <= c2 && maxCol2 >= c2 && (isExist = true);
      }), isExist;
    }, getRangeExistDataInCell = (c2, r) => {
      let isExistRange;
      return ranges.forEach((range5) => {
        const minRow2 = Math.min(range5.start.row, range5.end.row), maxRow2 = Math.max(range5.start.row, range5.end.row), minCol2 = Math.min(range5.start.col, range5.end.col), maxCol2 = Math.max(range5.start.col, range5.end.col);
        minCol2 <= c2 && maxCol2 >= c2 && minRow2 <= r && maxRow2 >= r && (isExistRange = range5);
      }), isExistRange;
    }, cellInfoArray = [];
    for (let r = minRow; r <= maxRow; r++) {
      if (isExistDataInRow(r)) {
        const cellInfoRow = [];
        for (let c2 = minCol; c2 <= maxCol; c2++) {
          if (isExistDataInCol(c2)) {
            if (getRangeExistDataInCell(c2, r)) {
              const cellInfo = this.getCellInfo(c2, r);
              cellInfoRow.push(cellInfo);
            }
          }
        }
        cellInfoArray.push(cellInfoRow);
      }
    }
    return cellInfoArray;
  }
  getSelectedCellRanges() {
    const ranges = this.stateManager.select.ranges;
    return ranges.length ? cloneDeep(ranges) : [];
  }
  measureText(text2, font) {
    return textMeasure.measureText(text2, font);
  }
  measureTextBounds(attribute) {
    return measureTextBounds(attribute);
  }
  getCustomRender(col, row) {
    let customRender;
    if ("body" !== this.getCellLocation(col, row)) {
      const define = this.getHeaderDefine(col, row);
      customRender = null == define ? void 0 : define.headerCustomRender;
    } else {
      const define = this.getBodyColumnDefine(col, row);
      customRender = (null == define ? void 0 : define.customRender) || this.customRender;
    }
    return customRender;
  }
  getCustomLayout(col, row) {
    let customLayout;
    if ("body" !== this.getCellLocation(col, row)) {
      const define = this.getHeaderDefine(col, row);
      customLayout = null == define ? void 0 : define.headerCustomLayout;
    } else {
      const define = this.getBodyColumnDefine(col, row);
      customLayout = null == define ? void 0 : define.customLayout;
    }
    return customLayout;
  }
  hasAutoImageColumn() {
    return void 0 === this._hasAutoImageColumn && (this._hasAutoImageColumn = hasAutoImageColumn(this)), this._hasAutoImageColumn;
  }
  _getActiveChartInstance() {
    var _a, _b, _c, _d, _e, _f;
    const cellGroup = this.scenegraph.getCell(null === (_b = null === (_a = this.stateManager.hover) || void 0 === _a ? void 0 : _a.cellPos) || void 0 === _b ? void 0 : _b.col, null === (_d = null === (_c = this.stateManager.hover) || void 0 === _c ? void 0 : _c.cellPos) || void 0 === _d ? void 0 : _d.row);
    return "chart" === (null === (_f = null === (_e = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.type) ? cellGroup.getChildren()[0].activeChartInstance : null;
  }
  cellIsInVisualView(col, row) {
    var _a, _b, _c, _d;
    const drawRange = this.getDrawRange(), rect = this.getCellRelativeRect(col, row);
    if (col < this.frozenColCount && row < this.frozenRowCount) return true;
    let colHeaderRangeRect, rowHeaderRangeRect, bottomFrozenRangeRect, rightFrozenRangeRect;
    if (this.frozenRowCount >= 1 && (colHeaderRangeRect = this.getCellRangeRelativeRect({
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: this.colCount - 1,
        row: this.frozenRowCount - 1
      }
    })), this.frozenColCount >= 1 && (rowHeaderRangeRect = this.getCellRangeRelativeRect({
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: this.frozenColCount - 1,
        row: this.rowCount - 1
      }
    })), this.bottomFrozenRowCount >= 1 && (bottomFrozenRangeRect = this.getCellRangeRelativeRect({
      start: {
        col: 0,
        row: this.rowCount - this.bottomFrozenRowCount
      },
      end: {
        col: this.colCount - 1,
        row: this.rowCount - 1
      }
    })), this.rightFrozenColCount >= 1 && (rightFrozenRangeRect = this.getCellRangeRelativeRect({
      start: {
        col: this.colCount - this.rightFrozenColCount,
        row: 0
      },
      end: {
        col: this.colCount - 1,
        row: this.rowCount - 1
      }
    })), rect.top >= drawRange.top && rect.bottom <= drawRange.bottom && rect.left >= drawRange.left && rect.right <= drawRange.right) {
      if (this.isFrozenCell(col, row)) return true;
      if (rect.top >= (null !== (_a = null == colHeaderRangeRect ? void 0 : colHeaderRangeRect.bottom) && void 0 !== _a ? _a : rect.top) && rect.left >= (null !== (_b = null == rowHeaderRangeRect ? void 0 : rowHeaderRangeRect.right) && void 0 !== _b ? _b : rect.left) && rect.bottom <= (null !== (_c = null == bottomFrozenRangeRect ? void 0 : bottomFrozenRangeRect.top) && void 0 !== _c ? _c : rect.bottom) && rect.right <= (null !== (_d = null == rightFrozenRangeRect ? void 0 : rightFrozenRangeRect.left) && void 0 !== _d ? _d : rect.right)) return true;
    }
    return false;
  }
  getCustomMergeValue(col, row) {
    if (this.internalProps.customMergeCell) {
      const customMerge = this.getCustomMerge(col, row);
      if (customMerge) {
        const { text: text2 } = customMerge;
        return text2;
      }
    }
  }
  exportImg() {
    return this.scenegraph.stage.toCanvas().toDataURL();
  }
  exportCellImg(col, row, options) {
    var _a, _b, _c, _d;
    const isInView = this.cellIsInVisualView(col, row), { scrollTop, scrollLeft } = this;
    isInView || this.scrollToCell({
      col,
      row
    });
    const cellRect = this.getCellRelativeRect(col, row);
    (null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 && hideCellSelectBorder(this.scenegraph);
    const { col: hoverCol, row: hoverRow } = this.stateManager.hover.cellPos;
    let oldFill, oldStroke;
    if (this.stateManager.updateHoverPos(-1, -1), this.scenegraph.component.hideVerticalScrollBar(), this.scenegraph.component.hideHorizontalScrollBar(), this.scenegraph.tableGroup.border.setAttribute("visible", false), null == options ? void 0 : options.disableBackground) {
      const cellGroup = this.scenegraph.getCell(col, row);
      oldFill = cellGroup.attribute.fill, cellGroup.setAttribute("fill", "transparent");
    }
    if (null == options ? void 0 : options.disableBorder) {
      const cellGroup = this.scenegraph.getCell(col, row);
      oldStroke = cellGroup.attribute.stroke, cellGroup.setAttribute("stroke", false);
    }
    this.scenegraph.renderSceneGraph();
    let sizeOffset = 0;
    "bottom-right" === this.theme.cellBorderClipDirection && (sizeOffset = 1);
    const c2 = this.scenegraph.stage.toCanvas(false, new AABBBounds().set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX - sizeOffset, cellRect.bottom + this.tableY - sizeOffset));
    if (isInView || (this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft)), this.scenegraph.tableGroup.border.setAttribute("visible", true), oldFill) {
      this.scenegraph.getCell(col, row).setAttribute("fill", oldFill);
    }
    if (oldStroke) {
      this.scenegraph.getCell(col, row).setAttribute("stroke", oldStroke);
    }
    return (null === (_d = null === (_c = this.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length) > 0 && restoreCellSelectBorder(this.scenegraph), this.stateManager.updateHoverPos(hoverCol, hoverRow), this.scenegraph.updateNextFrame(), c2.toDataURL();
  }
  exportCellRangeImg(cellRange) {
    var _a, _b, _c, _d;
    const { scrollTop, scrollLeft } = this, minCol = Math.min(cellRange.start.col, cellRange.end.col), minRow = Math.min(cellRange.start.row, cellRange.end.row), maxCol = Math.max(cellRange.start.col, cellRange.end.col), maxRow = Math.max(cellRange.start.row, cellRange.end.row), isInView = this.cellIsInVisualView(minCol, minRow), isMaxCellInView = this.cellIsInVisualView(maxCol, maxRow);
    isInView && isMaxCellInView || this.scrollToCell({
      col: minCol,
      row: minRow
    });
    const cellRect = this.getCellRangeRelativeRect({
      start: {
        col: minCol,
        row: minRow
      },
      end: {
        col: maxCol,
        row: maxRow
      }
    });
    (null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 && hideCellSelectBorder(this.scenegraph);
    const { col: hoverCol, row: hoverRow } = this.stateManager.hover.cellPos;
    this.stateManager.updateHoverPos(-1, -1), this.scenegraph.component.hideVerticalScrollBar(), this.scenegraph.component.hideHorizontalScrollBar(), this.scenegraph.renderSceneGraph();
    const base64Image = this.scenegraph.stage.toCanvas(false, new AABBBounds().set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX, cellRect.bottom + this.tableY)).toDataURL();
    return isInView && isMaxCellInView || (this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft)), (null === (_d = null === (_c = this.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length) > 0 && restoreCellSelectBorder(this.scenegraph), this.stateManager.updateHoverPos(hoverCol, hoverRow), base64Image;
  }
  exportCanvas() {
    return this.scenegraph.stage.toCanvas();
  }
  getImageBuffer(type = "image/png") {
    if ("node" !== this.options.mode) return;
    this.render();
    const stage = this.scenegraph.stage;
    if (stage) {
      const contentWidth = this.tableX + this.getAllColsWidth(), contentHeight = this.tableY + this.getAllRowsHeight();
      if (contentWidth >= this.canvasWidth && contentHeight >= this.canvasHeight) {
        stage.render();
        return stage.window.getImageBuffer(type);
      }
      return this.scenegraph.stage.toCanvas(false, new AABBBounds().set(0, 0, Math.min(this.canvasWidth, contentWidth), Math.min(this.canvasHeight, contentHeight))).toBuffer(type);
    }
    return null;
  }
  getBodyIndexByTableIndex(col, row) {
    return {
      col: col - this.rowHeaderLevelCount - this.leftRowSeriesNumberCount,
      row: row - this.columnHeaderLevelCount
    };
  }
  getTableIndexByBodyIndex(col, row) {
    return {
      col: col + this.rowHeaderLevelCount + this.leftRowSeriesNumberCount,
      row: row + this.columnHeaderLevelCount
    };
  }
  onVChartEvent(type, query, callback) {
    this._chartEventMap[type] || (this._chartEventMap[type] = []), "function" == typeof query ? this._chartEventMap[type].push({
      callback: query
    }) : this._chartEventMap[type].push({
      callback,
      query
    });
  }
  offVChartEvent(type, callback) {
    this._chartEventMap[type] && (this._chartEventMap[type] = callback ? this._chartEventMap[type].filter((e) => e.callback !== callback) : []);
  }
  _bindChartEvent(activeChartInstance) {
    if (activeChartInstance) for (const key in this._chartEventMap) (this._chartEventMap[key] || []).forEach((e) => {
      e.query ? activeChartInstance.on(key, e.query, e.callback) : activeChartInstance.on(key, e.callback);
    });
  }
  changeRecordOrder(source, target) {
  }
  hasCustomCellStyle(customStyleId) {
    var _a;
    return null === (_a = this.customCellStylePlugin) || void 0 === _a ? void 0 : _a.hasCustomCellStyle(customStyleId);
  }
  registerCustomCellStyle(customStyleId, customStyle) {
    var _a;
    null === (_a = this.customCellStylePlugin) || void 0 === _a || _a.registerCustomCellStyle(customStyleId, customStyle);
  }
  arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate) {
    var _a;
    null === (_a = this.customCellStylePlugin) || void 0 === _a || _a.arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate);
  }
  isSeriesNumber(col, row) {
    return this.internalProps.layoutMap.isSeriesNumber(col, row);
  }
  isHasSeriesNumber() {
    var _a;
    return (null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.leftRowSeriesNumberColumnCount) > 0;
  }
  get leftRowSeriesNumberCount() {
    var _a, _b;
    return null !== (_b = null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.leftRowSeriesNumberColumnCount) && void 0 !== _b ? _b : 0;
  }
  setMinMaxLimitWidth(setWidth = false) {
    var _a, _b;
    const internalProps = this.internalProps;
    for (let col = 0; col < internalProps.layoutMap.columnWidths.length; col++) {
      if (this.internalProps._widthResizedColMap.has(col)) continue;
      const { width, minWidth, maxWidth } = null !== (_b = null === (_a = internalProps.layoutMap.columnWidths) || void 0 === _a ? void 0 : _a[col]) && void 0 !== _b ? _b : {};
      setWidth && width && ("string" == typeof width && "auto" !== width || "number" == typeof width && width > 0) && this._setColWidth(col, width), minWidth && ("number" == typeof minWidth && minWidth > 0 || "string" == typeof minWidth) && this.setMinColWidth(col, minWidth), maxWidth && ("number" == typeof maxWidth && maxWidth > 0 || "string" == typeof maxWidth) && this.setMaxColWidth(col, maxWidth);
    }
  }
  setSortedIndexMap(field, filedMap) {
    var _a;
    null === (_a = this.dataSource) || void 0 === _a || _a.setSortedIndexMap(field, filedMap);
  }
  checkReactCustomLayout() {
    this.reactCustomLayout || (this.reactCustomLayout = new ReactCustomLayout(this));
  }
  get bodyDomContainer() {
    return this.internalProps.bodyDomContainer;
  }
  get headerDomContainer() {
    return this.internalProps.headerDomContainer;
  }
  get frozenBodyDomContainer() {
    return this.internalProps.frozenBodyDomContainer;
  }
  get frozenHeaderDomContainer() {
    return this.internalProps.frozenHeaderDomContainer;
  }
  get rightFrozenBodyDomContainer() {
    return this.internalProps.rightFrozenBodyDomContainer;
  }
  get rightFrozenHeaderDomContainer() {
    return this.internalProps.rightFrozenHeaderDomContainer;
  }
  get frozenBottomDomContainer() {
    return this.internalProps.frozenBottomDomContainer;
  }
  get bottomDomContainer() {
    return this.internalProps.bottomDomContainer;
  }
  get rightFrozenBottomDomContainer() {
    return this.internalProps.rightFrozenBottomDomContainer;
  }
  showMoverLine(col, row) {
    this.scenegraph.component.showMoveCol(col, row, 0), this.scenegraph.renderSceneGraph();
  }
  hideMoverLine(col, row) {
    this.scenegraph.component.hideMoveCol(), this.scenegraph.renderSceneGraph();
  }
  disableScroll() {
    this.eventManager.disableScroll();
  }
  enableScroll() {
    this.eventManager.enableScroll();
  }
  getGroupTitleLevel(col, row) {
  }
  scrollToRow(row, animationOption) {
    animationOption ? this.animationManager.scrollTo({
      row
    }, animationOption) : this.scrollToCell({
      row
    });
  }
  scrollToCol(col, animationOption) {
    animationOption ? this.animationManager.scrollTo({
      col
    }, animationOption) : this.scrollToCell({
      col
    });
  }
  scrollToCell(cellAddr, animationOption) {
    if (animationOption) return void this.animationManager.scrollTo(cellAddr, animationOption);
    const drawRange = this.getDrawRange();
    if (isValid_default(cellAddr.col) && cellAddr.col >= this.frozenColCount) {
      const frozenWidth = this.getFrozenColsWidth(), left = this.getColsWidth(0, cellAddr.col - 1);
      this.scrollLeft = Math.min(left - frozenWidth, this.getAllColsWidth() - drawRange.width);
    }
    if (isValid_default(cellAddr.row) && cellAddr.row >= this.frozenRowCount) {
      const frozenHeight = this.getFrozenRowsHeight(), top = this.getRowsHeight(0, cellAddr.row - 1);
      this.scrollTop = Math.min(top - frozenHeight, this.getAllRowsHeight() - drawRange.height);
    }
    this.render();
  }
  checkHasColumnAutoWidth() {
    return checkHasColumnAutoWidth(this);
  }
};

// node_modules/@visactor/vtable/es/register.js
var register_exports = {};
__export(register_exports, {
  aggregator: () => aggregator,
  chartModule: () => chartModule,
  clearAll: () => clearAll,
  editor: () => editor,
  icon: () => icon,
  theme: () => theme3
});

// node_modules/@visactor/vtable/es/chartModule.js
var chartTypes = {};
var builtin2 = {};
function get4() {
  return extend(builtin2, chartTypes);
}

// node_modules/@visactor/vtable/es/edit/editors.js
var editors = {};
function get5(editorName) {
  if (editors[editorName]) return editors[editorName];
}

// node_modules/@visactor/vtable/es/register.js
function register(obj2, name, value) {
  const old = obj2[name];
  return obj2[name] = value, old;
}
function theme3(name, theme4) {
  return null != theme4 ? register(themes, name, theme4) : themes[name];
}
function icon(name, icon2) {
  return null != icon2 ? register(icons, name, icon2) : icons[name];
}
function chartModule(name, chartModule2) {
  return null != chartModule2 ? register(chartTypes, name, chartModule2) : chartTypes[name];
}
function editor(name, editor2) {
  return null != editor2 ? register(editors, name, editor2) : editors[name];
}
function aggregator(aggregationType, aggregation) {
  null != aggregation && register(registeredAggregators, aggregationType, aggregation);
}
function clear(obj2) {
  for (const key in obj2) delete obj2[key];
}
function clearAll() {
  clear(themes), clear(icons), clear(chartTypes), clear(editors), clear(registeredAggregators);
}

// node_modules/@visactor/vtable/es/dataset/DataStatistics.js
var DataStatistics_exports = {};
__export(DataStatistics_exports, {
  dateFormat: () => dateFormat,
  numberFormat: () => numberFormat
});
function numberAddSeparators(str2, thousandsSep, decimalSep) {
  const strArr = (str2 += "").split(".");
  let str1 = strArr[0];
  const str22 = strArr.length > 1 ? decimalSep + strArr[1] : "";
  return str1 = numFormat(str1, thousandsSep), str1 + str22;
}
function numFormat(num, thousandsSep) {
  return num.replace(/\d+/, function(n) {
    return n.replace(/(\d)(?=(\d{3})+$)/g, function($1) {
      return `${$1}${thousandsSep}`;
    });
  });
}
function numberFormat(option) {
  return option = Object.assign({}, {
    digitsAfterDecimal: 2,
    scaler: 1,
    thousandsSep: ",",
    decimalSep: ".",
    prefix: "",
    suffix: ""
  }, option), function(num) {
    if (isNaN(num) || !isFinite(num)) return "";
    const result2 = numberAddSeparators((option.scaler * num).toFixed(option.digitsAfterDecimal), option.thousandsSep, option.decimalSep);
    return `${option.prefix}${result2}${option.suffix}`;
  };
}
function dateFormat(baseField, formatString, utcOutput, mthNames, dayNames) {
  null == utcOutput && (utcOutput = false), null == mthNames && (mthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]), null == dayNames && (dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]);
  const utc = utcOutput ? "UTC" : "", zeroPad = function(number) {
    return `0${number}`.substring(0, 2);
  };
  return function(record) {
    const date = new Date(Date.parse(record[baseField]));
    return formatString.replace(/%(.)/g, function(m3, p) {
      switch (p) {
        case "y":
          return date[`get${utc}FullYear`]();
        case "m":
          return zeroPad(date[`get${utc}Month`]() + 1);
        case "n":
          return mthNames[date[`get${utc}Month`]()];
        case "d":
          return zeroPad(date[`get${utc}Date`]());
        case "w":
          return dayNames[date[`get${utc}Day`]()];
        case "x":
          return date[`get${utc}Day`]();
        case "H":
          return zeroPad(date[`get${utc}Hours`]());
        case "M":
          return zeroPad(date[`get${utc}Minutes`]());
        case "S":
          return zeroPad(date[`get${utc}Seconds`]());
        default:
          return `%${p}`;
      }
    });
  };
}

// node_modules/@visactor/vtable/es/plugins/index.js
var plugins_exports = {};
__export(plugins_exports, {
  CustomCellStylePlugin: () => CustomCellStylePlugin,
  PluginManager: () => PluginManager
});

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/index.js
var import_eventemitter32 = __toESM(require_eventemitter3());

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isType.js
var isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType_default = isType;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isBoolean.js
var isBoolean2 = (value, fuzzy = false) => fuzzy ? "boolean" == typeof value : true === value || false === value || isType_default(value, "Boolean");
var isBoolean_default2 = isBoolean2;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isNil.js
var isNil = (value) => null == value;
var isNil_default2 = isNil;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isValid.js
var isValid = (value) => null != value;
var isValid_default2 = isValid;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isString.js
var isString2 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType_default(value, "String");
};
var isString_default2 = isString2;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isArray.js
var isArray = (value) => Array.isArray ? Array.isArray(value) : isType_default(value, "Array");
var isArray_default2 = isArray;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isDate.js
var isDate = (value) => isType_default(value, "Date");
var isDate_default = isDate;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isNumber.js
var isNumber3 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType_default(value, "Number");
};
var isNumber_default2 = isNumber3;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/isPrototype.js
var objectProto = Object.prototype;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/logger.js
var hasConsole = "undefined" != typeof console;
function log(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole && console[method].apply(console, args);
}
var LoggerLevel;
!function(LoggerLevel4) {
  LoggerLevel4[LoggerLevel4.None = 0] = "None", LoggerLevel4[LoggerLevel4.Error = 1] = "Error", LoggerLevel4[LoggerLevel4.Warn = 2] = "Warn", LoggerLevel4[LoggerLevel4.Info = 3] = "Info", LoggerLevel4[LoggerLevel4.Debug = 4] = "Debug";
}(LoggerLevel || (LoggerLevel = {}));
var Logger2 = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default2(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h) => h === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex((h) => h === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h) => h(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
  }
};
Logger2._instance = null;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/tickStep.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/debounce.js
var hasRaf = false;
try {
  hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf = false;
}
hasRaf = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/common/interpolate.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/math.js
var pi3 = Math.PI;
var halfPi3 = pi3 / 2;
var tau2 = 2 * pi3;
var pi22 = 2 * Math.PI;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/graphics/algorithm/intersect.js
var InnerBBox;
!function(InnerBBox4) {
  InnerBBox4[InnerBBox4.NONE = 0] = "NONE", InnerBBox4[InnerBBox4.BBOX1 = 1] = "BBOX1", InnerBBox4[InnerBBox4.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/graphics/text/stringWidth.js
var eastAsianCharacterInfo = (character) => {
  let x = character.charCodeAt(0), y = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x;
  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/graphics/text/measure/util.js
function getContextFont2(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/graphics/text/measure/textMeasure.js
var TextMeasure2 = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default2(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default2(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return false;
    if (isNil_default2(this._canvas) && (isValid_default2(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default2(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default2(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default2(this._context) && isValid_default2(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default2(context) && (context.save(), context.font = getContextFont2(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default2(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default2(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale6 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale6;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default2(text2)) return {
      width: 0,
      height: 0
    };
    if (isNil_default2(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i];
      let size = this._measureSpecialChar(char);
      isNil_default2(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default2(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil_default2(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i], size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default2(text2)) return defaultResult;
    if (isArray_default2(text2)) {
      const textArr = text2.filter(isValid_default2).map((s2) => s2.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default2(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default2(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default2(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default2(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default2(this._canvas) && (this._canvas = null), isValid_default2(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure2.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure2.NUMBERS_CHAR_SET = "0123456789", TextMeasure2.FULL_SIZE_CHAR = "字";

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/time/interval.js
var HOUR2 = 36e5;
var DAY2 = 24 * HOUR2;
var MONTH2 = 31 * DAY2;
var YEAR2 = 365 * DAY2;

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/node_modules/@visactor/vutils/es/dom.js
function isHTMLElement(obj2) {
  try {
    return obj2 instanceof Element;
  } catch (_a) {
    const htmlElementKeys = ["children", "innerHTML", "classList", "setAttribute", "tagName", "getBoundingClientRect"], keys2 = Object.keys(obj2);
    return htmlElementKeys.every((key) => keys2.includes(key));
  }
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/index.js
var import_eventemitter33 = __toESM(require_eventemitter3());

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isType.js
var isType2 = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType_default2 = isType2;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isBoolean.js
var isBoolean3 = (value, fuzzy = false) => fuzzy ? "boolean" == typeof value : true === value || false === value || isType_default2(value, "Boolean");
var isBoolean_default3 = isBoolean3;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isNil.js
var isNil2 = (value) => null == value;
var isNil_default3 = isNil2;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isValid.js
var isValid2 = (value) => null != value;
var isValid_default3 = isValid2;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isObjectLike.js
var isObjectLike = (value) => "object" == typeof value && null !== value;
var isObjectLike_default2 = isObjectLike;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isPlainObject.js
var isPlainObject = function(value) {
  if (!isObjectLike_default2(value) || !isType_default2(value, "Object")) return false;
  if (null === Object.getPrototypeOf(value)) return true;
  let proto = value;
  for (; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
};
var isPlainObject_default3 = isPlainObject;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isString.js
var isString3 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType_default2(value, "String");
};
var isString_default3 = isString3;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isArray.js
var isArray2 = (value) => Array.isArray ? Array.isArray(value) : isType_default2(value, "Array");
var isArray_default3 = isArray2;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isArrayLike.js
var isArrayLike = function(value) {
  return null !== value && "function" != typeof value && Number.isFinite(value.length);
};
var isArrayLike_default2 = isArrayLike;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isDate.js
var isDate2 = (value) => isType_default2(value, "Date");
var isDate_default2 = isDate2;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isNumber.js
var isNumber4 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType_default2(value, "Number");
};
var isNumber_default3 = isNumber4;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/isPrototype.js
var objectProto2 = Object.prototype;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/cloneDeep.js
function cloneDeep3(value, ignoreWhen, excludeKeys) {
  let result2;
  if (!isValid_default3(value) || "object" != typeof value || ignoreWhen && ignoreWhen(value)) return value;
  const isArr = isArray_default3(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default3(value) || isNumber_default3(value) || isString_default3(value) ? value : isDate_default2(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2) for (; ++index < (props || value).length; ) {
    const key = props ? props[index] : index, subValue = value[key];
    excludeKeys && excludeKeys.includes(key.toString()) ? result2[key] = subValue : result2[key] = cloneDeep3(subValue, ignoreWhen, excludeKeys);
  }
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/merge.js
function baseMerge2(target, source, shallowArray = false, skipTargetArray = false) {
  if (source) {
    if (target === source) return;
    if (isValid_default3(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key in iterable) props.push(key);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key = props[++propIndex];
        !isValid_default3(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray_default3(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
      }
    }
  }
}
function baseMergeDeep(target, source, key, shallowArray = false, skipTargetArray = false) {
  const objValue = target[key], srcValue = source[key];
  let newValue = source[key], isCommon = true;
  if (isArray_default3(srcValue)) {
    if (shallowArray) newValue = [];
    else if (isArray_default3(objValue)) newValue = objValue;
    else if (isArrayLike_default2(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length2 = objValue.length;
      for (; ++index < length2; ) newValue[index] = objValue[index];
    }
  } else isPlainObject_default3(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge2(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
}
function assignMergeValue(target, key, value) {
  (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function merge3(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge2(target, sources[sourceIndex], true);
  }
  return target;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/array.js
function array3(arr) {
  return isValid_default3(arr) ? isArray_default3(arr) ? arr : [arr] : [];
}
function uniqArray(arr) {
  return arr && isArray_default3(arr) ? Array.from(new Set(array3(arr))) : arr;
}
function flattenArray2(arr) {
  if (!isArray_default3(arr)) return [arr];
  const result2 = [];
  for (const value of arr) result2.push(...flattenArray2(value));
  return result2;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/logger.js
var hasConsole2 = "undefined" != typeof console;
function log2(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole2 && console[method].apply(console, args);
}
var LoggerLevel2;
!function(LoggerLevel4) {
  LoggerLevel4[LoggerLevel4.None = 0] = "None", LoggerLevel4[LoggerLevel4.Error = 1] = "Error", LoggerLevel4[LoggerLevel4.Warn = 2] = "Warn", LoggerLevel4[LoggerLevel4.Info = 3] = "Info", LoggerLevel4[LoggerLevel4.Debug = 4] = "Debug";
}(LoggerLevel2 || (LoggerLevel2 = {}));
var Logger3 = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default3(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel2.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h) => h === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex((h) => h === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h) => h(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel2.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel2.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel2.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel2.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel2.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log2(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel2.Warn && log2(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel2.Info && log2(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel2.Debug && log2(this._method || "log", "DEBUG", args), this;
  }
};
Logger3._instance = null;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/tickStep.js
var e103 = Math.sqrt(50);
var e53 = Math.sqrt(10);
var e23 = Math.sqrt(2);

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/debounce.js
var hasRaf2 = false;
try {
  hasRaf2 = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf2 = false;
}
hasRaf2 = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/common/interpolate.js
var reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB2 = new RegExp(reA2.source, "g");

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/math.js
var pi4 = Math.PI;
var halfPi4 = pi4 / 2;
var tau3 = 2 * pi4;
var pi23 = 2 * Math.PI;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/graphics/algorithm/intersect.js
var InnerBBox2;
!function(InnerBBox4) {
  InnerBBox4[InnerBBox4.NONE = 0] = "NONE", InnerBBox4[InnerBBox4.BBOX1 = 1] = "BBOX1", InnerBBox4[InnerBBox4.BBOX2 = 2] = "BBOX2";
}(InnerBBox2 || (InnerBBox2 = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/graphics/text/stringWidth.js
var eastAsianCharacterInfo2 = (character) => {
  let x = character.charCodeAt(0), y = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x;
  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/graphics/text/measure/util.js
function getContextFont3(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/graphics/text/measure/textMeasure.js
var TextMeasure3 = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default3(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default3(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return false;
    if (isNil_default3(this._canvas) && (isValid_default3(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default3(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default3(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default3(this._context) && isValid_default3(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default3(context) && (context.save(), context.font = getContextFont3(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default3(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default3(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale6 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale6;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default3(text2)) return {
      width: 0,
      height: 0
    };
    if (isNil_default3(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i];
      let size = this._measureSpecialChar(char);
      isNil_default3(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default3(size) && ["F", "W"].includes(eastAsianCharacterInfo2(char)) && (size = this._measureFullSizeChar()), isNil_default3(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i], size = ["F", "W"].includes(eastAsianCharacterInfo2(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default3(text2)) return defaultResult;
    if (isArray_default3(text2)) {
      const textArr = text2.filter(isValid_default3).map((s2) => s2.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default3(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default3(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default3(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default3(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default3(this._canvas) && (this._canvas = null), isValid_default3(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure3.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure3.NUMBERS_CHAR_SET = "0123456789", TextMeasure3.FULL_SIZE_CHAR = "字";

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/node_modules/@visactor/vutils/es/time/interval.js
var HOUR3 = 36e5;
var DAY3 = 24 * HOUR3;
var MONTH3 = 31 * DAY3;
var YEAR3 = 365 * DAY3;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/utils/geo.js
var WORLD_SIZE = 63781 * Math.PI * 2;
var fov = 0.25 * Math.PI;
var WORLD_HEIGHT = WORLD_SIZE / 2 / Math.tan(fov);
var PROJECTION_MERCATOR = mercator_default().translate([0, 0]).center([0, 0]).scale(63781);

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/transform/geo/dissolve.js
var import_geojson_dissolve = __toESM(require_geojson_dissolve());

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/transform/geo/simplify.js
var import_simplify_geojson = __toESM(require_simplify_geojson());

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/constants.js
var DATAVIEW_TYPE;
!function(DATAVIEW_TYPE2) {
  DATAVIEW_TYPE2.DSV = "dsv", DATAVIEW_TYPE2.TREE = "tree", DATAVIEW_TYPE2.GEO = "geo", DATAVIEW_TYPE2.BYTE = "bytejson", DATAVIEW_TYPE2.HEX = "hex", DATAVIEW_TYPE2.GRAPH = "graph", DATAVIEW_TYPE2.TABLE = "table", DATAVIEW_TYPE2.GEO_GRATICULE = "geo-graticule";
}(DATAVIEW_TYPE || (DATAVIEW_TYPE = {}));
var STATISTICS_METHODS = ["max", "mean", "median", "min", "mode", "product", "standardDeviation", "sum", "sumSimple", "variance"];

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/transform/statistics.js
var aggregates = {
  count: (data) => data.length,
  distinct: (data, field) => uniqArray(data.map((row) => row[field])).length
};
STATISTICS_METHODS.forEach((method) => {
  aggregates[method] = (data, field) => {
    let values = data.map((row) => row[field]);
    return isArray_default3(values) && isArray_default3(values[0]) && (values = flattenArray2(values)), simple_statistics_exports[method](values);
  };
}), aggregates.average = aggregates.mean;

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/transform/fields.js
var fields = (data, options) => {
  var _a, _b;
  if (!(null == options ? void 0 : options.fields)) return data;
  if (0 === data.length) return data;
  const fields2 = options.fields, dataTemp = data[0], filterFields = {}, sortFields = [];
  for (const key in fields2) if (Object.prototype.hasOwnProperty.call(fields2, key)) {
    const fieldInfo = fields2[key];
    if (!fieldInfo.type) {
      let dataCheck = dataTemp;
      key in dataTemp || (dataCheck = null !== (_a = data.find((d) => key in d)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
    }
    let sortInfo;
    if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
      key,
      type: fieldInfo.type,
      index: fieldInfo.sortIndex,
      sortIndex: {},
      sortIndexCount: 0,
      sortReverse: true === fieldInfo.sortReverse
    }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0) if ("ordinal" === fieldInfo.type) {
      fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
      const _domainCache = {};
      fieldInfo.domain.forEach((d, i) => {
        _domainCache[d] = i, fieldInfo._domainCache[d] = i;
      }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
    } else fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
  }
  return Object.keys(filterFields).length > 0 && (data = data.filter((d) => {
    for (const key in filterFields) {
      const fieldInfo = filterFields[key];
      if ("ordinal" === fieldInfo.type) {
        if (!(d[key] in fieldInfo._domainCache)) return false;
      } else if (fieldInfo.domain[0] > d[key] || fieldInfo.domain[1] < d[key]) return false;
    }
    return true;
  })), sortFields.sort((a2, b) => a2.index - b.index), data.sort((a2, b) => sortData(a2, b, sortFields)), data;
};
function sortData(a2, b, sortFields) {
  for (let i = 0; i < sortFields.length; i++) {
    const sortInfo = sortFields[i];
    let v = 0;
    if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b[sortInfo.key]] && (sortInfo.sortIndex[b[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a2[sortInfo.key]] && (sortInfo.sortIndex[a2[sortInfo.key]] = sortInfo.sortIndexCount++), v = sortInfo.sortIndex[a2[sortInfo.key]] - sortInfo.sortIndex[b[sortInfo.key]]) : "linear" === sortInfo.type && (v = a2[sortInfo.key] - b[sortInfo.key]), sortInfo.sortReverse && (v = -v), 0 !== v) return v;
  }
  return 0;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/parser/geo/geobuf.js
var geobuf = __toESM(require_geobuf());
var import_pbf = __toESM(require_pbf());

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/parser/geo/geojson.js
var geoPathInstance = path_default();

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/parser/geo/topojson.js
init_src();

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/utils/uuid.js
var idIndex = 0;
var maxId = 1e8;
function getUUID(prefix = "dataset") {
  return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/data-set.js
var DataSet = class {
  constructor(options) {
    var _a;
    let name;
    this.options = options, this.isDataSet = true, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new import_eventemitter33.default(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger3.getInstance();
  }
  setLogger(logger) {
    this._logger = logger;
  }
  getDataView(name) {
    return this.dataViewMap[name];
  }
  setDataView(name, dataView) {
    var _a;
    this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} 之前已存在，请重新命名`)), this.dataViewMap[name] = dataView;
  }
  removeDataView(name) {
    this.dataViewMap[name] = null, delete this.dataViewMap[name];
  }
  registerParser(name, parser) {
    var _a;
    this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.parserMap[name] = parser;
  }
  removeParser(name) {
    this.parserMap[name] = null, delete this.parserMap[name];
  }
  getParser(name) {
    return this.parserMap[name] || this.parserMap.default;
  }
  registerTransform(name, transform) {
    var _a;
    this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.transformMap[name] = transform;
  }
  removeTransform(name) {
    this.transformMap[name] = null, delete this.transformMap[name];
  }
  getTransform(name) {
    return this.transformMap[name];
  }
  multipleDataViewAddListener(list, event2, call) {
    this._callMap || (this._callMap = /* @__PURE__ */ new Map());
    let callAd = this._callMap.get(call);
    callAd || (callAd = () => {
      list.some((l) => l.isRunning) || call();
    }), list.forEach((l) => {
      l.target.addListener(event2, callAd);
    }), this._callMap.set(call, callAd);
  }
  allDataViewAddListener(event2, call) {
    this.multipleDataViewAddListener(Object.values(this.dataViewMap), event2, call);
  }
  multipleDataViewRemoveListener(list, event2, call) {
    if (this._callMap) {
      const callAd = this._callMap.get(call);
      callAd && list.forEach((l) => {
        l.target.removeListener(event2, callAd);
      }), this._callMap.delete(call);
    }
  }
  multipleDataViewUpdateInParse(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.parseNewData(d.data, d.options);
    });
  }
  multipleDataViewUpdateInRawData(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.updateRawData(d.data, d.options);
    });
  }
  destroy() {
    this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vdataset/es/data-view.js
var DataViewDiffRank = "_data-view-diff-rank";
var DataView = class _DataView {
  constructor(dataSet, options) {
    let name;
    this.dataSet = dataSet, this.options = options, this.isDataView = true, this.target = new import_eventemitter33.default(), this.parseOption = null, this.transformsArr = [], this.isRunning = false, this.rawData = {}, this.history = false, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = (opt = {
      pushHistory: true,
      emitMessage: true
    }) => (this.isRunning = true, this.resetTransformData(), this.transformsArr.forEach((t) => {
      this.executeTransform(t, {
        pushHistory: opt.pushHistory,
        emitMessage: false
      }), this.isLastTransform(t) && this.diffLastData();
    }), this.isRunning = false, false !== opt.emitMessage && this.target.emit("change", []), this), this.markRunning = () => {
      this.isRunning = true, this.target.emit("markRunning", []);
    }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
  }
  parse(data, options, emit = false) {
    var _a;
    this.isRunning = true, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
    const cloneData = this.cloneParseData(data, options);
    if (null == options ? void 0 : options.type) {
      const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
      this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
    } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
    return this.isRunning = false, emit && this.target.emit("afterParse", []), this;
  }
  transform(options, execute = true) {
    if (this.isRunning = true, options && options.type) {
      let pushOption = true;
      if ("fields" === options.type) {
        this._fields = options.options.fields;
        const index = this.transformsArr.findIndex((_op) => _op.type === options.type);
        index >= 0 && (pushOption = false, this.transformsArr[index].options.fields = this._fields);
      }
      if (pushOption && this.transformsArr.push(options), execute) {
        const lastTag = this.isLastTransform(options);
        this.executeTransform(options), lastTag && this.diffLastData();
      }
    }
    return this.sortTransform(), this.isRunning = false, this;
  }
  isLastTransform(options) {
    return this.transformsArr[this.transformsArr.length - 1] === options;
  }
  sortTransform() {
    this.transformsArr.length >= 2 && this.transformsArr.sort((a2, b) => {
      var _a, _b;
      return (null !== (_a = a2.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
    });
  }
  executeTransform(options, opt = {
    pushHistory: true,
    emitMessage: true
  }) {
    const { pushHistory, emitMessage } = opt, transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
    this.history && false !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, false !== emitMessage && this.target.emit("change", []);
  }
  resetTransformData() {
    this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
  }
  enableDiff(keys2) {
    this._diffData = true, this._diffKeys = keys2, this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  disableDiff() {
    this._diffData = false, this._diffMap = null, this._diffRank = null;
  }
  resetDiff() {
    this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  diffLastData() {
    var _a;
    if (!this._diffData) return;
    if (!this.latestData.forEach) return;
    if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length)) return;
    const next = this._diffRank + 1;
    if (0 === this._diffRank) this.latestData.forEach((d) => {
      d[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), d);
    }), this.latestDataAUD = {
      add: Array.from(this.latestData),
      del: [],
      update: []
    };
    else {
      let tempKey;
      this.latestDataAUD = {
        add: [],
        del: [],
        update: []
      }, this.latestData.forEach((d) => {
        d[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d) : this.latestDataAUD.add.push(d), this._diffMap.set(tempKey, d);
      }), this._diffMap.forEach((v, k2) => {
        v[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v), this._diffMap.delete(k2));
      });
    }
    this._diffRank = next;
  }
  cloneParseData(data, options) {
    let clone4 = false;
    return data instanceof _DataView || true !== (null == options ? void 0 : options.clone) || (clone4 = true), clone4 ? cloneDeep3(data) : data;
  }
  parseNewData(data, options) {
    this.parse(data, options || this.parseOption), this.reRunAllTransform();
  }
  updateRawData(data, options) {
    const cloneData = this.cloneParseData(data, options);
    this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
  }
  getFields() {
    var _a;
    return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
  }
  setFields(f, foreMerge = false) {
    this._fields = f && foreMerge ? merge3({}, this._fields, f) : f;
    const fieldsOption = this.transformsArr.find((_op) => "fields" === _op.type);
    !isNil_default3(this._fields) && isNil_default3(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
      type: "fields",
      options: {
        fields: this._fields
      }
    }, false)) : fieldsOption && (fieldsOption.options.fields = this._fields);
  }
  destroy() {
    this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
  }
};
function isDataView(obj2) {
  return obj2 instanceof DataView;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vutils-extension/es/spec/clone-deep.js
function cloneDeepSpec(spec, excludeKeys = ["data"]) {
  const value = spec;
  let result2;
  if (!isValid_default2(value) || "object" != typeof value) return value;
  if (isDataView(value) || isHTMLElement(value)) return value;
  const isArr = isArray_default2(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default2(value) || isNumber_default2(value) || isString_default2(value) ? value : isDate_default(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2) for (; ++index < (props || value).length; ) {
    const key = props ? props[index] : index, subValue = value[key];
    (null == excludeKeys ? void 0 : excludeKeys.includes(key.toString())) ? result2[key] = subValue : result2[key] = cloneDeepSpec(subValue, excludeKeys);
  }
  return result2;
}

// node_modules/@visactor/vtable/es/components/util/transform.js
function transformLegendTitleAttributes(title) {
  var _a, _b;
  const transformedTitle = Object.assign({}, title);
  return isEmpty_default(title.style) || (transformedTitle.textStyle = transformToGraphic(title.style)), isEmpty_default(title.textStyle) || merge(transformedTitle.textStyle, transformToGraphic(title.textStyle)), (null === (_a = title.shape) || void 0 === _a ? void 0 : _a.style) && transformToGraphic(transformedTitle.shape.style), (null === (_b = title.background) || void 0 === _b ? void 0 : _b.style) && transformToGraphic(transformedTitle.background.style), transformedTitle;
}
function transformToGraphic(style2) {
  return isEmpty_default(style2) || style2.angle && (style2.angle = degreeToRadian(style2.angle)), style2;
}
function transformComponentStyle(cfg = {}) {
  return isEmpty_default(cfg.style) || (cfg.style = transformToGraphic(cfg.style)), isEmpty_default(cfg.state) || Object.keys(cfg.state).forEach((key) => {
    isEmpty_default(cfg.state[key]) || (cfg.state[key] = transformToGraphic(cfg.state[key]));
  }), cfg;
}
function transformStateStyle(stateStyle) {
  return isEmpty_default(stateStyle) ? null : (Object.keys(stateStyle).forEach((key) => {
    isEmpty_default(stateStyle[key]) || (stateStyle[key] = transformToGraphic(stateStyle[key]));
  }), stateStyle);
}
function transformAxisLineStyle(lineCfg) {
  return transformComponentStyle(lineCfg), transformComponentStyle(lineCfg.startSymbol), transformComponentStyle(lineCfg.endSymbol), lineCfg;
}

// node_modules/@visactor/vtable/es/components/axis/get-axis-attributes.js
var DEFAULT_TITLE_STYLE = {
  left: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  right: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  radius: {},
  angle: {}
};
var DEFAULT_TEXT_FONT_FAMILY3 = "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol";
var DEFAULT_TEXT_FONT_SIZE2 = 14;
var THEME_CONSTANTS = {
  FONT_FAMILY: DEFAULT_TEXT_FONT_FAMILY3,
  LABEL_FONT_SIZE: 14,
  MAP_LABEL_FONT_SIZE: 10,
  TITLE_FONT_SIZE: 18,
  AXIS_TICK_SIZE: 4
};
var commonAxis = {
  domainLine: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  grid: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#EBEDF2",
      strokeOpacity: 1,
      lineDash: []
    }
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "#EBEDF2",
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  },
  tick: {
    visible: true,
    tickSize: THEME_CONSTANTS.AXIS_TICK_SIZE,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    tickSize: THEME_CONSTANTS.AXIS_TICK_SIZE / 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  label: {
    visible: true,
    space: 1,
    style: {
      fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE,
      fill: "#89909D",
      fontWeight: "normal",
      fillOpacity: 1
    },
    autoLimit: true
  },
  title: {
    space: 10,
    style: {
      fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
function getCommonAxis(theme4) {
  var _a, _b;
  return (null === (_b = null === (_a = null == theme4 ? void 0 : theme4.colorScheme) || void 0 === _a ? void 0 : _a.default) || void 0 === _b ? void 0 : _b.palette) ? merge({}, commonAxis, {
    tick: {
      style: {
        stroke: theme4.colorScheme.default.palette.axisDomainColor || "#D9DDE4"
      }
    },
    subTick: {
      style: {
        stroke: theme4.colorScheme.default.palette.axisDomainColor || "#D9DDE4"
      }
    },
    label: {
      style: {
        fill: theme4.colorScheme.default.palette.axisLabelFontColor || "#89909D"
      }
    },
    title: {
      style: {
        fill: theme4.colorScheme.default.palette.secondaryFontColor || "#333333"
      }
    }
  }) : commonAxis;
}
function getAxisAttributes(option) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  const spec = merge({}, option);
  let titleTextStyle, titleAngle = null !== (_b = null === (_a = spec.title) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
  "left" !== spec.orient && "right" !== spec.orient || (null === (_c = spec.title) || void 0 === _c ? void 0 : _c.autoRotate) && isNil_default(spec.title.angle) && (titleAngle = "left" === spec.orient ? -90 : 90, titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient]);
  const labelSpec = pickWithout(spec.label, ["style", "formatMethod", "state"]);
  return {
    orient: spec.orient,
    select: spec.select,
    hover: spec.hover,
    line: transformAxisLineStyle(spec.domainLine),
    label: Object.assign({
      style: transformToGraphic(spec.label.style),
      formatMethod: spec.label.formatMethod ? (value, datum, index) => spec.label.formatMethod(datum.rawValue, datum) : null,
      state: transformStateStyle(spec.label.state)
    }, labelSpec),
    tick: {
      visible: spec.tick.visible,
      length: spec.tick.tickSize,
      inside: spec.tick.inside,
      alignWithLabel: spec.tick.alignWithLabel,
      style: transformToGraphic(spec.tick.style),
      state: transformStateStyle(spec.tick.state),
      dataFilter: spec.tick.dataFilter
    },
    subTick: {
      visible: spec.subTick.visible,
      length: spec.subTick.tickSize,
      inside: spec.subTick.inside,
      count: spec.subTick.tickCount,
      style: transformToGraphic(spec.subTick.style),
      state: transformStateStyle(spec.subTick.state)
    },
    grid: {
      type: "line",
      visible: spec.grid.visible,
      alternateColor: spec.grid.alternateColor,
      alignWithLabel: spec.grid.alignWithLabel,
      style: transformToGraphic(spec.grid.style)
    },
    subGrid: {
      type: "line",
      visible: spec.subGrid.visible,
      alternateColor: spec.subGrid.alternateColor,
      style: transformToGraphic(spec.subGrid.style)
    },
    title: {
      visible: spec.title.visible,
      position: spec.title.position,
      space: spec.title.space,
      autoRotate: false,
      angle: titleAngle ? degreeToRadian(titleAngle) : null,
      textStyle: merge({}, titleTextStyle, transformToGraphic(spec.title.style)),
      padding: spec.title.padding,
      shape: {
        visible: null === (_d = spec.title.shape) || void 0 === _d ? void 0 : _d.visible,
        space: null === (_e = spec.title.shape) || void 0 === _e ? void 0 : _e.space,
        style: transformToGraphic(null === (_f = spec.title.shape) || void 0 === _f ? void 0 : _f.style)
      },
      background: {
        visible: null === (_g = spec.title.background) || void 0 === _g ? void 0 : _g.visible,
        style: transformToGraphic(null === (_h = spec.title.background) || void 0 === _h ? void 0 : _h.style)
      },
      state: {
        text: transformStateStyle(spec.title.state),
        shape: transformStateStyle(null === (_j = spec.title.shape) || void 0 === _j ? void 0 : _j.state),
        background: transformStateStyle(null === (_k = spec.title.background) || void 0 === _k ? void 0 : _k.state)
      }
    },
    panel: {
      visible: null === (_l = spec.background) || void 0 === _l ? void 0 : _l.visible,
      style: transformToGraphic(null === (_m = spec.background) || void 0 === _m ? void 0 : _m.style),
      state: transformStateStyle(null === (_o = spec.background) || void 0 === _o ? void 0 : _o.state)
    }
  };
}

// node_modules/@visactor/vtable/es/layout/chart-helper/get-chart-spec.js
var NO_AXISID_FRO_VTABLE = "NO_AXISID_FRO_VTABLE";
function getRawChartSpec(col, row, layout) {
  var _a, _b;
  const paths = layout.getCellHeaderPaths(col, row);
  let indicatorObj;
  if (layout.indicatorsAsCol) {
    const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath) => colPath.indicatorKey)) || void 0 === _a ? void 0 : _a.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  } else {
    const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath) => rowPath.indicatorKey)) || void 0 === _b ? void 0 : _b.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  }
  const chartSpec = null == indicatorObj ? void 0 : indicatorObj.chartSpec;
  if ("function" == typeof chartSpec) {
    return chartSpec({
      col,
      row,
      dataValue: layout._table.getCellOriginValue(col, row) || "",
      value: layout._table.getCellValue(col, row) || "",
      rect: layout._table.getCellRangeRelativeRect(layout._table.getCellRange(col, row)),
      table: layout._table
    });
  }
  return chartSpec;
}
function isShareChartSpec(col, row, layout) {
  var _a, _b;
  const paths = layout.getCellHeaderPaths(col, row);
  let indicatorObj;
  if (layout.indicatorsAsCol) {
    const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath) => colPath.indicatorKey)) || void 0 === _a ? void 0 : _a.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  } else {
    const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath) => rowPath.indicatorKey)) || void 0 === _b ? void 0 : _b.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  }
  return "function" != typeof (null == indicatorObj ? void 0 : indicatorObj.chartSpec);
}
function isNoChartDataRenderNothing(col, row, layout) {
  var _a, _b;
  const paths = layout.getCellHeaderPaths(col, row);
  let indicatorObj;
  if (layout.indicatorsAsCol) {
    const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath) => colPath.indicatorKey)) || void 0 === _a ? void 0 : _a.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  } else {
    const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath) => rowPath.indicatorKey)) || void 0 === _b ? void 0 : _b.indicatorKey;
    indicatorObj = layout.columnObjects.find((indicator) => indicator.indicatorKey === indicatorKey);
  }
  return null == indicatorObj ? void 0 : indicatorObj.noDataRenderNothing;
}
function checkHasCartesianChart(indicatorsDefine) {
  let isHasCartesianChart = false;
  for (let i = 0; i < indicatorsDefine.length; i++) {
    const columnObj = indicatorsDefine[i];
    if (columnObj.chartSpec && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "pie" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
      isHasCartesianChart = true;
      break;
    }
  }
  return isHasCartesianChart;
}
function isCartesianChart(col, row, layout) {
  let isHasCartesianChart = true;
  const chartSpec = layout.getRawChartSpec(col, row);
  return chartSpec && "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type || (isHasCartesianChart = false), isHasCartesianChart;
}
function isHasCartesianChartInline(col, row, checkDirection, layout) {
  let isHasCartesianChart = false;
  if (layout.indicatorsAsCol && "row" === checkDirection || !layout.indicatorsAsCol && "col" === checkDirection) for (let i = 0; i < layout.indicatorsDefine.length; i++) {
    const columnObj = layout.indicatorsDefine[i];
    if (columnObj.chartSpec && "pie" !== columnObj.chartSpec.type && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
      isHasCartesianChart = true;
      break;
    }
  }
  else {
    const chartSpec = layout.getRawChartSpec(col, row);
    chartSpec ? "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type && (isHasCartesianChart = true) : isHasCartesianChart = false;
  }
  return isHasCartesianChart;
}
function getChartSpec(col, row, layout) {
  let chartSpec = layout.getRawChartSpec(col, row);
  return chartSpec ? layout._table.isPivotChart() ? (chartSpec = cloneDeepSpec(chartSpec), chartSpec.sortDataByAxis = true, isArray_default(chartSpec.series) && chartSpec.series.forEach((serie) => {
    serie.sortDataByAxis = true;
  }), "gauge" !== chartSpec.type && "rose" !== chartSpec.type && "radar" !== chartSpec.type && (chartSpec.axes = layout.getChartAxes(col, row)), chartSpec.padding = 0, chartSpec.dataZoom = [], chartSpec) : chartSpec : null;
}
function getChartAxes(col, row, layout) {
  var _a, _b, _c;
  const axes = [];
  if (layout.indicatorsAsCol) {
    const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), colPath = layout.getColKeysPath(col, row);
    indicatorKeys.forEach((key, index) => {
      const { range: range5, targetTicks, targetRange, axisOption: axisOption2 } = getAxisRangeAndTicks(col, row, index, 0 === index ? "bottom" : "top", 0 === index ? "top" : "bottom", indicatorKeys, colPath, layout);
      isNumber_default(null == axisOption2 ? void 0 : axisOption2.min) && (range5.min = axisOption2.min), isNumber_default(null == axisOption2 ? void 0 : axisOption2.max) && (range5.max = axisOption2.max), hasSameAxis(axisOption2, axes) || axes.push(merge({
        range: range5,
        label: {
          style: {
            fontSize: DEFAULT_TEXT_FONT_SIZE2
          }
        }
      }, axisOption2, {
        type: (null == axisOption2 ? void 0 : axisOption2.type) || "linear",
        orient: 0 === index ? "bottom" : "top",
        label: {
          visible: false,
          flush: true
        },
        title: {
          visible: false
        },
        domainLine: {
          visible: false
        },
        seriesIndex: (null == axisOption2 ? void 0 : axisOption2.seriesId) ? void 0 : index,
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        sync: {
          axisId: NO_AXISID_FRO_VTABLE
        }
      }));
    });
    let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
    isArray_default(rowDimensionKey) && (rowDimensionKey = rowDimensionKey[0]);
    const data = layout.dataset.cacheCollectedValues[rowDimensionKey] || layout.dataset.collectedValues[rowDimensionKey] || [], rowPath = layout.getRowKeysPath(col, row), domain = data[null != rowPath ? rowPath : ""], { axisOption, isPercent: isPercent2, chartType } = getAxisOption(col, row, "left", layout);
    axes.push(merge({
      domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
      range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
      label: {
        style: {
          fontSize: DEFAULT_TEXT_FONT_SIZE2
        }
      }
    }, axisOption, {
      type: null !== (_a = null == axisOption ? void 0 : axisOption.type) && void 0 !== _a ? _a : "band",
      orient: "left",
      label: {
        visible: false
      },
      domainLine: {
        visible: false
      },
      tick: {
        visible: false
      },
      subTick: {
        visible: false
      },
      title: {
        visible: false
      }
    }));
  } else {
    const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), rowPath = layout.getRowKeysPath(col, row);
    indicatorKeys.forEach((key, index) => {
      const { range: range5, targetTicks, targetRange, axisOption: axisOption2 } = getAxisRangeAndTicks(col, row, index, 0 === index ? "left" : "right", 0 === index ? "right" : "left", indicatorKeys, rowPath, layout);
      isNumber_default(null == axisOption2 ? void 0 : axisOption2.min) && (range5.min = axisOption2.min), isNumber_default(null == axisOption2 ? void 0 : axisOption2.max) && (range5.max = axisOption2.max), hasSameAxis(axisOption2, axes) || axes.push(merge({
        range: range5,
        label: {
          style: {
            fontSize: DEFAULT_TEXT_FONT_SIZE2
          }
        }
      }, axisOption2, {
        type: (null == axisOption2 ? void 0 : axisOption2.type) || "linear",
        orient: 0 === index ? "left" : "right",
        label: {
          visible: false,
          flush: true
        },
        title: {
          visible: false
        },
        domainLine: {
          visible: false
        },
        seriesIndex: (null == axisOption2 ? void 0 : axisOption2.seriesId) ? void 0 : index,
        tick: {
          tickMode: getTickModeFunction(targetTicks, targetRange, range5, index)
        },
        sync: {
          axisId: NO_AXISID_FRO_VTABLE
        }
      }));
    });
    let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
    isArray_default(columnDimensionKey) && (columnDimensionKey = columnDimensionKey[0]);
    const data = layout.dataset.cacheCollectedValues[columnDimensionKey] || layout.dataset.collectedValues[columnDimensionKey] || [], colPath = layout.getColKeysPath(col, row), domain = null !== (_b = null == data ? void 0 : data[null != colPath ? colPath : ""]) && void 0 !== _b ? _b : [], { axisOption, isPercent: isPercent2, chartType } = getAxisOption(col, row, "bottom", layout);
    axes.push(merge({
      domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
      range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
      label: {
        style: {
          fontSize: DEFAULT_TEXT_FONT_SIZE2
        }
      }
    }, axisOption, {
      type: null !== (_c = null == axisOption ? void 0 : axisOption.type) && void 0 !== _c ? _c : "band",
      orient: "bottom",
      visible: true,
      label: {
        visible: false
      },
      domainLine: {
        visible: false
      },
      tick: {
        visible: false
      },
      subTick: {
        visible: false
      },
      title: {
        visible: false
      }
    }));
  }
  return axes;
}
function getChartDataId(col, row, layout) {
  var _a;
  const chartSpec = layout.getRawChartSpec(col, row);
  if (null == chartSpec ? void 0 : chartSpec.series) {
    const dataIdfield = {};
    return (null === (_a = chartSpec.data) || void 0 === _a ? void 0 : _a.id) && (dataIdfield[chartSpec.data.id] = void 0), null == chartSpec || chartSpec.series.forEach((seriesSpec) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      if (!(null === (_a2 = seriesSpec.data) || void 0 === _a2 ? void 0 : _a2.fromDataId)) if (null === (_b = seriesSpec.data) || void 0 === _b ? void 0 : _b.transforms) dataIdfield[null !== (_l = null !== (_j = null === (_h = seriesSpec.data) || void 0 === _h ? void 0 : _h.id) && void 0 !== _j ? _j : null === (_k = chartSpec.data) || void 0 === _k ? void 0 : _k.id) && void 0 !== _l ? _l : "data"] = void 0;
      else {
        const seriesField = "horizontal" === seriesSpec.direction ? seriesSpec.xField : seriesSpec.yField;
        dataIdfield[null !== (_f = null !== (_d = null === (_c = seriesSpec.data) || void 0 === _c ? void 0 : _c.id) && void 0 !== _d ? _d : null === (_e = chartSpec.data) || void 0 === _e ? void 0 : _e.id) && void 0 !== _f ? _f : "data"] = (null === (_g = seriesSpec.data) || void 0 === _g ? void 0 : _g.id) ? seriesField : void 0;
      }
    }), dataIdfield;
  }
  return chartSpec.data.id;
}
function checkHasChart(layout) {
  let isHasChart = false;
  for (let i = 0; i < layout.columnObjects.length; i++) {
    if (layout.columnObjects[i].chartSpec) {
      isHasChart = true;
      break;
    }
  }
  return isHasChart;
}
function hasSameAxis(axisOption, axes) {
  if (axisOption && isArray_default(axisOption.seriesId) && axisOption.seriesId.length > 0) {
    if (axes.filter((axis) => !(axis.orient !== axisOption.orient || !axis.seriesId || axis.seriesId.length !== axisOption.seriesId.length || !axis.seriesId.every((id, index) => id === axisOption.seriesId[index]))).length > 0) return true;
  }
  return false;
}

// node_modules/@visactor/vtable/es/layout/cell-range/simple-cell-range.js
function getCellRange2(col, row, layout) {
  var _a, _b, _c;
  if (-1 === col || -1 === row) return {
    start: {
      col,
      row
    },
    end: {
      col,
      row
    }
  };
  if (layout._cellRangeMap.has(`$${col}$${row}`)) return layout._cellRangeMap.get(`$${col}$${row}`);
  let cellRange = {
    start: {
      col,
      row
    },
    end: {
      col,
      row
    }
  };
  if (layout.transpose) cellRange = getCellRangeTranspose(col, row, layout);
  else if (layout.headerLevelCount <= row) {
    if (layout.headerLevelCount <= row && (null === (_b = null === (_a = layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount]) || void 0 === _a ? void 0 : _a.define) || void 0 === _b ? void 0 : _b.mergeCell)) {
      const value = layout._table.getCellValue(col, row);
      for (let r = row - 1; r >= layout.headerLevelCount; r--) {
        const last_Value = layout._table.getCellValue(col, r);
        if ("boolean" == typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell) {
          if (value !== last_Value) break;
        } else if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, last_Value, {
          source: {
            col,
            row
          },
          target: {
            col,
            row: r
          },
          table: layout._table
        })) break;
        cellRange.start.row = r;
      }
      for (let r = row + 1; r < layout.rowCount; r++) {
        const next_Value = layout._table.getCellValue(col, r);
        if ("boolean" == typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell) {
          if (value !== next_Value) break;
        } else if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, next_Value, {
          source: {
            col,
            row
          },
          target: {
            col,
            row: r
          },
          table: layout._table
        })) break;
        cellRange.end.row = r;
      }
    }
    getTreeTitleMerge(col, row, cellRange, layout);
  } else {
    const id = layout.getCellId(col, row);
    for (let c2 = col - 1; c2 >= 0 && id === layout.getCellId(c2, row); c2--) cellRange.start.col = c2;
    for (let c2 = col + 1; c2 < (null !== (_c = layout.colCount) && void 0 !== _c ? _c : 0) && id === layout.getCellId(c2, row); c2++) cellRange.end.col = c2;
    for (let r = row - 1; r >= 0 && id === layout.getCellId(col, r); r--) cellRange.start.row = r;
    for (let r = row + 1; r < layout.headerLevelCount && id === layout.getCellId(col, r); r++) cellRange.end.row = r;
  }
  return layout._cellRangeMap.set(`$${col}$${row}`, cellRange), cellRange;
}
function getTreeTitleMerge(col, row, cellRange, layout) {
  var _a;
  if ("tree" !== layout.rowHierarchyType) return;
  const cellRecord = layout._table.getCellRawRecord(col, row);
  (null === (_a = layout._table.internalProps.rowSeriesNumber) || void 0 === _a ? void 0 : _a.enableTreeCheckbox) ? (null == cellRecord ? void 0 : cellRecord.vtableMerge) && col >= layout.leftRowSeriesNumberColumnCount && (cellRange.start.col = layout.rowHeaderLevelCount + layout.leftRowSeriesNumberColumnCount, cellRange.end.col = layout.colCount - 1, cellRange.start.row = cellRange.end.row = row) : (null == cellRecord ? void 0 : cellRecord.vtableMerge) && (cellRange.start.col = layout.rowHeaderLevelCount, cellRange.end.col = layout.colCount - 1, cellRange.start.row = cellRange.end.row = row);
}
function getCellRangeTranspose(col, row, layout) {
  var _a, _b, _c, _d;
  const result2 = {
    start: {
      col,
      row
    },
    end: {
      col,
      row
    }
  };
  if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col || -1 === col && -1 === row) {
    if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col && (null === (_b = null === (_a = layout.columnObjects[row]) || void 0 === _a ? void 0 : _a.define) || void 0 === _b ? void 0 : _b.mergeCell)) {
      const value = layout._table.getCellValue(col, row);
      for (let c2 = col - 1; c2 >= layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount; c2--) {
        const last_Value = layout._table.getCellValue(c2, row);
        if ("boolean" == typeof layout.columnObjects[row].define.mergeCell) {
          if (value !== last_Value) break;
        } else if (!layout.columnObjects[row].define.mergeCell(value, last_Value, {
          source: {
            col,
            row
          },
          target: {
            col: c2,
            row
          },
          table: layout._table
        })) break;
        result2.start.col = c2;
      }
      for (let c2 = col + 1; c2 < (null !== (_c = layout.colCount) && void 0 !== _c ? _c : 0); c2++) {
        const next_Value = layout._table.getCellValue(c2, row);
        if ("boolean" == typeof layout.columnObjects[row].define.mergeCell) {
          if (value !== next_Value) break;
        } else if (!layout.columnObjects[row].define.mergeCell(value, next_Value, {
          source: {
            col,
            row
          },
          target: {
            col: c2,
            row
          },
          table: layout._table
        })) break;
        result2.end.col = c2;
      }
    }
    return result2;
  }
  const id = layout.getCellId(col, row);
  for (let r = row - 1; r >= 0 && id === layout.getCellId(col, r); r--) result2.start.row = r;
  for (let r = row + 1; r < (null !== (_d = layout.rowCount) && void 0 !== _d ? _d : 0) && id === layout.getCellId(col, r); r++) result2.end.row = r;
  for (let c2 = col - 1; c2 >= 0 && id === layout.getCellId(c2, row); c2--) result2.start.col = c2;
  for (let c2 = col + 1; c2 < layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount && id === layout.getCellId(c2, row); c2++) result2.end.col = c2;
  return result2;
}

// node_modules/@visactor/vtable/es/layout/simple-header-layout.js
var SimpleHeaderLayoutMap = class {
  constructor(table, columns, showHeader, hierarchyIndent) {
    var _a, _b;
    this.seqId = 0, this.leftRowSeriesNumberColumnCount = 0, this.rightRowSeriesNumberColumnCount = 0, this.bodyRowSpanCount = 1, this._transpose = false, this._showHeader = true, this._recordsCount = 0, this._hasAggregation = false, this._hasAggregationOnTopCount = 0, this._hasAggregationOnBottomCount = 0, this._cellRangeMap = /* @__PURE__ */ new Map(), this._showHeader = showHeader, this._table = table, this._columns = [], this._columnsIncludeHided = [], this._headerCellIds = [], this.hierarchyIndent = null != hierarchyIndent ? hierarchyIndent : 20, this.hierarchyTextStartAlignment = table.options.hierarchyTextStartAlignment, this.columnHierarchyType = table.options.headerHierarchyType, this.columnExpandLevel = null !== (_a = table.options.headerExpandLevel) && void 0 !== _a ? _a : 1, this.columnTree = new DimensionTree(columns, {
      seqId: 0
    }, null !== (_b = this.columnHierarchyType) && void 0 !== _b ? _b : null, "grid-tree" === this.columnHierarchyType ? this.columnExpandLevel : void 0), this._headerObjectsIncludeHided = this._addHeaders(0, columns, []), this._headerObjects = this._headerObjectsIncludeHided.filter((col) => true !== col.define.hide), this._headerObjectMap = this._headerObjects.reduce((o, e) => (o[e.id] = e, o), {}), this.rowHierarchyType = checkHasTreeDefine(this) ? "tree" : "grid", this._hasAggregation = checkHasAggregation(this), this._hasAggregationOnBottomCount = checkHasAggregationOnBottom(this), this._hasAggregationOnTopCount = checkHasAggregationOnTop(this), this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber);
  }
  handleRowSeriesNumber(rowSeriesNumber) {
    var _a;
    rowSeriesNumber && (Array.isArray(rowSeriesNumber) ? this.rowSeriesNumberColumn = rowSeriesNumber.map((seriesNumber, index) => {
      var _a2, _b;
      return {
        id: this.seqId++,
        title: seriesNumber.title,
        define: merge({
          field: "_vtable_rowSeries_number_" + index
        }, seriesNumber),
        cellType: null !== (_a2 = seriesNumber.cellType) && void 0 !== _a2 ? _a2 : "text",
        headerType: "checkbox" === seriesNumber.cellType ? "checkbox" : "text",
        style: seriesNumber.style,
        width: seriesNumber.width,
        format: seriesNumber.format,
        field: null !== (_b = seriesNumber.field) && void 0 !== _b ? _b : "_vtable_rowSeries_number_" + index,
        icon: seriesNumber.icon,
        headerIcon: seriesNumber.headerIcon,
        isChildNode: false
      };
    }) : this.rowSeriesNumberColumn = [{
      id: this.seqId++,
      title: rowSeriesNumber.title,
      define: merge({
        field: "_vtable_rowSeries_number"
      }, rowSeriesNumber),
      cellType: null !== (_a = rowSeriesNumber.cellType) && void 0 !== _a ? _a : "text",
      headerType: "checkbox" === rowSeriesNumber.cellType ? "checkbox" : "text",
      style: rowSeriesNumber.style,
      width: rowSeriesNumber.width,
      format: rowSeriesNumber.format,
      field: "_vtable_rowSeries_number",
      icon: rowSeriesNumber.icon,
      headerIcon: rowSeriesNumber.headerIcon,
      isChildNode: false
    }], this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem) => true), this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem) => false), this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length, this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length);
  }
  get transpose() {
    return this._transpose;
  }
  set transpose(_transpose) {
    this._transpose = _transpose;
  }
  get showHeader() {
    return this._showHeader;
  }
  set showHeader(_showHeader) {
    this._showHeader = _showHeader;
  }
  isSeriesNumberInHeader(col, row) {
    if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) {
      if (this.transpose) return false;
      if (row < this.headerLevelCount) return true;
    }
    if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
      if (this.transpose) return false;
      if (row < this.headerLevelCount) return true;
    }
    return false;
  }
  isSeriesNumberInBody(col, row) {
    if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
      if (this.transpose) return true;
      if (row >= this.headerLevelCount) return true;
    }
    if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
      if (this.transpose) return true;
      if (row >= this.headerLevelCount) return true;
    }
    return false;
  }
  isSeriesNumber(col, row) {
    if (isValid_default(col) && isValid_default(row)) {
      if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) return true;
      if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) return true;
    }
    return false;
  }
  getSeriesNumberHeader(col, row) {
    if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
      if (this.transpose) return;
      if (row < this.headerLevelCount) return Object.assign({}, this.leftRowSeriesNumberColumn[col], {
        style: Object.assign({}, this._table.transpose ? this._table.internalProps.theme.rowHeaderStyle : this._table.internalProps.theme.headerStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
      });
    }
    if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount) {
      if (this.transpose) return;
      if (row < this.headerLevelCount) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
    }
  }
  getSeriesNumberBody(col, row) {
    if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
      if (this.transpose) return this.leftRowSeriesNumberColumn[col];
      if (row >= this.headerLevelCount) return this.leftRowSeriesNumberColumn[col];
    }
    if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
      if (this.transpose) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
      if (row >= this.headerLevelCount) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
    }
  }
  isHeader(col, row) {
    return !!(this.transpose && col >= this.leftRowSeriesNumberColumnCount && col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount) || !this.transpose && row >= 0 && row < this.headerLevelCount;
  }
  isAggregation(col, row) {
    if (this.hasAggregation) {
      if (this.hasAggregationOnBottomCount) {
        if (this.transpose) {
          if (col >= this.colCount - this.hasAggregationOnBottomCount) return true;
        } else if (row >= this.rowCount - this.hasAggregationOnBottomCount) return true;
      }
      if (this.hasAggregationOnTopCount) {
        if (this.transpose) {
          if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) return true;
        } else if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) return true;
      }
    }
    return false;
  }
  isTopAggregation(col, row) {
    if (this.hasAggregationOnTopCount) {
      if (this.transpose) {
        if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) return true;
      } else if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) return true;
    }
    return false;
  }
  isBottomAggregation(col, row) {
    if (this.hasAggregationOnBottomCount) {
      if (this.transpose) {
        if (col >= this.colCount - this.hasAggregationOnBottomCount) return true;
      } else if (row >= this.rowCount - this.hasAggregationOnBottomCount) return true;
    }
    return false;
  }
  get hasAggregation() {
    return this._hasAggregation;
  }
  get hasAggregationOnTopCount() {
    return this._hasAggregationOnTopCount;
  }
  get hasAggregationOnBottomCount() {
    return this._hasAggregationOnBottomCount;
  }
  getAggregatorsByCell(col, row) {
    return this.getColumnDefine(col, row).vtable_aggregator;
  }
  getAggregatorsByCellRange(startCol, startRow, endCol, endRow) {
    let aggregators = [];
    if (!this.transpose) {
      for (let i = startCol; i <= endCol; i++) {
        const column = this.getColumnDefine(i, startRow);
        column.vtable_aggregator && (aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [column.vtable_aggregator]));
      }
      return aggregators;
    }
    for (let i = startRow; i <= endRow; i++) {
      const column = this.getColumnDefine(startCol, i);
      column.vtable_aggregator && (aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [column.vtable_aggregator]));
    }
    return [];
  }
  getAggregatorOnTop(col, row) {
    const column = this.getColumnDefine(col, row), aggregators = column.vtable_aggregator, aggregation = column.aggregation;
    if (Array.isArray(aggregation)) {
      const topAggregators = aggregation.reduce((indexs, agg, index) => (agg.showOnTop && indexs.push(index), indexs), []).map((index) => aggregators[index]);
      return this.transpose ? topAggregators[col - this.rowHeaderLevelCount] : topAggregators[row - this.columnHeaderLevelCount];
    }
    return this.transpose && col - this.rowHeaderLevelCount == 0 ? (null == aggregation ? void 0 : aggregation.showOnTop) ? aggregators : null : this.transpose || row - this.columnHeaderLevelCount != 0 ? null : (null == aggregation ? void 0 : aggregation.showOnTop) ? aggregators : null;
  }
  getAggregatorOnBottom(col, row) {
    const column = this.getColumnDefine(col, row), aggregators = column.vtable_aggregator, aggregation = column.aggregation;
    if (Array.isArray(aggregation)) {
      const bottomAggregators = aggregation.reduce((indexs, agg, index) => (agg.showOnTop || indexs.push(index), indexs), []).map((index) => aggregators[index]);
      return this.transpose ? bottomAggregators[col - (this.colCount - this.hasAggregationOnBottomCount)] : bottomAggregators[row - (this.rowCount - this.hasAggregationOnBottomCount)];
    }
    return this.transpose && col - (this.colCount - this.hasAggregationOnBottomCount) == 0 ? (null == aggregation ? void 0 : aggregation.showOnTop) ? null : aggregators : this.transpose || row - (this.rowCount - this.hasAggregationOnBottomCount) != 0 || (null == aggregation ? void 0 : aggregation.showOnTop) ? null : aggregators;
  }
  getAggregatorCellAddress(startCol, startRow, endCol, endRow) {
    const cellAddrs = [], topCount = this.hasAggregationOnTopCount, bottomCount = this.hasAggregationOnBottomCount;
    if (this.transpose) for (let row = startRow; row <= endRow; row++) {
      if (this.getColumnDefine(startCol, row).vtable_aggregator) {
        for (let i = 0; i < topCount; i++) cellAddrs.push({
          col: this.headerLevelCount + i,
          row
        });
        for (let i = 0; i < bottomCount; i++) cellAddrs.push({
          col: this.rowCount - bottomCount + i,
          row
        });
      }
    }
    else for (let col = startCol; col <= endCol; col++) {
      if (this.getColumnDefine(col, startRow).vtable_aggregator) {
        for (let i = 0; i < topCount; i++) cellAddrs.push({
          col,
          row: this.headerLevelCount + i
        });
        for (let i = 0; i < bottomCount; i++) cellAddrs.push({
          col,
          row: this.rowCount - bottomCount + i
        });
      }
    }
    return cellAddrs;
  }
  getCellLocation(col, row) {
    return this.isHeader(col, row) ? this.transpose ? "rowHeader" : "columnHeader" : "body";
  }
  isRowHeader(col, row) {
    return !!(this.transpose && col >= this.leftRowSeriesNumberColumnCount && col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount);
  }
  isColumnHeader(col, row) {
    return !this.transpose && row >= 0 && row <= this.headerLevelCount - 1 && col >= this.leftRowSeriesNumberColumnCount && col < this.colCount - this.rightRowSeriesNumberColumnCount;
  }
  isFrozenColumn(col, row) {
    if (isValid_default(row)) {
      if (col >= 0 && col < this.frozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return true;
    } else if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) return true;
    return false;
  }
  isRightFrozenColumn(col, row) {
    if (isValid_default(row)) {
      if (col >= this.colCount - this.rightFrozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return true;
    } else if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) return true;
    return false;
  }
  isFrozenRow(col, row) {
    if (isValid_default(row)) {
      if (row >= 0 && row < this.frozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return true;
    } else if (row = col, this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) return true;
    return false;
  }
  isBottomFrozenRow(col, row) {
    if (isValid_default(row)) {
      if (row >= this.rowCount - this.bottomFrozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return true;
    } else if (row = col, this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) return true;
    return false;
  }
  isLeftTopCorner(col, row) {
    return col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount;
  }
  isLeftBottomCorner(col, row) {
    return col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
  }
  isRightTopCorner(col, row) {
    return col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount;
  }
  isRightBottomCorner(col, row) {
    return col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
  }
  isCornerHeader(col, row) {
    return false;
  }
  getColumnHeaderRange() {
    var _a, _b;
    return this.transpose ? {
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: this._headerCellIds.length - 1,
        row: (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0) - 1
      }
    } : {
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0) - 1,
        row: this._headerCellIds.length - 1
      }
    };
  }
  getRowHeaderRange() {
    var _a, _b;
    return this.transpose ? {
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: this._headerCellIds.length - 1,
        row: (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0) - 1
      }
    } : {
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0) - 1,
        row: this._headerCellIds.length - 1
      }
    };
  }
  getCornerHeaderRange() {
  }
  getBodyRange() {
    var _a, _b, _c, _d;
    return this.transpose ? {
      start: {
        col: this.headerLevelCount,
        row: 0
      },
      end: {
        col: (null !== (_a = this.colCount) && void 0 !== _a ? _a : 0) - 1,
        row: (null !== (_b = this.rowCount) && void 0 !== _b ? _b : 0) - 1
      }
    } : {
      start: {
        col: 0,
        row: this.headerLevelCount
      },
      end: {
        col: (null !== (_c = this.colCount) && void 0 !== _c ? _c : 0) - 1,
        row: (null !== (_d = this.rowCount) && void 0 !== _d ? _d : 0) - 1
      }
    };
  }
  get headerLevelCount() {
    return this.showHeader ? this._headerCellIds.length : 0;
  }
  get columnHeaderLevelCount() {
    return this.transpose ? 0 : this.headerLevelCount;
  }
  get rowHeaderLevelCount() {
    return this.transpose ? this.headerLevelCount : 0;
  }
  get frozenColCount() {
    return this._table.internalProps.frozenColCount ? this.colCount > this._table.internalProps.frozenColCount ? this._table.internalProps.frozenColCount : this.colCount : 0;
  }
  get frozenRowCount() {
    return this._table.internalProps.frozenRowCount ? this.rowCount >= this._table.internalProps.frozenRowCount ? this._table.internalProps.frozenRowCount : this.rowCount : 0;
  }
  get bottomFrozenRowCount() {
    return this._table.internalProps.bottomFrozenRowCount ? this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount ? this._table.internalProps.bottomFrozenRowCount : this.rowCount - this.headerLevelCount : 0;
  }
  get rightFrozenColCount() {
    return this._table.internalProps.rightFrozenColCount ? this.colCount - this.frozenColCount >= this._table.internalProps.rightFrozenColCount ? this._table.internalProps.rightFrozenColCount : Math.max(0, this.colCount - this.frozenColCount) : 0;
  }
  get colCount() {
    return this.transpose ? this.headerLevelCount + this.recordsCount + this.leftRowSeriesNumberColumnCount + this.rightRowSeriesNumberColumnCount : this._columns.length + this.leftRowSeriesNumberColumnCount + this.rightRowSeriesNumberColumnCount;
  }
  get rowCount() {
    return this.transpose ? this._columns.length : this.headerLevelCount + this.recordsCount;
  }
  get bodyRowCount() {
    return this.transpose ? this._columns.length : this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
  }
  get bodyColCount() {
    return this.transpose ? this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount : this._columns.length;
  }
  get recordsCount() {
    return this._recordsCount;
  }
  set recordsCount(recordsCount) {
    this._recordsCount = recordsCount;
  }
  get headerObjects() {
    return this._headerObjects;
  }
  get columnObjects() {
    return this._columns;
  }
  get headerObjectsIncludeHided() {
    return this._headerObjectsIncludeHided;
  }
  get columnWidths() {
    if (this.leftRowSeriesNumberColumnCount) {
      const widths = this.leftRowSeriesNumberColumn.map((item) => ({
        width: item.width,
        minWidth: item.minWidth,
        maxWidth: item.maxWidth
      }));
      return widths.push(...this._columns.map((item) => ({
        width: item.width,
        minWidth: item.minWidth,
        maxWidth: item.maxWidth
      }))), widths;
    }
    return this._columns.map((item) => ({
      width: item.width,
      minWidth: item.minWidth,
      maxWidth: item.maxWidth
    }));
  }
  getColumnWidthDefined(col) {
    var _a;
    if (col >= 0) {
      if (col < this.leftRowSeriesNumberColumnCount) return this.leftRowSeriesNumberColumn[col];
      if (this.transpose) {
        let maxWidth, minWidth, width = 0;
        if (col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount) {
          let isAuto;
          return this.columnObjects.forEach((obj2, index) => {
            "number" == typeof obj2.width ? width = Math.max(obj2.width, width) : "auto" === obj2.width && (isAuto = true), "number" == typeof obj2.minWidth && (minWidth = Math.max(obj2.minWidth, minWidth)), "number" == typeof obj2.maxWidth && (maxWidth = Math.max(obj2.maxWidth, maxWidth));
          }), width = width > 0 ? width : isAuto ? "auto" : void 0, {
            width,
            minWidth,
            maxWidth
          };
        }
        if (this.isRowHeader(col, 0)) {
          const defaultWidth = Array.isArray(this._table.defaultHeaderColWidth) ? null !== (_a = this._table.defaultHeaderColWidth[col]) && void 0 !== _a ? _a : this._table.defaultColWidth : this._table.defaultHeaderColWidth;
          return "auto" === defaultWidth ? {
            width: "auto"
          } : {
            width: defaultWidth
          };
        }
      }
      return this._columns[col - this.leftRowSeriesNumberColumnCount];
    }
  }
  getCellId(col, row) {
    var _a, _b, _c, _d;
    return this.transpose ? col >= this.headerLevelCount + this.leftRowSeriesNumberColumnCount ? null === (_a = this._columns[row]) || void 0 === _a ? void 0 : _a.id : this.isSeriesNumber(col, row) ? row + "_series_number" : null === (_b = this._headerCellIds[col - this.leftRowSeriesNumberColumnCount]) || void 0 === _b ? void 0 : _b[row] : this.isSeriesNumber(col, row) ? this.rowSeriesNumberColumn[col].id : this.headerLevelCount <= row ? null === (_c = this._columns[col - this.leftRowSeriesNumberColumnCount]) || void 0 === _c ? void 0 : _c.id : null === (_d = this._headerCellIds[row]) || void 0 === _d ? void 0 : _d[col - this.leftRowSeriesNumberColumnCount];
  }
  getHeader(col, row) {
    if (this.isSeriesNumberInHeader(col, row)) return this.getSeriesNumberHeader(col, row);
    const id = this.getCellId(col, row);
    return this._headerObjectMap[id];
  }
  getHeaderField(col, row) {
    var _a, _b, _c;
    if (this.isSeriesNumberInHeader(col, row)) return null === (_a = this.getSeriesNumberHeader(col, row)) || void 0 === _a ? void 0 : _a.field;
    if (this.isSeriesNumberInBody(col, row)) return null === (_b = this.getSeriesNumberBody(col, row)) || void 0 === _b ? void 0 : _b.field;
    const id = this.getCellId(col, row);
    return (null === (_c = this._headerObjectMap[id]) || void 0 === _c ? void 0 : _c.field) || (this.transpose ? this._columns[row] && this._columns[row].field : this._columns[col - this.leftRowSeriesNumberColumnCount] && this._columns[col - this.leftRowSeriesNumberColumnCount].field);
  }
  getHeaderCellAdressById(id) {
    for (let i = 0; i < this._headerCellIds.length; i++) {
      const row = this._headerCellIds[i];
      for (let j = 0; j < row.length; j++) if (row[j] === id) return this.transpose ? {
        col: i,
        row: j
      } : {
        col: j + this.leftRowSeriesNumberColumnCount,
        row: i
      };
    }
  }
  getHeaderCellAddressByField(field) {
    const hd = this.headerObjects.find((col) => col && col.field === field);
    return hd && this.getHeaderCellAdressById(hd.id);
  }
  getBody(col, _row) {
    return this.isSeriesNumber(col, _row) ? this.getSeriesNumberBody(col, _row) : this.transpose ? this._columns[_row] : this._columns[col - this.leftRowSeriesNumberColumnCount];
  }
  getBodyLayoutRangeById(id) {
    var _a, _b;
    if (this.transpose) {
      for (let row = 0; row < (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0); row++) if (id === this._columns[row].id) return {
        start: {
          col: 0,
          row
        },
        end: {
          col: 0,
          row
        }
      };
    } else for (let col = this.leftRowSeriesNumberColumnCount; col < (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0); col++) if (id === this._columns[col - this.leftRowSeriesNumberColumnCount].id) return {
      start: {
        col,
        row: 0
      },
      end: {
        col,
        row: 0
      }
    };
    return {
      start: {
        col: -1,
        row: -1
      },
      end: {
        col: -1,
        row: -1
      }
    };
  }
  getCellRange(col, row) {
    return getCellRange2(col, row, this);
  }
  isCellRangeEqual(col, row, targetCol, targetRow) {
    const range1 = this.getCellRange(col, row), range22 = this.getCellRange(targetCol, targetRow);
    return range1.start.col === range22.start.col && range1.end.col === range22.end.col && range1.start.row === range22.start.row && range1.end.row === range22.end.row;
  }
  getRecordShowIndexByCell(col, row) {
    const skipRowCount = this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount;
    return this.transpose ? col < skipRowCount ? -1 : col - skipRowCount : row < skipRowCount ? -1 : row - skipRowCount;
  }
  getRecordStartRowByRecordIndex(index) {
    return (this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount) + index;
  }
  _addHeaders(row, column, roots2, hideColumnsSubHeader) {
    const results = [], rowCells = this._newRow(row, hideColumnsSubHeader);
    return column.forEach((hd) => {
      var _a, _b, _c, _d;
      const col = this._columns.length, id = this.seqId++, cell = {
        id,
        title: null !== (_a = hd.title) && void 0 !== _a ? _a : hd.caption,
        headerIcon: hd.headerIcon,
        field: hd.field,
        style: hd.headerStyle,
        headerType: null !== (_b = hd.headerType) && void 0 !== _b ? _b : "text",
        dropDownMenu: hd.dropDownMenu,
        define: hd,
        hierarchyState: hd.hierarchyState,
        columnWidthComputeMode: hd.columnWidthComputeMode
      };
      results[id] = cell;
      for (let r = row - 1; r >= 0; r--) this._headerCellIds[r] && (this._headerCellIds[r][col] = roots2[r]);
      hideColumnsSubHeader ? this._headerCellIds[row - 1] && (rowCells[col] = this._headerCellIds[row - 1][col]) : rowCells[col] = id;
      const expand = !hd.hierarchyState || hd.hierarchyState === HierarchyState.expand;
      if (hd.columns && expand) {
        !hd.columns.every((c2) => c2.hide) && this._addHeaders(row + 1, hd.columns, [...roots2, id], hd.hideColumnsSubHeader || hideColumnsSubHeader).forEach((c2) => results.push(c2));
      } else {
        const colDef = {
          id: this.seqId++,
          field: hd.field,
          fieldFormat: hd.fieldFormat,
          width: hd.width,
          minWidth: hd.minWidth,
          maxWidth: hd.maxWidth,
          icon: hd.icon,
          cellType: null !== (_d = null !== (_c = hd.cellType) && void 0 !== _c ? _c : hd.columnType) && void 0 !== _d ? _d : "text",
          chartModule: "chartModule" in hd ? hd.chartModule : null,
          chartSpec: "chartSpec" in hd ? hd.chartSpec : null,
          sparklineSpec: "sparklineSpec" in hd ? hd.sparklineSpec : DefaultSparklineSpec,
          style: hd.style,
          define: hd,
          columnWidthComputeMode: hd.columnWidthComputeMode,
          disableColumnResize: null == hd ? void 0 : hd.disableColumnResize,
          aggregation: hd.aggregation,
          isChildNode: row >= 1
        };
        if (this._columnsIncludeHided.push(colDef), true !== hd.hide) {
          this._columns.push(colDef);
          for (let r = row + 1; r < this._headerCellIds.length; r++) this._headerCellIds[r][col] = id;
        }
      }
    }), results;
  }
  _newRow(row, hideColumnsSubHeader = false) {
    if (this._headerCellIds[row]) {
      const prev2 = this._headerCellIds[row - 1];
      if (prev2.length > this._headerCellIds[row].length) for (let col = this._headerCellIds[row].length; col < prev2.length; col++) this._headerCellIds[row][col] = prev2[col];
      return this._headerCellIds[row];
    }
    if (hideColumnsSubHeader) return [];
    const newRow = this._headerCellIds[row] = [];
    if (!this._columns.length) return newRow;
    const prev = this._headerCellIds[row - 1];
    for (let col = 0; col < prev.length; col++) newRow[col] = prev[col];
    return newRow;
  }
  getCellHeaderPaths(col, row) {
    if (this.isSeriesNumber(col, row)) return;
    let colPath = [], rowPath = [];
    return this.transpose ? rowPath = [{
      field: this._columns[row].field
    }] : colPath = [{
      field: this._columns[col - this.leftRowSeriesNumberColumnCount].field
    }], {
      colHeaderPaths: colPath,
      rowHeaderPaths: rowPath,
      cellLocation: this.getCellLocation(col, row)
    };
  }
  getParentCellId(col, row) {
    if (0 !== row) {
      if (this.isColumnHeader(col, row)) return this.getCellId(col, row - 1);
      if (this.isRowHeader(col, row)) {
        if (this.isSeriesNumberInBody(col - 1, row)) return;
        return this.getCellId(col - 1, row);
      }
    }
  }
  canMoveHeaderPosition(source, target) {
    if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) return false;
    if (!this.transpose && this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row)) {
      const sourceIndex = this.getRecordShowIndexByCell(0, source.row), targetIndex = this.getRecordShowIndexByCell(0, target.row);
      return this._table.dataSource.canChangeOrder(sourceIndex, targetIndex);
    }
    if (this.transpose && this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row) && (this.getBody(source.col + this.leftRowSeriesNumberColumnCount, source.row).isChildNode && this.getBody(target.col + this.leftRowSeriesNumberColumnCount, target.row).isChildNode ? (source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1, target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1) : (source.col = source.col + this.leftRowSeriesNumberColumnCount, target.col = target.col + this.leftRowSeriesNumberColumnCount)), source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) return false;
    if ("disabled" === this._table.internalProps.frozenColDragHeaderMode && this._table.isFrozenColumn(target.col)) return false;
    const sourceCellRange = this.getCellRange(source.col, source.row);
    if (this.isColumnHeader(source.col, source.row)) {
      return this.getParentCellId(source.col, sourceCellRange.start.row) === this.getParentCellId(target.col, sourceCellRange.start.row);
    }
    if (this.isRowHeader(source.col, source.row)) {
      return this.getParentCellId(sourceCellRange.start.col, source.row) === this.getParentCellId(sourceCellRange.start.col, target.row);
    }
    return false;
  }
  moveHeaderPosition(source, target) {
    var _a, _b;
    if ((!(null === (_a = this._table.options.dragOrder) || void 0 === _a ? void 0 : _a.validateDragOrderOnEnd) || (null === (_b = this._table.options.dragOrder) || void 0 === _b ? void 0 : _b.validateDragOrderOnEnd(source, target))) && this.canMoveHeaderPosition(source, target)) {
      let sourceCellRange = this.getCellRange(source.col, source.row);
      if (this.isColumnHeader(source.col, source.row)) {
        const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
        let targetIndex;
        const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
        if (targetIndex = target.col >= source.col ? targetCellRange.end.col - sourceSize + 1 : targetCellRange.start.col, targetIndex === sourceCellRange.start.col) return null;
        for (let row = 0; row < this._headerCellIds.length; row++) {
          const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
          sourceIds.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
        }
        const sourceColumns = this._columns.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
        return sourceColumns.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), Array.prototype.splice.apply(this._columns, sourceColumns), this.columnTree.movePosition(sourceCellRange.start.row, sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, targetIndex - this.leftRowSeriesNumberColumnCount), this.columnTree.reset(this.columnTree.tree.children), this._cellRangeMap = /* @__PURE__ */ new Map(), {
          sourceIndex: sourceCellRange.start.col,
          targetIndex,
          sourceSize,
          targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
          moveType: "column"
        };
      }
      if (this.isRowHeader(source.col, source.row) || this.isSeriesNumberInBody(source.col, source.row) && this.transpose) {
        this.isSeriesNumberInBody(source.col, source.row) && (sourceCellRange = this.getCellRange(source.col + this.leftRowSeriesNumberColumnCount, source.row));
        const sourceSize = sourceCellRange.end.row - sourceCellRange.start.row + 1;
        let targetIndex;
        const targetCellRange = this.getCellRange(sourceCellRange.start.col, target.row);
        if (targetIndex = target.row >= source.row ? targetCellRange.end.row - sourceSize + 1 : targetCellRange.start.row, targetIndex === sourceCellRange.start.row) return null;
        for (let row = 0; row < this._headerCellIds.length; row++) {
          const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.row, sourceSize);
          sourceIds.unshift(targetIndex, 0), Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
        }
        const sourceColumns = this._columns.splice(sourceCellRange.start.row, sourceSize);
        return sourceColumns.unshift(targetIndex, 0), Array.prototype.splice.apply(this._columns, sourceColumns), this.columnTree.movePosition(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceCellRange.start.row, targetIndex + (target.row > source.row ? sourceCellRange.end.row - sourceCellRange.start.row : 0)), this.columnTree.reset(this.columnTree.tree.children), this._cellRangeMap = /* @__PURE__ */ new Map(), {
          sourceIndex: sourceCellRange.start.row,
          targetIndex,
          sourceSize,
          targetSize: targetCellRange.end.row - targetCellRange.start.row + 1,
          moveType: "row"
        };
      }
      if (this.isSeriesNumberInBody(source.col, source.row)) return {
        sourceIndex: source.row,
        targetIndex: target.row,
        sourceSize: 1,
        targetSize: 1,
        moveType: "row"
      };
    }
    return null;
  }
  toggleHierarchyState(diffDataIndices) {
    return {
      addCellPositions: diffDataIndices.add.map((index) => ({
        col: 0,
        row: this._table.columnHeaderLevelCount + index
      })),
      removeCellPositions: diffDataIndices.remove.map((index) => ({
        col: 0,
        row: this._table.columnHeaderLevelCount + index
      }))
    };
  }
  setChartInstance(_col, _row, chartInstance) {
    const columnObj = this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount];
    "function" != typeof columnObj.chartSpec && (columnObj.chartInstance = chartInstance);
  }
  getChartInstance(_col, _row) {
    return (this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount]).chartInstance;
  }
  checkHasChart() {
    return checkHasChart(this);
  }
  getAxisConfigInPivotChart(col, row) {
  }
  isEmpty(col, row) {
    return false;
  }
  isAxisCell(col, row) {
    return false;
  }
  getChartAxes(col, row) {
    return [];
  }
  isShareChartSpec(col, row) {
    const body = this.getBody(col, row);
    return "function" != typeof (null == body ? void 0 : body.chartSpec);
  }
  isNoChartDataRenderNothing(col, row) {
    const body = this.getBody(col, row);
    return (null == body ? void 0 : body.define).noDataRenderNothing;
  }
  getChartSpec(col, row) {
    return this.getRawChartSpec(col, row);
  }
  getRawChartSpec(col, row) {
    const body = this.getBody(col, row), chartSpec = null == body ? void 0 : body.chartSpec;
    if ("function" == typeof chartSpec) {
      return chartSpec({
        col,
        row,
        dataValue: this._table.getCellOriginValue(col, row) || "",
        value: this._table.getCellValue(col, row) || "",
        rect: this._table.getCellRangeRelativeRect(this._table.getCellRange(col, row)),
        table: this._table
      });
    }
    return chartSpec;
  }
  getChartDataId(col, row) {
    return getChartDataId(col, row, this);
  }
  release() {
    const activeChartInstance = this._table._getActiveChartInstance();
    null == activeChartInstance || activeChartInstance.release(), this.columnObjects.forEach((indicatorObject) => {
      var _a;
      null === (_a = indicatorObject.chartInstance) || void 0 === _a || _a.release();
    });
  }
  clearCellRangeMap() {
    this._cellRangeMap.clear();
  }
  updateColumnTitle(col, row, title) {
    const define = this._table.internalProps.layoutMap.getHeader(col, row);
    define.title = title, define.define.title = title;
  }
  getColumnByField(field) {
    var _a;
    return null === (_a = this.columnObjects) || void 0 === _a ? void 0 : _a.reduce((pre, cur, index) => (cur.field === field && pre.push({
      col: index,
      columnDefine: cur
    }), pre), []);
  }
  getColumnByKey(key) {
    var _a;
    let col;
    return {
      columnDefine: null === (_a = this.columnObjects) || void 0 === _a ? void 0 : _a.find((columnData, index) => {
        var _a2;
        return (null === (_a2 = columnData.define) || void 0 === _a2 ? void 0 : _a2.key) === key && (col = index + this.leftRowSeriesNumberColumnCount, true);
      }),
      col
    };
  }
  getColumnDefine(col, row) {
    if (col >= 0) return col < this.leftRowSeriesNumberColumnCount ? this.leftRowSeriesNumberColumn[col].define : this.transpose ? this._columns[row].define : this._columns[col - this.leftRowSeriesNumberColumnCount].define;
  }
};

// node_modules/@visactor/vtable/es/edit/edit-manager.js
var EditManager = class {
  constructor(table) {
    this.isValidatingValue = false, this.listenersId = [], this.table = table, this.bindEvent();
  }
  bindEvent() {
    const table = this.table, doubleClickEventId = table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, (e) => {
      var _a, _b, _c;
      const { editCellTrigger = "doubleclick" } = table.options;
      if (!editCellTrigger.includes("doubleclick")) return;
      const { col, row } = e, eventArgsSet = getCellEventArgsSet(e.federatedEvent), resizeCol = table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.targetCell);
      table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0 || (null === (_c = null === (_b = e.target) || void 0 === _b ? void 0 : _b.attribute) || void 0 === _c ? void 0 : _c.funcType) || (this.beginTriggerEditCellMode = "doubleclick", this.startEditCell(col, row));
    }), clickEventId = table.on(TABLE_EVENT_TYPE.CLICK_CELL, (e) => {
      var _a, _b;
      const { editCellTrigger = "doubleclick" } = table.options;
      if ("click" === editCellTrigger || Array.isArray(editCellTrigger) && editCellTrigger.includes("click")) {
        if (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.funcType) return;
        this.beginTriggerEditCellMode = "click";
        const { col, row } = e;
        this.startEditCell(col, row);
      }
    });
    this.listenersId.push(doubleClickEventId, clickEventId);
  }
  startEditCell(col, row, value) {
    var _a, _b, _c, _d, _e;
    if (this.editingEditor) return;
    const editor2 = this.table.getEditor(col, row);
    if (editor2) {
      if (null === (_b = null === (_a = this.table.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isAggregation) || void 0 === _b ? void 0 : _b.call(_a, col, row)) return;
      const record = this.table.getCellRawRecord(col, row);
      if (null == record ? void 0 : record.vtableMerge) return;
      this.editingEditor || (this.editCell = {
        col,
        row
      }), this.table._makeVisibleCell(col, row), this.editingEditor = editor2;
      const dataValue = isValid_default(value) ? value : this.table.getCellOriginValue(col, row), rect = this.table.getCellRangeRelativeRect(this.table.getCellRange(col, row)), referencePosition = {
        rect: {
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height
        }
      };
      col === this.table.colCount - 1 ? referencePosition.rect.width = rect.width - 1 : referencePosition.rect.width = rect.width + 1, row === this.table.rowCount - 1 ? referencePosition.rect.height = rect.height - 1 : referencePosition.rect.height = rect.height + 1, editor2.beginEditing, null === (_c = editor2.beginEditing) || void 0 === _c || _c.call(editor2, this.table.getElement(), referencePosition, dataValue), editor2.bindSuccessCallback, null === (_d = editor2.bindSuccessCallback) || void 0 === _d || _d.call(editor2, () => {
        this.completeEdit();
      }), null === (_e = editor2.onStart) || void 0 === _e || _e.call(editor2, {
        value: dataValue,
        endEdit: () => {
          this.completeEdit();
        },
        referencePosition,
        container: this.table.getElement(),
        col,
        row,
        table: this.table
      });
    }
  }
  completeEdit(e) {
    var _a, _b;
    if (!this.editingEditor) return true;
    if (this.isValidatingValue) return false;
    const target = null == e ? void 0 : e.target, { editingEditor: editor2 } = this;
    if (target) {
      if (editor2.targetIsOnEditor) {
        if (editor2.targetIsOnEditor(target)) return false;
      } else if (!editor2.isEditorElement || editor2.isEditorElement(target)) return false;
    }
    if (this.editingEditor.getValue, this.editingEditor.validateValue) {
      this.isValidatingValue = true;
      const newValue = this.editingEditor.getValue(), oldValue = this.table.getCellOriginValue(this.editCell.col, this.editCell.row), maybePromiseOrValue = null === (_b = (_a = this.editingEditor).validateValue) || void 0 === _b ? void 0 : _b.call(_a, newValue, oldValue, this.editCell, this.table);
      return isPromise(maybePromiseOrValue) ? (this.isValidatingValue = true, new Promise((resolve, reject) => {
        maybePromiseOrValue.then((result2) => {
          dealWithValidateValue(result2, this, oldValue, resolve);
        }).catch((err) => {
          this.isValidatingValue = false, reject(err);
        });
      })) : dealWithValidateValue(maybePromiseOrValue, this, oldValue);
    }
    return this.doExit(), true;
  }
  doExit() {
    var _a, _b, _c, _d, _e, _f;
    const changedValue = null === (_b = (_a = this.editingEditor).getValue) || void 0 === _b ? void 0 : _b.call(_a), range5 = this.table.getCellRange(this.editCell.col, this.editCell.row), changedValues = [];
    for (let row = range5.start.row; row <= range5.end.row; row++) {
      const rowChangedValues = [];
      for (let col = range5.start.col; col <= range5.end.col; col++) rowChangedValues.push(changedValue);
      changedValues.push(rowChangedValues);
    }
    this.table.changeCellValues(range5.start.col, range5.start.row, changedValues), this.editingEditor.exit, null === (_d = (_c = this.editingEditor).exit) || void 0 === _d || _d.call(_c), null === (_f = (_e = this.editingEditor).onEnd) || void 0 === _f || _f.call(_e), this.editingEditor = null, this.isValidatingValue = false, this.beginTriggerEditCellMode = null;
  }
  cancelEdit() {
    var _a, _b, _c, _d;
    this.editingEditor && (null === (_b = (_a = this.editingEditor).exit) || void 0 === _b || _b.call(_a), null === (_d = (_c = this.editingEditor).onEnd) || void 0 === _d || _d.call(_c), this.editingEditor = null);
  }
  release() {
    this.listenersId.forEach((id) => {
      this.table.off(id);
    });
  }
};
function dealWithValidateValue(validateValue, editManager, oldValue, resolve) {
  return editManager.isValidatingValue = false, "validate-exit" === validateValue ? (editManager.doExit(), null == resolve || resolve(true), true) : "invalidate-exit" === validateValue ? (editManager.editingEditor.setValue(oldValue), editManager.doExit(), null == resolve || resolve(true), true) : "validate-not-exit" === validateValue || "invalidate-not-exit" === validateValue ? (null == resolve || resolve(false), false) : true === validateValue ? (editManager.doExit(), null == resolve || resolve(true), true) : (null == resolve || resolve(false), false);
}

// node_modules/@visactor/vtable/es/core/group-helper.js
function getGroupByDataConfig(groupByOption) {
  if (isString_default(groupByOption)) return {
    groupByRules: [groupByOption]
  };
  if (isArray_default(groupByOption)) {
    return {
      groupByRules: groupByOption.map((item) => isString_default(item) ? item : item.key)
    };
  }
  return {};
}

// node_modules/@visactor/vtable/es/core/record-helper.js
function listTableChangeCellValue(col, row, value, workOnEditableCell, triggerEvent, table) {
  if (workOnEditableCell && table.isHasEditorDefine(col, row) || false === workOnEditableCell) {
    const recordIndex = table.getRecordShowIndexByCell(col, row), { field } = table.internalProps.layoutMap.getBody(col, row), beforeChangeValue = table.getCellRawValue(col, row), oldValue = table.getCellOriginValue(col, row);
    table.isHeader(col, row) ? table.internalProps.layoutMap.updateColumnTitle(col, row, value) : table.dataSource.changeFieldValue(value, recordIndex, field, col, row, table);
    const range5 = table.getCellRange(col, row), aggregators = table.internalProps.layoutMap.getAggregatorsByCell(col, row);
    if (aggregators) {
      if (Array.isArray(aggregators)) for (let i = 0; i < (null == aggregators ? void 0 : aggregators.length); i++) aggregators[i].recalculate();
      else aggregators.recalculate();
      const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(range5.start.col, range5.start.row, range5.end.col, range5.end.row);
      for (let i = 0; i < aggregatorCells.length; i++) {
        const range6 = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
        for (let sCol = range6.start.col; sCol <= range6.end.col; sCol++) for (let sRow = range6.start.row; sRow <= range6.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
      }
    }
    for (let sCol = range5.start.col; sCol <= range5.end.col; sCol++) for (let sRow = range5.start.row; sRow <= range5.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
    if ("adaptive" === table.widthMode || table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth) 0 === table.internalProps._widthResizedColMap.size && table.scenegraph.recalculateColWidths();
    else if (!table.internalProps._widthResizedColMap.has(col)) {
      const oldWidth = table.getColWidth(col), newWidth = computeColWidth(col, 0, table.rowCount - 1, table, false);
      newWidth !== oldWidth && table.scenegraph.updateColWidth(col, newWidth - oldWidth);
    }
    if ("adaptive" === table.heightMode || table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight) 0 === table.internalProps._heightResizedRowMap.size && table.scenegraph.recalculateRowHeights();
    else if (table.isAutoRowHeight(row) && !table.internalProps._heightResizedRowMap.has(row)) {
      const oldHeight = table.getRowHeight(row), newHeight = computeRowHeight(row, 0, table.colCount - 1, table);
      table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
    }
    const changedValue = table.getCellOriginValue(col, row);
    oldValue !== changedValue && triggerEvent && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
      col,
      row,
      rawValue: beforeChangeValue,
      currentValue: oldValue,
      changedValue
    }), table.scenegraph.updateNextFrame();
  }
}
function listTableChangeCellValues(startCol, startRow, values, workOnEditableCell, triggerEvent, table) {
  var _a, _b;
  let pasteColEnd = startCol, pasteRowEnd = startRow;
  const beforeChangeValues = [], oldValues = [];
  let cellUpdateType;
  for (let i = 0; i < values.length && !(startRow + i > table.rowCount - 1); i++) {
    const rowValues = values[i], rawRowValues = [], oldRowValues = [];
    beforeChangeValues.push(rawRowValues), oldValues.push(oldRowValues);
    for (let j = 0; j < rowValues.length && !(startCol + j > table.colCount - 1); j++) {
      cellUpdateType = getCellUpdateType(startCol + j, startRow + i, table, cellUpdateType);
      const beforeChangeValue = table.getCellRawValue(startCol + j, startRow + i);
      rawRowValues.push(beforeChangeValue);
      const oldValue = table.getCellOriginValue(startCol + j, startRow + i);
      oldRowValues.push(oldValue);
    }
  }
  for (let i = 0; i < values.length && !(startRow + i > table.rowCount - 1); i++) {
    pasteRowEnd = startRow + i;
    const rowValues = values[i];
    let thisRowPasteColEnd = startCol;
    for (let j = 0; j < rowValues.length && !(startCol + j > table.colCount - 1); j++) {
      thisRowPasteColEnd = startCol + j;
      let isCanChange = false;
      if (false === workOnEditableCell) isCanChange = true;
      else if (table.isHasEditorDefine(startCol + j, startRow + i)) {
        const editor2 = table.getEditor(startCol + j, startRow + i), oldValue = oldValues[i][j], value = rowValues[j], maybePromiseOrValue = null === (_b = null === (_a = null == editor2 ? void 0 : editor2.validateValue) || void 0 === _a ? void 0 : _a.call(editor2, value, oldValue)) || void 0 === _b || _b;
        isCanChange = !!isPromise(maybePromiseOrValue) || (true === maybePromiseOrValue || "validate-exit" === maybePromiseOrValue || "invalidate-exit" === maybePromiseOrValue);
      }
      if (isCanChange) {
        const value = rowValues[j], recordIndex = table.getRecordShowIndexByCell(startCol + j, startRow + i), { field } = table.internalProps.layoutMap.getBody(startCol + j, startRow + i), beforeChangeValue = beforeChangeValues[i][j], oldValue = oldValues[i][j];
        table.isHeader(startCol + j, startRow + i) ? table.internalProps.layoutMap.updateColumnTitle(startCol + j, startRow + i, value) : table.dataSource.changeFieldValue(value, recordIndex, field, startCol + j, startRow + i, table);
        const changedValue = table.getCellOriginValue(startCol + j, startRow + i);
        oldValue !== changedValue && triggerEvent && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
          col: startCol + j,
          row: startRow + i,
          rawValue: beforeChangeValue,
          currentValue: oldValue,
          changedValue
        });
      }
    }
    pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
  }
  const startRange = table.getCellRange(startCol, startRow), range5 = table.getCellRange(pasteColEnd, pasteRowEnd), aggregators = table.internalProps.layoutMap.getAggregatorsByCellRange(startRange.start.col, startRange.start.row, range5.end.col, range5.end.row);
  if (aggregators) {
    for (let i = 0; i < (null == aggregators ? void 0 : aggregators.length); i++) aggregators[i].recalculate();
    if ("normal" === cellUpdateType) {
      const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(startRange.start.col, startRange.start.row, range5.end.col, range5.end.row);
      for (let i = 0; i < aggregatorCells.length; i++) {
        const range6 = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
        for (let sCol = range6.start.col; sCol <= range6.end.col; sCol++) for (let sRow = range6.start.row; sRow <= range6.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
      }
    }
  }
  if ("group" === cellUpdateType && table.dataSource.updateRecordsForGroup([], []), "sort" === cellUpdateType || "group" === cellUpdateType) return table.dataSource.sortedIndexMap.clear(), sortRecords(table), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.scenegraph.clearCells(), void table.scenegraph.createSceneGraph();
  for (let sCol = startRange.start.col; sCol <= range5.end.col; sCol++) for (let sRow = startRange.start.row; sRow <= range5.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
  if ("adaptive" === table.widthMode || table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth) 0 === table.internalProps._widthResizedColMap.size && table.scenegraph.recalculateColWidths();
  else for (let sCol = startCol; sCol <= range5.end.col; sCol++) if (!table.internalProps._widthResizedColMap.has(sCol)) {
    const oldWidth = table.getColWidth(sCol), newWidth = computeColWidth(sCol, 0, table.rowCount - 1, table, false);
    newWidth !== oldWidth && table.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
  }
  if ("adaptive" === table.heightMode || table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight) table.scenegraph.recalculateRowHeights();
  else if (table.isAutoRowHeight(startRow)) {
    const rows = [], deltaYs = [];
    for (let sRow = startRow; sRow <= range5.end.row; sRow++) if (table.rowHeightsMap.get(sRow)) {
      const oldHeight = table.getRowHeight(sRow), newHeight = computeRowHeight(sRow, 0, table.colCount - 1, table);
      rows.push(sRow), deltaYs.push(newHeight - oldHeight);
    }
    table.scenegraph.updateRowsHeight(rows, deltaYs);
  }
  table.scenegraph.updateNextFrame();
}
function getCellUpdateType(col, row, table, oldCellUpdateType) {
  if ("group" === oldCellUpdateType) return oldCellUpdateType;
  if ("sort" === oldCellUpdateType && !table.options.groupBy) return oldCellUpdateType;
  let cellUpdateType = "normal";
  if (table.options.groupBy) cellUpdateType = "group";
  else if (!table.isHeader(col, row) && table.dataSource.lastOrderField) {
    table.getBodyField(col, row) === table.dataSource.lastOrderField && (cellUpdateType = "sort");
  }
  return cellUpdateType;
}
function sortRecords(table) {
  let sortState = table.sortState;
  sortState = !sortState || Array.isArray(sortState) ? sortState : [sortState], sortState && (sortState = sortState.map((item) => {
    var _a;
    return item.orderFn = null !== (_a = table._getSortFuncFromHeaderOption(void 0, item.field)) && void 0 !== _a ? _a : defaultOrderFn, item;
  }), table.dataSource.sort(sortState));
}
function listTableAddRecord(record, recordIndex, table) {
  var _a, _b, _c, _d;
  if (table.options.groupBy) null === (_b = (_a = table.dataSource).addRecordsForGroup) || void 0 === _b || _b.call(_a, [record], recordIndex), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).addRecordsForTree) || void 0 === _d || _d.call(_c, [record], recordIndex), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if (table.sortState) table.dataSource.addRecordForSorted(record), sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else {
    (void 0 === recordIndex || recordIndex > table.dataSource.sourceLength) && (recordIndex = table.dataSource.sourceLength);
    const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
    table.dataSource.addRecord(record, recordIndex);
    const oldRowCount = table.rowCount;
    if (table.refreshRowColCount(), 0 === table.scenegraph.proxy.totalActualBodyRowCount) return table.scenegraph.clearCells(), void table.scenegraph.createSceneGraph();
    const newRowCount = table.transpose ? table.colCount : table.rowCount;
    if (table.pagination) {
      const { perPageCount, currentPage } = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
      if (recordIndex < endIndex) if (recordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
      else {
        const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
        if (oldRowCount - headerCount === table.pagination.perPageCount) {
          const updateRows = [];
          for (let row = rowNum; row < newRowCount; row++) table.transpose ? updateRows.push({
            col: row,
            row: 0
          }) : updateRows.push({
            col: 0,
            row
          });
          table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
        } else {
          const addRows = [];
          for (let row = rowNum; row < Math.min(newRowCount, rowNum + 1); row++) table.transpose ? addRows.push({
            col: row,
            row: 0
          }) : addRows.push({
            col: 0,
            row
          });
          table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
        }
      }
    } else {
      const addRows = [];
      for (let row = recordIndex + headerCount; row < recordIndex + headerCount + 1; row++) table.transpose ? addRows.push({
        col: row,
        row: 0
      }) : addRows.push({
        col: 0,
        row
      });
      const updateRows = [], topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
      for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
    }
  }
}
function listTableAddRecords(records, recordIndex, table) {
  var _a, _b, _c, _d;
  if (table.options.groupBy) null === (_b = (_a = table.dataSource).addRecordsForGroup) || void 0 === _b || _b.call(_a, records, recordIndex), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).addRecordsForTree) || void 0 === _d || _d.call(_c, records, recordIndex), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if (table.sortState) table.dataSource.addRecordsForSorted(records), sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else {
    void 0 === recordIndex || recordIndex > table.dataSource.sourceLength ? recordIndex = table.dataSource.sourceLength : recordIndex < 0 && (recordIndex = 0);
    const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
    table.dataSource.addRecords(records, recordIndex);
    const oldRowCount = table.transpose ? table.colCount : table.rowCount;
    if (table.refreshRowColCount(), 0 === table.scenegraph.proxy.totalActualBodyRowCount) return table.scenegraph.clearCells(), void table.scenegraph.createSceneGraph();
    const newRowCount = table.transpose ? table.colCount : table.rowCount;
    if (table.pagination) {
      const { perPageCount, currentPage } = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
      if (recordIndex < endIndex) if (recordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
      else {
        const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
        if (oldRowCount - headerCount === table.pagination.perPageCount) {
          const updateRows = [];
          for (let row = rowNum; row < newRowCount; row++) table.transpose ? updateRows.push({
            col: row,
            row: 0
          }) : updateRows.push({
            col: 0,
            row
          });
          table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
        } else {
          const addRows = [];
          for (let row = rowNum; row < Math.min(newRowCount, rowNum + (Array.isArray(records) ? records.length : 1)); row++) table.transpose ? addRows.push({
            col: row,
            row: 0
          }) : addRows.push({
            col: 0,
            row
          });
          table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
        }
      }
    } else {
      const addRows = [];
      for (let row = recordIndex + headerCount; row < recordIndex + headerCount + (Array.isArray(records) ? records.length : 1); row++) table.transpose ? addRows.push({
        col: row,
        row: 0
      }) : addRows.push({
        col: 0,
        row
      });
      const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount, updateRows = [];
      for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      table.transpose ? table.scenegraph.updateCol([], addRows, updateRows) : table.scenegraph.updateRow([], addRows, updateRows);
    }
  }
}
function listTableDeleteRecords(recordIndexs, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if ((null == recordIndexs ? void 0 : recordIndexs.length) > 0) if (table.options.groupBy) null === (_b = (_a = table.dataSource).deleteRecordsForGroup) || void 0 === _b || _b.call(_a, recordIndexs), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).deleteRecordsForTree) || void 0 === _d || _d.call(_c, recordIndexs), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if (table.sortState) table.dataSource.deleteRecordsForSorted(recordIndexs), sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else {
    const deletedRecordIndexs = table.dataSource.deleteRecords(recordIndexs);
    if (0 === deletedRecordIndexs.length) return;
    const oldRowCount = table.transpose ? table.colCount : table.rowCount;
    table.refreshRowColCount();
    const newRowCount = table.transpose ? table.colCount : table.rowCount, recordIndexsMinToMax = deletedRecordIndexs.sort((a2, b) => a2 - b), minRecordIndex = recordIndexsMinToMax[0];
    if (table.pagination) {
      const { perPageCount, currentPage } = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
      if (minRecordIndex < endIndex) if (minRecordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
      else {
        const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, updateRows = [], delRows = [];
        for (let row = minRecordIndex - (endIndex - perPageCount) + (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) + topAggregationCount; row < newRowCount; row++) table.transpose ? updateRows.push({
          col: row,
          row: 0
        }) : updateRows.push({
          col: 0,
          row
        });
        for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
          col: row,
          row: 0
        }) : updateRows.push({
          col: 0,
          row
        });
        if (newRowCount < oldRowCount) for (let row = newRowCount; row < oldRowCount; row++) table.transpose ? delRows.push({
          col: row,
          row: 0
        }) : delRows.push({
          col: 0,
          row
        });
        null === (_e = table.reactCustomLayout) || void 0 === _e || _e.clearCache(), table.transpose ? table.scenegraph.updateCol(delRows, [], updateRows) : table.scenegraph.updateRow(delRows, [], updateRows), null === (_f = table.reactCustomLayout) || void 0 === _f || _f.updateAllCustomCell();
      }
    } else {
      const delRows = [], headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
      for (let index = 0; index < recordIndexsMinToMax.length; index++) {
        const rowNum = recordIndexsMinToMax[index] + headerCount + topAggregationCount;
        table.transpose ? delRows.push({
          col: rowNum,
          row: 0
        }) : delRows.push({
          col: 0,
          row: rowNum
        });
      }
      const updateRows = [];
      for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      null === (_g = table.reactCustomLayout) || void 0 === _g || _g.clearCache(), table.transpose ? table.scenegraph.updateCol(delRows, [], updateRows) : table.scenegraph.updateRow(delRows, [], updateRows), null === (_h = table.reactCustomLayout) || void 0 === _h || _h.updateAllCustomCell();
    }
  }
}
function listTableUpdateRecords(records, recordIndexs, table) {
  var _a, _b, _c, _d;
  if ((null == recordIndexs ? void 0 : recordIndexs.length) > 0) if (table.options.groupBy) null === (_b = (_a = table.dataSource).updateRecordsForGroup) || void 0 === _b || _b.call(_a, records, recordIndexs), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).updateRecordsForTree) || void 0 === _d || _d.call(_c, records, recordIndexs), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else if (table.sortState) table.dataSource.updateRecordsForSorted(records, recordIndexs), sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph();
  else {
    const updateRecordIndexs = table.dataSource.updateRecords(records, recordIndexs);
    if (0 === updateRecordIndexs.length) return;
    const recordIndexsMinToMax = updateRecordIndexs.map((index) => table.getBodyRowIndexByRecordIndex(index)).sort((a2, b) => a2 - b);
    if (table.pagination) {
      const { perPageCount, currentPage } = table.pagination, headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, endIndex = perPageCount * (currentPage || 0) + perPageCount, updateRows = [];
      for (let index = 0; index < recordIndexsMinToMax.length; index++) {
        const recordIndex = recordIndexsMinToMax[index];
        if (recordIndex < endIndex && recordIndex >= endIndex - perPageCount) {
          const rowNum = recordIndex - (endIndex - perPageCount) + (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) + topAggregationCount;
          updateRows.push(rowNum);
        }
      }
      if (updateRows.length >= 1) {
        const updateRowCells = [];
        for (let index = 0; index < updateRows.length; index++) {
          const updateRow2 = updateRows[index];
          table.transpose ? updateRowCells.push({
            col: updateRow2,
            row: 0
          }) : updateRowCells.push({
            col: 0,
            row: updateRow2
          });
        }
        for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRowCells.push({
          col: row,
          row: 0
        }) : updateRowCells.push({
          col: 0,
          row
        });
        table.transpose ? table.scenegraph.updateCol([], [], updateRowCells) : table.scenegraph.updateRow([], [], updateRowCells);
      }
    } else {
      const updateRows = [], headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
      for (let index = 0; index < recordIndexsMinToMax.length; index++) {
        const rowNum = recordIndexsMinToMax[index] + headerCount + topAggregationCount;
        table.transpose ? updateRows.push({
          col: rowNum,
          row: 0
        }) : updateRows.push({
          col: 0,
          row: rowNum
        });
      }
      for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
        col: row,
        row: 0
      }) : updateRows.push({
        col: 0,
        row
      });
      table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
    }
  }
}

// node_modules/@visactor/vtable/es/tools/update-row.js
function fixUpdateRowRange(diffPositions, col, row, table) {
  const updateCells = [{
    col,
    row
  }], addCells = [], removeCells = [], { addCellPositions, removeCellPositions } = diffPositions, proxy = table.scenegraph.proxy, { rowStart, rowLimit } = proxy;
  let { rowEnd } = proxy, updateRow2 = 1 / 0;
  for (let i = 0; i < addCellPositions.length; i++) {
    const { row: cellRow } = addCellPositions[i];
    rowEnd - rowStart + 1 === rowLimit ? cellRow >= rowStart && cellRow <= rowEnd && (updateRow2 = Math.min(updateRow2, cellRow)) : (addCells.push({
      col,
      row: cellRow
    }), rowEnd++);
  }
  const newRowEnd = Math.min(rowStart + rowLimit, table.rowCount - 1 - table.bottomFrozenRowCount), notFullRow = newRowEnd < rowStart + rowLimit;
  for (let i = 0; i < removeCellPositions.length; i++) {
    const { row: cellRow } = removeCellPositions[removeCellPositions.length - i - 1];
    cellRow < rowStart || cellRow > rowEnd || (cellRow > newRowEnd || notFullRow ? (removeCells.push({
      col,
      row: cellRow
    }), updateRow2--) : updateRow2 = Math.min(updateRow2, cellRow));
  }
  if (updateRow2 !== 1 / 0) for (let i = updateRow2; i <= rowEnd; i++) updateCells.push({
    col,
    row: i
  });
  return table.scenegraph.proxy.refreshRowCount(), {
    updateCells,
    addCells,
    removeCells
  };
}

// node_modules/@visactor/vtable/es/ListTable.js
var ListTable = class extends BaseTable {
  constructor(container2, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super(container2, options), this.showHeader = true, options = this.options;
    const internalProps = this.internalProps;
    if (internalProps.frozenColDragHeaderMode = null !== (_b = null === (_a = options.dragOrder) || void 0 === _a ? void 0 : _a.frozenColDragHeaderMode) && void 0 !== _b ? _b : options.frozenColDragHeaderMode, this.pagination = options.pagination, internalProps.sortState = options.sortState, internalProps.multipleSort = !!options.multipleSort, internalProps.dataConfig = options.groupBy ? getGroupByDataConfig(options.groupBy) : {}, internalProps.columns = options.columns ? cloneDeepSpec(options.columns, ["children"]) : options.header ? cloneDeepSpec(options.header, ["children"]) : [], generateAggregationForColumn(this), internalProps.enableTreeNodeMerge = null !== (_d = null !== (_c = options.enableTreeNodeMerge) && void 0 !== _c ? _c : isValid_default(options.groupBy)) && void 0 !== _d && _d, this.internalProps.headerHelper.setTableColumnsEditor(), this.showHeader = null === (_e = options.showHeader) || void 0 === _e || _e, this.internalProps.columnWidthConfig = options.columnWidthConfig, this.transpose = null !== (_f = options.transpose) && void 0 !== _f && _f, "node" !== Env.mode && (this.editorManager = new EditManager(this)), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, options.dataSource ? this.dataSource = options.dataSource : options.records ? this.setRecords(options.records, {
      sortState: internalProps.sortState
    }) : this.setRecords([]), options.title) {
      const Title3 = Factory2.getComponent("title");
      internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
    }
    if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_g = this.internalProps.emptyTip) || void 0 === _g || _g.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible();
    }
    if (options.enableTreeStickCell) {
      const ListTreeStickCellPlugin2 = Factory2.getComponent("listTreeStickCellPlugin");
      this.listTreeStickCellPlugin = new ListTreeStickCellPlugin2(this);
    }
    setTimeout(() => {
      this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
    }, 0);
  }
  isListTable() {
    return true;
  }
  isPivotTable() {
    return false;
  }
  isPivotChart() {
    return false;
  }
  get sortState() {
    return this.internalProps.sortState;
  }
  get records() {
    var _a;
    return null === (_a = this.dataSource) || void 0 === _a ? void 0 : _a.records;
  }
  get recordsCount() {
    return this.dataSource.records.length;
  }
  updateColumns(columns) {
    var _a, _b, _c, _d;
    this.scenegraph.clearCells();
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    this.internalProps.columns = cloneDeepSpec(columns, ["children"]), generateAggregationForColumn(this), this.options.columns = columns, this.internalProps.headerHelper.setTableColumnsEditor(), this._hasAutoImageColumn = void 0, this.refreshHeader(), null === (_b = (_a = this.dataSource).updateColumns) || void 0 === _b || _b.call(_a, this.internalProps.columns), this.records && checkHasAggregationOnColumnDefine(columns) && this.dataSource.processRecords(null !== (_d = null === (_c = this.dataSource.dataSourceObj) || void 0 === _c ? void 0 : _c.records) && void 0 !== _d ? _d : this.dataSource.dataSourceObj), this.internalProps.useOneRowHeightFillAll = false, this.headerStyleCache = /* @__PURE__ */ new Map(), this.bodyStyleCache = /* @__PURE__ */ new Map(), this.bodyBottomStyleCache = /* @__PURE__ */ new Map(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.renderAsync(), this.eventManager.updateEventBinder();
  }
  addColumn(column) {
    const columns = this.options.columns;
    columns.push(column), this.updateColumns(columns);
  }
  get columns() {
    return this.internalProps.layoutMap.columnTree.getCopiedTree();
  }
  get header() {
    return this.internalProps.columns;
  }
  set header(header) {
    this.internalProps.columns = header, generateAggregationForColumn(this), this.options.header = header, this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.renderAsync();
  }
  get transpose() {
    var _a;
    return null !== (_a = this.internalProps.transpose) && void 0 !== _a && _a;
  }
  set transpose(transpose2) {
    this.internalProps.transpose !== transpose2 && (this.internalProps.transpose = transpose2, this.internalProps.layoutMap && (this.internalProps.layoutMap.transpose = transpose2, this.refreshRowColCount(), this._resetFrozenColCount(), this.renderAsync()));
  }
  getCellValue(col, row, skipCustomMerge) {
    if (-1 === col || -1 === row) return null;
    if (!skipCustomMerge) {
      const customMergeText = this.getCustomMergeValue(col, row);
      if (customMergeText) return customMergeText;
    }
    const table = this;
    if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
      if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
        const { title } = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
        return title;
      }
      let value;
      if (this.options.groupBy) {
        const record = table.getCellRawRecord(col, row);
        if (null == record ? void 0 : record.vtableMerge) return "";
        table.internalProps.layoutMap.isAggregation(col, row) || (value = this.dataSource.getGroupSeriesNumber(row - this.columnHeaderLevelCount));
      } else value = row - this.columnHeaderLevelCount + 1;
      const { format } = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
      return "function" == typeof format ? format(col, row, this, value) : value;
    }
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    if (table.internalProps.layoutMap.isAggregation(col, row)) {
      if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
        const aggregator2 = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
        return (null == aggregator2 ? void 0 : aggregator2.formatValue) ? aggregator2.formatValue(col, row, this) : "";
      }
      if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
        const aggregator2 = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
        return (null == aggregator2 ? void 0 : aggregator2.formatValue) ? aggregator2.formatValue(col, row, this) : "";
      }
    }
    const { field, fieldFormat } = table.internalProps.layoutMap.getBody(col, row);
    return table.getFieldData(fieldFormat || field, col, row);
  }
  getCellOriginValue(col, row) {
    if (-1 === col || -1 === row) return null;
    const table = this;
    if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
      if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
        const { title } = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
        return title;
      }
      const { format } = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
      return "function" == typeof format ? format(col, row, this) : row - this.columnHeaderLevelCount;
    }
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    if (table.internalProps.layoutMap.isAggregation(col, row)) {
      if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
        const aggregator2 = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
        return null == aggregator2 ? void 0 : aggregator2.value();
      }
      if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
        const aggregator2 = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
        return null == aggregator2 ? void 0 : aggregator2.value();
      }
    }
    const { field } = table.internalProps.layoutMap.getBody(col, row);
    return table.getFieldData(field, col, row);
  }
  getCellRawValue(col, row) {
    if (-1 === col || -1 === row) return null;
    const table = this;
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    const { field } = table.internalProps.layoutMap.getBody(col, row);
    return table.getRawFieldData(field, col, row);
  }
  getRecordShowIndexByCell(col, row) {
    const { layoutMap } = this.internalProps;
    return layoutMap.getRecordShowIndexByCell(col, row);
  }
  getRecordIndexByCell(col, row) {
    const { layoutMap } = this.internalProps, recordShowIndex = layoutMap.getRecordShowIndexByCell(col, row);
    return this.dataSource.getRecordIndexPaths(recordShowIndex);
  }
  getTableIndexByRecordIndex(recordIndex) {
    return this.transpose ? this.dataSource.getTableIndex(recordIndex) + this.rowHeaderLevelCount : this.dataSource.getTableIndex(recordIndex) + this.columnHeaderLevelCount;
  }
  getTableIndexByField(field) {
    const colObj = this.internalProps.layoutMap.columnObjects.find((col) => col.field === field);
    if (!colObj) return -1;
    const layoutRange = this.internalProps.layoutMap.getBodyLayoutRangeById(colObj.id);
    return this.transpose ? layoutRange.start.row : layoutRange.start.col;
  }
  getCellAddrByFieldRecord(field, recordIndex) {
    return this.transpose ? {
      col: this.getTableIndexByRecordIndex(recordIndex),
      row: this.getTableIndexByField(field)
    } : {
      col: this.getTableIndexByField(field),
      row: this.getTableIndexByRecordIndex(recordIndex)
    };
  }
  getCellOriginRecord(col, row) {
    const table = this, index = table.getRecordShowIndexByCell(col, row);
    if (index > -1) return table.dataSource.get(index);
  }
  getCellRawRecord(col, row) {
    const table = this, index = table.getRecordShowIndexByCell(col, row);
    if (index > -1) return table.dataSource.getRaw(index);
  }
  _canResizeColumn(col, row) {
    const ifCan = super._canResizeColumn(col, row);
    if (ifCan && !this.transpose) {
      const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount), isSeriesNumber = this.internalProps.layoutMap.isSeriesNumber(col, row);
      if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return false;
      if (isSeriesNumber && true === this.internalProps.rowSeriesNumber.disableColumnResize) return false;
    }
    return ifCan;
  }
  updateOption(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const internalProps = this.internalProps;
    if (super.updateOption(options), internalProps.frozenColDragHeaderMode = null !== (_b = null === (_a = options.dragOrder) || void 0 === _a ? void 0 : _a.frozenColDragHeaderMode) && void 0 !== _b ? _b : options.frozenColDragHeaderMode, this.pagination = options.pagination, internalProps.sortState = options.sortState, internalProps.dataConfig = options.groupBy ? getGroupByDataConfig(options.groupBy) : {}, this.showHeader = null === (_c = options.showHeader) || void 0 === _c || _c, internalProps.columns = options.columns ? cloneDeepSpec(options.columns, ["children"]) : options.header ? cloneDeepSpec(options.header, ["children"]) : [], generateAggregationForColumn(this), internalProps.enableTreeNodeMerge = null !== (_e = null !== (_d = options.enableTreeNodeMerge) && void 0 !== _d ? _d : isValid_default(options.groupBy)) && void 0 !== _e && _e, this.internalProps.headerHelper.setTableColumnsEditor(), this.transpose = null !== (_f = options.transpose) && void 0 !== _f && _f, this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.internalProps.columnWidthConfig = options.columnWidthConfig, internalProps.releaseList) for (let i = internalProps.releaseList.length - 1; i >= 0; i--) {
      const releaseObj = internalProps.releaseList[i];
      releaseObj instanceof DataSource ? releaseObj.updateColumns(this.internalProps.columns) : (null === (_g = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _g || _g.call(releaseObj), internalProps.releaseList.splice(i, 1));
    }
    if (options.dataSource && this.dataSource !== options.dataSource ? this.dataSource = options.dataSource : options.records ? this.setRecords(options.records, {
      sortState: options.sortState
    }) : (this.refreshRowColCount(), this._resetFrozenColCount(), this.scenegraph.createSceneGraph(), this.render()), options.title) {
      const Title3 = Factory2.getComponent("title");
      internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
    }
    if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_j = this.internalProps.emptyTip) || void 0 === _j || _j.resetVisible();
    }
    return this.pluginManager.updatePlugins(options.plugins), new Promise((resolve) => {
      setTimeout(resolve, 0);
    });
  }
  updatePagination(pagination) {
    this.pagination && ("number" == typeof pagination.currentPage && pagination.currentPage >= 0 && (this.pagination.currentPage = pagination.currentPage), pagination.perPageCount && (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount), this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.clearCells(), this.dataSource.updatePagination(this.pagination), this.refreshRowColCount(), this.stateManager.initCheckedState(this.records), this.scenegraph.createSceneGraph(), this.renderAsync());
  }
  refreshHeader() {
    var _a;
    const internalProps = this.internalProps, transpose2 = this.transpose, showHeader = this.showHeader;
    (internalProps.layoutMap = new SimpleHeaderLayoutMap(this, null !== (_a = internalProps.columns) && void 0 !== _a ? _a : [], showHeader, this.options.hierarchyIndent)).transpose = transpose2, transpose2 || this.setMinMaxLimitWidth(true), this.refreshRowColCount();
  }
  refreshRowColCount() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const table = this, { layoutMap } = table.internalProps;
    if (!layoutMap) return;
    const dataCount = null !== (_b = null === (_a = table.internalProps.dataSource) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
    layoutMap.recordsCount = dataCount + (dataCount > 0 || this.options.showAggregationWhenEmpty ? layoutMap.hasAggregationOnTopCount + layoutMap.hasAggregationOnBottomCount : 0), table.transpose ? (table.rowCount = null !== (_c = layoutMap.rowCount) && void 0 !== _c ? _c : 0, table.colCount = null !== (_d = layoutMap.colCount) && void 0 !== _d ? _d : 0, this.internalProps.frozenColCount = Math.max((null !== (_e = layoutMap.headerLevelCount) && void 0 !== _e ? _e : 0) + layoutMap.leftRowSeriesNumberColumnCount, null !== (_f = this.options.frozenColCount) && void 0 !== _f ? _f : 0), this.internalProps.frozenRowCount = null !== (_g = this.options.frozenRowCount) && void 0 !== _g ? _g : 0, table.bottomFrozenRowCount !== (null !== (_h = this.options.bottomFrozenRowCount) && void 0 !== _h ? _h : 0) && (table.bottomFrozenRowCount = null !== (_j = this.options.bottomFrozenRowCount) && void 0 !== _j ? _j : 0), table.rightFrozenColCount !== (null !== (_k = this.options.rightFrozenColCount) && void 0 !== _k ? _k : 0) && (table.rightFrozenColCount = null !== (_l = this.options.rightFrozenColCount) && void 0 !== _l ? _l : 0)) : (table.colCount = null !== (_m = layoutMap.colCount) && void 0 !== _m ? _m : 0, table.rowCount = layoutMap.recordsCount * layoutMap.bodyRowSpanCount + layoutMap.headerLevelCount, this.internalProps.frozenColCount = null !== (_o = this.options.frozenColCount) && void 0 !== _o ? _o : 0, table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_p = this.options.frozenRowCount) && void 0 !== _p ? _p : 0), table.bottomFrozenRowCount !== (null !== (_q = this.options.bottomFrozenRowCount) && void 0 !== _q ? _q : 0) && (table.bottomFrozenRowCount = null !== (_r = this.options.bottomFrozenRowCount) && void 0 !== _r ? _r : 0), table.rightFrozenColCount !== (null !== (_s = this.options.rightFrozenColCount) && void 0 !== _s ? _s : 0) && (table.rightFrozenColCount = null !== (_t = this.options.rightFrozenColCount) && void 0 !== _t ? _t : 0)), this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
  }
  getFieldData(field, col, row) {
    if (null === field) return null;
    if (this.internalProps.layoutMap.isHeader(col, row)) return null;
    const index = this.getRecordShowIndexByCell(this.transpose ? col - this.internalProps.layoutMap.leftRowSeriesNumberColumnCount : col, row);
    return this.internalProps.dataSource.getField(index, field, col, row, this);
  }
  getRawFieldData(field, col, row) {
    if (null === field) return null;
    if (this.internalProps.layoutMap.isHeader(col, row)) return null;
    const index = this.getRecordShowIndexByCell(col, row);
    return this.internalProps.dataSource.getRawField(index, field, col, row, this);
  }
  _moveHeaderPosition(source, target) {
    const sourceCellRange = this.getCellRange(source.col, source.row), targetCellRange = this.getCellRange(target.col, target.row), moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
    return moveContext ? ("column" === moveContext.moveType ? (this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex), this.transpose || (this.colWidthsLimit = {}, this.setMinMaxLimitWidth())) : moveContext.targetIndex > moveContext.sourceIndex ? this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex) : this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex), moveContext) : null;
  }
  changeRecordOrder(sourceIndex, targetIndex) {
    this.transpose ? (sourceIndex = this.getRecordShowIndexByCell(sourceIndex, 0), targetIndex = this.getRecordShowIndexByCell(targetIndex, 0)) : (sourceIndex = this.getRecordShowIndexByCell(0, sourceIndex), targetIndex = this.getRecordShowIndexByCell(0, targetIndex)), this.dataSource.changeOrder(sourceIndex, targetIndex);
  }
  getCellAddress(findTargetRecord, field) {
    let targetRecordIndex;
    for (let i = 0; i < this.internalProps.records.length; i++) {
      const record = this.internalProps.records[i];
      if ("function" == typeof findTargetRecord) findTargetRecord(record) && (targetRecordIndex = i);
      else {
        let isAllRight = true;
        for (const prop in findTargetRecord) if (record[prop] !== findTargetRecord[prop]) {
          isAllRight = false;
          break;
        }
        isAllRight && (targetRecordIndex = i);
      }
      if (isValid_default(targetRecordIndex)) break;
    }
    const cellRange = this.getCellRangeByField(field, targetRecordIndex);
    if (cellRange) return {
      row: cellRange.start.row,
      col: cellRange.start.col
    };
  }
  getCellRangeByField(field, index) {
    const { layoutMap } = this.internalProps, colObj = layoutMap.columnObjects.find((col) => col.field === field);
    if (colObj) {
      const layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id);
      let startRow;
      return isValid_default(index) && (startRow = layoutMap.getRecordStartRowByRecordIndex(index)), this.transpose ? {
        start: {
          row: layoutRange.start.row,
          col: isValid_default(startRow) ? startRow + layoutRange.start.col : void 0
        },
        end: {
          row: layoutRange.end.row,
          col: isValid_default(startRow) ? startRow + layoutRange.end.col : void 0
        }
      } : {
        start: {
          col: layoutRange.start.col,
          row: isValid_default(startRow) ? startRow + layoutRange.start.row : void 0
        },
        end: {
          col: layoutRange.end.col,
          row: isValid_default(startRow) ? startRow + layoutRange.end.row : void 0
        }
      };
    }
    return null;
  }
  getHierarchyState(col, row) {
    var _a;
    if (this.isHeader(col, row)) return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
    if (!this.options.groupBy || isArray_default(this.options.groupBy) && 0 === this.options.groupBy.length) {
      if (!this.getBodyColumnDefine(col, row).tree) return HierarchyState.none;
    }
    const index = this.getRecordShowIndexByCell(col, row);
    return this.dataSource.getHierarchyState(index);
  }
  toggleHierarchyState(col, row, recalculateColWidths = true) {
    this.stateManager.updateHoverIcon(col, row, void 0, void 0);
    const hierarchyState = this.getHierarchyState(col, row);
    if (this.isHeader(col, row)) {
      const headerTreeNode = this.internalProps.layoutMap.getHeader(col, row), { hierarchyState: rawHierarchyState, define: columnDefine } = headerTreeNode;
      if (![HierarchyState.collapse, HierarchyState.expand].includes(rawHierarchyState) || !columnDefine) return;
      const children = columnDefine.columns;
      if (Array.isArray(children) && children.length > 0) {
        const hierarchyState2 = rawHierarchyState === HierarchyState.expand ? HierarchyState.collapse : HierarchyState.expand;
        headerTreeNode.hierarchyState = hierarchyState2, headerTreeNode.define.hierarchyState = hierarchyState2, this.updateColumns(this.internalProps.columns);
      }
      this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
        col,
        row,
        hierarchyState,
        originData: headerTreeNode,
        cellLocation: this.getCellLocation(col, row)
      });
    } else if (hierarchyState === HierarchyState.expand) this._refreshHierarchyState(col, row, recalculateColWidths), this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
      col,
      row,
      hierarchyState: HierarchyState.collapse
    });
    else if (hierarchyState === HierarchyState.collapse) {
      const record = this.getCellOriginRecord(col, row);
      Array.isArray(record.children) && this._refreshHierarchyState(col, row, recalculateColWidths), this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
        col,
        row,
        hierarchyState: HierarchyState.expand,
        originData: record
      });
    }
  }
  setLoadingHierarchyState(col, row) {
    this.scenegraph.setLoadingHierarchyState(col, row);
  }
  _refreshHierarchyState(col, row, recalculateColWidths = true) {
    var _a, _b;
    let notFillWidth = false, notFillHeight = false;
    const checkHasChart2 = this.internalProps.layoutMap.checkHasChart();
    checkHasChart2 && (this.autoFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), this.autoFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight));
    const index = this.getRecordShowIndexByCell(col, row), diffDataIndices = this.dataSource.toggleHierarchyState(index, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount, Math.max(this.scenegraph.proxy.rowEnd - this.columnHeaderLevelCount, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount + this.scenegraph.proxy.rowLimit - 1)), diffPositions = this.internalProps.layoutMap.toggleHierarchyState(diffDataIndices);
    this.refreshRowColCount();
    for (let row2 = this.rowCount - this.bottomFrozenRowCount; row2 < this.rowCount; row2++) {
      const newHeight = computeRowHeight(row2, 0, this.colCount - 1, this);
      this._setRowHeight(row2, newHeight);
    }
    this.clearCellStyleCache(), this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = false;
    const { updateCells, addCells, removeCells } = fixUpdateRowRange(diffPositions, col, row, this);
    null === (_a = this.reactCustomLayout) || void 0 === _a || _a.clearCache(), this.scenegraph.updateRow(removeCells, addCells, updateCells, recalculateColWidths, true), null === (_b = this.reactCustomLayout) || void 0 === _b || _b.updateAllCustomCell(), checkHasChart2 && (this.autoFillWidth && !notFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), this.autoFillHeight && !notFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight), ("adaptive" === this.widthMode || notFillWidth || "adaptive" === this.heightMode || notFillHeight) && this.scenegraph.updateChartSizeForResizeColWidth(-1));
  }
  _hasHierarchyTreeHeader() {
    var _a, _b;
    return null === (_b = null !== (_a = this.options.columns) && void 0 !== _a ? _a : this.options.header) || void 0 === _b ? void 0 : _b.some((column, i) => column.tree);
  }
  getMenuInfo(col, row, type) {
    return {
      field: this.getHeaderField(col, row),
      value: this.getCellValue(col, row),
      cellLocation: this.getCellLocation(col, row),
      event: void 0
    };
  }
  _getSortFuncFromHeaderOption(columns, field, fieldKey) {
    if (columns || (columns = this.internalProps.columns), field && columns && columns.length > 0) for (let i = 0; i < columns.length; i++) {
      const header = columns[i];
      if ((fieldKey && fieldKey === header.fieldKey || !fieldKey && header.field === field) && header.sort && "function" == typeof header.sort) return header.sort;
      if (header.columns) {
        const sort2 = this._getSortFuncFromHeaderOption(header.columns, field, fieldKey);
        if (sort2) return sort2;
      }
    }
  }
  updateSortState(sortState, executeSort2 = true) {
    var _a;
    if (sortState) this.internalProps.sortState = sortState;
    else if (this.internalProps.sortState) if (Array.isArray(this.internalProps.sortState)) for (let i = 0; i < this.internalProps.sortState.length; i++) (sortState = null === (_a = this.internalProps.sortState) || void 0 === _a ? void 0 : _a[i]) && (sortState.order = "normal");
    else this.internalProps.sortState.order = "normal", sortState = this.internalProps.sortState;
    (sortState = Array.isArray(sortState) ? sortState : [sortState]).some((item) => item.field) && executeSort2 && this.internalProps.layoutMap.headerObjects.some((item) => false !== item.define.sort) && (this.dataSource.sort(sortState.map((item) => {
      const sortFunc = this._getSortFuncFromHeaderOption(this.internalProps.columns, item.field);
      this.internalProps.layoutMap.headerObjects.find((col) => col && col.field === item.field);
      return {
        field: item.field,
        order: item.order,
        orderFn: null != sortFunc ? sortFunc : defaultOrderFn
      };
    })), this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.sortCell()), sortState.length && this.stateManager.updateSortState(sortState);
  }
  updateFilterRules(filterRules) {
    this.scenegraph.clearCells(), this.sortState ? (this.dataSource.updateFilterRulesForSorted(filterRules), sortRecords(this)) : this.dataSource.updateFilterRules(filterRules), this.refreshRowColCount(), this.stateManager.initCheckedState(this.records), this.scenegraph.createSceneGraph();
  }
  getCheckboxState(field) {
    if (this.stateManager.checkedState.size < this.rowCount - this.columnHeaderLevelCount && this.stateManager.initLeftRecordsCheckState(this.records), isValid_default(field)) {
      let stateArr = Array.from(this.stateManager.checkedState.keys()).sort((a2, b) => {
        var _a, _b;
        const aArr = a2.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
        for (let i = 0; i < maxLength; i++) {
          const a3 = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b2 = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
          if (a3 !== b2) return a3 - b2;
        }
        return 0;
      }).map((key) => this.stateManager.checkedState.get(key));
      return this.options.groupBy && (stateArr = getGroupCheckboxState(this)), Array.from(stateArr, (state) => state && state[field]);
    }
    return new Array(...this.stateManager.checkedState.values());
  }
  getCellCheckboxState(col, row) {
    var _a;
    const define = this.getBodyColumnDefine(col, row), field = null == define ? void 0 : define.field, cellType = this.getCellType(col, row);
    if (isValid_default(field) && ("checkbox" === cellType || "switch" === cellType)) {
      const dataIndex = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row)).toString();
      return null === (_a = this.stateManager.checkedState.get(dataIndex)) || void 0 === _a ? void 0 : _a[field];
    }
  }
  getRadioState(field) {
    return isValid_default(field) ? this.stateManager.radioState[field] : this.stateManager.radioState;
  }
  getCellRadioState(col, row) {
    return getCellRadioState(col, row, this);
  }
  setCellCheckboxState(col, row, checked) {
    setCellCheckboxState(col, row, checked, this);
  }
  setCellRadioState(col, row, index) {
    setCellRadioState(col, row, index, this);
  }
  getSwitchState(field) {
    return this.getCheckboxState(field);
  }
  getCellSwitchState(col, row) {
    return this.getCellCheckboxState(col, row);
  }
  setCellSwitchState(col, row, checked) {
    this.setCellCheckboxState(col, row, checked);
  }
  setRecords(records, option) {
    var _a, _b, _c, _d;
    let sort2;
    clearChartRenderQueue(), null === (_a = this.internalProps.dataSource) || void 0 === _a || _a.release(), this.internalProps.releaseList = null === (_b = this.internalProps.releaseList) || void 0 === _b ? void 0 : _b.filter((item) => !item.dataSourceObj), this.internalProps.dataSource = null, Array.isArray(option) || (null == option ? void 0 : option.order) ? sort2 = option : option ? sort2 = option.sortState : null === option && (sort2 = null);
    "undefined" != typeof window && window.performance.now();
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    if (this.scenegraph.clearCells(), void 0 !== sort2 && (null === sort2 || !Array.isArray(sort2) && isValid_default(sort2.field) || Array.isArray(sort2)) && (this.internalProps.sortState = this.internalProps.multipleSort ? Array.isArray(sort2) ? sort2 : [sort2] : sort2, this.stateManager.setSortState(this.sortState)), records) {
      if (_setRecords(this, records), this.sortState) {
        const sortState = Array.isArray(this.sortState) ? this.sortState : [this.sortState];
        sortState.some((item) => item.order && item.field && "normal" !== item.order) && this.internalProps.layoutMap.headerObjectsIncludeHided.some((item) => false !== item.define.sort) && this.dataSource.sort(sortState.map((item) => {
          const sortFunc = this._getSortFuncFromHeaderOption(void 0, item.field);
          this.internalProps.layoutMap.headerObjectsIncludeHided.find((col) => col && col.field === item.field);
          return {
            field: item.field,
            order: item.order || "asc",
            orderFn: null != sortFunc ? sortFunc : defaultOrderFn
          };
        }));
      }
      this.refreshRowColCount();
    } else _setRecords(this, records);
    if (this.stateManager.initCheckedState(records), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), this.internalProps.title.resize(), this.scenegraph.resize()), this.options.emptyTip) if (this.internalProps.emptyTip) null === (_c = this.internalProps.emptyTip) || void 0 === _c || _c.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_d = this.internalProps.emptyTip) || void 0 === _d || _d.resetVisible();
    }
    this.render(), isValid_default(oldHoverState.col) && isValid_default(oldHoverState.row) && oldHoverState.col >= 0 && oldHoverState.row >= 0 && setTimeout(() => {
      var _a2;
      null === (_a2 = this.internalProps) || void 0 === _a2 || _a2.tooltipHandler.showTooltip(oldHoverState.col, oldHoverState.row);
    }, 0);
  }
  setRecordChildren(records, col, row, recalculateColWidths = true) {
    const record = this.getCellOriginRecord(col, row);
    record.children = records;
    const index = this.getRecordShowIndexByCell(col, row);
    this.dataSource.setRecord(record, index), this._refreshHierarchyState(col, row, recalculateColWidths);
  }
  startEditCell(col, row, value) {
    var _a;
    if (isValid_default(col) && isValid_default(row)) this.eventManager.isDraging = false, this.selectCell(col, row), this.editorManager.startEditCell(col, row, value);
    else if (null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.cellPos) {
      const { col: col2, row: row2 } = this.stateManager.select.cellPos;
      isValid_default(col2) && isValid_default(row2) && this.editorManager.startEditCell(col2, row2, value);
    }
  }
  completeEditCell() {
    this.editorManager.completeEdit();
  }
  getEditor(col, row) {
    var _a, _b;
    const define = this.getBodyColumnDefine(col, row);
    let editorDefine = this.isHeader(col, row) ? null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor : null !== (_b = null == define ? void 0 : define.editor) && void 0 !== _b ? _b : this.options.editor;
    if ("function" == typeof editorDefine) {
      editorDefine = editorDefine({
        col,
        row,
        dataValue: this.getCellOriginValue(col, row),
        value: this.getCellValue(col, row) || "",
        table: this
      });
    }
    return "string" == typeof editorDefine ? get5(editorDefine) : editorDefine;
  }
  isHasEditorDefine(col, row) {
    var _a, _b;
    const define = this.getBodyColumnDefine(col, row);
    let editorDefine = this.isHeader(col, row) ? null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor : null !== (_b = null == define ? void 0 : define.editor) && void 0 !== _b ? _b : this.options.editor;
    if ("function" == typeof editorDefine) {
      editorDefine = editorDefine({
        col,
        row,
        dataValue: this.getCellOriginValue(col, row),
        value: this.getCellValue(col, row) || "",
        table: this
      });
    }
    return isValid_default(editorDefine);
  }
  changeCellValue(col, row, value, workOnEditableCell = false, triggerEvent = true) {
    return listTableChangeCellValue(col, row, value, workOnEditableCell, triggerEvent, this);
  }
  changeCellValues(startCol, startRow, values, workOnEditableCell = false, triggerEvent = true) {
    return listTableChangeCellValues(startCol, startRow, values, workOnEditableCell, triggerEvent, this);
  }
  addRecord(record, recordIndex) {
    var _a;
    listTableAddRecord(record, recordIndex, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
  }
  addRecords(records, recordIndex) {
    var _a;
    listTableAddRecords(records, recordIndex, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
  }
  deleteRecords(recordIndexs) {
    var _a;
    listTableDeleteRecords(recordIndexs, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
  }
  updateRecords(records, recordIndexs) {
    listTableUpdateRecords(records, recordIndexs, this);
  }
  _hasCustomRenderOrLayout() {
    var _a, _b, _c, _d;
    const { headerObjects } = this.internalProps.layoutMap;
    if (this.options.customRender) return true;
    for (let i = 0; i < headerObjects.length; i++) {
      const headerObject = headerObjects[i];
      if ((null === (_a = null == headerObject ? void 0 : headerObject.define) || void 0 === _a ? void 0 : _a.customLayout) || (null === (_b = null == headerObject ? void 0 : headerObject.define) || void 0 === _b ? void 0 : _b.headerCustomLayout) || (null === (_c = null == headerObject ? void 0 : headerObject.define) || void 0 === _c ? void 0 : _c.customRender) || (null === (_d = null == headerObject ? void 0 : headerObject.define) || void 0 === _d ? void 0 : _d.headerCustomRender)) return true;
    }
    return false;
  }
  getAggregateValuesByField(field) {
    const columns = this.internalProps.layoutMap.getColumnByField(field), results = [];
    for (let i = 0; i < columns.length; i++) {
      const aggregator2 = columns[i].columnDefine.aggregator;
      if (delete columns[i].columnDefine, aggregator2) {
        const columnAggregateValue = {
          col: columns[i].col,
          aggregateValue: null
        };
        if (columnAggregateValue.aggregateValue = [], Array.isArray(aggregator2)) for (let j = 0; j < aggregator2.length; j++) columnAggregateValue.aggregateValue.push({
          aggregationType: aggregator2[j].type,
          value: aggregator2[j].value()
        });
        else columnAggregateValue.aggregateValue.push({
          aggregationType: aggregator2.type,
          value: aggregator2.value()
        });
        results.push(columnAggregateValue);
      }
    }
    return results;
  }
  isAggregation(col, row) {
    return this.internalProps.layoutMap.isAggregation(col, row);
  }
  getGroupTitleLevel(col, row) {
    var _a;
    if (!this.options.groupBy) return;
    const indexArr = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row)), groupLength = null !== (_a = this.dataSource.getGroupLength()) && void 0 !== _a ? _a : 0;
    let indexArrLngth = isArray_default(indexArr) ? indexArr.length - 1 : 0;
    return groupLength > 0 && indexArrLngth === groupLength && (indexArrLngth = void 0), indexArrLngth;
  }
  getBodyRowIndexByRecordIndex(index) {
    return Array.isArray(index) && 1 === index.length && (index = index[0]), this.dataSource.getTableIndex(index);
  }
  _parseColumnWidthConfig(columnWidthConfig) {
    for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
      const item = columnWidthConfig[i], key = item.key, width = item.width, columnData = this.internalProps.layoutMap.getColumnByKey(key);
      if (columnData.columnDefine) {
        const { col } = columnData;
        this.internalProps._widthResizedColMap.has(col) || (this._setColWidth(col, width), this.internalProps._widthResizedColMap.add(col));
      }
    }
  }
  release() {
    this.editorManager.release(), super.release();
  }
};

// node_modules/@visactor/vtable/es/components/util/orient.js
function isXAxis2(orient) {
  return "bottom" === orient || "top" === orient;
}
function isYAxis(orient) {
  return "left" === orient || "right" === orient;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/index.js
var import_eventemitter34 = __toESM(require_eventemitter3());

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isType.js
var isType3 = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType_default3 = isType3;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isFunction.js
var isFunction = (value) => "function" == typeof value;
var isFunction_default4 = isFunction;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isNil.js
var isNil3 = (value) => null == value;
var isNil_default4 = isNil3;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isValid.js
var isValid3 = (value) => null != value;
var isValid_default4 = isValid3;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isString.js
var isString4 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType_default3(value, "String");
};
var isString_default4 = isString4;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isArray.js
var isArray3 = (value) => Array.isArray ? Array.isArray(value) : isType_default3(value, "Array");
var isArray_default4 = isArray3;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isNumber.js
var isNumber5 = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType_default3(value, "Number");
};
var isNumber_default4 = isNumber5;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/isPrototype.js
var objectProto3 = Object.prototype;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/mixin.js
function keys(obj2) {
  if (!obj2) return [];
  if (Object.keys) return Object.keys(obj2);
  const keyList = [];
  for (const key in obj2) obj2.hasOwnProperty(key) && keyList.push(key);
  return keyList;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i = 0; i < keysArr.length; i++) {
    const key = keysArr[i];
    (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
  }
  return target;
}
function mixin2(target, source, override = true) {
  if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keyList.length; i++) {
      const key = keyList[i];
      "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
    }
  } else defaults(target, source, override);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/range.js
function range4(start, stop, step) {
  isValid_default4(stop) || (stop = start, start = 0), isValid_default4(step) || (step = 1);
  let i = -1;
  const n = 0 | Math.max(0, Math.ceil((stop - start) / step)), range5 = new Array(n);
  for (; ++i < n; ) range5[i] = start + i * step;
  return range5;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/ascending.js
function ascending4(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/toNumber.js
function toNumber4(a2) {
  return Number(a2);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/logger.js
var hasConsole3 = "undefined" != typeof console;
function log3(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole3 && console[method].apply(console, args);
}
var LoggerLevel3;
!function(LoggerLevel4) {
  LoggerLevel4[LoggerLevel4.None = 0] = "None", LoggerLevel4[LoggerLevel4.Error = 1] = "Error", LoggerLevel4[LoggerLevel4.Warn = 2] = "Warn", LoggerLevel4[LoggerLevel4.Info = 3] = "Info", LoggerLevel4[LoggerLevel4.Debug = 4] = "Debug";
}(LoggerLevel3 || (LoggerLevel3 = {}));
var Logger4 = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default4(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel3.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h) => h === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex((h) => h === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h) => h(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel3.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel3.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel3.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel3.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel3.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log3(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel3.Warn && log3(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel3.Info && log3(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel3.Debug && log3(this._method || "log", "DEBUG", args), this;
  }
};
Logger4._instance = null;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/bisect.js
function bisect4(a2, x, lo = 0, hi) {
  for (isNil_default4(hi) && (hi = a2.length); lo < hi; ) {
    const mid = lo + hi >>> 1;
    ascending4(a2[mid], x) > 0 ? hi = mid : lo = mid + 1;
  }
  return lo;
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/tickStep.js
var e104 = Math.sqrt(50);
var e54 = Math.sqrt(10);
var e24 = Math.sqrt(2);

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/number.js
var DEFAULT_ABSOLUTE_TOLERATE = 1e-10;
var DEFAULT_RELATIVE_TOLERATE = 1e-10;
function isNumberClose2(a2, b, relTol = DEFAULT_RELATIVE_TOLERATE, absTol = DEFAULT_ABSOLUTE_TOLERATE) {
  const abs5 = absTol, rel = relTol * Math.max(a2, b);
  return Math.abs(a2 - b) <= Math.max(abs5, rel);
}
function isGreater2(a2, b, relTol, absTol) {
  return a2 > b && !isNumberClose2(a2, b, relTol, absTol);
}
function isLess2(a2, b, relTol, absTol) {
  return a2 < b && !isNumberClose2(a2, b, relTol, absTol);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/memoize.js
var memoize4 = (func) => {
  let lastArgs = null, lastResult = null;
  return (...args) => (lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/clamp.js
var clamp = function(input, min2, max2) {
  return input < min2 ? min2 : input > max2 ? max2 : input;
};
var clamp_default4 = clamp;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/clamper.js
function clamper4(a2, b) {
  let t;
  return a2 > b && (t = a2, a2 = b, b = t), (x) => Math.max(a2, Math.min(b, x));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/debounce.js
var hasRaf3 = false;
try {
  hasRaf3 = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf3 = false;
}
hasRaf3 = false;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/common/interpolate.js
function interpolateNumber2(a2, b) {
  return (t) => a2 * (1 - t) + b * t;
}
function interpolateNumberRound2(a2, b) {
  return function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}
function interpolateDate2(a2, b) {
  const aVal = a2.valueOf(), bVal = b.valueOf(), d = /* @__PURE__ */ new Date();
  return (t) => (d.setTime(aVal * (1 - t) + bVal * t), d);
}
var reA3 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB3 = new RegExp(reA3.source, "g");

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/math.js
var pi5 = Math.PI;
var halfPi5 = pi5 / 2;
var tau4 = 2 * pi5;
var pi24 = 2 * Math.PI;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/graphics/algorithm/intersect.js
var InnerBBox3;
!function(InnerBBox4) {
  InnerBBox4[InnerBBox4.NONE = 0] = "NONE", InnerBBox4[InnerBBox4.BBOX1 = 1] = "BBOX1", InnerBBox4[InnerBBox4.BBOX2 = 2] = "BBOX2";
}(InnerBBox3 || (InnerBBox3 = {}));

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/graphics/text/stringWidth.js
var eastAsianCharacterInfo3 = (character) => {
  let x = character.charCodeAt(0), y = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x;
  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/graphics/text/measure/util.js
function getContextFont4(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/graphics/text/measure/textMeasure.js
var TextMeasure4 = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default4(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default4(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return false;
    if (isNil_default4(this._canvas) && (isValid_default4(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default4(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default4(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default4(this._context) && isValid_default4(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default4(context) && (context.save(), context.font = getContextFont4(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default4(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default4(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale6 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale6;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default4(text2)) return {
      width: 0,
      height: 0
    };
    if (isNil_default4(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i];
      let size = this._measureSpecialChar(char);
      isNil_default4(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default4(size) && ["F", "W"].includes(eastAsianCharacterInfo3(char)) && (size = this._measureFullSizeChar()), isNil_default4(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i], size = ["F", "W"].includes(eastAsianCharacterInfo3(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default4(text2)) return defaultResult;
    if (isArray_default4(text2)) {
      const textArr = text2.filter(isValid_default4).map((s2) => s2.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default4(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default4(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default4(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default4(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default4(this._canvas) && (this._canvas = null), isValid_default4(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure4.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure4.NUMBERS_CHAR_SET = "0123456789", TextMeasure4.FULL_SIZE_CHAR = "字";

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/index.js
var color_exports4 = {};
__export(color_exports4, {
  Color: () => Color4,
  DEFAULT_COLORS: () => DEFAULT_COLORS4,
  RGB: () => RGB3,
  hexToRgb: () => hexToRgb4,
  hslToRgb: () => hslToRgb3,
  interpolateRgb: () => interpolateRgb2,
  rgbToHex: () => rgbToHex3,
  rgbToHsl: () => rgbToHsl3
});

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/hslToRgb.js
function hslToRgb3(h, s2, l) {
  s2 /= 100, l /= 100;
  const c2 = (1 - Math.abs(2 * l - 1)) * s2, x = c2 * (1 - Math.abs(h / 60 % 2 - 1)), m3 = l - c2 / 2;
  let r = 0, g = 0, b = 0;
  return 0 <= h && h < 60 ? (r = c2, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c2, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c2, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c2) : 240 <= h && h < 300 ? (r = x, g = 0, b = c2) : 300 <= h && h < 360 && (r = c2, g = 0, b = x), r = Math.round(255 * (r + m3)), g = Math.round(255 * (g + m3)), b = Math.round(255 * (b + m3)), {
    r,
    g,
    b
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/rgbToHsl.js
function rgbToHsl3(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  const cMin = Math.min(r, g, b), cMax = Math.max(r, g, b), delta = cMax - cMin;
  let h = 0, s2 = 0, l = 0;
  return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s2 = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s2 = +(100 * s2).toFixed(1), l = +(100 * l).toFixed(1), {
    h,
    s: s2,
    l
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/Color.js
var REG_HEX = /^#([0-9a-f]{3,8})$/;
var DEFAULT_COLORS_OPACITY = {
  transparent: 4294967040
};
var DEFAULT_COLORS4 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function hex(value) {
  return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
}
function rgb(value) {
  return isNumber_default4(value) ? new RGB3(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray_default4(value) ? new RGB3(value[0], value[1], value[2]) : new RGB3(255, 255, 255);
}
function rgba(value) {
  return isNumber_default4(value) ? new RGB3(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray_default4(value) ? new RGB3(value[0], value[1], value[2], value[3]) : new RGB3(255, 255, 255, 1);
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? 0.0773993808 * c2 : Math.pow(0.9478672986 * c2 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? 12.92 * c2 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var setHex = (formatValue, forceHex) => {
  const isHex = REG_HEX.exec(formatValue);
  if (forceHex || isHex) {
    const hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
    return 3 === hexLength ? new RGB3((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB3(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : null;
  }
};
var Color4 = class _Color {
  static Brighter(source, b = 1) {
    return 1 === b ? source : new _Color(source).brighter(b).toRGBA();
  }
  static SetOpacity(source, o = 1) {
    return 1 === o ? source : new _Color(source).setOpacity(o).toRGBA();
  }
  static getColorBrightness(source, model = "hsl") {
    const color = source instanceof _Color ? source : new _Color(source);
    switch (model) {
      case "hsv":
      default:
        return color.getHSVBrightness();
      case "hsl":
        return color.getHSLBrightness();
      case "lum":
        return color.getLuminance();
      case "lum2":
        return color.getLuminance2();
      case "lum3":
        return color.getLuminance3();
    }
  }
  static parseColorString(value) {
    if (isValid_default4(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
    if (isValid_default4(DEFAULT_COLORS4[value])) return rgb(DEFAULT_COLORS4[value]);
    const formatValue = `${value}`.trim().toLowerCase(), hexRes = setHex(formatValue);
    if (void 0 !== hexRes) return hexRes;
    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB3(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","), rgb2 = hslToRgb3(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
      return new RGB3(rgb2.r, rgb2.g, rgb2.b, parseFloat(aColor[3]));
    }
  }
  constructor(value) {
    const color = _Color.parseColorString(value);
    color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB3(255, 255, 255));
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(k2) {
    const { r, g, b } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k2))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k2))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k2))), this;
  }
  add(color) {
    const { r, g, b } = this.color;
    return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
  }
  sub(color) {
    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
  }
  multiply(color) {
    const { r, g, b } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return 0.5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
  }
  setHsl(h, s2, l) {
    const opacity = this.color.opacity, hsl = rgbToHsl3(this.color.r, this.color.g, this.color.b), rgb2 = hslToRgb3(isNil_default4(h) ? hsl.h : clamp_default4(h, 0, 360), isNil_default4(s2) ? hsl.s : s2 >= 0 && s2 <= 1 ? 100 * s2 : s2, isNil_default4(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
    return this.color = new RGB3(rgb2.r, rgb2.g, rgb2.b, opacity), this;
  }
  setRGB(r, g, b) {
    return !isNil_default4(r) && (this.color.r = r), !isNil_default4(g) && (this.color.g = g), !isNil_default4(b) && (this.color.b = b), this;
  }
  setHex(value) {
    const formatValue = `${value}`.trim().toLowerCase(), res = setHex(formatValue, true);
    return null != res ? res : this;
  }
  setColorName(name) {
    const hex2 = DEFAULT_COLORS4[name.toLowerCase()];
    return void 0 !== hex2 ? this.setHex(hex2) : console.warn("THREE.Color: Unknown color " + name), this;
  }
  setScalar(scalar) {
    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
  }
  setOpacity(o = 1) {
    return this.color.opacity = o, this;
  }
  getLuminance() {
    return (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) / 255;
  }
  getLuminance2() {
    return (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) / 255;
  }
  getLuminance3() {
    return (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255;
  }
  clone() {
    return new _Color(this.color.toString());
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  copySRGBToLinear(color) {
    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
  }
  copyLinearToSRGB(color) {
    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
};
var RGB3 = class {
  constructor(r, g, b, opacity) {
    this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid_default4(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
  }
  formatHex() {
    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
  }
  formatRgb() {
    const opacity = this.opacity;
    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
  }
  formatHsl() {
    const opacity = this.opacity, { h, s: s2, l } = rgbToHsl3(this.r, this.g, this.b);
    return `${1 === opacity ? "hsl(" : "hsla("}${h},${s2}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
  }
  toString() {
    return this.formatHex();
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/hexToRgb.js
function hexToRgb4(str2) {
  let r = "", g = "", b = "";
  const strtIndex = "#" === str2[0] ? 1 : 0;
  for (let i = strtIndex; i < str2.length; i++) "#" !== str2[i] && (i < strtIndex + 2 ? r += str2[i] : i < strtIndex + 4 ? g += str2[i] : i < strtIndex + 6 && (b += str2[i]));
  return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/rgbToHex.js
function rgbToHex3(r, g, b) {
  return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/color/interpolate.js
function interpolateRgb2(colorA, colorB) {
  const redA = colorA.r, redB = colorB.r, greenA = colorA.g, greenB = colorB.g, blueA = colorA.b, blueB = colorB.b, opacityA = colorA.opacity, opacityB = colorB.opacity;
  return (t) => {
    const r = Math.round(redA * (1 - t) + redB * t), g = Math.round(greenA * (1 - t) + greenB * t), b = Math.round(blueA * (1 - t) + blueB * t);
    return new RGB3(r, g, b, opacityA * (1 - t) + opacityB * t);
  };
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/node_modules/@visactor/vutils/es/time/interval.js
var SECOND2 = 1e3;
var MINUTE2 = 6e4;
var HOUR4 = 36e5;
var DAY4 = 24 * HOUR4;
var MONTH4 = 31 * DAY4;
var YEAR4 = 365 * DAY4;

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/type.js
var ScaleEnum2;
!function(ScaleEnum3) {
  ScaleEnum3.Identity = "identity", ScaleEnum3.Linear = "linear", ScaleEnum3.Log = "log", ScaleEnum3.Pow = "pow", ScaleEnum3.Sqrt = "sqrt", ScaleEnum3.Symlog = "symlog", ScaleEnum3.Time = "time", ScaleEnum3.Quantile = "quantile", ScaleEnum3.Quantize = "quantize", ScaleEnum3.Threshold = "threshold", ScaleEnum3.Ordinal = "ordinal", ScaleEnum3.Point = "point", ScaleEnum3.Band = "band";
}(ScaleEnum2 || (ScaleEnum2 = {}));
var EnableScaleMap2 = {};
Object.values(ScaleEnum2).forEach((v) => {
  EnableScaleMap2[v] = true;
});

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/utils.js
function identity2(x) {
  return x;
}
var logNegative2 = (x) => -Math.log(-x);
var expNegative2 = (x) => -Math.exp(-x);
var pow102 = (x) => isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
var powp2 = (base) => 10 === base ? pow102 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
var logp2 = (base) => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), (x) => Math.log(x) / base);
var symlog2 = (c2) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c2));
var symexp2 = (c2) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c2;
function normalize3(a2, b) {
  if (a2 = Number(a2), b = Number(b), b -= a2) return (x) => (x - a2) / b;
  const result2 = Number.isNaN(b) ? NaN : 0.5;
  return () => result2;
}
function bimap2(domain, range5, interpolate3) {
  const d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];
  let d0Fuc, r0Fuc;
  return d1 < d0 ? (d0Fuc = normalize3(d1, d0), r0Fuc = interpolate3(r1, r0)) : (d0Fuc = normalize3(d0, d1), r0Fuc = interpolate3(r0, r1)), (x) => r0Fuc(d0Fuc(x));
}
function bandSpace2(count, paddingInner, paddingOuter) {
  let space;
  return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
}
function scaleWholeRangeSize2(count, bandwidth, paddingInner, paddingOuter) {
  1 === paddingInner && (paddingInner = 0);
  return bandSpace2(count, paddingInner, paddingOuter) * (bandwidth / (1 - paddingInner));
}
function calculateBandwidthFromWholeRangeSize2(count, wholeSize, paddingInner, paddingOuter, round) {
  const space = bandSpace2(count, paddingInner, paddingOuter);
  let step = wholeSize / Math.max(1, space || 1);
  round && (step = Math.floor(step));
  let bandwidth = step * (1 - paddingInner);
  return round && (bandwidth = Math.round(bandwidth)), bandwidth;
}
function calculateWholeRangeFromRangeFactor2(range5, rangeFactor) {
  const k2 = (range5[1] - range5[0]) / (rangeFactor[1] - rangeFactor[0]), b = range5[0] - k2 * rangeFactor[0];
  return [b, k2 + b];
}
function polymap2(domain, range5, interpolate3) {
  const j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j);
  let i = -1;
  for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range5 = range5.slice().reverse()); ++i < j; ) d[i] = normalize3(domain[i], domain[i + 1]), r[i] = interpolate3(range5[i], range5[i + 1]);
  return function(x) {
    const i2 = bisect4(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
var nice2 = (domain, options) => {
  const newDomain = domain.slice();
  let startIndex = 0, endIndex = newDomain.length - 1, x0 = newDomain[startIndex], x1 = newDomain[endIndex];
  return x1 < x0 && ([startIndex, endIndex] = [endIndex, startIndex], [x0, x1] = [x1, x0]), newDomain[startIndex] = options.floor(x0), newDomain[endIndex] = options.ceil(x1), newDomain;
};
var niceNumber2 = (value, round = false) => {
  const exponent = Math.floor(Math.log10(value)), fraction = value / Math.pow(10, exponent);
  let niceFraction;
  return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent);
};
var restrictNumber2 = (value, domain) => {
  let min2, max2;
  return domain[0] < domain[1] ? (min2 = domain[0], max2 = domain[1]) : (min2 = domain[1], max2 = domain[0]), Math.min(Math.max(value, min2), max2);
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/base-scale.js
var BaseScale2 = class {
  constructor() {
    this._rangeFactorStart = null, this._rangeFactorEnd = null;
  }
  _calculateWholeRange(range5) {
    return this._wholeRange ? this._wholeRange : isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && 2 === range5.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor2(range5, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range5;
  }
  rangeFactor(_, slience, clear2) {
    return _ ? (2 === _.length && _.every((r) => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear2 ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
  }
  rangeFactorStart(_, slience) {
    var _a;
    return isNil_default4(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default4(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  rangeFactorEnd(_, slience) {
    var _a;
    return isNil_default4(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default4(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  generateFishEyeTransform() {
    var _a;
    if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
    const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions, range5 = this.range(), first = range5[0], last2 = range5[range5.length - 1], min2 = Math.min(first, last2), max2 = Math.max(first, last2), focus = clamp_default4(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min2, max2), rangeRadius = isNil_default4(radius) ? (max2 - min2) * radiusRatio : radius;
    let k0 = Math.exp(distortion);
    k0 = k0 / (k0 - 1) * rangeRadius;
    const k1 = distortion / rangeRadius;
    this._fishEyeTransform = (output) => {
      const delta = Math.abs(output - focus);
      if (delta >= rangeRadius) return output;
      if (delta <= 1e-6) return focus;
      const k2 = k0 * (1 - Math.exp(-delta * k1)) / delta * 0.75 + 0.25;
      return focus + (output - focus) * k2;
    };
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
  get(key, defaultValue) {
    var _a;
    return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/ordinal-scale.js
var implicit3 = Symbol("implicit");
var OrdinalScale2 = class _OrdinalScale extends BaseScale2 {
  specified(_) {
    var _a;
    return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), this) : Object.assign({}, this._specified);
  }
  _getSpecifiedValue(input) {
    if (this._specified) return this._specified[input];
  }
  constructor() {
    super(), this.type = ScaleEnum2.Ordinal, this._index = /* @__PURE__ */ new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit3;
  }
  clone() {
    const s2 = new _OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
    return this._specified && s2.specified(this._specified), s2;
  }
  calculateVisibleDomain(range5) {
    if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && 2 === range5.length) {
      return [this.invert(range5[0]), this.invert(range5[1])];
    }
    return this._domain;
  }
  scale(d) {
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit3) return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(d) {
    let i = 0;
    for (; i < this._ordinalRange.length && this._ordinalRange[i] !== d; ) i++;
    return this._domain[(i - 1) % this._domain.length];
  }
  domain(_) {
    if (!_) return this._domain.slice();
    this._domain = [], this._index = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = `${value}`;
      this._index.has(key) || this._index.set(key, this._domain.push(value));
    }
    return this;
  }
  range(_) {
    if (!_) return this._ordinalRange.slice();
    const nextRange = Array.from(_);
    return this._ordinalRange = nextRange, this;
  }
  index(x) {
    var _a;
    return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/tick-sample-int.js
function generateTicks(start, stop, step, reverse) {
  const ticks6 = [];
  let ptr = start;
  for (; ptr <= stop; ) ticks6.push(ptr), ptr += step;
  return reverse && ticks6.reverse(), ticks6;
}
function ticks4(start, stop, count, allowExcessive) {
  let reverse, step;
  if (stop = Math.floor(+stop), start = Math.floor(+start), !(count = Math.floor(+count))) return [];
  if (start === stop) return [start];
  if (reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  let expectedCount = clamper4(1, stop - start + 1)(count);
  if (step = Math.floor((stop - start + 1) / expectedCount), !allowExcessive) for (; Math.ceil((stop - start + 1) / step) > count && expectedCount > 1; ) expectedCount -= 1, step = Math.floor((stop - start) / expectedCount);
  return generateTicks(start, stop, step, reverse);
}
function stepTicks3(start, stop, step) {
  let reverse;
  if (stop = Math.floor(+stop), start = Math.floor(+start), step = clamper4(1, stop - start + 1)(Math.floor(+step)), reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  return generateTicks(start, stop, step, reverse);
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/band-scale.js
var BandScale2 = class _BandScale extends OrdinalScale2 {
  constructor(slience) {
    super(), this.type = ScaleEnum2.Band, this._range = [0, 1], this._step = void 0, this._bandwidth = void 0, this._isFixed = false, this._round = false, this._paddingInner = 0, this._paddingOuter = 0, this._align = 0.5, this._unknown = void 0, delete this.unknown, this.rescale(slience);
  }
  rescale(slience, changeProperty) {
    if (slience) return this;
    this._wholeRange = null;
    const wholeRange = this._calculateWholeRange(this._range, changeProperty), n = super.domain().length, reverse = wholeRange[1] < wholeRange[0];
    let start = wholeRange[Number(reverse) - 0];
    const stop = wholeRange[1 - Number(reverse)], space = bandSpace2(n, this._paddingInner, this._paddingOuter);
    return this._step = (stop - start) / Math.max(1, space || 1), this._round && (this._step = Math.floor(this._step)), start += (stop - start - this._step * (n - this._paddingInner)) * this._align, this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)), this._round && (start = Math.round(start), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth))), this._bandRangeState = {
      reverse,
      start: reverse ? start + this._step * (n - 1) : start,
      count: n
    }, this.generateFishEyeTransform(), this;
  }
  scale(d) {
    if (!this._bandRangeState) return;
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit3) return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const { count, start, reverse } = this._bandRangeState, output = start + (reverse ? -1 : 1) * ((i - 1) % count) * this._step;
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  _calculateWholeRange(range5, changeProperty) {
    if (this._wholeRange) return this._wholeRange;
    if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
      let wholeSize;
      if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && 2 === range5.length) {
        const wholeRange = calculateWholeRangeFromRangeFactor2(range5, [this._rangeFactorStart, this._rangeFactorEnd]);
        wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
      } else wholeSize = Math.abs(range5[1] - range5[0]);
      const autoBandwidth = calculateBandwidthFromWholeRangeSize2(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
      autoBandwidth < this._minBandwidth ? (this._bandwidth = this._minBandwidth, this._isFixed = true) : autoBandwidth > this._maxBandwidth ? (this._bandwidth = this._maxBandwidth, this._isFixed = true) : (this._bandwidth = autoBandwidth, this._isFixed = false);
    }
    if (this.isBandwidthFixed()) {
      const wholeLength = scaleWholeRangeSize2(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) * Math.sign(range5[1] - range5[0]), rangeFactorSize = Math.min((range5[1] - range5[0]) / wholeLength, 1);
      if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd)) {
        if (wholeLength > 0) {
          const r0 = range5[0] - wholeLength * this._rangeFactorStart, r1 = r0 + wholeLength;
          this._wholeRange = [r0, r1];
        } else {
          const r1 = range5[1] + wholeLength * (1 - this._rangeFactorEnd), r0 = r1 - wholeLength;
          this._wholeRange = [r0, r1];
        }
        const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1, canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
        "rangeFactorStart" === changeProperty && canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : "rangeFactorEnd" === changeProperty && canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : range5[0] <= range5[1] ? canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : (this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize) : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : (this._rangeFactorStart = 1 - rangeFactorSize, this._rangeFactorEnd = 1);
      } else this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize, this._wholeRange = [range5[0], range5[0] + wholeLength];
      return this._wholeRange;
    }
    return super._calculateWholeRange(range5);
  }
  calculateWholeRangeSize() {
    const wholeRange = this._calculateWholeRange(this._range);
    return Math.abs(wholeRange[1] - wholeRange[0]);
  }
  calculateVisibleDomain(range5) {
    const domain = this._domain;
    if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && domain.length) {
      const d0 = this._getInvertIndex(range5[0]), d1 = this._getInvertIndex(range5[1]);
      return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
    }
    return domain;
  }
  domain(_, slience) {
    return _ ? (super.domain(_), this.rescale(slience)) : super.domain();
  }
  range(_, slience) {
    return _ ? (this._range = [toNumber4(_[0]), toNumber4(_[1])], this.rescale(slience)) : this._range;
  }
  rangeRound(_, slience) {
    return this._range = [toNumber4(_[0]), toNumber4(_[1])], this._round = true, this.rescale(slience);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    if (-1 === count) return d;
    return ticks4(0, d.length - 1, count, false).map((i) => d[i]);
  }
  tickData(count = 10) {
    return this.ticks(count).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
    }));
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticks4(0, d.length - 1, count, true).filter((i) => i < d.length).map((i) => d[i]);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks3(0, d.length - 1, step).map((i) => d[i]);
  }
  _getInvertIndex(d) {
    let i = 0;
    const halfStep = this.step() / 2, halfBandwidth = this.bandwidth() / 2, len = this._domain.length, range5 = this.range(), reverse = range5[0] > range5[range5.length - 1];
    for (i = 0; i < len; i++) {
      const r = this.scale(this._domain[i]) + halfBandwidth;
      if (0 === i && (!reverse && !isGreater2(d, r + halfStep) || reverse && !isLess2(d, r - halfStep))) break;
      if (i === len - 1) break;
      if (!isLess2(d, r - halfStep) && !isGreater2(d, r + halfStep)) break;
    }
    return i >= 0 && i <= len - 1 ? i : len - 1;
  }
  invert(d) {
    return this._domain[this._getInvertIndex(d)];
  }
  padding(p, slience) {
    return void 0 !== p ? (this._paddingOuter = Math.max(0, Math.min(Array.isArray(p) ? Math.min.apply(null, p) : p)), this._paddingInner = this._paddingOuter, this.rescale(slience)) : this._paddingInner;
  }
  paddingInner(_, slience) {
    return void 0 !== _ ? (this._paddingInner = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingInner;
  }
  paddingOuter(_, slience) {
    return void 0 !== _ ? (this._paddingOuter = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingOuter;
  }
  step() {
    return this._step;
  }
  round(_, slience) {
    return void 0 !== _ ? (this._round = _, this.rescale(slience)) : this._round;
  }
  align(_, slience) {
    return void 0 !== _ ? (this._align = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._align;
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this.rescale(slience)) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default4(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this.rescale(slience, "rangeFactorStart"));
  }
  rangeFactorEnd(_, slience) {
    return isNil_default4(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this.rescale(slience, "rangeFactorEnd"));
  }
  bandwidth(_, slience) {
    return _ ? ("auto" === _ ? (this._bandwidth = void 0, this._isFixed = false) : (this._bandwidth = _, this._isFixed = true), this._userBandwidth = _, this.rescale(slience)) : this._bandwidth;
  }
  maxBandwidth(_, slience) {
    return _ ? (this._maxBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._maxBandwidth;
  }
  minBandwidth(_, slience) {
    return _ ? (this._minBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._minBandwidth;
  }
  fishEye(options, slience, clear2) {
    return options || clear2 ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  isBandwidthFixed() {
    return this._isFixed && !!this._bandwidth;
  }
  _isBandwidthFixedByUser() {
    return this._isFixed && this._userBandwidth && isNumber_default4(this._userBandwidth);
  }
  clone() {
    var _a, _b, _c;
    return new _BandScale(true).domain(this._domain, true).range(this._range, true).round(this._round, true).paddingInner(this._paddingInner, true).paddingOuter(this._paddingOuter, true).align(this._align, true).bandwidth(null !== (_a = this._userBandwidth) && void 0 !== _a ? _a : "auto", true).maxBandwidth(null !== (_b = this._maxBandwidth) && void 0 !== _b ? _b : "auto", true).minBandwidth(null !== (_c = this._maxBandwidth) && void 0 !== _c ? _c : "auto");
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/interpolate.js
var { interpolateRgb: interpolateRgb3 } = color_exports4;
function interpolate2(a2, b) {
  const t = typeof b;
  let c2;
  if (isNil_default4(b) || "boolean" === t) return () => b;
  if ("number" === t) return interpolateNumber2(a2, b);
  if ("string" === t) {
    if (c2 = color_exports4.Color.parseColorString(b)) {
      const rgb2 = interpolateRgb3(color_exports4.Color.parseColorString(a2), c2);
      return (t2) => rgb2(t2).formatRgb();
    }
    return interpolateNumber2(Number(a2), Number(b));
  }
  return b instanceof color_exports4.RGB ? interpolateRgb3(a2, b) : b instanceof color_exports4.Color ? interpolateRgb3(a2.color, b.color) : b instanceof Date ? interpolateDate2(a2, b) : interpolateNumber2(Number(a2), Number(b));
}

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/continuous-scale.js
var ContinuousScale2 = class extends BaseScale2 {
  constructor(transformer = identity2, untransformer = identity2) {
    super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = true, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity2, this._piecewise = bimap2, this._interpolate = interpolate2;
  }
  calculateVisibleDomain(range5) {
    var _a;
    if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && 2 === range5.length) {
      return [this.invert(range5[0]), this.invert(range5[1])];
    }
    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
  }
  fishEye(options, slience, clear2) {
    return options || clear2 ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._clamp(x)));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(y) {
    var _a;
    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber2)), this._clamp(this.untransformer(this._input(y)));
  }
  domain(_, slience) {
    var _a;
    if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
    const nextDomain = Array.from(_, toNumber4);
    return this._domain = nextDomain, this.rescale(slience);
  }
  range(_, slience) {
    if (!_) return this._range.slice();
    const nextRange = Array.from(_);
    return this._range = nextRange, this.rescale(slience);
  }
  rangeRound(_, slience) {
    const nextRange = Array.from(_);
    return this._range = nextRange, this._interpolate = interpolateNumberRound2, this.rescale(slience);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
    let n = Math.min(domainLength, rangeLength);
    if (domainLength && domainLength < rangeLength && this._forceAlign) {
      const deltaStep = rangeLength - domainLength + 1, last2 = domain[domainLength - 1], delta = domainLength >= 2 ? (last2 - domain[domainLength - 2]) / deltaStep : 0;
      for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last2 - delta * (deltaStep - i);
      n = rangeLength;
    }
    return this._autoClamp && (this._clamp = clamper4(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap2 : bimap2, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
  }
  clamp(_, f, slience) {
    return arguments.length ? (f ? (this._autoClamp = false, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity2), this.rescale(slience)) : this._clamp !== identity2;
  }
  interpolate(_, slience) {
    return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
  }
  ticks(count = 10) {
    return [];
  }
  tickData(count = 10) {
    const ticks6 = this.ticks(count);
    return (null != ticks6 ? ticks6 : []).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
    }));
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default4(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
  }
  rangeFactorEnd(_, slience) {
    return isNil_default4(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
  }
  forceAlignDomainRange(forceAlign) {
    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/tick-sample.js
var e105 = Math.sqrt(50);
var e55 = Math.sqrt(10);
var e25 = Math.sqrt(2);
var niceNumbers2 = [1, 2, 5, 10];
var calculateTicksOfSingleValue2 = (value, tickCount, noDecimals) => {
  let step = 1, start = value;
  const middleIndex = Math.floor((tickCount - 1) / 2), absVal = Math.abs(value);
  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep2(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range4(0, tickCount).map((index) => start + index * step)) : value > 0 ? calculateTicksByStep2(0, -(tickCount - 1) / step, step) : calculateTicksByStep2((tickCount - 1) / step, 0, step);
};
var d3Ticks2 = memoize4((start, stop, count, options) => {
  let reverse, n, ticks6, step, i = -1;
  if (count = +count, (start = +start) === (stop = +stop)) return [start];
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
  if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement2(start, stop, count).step, !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) * step;
  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
    step = 1;
    const r0 = Math.ceil(start), r1 = Math.floor(stop);
    if (!(r0 <= r1)) return [];
    for (ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = r0 + i;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) / step;
  }
  return reverse && ticks6.reverse(), ticks6;
});
var calculateTicksByStep2 = (start, stop, step) => {
  let n, ticks6, i = -1;
  if (step > 0) {
    let r0 = Math.floor(start / step), r1 = Math.ceil(stop / step);
    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.floor(start * step), r1 = Math.ceil(stop * step);
    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks6 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks6[i] = (r0 + i) / step;
  }
  return ticks6;
};
var appendTicksToCount2 = (ticks6, count, step) => {
  let n;
  const firstTick = ticks6[0], lastTick = ticks6[ticks6.length - 1], appendCount = count - ticks6.length;
  if (lastTick <= 0) {
    const headTicks2 = [];
    for (n = appendCount; n >= 1; n--) headTicks2.push(firstTick - n * step);
    return headTicks2.concat(ticks6);
  }
  if (firstTick >= 0) {
    for (n = 1; n <= appendCount; n++) ticks6.push(lastTick + n * step);
    return ticks6;
  }
  let headTicks = [];
  const tailTicks = [];
  for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
  return headTicks.concat(ticks6).concat(tailTicks);
};
var ticks5 = memoize4((start, stop, count, options) => {
  let reverse, ticks6, n;
  if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue2(start, count, null == options ? void 0 : options.noDecimals);
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue2(start, count, null == options ? void 0 : options.noDecimals);
  (reverse = stop < start) && (n = start, start = stop, stop = n);
  const stepRes = tickIncrement2(start, stop, count);
  let step = stepRes.step;
  if (!isFinite(step)) return [];
  if (step > 0) {
    let cur = 1;
    const { power, gap } = stepRes, delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
    for (; cur <= 5 && (ticks6 = calculateTicksByStep2(start, stop, step), ticks6.length > count + 1) && count > 2; ) step += delatStep, cur += 1;
    count > 2 && ticks6.length < count - 1 && (ticks6 = appendTicksToCount2(ticks6, count, step));
  } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks6 = calculateTicksByStep2(start, stop, step);
  return reverse && ticks6.reverse(), ticks6;
});
var getNickStep2 = (step) => {
  const power = Math.floor(Math.log(step) / Math.LN10), error = step / 10 ** power;
  let gap = niceNumbers2[0];
  return error >= e105 ? gap = niceNumbers2[3] : error >= e55 ? gap = niceNumbers2[2] : error >= e25 && (gap = niceNumbers2[1]), power >= 0 ? {
    step: gap * 10 ** power,
    gap,
    power
  } : {
    step: -(10 ** -power) / gap,
    gap,
    power
  };
};
function tickIncrement2(start, stop, count) {
  const step = (stop - start) / Math.max(0, count);
  return getNickStep2(step);
}
function forceTicks2(start, stop, count) {
  let step;
  if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
  if (count <= 0 || 0 === (step = forceTickIncrement2(start, stop, count)) || !isFinite(step)) return [];
  const ticks6 = new Array(count);
  for (let i = 0; i < count; i++) ticks6[i] = start + i * step;
  return ticks6;
}
function forceTickIncrement2(start, stop, count) {
  return (stop - start) / Math.max(1, count - 1);
}
function stepTicks4(start, stop, step) {
  let n, reverse, i = -1;
  if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
  const count = Math.floor((stop - start) / step + 1), ticks6 = new Array(count);
  for (; ++i < count; ) ticks6[i] = start + i * step;
  return reverse && ticks6.reverse(), ticks6;
}
function niceLinear2(d, count = 10) {
  let prestep, step, i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], maxIter = 10;
  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0; ) {
    if (step = tickIncrement2(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
    if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;
    else {
      if (!(step < 0)) break;
      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function parseNiceOptions2(originalDomain, option) {
  const hasForceMin = isNumber_default4(option.forceMin), hasForceMax = isNumber_default4(option.forceMax);
  let niceType = null;
  const niceMinMax = [];
  let niceDomain = null;
  const domainValidator = hasForceMin && hasForceMax ? (x) => x >= option.forceMin && x <= option.forceMax : hasForceMin ? (x) => x >= option.forceMin : hasForceMax ? (x) => x <= option.forceMax : null;
  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber_default4(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber_default4(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber_default4(niceMinMax[0]) && isNumber_default4(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber_default4(niceMinMax[0]) || isNumber_default4(niceMinMax[1]) ? isNumber_default4(niceMinMax[0]) ? "max" : "min" : "all", {
    niceType,
    niceDomain,
    niceMinMax,
    domainValidator
  };
}
var fixPrecision2 = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
var d3TicksForLog2 = memoize4((start, stop, count, base, transformer, untransformer, options) => {
  let u = start, v = stop;
  const r = v < u;
  r && ([u, v] = [v, u]);
  let k2, t, i = transformer(u), j = transformer(v), z = [];
  if (!(base % 1) && j - i < count) {
    if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
      for (; i <= j; ++i) for (k2 = 1; k2 < base; ++k2) if (t = i < 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
        if (t > v) break;
        z.push(t);
      }
    } else for (; i <= j; ++i) for (k2 = base - 1; k2 >= 1; --k2) if (t = i > 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
      if (t > v) break;
      z.push(t);
    }
    2 * z.length < count && (z = ticks5(u, v, count));
  } else z = ticks5(i, j, Math.min(j - i, count)).map(untransformer);
  return z = z.filter((t2) => 0 !== t2), (null == options ? void 0 : options.noDecimals) && (z = Array.from(new Set(z.map((t2) => Math.floor(t2))))), r ? z.reverse() : z;
});
var ticksBaseTransform2 = memoize4((start, stop, count, base, transformer, untransformer) => {
  const ticksResult = [], ticksMap = {}, startExp = transformer(start), stopExp = transformer(stop);
  let ticksExp = [];
  if (Number.isInteger(base)) ticksExp = ticks5(startExp, stopExp, count);
  else {
    const stepExp = (stopExp - startExp) / (count - 1);
    for (let i = 0; i < count; i++) ticksExp.push(startExp + i * stepExp);
  }
  return ticksExp.forEach((tl) => {
    const power = untransformer(tl), nicePower = Number.isInteger(base) ? fixPrecision2(start, stop, power) : fixPrecision2(start, stop, niceNumber2(power)), scopePower = fixPrecision2(start, stop, restrictNumber2(nicePower, [start, stop]));
    !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
  }), ticksResult;
});
var forceTicksBaseTransform2 = memoize4((start, stop, count, transformer, untransformer) => forceTicks2(transformer(start), transformer(stop), count).map((te) => niceNumber2(untransformer(te))));
var forceStepTicksBaseTransform2 = memoize4((start, stop, step, transformer, untransformer) => stepTicks4(transformer(start), transformer(stop), step).map((te) => niceNumber2(untransformer(te))));

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/linear-scale.js
var LinearScale2 = class _LinearScale extends ContinuousScale2 {
  constructor() {
    super(...arguments), this.type = ScaleEnum2.Linear;
  }
  clone() {
    return new _LinearScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate);
  }
  tickFormat() {
    return () => {
    };
  }
  d3Ticks(count = 10, options) {
    const d = this.calculateVisibleDomain(this._range);
    return d3Ticks2(d[0], d[d.length - 1], count, options);
  }
  ticks(count = 10, options) {
    var _a;
    if (isFunction_default4(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
    if (isValid_default4(this._rangeFactorStart) && isValid_default4(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
    let ticksResult = ticks5(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
    if (!ticksResult.length) return ticksResult;
    if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);
    else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
      const newNiceDomain = curNiceDomain.slice();
      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
        const min2 = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max2 = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
        ticksResult = ticksResult.filter((entry) => entry >= min2 && entry <= max2);
      }
    }
    return ticksResult;
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicks2(d[0], d[d.length - 1], count);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks4(d[0], d[d.length - 1], step);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [];
    if (option) {
      const res = parseNiceOptions2(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else this._niceType = "all";
    if (this._niceType) {
      const niceDomain = niceLinear2(originalDomain.slice(), count);
      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
    }
    return this;
  }
  niceMin(count = 10) {
    this._niceType = "min";
    const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear2(this.domain(), count);
    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax(count = 10) {
    this._niceType = "max";
    const minD = this._domain[0], niceDomain = niceLinear2(this._domain.slice(), count);
    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/log-nice-mixin.js
var LogNiceMixin2 = class {
  nice(count = 10, option) {
    var _b, _c, _d, _e;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions2(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else niceType = "all";
    if (niceType) {
      const niceDomain = nice2(originalDomain.slice(), null !== (_c = null === (_b = this.getNiceConfig) || void 0 === _b ? void 0 : _b.call(this)) && void 0 !== _c ? _c : {
        floor: (x) => Math.floor(x),
        ceil: (x) => Math.ceil(x)
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_d = niceMinMax[1]) && void 0 !== _d ? _d : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_e = niceMinMax[0]) && void 0 !== _e ? _e : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/log-scale.js
function reflect2(f) {
  return (x) => -f(-x);
}
function limitPositiveZero2(min2 = Number.EPSILON) {
  return (x) => Math.max(x, min2);
}
function limitNegativeZero2(min2 = Number.EPSILON) {
  return (x) => Math.min(x, -min2);
}
var LogScale2 = class _LogScale extends ContinuousScale2 {
  constructor() {
    super(logp2(10), powp2(10)), this.type = ScaleEnum2.Log, this._limit = limitPositiveZero2(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
  }
  clone() {
    return new _LogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).base(this._base);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    super.rescale();
    const logs = logp2(this._base), pows = powp2(this._base);
    return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect2(logs), this._pows = reflect2(pows), this._limit = limitNegativeZero2(), this.transformer = logNegative2, this.untransformer = expNegative2) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero2(), this.transformer = this._logs, this.untransformer = pows), this;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._limit(this._clamp(x))));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  base(_, slience) {
    return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
  }
  tickFormat() {
    return identity2;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
    return d3TicksForLog2(u, v, count, this._base, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform2(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform2(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform2(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
  }
  getNiceConfig() {
    return {
      floor: (x) => this._pows(Math.floor(this._logs(this._limit(x)))),
      ceil: (x) => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
    };
  }
};
mixin2(LogScale2, LogNiceMixin2);

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/point-scale.js
var PointScale2 = class extends BandScale2 {
  constructor(slience) {
    super(false), this.type = ScaleEnum2.Point, this._padding = 0, this.paddingInner(1, slience), this.padding = this.paddingOuter, this.paddingInner = void 0, this.paddingOuter = void 0;
  }
};

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/symlog-scale.js
var SymlogScale2 = class _SymlogScale extends LinearScale2 {
  constructor() {
    super(symlog2(1), symexp2(1)), this.type = ScaleEnum2.Symlog, this._const = 1;
  }
  clone() {
    return new _SymlogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).constant(this._const);
  }
  constant(_, slience) {
    return arguments.length ? (this._const = _, this.transformer = symlog2(_), this.untransformer = symexp2(_), this.rescale(slience)) : this._const;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = d[0], v = d[d.length - 1];
    return d3TicksForLog2(u, v, count, this._const, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform2(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform2(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform2(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
  }
};
mixin2(SymlogScale2, LogNiceMixin2);

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/time.js
var timeIntervals2 = [["second", 1, SECOND2], ["second", 5, 5 * SECOND2], ["second", 10, 10 * SECOND2], ["second", 30, 30 * SECOND2], ["minute", 1, MINUTE2], ["minute", 5, 5 * MINUTE2], ["minute", 10, 10 * MINUTE2], ["minute", 30, 30 * MINUTE2], ["hour", 1, HOUR4], ["hour", 3, 3 * HOUR4], ["hour", 6, 6 * HOUR4], ["hour", 12, 12 * HOUR4], ["day", 1, DAY4], ["day", 2, 2 * DAY4], ["day", 7, 7 * DAY4], ["month", 1, MONTH4], ["month", 3, 3 * MONTH4], ["month", 6, 6 * MONTH4], ["year", 1, 365 * DAY4]];

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/identity-scale.js
var implicit4 = Symbol("implicit");

// node_modules/@visactor/vtable/node_modules/@visactor/vscale/es/utils/tick-wilkinson-extended.js
var eps2 = 100 * Number.EPSILON;

// node_modules/@visactor/vtable/es/components/axis/band-scale.js
var BandAxisScale = class {
  constructor() {
    this._scale = new BandScale2(), this._scales = [this._scale];
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  getPosition(values) {
    let position = 0, bandScale = this._scale;
    if (1 === this._scales.length || 1 === values.length) position = this.valueToPosition(values[0]);
    else {
      const max2 = Math.min(values.length, this._scales.length);
      for (let i = 0; i < max2; i++) position += this._scales[i].scale(values[i]);
      bandScale = this._scales[max2 - 1];
    }
    return {
      position,
      bandScale
    };
  }
  calcScales(defalutBandInnerPadding, defalutBandOuterPadding) {
    var _a, _b;
    const { bandPadding, paddingInner, paddingOuter } = this, isBandPaddingArray = isArray_default(bandPadding), isPaddingInnerArray = isArray_default(paddingInner), isPaddingOuterArray = isArray_default(paddingOuter);
    for (let i = 0; i < this._scales.length; i++) {
      const _padding = isBandPaddingArray ? bandPadding[i] : bandPadding, _paddingInner = isPaddingInnerArray ? paddingInner[i] : paddingInner, _paddingOuter = isPaddingOuterArray ? paddingOuter[i] : paddingOuter;
      this._scales[i].paddingInner(null !== (_a = null != _paddingInner ? _paddingInner : _padding) && void 0 !== _a ? _a : defalutBandInnerPadding, true).paddingOuter(null !== (_b = null != _paddingOuter ? _paddingOuter : _padding) && void 0 !== _b ? _b : defalutBandOuterPadding);
    }
  }
  dataToPosition(values, cfg = {}) {
    var _a;
    if (0 === values.length || 0 === this._scales.length) return 0;
    const { position, bandScale } = this.getPosition(values);
    return position + bandScale.bandwidth() * (null !== (_a = cfg.bandPosition) && void 0 !== _a ? _a : 0.5);
  }
  updateScaleDomain(domain) {
    for (let i = 0; i < this._scales.length; i++) this._scales[i].domain(domain);
  }
  updateRange(newRange) {
    const [start, end] = this._scale.range();
    newRange[0] === start && newRange[1] === end || this._scale.range(newRange);
  }
};

// node_modules/@visactor/vtable/es/components/util/register.js
function registerDataSetInstanceTransform(dataSet, name, transform) {
  dataSet.getTransform(name) || dataSet.registerTransform(name, transform);
}
function registerDataSetInstanceParser(dataSet, name, parse4) {
  dataSet.getParser(name) || dataSet.registerParser(name, parse4);
}

// node_modules/@visactor/vtable/es/components/axis/linear-scale.js
var e106 = Math.sqrt(50);
var e56 = Math.sqrt(10);
var e26 = Math.sqrt(2);
var LinearAxisScale = class {
  constructor(type) {
    this._extend = {}, this.type = null != type ? type : "linear", this._scale = "log" === type ? new LogScale2() : "symlog" === type ? new SymlogScale2() : new LinearScale2(), this._scales = [this._scale];
  }
  setExtraAttrFromSpec(nice3, zero, range5, expand, base, constant) {
    this.nice = false, this.zero = zero, this.zero && (range5.min = Math.min(range5.min, 0), range5.max = Math.max(range5.max, 0)), this.domain = range5, this.expand = expand, "log" === this.type ? this._scale.base(null != base ? base : 10) : "symlog" === this.type && this._scale.constant(null != constant ? constant : 10);
  }
  transformScaleDomain() {
    "symlog" === this.type || "log" === this.type || this.setScaleNice();
  }
  setScaleNice() {
    "log" === this.type ? this.setLogScaleNice() : this.setLinearScaleNice();
  }
  setLogScaleNice() {
    var _a, _b, _c, _d, _e, _f;
    isNil_default(null === (_a = this.domain) || void 0 === _a ? void 0 : _a.min) && isNil_default(null === (_b = this.domain) || void 0 === _b ? void 0 : _b.max) ? this.nice && this._scale.nice() : isValid_default(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && isNil_default(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this.nice && this._scale.niceMax() : isNil_default(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && isValid_default(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) && this.nice && this._scale.niceMin();
  }
  setLinearScaleNice() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let tickCount = null !== (_b = null !== (_a = this.forceTickCount) && void 0 !== _a ? _a : this.tickCount) && void 0 !== _b ? _b : 10;
    "accurateFirst" === this.niceType && (tickCount = Math.max(10, tickCount)), isNil_default(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && isNil_default(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this.nice && this._scale.nice(tickCount) : isValid_default(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && isNil_default(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) ? this.nice && this._scale.niceMax(tickCount) : isNil_default(null === (_g = this.domain) || void 0 === _g ? void 0 : _g.min) && isValid_default(null === (_h = this.domain) || void 0 === _h ? void 0 : _h.max) ? this.nice && this._scale.niceMin(tickCount) : this.nice && this._scale.nice(tickCount);
  }
  dataToPosition(values) {
    return this.valueToPosition(values[0]);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  computeLinearDomain(data) {
    const domain = [];
    return data.forEach((d) => {
      const { min: min2, max: max2 } = d;
      domain[0] = void 0 === domain[0] ? min2 : Math.min(domain[0], min2), domain[1] = void 0 === domain[1] ? max2 : Math.max(domain[1], max2);
    }), this.expandDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), domain;
  }
  expandDomain(domain) {
    if (!this.expand) return;
    const domainMin = domain[0], domainMax = domain[domain.length - 1];
    isValid_default(this.expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this.expand.min), isValid_default(this.expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this.expand.max);
  }
  niceDomain(domain) {
    if (isValid_default(domain[0]) || isValid_default(domain[1]) || "linear" !== this.type) return domain;
    if (Math.abs(minInArray(domain) - maxInArray(domain)) <= 1e-12) {
      let num = domain[0];
      const flag = num >= 0 ? 1 : -1;
      if (num = Math.abs(num), num < 1) domain[0] = 0, domain[1] = 1;
      else {
        let step = num / 5;
        const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
        step = (err >= e106 ? 10 : err >= e56 ? 5 : err >= e26 ? 2 : 1) * Math.pow(10, power), domain[0] = 0, domain[1] = 10 * step;
      }
      flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
    }
    return domain;
  }
  niceMinMax() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.nice) {
      let tickCount = null !== (_b = null !== (_a = this.forceTickCount) && void 0 !== _a ? _a : this.tickCount) && void 0 !== _b ? _b : 10;
      "accurateFirst" === this.niceType && (tickCount = Math.max(10, tickCount)), isNil_default(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && isNil_default(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this._scale.nice(tickCount) : isValid_default(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && isNil_default(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) ? this._scale.niceMax(tickCount) : isNil_default(null === (_g = this.domain) || void 0 === _g ? void 0 : _g.min) && isValid_default(null === (_h = this.domain) || void 0 === _h ? void 0 : _h.max) ? this._scale.niceMin(tickCount) : this._scale.nice(tickCount);
    }
  }
  includeZero(domain) {
    this.zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
  }
  setExtendDomain(key, value) {
    if (void 0 === value) return void delete this._extend[key];
    this._extend[key] = value;
    const domain = this._scale.domain();
    this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this.nice), this.niceMinMax();
  }
  extendDomain(domain) {
    let temp2;
    const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min2 = reverse ? domainLast : 0, max2 = reverse ? 0 : domainLast;
    for (const key in this._extend) temp2 = this._extend[key], temp2 > domain[max2] && (domain[max2] = temp2), temp2 < domain[min2] && (domain[min2] = temp2);
  }
  setDomainMinMax(domain) {
    if (!this.domain) return;
    const { min: min2, max: max2 } = this.domain;
    isValid_default(min2) && (domain[0] = min2), isValid_default(max2) && (domain[1] = max2);
  }
  setZero(zero) {
    this.zero !== zero && (this.zero = zero, this.updateScaleDomain());
  }
  updateScaleDomain() {
    const domain = this.computeDomain([this.domain]);
    this.updateScaleDomainByModel(domain);
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  updateScaleDomainByModel(domain) {
    domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this.nice), this.niceMinMax();
  }
  updateRange(newRange) {
    const [start, end] = this._scale.range();
    newRange[0] === start && newRange[1] === end || this._scale.range(newRange);
  }
};

// node_modules/@visactor/vtable/es/components/axis/label-overlap.js
function doOverlap(axisComponent, axis) {
  const layer0LabelsContainer = axisComponent.find((node) => "axis-label-container-layer-0" === node.name, true), layer1LabelsContainer = axisComponent.find((node) => "axis-label-container-layer-1" === node.name, true);
  overlap(layer0LabelsContainer ? layer0LabelsContainer.getChildren() : [], axis), overlap(layer1LabelsContainer ? layer1LabelsContainer.getChildren() : [], axis);
}
function labelFlush(axisLabels, axis) {
  const { width, height } = axis.getLayoutRect(), isX = isXAxis2(axis.orient), isInverse = true === axis.option.inverse, first = axisLabels[0], last2 = last(axisLabels);
  if (isX) if (isInverse) {
    const start = width, end = 0, startBound = first.AABBBounds.x2, endBound = last2.AABBBounds.x1;
    startBound > start && first.setAttributes({
      x: start,
      textAlign: "right"
    }), endBound < end && last2.setAttributes({
      x: end,
      textAlign: "left"
    });
  } else {
    const start = 0, end = width, startBound = first.AABBBounds.x1, endBound = last2.AABBBounds.x2;
    startBound < start && first.setAttributes({
      x: start,
      textAlign: "left"
    }), endBound > end && last2.setAttributes({
      x: end,
      textAlign: "right"
    });
  }
  else if (isInverse) {
    const startBound = first.AABBBounds.y1, endBound = last2.AABBBounds.y2, start = 0, end = height;
    startBound < start && first.setAttributes({
      y: start,
      textBaseline: "top"
    }), endBound > end && last2.setAttributes({
      y: end,
      textBaseline: "bottom"
    });
  } else {
    const start = height, end = 0, startBound = first.AABBBounds.y2, endBound = last2.AABBBounds.y1;
    startBound > start && first.setAttributes({
      y: start,
      textBaseline: "bottom"
    }), endBound < end && last2.setAttributes({
      y: end,
      textBaseline: "top"
    });
  }
}
function overlap(axisLabels, axis) {
  var _a;
  const spec = axis.option;
  isEmpty_default(axisLabels) || (null === (_a = null == spec ? void 0 : spec.label) || void 0 === _a ? void 0 : _a.flush) && labelFlush(axisLabels, axis);
}

// node_modules/@visactor/vtable/es/components/axis/axis.js
var scaleParser = (scale6) => scale6;
var CartesianAxis = class {
  constructor(option, width, height, padding, table) {
    var _a, _b, _c;
    if (this.x = 0, this.y = 0, this.padding = padding, this.table = table, this.orient = null !== (_a = option.orient) && void 0 !== _a ? _a : "left", this.type = null !== (_b = option.type) && void 0 !== _b ? _b : "band", this.option = merge({}, getCommonAxis(option.__vtableChartTheme), getTableAxisTheme(this.orient, table.theme), getChartSpecAxisTheme(this.orient, this.type, option.__vtableChartTheme), option), "left" === this.orient || "right" === this.orient) {
      const innerOffsetTop = 0, innerOffsetBottom = 0;
      this.width = width, this.height = height - padding[0] - padding[2] - innerOffsetBottom, this.y = padding[0] + innerOffsetTop;
    } else if ("top" === this.orient || "bottom" === this.orient) {
      const innerOffsetLeft = 0, innerOffsetRight = 0;
      this.width = width - padding[1] - padding[3] - innerOffsetRight, this.height = height, this.x = padding[3] + innerOffsetLeft;
    }
    this.visible = null === (_c = option.visible) || void 0 === _c || _c, this.inverse = "inverse" in option && !!option.inverse, "band" === option.type && (this.data = option.domain), this.initScale(), this.initData(), this.createComponent(), this.initEvent();
  }
  initScale() {
    const option = this.option;
    "band" === this.type || "point" === this.type ? (this.scale = new BandAxisScale(), this.scale.bandPadding = option.bandPadding, this.scale.paddingInner = option.paddingInner, this.scale.paddingOuter = option.paddingOuter, this.scale.calcScales(0.1, 0.3), this.scale.updateScaleDomain(this.data), this.updateScaleRange()) : "linear" !== this.type && "time" !== this.type && "log" !== this.type && "symlog" !== this.type || (this.scale = new LinearAxisScale(this.type), this.scale.setExtraAttrFromSpec(option.nice, option.zero, option.range, option.expand, option.base, option.constant), this.scale.transformScaleDomain(), this.scale.updateScaleDomain(), this.updateScaleRange());
  }
  initData() {
    this.table._vDataSet || (this.table._vDataSet = new DataSet()), registerDataSetInstanceParser(this.table._vDataSet, "scale", scaleParser), registerDataSetInstanceTransform(this.table._vDataSet, "ticks", ticks3);
    const label = this.option.label || {}, tick = this.option.tick || {}, tickData = new DataView(this.table._vDataSet).parse(this.scale._scale, {
      type: "scale"
    }).transform({
      type: "ticks",
      options: {
        sampling: false !== this.option.sampling,
        tickCount: tick.tickCount,
        forceTickCount: tick.forceTickCount,
        tickStep: tick.tickStep,
        tickMode: tick.tickMode,
        noDecimals: tick.noDecimals,
        axisOrientType: this.orient,
        coordinateType: "cartesian",
        labelStyle: label.style,
        labelFormatter: label.formatMethod,
        labelGap: label.minGap,
        labelLastVisible: label.lastVisible,
        labelFlush: label.flush
      }
    }, false);
    this.tickData = tickData, this.computeData();
  }
  computeData() {
    this.tickData.reRunAllTransform();
  }
  initEvent() {
  }
  createComponent() {
    const axisStylrAttrs = getAxisAttributes(this.option), attrs = this.getUpdateAttribute();
    attrs.verticalFactor = "top" === this.orient || "right" === this.orient ? -1 : 1, this.component = new LineAxis(merge({
      disableTriggerEvent: this.table.options.disableInteraction
    }, axisStylrAttrs, attrs)), this.component.setAttributes(this.setLayoutStartPosition({
      x: this.x,
      y: this.y
    })), this.component.originAxis = this;
  }
  resize(width, height) {
    this.width = width - ("top" === this.orient || "bottom" === this.orient ? this.padding[1] + this.padding[3] : 0), this.height = height - ("left" === this.orient || "right" === this.orient ? this.padding[2] + this.padding[0] : 0), this.updateScaleRange(), this.computeData();
    const axisStylrAttrs = getAxisAttributes(this.option), attrs = this.getUpdateAttribute();
    attrs.verticalFactor = "top" === this.orient || "right" === this.orient ? -1 : 1, this.component.setAttributes(merge({}, axisStylrAttrs, attrs)), this.component.setAttributes(this.setLayoutStartPosition({
      x: this.x,
      y: this.y
    })), this.overlap();
  }
  overlap() {
    doOverlap(this.component, this);
  }
  getLayoutRect() {
    return {
      width: this.width,
      height: this.height
    };
  }
  getUpdateAttribute() {
    const regionHeight = this.table.tableNoFrameHeight, regionWidth = this.table.tableNoFrameWidth, { width, height } = this.getLayoutRect(), isX = isXAxis2(this.orient), isY = isYAxis(this.orient);
    let end = {
      x: 0,
      y: 0
    }, gridLength = 0, axisLength = 0;
    isX ? (end = {
      x: width,
      y: 0
    }, gridLength = regionHeight, axisLength = width) : isY && (end = {
      x: 0,
      y: height
    }, gridLength = regionWidth, axisLength = height);
    const size = "top" === this.orient || "bottom" === this.orient ? height : width;
    return {
      start: {
        x: 0,
        y: 0
      },
      end,
      title: {
        text: this.option.title.text,
        maxWidth: this._getTitleLimit(isX)
      },
      items: this.getLabelItems(axisLength),
      verticalLimitSize: size,
      verticalMinSize: size
    };
  }
  getLabelItems(length2) {
    return [this.tickData.latestData.map((obj2) => ({
      id: obj2.value,
      label: obj2.value,
      value: 0 === length2 ? 0 : this.scale.dataToPosition([obj2.value]) / length2,
      rawValue: obj2.value
    })).filter((entry) => entry.value >= 0 && entry.value <= 1)];
  }
  updateScaleRange() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const right = null !== (_b = null === (_a = this.option.innerOffset) || void 0 === _a ? void 0 : _a.right) && void 0 !== _b ? _b : 0, left = null !== (_d = null === (_c = this.option.innerOffset) || void 0 === _c ? void 0 : _c.left) && void 0 !== _d ? _d : 0, top = null !== (_f = null === (_e = this.option.innerOffset) || void 0 === _e ? void 0 : _e.top) && void 0 !== _f ? _f : 0, bottom = null !== (_h = null === (_g = this.option.innerOffset) || void 0 === _g ? void 0 : _g.bottom) && void 0 !== _h ? _h : 0, { width, height } = this.getLayoutRect(), inverse = this.option.inverse || false;
    let newRange = [0, 0];
    isXAxis2(this.orient) ? isValidNumber_default(width) && (newRange = inverse ? [width - right, left] : [left, width - right]) : isValidNumber_default(height) && (newRange = inverse ? [top, height - bottom] : [height - bottom, top]), this.scale.updateRange(newRange);
  }
  setLayoutStartPosition(pos) {
    let { x, y } = pos;
    return isValidNumber_default(x) && (x += Number("left" === this.orient) * this.getLayoutRect().width), isValidNumber_default(y) && (y += Number("top" === this.orient) * this.getLayoutRect().height), {
      x,
      y
    };
  }
  _getTitleLimit(isX) {
    var _a, _b, _c;
    if (this.option.title.visible && isNil_default(null === (_a = this.option.title.style) || void 0 === _a ? void 0 : _a.maxLineWidth)) {
      let angle2 = (null === (_b = this.option.title.style) || void 0 === _b ? void 0 : _b.angle) || 0;
      if ((null === (_c = this.option.title) || void 0 === _c ? void 0 : _c.autoRotate) && isNil_default(this.option.title.angle) && (angle2 = "left" === this.option.orient ? -90 : 90), isX) {
        const width = this.getLayoutRect().width, cosValue = Math.abs(Math.cos(degreeToRadian(angle2)));
        return cosValue < 1e-6 ? 1 / 0 : width / cosValue;
      }
      const height = this.getLayoutRect().height, sinValue = Math.abs(Math.sin(degreeToRadian(angle2)));
      return sinValue < 1e-6 ? 1 / 0 : height / sinValue;
    }
    return null;
  }
  getScale() {
    return this.scale._scale;
  }
  getDomainSpec() {
    return this.scale.domain;
  }
};
function getTableAxisTheme(orient, theme4) {
  let directionStyle;
  return "left" === orient ? directionStyle = theme4.axisStyle.leftAxisStyle : "right" === orient ? directionStyle = theme4.axisStyle.rightAxisStyle : "top" === orient ? directionStyle = theme4.axisStyle.topAxisStyle : "bottom" === orient && (directionStyle = theme4.axisStyle.bottomAxisStyle), merge({}, theme4.axisStyle.defaultAxisStyle, directionStyle);
}
function getChartSpecAxisTheme(orient, type, chartSpecTheme) {
  if (!chartSpecTheme) return {};
  const axisTheme = chartSpecTheme.axis;
  let axisTypeTheme, axisOrientTheme;
  return "linear" === type || "log" === type || "symlog" === type ? axisTypeTheme = chartSpecTheme.axisLinear : "band" === type && (axisTypeTheme = chartSpecTheme.axisBand), "top" === orient || "bottom" === orient ? axisOrientTheme = chartSpecTheme.axisX : "left" !== orient && "right" !== orient || (axisOrientTheme = chartSpecTheme.axisY), merge({}, axisTheme, axisTypeTheme, axisOrientTheme);
}

// node_modules/@visactor/vtable/es/components/axis/get-axis-component-size.js
function computeAxisComponentWidth(config, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const attribute = merge({}, commonAxis, config);
  let tickWidth = 0;
  false !== attribute.tick.visible && (tickWidth = null !== (_a = attribute.tick.width) && void 0 !== _a ? _a : 4);
  let labelWidth = 0;
  if (attribute.label.visible) {
    if ("band" === attribute.type) {
      attribute.domain.forEach((text2) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
        attribute.label.formatMethod && (text2 = attribute.label.formatMethod(text2));
        const { width, height } = table.measureText(text2, {
          fontSize: null !== (_c2 = null === (_b2 = null === (_a2 = attribute.label) || void 0 === _a2 ? void 0 : _a2.style) || void 0 === _b2 ? void 0 : _b2.fontSize) && void 0 !== _c2 ? _c2 : DEFAULT_TEXT_FONT_SIZE2,
          fontWeight: null !== (_f2 = null === (_e2 = null === (_d2 = attribute.label) || void 0 === _d2 ? void 0 : _d2.style) || void 0 === _e2 ? void 0 : _e2.fontWeight) && void 0 !== _f2 ? _f2 : "normal",
          fontFamily: null !== (_j2 = null === (_h2 = null === (_g2 = attribute.label) || void 0 === _g2 ? void 0 : _g2.style) || void 0 === _h2 ? void 0 : _h2.fontFamily) && void 0 !== _j2 ? _j2 : DEFAULT_TEXT_FONT_FAMILY3
        }), widthLimit = (null === (_l2 = null === (_k2 = attribute.label) || void 0 === _k2 ? void 0 : _k2.style) || void 0 === _l2 ? void 0 : _l2.maxLineWidth) || 1 / 0, angel = (null !== (_p2 = null === (_o2 = null === (_m2 = attribute.label) || void 0 === _m2 ? void 0 : _m2.style) || void 0 === _o2 ? void 0 : _o2.angle) && void 0 !== _p2 ? _p2 : 0) + ("vertical" === (null === (_r2 = null === (_q2 = attribute.label) || void 0 === _q2 ? void 0 : _q2.style) || void 0 === _r2 ? void 0 : _r2.direction) ? 90 : 0);
        labelWidth = Math.max(labelWidth, getSizeAfterResize(Math.min(width, widthLimit), height, angel).width);
      });
    } else {
      let ticks6;
      if ((null === (_b = config.sync) || void 0 === _b ? void 0 : _b.tickAlign) && isFunction_default(null === (_c = config.tick) || void 0 === _c ? void 0 : _c.tickMode)) ticks6 = config.tick.tickMode();
      else if (isArray_default(config.__ticksForVTable)) ticks6 = config.__ticksForVTable;
      else {
        const range5 = attribute.range, minNumber = Math.abs(range5.min) > 1 ? Math.round(range5.min) : range5.min, maxNumber = Math.abs(range5.max) > 1 ? Math.round(range5.max) : range5.max;
        ticks6 = [formatDecimal4(minNumber), formatDecimal4(maxNumber)];
      }
      ticks6.forEach((text2) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
        attribute.label.formatMethod && (text2 = attribute.label.formatMethod(text2));
        const { width, height } = table.measureText(text2, {
          fontSize: null !== (_c2 = null === (_b2 = null === (_a2 = attribute.label) || void 0 === _a2 ? void 0 : _a2.style) || void 0 === _b2 ? void 0 : _b2.fontSize) && void 0 !== _c2 ? _c2 : DEFAULT_TEXT_FONT_SIZE2,
          fontWeight: null !== (_f2 = null === (_e2 = null === (_d2 = attribute.label) || void 0 === _d2 ? void 0 : _d2.style) || void 0 === _e2 ? void 0 : _e2.fontWeight) && void 0 !== _f2 ? _f2 : "normal",
          fontFamily: null !== (_j2 = null === (_h2 = null === (_g2 = attribute.label) || void 0 === _g2 ? void 0 : _g2.style) || void 0 === _h2 ? void 0 : _h2.fontFamily) && void 0 !== _j2 ? _j2 : DEFAULT_TEXT_FONT_FAMILY3
        }), widthLimit = (null === (_l2 = null === (_k2 = attribute.label) || void 0 === _k2 ? void 0 : _k2.style) || void 0 === _l2 ? void 0 : _l2.maxLineWidth) || 1 / 0, angle2 = (null !== (_p2 = null === (_o2 = null === (_m2 = attribute.label) || void 0 === _m2 ? void 0 : _m2.style) || void 0 === _o2 ? void 0 : _o2.angle) && void 0 !== _p2 ? _p2 : 0) + ("vertical" === (null === (_r2 = null === (_q2 = attribute.label) || void 0 === _q2 ? void 0 : _q2.style) || void 0 === _r2 ? void 0 : _r2.direction) ? 90 : 0);
        labelWidth = Math.max(labelWidth, getSizeAfterResize(Math.min(width, widthLimit), height, angle2).width);
      });
    }
    labelWidth += null !== (_d = attribute.label.space) && void 0 !== _d ? _d : 4;
  }
  let titleWidth = 0;
  if (attribute.title.visible && isString_default(attribute.title.text)) {
    const { width, height } = table.measureText(attribute.title.text, {
      fontSize: null !== (_g = null === (_f = null === (_e = attribute.title) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.fontSize) && void 0 !== _g ? _g : DEFAULT_TEXT_FONT_SIZE2,
      fontWeight: null !== (_k = null === (_j = null === (_h = attribute.title) || void 0 === _h ? void 0 : _h.style) || void 0 === _j ? void 0 : _j.fontWeight) && void 0 !== _k ? _k : "normal",
      fontFamily: null !== (_o = null === (_m = null === (_l = attribute.title) || void 0 === _l ? void 0 : _l.style) || void 0 === _m ? void 0 : _m.fontFamily) && void 0 !== _o ? _o : DEFAULT_TEXT_FONT_FAMILY3
    }), widthLimit = (null === (_q = null === (_p = attribute.label) || void 0 === _p ? void 0 : _p.style) || void 0 === _q ? void 0 : _q.maxLineWidth) || 1 / 0, size = getSizeAfterResize(Math.min(width, widthLimit), height, null === (_s = null === (_r = attribute.title) || void 0 === _r ? void 0 : _r.style) || void 0 === _s ? void 0 : _s.angle);
    titleWidth = "left" !== config.orient && "right" !== config.orient || !attribute.title.autoRotate ? size.width : size.height, titleWidth += null !== (_t = attribute.title.space) && void 0 !== _t ? _t : 4;
  }
  return Math.ceil(tickWidth + labelWidth + titleWidth + 1);
}
function computeAxisComponentHeight(config, table) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const attribute = merge({}, commonAxis, config);
  let tickHeight = 0;
  false !== attribute.tick.visible && (tickHeight = null !== (_a = attribute.tick.width) && void 0 !== _a ? _a : 4);
  let labelHeight = 0;
  if (attribute.label.visible) {
    if ("band" === attribute.type) {
      attribute.domain.forEach((text2) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
        attribute.label.formatMethod && (text2 = attribute.label.formatMethod(text2));
        const { width, height } = table.measureText(text2, {
          fontSize: null !== (_c2 = null === (_b2 = null === (_a2 = attribute.label) || void 0 === _a2 ? void 0 : _a2.style) || void 0 === _b2 ? void 0 : _b2.fontSize) && void 0 !== _c2 ? _c2 : DEFAULT_TEXT_FONT_SIZE2,
          fontWeight: null !== (_f2 = null === (_e2 = null === (_d2 = attribute.label) || void 0 === _d2 ? void 0 : _d2.style) || void 0 === _e2 ? void 0 : _e2.fontWeight) && void 0 !== _f2 ? _f2 : "normal",
          fontFamily: null !== (_j2 = null === (_h2 = null === (_g2 = attribute.label) || void 0 === _g2 ? void 0 : _g2.style) || void 0 === _h2 ? void 0 : _h2.fontFamily) && void 0 !== _j2 ? _j2 : DEFAULT_TEXT_FONT_FAMILY3
        }), widthLimit = (null === (_l2 = null === (_k2 = attribute.label) || void 0 === _k2 ? void 0 : _k2.style) || void 0 === _l2 ? void 0 : _l2.maxLineWidth) || 1 / 0, angle2 = (null !== (_p2 = null === (_o2 = null === (_m2 = attribute.label) || void 0 === _m2 ? void 0 : _m2.style) || void 0 === _o2 ? void 0 : _o2.angle) && void 0 !== _p2 ? _p2 : 0) + ("vertical" === (null === (_r2 = null === (_q2 = attribute.label) || void 0 === _q2 ? void 0 : _q2.style) || void 0 === _r2 ? void 0 : _r2.direction) ? 90 : 0);
        labelHeight = Math.max(labelHeight, getSizeAfterResize(Math.min(width, widthLimit), height, angle2).height);
      });
    } else {
      let ticks6;
      if ((null === (_b = config.sync) || void 0 === _b ? void 0 : _b.tickAlign) && isFunction_default(null === (_c = config.tick) || void 0 === _c ? void 0 : _c.tickMode)) ticks6 = config.tick.tickMode();
      else if (isArray_default(config.__ticksForVTable)) ticks6 = config.__ticksForVTable;
      else {
        const range5 = attribute.range, minNumber = Math.abs(range5.min) > 1 ? Math.round(range5.min) : range5.min, maxNumber = Math.abs(range5.max) > 1 ? Math.round(range5.max) : range5.max;
        ticks6 = [formatDecimal4(minNumber), formatDecimal4(maxNumber)];
      }
      ticks6.forEach((text2) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
        attribute.label.formatMethod && (text2 = attribute.label.formatMethod(text2));
        const { width, height } = table.measureText(text2, {
          fontSize: null !== (_c2 = null === (_b2 = null === (_a2 = attribute.label) || void 0 === _a2 ? void 0 : _a2.style) || void 0 === _b2 ? void 0 : _b2.fontSize) && void 0 !== _c2 ? _c2 : DEFAULT_TEXT_FONT_SIZE2,
          fontWeight: null !== (_f2 = null === (_e2 = null === (_d2 = attribute.label) || void 0 === _d2 ? void 0 : _d2.style) || void 0 === _e2 ? void 0 : _e2.fontWeight) && void 0 !== _f2 ? _f2 : "normal",
          fontFamily: null !== (_j2 = null === (_h2 = null === (_g2 = attribute.label) || void 0 === _g2 ? void 0 : _g2.style) || void 0 === _h2 ? void 0 : _h2.fontFamily) && void 0 !== _j2 ? _j2 : DEFAULT_TEXT_FONT_FAMILY3
        }), widthLimit = (null === (_l2 = null === (_k2 = attribute.label) || void 0 === _k2 ? void 0 : _k2.style) || void 0 === _l2 ? void 0 : _l2.maxLineWidth) || 1 / 0, angle2 = (null !== (_p2 = null === (_o2 = null === (_m2 = attribute.label) || void 0 === _m2 ? void 0 : _m2.style) || void 0 === _o2 ? void 0 : _o2.angle) && void 0 !== _p2 ? _p2 : 0) + ("vertical" === (null === (_r2 = null === (_q2 = attribute.label) || void 0 === _q2 ? void 0 : _q2.style) || void 0 === _r2 ? void 0 : _r2.direction) ? 90 : 0);
        labelHeight = Math.max(labelHeight, getSizeAfterResize(Math.min(width, widthLimit), height, angle2).height);
      });
    }
    labelHeight += null !== (_d = attribute.label.space) && void 0 !== _d ? _d : 4;
  }
  let titleHeight = 0;
  if (attribute.title.visible && attribute.title.text) {
    const { width, height } = table.measureText(attribute.title.text, {
      fontSize: null !== (_g = null === (_f = null === (_e = attribute.title) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.fontSize) && void 0 !== _g ? _g : DEFAULT_TEXT_FONT_SIZE2,
      fontWeight: null !== (_k = null === (_j = null === (_h = attribute.title) || void 0 === _h ? void 0 : _h.style) || void 0 === _j ? void 0 : _j.fontWeight) && void 0 !== _k ? _k : "normal",
      fontFamily: null !== (_o = null === (_m = null === (_l = attribute.title) || void 0 === _l ? void 0 : _l.style) || void 0 === _m ? void 0 : _m.fontFamily) && void 0 !== _o ? _o : DEFAULT_TEXT_FONT_FAMILY3
    }), widthLimit = (null === (_q = null === (_p = attribute.label) || void 0 === _p ? void 0 : _p.style) || void 0 === _q ? void 0 : _q.maxLineWidth) || 1 / 0, size = getSizeAfterResize(Math.min(width, widthLimit), height, null === (_s = null === (_r = attribute.title) || void 0 === _r ? void 0 : _r.style) || void 0 === _s ? void 0 : _s.angle);
    titleHeight = "bottom" !== config.orient && "top" !== config.orient || !attribute.title.autoRotate ? size.height : size.width, titleHeight += null !== (_t = attribute.title.space) && void 0 !== _t ? _t : 4;
  }
  return tickHeight + labelHeight + titleHeight + 1;
}
function formatDecimal4(number) {
  return "number" != typeof number && (number = Number(number)), Number(number.toPrecision(1)).toString();
}
function getSizeAfterResize(width, height, angle2 = 0) {
  const theta = angle2 * Math.PI / 180, p1_x = -width / 2, p1_y = -height / 2, p2_x = width / 2, p2_y = -height / 2, p3_x = width / 2, p3_y = height / 2, p4_x = -width / 2, p4_y = height / 2, p1Rotated = {
    x: p1_x * Math.cos(theta) - p1_y * Math.sin(theta),
    y: p1_x * Math.sin(theta) + p1_y * Math.cos(theta)
  }, p2Rotated = {
    x: p2_x * Math.cos(theta) - p2_y * Math.sin(theta),
    y: p2_x * Math.sin(theta) + p2_y * Math.cos(theta)
  }, p3Rotated = {
    x: p3_x * Math.cos(theta) - p3_y * Math.sin(theta),
    y: p3_x * Math.sin(theta) + p3_y * Math.cos(theta)
  }, p4Rotated = {
    x: p4_x * Math.cos(theta) - p4_y * Math.sin(theta),
    y: p4_x * Math.sin(theta) + p4_y * Math.cos(theta)
  }, bounds_minX = Math.min(p1Rotated.x, p2Rotated.x, p3Rotated.x, p4Rotated.x), bounds_maxX = Math.max(p1Rotated.x, p2Rotated.x, p3Rotated.x, p4Rotated.x), bounds_minY = Math.min(p1Rotated.y, p2Rotated.y, p3Rotated.y, p4Rotated.y);
  return {
    width: bounds_maxX - bounds_minX,
    height: Math.max(p1Rotated.y, p2Rotated.y, p3Rotated.y, p4Rotated.y) - bounds_minY
  };
}

// node_modules/@visactor/vtable/es/components/empty-tip/empty-tip.js
var emptyTipSvg2 = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
var EmptyTip2 = class {
  constructor(emptyTipOption, table) {
    this._emptyTipOption = {
      spaceBetweenTextAndIcon: 20,
      text: "no data",
      textStyle: {
        fontSize: 14,
        color: "#000"
      },
      icon: {
        image: emptyTipSvg2,
        width: 100,
        height: 100
      }
    }, this.isReleased = false, this.table = table, this._emptyTipOption = Object.assign(this._emptyTipOption, true === emptyTipOption ? {} : emptyTipOption), isValid_default(this._emptyTipOption.displayMode) || (this.table.isListTable() ? this._emptyTipOption.displayMode = "basedOnTable" : this._emptyTipOption.displayMode = "basedOnContainer"), this._emptyTipComponent = this._createOrUpdateEmptyTipComponent(this._getEmptyTipAttrs());
  }
  _createOrUpdateEmptyTipComponent(attrs) {
    if (this._emptyTipComponent) isEqual(attrs, this._cacheAttrs) || this._emptyTipComponent.setAttributes(attrs);
    else {
      const emptyTip = new EmptyTip(attrs);
      emptyTip.name = "emptyTip", this.table.scenegraph.stage.defaultLayer.appendChild(emptyTip), this._emptyTipComponent = emptyTip, this.bindEvents();
    }
    return this._emptyTipComponent;
  }
  bindEvents() {
    this._emptyTipComponent.on("click", (e) => {
      const bounds = new AABBBounds();
      this._emptyTipComponent.forEachChildren((child) => {
        bounds.union(child.globalAABBBounds);
      }), bounds.contains(e.x, e.y) && this.table.fireListeners("empty_tip_click", e);
    }), this._emptyTipComponent.on("dblclick", (e) => {
      const bounds = new AABBBounds();
      this._emptyTipComponent.forEachChildren((child) => {
        bounds.union(child.globalAABBBounds);
      }), bounds.contains(e.x, e.y) && this.table.fireListeners("empty_tip_dblclick", e);
    });
  }
  resize() {
    var _a;
    if (!this._emptyTipComponent) return;
    const { leftHeaderWidth, topHeaderHeight, width, height } = this.getWidthAndHeight();
    this._emptyTipComponent.setAttributes({
      spaceBetweenTextAndIcon: this._emptyTipOption.spaceBetweenTextAndIcon,
      x: this.table.tableX + leftHeaderWidth,
      y: this.table.tableY + topHeaderHeight,
      width,
      height,
      text: Object.assign(Object.assign({
        text: this._emptyTipOption.text
      }, this._emptyTipOption.textStyle), {
        fill: null === (_a = this._emptyTipOption.textStyle) || void 0 === _a ? void 0 : _a.color
      }),
      icon: Object.assign({}, this._emptyTipOption.icon)
    });
  }
  release() {
    this._emptyTipComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this._emptyTipComponent), this._emptyTipComponent = null, this.isReleased = true;
  }
  resetVisible() {
    (this.table.recordsCount && 0 !== this.table.recordsCount || this.table.internalProps.layoutMap.rowCount !== this.table.internalProps.layoutMap.columnHeaderLevelCount) && this.table.internalProps.layoutMap.colCount !== this.table.internalProps.layoutMap.rowHeaderLevelCount ? this.table.scenegraph.stage.defaultLayer.children.includes(this._emptyTipComponent) && this.table.scenegraph.stage.defaultLayer.removeChild(this._emptyTipComponent) : this.table.scenegraph.stage.defaultLayer.children.includes(this._emptyTipComponent) || this.table.scenegraph.stage.defaultLayer.appendChild(this._emptyTipComponent);
  }
  getWidthAndHeight() {
    const leftHeaderWidth = this.table.transpose || false === this.table.options.indicatorsAsCol ? this.table.getFrozenColsWidth() : 0, topHeaderHeight = !this.table.transpose || this.table.options.indicatorsAsCol ? this.table.getFrozenRowsHeight() : 0;
    return {
      leftHeaderWidth,
      topHeaderHeight,
      width: ("basedOnContainer" !== this._emptyTipOption.displayMode && this.table.columnHeaderLevelCount > 0 && this.table.colCount > this.table.rowHeaderLevelCount ? this.table.getDrawRange().width : this.table.tableNoFrameWidth) - leftHeaderWidth - this.table.getTheme().scrollStyle.width,
      height: ("basedOnContainer" !== this._emptyTipOption.displayMode && this.table.rowHeaderLevelCount > 0 && this.table.rowCount > this.table.columnHeaderLevelCount ? this.table.getDrawRange().height : this.table.tableNoFrameHeight) - topHeaderHeight - this.table.getTheme().scrollStyle.width
    };
  }
  _getEmptyTipAttrs() {
    var _a;
    const { leftHeaderWidth, topHeaderHeight, width, height } = this.getWidthAndHeight();
    return {
      spaceBetweenTextAndIcon: this._emptyTipOption.spaceBetweenTextAndIcon,
      x: this.table.tableX + leftHeaderWidth,
      y: this.table.tableY + topHeaderHeight,
      width,
      height,
      text: Object.assign(Object.assign({
        text: this._emptyTipOption.text
      }, this._emptyTipOption.textStyle), {
        fill: null === (_a = this._emptyTipOption.textStyle) || void 0 === _a ? void 0 : _a.color
      }),
      icon: Object.assign({}, this._emptyTipOption.icon)
    };
  }
};

// node_modules/@visactor/vtable/es/components/legend/discrete-legend/get-discrete-legend-attributes.js
var __rest15 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var defaultLegendSpec = {
  orient: "bottom",
  position: "middle",
  padding: 30,
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: 14,
      fill: "#000000",
      fontWeight: "normal"
    },
    space: 12
  },
  item: {
    visible: true,
    spaceCol: 10,
    spaceRow: 10,
    padding: 2,
    background: {
      state: {
        selectedHover: {
          fill: "gray",
          fillOpacity: 0.7
        },
        unSelectedHover: {
          fill: "gray",
          fillOpacity: 0.2
        }
      }
    },
    shape: {
      space: 4,
      state: {
        unSelected: {
          fillOpacity: 0.5
        }
      }
    },
    label: {
      space: 4,
      style: {
        fill: "#89909D",
        fontSize: 14
      },
      state: {
        unSelected: {
          fillOpacity: 0.5
        }
      }
    }
  },
  allowAllCanceled: true,
  visible: true
};
function getLegendAttributes(spec, rect) {
  const _a = merge({}, defaultLegendSpec, spec), { title = {}, item = {}, pager = {}, background = {}, type, id, visible, orient, position, data, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = _a, attrs = __rest15(_a, ["title", "item", "pager", "background", "type", "id", "visible", "orient", "position", "data", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title.visible && (attrs.title = transformLegendTitleAttributes(title)), isEmpty_default(item.focusIconStyle) || transformToGraphic(item.focusIconStyle), transformComponentStyle(item.shape), transformComponentStyle(item.label), transformComponentStyle(item.value), transformComponentStyle(item.background), isPercent(item.maxWidth) && (item.maxWidth = Number(item.maxWidth.substring(0, item.maxWidth.length - 1)) * rect.width / 100), isPercent(item.width) && (item.width = Number(item.width.substring(0, item.width.length - 1)) * rect.width / 100), isPercent(item.height) && (item.height = Number(item.height.substring(0, item.height.length - 1)) * rect.width / 100), attrs.item = item, isEmpty_default(pager.textStyle) || transformToGraphic(pager.textStyle), transformComponentStyle(pager.handler), attrs.pager = pager, background.visible && !isEmpty_default(background.style) && (merge(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}

// node_modules/@visactor/vtable/es/components/legend/discrete-legend/discrete-legend.js
var DiscreteTableLegend = class {
  constructor(option, table) {
    var _a, _b, _c, _d;
    this.table = table, this.option = cloneDeep(option), this.orient = null !== (_a = option.orient) && void 0 !== _a ? _a : "left", this.visible = null === (_b = option.visible) || void 0 === _b || _b, this.position = null !== (_c = option.position) && void 0 !== _c ? _c : "middle", this.selectedData = null !== (_d = option.defaultSelected) && void 0 !== _d ? _d : null, this.createComponent(), this.initEvent();
  }
  createComponent() {
    const attrs = this.getLegendAttributes({
      width: this.table.tableNoFrameWidth,
      height: this.table.tableNoFrameHeight
    }), legend = new DiscreteLegend(merge({}, attrs, {
      defaultSelected: this.selectedData,
      disableTriggerEvent: this.table.options.disableInteraction
    }));
    legend.name = "legend", this.legendComponent = legend, false === this.visible && (legend.setAttributes({
      visible: false,
      visibleAll: false
    }), legend.hideAll()), this.table.scenegraph.stage.defaultLayer.appendChild(legend), this.adjustTableSize(attrs);
  }
  resize() {
    this.legendComponent && false !== this.visible && (this.legendComponent.setAttributes({
      maxWidth: this.table.tableNoFrameWidth,
      maxHeight: this.table.tableNoFrameHeight
    }), this.adjustTableSize(this.legendComponent.attribute));
  }
  adjustTableSize(attrs) {
    var _a, _b;
    if (!this.legendComponent || false === this.visible) return;
    let width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0, height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
    if (width <= 0 || height <= 0) return;
    const rectWidth = this.table.tableNoFrameWidth, rectHeight = this.table.tableNoFrameHeight, padding = getQuadProps(null !== (_b = null !== (_a = attrs.padding) && void 0 !== _a ? _a : this.option.padding) && void 0 !== _b ? _b : 10);
    let x = 0, y = 0;
    "left" === this.orient ? (x = padding[3], y = 0, width += padding[1] + padding[3]) : "top" === this.orient ? (x = 0, y = padding[0], height += padding[0] + padding[2]) : "right" === this.orient ? (x = rectWidth - width - padding[1], y = 0, width += padding[1] + padding[3]) : "bottom" === this.orient && (x = 0, y = rectHeight - height - padding[2], height += padding[0] + padding[2]);
    const layout = "bottom" === this.orient || "top" === this.orient ? "horizontal" : "vertical", position = this.position;
    let offsetX = 0, offsetY = 0;
    "horizontal" === layout ? offsetX = "middle" === position ? (rectWidth - width) / 2 : "end" === position ? rectWidth - width - padding[1] : padding[3] : offsetY = "middle" === position ? (rectHeight - height) / 2 : "end" === position ? rectHeight - height - padding[2] : padding[0], this.legendComponent.setAttributes({
      dx: offsetX,
      dy: offsetY,
      x,
      y
    }), "left" === this.orient ? (this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width), this.table.tableX += Math.ceil(width)) : "top" === this.orient ? (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height), this.table.tableY += Math.ceil(height)) : "right" === this.orient ? this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width) : "bottom" === this.orient && (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height));
  }
  getLegendAttributes(rect) {
    var _a, _b;
    const layout = "bottom" === this.orient || "top" === this.orient ? "horizontal" : "vertical", legendAttrs = getLegendAttributes(this.option, rect), padding = getQuadProps(null !== (_b = null !== (_a = legendAttrs.padding) && void 0 !== _a ? _a : this.option.padding) && void 0 !== _b ? _b : 10);
    return Object.assign({
      layout,
      items: this.getLegendItems(),
      maxWidth: rect.width - padding[1] - padding[3],
      maxHeight: rect.height - padding[0] - padding[2]
    }, legendAttrs);
  }
  getLegendItems() {
    return this.option.data;
  }
  initEvent() {
    this.legendComponent && (this.legendComponent.addEventListener(LegendEvent.legendItemClick, (e) => {
      const selectedData = get_default(e, "detail.currentSelected");
      this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_CLICK, {
        model: this,
        value: selectedData,
        event: e
      });
    }), this.legendComponent.addEventListener(LegendEvent.legendItemHover, (e) => {
      const detail = get_default(e, "detail");
      this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_HOVER, {
        model: this,
        value: detail,
        event: e
      });
    }), this.legendComponent.addEventListener(LegendEvent.legendItemUnHover, (e) => {
      const detail = get_default(e, "detail");
      this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_UNHOVER, {
        model: this,
        value: detail,
        event: e
      });
    }), this.legendComponent.addEventListener("legendItemAttributeUpdate", (e) => {
      this.table.scenegraph.updateNextFrame();
    }));
  }
  getLegendBounds() {
    return {
      width: isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0,
      height: isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0
    };
  }
  release() {
    this.legendComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this.legendComponent), this.legendComponent = null;
  }
};

// node_modules/@visactor/vtable/es/components/legend/continue-legend/get-continue-legend-attributes.js
var __rest16 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var defaultContinueLegendSpec = {
  orient: "right",
  position: "middle",
  padding: 30,
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: 14,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "titleFontColor"
      }
    },
    space: 12
  },
  handler: {
    visible: true
  },
  startText: {
    style: {
      fontSize: 14,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "labelFontColor"
      }
    }
  },
  endText: {
    style: {
      fontSize: 14,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "labelFontColor"
      }
    }
  },
  handlerText: {
    style: {
      fontSize: 14,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "labelFontColor"
      }
    }
  }
};
var defaultColorLegendSpec = {
  horizontal: Object.assign(Object.assign({}, defaultContinueLegendSpec), {
    rail: {
      width: 200,
      height: 8,
      style: {
        fill: "rgba(0,0,0,0.04)"
      }
    }
  }),
  vertical: Object.assign(Object.assign({}, defaultContinueLegendSpec), {
    rail: {
      width: 8,
      height: 200,
      style: {
        fill: "rgba(0,0,0,0.04)"
      }
    }
  })
};
var defaultSizeLegendSpec = {
  horizontal: Object.assign({
    sizeBackground: {
      fill: "#cdcdcd"
    },
    track: {
      style: {
        fill: "rgba(20,20,20,0.1)"
      }
    },
    rail: {
      width: 200,
      height: 4,
      style: {
        fill: "rgba(0,0,0,0.04)"
      }
    }
  }, defaultContinueLegendSpec),
  vertical: Object.assign({
    sizeBackground: {
      fill: "#cdcdcd"
    },
    track: {
      style: {
        fill: "rgba(20,20,20,0.1)"
      }
    },
    rail: {
      width: 4,
      height: 200,
      style: {
        fill: "rgba(0,0,0,0.04)"
      }
    }
  }, defaultContinueLegendSpec)
};
function getContinuousLegendAttributes(spec, rect) {
  const _a = merge({}, ("color" === spec.type ? defaultColorLegendSpec : defaultSizeLegendSpec)["bottom" === spec.orient || "top" === spec.orient ? "horizontal" : "vertical"], spec), { title = {}, handler = {}, rail = {}, track = {}, startText, endText, handlerText, sizeBackground, background = {}, type, id, visible, orient, position, data, defaultSelected, field, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = _a, attrs = __rest16(_a, ["title", "handler", "rail", "track", "startText", "endText", "handlerText", "sizeBackground", "background", "type", "id", "visible", "orient", "position", "data", "defaultSelected", "field", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title.visible && (attrs.title = transformLegendTitleAttributes(title)), attrs.showHandler = false !== handler.visible, isEmpty_default(handler.style) || (attrs.handlerStyle = transformToGraphic(handler.style)), isValid_default(rail.width) && (attrs.railWidth = rail.width), isValid_default(rail.height) && (attrs.railHeight = rail.height), isEmpty_default(rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(track.style) || (attrs.trackStyle = transformToGraphic(track.style)), attrs.startText = transformComponentStyle(startText), attrs.endText = transformComponentStyle(endText), attrs.handlerText = transformComponentStyle(handlerText), isEmpty_default(sizeBackground) || (attrs.sizeBackground = transformToGraphic(sizeBackground)), background.visible && !isEmpty_default(background.style) && (merge(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}

// node_modules/@visactor/vtable/es/components/legend/continue-legend/continue-legend.js
var ContinueTableLegend = class {
  constructor(option, table) {
    var _a, _b, _c, _d;
    this.table = table, this.option = cloneDeep(option), this.orient = null !== (_a = option.orient) && void 0 !== _a ? _a : "left", this.visible = null === (_b = option.visible) || void 0 === _b || _b, this.position = null !== (_c = option.position) && void 0 !== _c ? _c : "middle", this.selectedData = null !== (_d = option.defaultSelected) && void 0 !== _d ? _d : null, this.createComponent(), this.initEvent();
  }
  createComponent() {
    const attrs = this.getLegendAttributes({
      width: this.table.tableNoFrameWidth,
      height: this.table.tableNoFrameHeight
    });
    let legend;
    legend = "color" === this.option.type ? new ColorContinuousLegend(merge({}, attrs, {
      slidable: true
    })) : new SizeContinuousLegend(merge({}, attrs, {
      slidable: true
    })), legend.name = "legend", this.legendComponent = legend, false === this.visible && (legend.setAttributes({
      visible: false,
      visibleAll: false
    }), legend.hideAll()), this.table.scenegraph.stage.defaultLayer.appendChild(legend), this.adjustTableSize(attrs);
  }
  resize() {
    this.legendComponent && false !== this.visible && (this.legendComponent.setAttributes({
      width: this.table.tableNoFrameWidth,
      height: this.table.tableNoFrameHeight
    }), this.adjustTableSize(this.legendComponent.attribute));
  }
  adjustTableSize(attrs) {
    var _a, _b;
    if (!this.legendComponent || false === this.visible) return;
    let width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0, height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
    if (width <= 0 || height <= 0) return;
    const rectWidth = this.table.tableNoFrameWidth, rectHeight = this.table.tableNoFrameHeight, padding = getQuadProps(null !== (_b = null !== (_a = attrs.padding) && void 0 !== _a ? _a : this.option.padding) && void 0 !== _b ? _b : 10);
    let x = 0, y = 0;
    "left" === this.orient ? (x = padding[3], y = 0, width += padding[1] + padding[3]) : "top" === this.orient ? (x = 0, y = padding[0], height += padding[0] + padding[2]) : "right" === this.orient ? (x = rectWidth - width - padding[1], y = 0, width += padding[1] + padding[3]) : "bottom" === this.orient && (x = 0, y = rectHeight - height - padding[2], height += padding[0] + padding[2]);
    const layout = "bottom" === this.orient || "top" === this.orient ? "horizontal" : "vertical", position = this.position;
    let offsetX = 0, offsetY = 0;
    "horizontal" === layout ? offsetX = "middle" === position ? (rectWidth - width) / 2 : "end" === position ? rectWidth - width - padding[1] : padding[3] : offsetY = "middle" === position ? (rectHeight - height) / 2 : "end" === position ? rectHeight - height - padding[2] : padding[0], this.legendComponent.setAttributes({
      dx: offsetX,
      dy: offsetY,
      x,
      y
    }), "left" === this.orient ? (this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width), this.table.tableX += Math.ceil(width)) : "top" === this.orient ? (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height), this.table.tableY += Math.ceil(height)) : "right" === this.orient ? this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width) : "bottom" === this.orient && (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height));
  }
  getLegendAttributes(rect) {
    const layout = "bottom" === this.orient || "top" === this.orient ? "horizontal" : "vertical", align = "horizontal" === layout ? "bottom" : this.orient;
    return Object.assign(Object.assign({}, getContinuousLegendAttributes(this.option, rect)), {
      layout,
      align,
      min: this.option.min,
      max: this.option.max,
      value: this.option.value,
      ["color" === this.option.type ? "colors" : "sizeRange"]: "color" === this.option.type ? this.option.colors : this.option.sizeRange
    });
  }
  initEvent() {
    this.legendComponent && this.legendComponent.addEventListener("change", (e) => {
      const selectedData = get_default(e, "detail.value");
      this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_CHANGE, {
        model: this,
        value: selectedData,
        event: e
      }), this.table.scenegraph.updateNextFrame();
    });
  }
  getLegendBounds() {
    return {
      width: isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0,
      height: isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0
    };
  }
  release() {
    this.legendComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this.legendComponent), this.legendComponent = null;
  }
};

// node_modules/@visactor/vtable/es/components/legend/create-legend.js
function createLegend(option, table) {
  return "color" === option.type || "size" === option.type ? new ContinueTableLegend(option, table) : new DiscreteTableLegend(option, table);
}

// node_modules/@visactor/vtable/es/components/menu/dom/BaseMenu.js
var BaseMenu = class {
  constructor(table) {
    this._table = table;
  }
  release() {
    this.unbindMenuElement(), this._menuElement && this._menuElement.release(), this._menuElement = void 0;
  }
  _getMenuElement() {
    return this._menuElement || (this._menuElement = this.createMenuElementInternal()), this._menuElement;
  }
  bindMenuElement(col, row, menuInstanceInfo) {
    return this._getMenuElement().bindToCell(this._table, col, row, menuInstanceInfo);
  }
  unbindMenuElement() {
    this._getMenuElement().unbindFromCell();
  }
  pointInMenuElement(x, y) {
    return this._getMenuElement().pointInMenuElement(x, y);
  }
  getRootElement() {
    return this._getMenuElement().rootElement;
  }
};

// node_modules/@visactor/vtable/es/components/menu/dom/logic/MenuContainer.js
var CLASSNAME2 = "vtable__menu-element";
var HIDDEN_CLASSNAME2 = `${CLASSNAME2}--hidden`;
var SHOWN_CLASSNAME2 = `${CLASSNAME2}--shown`;
function createMenuDomElement2() {
  return createElement("div", [CLASSNAME2, HIDDEN_CLASSNAME2]);
}
var MenuContainer = class {
  constructor(table) {
    var _a, _b, _c;
    this._handler = new EventHandler(), this._rootElement = createMenuDomElement2(), this._rootElement.addEventListener("wheel", (e) => {
      e.stopPropagation();
    }), null === (_a = this._rootElement) || void 0 === _a || _a.addEventListener("mousedown", (e) => {
      e.stopPropagation(), e.preventDefault();
    }), null === (_b = this._rootElement) || void 0 === _b || _b.addEventListener("click", (e) => {
      if (e.stopPropagation(), e.preventDefault(), this._rootElement.classList.contains(HIDDEN_CLASSNAME2)) return;
      const { col, row, dropDownIndex, menuKey, text: text2, hasChildren } = e.target;
      if ("number" != typeof dropDownIndex || hasChildren) return void e.stopPropagation();
      const field = table.isPivotTable() ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row) : table.getHeaderField(col, row), highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
      table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
        col,
        row,
        field,
        menuKey,
        text: text2,
        highlight,
        cellLocation: table.getCellLocation(col, row),
        event: e
      }), table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null), e.stopPropagation();
    }), null === (_c = this._rootElement) || void 0 === _c || _c.addEventListener("mousemove", (e) => {
      this._rootElement.classList.contains(HIDDEN_CLASSNAME2) || e.stopPropagation();
    });
  }
  get rootElement() {
    return this._rootElement;
  }
  release() {
    this.unbindFromCell();
    const rootElement = this._rootElement;
    (null == rootElement ? void 0 : rootElement.parentElement) && rootElement.parentElement.removeChild(rootElement), this._handler.release(), delete this._rootElement;
  }
  bindToCell(table, col, row, menuInstanceInfo) {
    const rootElement = this._rootElement;
    if (this._menuInstanceInfo = menuInstanceInfo, null == rootElement || rootElement.classList.remove(SHOWN_CLASSNAME2), null == rootElement || rootElement.classList.add(HIDDEN_CLASSNAME2), this._canBindToCell(table, col, row)) {
      rootElement.innerHTML = "", rootElement.appendChild(menuInstanceInfo.content);
      if (this._bindCell(table, col, row, menuInstanceInfo.position, menuInstanceInfo.referencePosition)) return null == rootElement || rootElement.classList.add(SHOWN_CLASSNAME2), null == rootElement || rootElement.classList.remove(HIDDEN_CLASSNAME2), true;
    } else this.unbindFromCell();
    return false;
  }
  unbindFromCell() {
    const rootElement = this._rootElement;
    this._menuInstanceInfo = void 0, (null == rootElement ? void 0 : rootElement.parentElement) && (rootElement.classList.remove(SHOWN_CLASSNAME2), rootElement.classList.add(HIDDEN_CLASSNAME2));
  }
  _canBindToCell(table, col, row) {
    var _a;
    const rect = table.getCellRangeRelativeRect({
      col,
      row
    }), element = null !== (_a = table.internalProps.menu.parentElement) && void 0 !== _a ? _a : table.getElement(), { top, bottom, left, right } = rect;
    if (table.isFrozenCell(col, row)) return true;
    if (bottom < table.getFrozenRowsHeight() || right < table.getFrozenColsWidth() || left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() || top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) return false;
    const { offsetHeight, offsetWidth } = element;
    return !(offsetHeight < top) && !(offsetWidth < left);
  }
  _bindCell(table, col, row, position, referencePosition) {
    var _a;
    const rootElement = this._rootElement, element = null !== (_a = table.internalProps.menu.parentElement) && void 0 !== _a ? _a : table.getElement(), { width: containerWidth, height: containerHeight, left: containerLeft, top: containerTop } = element.getBoundingClientRect();
    if (rootElement) {
      rootElement.parentElement !== element && element.appendChild(rootElement), rootElement.style.left = "0px";
      const maxWidth = 0.8 * containerWidth;
      rootElement.style.maxWidth = `${maxWidth}px`;
      const rootElementWidth = rootElement.clientWidth, rootElementHeight = rootElement.clientHeight;
      let rootElementLeft, rootElementTop;
      position && (rootElementLeft = position.x, rootElementTop = position.y), referencePosition && (rootElementLeft = referencePosition.rect.right - rootElementWidth, rootElementTop = referencePosition.rect.bottom), rootElementTop + rootElementHeight > containerHeight && (rootElementTop = containerHeight - rootElementHeight, rootElementLeft += rootElementWidth - 2), rootElementTop < 0 && (rootElementTop /= 2);
      let deltaTop = 0, deltaLeft = 0;
      if (table.getElement() !== element) {
        const { left, top } = table.getElement().getBoundingClientRect();
        deltaTop = top - containerTop, deltaLeft = left - containerLeft;
      }
      return rootElement.style.top = `${rootElementTop + deltaTop}px`, rootElementLeft < 0 ? rootElementLeft = 0 : rootElementLeft + rootElementWidth > containerWidth && (rootElementLeft = containerWidth - rootElementWidth), rootElement.style.left = `${rootElementLeft + deltaLeft}px`, true;
    }
    return false;
  }
  pointInMenuElement(x, y) {
    const rootElement = this._rootElement, { x: rootLeft, y: rootTop, width: rootWidth, height: rootHeight } = rootElement.getBoundingClientRect();
    return x > rootLeft - 5 && x < rootLeft + rootWidth + 5 && y > rootTop - 5 && y < rootTop + rootHeight + 5;
  }
};

// node_modules/@visactor/vtable/es/components/menu/dom/Menu.js
var Menu = class extends BaseMenu {
  createMenuElementInternal() {
    return new MenuElement(this._table);
  }
};
var Container2 = class extends BaseMenu {
  createMenuElementInternal() {
    return new MenuContainer(this._table);
  }
};

// node_modules/@visactor/vtable/es/components/menu/dom/MenuHandler.js
var MENU_INSTANCE_FACTORY = {
  "dropdown-menu": function(table) {
    return new Menu(table);
  },
  "context-menu": function(table) {
    return new Menu(table);
  },
  container: (table) => new Container2(table)
};
function getMenuInstanceInfo(table, col, row, type, dropDownMenuOptions) {
  var _a, _b;
  const { lineHeight, textBaseline, textStick } = table._getCellStyle(col, row);
  let rect = table.getCellRangeRelativeRect(table.getCellRange(col, row));
  textStick && (rect = table.getVisibleCellRangeRelativeRect({
    col,
    row
  }));
  let { left, right, bottom, top, width, height } = rect;
  if (table.isHeader(col, row) && ({ left, right, bottom, top, width, height } = table.internalProps.headerHelper.getDropDownIconRect(rect, lineHeight, textBaseline || "middle")), null == dropDownMenuOptions ? void 0 : dropDownMenuOptions.content) return {
    type,
    position: dropDownMenuOptions.position,
    referencePosition: null !== (_a = dropDownMenuOptions.referencePosition) && void 0 !== _a ? _a : {
      rect: {
        left,
        right,
        top,
        bottom,
        width,
        height
      }
    },
    content: dropDownMenuOptions.content
  };
  if ("dropdown-menu" === type) {
    let dropDownMenu = table.globalDropDownMenu;
    const headerData = table._getHeaderLayoutMap(col, row);
    dropDownMenu = null !== (_b = headerData.dropDownMenu) && void 0 !== _b ? _b : dropDownMenu;
    const pivotInfo = headerData.pivotInfo;
    return "function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
      row,
      col,
      table
    })), {
      type,
      referencePosition: {
        rect: {
          left,
          right,
          top,
          bottom,
          width,
          height
        }
      },
      content: dropDownMenu,
      pivotInfo
    };
  }
  return null;
}
var MenuHandler2 = class {
  constructor(table) {
    this._table = table, this._menuInstances = {}, this._bindTableEvent(table);
  }
  release() {
    const menuInstances = this._menuInstances;
    for (const k2 in menuInstances) menuInstances[k2].release();
    delete this._menuInstances, this._attachInfo = null;
  }
  _bindToCell(col, row, type, dropDownMenuOptions) {
    var _a;
    const info = this._attachInfo, instanceInfo = this._getMenuInstanceInfo(col, row, type, dropDownMenuOptions);
    if (!info || instanceInfo && info.instance === instanceInfo.instance || (null === (_a = info.instance) || void 0 === _a || _a.unbindMenuElement(), this._attachInfo = null), !instanceInfo) return;
    const { instance, info: menuInstanceInfo } = instanceInfo;
    if (instance && instance.bindMenuElement(col, row, menuInstanceInfo)) {
      const range5 = this._table.getCellRange(col, row);
      this._attachInfo = {
        range: range5,
        instance
      };
    }
  }
  _unbindFromCell() {
    const info = this._attachInfo;
    if (!info) return;
    const { instance } = info;
    null == instance || instance.unbindMenuElement(), this._attachInfo = null;
  }
  _isBindToCell(col, row) {
    const info = this._attachInfo;
    return !!info && cellInRange(info.range, col, row);
  }
  pointInMenuElement(x, y) {
    if (!this._attachInfo) return false;
    const info = this._attachInfo, { instance } = info;
    return instance.pointInMenuElement(x, y);
  }
  _bindTableEvent(table) {
    table.on(TABLE_EVENT_TYPE.DROPDOWN_ICON_CLICK, (e) => {
      this._attachInfo && this._isBindToCell(e.col, e.row) ? this._unbindFromCell() : this._bindToCell(e.col, e.row, "dropdown-menu");
    }), table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, (e) => {
      this._unbindFromCell();
    }), table.on(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, (e) => {
      var _a, _b, _c, _d;
      if ("html" === (null === (_a = table.internalProps.menu) || void 0 === _a ? void 0 : _a.renderMode)) {
        const abstractPos = table._getMouseAbstractPoint(e.event);
        let menu = null;
        abstractPos.inTable && "function" == typeof (null === (_b = table.internalProps.menu) || void 0 === _b ? void 0 : _b.contextMenuItems) ? menu = table.internalProps.menu.contextMenuItems(table.getHeaderField(e.col, e.row), e.row, e.col, table) : abstractPos.inTable && Array.isArray(null === (_c = table.internalProps.menu) || void 0 === _c ? void 0 : _c.contextMenuItems) && (menu = null === (_d = table.internalProps.menu) || void 0 === _d ? void 0 : _d.contextMenuItems), this._bindToCell(e.col, e.row, "context-menu", {
          content: menu,
          position: {
            x: abstractPos.x,
            y: abstractPos.y
          }
        });
      }
    });
  }
  _getMenuInstanceInfo(col, row, type, dropDownMenuOptions) {
    const table = this._table, menuInstances = this._menuInstances, info = getMenuInstanceInfo(table, col, row, type, dropDownMenuOptions);
    if (!info) return null;
    return {
      instance: menuInstances && menuInstances[type] || menuInstances && (menuInstances[type] = MENU_INSTANCE_FACTORY[type](table)),
      type,
      info
    };
  }
  containElement(el) {
    var _a;
    for (const k2 in this._menuInstances) {
      if (null === (_a = this._menuInstances[k2].getRootElement()) || void 0 === _a ? void 0 : _a.contains(el)) return true;
    }
    return false;
  }
};

// node_modules/@visactor/vtable/es/components/title/title.js
var Title2 = class {
  constructor(titleOption, table) {
    this.isReleased = false, this.table = table, this._titleOption = merge({
      orient: "top"
    }, titleOption), false !== titleOption.visible && (this._titleComponent = this._createOrUpdateTitleComponent(this._getTitleAttrs()));
  }
  _createOrUpdateTitleComponent(attrs) {
    if (this._titleComponent) isEqual(attrs, this._cacheAttrs) || this._titleComponent.setAttributes(attrs);
    else {
      const title = new Title(attrs);
      title.name = "title", this.table.scenegraph.stage.defaultLayer.appendChild(title), this._titleComponent = title;
    }
    return this._adjustTableSize(this._titleComponent.attribute), this._titleComponent;
  }
  resize() {
    var _a, _b, _c, _d, _e;
    if (!this._titleComponent) return;
    const padding = getQuadProps(null !== (_a = this._titleOption.padding) && void 0 !== _a ? _a : 10), realWidth = null !== (_b = this._titleOption.width) && void 0 !== _b ? _b : ("adaptive" === this.table.widthMode ? this.table.tableNoFrameWidth : Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width)) - padding[1] - padding[3], realHeight = null !== (_c = this._titleOption.height) && void 0 !== _c ? _c : ("adaptive" === this.table.heightMode ? this.table.tableNoFrameHeight : Math.min(this.table.tableNoFrameHeight, this.table.getDrawRange().height)) - padding[0] - padding[2];
    this._titleComponent.setAttributes({
      x: (null !== (_d = this._titleOption.x) && void 0 !== _d ? _d : "right" === this._titleOption.orient) ? this.table.tableX + Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width) : this.table.tableX,
      y: (null !== (_e = this._titleOption.y) && void 0 !== _e ? _e : "bottom" === this._titleOption.orient) ? this.table.tableY + this.table.tableNoFrameHeight : this.table.tableY,
      width: "top" === this._titleOption.orient || "bottom" === this._titleOption.orient ? realWidth : this._titleOption.width,
      height: "left" === this._titleOption.orient || "right" === this._titleOption.orient ? realHeight : this._titleOption.height,
      textStyle: Object.assign({
        width: realWidth
      }, this._titleOption.textStyle),
      subtextStyle: Object.assign({
        width: realWidth
      }, this._titleOption.subtextStyle)
    }), this._adjustTableSize(this._titleComponent.attribute);
  }
  _adjustTableSize(attrs) {
    var _a, _b, _c, _d;
    const width = isFinite(null === (_a = this._titleComponent) || void 0 === _a ? void 0 : _a.AABBBounds.width()) ? this._titleComponent.AABBBounds.width() : 0, height = isFinite(null === (_b = this._titleComponent) || void 0 === _b ? void 0 : _b.AABBBounds.height()) ? this._titleComponent.AABBBounds.height() : 0;
    "left" === this._titleOption.orient ? (this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width), this.table.tableX += Math.ceil(width)) : "top" === this._titleOption.orient ? (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height), this.table.tableY += Math.ceil(height)) : "right" === this._titleOption.orient ? this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width) : "bottom" === this._titleOption.orient && (this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height)), this._cacheAttrs = attrs, "right" !== this._titleOption.orient && "bottom" !== this._titleOption.orient || this._titleComponent.setAttributes({
      x: (null !== (_c = this._titleOption.x) && void 0 !== _c ? _c : "right" === this._titleOption.orient) ? this.table.tableX + this.table.tableNoFrameWidth : this.table.tableX,
      y: (null !== (_d = this._titleOption.y) && void 0 !== _d ? _d : "bottom" === this._titleOption.orient) ? this.table.tableY + this.table.tableNoFrameHeight : this.table.tableY
    });
  }
  release() {
    this._titleComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this._titleComponent), this._titleComponent = null, this.isReleased = true;
  }
  _getTitleAttrs() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const defaultPadding = this._titleOption.text || this._titleOption.subtext ? 10 : 0, padding = getQuadProps(null !== (_a = this._titleOption.padding) && void 0 !== _a ? _a : defaultPadding), realWidth = null !== (_b = this._titleOption.width) && void 0 !== _b ? _b : Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width) - padding[1] - padding[3], realHeight = null !== (_c = this._titleOption.height) && void 0 !== _c ? _c : Math.min(this.table.tableNoFrameHeight, this.table.getDrawRange().height) - padding[0] - padding[2];
    return {
      text: null !== (_d = this._titleOption.text) && void 0 !== _d ? _d : "",
      subtext: null !== (_e = this._titleOption.subtext) && void 0 !== _e ? _e : "",
      x: (null !== (_f = this._titleOption.x) && void 0 !== _f ? _f : "right" === this._titleOption.orient) ? this.table.tableX + Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width) : this.table.tableX,
      y: (null !== (_g = this._titleOption.y) && void 0 !== _g ? _g : "bottom" === this._titleOption.orient) ? this.table.tableY + this.table.tableNoFrameHeight : this.table.tableY,
      width: "top" === this._titleOption.orient || "bottom" === this._titleOption.orient ? realWidth : this._titleOption.width,
      height: "left" === this._titleOption.orient || "right" === this._titleOption.orient ? realHeight : this._titleOption.height,
      minWidth: this._titleOption.minWidth,
      maxWidth: this._titleOption.maxWidth,
      minHeight: this._titleOption.minHeight,
      maxHeight: this._titleOption.maxHeight,
      padding: this._titleOption.padding,
      align: null !== (_h = this._titleOption.align) && void 0 !== _h ? _h : "left",
      verticalAlign: null !== (_j = this._titleOption.verticalAlign) && void 0 !== _j ? _j : "top",
      textStyle: Object.assign({
        width: realWidth
      }, this._titleOption.textStyle),
      subtextStyle: Object.assign({
        width: realWidth
      }, this._titleOption.subtextStyle),
      dx: null !== (_k = this._titleOption.dx) && void 0 !== _k ? _k : 0,
      dy: null !== (_l = this._titleOption.dy) && void 0 !== _l ? _l : 0
    };
  }
  getComponentGraphic() {
    return this._titleComponent;
  }
};

// node_modules/@visactor/vtable/es/components/tooltip/BaseTooltip.js
var BaseTooltip = class {
  constructor(table) {
    this._table = table;
  }
  release() {
    var _a, _b;
    this.unbindTooltipElement(), this._tooltipElement && (null === (_b = (_a = this._tooltipElement).release) || void 0 === _b || _b.call(_a)), this._tooltipElement = void 0;
  }
  _getTooltipElement() {
    return this._tooltipElement || (this._tooltipElement = this.createTooltipElementInternal()), this._tooltipElement;
  }
  bindTooltipElement(col, row, tooltipInstanceInfo, confine) {
    return this._getTooltipElement().bindToCell(this._table, col, row, tooltipInstanceInfo, confine);
  }
  moveTooltipElement(col, row, tooltipOptions, confine) {
    this._getTooltipElement().move(this._table, col, row, tooltipOptions, confine);
  }
  unbindTooltipElement() {
    this._getTooltipElement().unbindFromCell();
  }
  locateTooltipElement(col, row, position, referencePosition, confine) {
    this._getTooltipElement()._locate(this._table, col, row, position, referencePosition, confine);
  }
};

// node_modules/@visactor/vtable/es/components/tooltip/logic/BubbleTooltipElementStyle.js
function importStyle3() {
  if ("node" === Env.mode) return;
  const styleElement = document.createElement("style");
  styleElement.id = "vtable-tooltip-styleSheet", styleElement.textContent = "\n@keyframes vtable__bubble-tooltip-element--shown-animation {\n	0% {\n		opacity: 0;\n	}\n	100% {\n		opacity: 1;\n	}\n}\n.vtable__bubble-tooltip-element {\n	position: absolute;\n	\n	// pointer-events: none;\n	//user-select: none;\n	max-width: 300px;\n	z-index: 99999;\n\n	background: #FFFFFF;\n    border: 1px solid #E6E8ED;\n    box-sizing: border-box;\n    border-radius: 4px;\n    box-shadow: 0px 2px 4px rgb(27 31 35 / 8%);\n    color: #141414;\n    font-size: 13px;\n}\n.vtable__bubble-tooltip-element--hidden {\n	opacity: 0;\n  pointer-events: none;\n	user-select: none;\n	/* transform: translate(-50%, -50%); */\n	transition: opacity 75ms linear;\n}\n.vtable__bubble-tooltip-element--shown {\n	opacity: 1;\n	/* transform: translate(-50%, -50%); */\n	animation: vtable__bubble-tooltip-element--shown-animation 150ms ease-out;\n}\n.vtable__bubble-tooltip-element__content {\n	/* font-size: .75rem; */\n	padding: 6px 8px;\n	min-height: 1em;\n	line-height: 1.5;\n	width: 100%;\n	display: block;\n	white-space: pre-wrap;\n	margin: 0;\n	box-sizing: border-box;\n	overflow: auto;\n	word-wrap: break-word;\n	position: relative;\n	background-color: #FFF;\n	z-index: 2;\n	border-radius: 4px;\n}\n/*  WebKit Microsoft Edge（新版）： */\n.vtable__bubble-tooltip-element__content::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  background-color: transparent;\n}\n/*  Opera Firefox  */\n.vtable__bubble-tooltip-element__content > scrollbar-track {\n  width: 0;\n  height: 0;\n  background-color: transparent;\n}\n/* Internet Explorer 11 和 Microsoft Edge（旧版） */\n.vtable__bubble-tooltip-element__content > scrollbar {\n  width: 0;\n  height: 0;\n  background-color: transparent;\n}\n.vtable__bubble-tooltip-element__triangle {\n	/* font-size: .75rem; */\n	position: absolute;\n	width: 10px;\n	height: 10px;\n	display: block;\n	transform: rotate(45deg);\n    transform-origin: 50% 50% 0;\n	z-index: 1;\n	background-color: #FFF;\n	border: 1px solid #E6E8ED;\n}\n", document.head.appendChild(styleElement);
}

// node_modules/@visactor/vtable/es/components/tooltip/logic/BubbleTooltipElement.js
importStyle3();
var TOOLTIP_CLASS = "vtable__bubble-tooltip-element";
var CONTENT_CLASS = `${TOOLTIP_CLASS}__content`;
var TRIANGLE_CLASS = `${TOOLTIP_CLASS}__triangle`;
var HIDDEN_CLASS = `${TOOLTIP_CLASS}--hidden`;
var SHOWN_CLASS = `${TOOLTIP_CLASS}--shown`;
var BubbleTooltipElement = class {
  constructor() {
    this._handler = new EventHandler();
    const rootElement = this._rootElement = createElement("div", [TOOLTIP_CLASS, HIDDEN_CLASS]), messageElement = createElement("div", [CONTENT_CLASS]), triangle = createElement("span", [TRIANGLE_CLASS]);
    rootElement.appendChild(triangle), rootElement.appendChild(messageElement), this._messageElement = rootElement.querySelector(`.${CONTENT_CLASS}`) || void 0, this._triangleElement = rootElement.querySelector(`.${TRIANGLE_CLASS}`) || void 0, rootElement.addEventListener("mousemove", () => {
      this._disappearDelayId && clearTimeout(this._disappearDelayId);
    }), rootElement.addEventListener("mouseleave", () => {
      this._disappearDelay = void 0, this.unbindFromCell();
    }), messageElement.addEventListener("wheel", (e) => {
      e.stopPropagation();
    }), messageElement.addEventListener("copy", (e) => {
      isDivSelected(messageElement) && e.stopPropagation();
    });
  }
  bindToCell(table, col, row, tooltipInstanceInfo, confine) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    this._disappearDelay = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.disappearDelay, this._disappearDelayId && clearTimeout(this._disappearDelayId);
    const rootElement = this._rootElement, messageElement = this._messageElement, triangle = this._triangleElement;
    if (null == rootElement || rootElement.classList.remove(SHOWN_CLASS), null == rootElement || rootElement.classList.add(HIDDEN_CLASS), this._canBindToCell(table, col, row)) {
      messageElement.setAttribute("style", ""), triangle.setAttribute("style", ""), (null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.className) && rootElement.classList.add(tooltipInstanceInfo.className), (null === (_a = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _a ? void 0 : _a.bgColor) && (messageElement.style.backgroundColor = null === (_b = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _b ? void 0 : _b.bgColor), (null === (_c = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _c ? void 0 : _c.bgColor) && (triangle.style.backgroundColor = null === (_d = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _d ? void 0 : _d.bgColor), triangle.style.display = true === (null === (_e = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _e ? void 0 : _e.arrowMark) ? "block" : "none", (null === (_f = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _f ? void 0 : _f.fontSize) && (messageElement.style.fontSize = (null !== (_h = null === (_g = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _g ? void 0 : _g.fontSize) && void 0 !== _h ? _h : 12) + "px"), (null === (_j = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _j ? void 0 : _j.fontFamily) && (messageElement.style.fontFamily = null === (_k = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _k ? void 0 : _k.fontFamily), (null === (_l = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _l ? void 0 : _l.color) && (messageElement.style.color = null === (_m = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _m ? void 0 : _m.color), (null === (_o = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _o ? void 0 : _o.padding) && (messageElement.style.padding = `${null === (_p = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _p ? void 0 : _p.padding.join("px ")}px`), (null === (_q = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _q ? void 0 : _q.maxHeight) && (messageElement.style.maxHeight = `${null === (_r = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _r ? void 0 : _r.maxHeight}px`), (null === (_s = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _s ? void 0 : _s.maxWidth) && (messageElement.style.maxWidth = `${null === (_t = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _t ? void 0 : _t.maxWidth}px`), messageElement && (messageElement.textContent = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.content);
      if (this._bindToCell(table, col, row, null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.position, null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.referencePosition, confine, null === (_u = null == tooltipInstanceInfo ? void 0 : tooltipInstanceInfo.style) || void 0 === _u ? void 0 : _u.arrowMark)) return null == rootElement || rootElement.classList.add(SHOWN_CLASS), null == rootElement || rootElement.classList.remove(HIDDEN_CLASS), true;
    } else this.unbindFromCell();
    return false;
  }
  release() {
    var _a, _b;
    this.unbindFromCell();
    const rootElement = this._rootElement;
    (null == rootElement ? void 0 : rootElement.parentElement) && rootElement.parentElement.removeChild(rootElement), null === (_b = null === (_a = this._handler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), delete this._rootElement, delete this._messageElement;
  }
  move(table, col, row, tooltipOptions, confine) {
    const rootElement = this._rootElement;
    this._canBindToCell(table, col, row) ? (this._bindToCell(table, col, row, null == tooltipOptions ? void 0 : tooltipOptions.position, null == tooltipOptions ? void 0 : tooltipOptions.referencePosition, confine), null == rootElement || rootElement.classList.add(SHOWN_CLASS), null == rootElement || rootElement.classList.remove(HIDDEN_CLASS)) : this.unbindFromCell();
  }
  unbindFromCell() {
    var _a;
    if (this._disappearDelay) this._disappearDelayId = setTimeout(() => {
      const rootElement = this._rootElement;
      (null == rootElement ? void 0 : rootElement.parentElement) && (rootElement.classList.remove(SHOWN_CLASS), rootElement.classList.add(HIDDEN_CLASS));
    }, null !== (_a = this._disappearDelay) && void 0 !== _a ? _a : 0);
    else {
      const rootElement = this._rootElement;
      (null == rootElement ? void 0 : rootElement.parentElement) && (rootElement.classList.remove(SHOWN_CLASS), rootElement.classList.add(HIDDEN_CLASS));
    }
  }
  _canBindToCell(table, col, row) {
    const rect = table.getCellRangeRelativeRect({
      col,
      row
    }), element = table.getElement(), { bottom, left, right, top } = rect;
    if (table.isFrozenCell(col, row)) return true;
    if (bottom < table.getFrozenRowsHeight() || right < table.getFrozenColsWidth() || left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() || top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) return false;
    const { offsetHeight, offsetWidth } = element;
    return !(top > offsetHeight) && !(left > offsetWidth);
  }
  _bindToCell(table, col, row, position, referencePosition, confine, arrowMark) {
    const rootElement = this._rootElement, rect = table.getCellRangeRelativeRect({
      col,
      row
    }), element = table.internalProps.tooltip.parentElement, containerWidth = table.internalProps.element.offsetWidth, { width } = rect;
    if (rootElement) {
      let tooltipY, tooltipX;
      rootElement.parentElement !== element && element.appendChild(rootElement), rootElement.style.left = "0px";
      const maxWidth = Math.min(0.8 * containerWidth, 4 * width);
      rootElement.style.maxWidth = `${maxWidth}px`;
      const rootElementWidth = rootElement.clientWidth, rootElementHeight = rootElement.clientHeight;
      if (!position && !referencePosition) return false;
      {
        const tooltipPosition = this.getComputedPosition(table, col, row, position, referencePosition, confine, arrowMark);
        tooltipX = tooltipPosition.x, tooltipY = tooltipPosition.y;
      }
      rootElement.style.left = `${tooltipX}px`, rootElement.style.top = `${tooltipY}px`, isMobile() && (rootElement.style.fontSize = "11px");
      const { x1: menuLeft, x2: menuRight, y1: menuTop, y2: menuBottom } = table.stateManager.menu.bounds, tooltipLeft = tooltipX, tooltipRight = tooltipLeft + rootElementWidth, tooltipTop = tooltipY, tooltipBottom = tooltipLeft + rootElementHeight;
      return !(table.stateManager.menu.isShow && menuLeft < tooltipRight && menuRight > tooltipLeft && menuBottom > tooltipTop && menuTop < tooltipBottom);
    }
    return false;
  }
  getComputedPosition(table, col, row, position, referencePosition, confine, arrowMark) {
    var _a;
    const rootElement = this._rootElement, rect = table.getCellRangeRelativeRect({
      col,
      row
    }), { x: parentX, y: parentY } = table.internalProps.tooltip.parentElement.getBoundingClientRect(), { width: containerWidth, height: containerHeight, x, y } = table.internalProps.element.getBoundingClientRect(), { width } = rect;
    let tooltipY, tooltipX;
    const maxWidth = Math.min(0.8 * containerWidth, 4 * width);
    rootElement.style.maxWidth = `${maxWidth}px`;
    const rootElementWidth = rootElement.clientWidth, rootElementHeight = rootElement.clientHeight, triangleHeight = arrowMark ? 6 : 0;
    if (position) tooltipX = position.x, tooltipY = position.y + triangleHeight, this._triangleElement.style.left = "50%", this._triangleElement.style.marginLeft = "-5px", this._triangleElement.style.top = "-5px";
    else if (referencePosition) {
      let placement = null !== (_a = referencePosition.placement) && void 0 !== _a ? _a : Placement.bottom;
      const referenceXMiddle = referencePosition.rect.left + referencePosition.rect.width / 2, referenceYMiddle = referencePosition.rect.top + referencePosition.rect.height / 2, referenceTop = referencePosition.rect.top, referenceBottom = referencePosition.rect.bottom, referenceLeft = referencePosition.rect.left, referenceRight = referencePosition.rect.right;
      let callCount = 0;
      const adjustPosition = () => {
        callCount++, callCount >= 4 || (this.removeStyleFromTriangle(), placement === Placement.top ? (tooltipX = referenceXMiddle - rootElementWidth / 2, tooltipY = referenceTop - rootElementHeight - triangleHeight, this._triangleElement.style.left = "50%", this._triangleElement.style.marginLeft = "-5px", this._triangleElement.style.bottom = "-5px", confine && tooltipY < 0 && (placement = Placement.right, adjustPosition())) : placement === Placement.bottom ? (tooltipX = referenceXMiddle - rootElementWidth / 2, tooltipY = referenceBottom + triangleHeight, this._triangleElement.style.left = "50%", this._triangleElement.style.marginLeft = "-5px", this._triangleElement.style.top = "-5px", confine && tooltipY + rootElementHeight > containerHeight && (placement = Placement.left, adjustPosition())) : placement === Placement.left ? (tooltipY = referenceYMiddle - rootElementHeight / 2, tooltipX = referenceLeft - rootElementWidth - triangleHeight, this._triangleElement.style.top = "50%", this._triangleElement.style.marginTop = "-5px", this._triangleElement.style.right = "-5px", confine && tooltipX < 0 && (placement = Placement.top, adjustPosition())) : placement === Placement.right && (tooltipY = referenceYMiddle - rootElementHeight / 2, tooltipX = referenceRight + triangleHeight, this._triangleElement.style.top = "50%", this._triangleElement.style.marginTop = "-5px", this._triangleElement.style.left = "-5px", confine && tooltipX + rootElementWidth > containerWidth && (placement = Placement.bottom, adjustPosition())));
      };
      adjustPosition();
    }
    return confine && (tooltipX < 0 ? tooltipX = 0 : tooltipX + rootElement.offsetWidth > containerWidth && (tooltipX = containerWidth - rootElement.offsetWidth)), {
      x: tooltipX + x - parentX,
      y: tooltipY + y - parentY
    };
  }
  removeStyleFromTriangle() {
    this._triangleElement.style.left = "", this._triangleElement.style.right = "", this._triangleElement.style.top = "", this._triangleElement.style.bottom = "", this._triangleElement.style.marginLeft = "", this._triangleElement.style.marginTop = "";
  }
  _locate(table, col, row, position, referencePosition, confine) {
    const tooltipPosition = this.getComputedPosition(table, col, row, position, referencePosition, confine), tooltipX = tooltipPosition.x, tooltipY = tooltipPosition.y;
    this._rootElement.style.left = `${tooltipX}px`, this._rootElement.style.top = `${tooltipY}px`;
  }
};

// node_modules/@visactor/vtable/es/components/tooltip/Tooltip.js
var BubbleTooltip = class extends BaseTooltip {
  createTooltipElementInternal() {
    return new BubbleTooltipElement();
  }
};

// node_modules/@visactor/vtable/es/components/tooltip/TooltipHandler.js
var TOOLTIP_INSTANCE_FACTORY = {
  "bubble-tooltip": function(table) {
    return new BubbleTooltip(table);
  }
};
var TooltipHandler = class {
  constructor(table, confine) {
    this._table = table, this._tooltipInstances = {}, this._bindTableEvent(table), this.confine = confine;
  }
  release() {
    var _a, _b;
    const tooltipInstances = this._tooltipInstances;
    for (const k2 in tooltipInstances) null === (_b = null === (_a = tooltipInstances[k2]) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a);
    delete this._tooltipInstances, this._attachInfo = null;
  }
  _bindToCell(col, row, tooltipOptions) {
    var _a;
    const info = this._attachInfo, instance = this._getTooltipInstanceInfo(col, row);
    if (!info || instance && info.instance === instance || (null === (_a = info.instance) || void 0 === _a || _a.unbindTooltipElement(), this._attachInfo = null), !instance) return;
    if (instance && instance.bindTooltipElement(col, row, tooltipOptions, this.confine)) {
      const range5 = this._table.getCellRange(col, row);
      this._attachInfo = {
        range: range5,
        instance,
        tooltipOptions
      };
    }
  }
  _move(col, row, tooltipOptions) {
    const info = this._attachInfo;
    if (!info || !cellInRange(info.range, col, row)) return;
    const { instance } = info;
    null == instance || instance.moveTooltipElement(col, row, tooltipOptions, this.confine);
  }
  moveToPosition(col, row, position, referencePosition) {
    const info = this._attachInfo;
    if (!info || !cellInRange(info.range, col, row)) return;
    const { instance } = info;
    this._attachInfo.tooltipOptions.position = position, this._attachInfo.tooltipOptions.referencePosition = referencePosition, null == instance || instance.locateTooltipElement(col, row, position, referencePosition, this.confine);
  }
  _unbindFromCell() {
    const info = this._attachInfo;
    if (!info) return;
    const { instance } = info;
    null == instance || instance.unbindTooltipElement(), this._attachInfo = null;
  }
  _isBindCell(col, row) {
    const info = this._attachInfo;
    return !!info && cellInRange(info.range, col, row);
  }
  _bindTableEvent(table) {
    table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, (e) => {
      if (isMobile()) return;
      const { x1: left, x2: right, y1: top, y2: bottom } = table.stateManager.menu.bounds;
      if (table.stateManager.menu.isShow && "number" == typeof e.x && "number" == typeof e.y && e.x > left && e.x < right && e.y > top && e.y < bottom) return;
      const { col, row } = e;
      this.showTooltip(col, row);
    }), table.on(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, (e) => {
      var _a, _b;
      if (!isMobile()) {
        if (null === (_b = null === (_a = this._attachInfo) || void 0 === _a ? void 0 : _a.tooltipOptions) || void 0 === _b ? void 0 : _b.referencePosition) {
          const position = this._attachInfo.tooltipOptions.referencePosition, { event: event2 } = e, { left, right, top, bottom } = position.rect, abstractPos = table._getMouseAbstractPoint(event2);
          abstractPos.inTable && abstractPos.x >= left - 5 && abstractPos.x <= right + 5 && abstractPos.y >= top - 5 && abstractPos.y <= bottom + 5 || this._unbindFromCell();
        }
        this._attachInfo && table.stateManager.menu.isShow && this._bindToCell(e.col, e.row);
      }
    }), table.on(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, (e) => {
      this._unbindFromCell();
    }), table.on(TABLE_EVENT_TYPE.SELECTED_CELL, (e) => {
      this._isBindCell(e.col, e.row) && this._unbindFromCell();
    }), table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, (e) => {
      this._unbindFromCell();
    }), table.on(TABLE_EVENT_TYPE.SCROLL, (e) => {
      this._unbindFromCell();
    });
  }
  showTooltip(col, row) {
    var _a, _b, _c;
    let tooltipOption;
    const table = this._table, headerDescription = table.getHeaderDescription(col, row);
    if (headerDescription) {
      const rect = table.getCellRangeRelativeRect({
        col,
        row
      });
      tooltipOption = {
        content: headerDescription,
        referencePosition: {
          placement: table.internalProps.tooltip.position,
          rect
        },
        disappearDelay: null !== (_a = table.internalProps.tooltip.overflowTextTooltipDisappearDelay) && void 0 !== _a ? _a : 0,
        style: table.theme.tooltipStyle
      };
    } else if (isFunction_default(null === (_b = table.internalProps.tooltip) || void 0 === _b ? void 0 : _b.isShowOverflowTextTooltip) ? table.internalProps.tooltip.isShowOverflowTextTooltip(col, row, table) : table.internalProps.tooltip.isShowOverflowTextTooltip) {
      const overflowText = table.getCellOverflowText(col, row), rect = table.getCellRangeRelativeRect({
        col,
        row
      });
      overflowText && (tooltipOption = {
        content: headerDescription ? `${headerDescription}
  ${overflowText}` : overflowText,
        referencePosition: {
          placement: table.internalProps.tooltip.position,
          rect
        },
        disappearDelay: null !== (_c = table.internalProps.tooltip.overflowTextTooltipDisappearDelay) && void 0 !== _c ? _c : 0,
        style: table.theme.tooltipStyle
      });
    }
    tooltipOption ? this._bindToCell(col, row, tooltipOption) : this._unbindFromCell();
  }
  _getTooltipInstanceInfo(col, row) {
    const table = this._table, tooltipInstances = this._tooltipInstances;
    return tooltipInstances && tooltipInstances["bubble-tooltip"] || tooltipInstances && (tooltipInstances["bubble-tooltip"] = TOOLTIP_INSTANCE_FACTORY["bubble-tooltip"](table));
  }
  isBinded(tooltipOptions) {
    var _a;
    return JSON.stringify(tooltipOptions) === JSON.stringify(null === (_a = this._attachInfo) || void 0 === _a ? void 0 : _a.tooltipOptions);
  }
};

// node_modules/@visactor/vtable/es/components/index.js
var registerAxis = () => {
  Factory2.registerComponent("axis", CartesianAxis), Factory2.registerFunction("computeAxisComponentWidth", computeAxisComponentWidth), Factory2.registerFunction("computeAxisComponentHeight", computeAxisComponentHeight), Factory2.registerFunction("getAxisConfigInPivotChart", getAxisConfigInPivotChart);
};
var registerEmptyTip = () => {
  Factory2.registerComponent("emptyTip", EmptyTip2);
};
var registerLegend = () => {
  Factory2.registerFunction("createLegend", createLegend);
};
var registerMenu = () => {
  Factory2.registerComponent("menuHandler", MenuHandler2);
};
var registerTitle = () => {
  Factory2.registerComponent("title", Title2);
};
var registerTooltip = () => {
  Factory2.registerComponent("tooltipHandler", TooltipHandler);
};

// node_modules/@visactor/vtable/es/plugins/list-tree-stick-cell.js
var ListTreeStickCellPlugin = class {
  constructor(table) {
    this.titleRows = [], this.showedTitleRows = [], this.rowNow = -1, this.skipStartRow = -1, this.skipEndRow = -1, this.table = table, this.table.on("scroll", (e) => {
      "vertical" === e.scrollDirection && this.updateGroupTitle();
    }), this.table.on("tree_hierarchy_state_change", (e) => {
      this.updateGroupTitle();
    }), this.table.on("resize_column", (e) => {
      this.updateGroupTitle();
    });
  }
  updateGroupTitle() {
    0 === this.table.scrollTop ? (this.titleRows = [], this.showedTitleRows = []) : -1 !== this.skipStartRow && -1 !== this.skipEndRow && this.skipStartRow !== this.table.scenegraph.proxy.bodyTopRow - 1 ? (this.table.scenegraph.proxy.screenTopRow <= this.skipStartRow || this.table.scenegraph.proxy.screenTopRow >= this.skipEndRow) && (this.skipStartRow = -1, this.skipEndRow = -1, this.updateGroupTitleInfo()) : (this.skipStartRow = -1, this.skipEndRow = -1, this.updateGroupTitleInfo()), this.updateScenegraph();
  }
  updateGroupTitleInfo() {
    this.rowNow = this.table.scenegraph.proxy.screenTopRow + this.titleRows.length;
    const recordIndex = this.table.getRecordIndexByCell(0, this.rowNow), nextRecordIndex = this.table.getRecordIndexByCell(0, this.rowNow + 1);
    this.getTitleRowsByRecordIndex(recordIndex, nextRecordIndex);
  }
  getTitleRowsByRecordIndex(recordIndex, nextRecordIndex) {
    const titleRecords = [];
    isArray_default(recordIndex) || (recordIndex = [recordIndex]), isArray_default(nextRecordIndex) || (nextRecordIndex = [nextRecordIndex]);
    for (let i = 0; i < recordIndex.length; i++) {
      const index = recordIndex.slice(0, i + 1), record = this.table.dataSource.getRaw(index);
      titleRecords.push(record);
    }
    const titleRows = [], isTitle = nextRecordIndex.length === recordIndex.length + 1;
    let titleIndex = recordIndex.slice(0, isTitle ? recordIndex.length : recordIndex.length - 1);
    const currentIndexedData = this.table.dataSource.currentIndexedData;
    for (let i = this.rowNow - this.table.columnHeaderLevelCount; i >= 0; i--) {
      const currentIndex = currentIndexedData[i];
      if (isArray_default(currentIndex) && titleIndex.length === currentIndex.length) {
        let isMatch = true;
        for (let j = 0; j < currentIndex.length; j++) if (currentIndex[j] !== titleIndex[j]) {
          isMatch = false;
          break;
        }
        isMatch && (titleRows.push(i + this.table.columnHeaderLevelCount), titleIndex = titleIndex.slice(0, titleIndex.length - 1));
      } else if (currentIndex === recordIndex[0]) {
        titleRows.push(i + this.table.columnHeaderLevelCount);
        break;
      }
    }
    this.titleRows = titleRows.reverse();
  }
  updateScenegraph() {
    const { table } = this, { shadowGroup, shadowGroupFrozen } = prepareShadowRoot(table);
    this.showedTitleRows.length = 0;
    let skip = 0;
    for (let col = 0; col < table.colCount; col++) {
      let colGroup;
      col < table.frozenColCount ? (colGroup = new Group2({
        x: table.getColsWidth(0, col - 1),
        y: table.getFrozenRowsHeight()
      }), shadowGroupFrozen.add(colGroup)) : (colGroup = new Group2({
        x: table.getColsWidth(table.frozenColCount, col - 1),
        y: table.getFrozenRowsHeight()
      }), shadowGroup.add(colGroup)), colGroup.col = col;
      for (let i = 0; i < this.titleRows.length; i++) {
        const row = this.titleRows[i];
        if (isSkipRow(row, this.rowNow, table.scenegraph.proxy.screenTopRow, this.titleRows)) {
          0 === col && skip++;
          continue;
        }
        0 === col && this.showedTitleRows.push(row);
        const cell = table.scenegraph.getCell(col, row);
        if ("cell" === cell.role) {
          const newCell = cloneGraphic(cell);
          newCell.setAttributes({
            y: 40 * i
          }), colGroup.add(newCell);
        } else {
          const newCell = updateCell(col, row, table, true, true);
          newCell.setAttributes({
            y: 40 * i
          }), colGroup.add(newCell);
        }
      }
    }
    skip > 0 && -1 === this.skipStartRow && -1 === this.skipEndRow && (this.skipStartRow = table.scenegraph.proxy.screenTopRow - 1, this.skipEndRow = table.scenegraph.proxy.screenTopRow + 1);
  }
};
function isSkipRow(row, topRow, screenTopRow, titleRows) {
  if (row === topRow && row !== screenTopRow + titleRows.length - 1) return true;
  return row === screenTopRow + titleRows.indexOf(row) + 1 && row < topRow;
}
function cloneGraphic(graphic) {
  const newGraphic = graphic.clone();
  if (newGraphic.role = graphic.role, newGraphic.col = graphic.col, newGraphic.row = graphic.row, newGraphic.mergeStartCol = graphic.mergeStartCol, newGraphic.mergeStartRow = graphic.mergeStartRow, newGraphic.mergeEndCol = graphic.mergeEndCol, newGraphic.mergeEndRow = graphic.mergeEndRow, newGraphic.contentWidth = graphic.contentWidth, newGraphic.contentHeight = graphic.contentHeight, "cell" === newGraphic.role) {
    const hackRect = createRect({
      x: 0,
      y: 0,
      width: newGraphic.attribute.width,
      height: newGraphic.attribute.height
    });
    newGraphic.add(hackRect);
  }
  if ("group" === graphic.type) {
    const newGroup = newGraphic;
    graphic.forEachChildren((child) => {
      const newChild = cloneGraphic(child);
      newGroup.add(newChild);
    });
  }
  return newGraphic;
}
function prepareShadowRoot(table) {
  const colHeaderGroup = table.scenegraph.colHeaderGroup, cornerHeaderGroup = table.scenegraph.cornerHeaderGroup;
  if (!colHeaderGroup.border) {
    const hackBorder = createRect({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      cursor: "pointer"
    });
    colHeaderGroup.add(hackBorder), colHeaderGroup.border = hackBorder, hackBorder.attachShadow(hackBorder.shadowRoot), hackBorder.name = "border-rect", hackBorder.addEventListener("click", (e) => {
      const titleRows = table.listTreeStickCellPlugin.titleRows, { shadowTarget } = e.pickParams, cellGroup = getTargetCell(shadowTarget), { col, row } = cellGroup;
      scrollToRow(row - titleRows.indexOf(row), table);
    });
  }
  if (!cornerHeaderGroup.border) {
    const hackBorder = createRect({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      cursor: "pointer"
    });
    cornerHeaderGroup.add(hackBorder), cornerHeaderGroup.border = hackBorder, hackBorder.attachShadow(hackBorder.shadowRoot), hackBorder.name = "border-rect", hackBorder.addEventListener("click", (e) => {
      const titleRows = table.listTreeStickCellPlugin.titleRows, { shadowTarget } = e.pickParams, cellGroup = getTargetCell(shadowTarget), { col, row } = cellGroup;
      scrollToRow(row - titleRows.indexOf(row), table);
    });
  }
  const shadowGroup = colHeaderGroup.border.shadowRoot, shadowGroupFrozen = cornerHeaderGroup.border.shadowRoot;
  return shadowGroup.removeAllChild(), shadowGroupFrozen.removeAllChild(), {
    shadowGroup,
    shadowGroupFrozen
  };
}
function scrollToRow(row, table) {
  const drawRange = table.getDrawRange();
  if (isValid_default(row) && row >= table.frozenRowCount) {
    const frozenHeight = table.getFrozenRowsHeight(), top = table.getRowsHeight(0, row - 1);
    table.scrollTop = Math.min(top - frozenHeight, table.getAllRowsHeight() - drawRange.height) - 1;
  }
  table.scenegraph.updateNextFrame();
}
var registerListTreeStickCellPlugin = () => {
  Factory2.registerComponent("listTreeStickCellPlugin", ListTreeStickCellPlugin);
};

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/chart-cell.js
function createChartCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, dataValue, chartModule2, chartSpec, chartInstance, dataId, table, cellTheme, isShareChartSpec2, isAsync, isNoChartDataRenderNothing2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
  const ClassType = get4()[chartModule2], headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
  if (isValid_default(functionalPadding) && (padding = functionalPadding), !cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true)) && "cell" === cellGroup.role && cellGroup.setAttributes({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
      fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
      stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
      cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
      lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
  }
  if (cellGroup.AABBBounds.width(), isNoChartDataRenderNothing2 && Array.isArray(table.getCellValue(col, row)) || !isNoChartDataRenderNothing2) {
    const chartGroup = new Chart(isShareChartSpec2, {
      stroke: false,
      x: padding[3],
      y: padding[0],
      canvas: null !== (_0 = table.canvas) && void 0 !== _0 ? _0 : table.scenegraph.stage.window.getContext().canvas,
      mode: table.options.mode,
      modeParams: table.options.modeParams,
      spec: table.options.specTransformInCell ? table.options.specTransformInCell(chartSpec, col, row) : chartSpec,
      ClassType,
      width: width - padding[3] - padding[1],
      height: height - padding[2] - padding[0],
      chartInstance,
      dataId,
      data: table.getCellValue(col, row) || [],
      cellPadding: padding,
      dpr: table.internalProps.pixelRatio,
      axes: table.isPivotChart() ? table.internalProps.layoutMap.getChartAxes(col, row) : [],
      tableChartOption: table.options.chartOption,
      col,
      row
    });
    cellGroup.appendChild(chartGroup), table.internalProps.layoutMap.setChartInstance(col, row, chartGroup.chartInstance);
  }
  return cellGroup;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/checkbox-cell.js
function createCheckboxCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  if (!cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true)) && "cell" === cellGroup.role && cellGroup.setAttributes({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
      fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
      stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
      cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
      lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
  }
  let icons2;
  if (mayHaveIcon) {
    let iconCol = col, iconRow = row;
    range5 && (iconCol = range5.start.col, iconRow = range5.start.row), icons2 = table.getCellIcons(iconCol, iconRow);
  }
  let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
  if (Array.isArray(icons2) && 0 !== icons2.length) {
    const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons2, cellGroup, range5, table);
    iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, cellGroup.forEachChildren((child) => {
      "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
    }), cellGroup.forEachChildren((child) => {
      "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
    });
  }
  const checkboxComponent = createCheckbox(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
  return checkboxComponent && cellGroup.appendChild(checkboxComponent), checkboxComponent.render(), width -= padding[1] + padding[3] + iconWidth, height -= padding[0] + padding[2], "center" === textAlign ? checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - checkboxComponent.AABBBounds.width()) / 2) : "right" === textAlign ? checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - checkboxComponent.AABBBounds.width()) : checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth), "middle" === textBaseline ? checkboxComponent.setAttribute("y", padding[0] + (height - checkboxComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? checkboxComponent.setAttribute("y", padding[0] + height - checkboxComponent.AABBBounds.height()) : checkboxComponent.setAttribute("y", padding[0]), cellGroup;
}
function createCheckbox(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
  var _a, _b, _c, _d;
  const style2 = table._getCellStyle(col, row), size = getProp2("size", style2, col, row, table), spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", style2, col, row, table), defaultFill = getProp2("defaultFill", style2, col, row, table), defaultStroke = getProp2("defaultStroke", style2, col, row, table), disableFill = getProp2("disableFill", style2, col, row, table), checkedFill = getProp2("checkedFill", style2, col, row, table), checkedStroke = getProp2("checkedStroke", style2, col, row, table), disableCheckedFill = getProp2("disableCheckedFill", style2, col, row, table), disableCheckedStroke = getProp2("disableCheckedStroke", style2, col, row, table), checkIconImage = getProp2("checkIconImage", style2, col, row, table), indeterminateIconImage = getProp2("indeterminateIconImage", style2, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row);
  let isChecked, isDisabled, text2 = null !== (_a = value) && void 0 !== _a ? _a : "";
  isObject_default(value) ? (isChecked = value.checked, isDisabled = value.disable, text2 = null !== (_b = value.text) && void 0 !== _b ? _b : "") : "boolean" == typeof value && (isChecked = value, text2 = ""), isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
  const hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_c = cellStyle.autoWrapText) && void 0 !== _c ? _c : table.internalProps.autoWrapText, { lineClamp } = cellStyle, { checked, disable } = define;
  if (null == isChecked || "function" == typeof isChecked) {
    const globalChecked = getOrApply(checked, {
      col,
      row,
      table,
      context: null,
      value,
      dataValue
    });
    isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
  }
  const globalDisable = getOrApply(disable, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
    text: 1 === text2.length ? text2[0] : text2,
    maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
    textAlign: "left",
    textBaseline: "top",
    autoWrapText,
    lineClamp,
    wordBreak: "break-word",
    heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
    pickable: false,
    dx: hierarchyOffset,
    whiteSpace: 1 !== text2.length || autoWrapText ? "normal" : "no-wrap"
  }, checkboxAttributes = {
    x: 0,
    y: 0,
    text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
    icon: {
      width: Math.floor(size / 1.4),
      height: Math.floor(size / 1.4)
    },
    box: {
      width: size,
      height: size
    },
    spaceBetweenTextAndIcon,
    disabled: null !== (_d = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _d && _d
  };
  "indeterminate" === isChecked ? (checkboxAttributes.checked = void 0, checkboxAttributes.indeterminate = true) : (checkboxAttributes.checked = isChecked, checkboxAttributes.indeterminate = void 0), defaultFill && (checkboxAttributes.box.fill = defaultFill), defaultStroke && (checkboxAttributes.box.stroke = defaultStroke), disableFill && (checkboxAttributes.box.disableFill = disableFill), checkedFill && (checkboxAttributes.box.checkedFill = checkedFill), checkedStroke && (checkboxAttributes.box.checkedStroke = checkedStroke), disableCheckedFill && (checkboxAttributes.box.disableCheckedFill = disableCheckedFill), disableCheckedStroke && (checkboxAttributes.box.disableCheckedStroke = disableCheckedStroke), checkIconImage && (checkboxAttributes.icon.checkIconImage = checkIconImage), indeterminateIconImage && (checkboxAttributes.icon.indeterminateIconImage = indeterminateIconImage);
  const checkbox = new CheckBox(checkboxAttributes);
  return checkbox.name = "checkbox", checkbox;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/radio-cell.js
function createRadioCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, table, cellTheme, define, range5) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (!cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    (cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup);
  }
  const { width: radioWidth, height: radioHeight } = createRadio(col, row, colWidth, width, height, padding, cellTheme, define, cellGroup, range5, table);
  return width -= padding[1] + padding[3], height -= padding[0] + padding[2], cellGroup.forEachChildren((radioComponent) => {
    "center" === textAlign ? radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x + (width - radioWidth) / 2) : "right" === textAlign ? radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x + width - radioWidth) : radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x), "middle" === textBaseline ? radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y + (height - radioHeight) / 2) : "bottom" === textBaseline ? radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y + height - radioHeight) : radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y);
  }), cellGroup;
}
function createRadio(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, cellGroup, range5, table) {
  var _a, _b, _c, _d;
  const style2 = table._getCellStyle(col, row);
  let size = getProp2("size", style2, col, row, table), innerRadius = getProp2("innerRadius", style2, col, row, table), outerRadius = getProp2("outerRadius", style2, col, row, table);
  const spaceBetweenTextAndIcon = getProp2("spaceBetweenTextAndIcon", style2, col, row, table), spaceBetweenRadio = getProp2("spaceBetweenRadio", style2, col, row, table), defaultFill = getProp2("defaultFill", style2, col, row, table), defaultStroke = getProp2("defaultStroke", style2, col, row, table), disableFill = getProp2("disableFill", style2, col, row, table), checkedFill = getProp2("checkedFill", style2, col, row, table), checkedStroke = getProp2("checkedStroke", style2, col, row, table), disableCheckedFill = getProp2("disableCheckedFill", style2, col, row, table), disableCheckedStroke = getProp2("disableCheckedStroke", style2, col, row, table);
  isNumber_default(outerRadius) ? size = 2 * outerRadius : outerRadius = Math.round(size / 2), (!isNumber_default(innerRadius) || innerRadius < 0) && (innerRadius = Math.round(outerRadius / 7 * 3));
  const value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row), hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, { lineClamp } = cellStyle, autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
    maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
    textAlign: "left",
    textBaseline: "top",
    autoWrapText,
    lineClamp,
    wordBreak: "break-word",
    heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
    pickable: false,
    dx: hierarchyOffset
  }, radioAttributes = {
    x: 0,
    y: 0,
    text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
    circle: {
      innerRadius,
      outerRadius
    },
    spaceBetweenTextAndIcon
  };
  defaultFill && (radioAttributes.circle.fill = defaultFill), defaultStroke && (radioAttributes.circle.stroke = defaultStroke), disableFill && (radioAttributes.circle.disableFill = disableFill), checkedFill && (radioAttributes.circle.checkedFill = checkedFill), checkedStroke && (radioAttributes.circle.checkedStroke = checkedStroke), disableCheckedFill && (radioAttributes.circle.disableCheckedFill = disableCheckedFill), disableCheckedStroke && (radioAttributes.circle.disableCheckedStroke = disableCheckedStroke);
  let width = 0, height = 0;
  const direction = null !== (_b = define.radioDirectionInCell) && void 0 !== _b ? _b : "vertical";
  if (isArray_default(value)) value.forEach((item, index) => {
    var _a2, _b2;
    const radioComponent = createSingleRadio(item, dataValue, index, col, row, define, autoWrapText, radioAttributes, table);
    radioComponent && cellGroup.appendChild(radioComponent), radioComponent.id = `radio-${null !== (_a2 = null == range5 ? void 0 : range5.start.col) && void 0 !== _a2 ? _a2 : col}-${null !== (_b2 = null == range5 ? void 0 : range5.start.row) && void 0 !== _b2 ? _b2 : row}-${index}`, radioComponent.render();
    const bounds = radioComponent.AABBBounds;
    "vertical" === direction ? (radioComponent.setAttribute("y", height), height += bounds.height() + (index !== value.length - 1 ? spaceBetweenRadio : 0), width = Math.max(width, bounds.width())) : "horizontal" === direction && (radioComponent.setAttribute("x", width), width += bounds.width() + (index !== value.length - 1 ? spaceBetweenRadio : 0), height = Math.max(height, bounds.height()));
  });
  else {
    const radioComponent = createSingleRadio(value, dataValue, void 0, col, row, define, autoWrapText, radioAttributes, table);
    radioComponent && cellGroup.appendChild(radioComponent), radioComponent.id = `radio-${null !== (_c = null == range5 ? void 0 : range5.start.col) && void 0 !== _c ? _c : col}-${null !== (_d = null == range5 ? void 0 : range5.start.row) && void 0 !== _d ? _d : row}`, radioComponent.render();
    const bounds = radioComponent.AABBBounds;
    width = bounds.width(), height = bounds.height();
  }
  return {
    width,
    height
  };
}
function createSingleRadio(value, dataValue, indexInCell, col, row, define, autoWrapText, cellRadioAttributes, table) {
  const isChecked = getChecked(value, dataValue, indexInCell, col, row, define, table), isDisabled = getDisable(value, dataValue, col, row, define, table), text2 = isObject_default(value) ? value.text : isBoolean_default(value) ? "" : null != value ? value : "", radioAttributes = merge({}, cellRadioAttributes, {
    checked: isChecked,
    disabled: isDisabled,
    text: {
      text: 1 === text2.length ? text2[0] : text2,
      whiteSpace: 1 !== text2.length || autoWrapText ? "normal" : "no-wrap"
    },
    boundsPadding: 0
  }), radio = new Radio(radioAttributes);
  return radio.name = "radio", radio;
}
function getChecked(value, dataValue, indexInCell, col, row, define, table) {
  var _a, _b;
  const radioType = null !== (_a = define.radioCheckType) && void 0 !== _a ? _a : "column";
  let isChecked, globalChecked;
  return isObject_default(value) ? isChecked = value.checked : "boolean" == typeof value && (isChecked = value), isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, isChecked), null != isChecked && "function" != typeof isChecked || (globalChecked = getOrApply(define.checked, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, globalChecked)), null !== (_b = null != isChecked ? isChecked : globalChecked) && void 0 !== _b && _b;
}
function getDisable(value, dataValue, col, row, define, table) {
  var _a;
  let isDisabled;
  isObject_default(value) && (isDisabled = value.disable);
  const globalDisable = getOrApply(define.disable, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  });
  return null !== (_a = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _a && _a;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/switch-cell.js
function createSwitchCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  if (!cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true)) && "cell" === cellGroup.role && cellGroup.setAttributes({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
      fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
      stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
      cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
      lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
  }
  let icons2;
  if (mayHaveIcon) {
    let iconCol = col, iconRow = row;
    range5 && (iconCol = range5.start.col, iconRow = range5.start.row), icons2 = table.getCellIcons(iconCol, iconRow);
  }
  let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
  if (Array.isArray(icons2) && 0 !== icons2.length) {
    const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons2, cellGroup, range5, table);
    iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, cellGroup.forEachChildren((child) => {
      "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
    }), cellGroup.forEachChildren((child) => {
      "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
    });
  }
  const switchComponent = createSwitch(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
  return switchComponent && cellGroup.appendChild(switchComponent), switchComponent.render(), width -= padding[1] + padding[3] + iconWidth, height -= padding[0] + padding[2], "center" === textAlign ? switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - switchComponent.AABBBounds.width()) / 2) : "right" === textAlign ? switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - switchComponent.AABBBounds.width()) : switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth), "middle" === textBaseline ? switchComponent.setAttribute("y", padding[0] + (height - switchComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? switchComponent.setAttribute("y", padding[0] + height - switchComponent.AABBBounds.height()) : switchComponent.setAttribute("y", padding[0]), cellGroup;
}
function createSwitch(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
  var _a, _b, _c, _d;
  const style2 = table._getCellStyle(col, row), spaceBetweenTextAndCircle = getProp2("spaceBetweenTextAndCircle", style2, col, row, table), circleRadius = getProp2("circleRadius", style2, col, row, table), boxWidth = getProp2("boxWidth", style2, col, row, table), boxHeight = getProp2("boxHeight", style2, col, row, table), checkedFill = getProp2("checkedFill", style2, col, row, table), uncheckedFill = getProp2("uncheckedFill", style2, col, row, table), disableCheckedFill = getProp2("disableCheckedFill", style2, col, row, table), disableUncheckedFill = getProp2("disableUncheckedFill", style2, col, row, table), circleFill = getProp2("circleFill", style2, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row);
  let isChecked, isDisabled, text2 = null !== (_a = value) && void 0 !== _a ? _a : "";
  isObject_default(value) ? (isChecked = value.checked, isDisabled = value.disable, text2 = null !== (_b = value.text) && void 0 !== _b ? _b : "") : "boolean" == typeof value && (isChecked = value, text2 = ""), isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
  const hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_c = cellStyle.autoWrapText) && void 0 !== _c ? _c : table.internalProps.autoWrapText, { lineClamp } = cellStyle, { checked, disable, uncheckedText, checkedText } = define;
  if (null == isChecked || "function" == typeof isChecked) {
    const globalChecked = getOrApply(checked, {
      col,
      row,
      table,
      context: null,
      value,
      dataValue
    });
    isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
  }
  const globalDisable = getOrApply(disable, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), checkedTextString = getOrApply(checkedText, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), uncheckedTextString = getOrApply(uncheckedText, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
    text: 1 === text2.length ? text2[0] : text2,
    maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - 2 * circleRadius - spaceBetweenTextAndCircle,
    textAlign: "left",
    textBaseline: "top",
    autoWrapText,
    lineClamp,
    wordBreak: "break-word",
    heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
    pickable: false,
    dx: hierarchyOffset,
    whiteSpace: 1 !== text2.length || autoWrapText ? "normal" : "no-wrap",
    checkedText: checkedTextString,
    uncheckedText: uncheckedTextString
  }, switchAttributes = {
    x: 0,
    y: 0,
    text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
    circle: {
      radius: circleRadius
    },
    box: {
      width: boxWidth,
      height: boxHeight
    },
    spaceBetweenTextAndCircle,
    disabled: null !== (_d = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _d && _d
  };
  switchAttributes.checked = isChecked, uncheckedFill && (switchAttributes.box.uncheckedFill = uncheckedFill), disableUncheckedFill && (switchAttributes.box.disableUncheckedFill = disableUncheckedFill), checkedFill && (switchAttributes.box.checkedFill = checkedFill), disableCheckedFill && (switchAttributes.box.disableCheckedFill = disableCheckedFill), circleFill && (switchAttributes.circle.fill = circleFill);
  const switchComponent = new Switch(switchAttributes);
  return switchComponent.name = "switch", switchComponent;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/spark-line-cell.js
var xScale = new PointScale2();
var yScale = new LinearScale2();
function createSparkLineCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, table, cellTheme, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  if (!cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true)) && "cell" === cellGroup.role && cellGroup.setAttributes({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
      fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
      stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
      cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
      lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
  }
  const chartGroup = createSparkLine(col, row, width, height, padding, table);
  return chartGroup && cellGroup.appendChild(chartGroup), cellGroup;
}
function createSparkLine(col, row, width, height, padding, table) {
  let sparklineSpec, chartGroup;
  const chartSpecRaw = table.internalProps.layoutMap.getBody(col, row).sparklineSpec, dataValue = table.getCellValue(col, row);
  if (!Array.isArray(dataValue)) return;
  const x = padding[3], y = padding[0];
  width -= padding[1] + padding[3];
  const bottom = height -= padding[0] + padding[2];
  if ("function" == typeof chartSpecRaw) {
    const arg = {
      col,
      row,
      dataValue: table.getCellOriginValue(col, row) || "",
      value: table.getCellValue(col, row) || "",
      rect: table.getCellRangeRelativeRect(table.getCellRange(col, row)),
      table
    };
    sparklineSpec = chartSpecRaw(arg), chartGroup = createChartGroup(sparklineSpec, x, y, width, height);
  } else sparklineSpec = chartSpecRaw, chartGroup = createChartGroup(chartSpecRaw, x, y, width, height);
  const items = [], dataItems = [];
  let xField, yField;
  if ("object" == typeof sparklineSpec.xField) xScale.domain(sparklineSpec.xField.domain), xField = sparklineSpec.xField.field;
  else if ("string" == typeof sparklineSpec.xField) {
    const indexValues = dataValue.map((value) => value[sparklineSpec.xField]);
    xScale.domain(indexValues), xField = sparklineSpec.xField;
  } else Array.isArray(dataValue) && (xScale.domain(Array.from({
    length: dataValue.length
  }, (_, i) => i)), xField = sparklineSpec.xField);
  if (xScale.range([0, width]), "object" == typeof sparklineSpec.yField) yScale.domain(sparklineSpec.yField.domain), yField = sparklineSpec.yField.field;
  else if ("string" == typeof sparklineSpec.yField) {
    const values = getYNumbers(dataValue, sparklineSpec.yField);
    yScale.domain([Math.min(...values), Math.max(...values)]), yField = sparklineSpec.yField;
  } else if (Array.isArray(dataValue)) {
    const values = getYNumbers(dataValue);
    yScale.domain([Math.min(...values), Math.max(...values)]), yField = sparklineSpec.yField;
  }
  if (yScale.range([0, height]), "object" == typeof sparklineSpec.xField && Array.isArray(sparklineSpec.xField.domain)) {
    const values = dataValue.map((value) => value[sparklineSpec.xField.field]), domain = sparklineSpec.xField.domain;
    for (let i = 0; i < domain.length; i++) {
      let valid = false;
      for (let j = 0; j < values.length; j++) if (domain[i] === values[j]) {
        const data = dataValue[j];
        if (!isValid_default(data[xField]) || !isValid_default(data[yField])) break;
        items.push({
          x: 0 + xScale.scale(data[xField]),
          y: bottom - yScale.scale(data[yField]),
          defined: isValid_default(data[yField])
        }), dataItems.push(data), valid = true;
        break;
      }
      valid || (items.push({
        x: 0 + xScale.scale(domain[i]),
        y: 0,
        defined: false
      }), dataItems.push({
        [xField]: domain[i],
        [yField]: null
      }));
    }
  } else for (let i = 0; i < dataValue.length; i++) {
    const data = dataValue[i];
    items.push({
      x: 0 + xScale.scale(xField ? data[xField] : i),
      y: bottom - yScale.scale(yField ? data[yField] : data),
      defined: isValid_default(yField ? data[yField] : data),
      rawData: data
    }), dataItems.push(data);
  }
  const line = chartGroup.getChildByName("sparkline-line");
  line && line.setAttribute("points", items), line.bandwidth = xScale.step(), line.min = yScale.range()[0], line.max = yScale.range()[1];
  const symbolGroup = chartGroup.getChildByName("sparkline-symbol-group");
  if (symbolGroup) {
    const isShowIsolatedPoint = "isolatedPoint" === sparklineSpec.pointShowRule;
    if ("all" === sparklineSpec.pointShowRule) for (let i = 0; i < items.length; i++) {
      const { x: x2, y: y2, defined } = items[i];
      if (defined) {
        const symbol = createSymbol({
          x: x2,
          y: y2
        });
        symbolGroup.appendChild(symbol);
      }
    }
    else if (isShowIsolatedPoint) for (let i = 0; i < items.length; i++) {
      const { x: x2, y: y2, defined } = items[i];
      if (defined && (!items[i - 1] || !items[i - 1].defined) && (!items[i + 1] || !items[i + 1].defined)) {
        const symbol = createSymbol({
          x: x2,
          y: y2
        });
        symbolGroup.appendChild(symbol);
      }
    }
  }
  return chartGroup;
}
function createChartGroup(spec, x, y, width, height) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  let specObj;
  specObj = "function" == typeof spec ? spec(null) : spec;
  const group = new Group2({
    x,
    y,
    width,
    height,
    stroke: false,
    fill: false
  });
  if (group.name = "sparkline", "line" === specObj.type) {
    const line = createLine({
      x: 0,
      y: 0,
      curveType: specObj.smooth ? "monotoneX" : "linear",
      stroke: null !== (_c = null === (_b = null === (_a = specObj.line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.stroke) && void 0 !== _c ? _c : "blue",
      lineWidth: null !== (_f = null === (_e = null === (_d = specObj.line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.strokeWidth) && void 0 !== _f ? _f : 2
    });
    line.name = "sparkline-line", group.addChild(line), specObj.crosshair && (line.hover = null !== (_h = null === (_g = specObj.crosshair) || void 0 === _g ? void 0 : _g.style) && void 0 !== _h ? _h : {
      stroke: "#000",
      interpolate: "linear"
    });
    const symbolGroup = new Group2({
      x: 0,
      y: 0,
      width,
      height,
      stroke: false,
      fill: false
    });
    symbolGroup.name = "sparkline-symbol-group", symbolGroup.setTheme({
      symbol: {
        stroke: null !== (_l = null === (_k = null === (_j = specObj.point) || void 0 === _j ? void 0 : _j.style) || void 0 === _k ? void 0 : _k.stroke) && void 0 !== _l ? _l : "#000",
        lineWidth: null !== (_p = null === (_o = null === (_m = specObj.point) || void 0 === _m ? void 0 : _m.style) || void 0 === _o ? void 0 : _o.strokeWidth) && void 0 !== _p ? _p : 1,
        fill: null !== (_s = null === (_r = null === (_q = specObj.point) || void 0 === _q ? void 0 : _q.style) || void 0 === _r ? void 0 : _r.fill) && void 0 !== _s ? _s : "#000",
        size: 2 * (null !== (_v = null === (_u = null === (_t = specObj.point) || void 0 === _t ? void 0 : _t.style) || void 0 === _u ? void 0 : _u.size) && void 0 !== _v ? _v : 3),
        symbolType: "circle"
      }
    }), group.addChild(symbolGroup), symbolGroup.hover = null !== (_x = null === (_w = specObj.point) || void 0 === _w ? void 0 : _w.hover) && void 0 !== _x && _x;
  }
  return group;
}
function getYNumbers(data, field) {
  const numbers = [];
  for (let i = 0; i < data.length; i++) {
    const item = data[i];
    isValid_default(field) && isValid_default(item[field]) ? numbers.push(item[field]) : !isValid_default(field) && isValid_default(item) && numbers.push(item);
  }
  return numbers;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/video-cell.js
var regedIcons2 = get3();
function createVideoCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
  const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
  (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.imageMargin) ? padding = getQuadProps(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.imageMargin) : isValid_default(functionalPadding) && (padding = functionalPadding), (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textAlign) && (textAlign = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textAlign), (null === (_e = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _e ? void 0 : _e.textBaseline) && (textBaseline = null === (_f = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _f ? void 0 : _f.textBaseline);
  const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
  let cellGroup, cellIcons;
  if (isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true), cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
    x: xOrigin,
    y: yOrigin,
    width,
    height,
    lineWidth: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth) && void 0 !== _h ? _h : void 0,
    fill: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.fill) && void 0 !== _k ? _k : void 0,
    stroke: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.stroke) && void 0 !== _m ? _m : void 0,
    strokeArrayWidth,
    strokeArrayColor: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.strokeArrayColor) && void 0 !== _p ? _p : void 0,
    cursor: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.cursor) && void 0 !== _r ? _r : void 0,
    lineDash: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineDash) && void 0 !== _t ? _t : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group2({
    x: xOrigin,
    y: yOrigin,
    width,
    height,
    lineWidth: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.lineWidth) && void 0 !== _v ? _v : void 0,
    fill: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.fill) && void 0 !== _x ? _x : void 0,
    stroke: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.stroke) && void 0 !== _z ? _z : void 0,
    strokeArrayWidth,
    strokeArrayColor: null !== (_1 = null === (_0 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _0 ? void 0 : _0.strokeArrayColor) && void 0 !== _1 ? _1 : void 0,
    cursor: null !== (_3 = null === (_2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _2 ? void 0 : _2.cursor) && void 0 !== _3 ? _3 : void 0,
    lineDash: null !== (_5 = null === (_4 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _4 ? void 0 : _4.lineDash) && void 0 !== _5 ? _5 : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), mayHaveIcon) {
    let iconCol = col, iconRow = row;
    range5 && (iconCol = range5.start.col, iconRow = range5.start.row), cellIcons = table.getCellIcons(iconCol, iconRow);
  }
  let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
  if (Array.isArray(cellIcons) && 0 !== cellIcons.length) {
    const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(cellIcons, cellGroup, range5, table);
    iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, cellGroup.forEachChildren((child) => {
      "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
    }), cellGroup.forEachChildren((child) => {
      "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
    }), cellGroup._cellLeftIconWidth = cellLeftIconWidth, cellGroup._cellRightIconWidth = cellRightIconWidth;
  }
  const value = table.getCellValue(col, row), video = document.createElement("video");
  video.addEventListener("loadeddata", () => {
    imageAutoSizing && _adjustWidthHeight(col, row, video.videoWidth, video.videoHeight, table.scenegraph, padding, cellGroup);
    const { width: cellWidth, height: cellHeight, isMerge } = getCellRange(cellGroup, table);
    if (keepAspectRatio) {
      const { width: videoWidth, height: videoHeight } = calcKeepAspectRatioSize(video.videoWidth, video.videoHeight, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]), pos = calcStartPosition(0, 0, cellWidth, cellHeight, videoWidth, videoHeight, textAlign, textBaseline, padding);
      image.setAttributes({
        width: videoWidth,
        height: videoHeight,
        x: pos.x,
        y: pos.y,
        dx: 0
      });
    } else image.setAttributes({
      x: padding[3],
      y: padding[0],
      width: cellWidth - padding[1] - padding[3],
      height: cellHeight - padding[2] - padding[0],
      dy: 0
    });
    isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
    const { width: width2, height: height2 } = getCellRange(cellGroup, table), iconSize = Math.floor(Math.min(width2 - padding[1] - padding[3], height2 - padding[2] - padding[0]) / 2), anchorX = 0 + (width2 > image.attribute.width ? image.attribute.x - 0 + image.attribute.width / 2 : width2 / 2), anchorY = 0 + (height2 > image.attribute.height ? image.attribute.y - 0 + image.attribute.height / 2 : height2 / 2), imageGraphic = cellGroup.getChildByName("image", true), { dx, dy } = imageGraphic.attribute, playIcon = new Icon({
      x: anchorX - iconSize / 2,
      y: anchorY - iconSize / 2,
      width: iconSize,
      height: iconSize,
      image: regedIcons2.play.svg,
      cursor: regedIcons2.play.cursor,
      dx,
      dy
    });
    playIcon.name = "play-icon", cellGroup.appendChild(playIcon), table.scenegraph.updateNextFrame();
  }), video.onerror = () => {
    image.image = regedIcons2.damage_pic.svg;
  }, video.src = value, video.setAttribute("preload", "auto");
  const image = createImage({
    x: padding[3],
    y: padding[0],
    width: width - padding[1] - padding[3],
    height: height - padding[2] - padding[0],
    image: video,
    cursor: "pointer"
  });
  return image.name = "image", image.keepAspectRatio = keepAspectRatio, image.textAlign = textAlign, image.textBaseline = textBaseline, cellGroup.appendChild(image), cellGroup;
}

// node_modules/@visactor/vtable/es/scenegraph/graphic/mark.js
function createMark(marked, cellGroup, table) {
  if ("boolean" == typeof marked) {
    const mark = createArc({
      x: cellGroup.attribute.width,
      y: 0,
      startAngle: Math.PI / 2,
      endAngle: Math.PI,
      outerRadius: 6,
      fill: "#3073F2",
      pickable: false
    });
    mark.name = "mark", cellGroup.appendChild(mark);
  } else {
    const { bgColor = "#3073F2", shape = "sector", position = "right-top", size = 10, offset = 0 } = marked;
    let x, y, startAngle, endAngle, fill, mark;
    if ("sector" === shape) "right-top" === position ? (x = cellGroup.attribute.width - offset, y = offset, startAngle = Math.PI / 2, endAngle = Math.PI) : "left-top" === position ? (x = offset, y = offset, startAngle = 0, endAngle = Math.PI / 2) : "right-bottom" === position ? (x = cellGroup.attribute.width - offset, y = cellGroup.attribute.height - offset, startAngle = Math.PI, endAngle = Math.PI / 2 * 3) : "left-bottom" === position && (x = offset, y = cellGroup.attribute.height - offset, startAngle = Math.PI / 2 * 3, endAngle = 2 * Math.PI), fill = bgColor, mark = createArc({
      x,
      y,
      startAngle,
      endAngle,
      outerRadius: size,
      fill,
      pickable: false
    });
    else if ("triangle" === shape) {
      let x2, y2, x3, y3;
      "right-top" === position ? (x = cellGroup.attribute.width - offset, y = offset, x2 = x - size, y2 = y, x3 = x, y3 = y + size) : "left-top" === position ? (x = offset, y = offset, x2 = x + size, y2 = y, x3 = x, y3 = y + size) : "right-bottom" === position ? (x = cellGroup.attribute.width - offset, y = cellGroup.attribute.height - offset, x2 = x - size, y2 = y, x3 = x, y3 = y - size) : "left-bottom" === position && (x = offset, y = cellGroup.attribute.height - offset, x2 = x + size, y2 = y, x3 = x, y3 = y - size), fill = bgColor, mark = createPolygon({
        points: [{
          x,
          y
        }, {
          x: x2,
          y: y2
        }, {
          x: x3,
          y: y3
        }],
        fill,
        pickable: false
      });
    } else "rect" === shape && ("right-top" === position ? (x = cellGroup.attribute.width - size - offset, y = offset) : "left-top" === position ? (x = offset, y = offset) : "right-bottom" === position ? (x = cellGroup.attribute.width - size - offset, y = cellGroup.attribute.height - size - offset) : "left-bottom" === position && (x = offset, y = cellGroup.attribute.height - size - offset), fill = bgColor, mark = createRect({
      x,
      y,
      width: size,
      height: size,
      fill,
      pickable: false
    }));
    mark.name = "mark", cellGroup.appendChild(mark);
  }
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/text-cell.js
function createCellGroup(table, value, columnGroup, xOrigin, yOrigin, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;
  const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
  isValid_default(functionalPadding) && (padding = functionalPadding), (null === (_a = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _a ? void 0 : _a.textAlign) && (textAlign = null === (_b = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _b ? void 0 : _b.textAlign), (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textBaseline) && (textBaseline = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textBaseline);
  const autoRowHeight = table.isAutoRowHeight(row), autoColWidth = "auto" === colWidth, autoWrapText = null !== (_e = headerStyle.autoWrapText) && void 0 !== _e ? _e : table.internalProps.autoWrapText, lineClamp = headerStyle.lineClamp, strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
  let cellGroup;
  if (isAsync && (cellGroup = table.scenegraph.getCell(col, row, true), cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
    x: xOrigin,
    y: yOrigin,
    width: cellWidth,
    height: cellHeight,
    lineWidth: null !== (_g = null === (_f = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _f ? void 0 : _f.lineWidth) && void 0 !== _g ? _g : void 0,
    fill: null !== (_j = null === (_h = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _h ? void 0 : _h.fill) && void 0 !== _j ? _j : void 0,
    stroke: null !== (_l = null === (_k = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _k ? void 0 : _k.stroke) && void 0 !== _l ? _l : void 0,
    strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
    strokeArrayColor: null !== (_o = null === (_m = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _m ? void 0 : _m.strokeArrayColor) && void 0 !== _o ? _o : void 0,
    cursor: null !== (_q = null === (_p = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _p ? void 0 : _p.cursor) && void 0 !== _q ? _q : void 0,
    lineDash: null !== (_s = null === (_r = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _r ? void 0 : _r.lineDash) && void 0 !== _s ? _s : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group2({
    x: xOrigin,
    y: yOrigin,
    width: cellWidth,
    height: cellHeight,
    lineWidth: null !== (_u = null === (_t = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _t ? void 0 : _t.lineWidth) && void 0 !== _u ? _u : void 0,
    fill: null !== (_w = null === (_v = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _v ? void 0 : _v.fill) && void 0 !== _w ? _w : void 0,
    stroke: null !== (_y = null === (_x = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _x ? void 0 : _x.stroke) && void 0 !== _y ? _y : void 0,
    strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
    strokeArrayColor: null !== (_0 = null === (_z = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _z ? void 0 : _z.strokeArrayColor) && void 0 !== _0 ? _0 : void 0,
    cursor: null !== (_2 = null === (_1 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _1 ? void 0 : _1.cursor) && void 0 !== _2 ? _2 : void 0,
    lineDash: null !== (_4 = null === (_3 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _3 ? void 0 : _3.lineDash) && void 0 !== _4 ? _4 : void 0,
    lineCap: "butt",
    clip: true,
    cornerRadius: cellTheme.group.cornerRadius
  }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), customElementsGroup && cellGroup.appendChild(customElementsGroup), renderDefault) {
    const textStr = value;
    let icons2;
    if (mayHaveIcon) {
      let iconCol = col, iconRow = row;
      range5 && (iconCol = range5.start.col, iconRow = range5.start.row), icons2 = table.getCellIcons(iconCol, iconRow);
    }
    createCellContent(cellGroup, icons2, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, "number" == typeof lineClamp ? lineClamp : void 0, cellGroup.attribute.width, cellGroup.attribute.height, textAlign, textBaseline, table, cellTheme, range5), (null === (_5 = null == cellTheme ? void 0 : cellTheme._vtable) || void 0 === _5 ? void 0 : _5.marked) && createMark(null === (_6 = null == cellTheme ? void 0 : cellTheme._vtable) || void 0 === _6 ? void 0 : _6.marked, cellGroup, table);
  }
  return customElementsGroup && cellGroup.setAttributes({
    width: Math.max(cellGroup.attribute.width, null !== (_7 = customElementsGroup.attribute.width) && void 0 !== _7 ? _7 : 0),
    height: Math.max(cellGroup.attribute.height, null !== (_8 = customElementsGroup.attribute.height) && void 0 !== _8 ? _8 : 0)
  }), cellGroup;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/progress-bar-cell.js
function createProgressBarCell(progressBarDefine, style2, width, value, dataValue, col, row, padding, table, range5) {
  var _a, _b, _c, _d, _e;
  if (progressBarDefine.dependField) {
    const dependField = getOrApply(progressBarDefine.dependField, {
      col,
      row,
      table,
      value,
      dataValue,
      cellHeaderPaths: void 0
    });
    dataValue = null !== (_b = null === (_a = table.getCellOriginRecord(col, row)) || void 0 === _a ? void 0 : _a[dependField]) && void 0 !== _b ? _b : dataValue;
  }
  const barType = null !== (_c = getOrApply(progressBarDefine.barType, {
    col,
    row,
    table,
    value,
    dataValue,
    cellHeaderPaths: void 0
  })) && void 0 !== _c ? _c : "default", min2 = null !== (_d = getOrApply(progressBarDefine.min, {
    col,
    row,
    table,
    value,
    dataValue,
    cellHeaderPaths: void 0
  })) && void 0 !== _d ? _d : 0, max2 = null !== (_e = getOrApply(progressBarDefine.max, {
    col,
    row,
    table,
    value,
    dataValue,
    cellHeaderPaths: void 0
  })) && void 0 !== _e ? _e : min2 + 100;
  let height = 0;
  height = range5 ? table.getRowsHeight(range5.start.row, range5.end.row) : table.getRowHeight(row);
  let contentWidth = width, contentHeight = height, _contentOffset = 0;
  isNumber_default(table.theme._contentOffset) && (_contentOffset = table.theme._contentOffset);
  const percentCompleteBarGroup = new Group2({
    x: -_contentOffset,
    y: -_contentOffset,
    width: contentWidth,
    height: contentHeight
  });
  percentCompleteBarGroup.name = "progress-bar";
  const { showBar, barColor, barBgColor, barPositiveColor, barNegativeColor, barAxisColor, barRightToLeft, showBarMark, barMarkPositiveColor, barMarkNegativeColor, barMarkWidth, barMarkPosition, barMarkInBar } = style2;
  let { barHeight, barBottom, barPadding } = style2;
  1 === barPadding.length ? barPadding = [barPadding[0], barPadding[0], barPadding[0], barPadding[0]] : 2 === barPadding.length ? barPadding = [barPadding[0], barPadding[1], barPadding[0], barPadding[1]] : 3 === barPadding.length && (barPadding = [barPadding[0], barPadding[1], barPadding[2], barPadding[1]]), barPadding = barPadding.map((v, i) => {
    if ("string" == typeof v && str.endsWith(v, "%")) {
      const num = Number(v.substr(0, v.length - 1));
      return 0 === i || 2 === i ? height * num / 100 : width * num / 100;
    }
    return Number(v);
  });
  const borderWidth = getQuadProps(getProp2("borderLineWidth", style2, col, row, table)), barPaddingTop = Math.max(barPadding[0], Math.ceil(borderWidth[0] / 2));
  let barPaddingRight = Math.max(barPadding[1], Math.floor(borderWidth[1] / 2));
  const barPaddingBottom = Math.max(barPadding[2], Math.floor(borderWidth[2] / 2));
  let barPaddingLeft = Math.max(barPadding[3], Math.ceil(borderWidth[3] / 2));
  showBarMark && barMarkWidth > 0 && "right" === barMarkPosition && false === barMarkInBar && (barPaddingRight += barMarkWidth, barPaddingLeft += barMarkWidth), contentWidth -= barPaddingRight + barPaddingLeft, contentHeight -= barPaddingBottom + barPaddingTop, row === table.rowCount - 1 && [0, "0"].includes(barBottom) && (contentHeight -= 1);
  const top = barPaddingTop, left = barPaddingLeft, right = contentWidth;
  "string" == typeof barHeight && str.endsWith(barHeight, "%") ? (barHeight = Number(barHeight.substr(0, barHeight.length - 1)), barHeight = contentHeight * barHeight / 100) : barHeight = Number(barHeight), "string" == typeof barBottom && str.endsWith(barBottom, "%") ? (barBottom = Number(barBottom.substr(0, barBottom.length - 1)), barBottom = contentHeight * barBottom / 100) : barBottom = Number(barBottom);
  if (getOrApply(showBar, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  })) {
    let svalue = `${dataValue}`;
    str.endsWith(svalue, "%") && (svalue = svalue.substr(0, svalue.length - 1));
    const num = Number(svalue);
    if (isNaN(num)) return percentCompleteBarGroup;
    if ("default" === (null != barType ? barType : "default")) {
      const percentile = num < min2 ? 0 : num > max2 ? 1 : (num - min2) / (max2 - min2), barMaxWidth = contentWidth, barTop = top + contentHeight - barHeight - barBottom;
      let barSize = Math.min(barMaxWidth * percentile, barMaxWidth);
      const barLeft = barRightToLeft ? left + right - barSize : left;
      col !== table.colCount - 1 || 1 !== percentile || barRightToLeft || (barSize -= 1);
      const bgFillColor = getOrApply(barBgColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile
      });
      if (bgFillColor) {
        const barBack = createRect({
          x: barLeft,
          y: barTop,
          width: barMaxWidth,
          height: barHeight,
          fill: bgFillColor
        });
        percentCompleteBarGroup.addChild(barBack);
      }
      const fillColor = getOrApply(barColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile
      }) || "#20a8d8", barMain = createRect({
        x: barLeft,
        y: barTop,
        width: barSize,
        height: barHeight,
        fill: fillColor
      });
      percentCompleteBarGroup.addChild(barMain);
    } else if ("negative" === barType) {
      const negativeRange = min2 < 0 ? -min2 : 0, positiveRange = max2 > 0 ? max2 : 0, negativeFactor = negativeRange / (negativeRange + positiveRange), positiveFactor = 1 - negativeFactor, positiveRate = num > 0 ? num / positiveRange : 0, negativeRate = num < 0 ? -num / negativeRange : 0, barMaxWidth = contentWidth, barTop = top + contentHeight - barHeight - barBottom, barLeft = left, bgFillColor = getOrApply(barBgColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile: positiveRate
      });
      if (bgFillColor) {
        const barBack = createRect({
          x: barLeft,
          y: barTop,
          width: barMaxWidth,
          height: barHeight,
          fill: bgFillColor
        });
        percentCompleteBarGroup.addChild(barBack);
      }
      const positiveLeft = barRightToLeft ? positiveFactor * barMaxWidth : negativeFactor * barMaxWidth, barSizeNega = Math.min(barMaxWidth * negativeFactor * negativeRate, barMaxWidth), barRectNega = barRightToLeft ? {
        left: barLeft + positiveLeft,
        top: barTop,
        width: barSizeNega,
        height: barHeight
      } : {
        left: barLeft + positiveLeft - barSizeNega,
        top: barTop,
        width: barSizeNega,
        height: barHeight
      }, barNagiFillColor = getOrApply(barNegativeColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile: negativeRate
      }) || "#20a8d8", barNega = createRect({
        x: barRectNega.left,
        y: barRectNega.top,
        width: barRectNega.width,
        height: barRectNega.height,
        fill: barNagiFillColor
      });
      percentCompleteBarGroup.addChild(barNega);
      let barSizePosi = Math.min(barMaxWidth * positiveFactor * positiveRate, barMaxWidth);
      col !== table.colCount - 1 || 1 !== positiveRate || barRightToLeft || (barSizePosi -= 1);
      const barRectPosi = barRightToLeft ? {
        left: barLeft + positiveLeft - barSizePosi,
        top: barTop,
        width: barSizePosi,
        height: barHeight
      } : {
        left: barLeft + positiveLeft,
        top: barTop,
        width: barSizePosi,
        height: barHeight
      }, barPosiFillColor = getOrApply(barPositiveColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile: positiveRate
      }) || "#20a8d8", barPosi = createRect({
        x: barRectPosi.left,
        y: barRectPosi.top,
        width: barRectPosi.width,
        height: barRectPosi.height,
        fill: barPosiFillColor
      });
      percentCompleteBarGroup.addChild(barPosi);
      const lineLeft = barRightToLeft ? barRectNega.left : barRectPosi.left, lineStrokeColor = getOrApply(barAxisColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile: positiveRate
      }), line = createLine({
        x: 0,
        y: 0,
        stroke: lineStrokeColor,
        lineWidth: 1,
        lineDash: [2, 2],
        points: [{
          x: lineLeft,
          y: 0
        }, {
          x: lineLeft,
          y: height
        }]
      });
      if (percentCompleteBarGroup.addChild(line), showBarMark && (positiveRate || negativeRate)) {
        const lineWidth = barMarkWidth, points = [];
        let barMarkStrokeColor;
        if (positiveRate > 0) if (barMarkStrokeColor = getOrApply(barMarkPositiveColor, {
          col,
          row,
          table,
          context: null,
          value,
          dataValue,
          percentile: positiveRate
        }) || "#20a8d8", "right" === barMarkPosition) {
          const markLeft = barRightToLeft ? barRectPosi.left + barMarkWidth / 2 : barRectPosi.left + barRectPosi.width + (barMarkInBar ? -barMarkWidth / 2 : barMarkWidth / 2);
          points.push({
            x: markLeft,
            y: barRectPosi.top
          }), points.push({
            x: markLeft,
            y: barRectPosi.top + barRectPosi.height
          });
        } else "bottom" === barMarkPosition && (points.push({
          x: barRectPosi.left,
          y: barRectPosi.top + barRectPosi.height - barMarkWidth / 2
        }), points.push({
          x: barRectPosi.left + barRectPosi.width,
          y: barRectPosi.top + barRectPosi.height - barMarkWidth / 2
        }));
        else if (negativeRate > 0) if (barMarkStrokeColor = getOrApply(barMarkNegativeColor, {
          col,
          row,
          table,
          context: null,
          value,
          dataValue,
          percentile: negativeRate
        }) || "#20a8d8", "right" === barMarkPosition) {
          const markLeft = barRightToLeft ? barRectNega.left + barRectNega.width - barMarkWidth / 2 : barRectNega.left + barMarkWidth / 2;
          points.push({
            x: markLeft,
            y: barRectNega.top
          }), points.push({
            x: markLeft,
            y: barRectNega.top + barRectNega.height
          });
        } else "bottom" === barMarkPosition && (points.push({
          x: barRectNega.left,
          y: barRectNega.top + barRectNega.height - barMarkWidth / 2
        }), points.push({
          x: barRectNega.left + barRectNega.width,
          y: barRectNega.top + barRectNega.height - barMarkWidth / 2
        }));
        const barMark = createLine({
          x: 0,
          y: 0,
          stroke: barMarkStrokeColor,
          lineWidth,
          points
        });
        percentCompleteBarGroup.addChild(barMark);
      }
    } else if ("negative_no_axis" === barType) {
      const _negativeRange = min2 < 0 ? -min2 : 0, _positiveRange = max2 > 0 ? max2 : 0, range6 = Math.max(_negativeRange, _positiveRange), percentile = 0 === range6 ? 0 : Math.abs(num) / range6, barMaxWidth = contentWidth;
      let barSize = Math.min(barMaxWidth * percentile, barMaxWidth);
      col !== table.colCount - 1 || 1 !== percentile || barRightToLeft || (barSize -= 1);
      const barTop = top + contentHeight - barHeight - barBottom, barLeft = barRightToLeft ? left + right - barSize : left, bgFillColor = getOrApply(barBgColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile
      });
      if (bgFillColor) {
        const barBack = createRect({
          x: barLeft,
          y: barTop,
          width: barMaxWidth,
          height: barHeight,
          fill: bgFillColor
        });
        percentCompleteBarGroup.addChild(barBack);
      }
      const barRect = {
        left: barLeft,
        top: barTop,
        width: barSize,
        height: barHeight
      };
      let barRectFillColor;
      barRectFillColor = num >= 0 ? getOrApply(barPositiveColor, {
        col,
        row,
        table,
        context: null,
        value,
        percentile,
        dataValue
      }) || "#20a8d8" : getOrApply(barNegativeColor, {
        col,
        row,
        table,
        context: null,
        value,
        dataValue,
        percentile
      }) || "#20a8d8";
      const bar = createRect({
        x: barRect.left,
        y: barRect.top,
        width: barRect.width,
        height: barRect.height,
        fill: barRectFillColor
      });
      if (percentCompleteBarGroup.addChild(bar), showBarMark && num) {
        const lineWidth = barMarkWidth, points = [];
        let barMarkStrokeColor;
        if (barMarkStrokeColor = num >= 0 ? getOrApply(barMarkPositiveColor, {
          col,
          row,
          table,
          context: null,
          value,
          dataValue,
          percentile
        }) || "#20a8d8" : getOrApply(barMarkNegativeColor, {
          col,
          row,
          table,
          context: null,
          value,
          dataValue,
          percentile
        }) || "#20a8d8", "right" === barMarkPosition) {
          const markLeft = barRightToLeft ? barRect.left + barMarkWidth / 2 : barRect.left + barRect.width - barMarkWidth / 2;
          points.push({
            x: markLeft,
            y: barRect.top
          }), points.push({
            x: markLeft,
            y: barRect.top + barRect.height
          });
        } else "bottom" === barMarkPosition && (points.push({
          x: barRect.left,
          y: barRect.top + barRect.height - barMarkWidth / 2
        }), points.push({
          x: barRect.left + barRect.width,
          y: barRect.top + barRect.height - barMarkWidth / 2
        }));
        const barMark = createLine({
          x: 0,
          y: 0,
          stroke: barMarkStrokeColor,
          lineWidth,
          points
        });
        percentCompleteBarGroup.addChild(barMark);
      }
    }
  }
  return percentCompleteBarGroup;
}

// node_modules/@visactor/vtable/es/layout/chart-helper/get-axis-domain.js
function getAxisDomainRangeAndLabels(min2, max2, axisOption, isZeroAlign, axisLength, target) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
  if ((null == axisOption ? void 0 : axisOption.zero) && (min2 = Math.min(min2, 0), max2 = Math.max(max2, 0)), null == axisOption ? void 0 : axisOption.expand) {
    const domainMin = min2, domainMax = max2;
    isValid_default(axisOption.expand.min) && (min2 = domainMin - (domainMax - domainMin) * axisOption.expand.min), isValid_default(axisOption.expand.max) && (max2 = domainMax + (domainMax - domainMin) * axisOption.expand.max);
  }
  let scale6, scaleTicks;
  if (isNumber_default(null == axisOption ? void 0 : axisOption.min) && (min2 = axisOption.min), isNumber_default(null == axisOption ? void 0 : axisOption.max) && (max2 = axisOption.max), "log" === (null == axisOption ? void 0 : axisOption.type) ? (scale6 = new LogScale2(), scale6.base(null !== (_a = null == axisOption ? void 0 : axisOption.base) && void 0 !== _a ? _a : 10)) : "symlog" === (null == axisOption ? void 0 : axisOption.type) ? (scale6 = new SymlogScale2(), scale6.constant(null !== (_b = null == axisOption ? void 0 : axisOption.constant) && void 0 !== _b ? _b : 10)) : scale6 = new LinearScale2(), scale6.domain([min2, max2], !!(null == axisOption ? void 0 : axisOption.nice)), target) forceTickCountNice(scale6, target);
  else if (null == axisOption ? void 0 : axisOption.nice) {
    let tickCount = null !== (_f = null !== (_d = null === (_c = axisOption.tick) || void 0 === _c ? void 0 : _c.forceTickCount) && void 0 !== _d ? _d : null === (_e = axisOption.tick) || void 0 === _e ? void 0 : _e.tickCount) && void 0 !== _f ? _f : 10;
    isFunction_default(tickCount) && (tickCount = tickCount({
      axisLength,
      labelStyle: null !== (_h = null === (_g = null == axisOption ? void 0 : axisOption.label) || void 0 === _g ? void 0 : _g.style) && void 0 !== _h ? _h : {
        fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE
      }
    })), "accurateFirst" === axisOption.niceType && (tickCount = Math.max(10, tickCount)), isNil_default(axisOption.min) && isNil_default(axisOption.max) ? scale6.nice(tickCount) : isValid_default(axisOption.min) && isNil_default(axisOption.max) ? scale6.niceMax(tickCount) : isNil_default(axisOption.min) && isValid_default(axisOption.max) && scale6.niceMin(tickCount);
  }
  return delete scale6._niceType, scaleTicks = (null !== (_k = null === (_j = null == target ? void 0 : target.targetTicks) || void 0 === _j ? void 0 : _j.length) && void 0 !== _k ? _k : null === (_l = null == axisOption ? void 0 : axisOption.tick) || void 0 === _l ? void 0 : _l.forceTickCount) ? scale6.forceTicks(null !== (_o = null === (_m = null == target ? void 0 : target.targetTicks) || void 0 === _m ? void 0 : _m.length) && void 0 !== _o ? _o : null === (_p = null == axisOption ? void 0 : axisOption.tick) || void 0 === _p ? void 0 : _p.forceTickCount) : scale6.ticks(isNumber_default(null === (_q = null == axisOption ? void 0 : axisOption.tick) || void 0 === _q ? void 0 : _q.tickCount) ? axisOption.tick.tickCount : 5, {
    noDecimals: null === (_r = null == axisOption ? void 0 : axisOption.tick) || void 0 === _r ? void 0 : _r.noDecimals
  }), {
    range: scale6.domain(),
    ticks: scaleTicks
  };
}
function forceTickCountNice(scale6, target) {
  scale6.niceMax(target.targetTicks.length);
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/button-cell.js
function createButtonCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range5, isAsync) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  if (!cellGroup) {
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true)) && "cell" === cellGroup.role && cellGroup.setAttributes({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
      fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
      stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
      cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
      lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group2({
      x: xOrigin,
      y: yOrigin,
      width,
      height,
      lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
      fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
      stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
      strokeArrayWidth,
      strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
      cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
      lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
      lineCap: "butt",
      clip: true,
      cornerRadius: cellTheme.group.cornerRadius
    })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
  }
  let icons2;
  if (mayHaveIcon) {
    let iconCol = col, iconRow = row;
    range5 && (iconCol = range5.start.col, iconRow = range5.start.row), icons2 = table.getCellIcons(iconCol, iconRow);
  }
  let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
  if (Array.isArray(icons2) && 0 !== icons2.length) {
    const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons2, cellGroup, range5, table);
    iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, cellGroup.forEachChildren((child) => {
      "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
    }), cellGroup.forEachChildren((child) => {
      "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
    });
  }
  const buttonComponent = createButton(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
  return buttonComponent && cellGroup.appendChild(buttonComponent), width -= padding[1] + padding[3] + iconWidth, height -= padding[0] + padding[2], "center" === textAlign ? buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - buttonComponent.AABBBounds.width()) / 2) : "right" === textAlign ? buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - buttonComponent.AABBBounds.width()) : buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth), "middle" === textBaseline ? buttonComponent.setAttribute("y", padding[0] + (height - buttonComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? buttonComponent.setAttribute("y", padding[0] + height - buttonComponent.AABBBounds.height()) : buttonComponent.setAttribute("y", padding[0]), cellGroup;
}
function createButton(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
  var _a, _b;
  const style2 = table._getCellStyle(col, row), buttonColor = getProp2("buttonColor", style2, col, row, table), buttonBorderColor = getProp2("buttonBorderColor", style2, col, row, table), buttonLineWidth = getProp2("buttonLineWidth", style2, col, row, table), buttonBorderRadius = getProp2("buttonBorderRadius", style2, col, row, table), buttonHoverColor = getProp2("buttonHoverColor", style2, col, row, table), buttonHoverBorderColor = getProp2("buttonHoverBorderColor", style2, col, row, table), buttonPadding = getProp2("buttonPadding", style2, col, row, table), buttonTextHoverColor = getProp2("buttonTextHoverColor", style2, col, row, table), buttonDisableColor = getProp2("buttonDisableColor", style2, col, row, table), buttonDisableBorderColor = getProp2("buttonDisableBorderColor", style2, col, row, table), buttonTextDisableColor = getProp2("buttonTextDisableColor", style2, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row), hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, { lineClamp } = cellStyle, autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), { disable, text: text2 } = define, isDisable = getOrApply(disable, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), buttonTextValue = getOrApply(text2, {
    col,
    row,
    table,
    context: null,
    value,
    dataValue
  }), buttonText = null !== (_b = null != buttonTextValue ? buttonTextValue : value) && void 0 !== _b ? _b : "", attribute = {
    maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
    textAlign: "left",
    textBaseline: "top",
    autoWrapText,
    lineClamp,
    wordBreak: "break-word",
    heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
    pickable: false,
    dx: hierarchyOffset,
    whiteSpace: 1 !== buttonText.length || autoWrapText ? "normal" : "no-wrap"
  }, testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute, buttonAttributes = {
    x: 0,
    y: 0,
    cursor: isDisable ? "not-allowed" : "pointer",
    disable: isDisable,
    childrenPickable: false,
    text: 1 === buttonText.length ? buttonText[0] : buttonText,
    textStyle: testAttribute,
    padding: buttonPadding,
    panel: {
      visible: true,
      fill: isDisable ? buttonDisableColor : buttonColor,
      stroke: isDisable ? buttonDisableBorderColor : buttonBorderColor,
      lineWidth: buttonLineWidth,
      cornerRadius: buttonBorderRadius
    },
    state: {
      text: {
        hover: {}
      },
      panel: {
        hover: {
          fill: buttonHoverColor,
          stroke: buttonHoverBorderColor
        }
      }
    }
  };
  buttonTextDisableColor && (buttonAttributes.state.text.fill = buttonTextDisableColor), buttonTextHoverColor && (buttonAttributes.state.text.hover.fill = buttonTextHoverColor);
  const buttonComponent = new Tag(buttonAttributes);
  return buttonComponent.name = "button", isDisable || (buttonComponent.addEventListener("mouseenter", () => {
    buttonComponent.addState("hover", true, false), buttonComponent.stage.renderNextFrame();
  }), buttonComponent.addEventListener("mouseleave", () => {
    buttonComponent.removeState("hover", false), buttonComponent.stage.renderNextFrame();
  })), buttonComponent;
}

// node_modules/@visactor/vtable/es/scenegraph/group-creater/cell-type/index.js
var registerChartCell = () => {
  Factory2.registerFunction("createChartCellGroup", createChartCellGroup), Factory2.registerFunction("getAxisDomainRangeAndLabels", getAxisDomainRangeAndLabels);
};
var registerCheckboxCell = () => {
  Factory2.registerFunction("createCheckboxCellGroup", createCheckboxCellGroup);
};
var registerImageCell = () => {
  Factory2.registerFunction("createImageCellGroup", createImageCellGroup);
};
var registerProgressBarCell = () => {
  Factory2.registerFunction("createProgressBarCell", createProgressBarCell);
};
var registerRadioCell = () => {
  Factory2.registerFunction("createRadioCellGroup", createRadioCellGroup);
};
var registerSwitchCell = () => {
  Factory2.registerFunction("createSwitchCellGroup", createSwitchCellGroup);
};
var registerButtonCell = () => {
  Factory2.registerFunction("createButtonCellGroup", createButtonCellGroup);
};
var registerSparkLineCell = () => {
  Factory2.registerFunction("createSparkLineCellGroup", createSparkLineCellGroup);
};
var registerTextCell = () => {
  Factory2.registerFunction("createTextCellGroup", createCellGroup);
};
var registerVideoCell = () => {
  Factory2.registerFunction("createVideoCellGroup", createVideoCellGroup);
};

// node_modules/@visactor/vtable/es/ListTable-all.js
registerAxis(), registerEmptyTip(), registerLegend(), registerMenu(), registerTitle(), registerTooltip(), registerListTreeStickCellPlugin(), registerCustomCellStylePlugin(), registerChartCell(), registerCheckboxCell(), registerImageCell(), registerProgressBarCell(), registerRadioCell(), registerSwitchCell(), registerButtonCell(), registerSparkLineCell(), registerTextCell(), registerVideoCell();
var ListTableAll = class extends ListTable {
};

// node_modules/@visactor/vtable/es/ListTable-simple.js
registerTextCell();
var ListTableSimple = class extends ListTable {
};

// node_modules/@visactor/vtable/es/tools/diff-cell.js
function diffCellAddress(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
  const columnHeaderStart = layout.columnHeaderLevelCount, addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
  for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
  for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
    const newCellAddr = {
      col,
      row: columnHeaderStart + i
    };
    addCellPositionsRowDirection.push(newCellAddr);
  }
  let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
  const updateCellPositionsRowDirection = [];
  for (parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress); parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), updateCellPositionsRowDirection.push(parentCellAddress));
  return {
    addCellPositionsRowDirection,
    removeCellPositionsRowDirection,
    updateCellPositionsRowDirection
  };
}
function diffCellAddressForGridTree(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
  const columnHeaderStart = layout.columnHeaderLevelCount, addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
  for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
  for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
    const newCellAddr = {
      col,
      row: columnHeaderStart + i
    };
    addCellPositionsRowDirection.push(newCellAddr);
  }
  let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
  const updateCellPositionsRowDirection = [];
  for (parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress); parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), updateCellPositionsRowDirection.push(parentCellAddress));
  const addCellPositionsColumnDirection = [], removeCellPositionsColumnDirection = [];
  if ("grid-tree" === layout.rowHierarchyType && "column" === layout.cornerSetting.titleOnDimension && layout.rowHeaderLevelCount !== layout._cornerHeaderCellIds[0].length) if (layout.rowHeaderLevelCount > layout._cornerHeaderCellIds[0].length) for (let i = layout._cornerHeaderCellIds[0].length; i < layout.rowHeaderLevelCount; i++) addCellPositionsColumnDirection.push({
    col: i,
    row
  });
  else for (let i = layout.rowHeaderLevelCount; i < layout._cornerHeaderCellIds[0].length; i++) removeCellPositionsColumnDirection.push({
    col: i,
    row
  });
  return {
    addCellPositionsRowDirection,
    removeCellPositionsRowDirection,
    updateCellPositionsRowDirection,
    addCellPositionsColumnDirection,
    removeCellPositionsColumnDirection
  };
}
function diffCellAddressForGridTreeOnColumn(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
  const rowHeaderStart = layout.rowHeaderLevelCount, addCellPositionsColumnDirection = [], removeCellPositionsColumnDirection = [];
  for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsColumnDirection.push(oldRowHeaderCellPositons[i]);
  for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
    const newCellAddr = {
      col: rowHeaderStart + i,
      row
    };
    addCellPositionsColumnDirection.push(newCellAddr);
  }
  let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
  const updateCellPositionsColumnDirection = [];
  for (parentCellAddress && updateCellPositionsColumnDirection.push(parentCellAddress); parentCellAddress && parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), updateCellPositionsColumnDirection.push(parentCellAddress));
  const addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
  if ("grid-tree" === layout.columnHierarchyType && "row" === layout.cornerSetting.titleOnDimension && layout.columnHeaderLevelCount !== layout._cornerHeaderCellIds.length) if (layout.columnHeaderLevelCount > layout._cornerHeaderCellIds.length) for (let i = layout._cornerHeaderCellIds.length; i < layout.columnHeaderLevelCount; i++) addCellPositionsRowDirection.push({
    col,
    row: i
  });
  else for (let i = layout.columnHeaderLevelCount; i < layout._cornerHeaderCellIds.length; i++) removeCellPositionsRowDirection.push({
    col,
    row: i
  });
  return {
    addCellPositionsColumnDirection,
    removeCellPositionsColumnDirection,
    updateCellPositionsColumnDirection,
    addCellPositionsRowDirection,
    removeCellPositionsRowDirection
  };
}

// node_modules/@visactor/vtable/es/layout/pivot-header-layout.js
var defaultDimension = {
  startInTotal: 0,
  afterSpanLevel: 0
};
var PivotHeaderLayoutMap = class {
  constructor(table, dataset, columnDimensionTree, rowDimensionTree) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    this.colIndex = 0, this._showHeader = true, this.columnHeaderObjs = [], this.rowHeaderObjs = [], this._cornerHeaderCellFullPathIds = [], this._columnHeaderCellFullPathIds = [], this._rowHeaderCellFullPathIds = [], this._rowHeaderCellFullPathIds_FULL = [], this._cornerHeaderCellIds = [], this._columnHeaderCellIds = [], this._rowHeaderCellIds = [], this._rowHeaderCellIds_FULL = [], this._columnWidths = [], this.columnPaths = [], this._headerObjects = [], this._headerObjectMap = {}, this._indicators = [], this.indicatorsAsCol = true, this.hideIndicatorName = false, this._showRowHeader = true, this._showColumnHeader = true, this._indicatorShowType = "column", this.rowHierarchyTextStartAlignment = false, this.rowDimensionKeys = [], this.colDimensionKeys = [], this.indicatorKeys = [], this.indicatorDimensionKey = IndicatorDimensionKeyPlaceholder, this._rowHeaderExtensionTree = {}, this._extensionRowDimensionKeys = [], this.fullRowDimensionKeys = [], this.leftRowSeriesNumberColumnCount = 0, this.rightRowSeriesNumberColumnCount = 0, this._useGetBodyCache = false, this._getBodyCache = /* @__PURE__ */ new Map(), this._useHeaderPathCache = false, this._colHeaderPathCache = /* @__PURE__ */ new Map(), this._rowHeaderPathCache = /* @__PURE__ */ new Map(), this.sharedVar = table.layoutNodeId, this._table = table, "tree" === table.options.rowHierarchyType && (this.extensionRows = table.options.extensionRows), this.dataset = dataset, this._largeCellRangeCache = [], this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this.rowTree = table.internalProps.rowTree, this.columnTree = table.internalProps.columnTree, this.rowsDefine = null !== (_a = table.internalProps.rows) && void 0 !== _a ? _a : [], this.columnsDefine = null !== (_b = table.internalProps.columns) && void 0 !== _b ? _b : [], this.indicatorsDefine = null !== (_c = table.internalProps.indicators) && void 0 !== _c ? _c : [], this.indicatorTitle = table.options.indicatorTitle, this.indicatorsAsCol = null === (_d = table.options.indicatorsAsCol) || void 0 === _d || _d, this.hideIndicatorName = null !== (_e = table.options.hideIndicatorName) && void 0 !== _e && _e, this.showRowHeader = null === (_f = table.options.showRowHeader) || void 0 === _f || _f, this.showColumnHeader = null === (_g = table.options.showColumnHeader) || void 0 === _g || _g, this.rowHeaderTitle = table.options.rowHeaderTitle, this.columnHeaderTitle = table.options.columnHeaderTitle, this.rowHierarchyType = null !== (_h = table.options.rowHierarchyType) && void 0 !== _h ? _h : "grid", this.columnHierarchyType = null !== (_j = table.options.columnHierarchyType) && void 0 !== _j ? _j : "grid", this.rowExpandLevel = null !== (_k = table.options.rowExpandLevel) && void 0 !== _k ? _k : 1, this.columnExpandLevel = null !== (_l = table.options.columnExpandLevel) && void 0 !== _l ? _l : 1, this.rowHierarchyIndent = null !== (_m = table.options.rowHierarchyIndent) && void 0 !== _m ? _m : 20, this.rowHierarchyTextStartAlignment = table.options.rowHierarchyTextStartAlignment, this.cornerSetting = Object.assign({
      titleOnDimension: "column",
      forceShowHeader: false
    }, table.options.corner), (null === (_p = null === (_o = this._table.options) || void 0 === _o ? void 0 : _o.customConfig) || void 0 === _p ? void 0 : _p.enablePivotPathCache) && (this._useHeaderPathCache = true, this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear()), dataset && (this.rowTree = dataset.rowHeaderTree, this.columnTree = dataset.colHeaderTree), null === (_q = this.indicatorsDefine) || void 0 === _q || _q.forEach((indicator) => {
      "string" == typeof indicator ? this.indicatorKeys.push(indicator) : this.indicatorKeys.push(indicator.indicatorKey);
    }), this.columnDimensionTree = columnDimensionTree, this.rowDimensionTree = rowDimensionTree, this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr(), this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys), this.resetRowHeaderLevelCount(), this._table.isPivotChart() && (this.hasTwoIndicatorAxes = this.indicatorsDefine.some((indicatorObject) => {
      var _a2, _b2;
      if (indicatorObject.chartSpec && indicatorObject.chartSpec.series && indicatorObject.chartSpec.series.length > 1) {
        const axes = null !== (_b2 = null !== (_a2 = indicatorObject.chartSpec.axes) && void 0 !== _a2 ? _a2 : this._table.pivotChartAxes) && void 0 !== _b2 ? _b2 : [];
        if (!axes.length || axes.every((axis) => axis.orient !== (this.indicatorsAsCol ? "top" : "right") || false !== axis.visible)) return true;
      }
      return false;
    })), this.resetColumnHeaderLevelCount(), this._generateColHeaderIds(), this.colIndex = 0, this._generateRowHeaderIds(), this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), "tree" === table.options.rowHierarchyType && (null === (_r = this.extensionRows) || void 0 === _r ? void 0 : _r.length) >= 1 && (this.generateExtensionRowTree(), this.extensionRows.forEach((extensionRow) => {
      const rowKeys = [];
      extensionRow.rows.forEach((row) => {
        "string" == typeof row ? rowKeys.push(row) : rowKeys.push(row.dimensionKey);
      }), this._extensionRowDimensionKeys.push(rowKeys), this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(rowKeys);
    })), this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
    let rowDimensionKeys, colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr();
    !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_t = null === (_s = this.dataset.records) || void 0 === _s ? void 0 : _s.length) && void 0 !== _t ? _t : 0) || this.dataset.customColTree || (colDimensionKeys = this.columnsDefine.map((define) => "string" == typeof define ? define : define.dimensionKey), this.indicatorsAsCol && colDimensionKeys.push(this.indicatorDimensionKey)), colDimensionKeys = this.columnHeaderTitle ? [""].concat(colDimensionKeys) : colDimensionKeys;
    let extensionRowDimensions = [];
    if ("tree" === this.rowHierarchyType && (null === (_u = this.extensionRows) || void 0 === _u ? void 0 : _u.length) >= 1) {
      const rowTreeFirstKey = [];
      rowTreeFirstKey.push(this.rowDimensionKeys[0]), this._extensionRowDimensionKeys.forEach((extensionRowKeys) => {
        rowTreeFirstKey.push(extensionRowKeys[0]);
      }), extensionRowDimensions = this.extensionRows.reduce((dimensions, cur) => dimensions.concat(cur.rows), []), rowDimensionKeys = this.rowHeaderTitle ? [""].concat(rowTreeFirstKey) : rowTreeFirstKey;
    } else rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_w = null === (_v = this.dataset.records) || void 0 === _v ? void 0 : _v.length) && void 0 !== _w ? _w : 0) || this.dataset.customRowTree || (rowDimensionKeys = this.rowsDefine.map((define) => "string" == typeof define ? define : define.dimensionKey), this.indicatorsAsCol || rowDimensionKeys.push(this.indicatorDimensionKey)), rowDimensionKeys = this.rowHeaderTitle ? [""].concat(rowDimensionKeys) : rowDimensionKeys;
    this.cornerHeaderObjs = this._addCornerHeaders(colDimensionKeys, rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine, ...extensionRowDimensions)), this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce((o, e) => (o[e.id] = e, o), {}), this.indicatorsAsCol && !this.hideIndicatorName ? this._indicatorShowType = "column" : this.indicatorsAsCol || this.hideIndicatorName ? this._indicatorShowType = "none" : this._indicatorShowType = "row", this.generateCellIdsConsiderHideHeader(), this.setPagination(table.options.pagination), this._table.isPivotChart() && (this._chartItemSpanSize = 0, this._chartItemBandSize = 0, this._indicators.find((indicatorObject) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      (null === (_a2 = null == indicatorObject ? void 0 : indicatorObject.style) || void 0 === _a2 ? void 0 : _a2.padding) && (this._chartPadding = indicatorObject.style.padding), (null === (_b2 = indicatorObject.chartSpec) || void 0 === _b2 ? void 0 : _b2.barWidth) && "number" == typeof indicatorObject.chartSpec.barWidth && (this._chartItemSpanSize = null === (_c2 = indicatorObject.chartSpec) || void 0 === _c2 ? void 0 : _c2.barWidth);
      const bandAxisConfig = null === (_e2 = null === (_d2 = indicatorObject.chartSpec) || void 0 === _d2 ? void 0 : _d2.axes) || void 0 === _e2 ? void 0 : _e2.find((axis) => "band" === axis.type);
      return (null == bandAxisConfig ? void 0 : bandAxisConfig.bandSize) && (this._chartItemBandSize = null == bandAxisConfig ? void 0 : bandAxisConfig.bandSize, this._chartPaddingInner = null !== (_f2 = isArray_default(bandAxisConfig.paddingInner) ? bandAxisConfig.paddingInner[0] : bandAxisConfig.paddingInner) && void 0 !== _f2 ? _f2 : 0, this._chartPaddingOuter = null !== (_g2 = isArray_default(bandAxisConfig.paddingOuter) ? bandAxisConfig.paddingOuter[0] : bandAxisConfig.paddingOuter) && void 0 !== _g2 ? _g2 : 0), this._chartItemSpanSize > 0 || (null === (_h2 = indicatorObject.chartSpec.series) || void 0 === _h2 || _h2.find((seriesObject) => (seriesObject.barWidth && "number" == typeof seriesObject.barWidth && (this._chartItemSpanSize = seriesObject.barWidth), this._chartItemSpanSize > 0)), false);
    })), this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber), this.setColumnWidths();
  }
  handleRowSeriesNumber(rowSeriesNumber) {
    var _a;
    rowSeriesNumber && (Array.isArray(rowSeriesNumber) ? this.rowSeriesNumberColumn = rowSeriesNumber.map((seriesNumber) => {
      var _a2;
      return {
        id: "",
        title: seriesNumber.title,
        define: seriesNumber,
        cellType: null !== (_a2 = seriesNumber.cellType) && void 0 !== _a2 ? _a2 : "text",
        headerType: seriesNumber.cellType && "radio" !== seriesNumber.cellType ? seriesNumber.cellType : "text",
        width: seriesNumber.width,
        style: seriesNumber.style,
        format: seriesNumber.format,
        field: seriesNumber.field,
        icon: seriesNumber.icon,
        headerIcon: seriesNumber.headerIcon,
        isChildNode: false
      };
    }) : this.rowSeriesNumberColumn = [{
      id: "",
      title: rowSeriesNumber.title,
      define: rowSeriesNumber,
      cellType: null !== (_a = rowSeriesNumber.cellType) && void 0 !== _a ? _a : "text",
      headerType: rowSeriesNumber.cellType && "radio" !== rowSeriesNumber.cellType ? rowSeriesNumber.cellType : "text",
      style: rowSeriesNumber.style,
      width: rowSeriesNumber.width,
      format: rowSeriesNumber.format,
      field: "",
      icon: rowSeriesNumber.icon,
      headerIcon: rowSeriesNumber.headerIcon,
      isChildNode: false
    }], this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem) => true), this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem) => false), this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length, this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length);
  }
  _generateColHeaderIds() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((null === (_a = this.columnDimensionTree.tree.children) || void 0 === _a ? void 0 : _a.length) >= 1) if ("grid-tree" === this.columnHierarchyType) {
      const startCol = 0;
      this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startCol, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), true, this.columnsDefine, this.columnHeaderObjs, false);
    } else {
      let startRow = 0;
      if (this.dataset && !this._table.isPivotChart() && 0 === (null !== (_c = null === (_b = this.dataset.records) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) && !this.dataset.customColTree && !this.dataset.customRowTree && this.indicatorsAsCol && this._getColumnHeaderTreeExpandedMaxLevelCount() < this.columnHeaderLevelCount) {
        startRow = this.columnHeaderLevelCount - this._getColumnHeaderTreeExpandedMaxLevelCount();
        for (let i = 0; i < startRow; i++) this._columnHeaderCellFullPathIds.unshift([]);
      }
      this._addHeaders(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnHeaderObjs);
    }
    if (this.columnHeaderTitle) {
      this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
      const id = ++this.sharedVar.seqId, firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
      this._columnHeaderCellFullPathIds.unshift(firstRowIds);
      const cell = {
        id,
        title: "string" == typeof this.columnHeaderTitle.title ? this.columnHeaderTitle.title : this.columnsDefine.reduce((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`), ""),
        field: void 0,
        headerType: null !== (_e = null === (_d = this.columnHeaderTitle) || void 0 === _d ? void 0 : _d.headerType) && void 0 !== _e ? _e : "text",
        style: null === (_f = this.columnHeaderTitle) || void 0 === _f ? void 0 : _f.headerStyle,
        define: {
          id,
          disableHeaderHover: !!(null === (_g = this.columnHeaderTitle) || void 0 === _g ? void 0 : _g.disableHeaderHover),
          disableHeaderSelect: !!(null === (_h = this.columnHeaderTitle) || void 0 === _h ? void 0 : _h.disableHeaderSelect)
        }
      };
      this.columnHeaderObjs.push(cell), this._headerObjects[id] = cell;
    }
  }
  _generateRowHeaderIds() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if ((null === (_a = this.rowDimensionTree.tree.children) || void 0 === _a ? void 0 : _a.length) >= 1) if ("tree" === this.rowHierarchyType) this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, true, this.rowsDefine, this.rowHeaderObjs);
    else if ("grid-tree" === this.rowHierarchyType) {
      const startRow = 0;
      this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), true, this.rowsDefine, this.rowHeaderObjs, true);
    } else {
      let startRow = 0;
      if (this.dataset && !this._table.isPivotChart() && 0 === (null !== (_c = null === (_b = this.dataset.records) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) && !this.dataset.customColTree && !this.dataset.customRowTree && !this.indicatorsAsCol && this._getRowHeaderTreeExpandedMaxLevelCount() < this.rowHeaderLevelCount) {
        startRow = this.rowHeaderLevelCount - this._getRowHeaderTreeExpandedMaxLevelCount();
        for (let i = 0; i < startRow; i++) this._rowHeaderCellFullPathIds_FULL.unshift([]);
      }
      this._addHeaders(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowHeaderObjs);
    }
    if (this.rowHeaderTitle) {
      this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
      const id = ++this.sharedVar.seqId, firstColIds = Array(null !== (_e = null === (_d = this._rowHeaderCellFullPathIds_FULL[0]) || void 0 === _d ? void 0 : _d.length) && void 0 !== _e ? _e : this.rowDimensionTree.tree.size).fill(id);
      this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
      const cell = {
        id,
        title: "string" == typeof this.rowHeaderTitle.title ? this.rowHeaderTitle.title : this.rowsDefine.reduce((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`), ""),
        field: void 0,
        headerType: null !== (_g = null === (_f = this.rowHeaderTitle) || void 0 === _f ? void 0 : _f.headerType) && void 0 !== _g ? _g : "text",
        style: null === (_h = this.rowHeaderTitle) || void 0 === _h ? void 0 : _h.headerStyle,
        define: {
          id,
          disableHeaderHover: !!(null === (_j = this.rowHeaderTitle) || void 0 === _j ? void 0 : _j.disableHeaderHover),
          disableHeaderSelect: !!(null === (_k = this.rowHeaderTitle) || void 0 === _k ? void 0 : _k.disableHeaderSelect)
        }
      };
      this.rowHeaderObjs.push(cell), this._headerObjects[id] = cell;
    }
  }
  _getRowHeaderTreeExpandedMaxLevelCount() {
    return "tree" === this.rowHierarchyType ? 1 : "grid-tree" === this.rowHierarchyType ? "row" === this.cornerSetting.titleOnDimension ? this.rowDimensionTree.totalLevel : this.indicatorsAsCol ? this.rowDimensionTree.expandedMaxLevel : this.rowDimensionTree.expandedMaxLevel + 1 : this.rowDimensionTree.totalLevel;
  }
  _getColumnHeaderTreeExpandedMaxLevelCount() {
    return "grid-tree" === this.columnHierarchyType ? "column" === this.cornerSetting.titleOnDimension ? this.columnDimensionTree.totalLevel : false === this.indicatorsAsCol ? this.columnDimensionTree.expandedMaxLevel : this.columnDimensionTree.expandedMaxLevel + 1 : this.columnDimensionTree.totalLevel;
  }
  _addHeaders(_headerCellIds, row, header, roots2, results) {
    const _this = this;
    _headerCellIds[row] || function(row2) {
      const newRow = _headerCellIds[row2] = [];
      if (0 === _this.colIndex) return newRow;
      const prev = _headerCellIds[row2 - 1];
      for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
    }(row);
    for (let i = 0; i < header.length; i++) {
      const hd = header[i];
      dealHeader(hd, _headerCellIds, results, roots2, row, this);
    }
  }
  _addHeadersForTreeMode(_headerCellIds, row, header, roots2, totalLevel, show, dimensions, results) {
    const _this = this;
    _headerCellIds[row] || function(row2) {
      const newRow = _headerCellIds[row2] = [];
      if (0 === _this.colIndex) return newRow;
      const prev = _headerCellIds[row2 - 1];
      for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
    }(row);
    for (let i = 0; i < header.length; i++) {
      const hd = header[i];
      dealHeaderForTreeMode(hd, _headerCellIds, results, roots2, row, totalLevel, show, dimensions, this);
    }
  }
  _addHeadersForGridTreeMode(_headerCellIds, row, header, roots2, totalLevel, expandedMaxLevel, show, dimensions, results, isRowTree) {
    const _this = this;
    _headerCellIds[row] || function(row2) {
      const newRow = _headerCellIds[row2] = [];
      if (0 === _this.colIndex) return newRow;
      const prev = _headerCellIds[row2 - 1];
      for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
    }(row);
    for (let i = 0; i < header.length; i++) {
      const hd = header[i];
      dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots2, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, this.indicatorsAsCol, this);
    }
  }
  _addCornerHeaders(colDimensionKeys, rowDimensionKeys, dimensions) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this._cornerHeaderCellFullPathIds = [];
    const results = [], colLevelCount = "grid-tree" === this.columnHierarchyType && this._getColumnHeaderTreeExpandedMaxLevelCount() || this.columnHeaderLevelCount, rowLevelCount = "grid-tree" === this.rowHierarchyType && this._getRowHeaderTreeExpandedMaxLevelCount() || this.rowHeaderLevelCount;
    if (0 === colLevelCount || 0 === rowLevelCount) return results;
    if ("all" === this.cornerSetting.titleOnDimension) if (this.indicatorsAsCol) {
      if (colDimensionKeys) for (let i = 0; i < colLevelCount; i++) {
        const dimensionKey = colDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey), cell = {
          id,
          title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
          field: dimensionKey,
          style: this.cornerSetting.headerStyle,
          headerType: null !== (_a = this.cornerSetting.headerType) && void 0 !== _a ? _a : "text",
          showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
          sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
          define: {
            showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
            sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
            dimensionKey,
            id,
            value: dimensionKey,
            headerEditor: this.cornerSetting.headerEditor,
            disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
            disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
          },
          dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
          headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
          pivotInfo: {
            value: null !== (_b = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _b ? _b : "",
            dimensionKey,
            isPivotCorner: true
          },
          description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
        };
        results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[i] || (this._cornerHeaderCellFullPathIds[i] = []);
        for (let r = 0; r < rowLevelCount; r++) this._cornerHeaderCellFullPathIds[i][r] = id;
      }
      if (rowDimensionKeys) for (let i = 0; i < rowLevelCount; i++) {
        const dimensionKey = rowDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey), cell = {
          id,
          title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
          field: dimensionKey,
          style: this.cornerSetting.headerStyle,
          headerType: null !== (_c = this.cornerSetting.headerType) && void 0 !== _c ? _c : "text",
          showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
          sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
          define: {
            showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
            sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
            dimensionKey,
            id,
            value: dimensionKey,
            headerEditor: this.cornerSetting.headerEditor,
            disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
            disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
          },
          dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
          headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
          pivotInfo: {
            value: null !== (_d = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _d ? _d : "",
            dimensionKey,
            isPivotCorner: true
          },
          description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
        };
        results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1] || (this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1] = []), this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1][i] = id;
      }
    } else {
      if (rowDimensionKeys) for (let i = 0; i < rowLevelCount; i++) {
        const dimensionKey = rowDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey), cell = {
          id,
          title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
          field: dimensionKey,
          style: this.cornerSetting.headerStyle,
          headerType: null !== (_e = this.cornerSetting.headerType) && void 0 !== _e ? _e : "text",
          showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
          sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
          define: {
            showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
            sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
            dimensionKey,
            id,
            value: dimensionKey,
            headerEditor: this.cornerSetting.headerEditor,
            disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
            disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
          },
          dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
          headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
          pivotInfo: {
            value: null !== (_f = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _f ? _f : "",
            dimensionKey,
            isPivotCorner: true
          },
          description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
        };
        results[id] = cell, this._headerObjects[id] = cell;
        for (let r = 0; r < colLevelCount; r++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), this._cornerHeaderCellFullPathIds[r][i] = id;
      }
      if (colDimensionKeys) for (let c2 = 0; c2 < colLevelCount; c2++) {
        const dimensionKey = colDimensionKeys[c2], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey), cell = {
          id,
          title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
          field: dimensionKey,
          style: this.cornerSetting.headerStyle,
          headerType: null !== (_g = this.cornerSetting.headerType) && void 0 !== _g ? _g : "text",
          showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
          sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
          define: {
            showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
            sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
            dimensionKey,
            id,
            value: dimensionKey,
            headerEditor: this.cornerSetting.headerEditor,
            disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
            disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
          },
          dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
          headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
          pivotInfo: {
            value: null !== (_h = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _h ? _h : "",
            dimensionKey,
            isPivotCorner: true
          },
          description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
        };
        results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[c2][this._cornerHeaderCellFullPathIds[c2].length - 1] = id;
      }
    }
    else if ("row" === this.cornerSetting.titleOnDimension || "column" === this.cornerSetting.titleOnDimension) {
      const dimensionKeys = "row" === (null === (_j = this.cornerSetting) || void 0 === _j ? void 0 : _j.titleOnDimension) ? rowDimensionKeys : colDimensionKeys;
      dimensionKeys && dimensionKeys.forEach((dimensionKey, key) => {
        var _a2, _b2;
        const id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey), cell = {
          id,
          title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
          field: dimensionKey,
          style: this.cornerSetting.headerStyle,
          headerType: null !== (_a2 = this.cornerSetting.headerType) && void 0 !== _a2 ? _a2 : "text",
          showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
          sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
          define: {
            showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
            sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
            dimensionKey,
            id,
            value: dimensionKey,
            headerCustomRender: this.cornerSetting.customRender,
            headerCustomLayout: this.cornerSetting.customLayout,
            headerEditor: this.cornerSetting.headerEditor,
            disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
            disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
          },
          dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
          headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
          pivotInfo: {
            value: null !== (_b2 = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _b2 ? _b2 : "",
            dimensionKey,
            isPivotCorner: true
          },
          description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
        };
        if (results[id] = cell, this._headerObjects[id] = cell, "column" === this.cornerSetting.titleOnDimension) {
          this._cornerHeaderCellFullPathIds[key] || (this._cornerHeaderCellFullPathIds[key] = []);
          for (let r = 0; r < this.rowHeaderLevelCount; r++) this._cornerHeaderCellFullPathIds[key][r] = id;
        } else if ("row" === this.cornerSetting.titleOnDimension) for (let r = 0; r < this.columnHeaderLevelCount; r++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), this._cornerHeaderCellFullPathIds[r][key] = id;
      });
    } else {
      const id = ++this.sharedVar.seqId, cell = {
        id,
        title: "",
        field: "维度名称",
        style: this.cornerSetting.headerStyle,
        headerType: null !== (_k = this.cornerSetting.headerType) && void 0 !== _k ? _k : "text",
        define: {
          dimensionKey: "维度名称",
          id,
          headerCustomRender: this.cornerSetting.customRender,
          headerCustomLayout: this.cornerSetting.customLayout,
          disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
          disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
        }
      };
      results[id] = cell, this._headerObjects[id] = cell;
      for (let r = 0; r < this.columnHeaderLevelCount; r++) for (let j = 0; j < this.rowHeaderLevelCount; j++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), this._cornerHeaderCellFullPathIds[r][j] = id;
    }
    return results;
  }
  generateExtensionRowTree() {
    this.extensionRows.forEach((extensionRow, indexP) => {
      const old_rowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL;
      this._rowHeaderCellFullPathIds_FULL = [], old_rowHeaderCellIds.forEach((row_ids, index) => {
        const key = row_ids[row_ids.length - 1];
        let tree, rowExtensionDimensionTree;
        if (this.colIndex = 0, "function" == typeof extensionRow.rowTree) {
          const fullCellIds = this.findFullCellIds(row_ids);
          tree = extensionRow.rowTree(fullCellIds.map((id) => ({
            dimensionKey: this._headerObjects[id].field,
            value: this._headerObjects[id].title
          })));
        } else tree = cloneDeep(extensionRow.rowTree);
        this._rowHeaderExtensionTree[key] ? (this._rowHeaderExtensionTree[key].reset(this._rowHeaderExtensionTree[key].tree.children), rowExtensionDimensionTree = this._rowHeaderExtensionTree[key]) : (rowExtensionDimensionTree = new DimensionTree(null != tree ? tree : [], this.sharedVar, this.rowHierarchyType, void 0), this._rowHeaderExtensionTree[key] = rowExtensionDimensionTree);
        const extensionRowTreeHeaderIds = [];
        this._addHeadersForTreeMode(extensionRowTreeHeaderIds, 0, rowExtensionDimensionTree.tree.children, [], rowExtensionDimensionTree.totalLevel, true, extensionRow.rows, this.rowHeaderObjs);
        for (let i = 0; i < extensionRowTreeHeaderIds[0].length; i++) this._rowHeaderCellFullPathIds_FULL.push(row_ids.concat(extensionRowTreeHeaderIds[0][i]));
      });
    });
  }
  setColumnWidths() {
    var _a, _b, _c;
    const returnWidths = new Array(this.colCount).fill(void 0);
    if (this.leftRowSeriesNumberColumnCount && (returnWidths[0] = this.leftRowSeriesNumberColumn[0]), this.showHeader && this.showRowHeader) if (this.rowHeaderTitle && (returnWidths[0 + this.leftRowSeriesNumberColumnCount] = {}), "tree" === this.rowHierarchyType) {
      const mainDimensionFirstRowKey = this.rowDimensionKeys[0];
      if (mainDimensionFirstRowKey) {
        const dimension = null === (_a = this.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension2) => "string" != typeof dimension2 && dimension2.dimensionKey === mainDimensionFirstRowKey);
        dimension && (returnWidths[0 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
          width: dimension.width,
          minWidth: dimension.minWidth,
          maxWidth: dimension.maxWidth
        });
      }
      null === (_b = this._extensionRowDimensionKeys) || void 0 === _b || _b.forEach((extensionRowDimensionKeys, index) => {
        var _a2;
        const curDimensionFirstRowKey = extensionRowDimensionKeys[0];
        if (curDimensionFirstRowKey) {
          const dimension = null === (_a2 = this.extensionRows[index].rows) || void 0 === _a2 ? void 0 : _a2.find((dimension2) => "string" != typeof dimension2 && dimension2.dimensionKey === curDimensionFirstRowKey);
          dimension && (returnWidths[index + 1 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
            width: dimension.width,
            minWidth: dimension.minWidth,
            maxWidth: dimension.maxWidth
          });
        }
      });
    } else {
      (this.rowDimensionTree.totalLevel > 0 ? this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr() : this.rowsDefine.map((dimension) => "string" == typeof dimension ? dimension : dimension.dimensionKey)).forEach((objKey, index) => {
        var _a2;
        const dimension = null === (_a2 = this.rowsDefine) || void 0 === _a2 ? void 0 : _a2.find((dimension2) => "string" != typeof dimension2 && dimension2.dimensionKey === objKey);
        dimension && (returnWidths[index + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
          width: dimension.width,
          minWidth: dimension.minWidth,
          maxWidth: dimension.maxWidth
        });
      });
    }
    if (this.indicatorsAsCol) for (let i = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount; i < this.colCount; i++) {
      const cellDefine = this.getBody(i, this.columnHeaderLevelCount);
      returnWidths[i] = {
        width: null == cellDefine ? void 0 : cellDefine.width,
        minWidth: null == cellDefine ? void 0 : cellDefine.minWidth,
        maxWidth: null == cellDefine ? void 0 : cellDefine.maxWidth
      };
    }
    else {
      let maxWidth, minWidth, isAuto, width = 0;
      null === (_c = this._indicators) || void 0 === _c || _c.forEach((obj2, index) => {
        var _a2, _b2;
        "number" == typeof obj2.width ? width = Math.max(obj2.width, width) : "auto" === obj2.width && (isAuto = true), "number" == typeof obj2.minWidth && (minWidth = Math.max(obj2.minWidth, null !== (_a2 = minWidth) && void 0 !== _a2 ? _a2 : 0)), "number" == typeof obj2.maxWidth && (maxWidth = Math.min(obj2.maxWidth, null !== (_b2 = maxWidth) && void 0 !== _b2 ? _b2 : Number.MAX_VALUE));
      }), width = width > 0 ? width : isAuto ? "auto" : void 0, returnWidths.fill({
        width,
        minWidth,
        maxWidth
      }, this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount, this.colCount - this.rightFrozenColCount);
    }
    this._columnWidths = returnWidths;
  }
  get columnWidths() {
    return this._columnWidths;
  }
  getColumnWidthDefined(col) {
    return this._columnWidths[col];
  }
  get showHeader() {
    return this._showHeader;
  }
  set showHeader(_showHeader) {
    this._showHeader = _showHeader;
  }
  get showColumnHeader() {
    return this._showColumnHeader;
  }
  set showColumnHeader(_showColumnHeader) {
    this._showColumnHeader = _showColumnHeader;
  }
  get showRowHeader() {
    return this._showRowHeader;
  }
  set showRowHeader(_showRowHeader) {
    this._showRowHeader = _showRowHeader;
  }
  get columnHeaderTitle() {
    return this._columnHeaderTitle;
  }
  set columnHeaderTitle(_columnHeaderTitle) {
    this._columnHeaderTitle = _columnHeaderTitle;
  }
  get rowHeaderTitle() {
    return this._rowHeaderTitle;
  }
  set rowHeaderTitle(_rowHeaderTitle) {
    this._rowHeaderTitle = _rowHeaderTitle;
  }
  getHeaderFieldKey(col, row) {
  }
  getCellLocation(col, row) {
    return this.isCornerHeader(col, row) ? "cornerHeader" : this.isColumnHeader(col, row) ? "columnHeader" : this.isRowHeader(col, row) ? "rowHeader" : "body";
  }
  isHeader(col, row) {
    return col >= this.leftRowSeriesNumberColumnCount && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount || (row >= 0 && row < this.columnHeaderLevelCount || (col >= this.colCount - this.rightHeaderColCount || row >= this.rowCount - this.bottomHeaderRowCount));
  }
  isCornerHeader(col, row) {
    return col >= 0 && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= 0 && row < this.columnHeaderLevelCount;
  }
  isColumnHeader(col, row) {
    return col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= 0 && row < this.columnHeaderLevelCount;
  }
  isRowHeader(col, row) {
    return col >= this.leftRowSeriesNumberColumnCount && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= this.columnHeaderLevelCount;
  }
  isFrozen(col, row) {
    return this.isFrozenColumn(col) || this.isRightFrozenColumn(col) || this.isBottomFrozenRow(row) || this.isFrozenRow(row) || this.isSeriesNumberInBody(col, row) || this.isSeriesNumberInHeader(col, row);
  }
  isFrozenColumn(col, row) {
    if (isValid_default(row)) {
      if (col >= 0 && col < this.frozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return true;
    } else if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) return true;
    return false;
  }
  isRightFrozenColumn(col, row) {
    if (isValid_default(row)) {
      if (col >= this.colCount - this.rightFrozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return true;
    } else if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) return true;
    return false;
  }
  isFrozenRow(col, row) {
    if (isValid_default(row)) {
      if (row >= 0 && row < this.frozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return true;
    } else if (row = col, this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) return true;
    return false;
  }
  isBottomFrozenRow(col, row) {
    if (isValid_default(row)) {
      if (row >= this.rowCount - this.bottomFrozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return true;
    } else if (row = col, this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) return true;
    return false;
  }
  isLeftTopCorner(col, row) {
    return col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount;
  }
  isLeftBottomCorner(col, row) {
    return col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
  }
  isRightTopCorner(col, row) {
    return col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount;
  }
  isRightBottomCorner(col, row) {
    return col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
  }
  getColumnHeaderRange() {
    return {
      start: {
        col: this.rowHeaderLevelCount,
        row: 0
      },
      end: {
        col: this.colCount - 1,
        row: this.columnHeaderLevelCount - 1
      }
    };
  }
  getRowHeaderRange() {
    return {
      start: {
        col: 0,
        row: this.columnHeaderLevelCount
      },
      end: {
        col: this.rowHeaderLevelCount - 1,
        row: this.rowCount - 1
      }
    };
  }
  getCornerHeaderRange() {
    return {
      start: {
        col: 0,
        row: 0
      },
      end: {
        col: this.rowHeaderLevelCount - 1,
        row: this.columnHeaderLevelCount - 1
      }
    };
  }
  getBodyRange() {
    return {
      start: {
        col: this.rowHeaderLevelCount,
        row: this.columnHeaderLevelCount
      },
      end: {
        col: this.colCount - 1,
        row: this.rowCount - 1
      }
    };
  }
  resetCellIds() {
  }
  get frozenColCount() {
    return this._table.internalProps.frozenColCount ? this.colCount > this._table.internalProps.frozenColCount ? this._table.internalProps.frozenColCount : this.colCount : 0;
  }
  get frozenRowCount() {
    return this._table.internalProps.frozenRowCount ? this.rowCount >= this._table.internalProps.frozenRowCount ? this._table.internalProps.frozenRowCount : this.rowCount : 0;
  }
  get headerLevelCount() {
    return this.columnHeaderLevelCount;
  }
  resetColumnHeaderLevelCount() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    if (this.showHeader && this.showColumnHeader) {
      if (this._table.isPivotChart() && this.indicatorsAsCol && !(null === (_b = null === (_a = this.dataset) || void 0 === _a ? void 0 : _a.colKeys) || void 0 === _b ? void 0 : _b.length) && 0 === (null === (_d = null === (_c = this.columnDimensionTree) || void 0 === _c ? void 0 : _c.tree) || void 0 === _d ? void 0 : _d.level) && !this.hasTwoIndicatorAxes) return void (this.columnHeaderLevelCount = 0);
      let count = this._getColumnHeaderTreeExpandedMaxLevelCount();
      return this.indicatorsAsCol && this.hideIndicatorName && this.colDimensionKeys[this.colDimensionKeys.length - 1] === this.indicatorDimensionKey && count--, 0 === count && this.dataset && !(null === (_e = this.dataset.customColTree) || void 0 === _e ? void 0 : _e.length) ? "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || !this.cornerSetting.forceShowHeader ? this._table.isPivotChart() || 0 !== (null !== (_g = null === (_f = this.dataset.records) || void 0 === _f ? void 0 : _f.length) && void 0 !== _g ? _g : 0) || "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_h = this.columnsDefine.length) && void 0 !== _h ? _h : 0) : count = 1 : !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_k = null === (_j = this.dataset.records) || void 0 === _j ? void 0 : _j.length) && void 0 !== _k ? _k : 0) || this.dataset.customColTree || "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_l = this.columnsDefine.length) && void 0 !== _l ? _l : 0, !this.hideIndicatorName && this.indicatorsAsCol && count++), this.columnHeaderTitle && (count += 1), this._table.isPivotChart() && this.indicatorsAsCol && !this.hasTwoIndicatorAxes && checkHasCartesianChart(this.indicatorsDefine) && (count -= 1), void (this.columnHeaderLevelCount = count);
    }
    this.columnHeaderLevelCount = this.indicatorsAsCol ? this.hideIndicatorName ? 0 : 1 : 0;
  }
  resetRowHeaderLevelCount() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.showHeader && this.showRowHeader) {
      if ("tree" === this.rowHierarchyType) {
        const extensionRowCount = null !== (_b = null === (_a = this.extensionRows) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
        return this.rowHeaderTitle ? void (this.rowHeaderLevelCount = 1 + (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount) : void (this.rowHeaderLevelCount = (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount);
      }
      const rowLevelCount = this._getRowHeaderTreeExpandedMaxLevelCount();
      let count = rowLevelCount;
      return 0 === count && this.dataset && !(null === (_c = this.dataset.customRowTree) || void 0 === _c ? void 0 : _c.length) ? "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || !this.cornerSetting.forceShowHeader ? this._table.isPivotChart() || 0 !== (null !== (_e = null === (_d = this.dataset.records) || void 0 === _d ? void 0 : _d.length) && void 0 !== _e ? _e : 0) || "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_f = this.rowsDefine.length) && void 0 !== _f ? _f : 0) : count = 1 : !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_h = null === (_g = this.dataset.records) || void 0 === _g ? void 0 : _g.length) && void 0 !== _h ? _h : 0) || this.dataset.customRowTree || "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = this.rowsDefine.length, this.hideIndicatorName || this.indicatorsAsCol || count++), !this.indicatorsAsCol && this.hideIndicatorName && this.rowDimensionKeys[this.rowDimensionKeys.length - 1] === this.indicatorDimensionKey && (count = rowLevelCount - 1), this.rowHeaderTitle && (count += 1), void (this.rowHeaderLevelCount = count);
    }
    this.rowHeaderLevelCount = this.indicatorsAsCol || this.hideIndicatorName ? 0 : 1;
  }
  get columnHeaderLevelCount() {
    return this._columnHeaderLevelCount;
  }
  set columnHeaderLevelCount(count) {
    this._columnHeaderLevelCount = count;
  }
  get rowHeaderLevelCount() {
    return this._rowHeaderLevelCount;
  }
  set rowHeaderLevelCount(count) {
    this._rowHeaderLevelCount = count;
  }
  get colCount() {
    var _a, _b, _c, _d;
    let bodyColCount;
    return bodyColCount = this._getColumnHeaderTreeExpandedMaxLevelCount() > 0 || this._table.isPivotChart() || (null === (_a = this.dataset.records) || void 0 === _a ? void 0 : _a.length) > 0 || this.dataset.records && !Array.isArray(this.dataset.records) ? (null !== (_c = null === (_b = this._columnHeaderCellIds[0]) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : this.columnDimensionTree.tree.size) || ((null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.length) > 0 ? 1 : 0) : 0, bodyColCount + this.rowHeaderLevelCount + this.rightHeaderColCount + this.leftRowSeriesNumberColumnCount;
  }
  get rowCount() {
    var _a, _b, _c, _d;
    return ((this._table.records || this.dataset.records) && (!Array.isArray(this._table.records) || this._table.records.length > 0) && (null === (_a = this._indicators) || void 0 === _a ? void 0 : _a.length) > 0 && !(null === (_b = this._rowHeaderCellIds) || void 0 === _b ? void 0 : _b.length) ? 1 : null !== (_d = null === (_c = this._rowHeaderCellIds) || void 0 === _c ? void 0 : _c.length) && void 0 !== _d ? _d : 0) + this.columnHeaderLevelCount + this.bottomHeaderRowCount;
  }
  get bodyRowSpanCount() {
    return this.rowDimensionTree.tree.size;
  }
  get bottomFrozenRowCount() {
    if (!this._table.isPivotChart()) return this._table.internalProps.bottomFrozenRowCount ? this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount ? this._table.internalProps.bottomFrozenRowCount : this.rowCount - this.headerLevelCount : 0;
    if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
      const axisOption = this._table.pivotChartAxes.find((axisOption2) => "bottom" === axisOption2.orient);
      return false === (null == axisOption ? void 0 : axisOption.visible) ? 0 : (this.indicatorsAsCol, 1);
    }
    return 0;
  }
  get rightFrozenColCount() {
    if (!this._table.isPivotChart()) return this._table.internalProps.rightFrozenColCount ? this.colCount - this.rowHeaderLevelCount >= this._table.internalProps.rightFrozenColCount ? this._table.internalProps.rightFrozenColCount : this.colCount - this.rowHeaderLevelCount : 0;
    const axisOption = this._table.pivotChartAxes.find((axisOption2) => "right" === axisOption2.orient);
    return false === (null == axisOption ? void 0 : axisOption.visible) || this.indicatorsAsCol ? 0 : this.hasTwoIndicatorAxes ? 1 : 0;
  }
  get bodyRowCount() {
    return this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
  }
  get bodyColCount() {
    return this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount;
  }
  get headerObjects() {
    return this._headerObjects;
  }
  get columnObjects() {
    return this._indicators;
  }
  getCellId(col, row) {
    var _a, _b, _c, _d, _e;
    if (row >= 0 && col >= 0) {
      if (this.isSeriesNumber(col, row)) return "";
      if (this.isCornerHeader(col, row)) return null === (_a = this._cornerHeaderCellIds[row]) || void 0 === _a ? void 0 : _a[col - this.leftRowSeriesNumberColumnCount];
      if (this.isColumnHeader(col, row)) return null === (_b = this._columnHeaderCellIds[row]) || void 0 === _b ? void 0 : _b[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
      if (this.isRowHeader(col, row)) return null === (_c = this._rowHeaderCellIds[row - this.columnHeaderLevelCount]) || void 0 === _c ? void 0 : _c[col - this.leftRowSeriesNumberColumnCount];
      if (this.isRightFrozenColumn(col, row)) return null === (_d = this._rowHeaderCellIds[row - this.columnHeaderLevelCount]) || void 0 === _d ? void 0 : _d[this.rowHeaderLevelCount - 1];
      if (this.isBottomFrozenRow(col, row)) return null === (_e = this._columnHeaderCellIds[this.columnHeaderLevelCount - 1]) || void 0 === _e ? void 0 : _e[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
    }
  }
  getHeader(col, row) {
    var _a;
    if (this.isSeriesNumberInHeader(col, row)) return this.getSeriesNumberHeader(col, row);
    const id = this.getCellId(col, row);
    return null !== (_a = this._headerObjectMap[id]) && void 0 !== _a ? _a : {
      id: void 0,
      field: "",
      headerType: "text",
      define: void 0
    };
  }
  getHeaderField(col, row) {
    var _a, _b;
    const id = this.getCellId(col, row);
    return (null === (_a = this._headerObjectMap[id]) || void 0 === _a ? void 0 : _a.field) || (null === (_b = this.getBody(col, row)) || void 0 === _b ? void 0 : _b.field);
  }
  getHeaderCellAdressById(id) {
    for (let i = 0; i < this._columnHeaderCellIds.length; i++) {
      const row = this._columnHeaderCellIds[i];
      for (let j = 0; j < row.length; j++) if (row[j] === id) return {
        col: j + this._table.frozenColCount,
        row: i
      };
    }
    for (let i = 0; i < this._rowHeaderCellIds.length; i++) {
      const row = this._rowHeaderCellIds[i];
      for (let j = 0; j < row.length; j++) if (row[j] === id) return {
        col: j,
        row: i + this._table.frozenRowCount
      };
    }
    for (let i = 0; i < this._cornerHeaderCellIds.length; i++) {
      const row = this._cornerHeaderCellIds[i];
      for (let j = 0; j < row.length; j++) if (row[j] === id) return {
        col: j,
        row: i
      };
    }
  }
  getHeaderCellAddressByField(field) {
    const hd = this.headerObjects.find((col) => col && col.field === field);
    return hd && this.getHeaderCellAdressById(hd.id);
  }
  getBody(_col, _row) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const cache = this.getBodyWidthCache(_col, _row);
    if (cache) return cache;
    if (this.isSeriesNumber(_col, _row)) {
      const body2 = this.getSeriesNumberBody(_col, _row);
      return this.setBodyWidthCache(_col, _row, body2), body2;
    }
    const paths = this.getCellHeaderPaths(_col, _row);
    if (this.indicatorsAsCol) {
      const indicatorKey2 = null === (_b = null === (_a = paths.colHeaderPaths) || void 0 === _a ? void 0 : _a.find((colPath) => colPath.indicatorKey)) || void 0 === _b ? void 0 : _b.indicatorKey, body2 = isValid_default(indicatorKey2) && null !== (_e = null !== (_d = null === (_c = this._indicators) || void 0 === _c ? void 0 : _c.find((indicator) => indicator.indicatorKey === indicatorKey2)) && void 0 !== _d ? _d : this._indicators[0]) && void 0 !== _e ? _e : {
        id: "",
        field: void 0,
        indicatorKey: void 0,
        cellType: "text",
        define: void 0
      };
      return this.setBodyWidthCache(_col, _row, body2), body2;
    }
    const indicatorKey = null === (_g = null === (_f = paths.rowHeaderPaths) || void 0 === _f ? void 0 : _f.find((rowPath) => rowPath.indicatorKey)) || void 0 === _g ? void 0 : _g.indicatorKey, body = isValid_default(indicatorKey) && null !== (_k = null !== (_j = null === (_h = this._indicators) || void 0 === _h ? void 0 : _h.find((indicator) => indicator.indicatorKey === indicatorKey)) && void 0 !== _j ? _j : this._indicators[0]) && void 0 !== _k ? _k : {
      id: "",
      field: void 0,
      indicatorKey: void 0,
      cellType: "text",
      define: void 0
    };
    return this.setBodyWidthCache(_col, _row, body), body;
  }
  getCellRange(col, row) {
    var _a, _b;
    const result2 = {
      start: {
        col,
        row
      },
      end: {
        col,
        row
      }
    };
    if (!this.isHeader(col, row) || -1 === col || -1 === row) return result2;
    if (this.isRightFrozenColumn(col, row) || this.isBottomFrozenRow(col, row)) return result2;
    if (this._table.isPivotChart()) {
      if (this.isLeftBottomCorner(col, row)) return {
        start: {
          col: 0,
          row: this.rowCount - this.bottomFrozenRowCount
        },
        end: {
          col: this.frozenColCount - 1,
          row: this.rowCount - 1
        }
      };
      if (this.isRightTopCorner(col, row)) return {
        start: {
          col: this.colCount - this.rightFrozenColCount,
          row: 0
        },
        end: {
          col: this.colCount - 1,
          row: this.frozenRowCount - 1
        }
      };
      if (this.isRightBottomCorner(col, row)) return {
        start: {
          col: this.colCount - this.rightFrozenColCount,
          row: this.rowCount - this.bottomFrozenRowCount
        },
        end: {
          col: this.colCount - 1,
          row: this.rowCount - 1
        }
      };
    }
    for (let i = 0; i < this._largeCellRangeCache.length; i++) {
      const range5 = this._largeCellRangeCache[i];
      if (col >= range5.start.col && col <= range5.end.col && row >= range5.start.row && row <= range5.end.row) return range5;
    }
    if (this.isHeader(col, row) && -1 !== col && -1 !== row) {
      const id = this.getCellId(col, row);
      for (let c2 = col - 1; c2 >= 0 && id === this.getCellId(c2, row); c2--) result2.start.col = c2;
      for (let c2 = col + 1; c2 < (null !== (_a = this.colCount) && void 0 !== _a ? _a : 0) && id === this.getCellId(c2, row); c2++) result2.end.col = c2;
      for (let r = row - 1; r >= 0 && id === this.getCellId(col, r); r--) result2.start.row = r;
      for (let r = row + 1; r < (null !== (_b = this.rowCount) && void 0 !== _b ? _b : 0) && !(id !== this.getCellId(col, r) || this.isSeriesNumberInHeader(col, row) && r >= this.columnHeaderLevelCount); r++) result2.end.row = r;
    }
    return (result2.end.col - result2.start.col > 100 || result2.end.row - result2.start.row > 100) && this._largeCellRangeCache.push(result2), result2;
  }
  isCellRangeEqual(col, row, targetCol, targetRow) {
    const range1 = this.getCellRange(col, row), range22 = this.getCellRange(targetCol, targetRow);
    return range1.start.col === range22.start.col && range1.end.col === range22.end.col && range1.start.row === range22.start.row && range1.end.row === range22.end.row;
  }
  getBodyIndexByRow(row) {
    return row < this.columnHeaderLevelCount || row >= this.rowCount - this.bottomHeaderRowCount ? -1 : row - this.columnHeaderLevelCount;
  }
  get bottomHeaderRowCount() {
    return this._table.isPivotChart() ? this.bottomFrozenRowCount : 0;
  }
  get rightHeaderColCount() {
    return this._table.isPivotChart() ? this.rightFrozenColCount : 0;
  }
  getBodyIndexByCol(col) {
    return col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount || col >= this.colCount - this.rightHeaderColCount ? -1 : col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount;
  }
  getRecordStartRowByRecordIndex(index) {
    return this.columnHeaderLevelCount + index;
  }
  getRecordShowIndexByCell(col, row) {
  }
  getCellHeaderPathsWithTreeNode(col, row) {
    let _largeCellRangeCacheIndex = -1;
    for (let i = 0; i < this._largeCellRangeCache.length; i++) {
      const range5 = this._largeCellRangeCache[i];
      if (col >= range5.start.col && col <= range5.end.col && row >= range5.start.row && row <= range5.end.row) {
        _largeCellRangeCacheIndex = i;
        break;
      }
    }
    let colPath = this.getColHeaderPathCache(col, row), rowPath = this.getRowHeaderPathCache(col, row);
    const recordCol = this.getBodyIndexByCol(col), recordRow = this.getBodyIndexByRow(row) + this.currentPageStartIndex;
    if (!colPath && row >= 0 && recordCol >= 0) {
      if (colPath = [], "grid-tree" === this.columnHierarchyType) {
        const col_pathIds = [];
        this._columnHeaderCellFullPathIds.map((arr) => {
          col_pathIds.push(arr[recordCol]);
        });
        const findedRowPath = this.getTreePathByCellIds(col_pathIds);
        colPath.push(...findedRowPath);
      } else colPath = this.columnDimensionTree.getTreePath(recordCol, this.showHeader && this.showColumnHeader ? row - (this.columnHeaderTitle ? 1 : 0) : this.columnDimensionTree.totalLevel);
      this.setColHeaderPathCache(col, row, colPath);
    }
    if (!rowPath && col >= 0 && recordRow >= 0) {
      if (rowPath = [], "tree" === this.rowHierarchyType) {
        const row_pathIds = this._rowHeaderCellFullPathIds[recordRow];
        let findTree = this.rowDimensionTree, level = 0;
        for (; findTree && row_pathIds; ) {
          const pathIds = [];
          let cellId = row_pathIds[level];
          for (pathIds.push(cellId); ; ) {
            const hd = this._headerObjectMap[cellId];
            if (!(null == hd ? void 0 : hd.parentCellId)) break;
            pathIds.unshift(hd.parentCellId), cellId = hd.parentCellId;
          }
          const findedRowPath = this.getTreePathByCellIds(pathIds);
          rowPath.push(...findedRowPath), findTree = this._rowHeaderExtensionTree[row_pathIds[level]], level++;
        }
      } else if ("grid-tree" === this.rowHierarchyType) {
        const row_pathIds = this._rowHeaderCellFullPathIds[recordRow], findedRowPath = this.getTreePathByCellIds(row_pathIds);
        rowPath.push(...findedRowPath);
      } else rowPath = this.rowDimensionTree.getTreePath(recordRow, this.showHeader && this.showRowHeader ? col - (this.rowHeaderTitle ? 1 : 0) - this.leftRowSeriesNumberColumnCount : this.rowDimensionTree.totalLevel);
      this.setRowHeaderPathCache(col, row, rowPath);
    }
    return {
      colHeaderPaths: colPath,
      rowHeaderPaths: rowPath,
      cellLocation: this.getCellLocation(col, row)
    };
  }
  getTreePathByCellIds(row_pathIds) {
    const paths = [];
    for (let i = 0; i < row_pathIds.length; i++) {
      const id = row_pathIds[i];
      if (i > 0 && id === row_pathIds[i - 1]) continue;
      const hd = this._headerObjects[id];
      (null == hd ? void 0 : hd.define) && paths.push(hd.define);
    }
    return paths;
  }
  getCellHeaderPaths(col, row) {
    var _a, _b;
    const headerPathsWidthNode = this.getCellHeaderPathsWithTreeNode(col, row), headerPaths = {
      colHeaderPaths: [],
      rowHeaderPaths: [],
      cellLocation: headerPathsWidthNode.cellLocation
    };
    return null === (_a = headerPathsWidthNode.colHeaderPaths) || void 0 === _a || _a.forEach((colHeader) => {
      var _a2, _b2, _c;
      const colHeaderPath = {};
      colHeaderPath.dimensionKey = colHeader.dimensionKey, colHeaderPath.indicatorKey = colHeader.indicatorKey, colHeaderPath.value = null !== (_c = null !== (_a2 = colHeader.value) && void 0 !== _a2 ? _a2 : null === (_b2 = this.getIndicatorInfoByIndicatorKey(colHeader.indicatorKey)) || void 0 === _b2 ? void 0 : _b2.title) && void 0 !== _c ? _c : "", colHeaderPath.virtual = colHeader.virtual, colHeaderPath.role = colHeader.role, headerPaths.colHeaderPaths.push(colHeaderPath);
    }), null === (_b = headerPathsWidthNode.rowHeaderPaths) || void 0 === _b || _b.forEach((rowHeader) => {
      var _a2, _b2, _c;
      if ("axis" !== rowHeader.dimensionKey) {
        const rowHeaderPath = {};
        rowHeaderPath.dimensionKey = rowHeader.dimensionKey, rowHeaderPath.indicatorKey = rowHeader.indicatorKey, rowHeaderPath.value = null !== (_c = null !== (_a2 = rowHeader.value) && void 0 !== _a2 ? _a2 : null === (_b2 = this.getIndicatorInfoByIndicatorKey(rowHeader.indicatorKey)) || void 0 === _b2 ? void 0 : _b2.title) && void 0 !== _c ? _c : "", rowHeaderPath.virtual = rowHeader.virtual, rowHeaderPath.role = rowHeader.role, headerPaths.rowHeaderPaths.push(rowHeaderPath);
      }
    }), headerPaths;
  }
  getIndicatorInfoByIndicatorKey(indicatorKey) {
    var _a;
    return null === (_a = this.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator) => "string" != typeof indicator && (!!indicatorKey && indicator.indicatorKey === indicatorKey));
  }
  findFullCellIds(row_pathIds) {
    const pathIds = [];
    for (let level = 0; level < row_pathIds.length; level++) {
      let cellId = row_pathIds[level];
      for (pathIds.push(cellId); ; ) {
        const hd = this._headerObjectMap[cellId];
        if (!(null == hd ? void 0 : hd.parentCellId)) break;
        pathIds.unshift(hd.parentCellId), cellId = hd.parentCellId;
      }
    }
    return pathIds;
  }
  getHeaderDimension(col, row) {
    var _a, _b, _c;
    if (this.isHeader(col, row)) {
      const header = this.getHeader(col, row);
      return null !== (_b = null === (_a = this.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === header.field)) && void 0 !== _b ? _b : null === (_c = this.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === header.field);
    }
  }
  isColumnIndicatorHeader(col, row) {
    return "column" === this._indicatorShowType && row === this.columnHeaderLevelCount - 1 && col >= this.rowHeaderLevelCount;
  }
  isRowIndicatorHeader(col, row) {
    return "row" === this._indicatorShowType && col === this.rowHeaderLevelCount - 1 && row >= this.columnHeaderLevelCount;
  }
  isIndicatorHeader(col, row) {
    return this.isColumnIndicatorHeader(col, row) || this.isRowIndicatorHeader(col, row);
  }
  toggleHierarchyState(col, row) {
    var _a, _b, _c, _d, _e, _f;
    this.colIndex = 0;
    const lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) - this.leftRowSeriesNumberColumnCount, oldRowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL.slice(0), oldRowHeaderCellPositons = oldRowHeaderCellIds.map((id, row2) => ({
      col,
      row: row2 + this.columnHeaderLevelCount
    })), hd = this.getHeader(col, row);
    if (hd.define.hierarchyState = hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse, this.rowDimensionTree.reset(this.rowDimensionTree.tree.children), this.resetRowHeaderLevelCount(), this._rowHeaderCellFullPathIds_FULL = [], this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), this.fullRowDimensionKeys = [], this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys), "tree" === this.rowHierarchyType) this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, true, this.rowsDefine, this.rowHeaderObjs);
    else if ("grid-tree" === this.rowHierarchyType) {
      const startRow = 0;
      this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), true, this.rowsDefine, this.rowHeaderObjs, true), this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
    }
    if (this.rowHeaderTitle) {
      const id = ++this.sharedVar.seqId, firstColIds = Array(this.rowCount - this.columnHeaderLevelCount).fill(id);
      this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
      const cell = {
        id,
        title: "string" == typeof this.rowHeaderTitle.title ? this.rowHeaderTitle.title : this.rowsDefine.reduce((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`), ""),
        field: void 0,
        headerType: null !== (_b = null === (_a = this.rowHeaderTitle) || void 0 === _a ? void 0 : _a.headerType) && void 0 !== _b ? _b : "text",
        style: null === (_c = this.rowHeaderTitle) || void 0 === _c ? void 0 : _c.headerStyle,
        define: {
          field: "",
          headerType: "text",
          cellType: "text",
          disableHeaderHover: !!(null === (_d = this.rowHeaderTitle) || void 0 === _d ? void 0 : _d.disableHeaderHover),
          disableHeaderSelect: !!(null === (_e = this.rowHeaderTitle) || void 0 === _e ? void 0 : _e.disableHeaderSelect)
        }
      };
      this.rowHeaderObjs.push(cell), this._headerObjects[id] = cell;
    }
    let diffCell;
    if (this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), "tree" === this.rowHierarchyType && (null === (_f = this.extensionRows) || void 0 === _f ? void 0 : _f.length) >= 1 && this.generateExtensionRowTree(), this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce((o, e) => (o[e.id] = e, o), {}), this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this._largeCellRangeCache.length = 0, "tree" === this.rowHierarchyType) diffCell = diffCellAddress(col, row, oldRowHeaderCellIds.map((oldCellId) => oldCellId[col - this.leftRowSeriesNumberColumnCount]), this._rowHeaderCellFullPathIds_FULL.map((newCellId) => newCellId[col - this.leftRowSeriesNumberColumnCount]), oldRowHeaderCellPositons, this);
    else {
      const new_lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) - this.leftRowSeriesNumberColumnCount;
      diffCell = diffCellAddressForGridTree(col, row, oldRowHeaderCellIds.map((oldCellId) => oldCellId[lastLevelIndex]), this._rowHeaderCellFullPathIds_FULL.map((newCellId) => newCellId[new_lastLevelIndex]), oldRowHeaderCellPositons, this);
    }
    return this.generateCellIdsConsiderHideHeader(), this.setPagination(this.pagination), "grid-tree" === this.rowHierarchyType && this.setColumnWidths(), diffCell;
  }
  toggleHierarchyStateForColumnTree(col, row) {
    var _a, _b, _c, _d, _e;
    this.colIndex = 0;
    const lastLevelIndex = this.indicatorsAsCol ? this.columnHeaderLevelCount - 2 : this.columnHeaderLevelCount - 1, oldColumnHeaderCellIds = this._columnHeaderCellFullPathIds.slice(0), oldColumnHeaderCellPositons = oldColumnHeaderCellIds[this.columnHeaderLevelCount - 1].map((id, col2) => ({
      col: col2 + this.rowHeaderLevelCount,
      row
    })), hd = this.getHeader(col, row);
    if (hd.define.hierarchyState = hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse, this.columnDimensionTree.reset(this.columnDimensionTree.tree.children), this.resetColumnHeaderLevelCount(), this._columnHeaderCellFullPathIds = [], this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr(), "grid-tree" === this.columnHierarchyType) {
      const startRow = 0;
      this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), true, this.columnsDefine, this.columnHeaderObjs, false), this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
    }
    if (this.columnHeaderTitle) {
      const id = ++this.sharedVar.seqId, firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
      this._columnHeaderCellFullPathIds.unshift(firstRowIds);
      const cell = {
        id,
        title: "string" == typeof this.columnHeaderTitle.title ? this.columnHeaderTitle.title : this.columnsDefine.reduce((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`), ""),
        field: void 0,
        headerType: null !== (_b = null === (_a = this.columnHeaderTitle) || void 0 === _a ? void 0 : _a.headerType) && void 0 !== _b ? _b : "text",
        style: null === (_c = this.columnHeaderTitle) || void 0 === _c ? void 0 : _c.headerStyle,
        define: {
          id,
          disableHeaderHover: !!(null === (_d = this.columnHeaderTitle) || void 0 === _d ? void 0 : _d.disableHeaderHover),
          disableHeaderSelect: !!(null === (_e = this.columnHeaderTitle) || void 0 === _e ? void 0 : _e.disableHeaderSelect)
        }
      };
      this.columnHeaderObjs.push(cell), this._headerObjects[id] = cell;
    }
    this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce((o, e) => (o[e.id] = e, o), {}), this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this._largeCellRangeCache.length = 0;
    const new_lastLevelIndex = this.indicatorsAsCol ? this.columnHeaderLevelCount - 2 : this.columnHeaderLevelCount - 1, diffCell = diffCellAddressForGridTreeOnColumn(col, row, oldColumnHeaderCellIds[lastLevelIndex], this._columnHeaderCellFullPathIds[new_lastLevelIndex], oldColumnHeaderCellPositons, this);
    return this.generateCellIdsConsiderHideHeader(), "grid-tree" === this.columnHierarchyType && this.setColumnWidths(), diffCell;
  }
  isHeaderForColWidth(col, row) {
    return this.isHeader(col, row);
  }
  getHeaderForColWidth(col, row) {
    return this.getHeader(col, row);
  }
  getPivotCellAdress(dimensions) {
    var _a;
    if (!Array.isArray(dimensions)) return;
    let rowDimension, colDimension, rowArr = this.rowTree, colArr = this.columnTree;
    for (let i = 0; i < dimensions.length; i++) {
      const highlightDimension = dimensions[i];
      if ((highlightDimension.isPivotCorner || !isValid_default(highlightDimension.value)) && i === dimensions.length - 1) {
        if ("row" === (null === (_a = null == this ? void 0 : this.cornerSetting) || void 0 === _a ? void 0 : _a.titleOnDimension)) {
          let col2 = 0;
          return "grid" === this.rowHierarchyType && (col2 = this.rowDimensionKeys.indexOf(highlightDimension.dimensionKey)), -1 === col2 ? void 0 : {
            col: (this.rowHeaderTitle ? col2 + 1 : col2) + this.leftRowSeriesNumberColumnCount,
            row: 0
          };
        }
        const row2 = this.colDimensionKeys.indexOf(highlightDimension.dimensionKey);
        return -1 === row2 ? void 0 : {
          col: 0 + this.leftRowSeriesNumberColumnCount,
          row: this.columnHeaderTitle ? row2 + 1 : row2
        };
      }
      let isCol = false;
      for (let j = 0; j < colArr.length; j++) {
        const dimension = colArr[j];
        if ((isValid_default(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey || isValid_default(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey) && dimension.value === highlightDimension.value) {
          colArr = dimension.children, colDimension = dimension, isCol = true;
          break;
        }
      }
      if (!isCol) for (let k2 = 0; k2 < rowArr.length; k2++) {
        const dimension = rowArr[k2];
        if ((isValid_default(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey || isValid_default(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey) && dimension.value === highlightDimension.value) {
          rowArr = dimension.children, rowDimension = dimension;
          break;
        }
      }
    }
    let col = 0, row = 0;
    if (rowDimension) {
      row = this.columnHeaderLevelCount;
      const { startInTotal, afterSpanLevel } = rowDimension;
      return row += startInTotal, col = "grid" === this.rowHierarchyType ? (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount : 0 + this.leftRowSeriesNumberColumnCount, {
        col,
        row
      };
    }
    if (colDimension) {
      col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
      const { startInTotal, afterSpanLevel } = colDimension;
      return col += startInTotal, row = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel, {
        col,
        row
      };
    }
  }
  getPivotDimensionInfo(col, row) {
    var _a;
    const { colHeaderPaths, rowHeaderPaths } = this.getCellHeaderPaths(col, row), pivotInfo = [];
    return colHeaderPaths.length ? colHeaderPaths.forEach((path, i) => {
      pivotInfo.push({
        dimensionKey: path.dimensionKey,
        value: path.value,
        isPivotCorner: false,
        indicatorKey: path.indicatorKey
      });
    }) : rowHeaderPaths.length ? rowHeaderPaths.forEach((path, i) => {
      pivotInfo.push({
        dimensionKey: path.dimensionKey,
        value: path.value,
        isPivotCorner: false,
        indicatorKey: path.indicatorKey
      });
    }) : this.isCornerHeader(col, row) && ("row" === (null === (_a = null == this ? void 0 : this.cornerSetting) || void 0 === _a ? void 0 : _a.titleOnDimension) ? pivotInfo.push({
      dimensionKey: this.rowDimensionKeys[(this.rowHeaderTitle ? col - 1 : col) - this.leftRowSeriesNumberColumnCount],
      isPivotCorner: true
    }) : pivotInfo.push({
      dimensionKey: this.colDimensionKeys[this.columnHeaderTitle ? row - 1 : row],
      isPivotCorner: true
    })), pivotInfo;
  }
  getIndicatorKey(col, row) {
    var _a;
    return null === (_a = this.getBody(col, row)) || void 0 === _a ? void 0 : _a.indicatorKey;
  }
  getParentCellId(col, row) {
    if (0 !== row) return this.isColumnHeader(col, row) ? this.getCellId(col, row - 1) : this.isRowHeader(col, row) ? this.getCellId(col - 1, row) : void 0;
  }
  getRowHeaderCellAddressByCellId(cellId) {
    let col, row;
    if (this._rowHeaderCellIds.find((cellIds, rowIndex) => !!cellIds.find((id, colIndex) => id === cellId && (col = colIndex, true)) && (row = rowIndex, true)), isValid_default(col) && isValid_default(row)) return {
      col,
      row: row + this.columnHeaderLevelCount
    };
  }
  canMoveHeaderPosition(source, target) {
    if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) return false;
    if (this.isCornerHeader(target.col, target.row)) return false;
    if (source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) return false;
    this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row) && (source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1, target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1);
    const sourceCellRange = this.getCellRange(source.col, source.row);
    if (this.isColumnHeader(source.col, source.row)) {
      return this.getParentCellId(source.col, sourceCellRange.start.row) === this.getParentCellId(target.col, sourceCellRange.start.row);
    }
    if (this.isRowHeader(source.col, source.row)) {
      if ("tree" !== this.rowHierarchyType) {
        return this.getParentCellId(sourceCellRange.start.col, source.row) === this.getParentCellId(sourceCellRange.start.col, target.row);
      }
      {
        const sourceRowHeaderPaths = cloneDeep(this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths), targetRowHeaderPaths = cloneDeep(this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths);
        if (sourceRowHeaderPaths.pop(), targetRowHeaderPaths.pop(), sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
          if (sourceRowHeaderPaths.length === targetRowHeaderPaths.length) return !sourceRowHeaderPaths.find((item, i) => item.dimensionKey !== targetRowHeaderPaths[i].dimensionKey || item.value !== targetRowHeaderPaths[i].value);
          if (sourceRowHeaderPaths.length > 0) {
            for (let i = 0; i < sourceRowHeaderPaths.length; i++) if (sourceRowHeaderPaths[i].startInTotal !== targetRowHeaderPaths[i].startInTotal) return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  moveHeaderPosition(source, target) {
    var _a, _b;
    if ((!(null === (_a = this._table.options.dragOrder) || void 0 === _a ? void 0 : _a.validateDragOrderOnEnd) || (null === (_b = this._table.options.dragOrder) || void 0 === _b ? void 0 : _b.validateDragOrderOnEnd(source, target))) && this.canMoveHeaderPosition(source, target) && !this.isCellRangeEqual(source.col, source.row, target.col, target.row)) {
      const sourceCellRange = this.getCellRange(source.col, source.row);
      if (this.isColumnHeader(source.col, source.row)) {
        const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
        let targetIndex;
        const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
        if (targetIndex = target.col >= source.col ? targetCellRange.end.col - sourceSize + 1 : targetCellRange.start.col, targetIndex === sourceCellRange.start.col) return null;
        for (let row = 0; row < this._columnHeaderCellFullPathIds.length; row++) {
          const sourceIds = this._columnHeaderCellFullPathIds[row].splice(sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, sourceSize);
          sourceIds.unshift(targetIndex - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, 0), Array.prototype.splice.apply(this._columnHeaderCellFullPathIds[row], sourceIds);
        }
        const sourceColumns = this._columnWidths.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
        return sourceColumns.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), Array.prototype.splice.apply(this._columnWidths, sourceColumns), this.columnDimensionTree.movePosition(this.getCellHeaderPathsWithTreeNode(source.col, source.row).colHeaderPaths.length - 1, sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, targetCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount), this.columnDimensionTree.reset(this.columnDimensionTree.tree.children), this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this._largeCellRangeCache.length = 0, {
          sourceIndex: sourceCellRange.start.col,
          targetIndex,
          sourceSize,
          targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
          moveType: "column"
        };
      }
      if (this.isRowHeader(source.col, source.row)) {
        let targetIndex;
        const sourceRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths, targetRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths, sourceRowHeaderNode = sourceRowHeaderPaths[sourceRowHeaderPaths.length - 1], targetRowHeaderNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1], sourceSize = sourceRowHeaderNode.size;
        if (targetIndex = target.row >= source.row ? targetRowHeaderNode.startInTotal + targetRowHeaderNode.size - sourceSize : targetRowHeaderNode.startInTotal, targetIndex === sourceCellRange.start.row - this.columnHeaderLevelCount) return null;
        const sourceIds = this._rowHeaderCellIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
        sourceIds.unshift(targetIndex - this.currentPageStartIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellIds, sourceIds);
        const sourceIds0 = this._rowHeaderCellFullPathIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
        sourceIds0.unshift(targetIndex - this.currentPageStartIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellFullPathIds, sourceIds0);
        const sourceIds_FULL = this._rowHeaderCellIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
        sourceIds_FULL.unshift(targetIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellIds_FULL, sourceIds_FULL);
        const sourceIds_FULL0 = this._rowHeaderCellFullPathIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
        return sourceIds_FULL0.unshift(targetIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellFullPathIds_FULL, sourceIds_FULL0), this.rowDimensionTree.movePosition(sourceRowHeaderPaths.length - 1, sourceCellRange.start.row - this.columnHeaderLevelCount, targetIndex + (target.row > source.row ? sourceRowHeaderNode.size - 1 : 0)), this.rowDimensionTree.reset(this.rowDimensionTree.tree.children), this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this._largeCellRangeCache.length = 0, {
          sourceIndex: sourceCellRange.start.row,
          targetIndex: targetIndex + this.columnHeaderLevelCount,
          sourceSize,
          targetSize: targetRowHeaderNode.size,
          moveType: "row"
        };
      }
    }
    return null;
  }
  getCellAdressByHeaderPath(dimensionPaths) {
    var _a, _b, _c, _d, _e, _f;
    let colHeaderPaths, rowHeaderPaths, isCornerCell = false, forceBody = false;
    if (Array.isArray(dimensionPaths)) {
      if (dimensionPaths.length > this.rowDimensionKeys.length + this.colDimensionKeys.length) return;
      colHeaderPaths = dimensionPaths.filter((path) => this.colDimensionKeys.indexOf(path.dimensionKey) >= 0 || this.colDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey), rowHeaderPaths = dimensionPaths.filter((path) => this.rowDimensionKeys.indexOf(path.dimensionKey) >= 0 || this.rowDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey);
    } else colHeaderPaths = dimensionPaths.colHeaderPaths, rowHeaderPaths = dimensionPaths.rowHeaderPaths, "body" === (null == dimensionPaths ? void 0 : dimensionPaths.cellLocation) && this._table.isPivotTable() && (forceBody = true);
    if (!Array.isArray(colHeaderPaths) && !Array.isArray(rowHeaderPaths)) return;
    if (null == colHeaderPaths || colHeaderPaths.sort((a2, b) => {
      var _a2, _b2;
      return this.colDimensionKeys.indexOf(null !== (_a2 = a2.dimensionKey) && void 0 !== _a2 ? _a2 : this.indicatorDimensionKey) - this.colDimensionKeys.indexOf(null !== (_b2 = b.dimensionKey) && void 0 !== _b2 ? _b2 : this.indicatorDimensionKey);
    }), null == rowHeaderPaths || rowHeaderPaths.sort((a2, b) => {
      var _a2, _b2;
      return this.fullRowDimensionKeys.indexOf(null !== (_a2 = a2.dimensionKey) && void 0 !== _a2 ? _a2 : this.indicatorDimensionKey) - this.fullRowDimensionKeys.indexOf(null !== (_b2 = b.dimensionKey) && void 0 !== _b2 ? _b2 : this.indicatorDimensionKey);
    }), null == colHeaderPaths || colHeaderPaths.forEach((a2) => {
      a2.isPivotCorner && (isCornerCell = true);
    }), null == rowHeaderPaths || rowHeaderPaths.forEach((a2) => {
      a2.isPivotCorner && (isCornerCell = true);
    }), isCornerCell) {
      if ("all" === this.cornerSetting.titleOnDimension && this.indicatorsAsCol && 0 === colHeaderPaths.length) {
        for (let i = 0; i < this.rowDimensionKeys.length; i++) if ((null === (_a = rowHeaderPaths[0]) || void 0 === _a ? void 0 : _a.dimensionKey) === this.rowDimensionKeys[i]) return {
          col: i + this.leftRowSeriesNumberColumnCount,
          row: this.columnHeaderLevelCount - 1
        };
      } else if ("all" !== this.cornerSetting.titleOnDimension || this.indicatorsAsCol || 0 !== rowHeaderPaths.length) {
        if ("row" === this.cornerSetting.titleOnDimension || "all" === this.cornerSetting.titleOnDimension && !this.indicatorsAsCol) {
          for (let i = 0; i < this.rowDimensionKeys.length; i++) if ((null === (_c = rowHeaderPaths[0]) || void 0 === _c ? void 0 : _c.dimensionKey) === this.rowDimensionKeys[i]) return {
            col: i + this.leftRowSeriesNumberColumnCount,
            row: 0
          };
        } else for (let i = 0; i < this.colDimensionKeys.length; i++) if ((null === (_d = colHeaderPaths[0]) || void 0 === _d ? void 0 : _d.dimensionKey) === this.colDimensionKeys[i]) return {
          col: 0,
          row: i
        };
      } else for (let i = 0; i < this.colDimensionKeys.length; i++) if ((null === (_b = colHeaderPaths[0]) || void 0 === _b ? void 0 : _b.dimensionKey) === this.colDimensionKeys[i]) return {
        col: this.rowHeaderLevelCount - 1,
        row: i
      };
    }
    let col, row, defaultCol, defaultRow, needLowestLevel_colPaths = false, needLowestLevel_rowPaths = false;
    (null == colHeaderPaths ? void 0 : colHeaderPaths.length) >= 1 && (null == rowHeaderPaths ? void 0 : rowHeaderPaths.length) >= 1 && (needLowestLevel_colPaths = true, needLowestLevel_rowPaths = true), colHeaderPaths.length >= this._getColumnHeaderTreeExpandedMaxLevelCount() && (needLowestLevel_colPaths = true), rowHeaderPaths.length >= this._getRowHeaderTreeExpandedMaxLevelCount() && (needLowestLevel_rowPaths = true);
    let rowDimensionFinded, colDimensionFinded, rowArr = this.rowTree, colArr = this.columnTree;
    if (colHeaderPaths) for (let i = 0; i < colHeaderPaths.length; i++) {
      const colDimension = colHeaderPaths[i];
      for (let j = 0; j < colArr.length; j++) {
        const dimension = colArr[j];
        if (!isValid_default(colDimension.indicatorKey) && dimension.dimensionKey === colDimension.dimensionKey && dimension.value === colDimension.value || isValid_default(colDimension.indicatorKey) && dimension.indicatorKey === colDimension.indicatorKey && (isValid_default(dimension.value) && isValid_default(colDimension.value) && colDimension.value === dimension.value || !isValid_default(dimension.value) || !isValid_default(colDimension.value))) {
          colArr = dimension.children, needLowestLevel_colPaths && !(null == colArr ? void 0 : colArr.length) ? colDimensionFinded = dimension : needLowestLevel_colPaths || (colDimensionFinded = dimension);
          break;
        }
      }
    }
    if ((null == rowHeaderPaths ? void 0 : rowHeaderPaths.length) >= 1) if ("tree" === this.rowHierarchyType) {
      const rowDimension = rowHeaderPaths[rowHeaderPaths.length - 1], cellIDs = this.headerObjects.filter((hd) => ((null == hd ? void 0 : hd.field) === rowDimension.dimensionKey || (null == hd ? void 0 : hd.field) === rowDimension.indicatorKey) && (null == hd ? void 0 : hd.title) === rowDimension.value).map((hd) => hd.id), findedCellIdPath = this._rowHeaderCellIds.filter((rowHdCellIDs) => cellIDs.indexOf(rowHdCellIDs[rowHdCellIDs.length - 1]) >= 0).find((pathIds) => {
        const fullCellIds = this.findFullCellIds(pathIds);
        return fullCellIds.length === rowHeaderPaths.length && fullCellIds.every((id) => {
          const curHd = this._headerObjectMap[id];
          return rowHeaderPaths.find((rowDimensionPath) => rowDimensionPath.dimensionKey === curHd.field && rowDimensionPath.value === curHd.title);
        });
      });
      row = this._rowHeaderCellIds.indexOf(findedCellIdPath) + this.columnHeaderLevelCount;
    } else for (let i = 0; i < rowHeaderPaths.length; i++) {
      const rowDimension = rowHeaderPaths[i];
      for (let j = 0; j < rowArr.length; j++) {
        const dimension = rowArr[j];
        if (!isValid_default(rowDimension.indicatorKey) && dimension.dimensionKey === rowDimension.dimensionKey && dimension.value === rowDimension.value || isValid_default(rowDimension.indicatorKey) && dimension.indicatorKey === rowDimension.indicatorKey && (!isValid_default(rowDimension.value) || dimension.value === rowDimension.value)) {
          rowArr = dimension.children, (!needLowestLevel_rowPaths || (null == rowArr ? void 0 : rowArr.length) && !rowArr.some((row2) => "axis" === row2.dimensionKey)) && needLowestLevel_rowPaths || (rowDimensionFinded = dimension);
          break;
        }
      }
    }
    if (forceBody || !needLowestLevel_colPaths || !needLowestLevel_rowPaths || (rowDimensionFinded || isValid_default(row)) && colDimensionFinded) {
      if (rowDimensionFinded || forceBody) {
        row = this.columnHeaderLevelCount;
        const { startInTotal, afterSpanLevel } = null !== (_e = rowDimensionFinded) && void 0 !== _e ? _e : defaultDimension;
        row += null != startInTotal ? startInTotal : 0, defaultCol = "grid" === this.rowHierarchyType ? (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount : 0;
      }
      if (colDimensionFinded || forceBody) {
        col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
        const { startInTotal, afterSpanLevel } = null !== (_f = colDimensionFinded) && void 0 !== _f ? _f : defaultDimension;
        col += null != startInTotal ? startInTotal : 0, defaultRow = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel;
      }
      return isValid_default(col) || isValid_default(row) ? {
        col: null != col ? col : defaultCol,
        row: null != row ? row : defaultRow
      } : void 0;
    }
  }
  setChartInstance(_col, _row, chartInstance) {
    var _a, _b, _c, _d;
    const paths = this.getCellHeaderPaths(_col, _row);
    let indicatorObj;
    if (this.indicatorsAsCol) {
      const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath) => colPath.indicatorKey)) || void 0 === _a ? void 0 : _a.indicatorKey;
      indicatorObj = null === (_b = this._indicators) || void 0 === _b ? void 0 : _b.find((indicator) => indicator.indicatorKey === indicatorKey);
    } else {
      const indicatorKey = null === (_c = paths.rowHeaderPaths.find((rowPath) => rowPath.indicatorKey)) || void 0 === _c ? void 0 : _c.indicatorKey;
      indicatorObj = null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.find((indicator) => indicator.indicatorKey === indicatorKey);
    }
    "function" != typeof (null == indicatorObj ? void 0 : indicatorObj.chartSpec) && indicatorObj && (indicatorObj.chartInstance = chartInstance);
  }
  getChartInstance(_col, _row) {
    var _a, _b, _c, _d;
    const paths = this.getCellHeaderPaths(_col, _row);
    let indicatorObj;
    if (this.indicatorsAsCol) {
      const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath) => colPath.indicatorKey)) || void 0 === _a ? void 0 : _a.indicatorKey;
      indicatorObj = null === (_b = this._indicators) || void 0 === _b ? void 0 : _b.find((indicator) => indicator.indicatorKey === indicatorKey);
    } else {
      const indicatorKey = null === (_c = paths.rowHeaderPaths.find((rowPath) => rowPath.indicatorKey)) || void 0 === _c ? void 0 : _c.indicatorKey;
      indicatorObj = null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.find((indicator) => indicator.indicatorKey === indicatorKey);
    }
    return null == indicatorObj ? void 0 : indicatorObj.chartInstance;
  }
  checkHasChart() {
    return checkHasChart(this);
  }
  getDimension(dimensionKey, type) {
    var _a, _b;
    return "column" === type ? null === (_a = this.columnsDefine) || void 0 === _a ? void 0 : _a.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey) : "row" === type ? null === (_b = this.rowsDefine) || void 0 === _b ? void 0 : _b.find((dimension) => "string" != typeof dimension && dimension.dimensionKey === dimensionKey) : void 0;
  }
  getAxisConfigInPivotChart(col, row) {
    if ((this.isFrozenColumn(col, row) || this.isRightFrozenColumn(col, row)) && isHasCartesianChartInline(col, row, "row", this) || (this.isFrozenRow(col, row) || this.isBottomFrozenRow(col, row)) && isHasCartesianChartInline(col, row, "col", this)) {
      const config = Factory2.getFunction("getAxisConfigInPivotChart")(col, row, this);
      if (false === (null == config ? void 0 : config.visible)) return;
      return config;
    }
  }
  isEmpty(col, row) {
    return !!this._table.isPivotChart() && (!!this.isLeftBottomCorner(col, row) || (!!this.isRightBottomCorner(col, row) || !!this.isRightTopCorner(col, row)));
  }
  isAxisCell(col, row) {
    if (!this._table.isPivotChart()) return false;
    if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
      if (this.isBottomFrozenRow(col, row) && isHasCartesianChartInline(col, row, "col", this) || this.isRightFrozenColumn(col, row) && isHasCartesianChartInline(col, row, "row", this)) return true;
      if (this.isRowHeader(col, row) && col === this.rowHeaderLevelCount - 1 && isHasCartesianChartInline(col, row, "row", this)) return true;
      if (this.hasTwoIndicatorAxes && this.indicatorsAsCol && row === this.columnHeaderLevelCount - 1 && isHasCartesianChartInline(col, row, "col", this)) return true;
    }
    return false;
  }
  getChartAxes(col, row) {
    if (isCartesianChart(col, row, this) || this.isAxisCell(col, row)) return getChartAxes(col, row, this);
  }
  getRawChartSpec(col, row) {
    return getRawChartSpec(col, row, this);
  }
  getChartSpec(col, row) {
    return getChartSpec(col, row, this);
  }
  isShareChartSpec(col, row) {
    return isShareChartSpec(col, row, this);
  }
  getChartDataId(col, row) {
    return getChartDataId(col, row, this);
  }
  isNoChartDataRenderNothing(col, row) {
    return isNoChartDataRenderNothing(col, row, this);
  }
  setPagination(pagination) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.clearCellRangeMap(), this._table.internalProps.useOneRowHeightFillAll = false, this.pagination = pagination, "grid" === this.rowHierarchyType && isValid_default(null === (_a = this.pagination) || void 0 === _a ? void 0 : _a.perPageCount) && isValid_default(null === (_b = this.pagination) || void 0 === _b ? void 0 : _b.currentPage)) {
      false === this.indicatorsAsCol && (this.pagination.perPageCount = Math.ceil(this.pagination.perPageCount / this.indicatorKeys.length) * this.indicatorKeys.length);
      const { perPageCount, currentPage } = this.pagination;
      this.currentPageStartIndex = perPageCount * (currentPage || 0), this.currentPageEndIndex = this.currentPageStartIndex + perPageCount, this._rowHeaderCellIds = null === (_c = this._rowHeaderCellIds_FULL) || void 0 === _c ? void 0 : _c.slice(this.currentPageStartIndex, this.currentPageEndIndex), this._rowHeaderCellFullPathIds = null === (_d = this._rowHeaderCellFullPathIds_FULL) || void 0 === _d ? void 0 : _d.slice(this.currentPageStartIndex, this.currentPageEndIndex);
    } else this.currentPageStartIndex = 0, this.currentPageEndIndex = this._rowHeaderCellIds_FULL.length, this._rowHeaderCellIds = null === (_e = this._rowHeaderCellIds_FULL) || void 0 === _e ? void 0 : _e.slice(this.currentPageStartIndex, this.currentPageEndIndex), this._rowHeaderCellFullPathIds = null === (_f = this._rowHeaderCellFullPathIds_FULL) || void 0 === _f ? void 0 : _f.slice(this.currentPageStartIndex, this.currentPageEndIndex);
    this.pagination && (this.pagination.totalCount = null === (_g = this._rowHeaderCellIds_FULL) || void 0 === _g ? void 0 : _g.length);
  }
  release() {
    var _a;
    const activeChartInstance = this._table._getActiveChartInstance();
    null == activeChartInstance || activeChartInstance.release(), null === (_a = this._indicators) || void 0 === _a || _a.forEach((indicatorObject) => {
      var _a2;
      null === (_a2 = indicatorObject.chartInstance) || void 0 === _a2 || _a2.release();
    });
  }
  getHeadNode(col, row) {
    var _a, _b, _c;
    let dimensions;
    const headerPaths = this.getCellHeaderPaths(col, row);
    return headerPaths.rowHeaderPaths && (null !== (_b = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0) > 0 ? dimensions = null === (_c = headerPaths.rowHeaderPaths) || void 0 === _c ? void 0 : _c.slice(0, headerPaths.rowHeaderPaths.length) : headerPaths.colHeaderPaths && headerPaths.colHeaderPaths.length > 0 && (dimensions = headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length)), this.getHeadNodeByRowOrColDimensions(dimensions, col, row);
  }
  getHeadNodeByRowOrColDimensions(dimensions, col, row) {
    var _a;
    if (!Array.isArray(dimensions)) return;
    let rowDimension, colDimension, rowArr = this.rowTree, colArr = this.columnTree;
    if (isValid_default(row) && isValid_default(col) && "tree" === this.rowHierarchyType && this.extensionRows && col >= 1 + this.leftRowSeriesNumberColumnCount) {
      const hdId = this.getCellId(col - 1, row);
      rowArr = this._rowHeaderExtensionTree[hdId].tree.children;
    }
    for (let i = 0; i < dimensions.length; i++) {
      const highlightDimension = dimensions[i];
      if ((highlightDimension.isPivotCorner || !isValid_default(highlightDimension.value)) && i === dimensions.length - 1) return;
      let isCol = false;
      for (let j = 0; j < colArr.length; j++) {
        const dimension = colArr[j];
        if (isValid_default(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey && dimension.value === highlightDimension.value || isValid_default(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey && (dimension.value === highlightDimension.value || !isValid_default(highlightDimension.value) || !isValid_default(dimension.value))) {
          colArr = dimension.children, colDimension = dimension, isCol = true;
          break;
        }
      }
      if (!isCol) for (let k2 = 0; k2 < (null !== (_a = null == rowArr ? void 0 : rowArr.length) && void 0 !== _a ? _a : 0); k2++) {
        const dimension = rowArr[k2];
        if (isValid_default(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey && dimension.value === highlightDimension.value || isValid_default(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey && (dimension.value === highlightDimension.value || !isValid_default(highlightDimension.value) || !isValid_default(dimension.value))) {
          rowArr = dimension.children, rowDimension = dimension;
          break;
        }
      }
    }
    return rowDimension || (colDimension || void 0);
  }
  clearCellRangeMap() {
    this._largeCellRangeCache.length = 0, this._CellHeaderPathMap = /* @__PURE__ */ new Map();
  }
  getDimensionKeyInChartSpec(_col, _row) {
    var _a, _b, _c, _d, _e, _f;
    let dimensionKey;
    if (false === this.indicatorsAsCol) for (let i = 0; i < this.indicatorsDefine.length; i++) {
      const chartSpec = this.indicatorsDefine[i].chartSpec;
      if (chartSpec && (dimensionKey = null !== (_a = chartSpec.xField) && void 0 !== _a ? _a : null === (_c = null === (_b = null == chartSpec ? void 0 : chartSpec.series) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.xField, dimensionKey)) return dimensionKey;
    }
    else for (let i = 0; i < this.indicatorsDefine.length; i++) {
      const chartSpec = this.indicatorsDefine[i].chartSpec;
      if (chartSpec && (dimensionKey = null !== (_d = chartSpec.yField) && void 0 !== _d ? _d : null === (_f = null === (_e = null == chartSpec ? void 0 : chartSpec.series) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.yField, dimensionKey)) return dimensionKey;
    }
    return null;
  }
  _generateChartState() {
    return {
      vtable_selected: {
        filter: (datum) => {
          var _a;
          if (this._table._selectedDataItemsInChart.length >= 1) {
            return !!this._table._selectedDataItemsInChart.find((item) => {
              for (const itemKey in item) if ("object" != typeof item[itemKey] && item[itemKey] !== datum[itemKey]) return false;
              return true;
            });
          }
          if (null === (_a = this._table._selectedDimensionInChart) || void 0 === _a ? void 0 : _a.length) {
            return !!this._table._selectedDimensionInChart.every((item) => "object" == typeof item.value || datum[item.key] === item.value);
          }
          return false;
        }
      },
      vtable_selected_reverse: {
        filter: (datum) => {
          var _a;
          if (this._table._selectedDataItemsInChart.length >= 1) {
            return !this._table._selectedDataItemsInChart.find((item) => {
              for (const itemKey in item) if ("object" != typeof item[itemKey] && item[itemKey] !== datum[itemKey]) return false;
              return true;
            });
          }
          if (null === (_a = this._table._selectedDimensionInChart) || void 0 === _a ? void 0 : _a.length) {
            return !this._table._selectedDimensionInChart.every((item) => "object" == typeof item.value || datum[item.key] === item.value);
          }
          return false;
        }
      }
    };
  }
  updateDataStateToChartInstance(activeChartInstance) {
    var _a;
    if (false !== (null === (_a = null == activeChartInstance ? void 0 : activeChartInstance.getSpec().select) || void 0 === _a ? void 0 : _a.enable)) {
      activeChartInstance || (activeChartInstance = this._table._getActiveChartInstance());
      const state = this._generateChartState();
      this._indicators.forEach((_indicatorObject) => {
        var _a2;
        const chartInstance = _indicatorObject.chartInstance;
        false !== (null === (_a2 = _indicatorObject.chartSpec.select) || void 0 === _a2 ? void 0 : _a2.enable) && chartInstance.updateState(state);
      }), null == activeChartInstance || activeChartInstance.updateState(state);
    }
  }
  updateDataStateToActiveChartInstance(activeChartInstance) {
    var _a;
    if (false !== (null === (_a = null == activeChartInstance ? void 0 : activeChartInstance.getSpec().select) || void 0 === _a ? void 0 : _a.enable)) {
      activeChartInstance || (activeChartInstance = this._table._getActiveChartInstance());
      const state = this._generateChartState();
      null == activeChartInstance || activeChartInstance.updateState(state);
    }
  }
  getIndicatorKeyInChartSpec(_col, _row) {
    const chartSpec = this.getRawChartSpec(_col, _row), indicatorKeys = [];
    if (chartSpec) {
      if (chartSpec.series || chartSpec.xField || chartSpec.yField) return false === this.indicatorsAsCol ? chartSpec.series ? chartSpec.series.forEach((chartSeries) => {
        const yField = chartSeries.yField;
        indicatorKeys.push(yField);
      }) : indicatorKeys.push(chartSpec.yField) : chartSpec.series ? chartSpec.series.forEach((chartSeries) => {
        const xField = chartSeries.xField;
        indicatorKeys.push(xField);
      }) : indicatorKeys.push(chartSpec.xField), indicatorKeys;
      if (chartSpec.valueField && indicatorKeys.push(chartSpec.valueField), indicatorKeys.length >= 1) return indicatorKeys;
    }
    return null;
  }
  getOptimunHeightForChart(row) {
    var _a, _b, _c, _d, _e;
    const path = this.getCellHeaderPaths(this.rowHeaderLevelCount, row).rowHeaderPaths;
    let collectedValues, height;
    for (const key in this.dataset.collectValuesBy) if ("yField" === this.dataset.collectValuesBy[key].type && !this.dataset.collectValuesBy[key].range) {
      collectedValues = null === (_a = this.dataset.collectedValues[key]) || void 0 === _a ? void 0 : _a[path.map((pathObj) => pathObj.value).join(this.dataset.stringJoinChar)];
      break;
    }
    if (this._chartItemBandSize) height = scaleWholeRangeSize3(null !== (_b = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _b ? _b : 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter);
    else {
      const barWidth = this._chartItemSpanSize || 25;
      height = (null !== (_c = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _c ? _c : 0) * (barWidth + barWidth / 3);
    }
    const padding = getQuadProps(null !== (_e = null !== (_d = this._chartPadding) && void 0 !== _d ? _d : this._table.theme.bodyStyle.padding) && void 0 !== _e ? _e : 0);
    return height + padding[0] + padding[2];
  }
  getOptimunWidthForChart(col) {
    var _a, _b, _c, _d, _e;
    const path = this.getCellHeaderPaths(col, this.columnHeaderLevelCount).colHeaderPaths;
    let collectedValues, width;
    for (const key in this.dataset.collectValuesBy) if ("xField" === this.dataset.collectValuesBy[key].type && !this.dataset.collectValuesBy[key].range) {
      collectedValues = null === (_a = this.dataset.collectedValues[key]) || void 0 === _a ? void 0 : _a[path.map((pathObj) => pathObj.value).join(this.dataset.stringJoinChar)];
      break;
    }
    if (this._chartItemBandSize) width = scaleWholeRangeSize3(null !== (_b = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _b ? _b : 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter);
    else {
      const barWidth = this._chartItemSpanSize || 25;
      width = (null !== (_c = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _c ? _c : 0) * (barWidth + barWidth / 3);
    }
    const padding = getQuadProps(null !== (_e = null !== (_d = this._chartPadding) && void 0 !== _d ? _d : this._table.theme.bodyStyle.padding) && void 0 !== _e ? _e : 0);
    return width + padding[1] + padding[3];
  }
  get leftAxesCount() {
    if (!this._table.isPivotChart()) return 0;
    const axisOption = this._table.pivotChartAxes.find((axisOption2) => "left" === axisOption2.orient);
    return false === (null == axisOption ? void 0 : axisOption.visible) ? 0 : (this.indicatorsAsCol, 1);
  }
  get topAxesCount() {
    if (!this._table.isPivotChart()) return 0;
    const axisOption = this._table.pivotChartAxes.find((axisOption2) => "top" === axisOption2.orient);
    return false === (null == axisOption ? void 0 : axisOption.visible) ? 0 : this.indicatorsAsCol && this.hasTwoIndicatorAxes ? 1 : 0;
  }
  get rightAxesCount() {
    return this.rightFrozenColCount;
  }
  get bottomAxesCount() {
    return this.bottomFrozenRowCount;
  }
  getColKeysPath(col, row) {
    const path = this.getCellHeaderPaths(col, row), colKey = [];
    return path.colHeaderPaths.length && path.colHeaderPaths.forEach((path2) => {
      path2.dimensionKey && colKey.push(path2.value);
    }), null == colKey ? void 0 : colKey.join(this.dataset.stringJoinChar);
  }
  getRowKeysPath(col, row) {
    const path = this.getCellHeaderPaths(col, row), rowKey = [];
    return path.rowHeaderPaths.length && path.rowHeaderPaths.forEach((path2) => {
      path2.dimensionKey && rowKey.push(path2.value);
    }), null == rowKey ? void 0 : rowKey.join(this.dataset.stringJoinChar);
  }
  getIndicatorInfo(indicatorKey, indicatorValue = "") {
    var _a;
    return null === (_a = this.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator) => "string" != typeof indicator && (indicatorKey ? indicator.indicatorKey === indicatorKey : !!indicatorValue && indicator.title === indicatorValue));
  }
  getLayoutColumnTree() {
    const tree = [], children = this.columnDimensionTree.tree.children;
    return generateLayoutTree(tree, children), tree;
  }
  getLayoutRowTree() {
    const tree = [], children = this.rowDimensionTree.tree.children;
    return generateLayoutTree(tree, children), tree;
  }
  getLayoutColumnTreeCount() {
    const children = this.columnDimensionTree.tree.children;
    return countLayoutTree(children, "tree" === this.rowHierarchyType);
  }
  getLayoutRowTreeCount() {
    var _a;
    const children = this.rowDimensionTree.tree.children;
    let totalCount = countLayoutTree(children, "tree" === this.rowHierarchyType);
    return null === (_a = this.extensionRows) || void 0 === _a || _a.forEach((extensionRow) => {
      if ("function" != typeof extensionRow.rowTree) {
        const thisTreeCount = countLayoutTree(extensionRow.rowTree, true);
        totalCount *= thisTreeCount;
      }
    }), totalCount;
  }
  resetHeaderTree() {
    var _a, _b, _c;
    this.colIndex = 0, this._rowHeaderCellFullPathIds_FULL = [], this._columnHeaderCellFullPathIds = [], this._columnHeaderCellIds = [];
    const dataset = this.dataset;
    this.rowTree = dataset.rowHeaderTree, this.columnTree = dataset.colHeaderTree;
    const beforeRowDimensions = this.rowDimensionTree.tree.children;
    null === (_a = this.rowTree) || void 0 === _a || _a.forEach((node, index) => {
      const beforeRowDimension = beforeRowDimensions.find((item) => item.dimensionKey === node.dimensionKey && item.value === node.value);
      beforeRowDimension && this._table._syncHierarchyState(beforeRowDimension, node);
    }), this.columnDimensionTree = new DimensionTree(null !== (_b = this.columnTree) && void 0 !== _b ? _b : [], this.sharedVar, this.columnHierarchyType, "grid" !== this.columnHierarchyType ? this.columnExpandLevel : void 0), this.rowDimensionTree = new DimensionTree(null !== (_c = this.rowTree) && void 0 !== _c ? _c : [], this.sharedVar, this.rowHierarchyType, "grid" !== this.rowHierarchyType ? this.rowExpandLevel : void 0), this.resetColumnHeaderLevelCount(), this._generateColHeaderIds(), this.colIndex = 0, this._generateRowHeaderIds(), this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), this._headerObjectMap = this._headerObjects.reduce((o, e) => (o[e.id] = e, o), {}), this._CellHeaderPathMap = /* @__PURE__ */ new Map(), this._largeCellRangeCache.length = 0, this.generateCellIdsConsiderHideHeader(), this.setPagination(this.pagination);
  }
  isSeriesNumberInHeader(col, row) {
    return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount && row < this.headerLevelCount || this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount;
  }
  isSeriesNumberInBody(col, row) {
    return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row >= this.headerLevelCount || this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row >= this.headerLevelCount;
  }
  isSeriesNumber(col, row) {
    if (isValid_default(col) && isValid_default(row)) {
      if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) return true;
      if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) return true;
    }
    return false;
  }
  getSeriesNumberHeader(col, row) {
    return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row < this.headerLevelCount ? Object.assign({}, this.leftRowSeriesNumberColumn[col], {
      style: Object.assign({}, this._table.internalProps.theme.cornerHeaderStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
    }) : this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount && row < this.headerLevelCount ? this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)] : void 0;
  }
  getSeriesNumberBody(col, row) {
    return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row >= this.headerLevelCount ? this.leftRowSeriesNumberColumn[col] : this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row >= this.headerLevelCount ? this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)] : void 0;
  }
  changeTreeNodeTitle(col, row, value) {
    this.getHeadNode(col, row).value = value;
    const id = this.getCellId(col, row);
    this._headerObjectMap[id].title = value;
  }
  changeCornerTitle(col, row, value) {
    if (this.isCornerHeader(col, row)) {
      const id = this.getCellId(col, row);
      this._headerObjectMap[id].title = value;
    }
  }
  generateCellIdsConsiderHideHeader() {
    var _a, _b, _c, _d;
    if (this._columnHeaderCellIds = this._columnHeaderCellFullPathIds.slice(), !this.showColumnHeader) if (this.indicatorsAsCol && !this.hideIndicatorName) {
      const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder), indicatorIds = this._columnHeaderCellIds.splice(indicatorIndex, 1);
      this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length), this._columnHeaderCellIds.push(indicatorIds[0]);
    } else this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length);
    if (this._rowHeaderCellIds_FULL = this._rowHeaderCellFullPathIds_FULL.slice(), !this.showRowHeader) if (this.indicatorsAsCol || this.hideIndicatorName) this._rowHeaderCellIds_FULL.forEach((cellIds, index) => {
      const _cellIds = cellIds.slice();
      _cellIds.splice(0, _cellIds.length), this._rowHeaderCellIds_FULL[index] = _cellIds;
    });
    else {
      const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
      this._rowHeaderCellIds_FULL.forEach((cellIds, index) => {
        const _cellIds = cellIds.slice(), indicator = _cellIds.splice(indicatorIndex, 1);
        _cellIds.splice(0, _cellIds.length), _cellIds.push(indicator[0]), this._rowHeaderCellIds_FULL[index] = _cellIds;
      });
    }
    if (this._rowHeaderCellIds = this._rowHeaderCellIds_FULL.slice(), this._cornerHeaderCellIds = this._cornerHeaderCellFullPathIds.slice(), 0 === this.rowHeaderLevelCount || 0 === this.columnHeaderLevelCount) this._cornerHeaderCellIds = [];
    else if ("row" !== this.cornerSetting.titleOnDimension || this.showRowHeader) {
      if ("column" === this.cornerSetting.titleOnDimension && !this.showColumnHeader) if (this.indicatorsAsCol && !this.hideIndicatorName) {
        const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder), indicatorIds = this._cornerHeaderCellIds.splice(indicatorIndex, 1);
        this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length), this._cornerHeaderCellIds.push(indicatorIds[0]);
      } else this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length);
    } else if (this.indicatorsAsCol || this.hideIndicatorName) this._cornerHeaderCellIds.forEach((cellIds, index) => {
      const _cellIds = cellIds.slice();
      _cellIds.splice(0, _cellIds.length), this._cornerHeaderCellIds[index] = _cellIds;
    });
    else {
      const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
      this._cornerHeaderCellIds.forEach((cellIds, index) => {
        const _cellIds = cellIds.slice(), indicator = _cellIds.splice(indicatorIndex, 1);
        _cellIds.splice(0, _cellIds.length), _cellIds.push(indicator[0]), this._cornerHeaderCellIds[index] = _cellIds;
      });
    }
    if ("grid-tree" === this.rowHierarchyType && "column" === this.cornerSetting.titleOnDimension) this._cornerHeaderCellIds[0].length < this._rowHeaderCellIds[0].length ? this._cornerHeaderCellIds.forEach((cellIds, index) => {
      const oldLength = cellIds.length;
      cellIds.length = this._rowHeaderCellIds[0].length, cellIds.fill(cellIds[0], oldLength);
    }) : this._cornerHeaderCellIds[0].length > this._rowHeaderCellIds[0].length && this._cornerHeaderCellIds.forEach((cellIds, index) => {
      cellIds.length = this._rowHeaderCellIds[0].length;
    });
    else if ("grid-tree" === this.columnHierarchyType && "row" === this.cornerSetting.titleOnDimension) if ((null === (_a = this._cornerHeaderCellIds) || void 0 === _a ? void 0 : _a.length) < (null === (_b = this._columnHeaderCellIds) || void 0 === _b ? void 0 : _b.length)) {
      const oldLength = this._cornerHeaderCellIds.length;
      this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length, this._cornerHeaderCellIds.fill(this._cornerHeaderCellIds[0], oldLength);
    } else (null === (_c = this._cornerHeaderCellIds) || void 0 === _c ? void 0 : _c.length) > (null === (_d = this._columnHeaderCellIds) || void 0 === _d ? void 0 : _d.length) && (this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length);
  }
  enableUseGetBodyCache() {
    this._useGetBodyCache = true, this._getBodyCache.clear();
  }
  disableUseGetBodyCache() {
    this._useGetBodyCache = false, this._getBodyCache.clear();
  }
  enableUseHeaderPathCache() {
    var _a, _b;
    (null === (_b = null === (_a = this._table.options) || void 0 === _a ? void 0 : _a.customConfig) || void 0 === _b ? void 0 : _b.enablePivotPathCache) ? this._useHeaderPathCache = true : (this._useHeaderPathCache = true, this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear());
  }
  disableUseHeaderPathCache() {
    var _a, _b;
    (null === (_b = null === (_a = this._table.options) || void 0 === _a ? void 0 : _a.customConfig) || void 0 === _b ? void 0 : _b.enablePivotPathCache) ? this._useHeaderPathCache = true : (this._useHeaderPathCache = false, this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear());
  }
  getBodyWidthCache(col, row) {
    if (this._useGetBodyCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row)) return this.indicatorsAsCol && this._getBodyCache.has(col) ? this._getBodyCache.get(col) : !this.indicatorsAsCol && this._getBodyCache.has(row) ? this._getBodyCache.get(row) : void 0;
  }
  setBodyWidthCache(col, row, cache) {
    !this._useGetBodyCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || (this.indicatorsAsCol ? this._getBodyCache.set(col, cache) : this._getBodyCache.set(row, cache));
  }
  getColHeaderPathCache(col, row) {
    if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row) && this._colHeaderPathCache.has(col)) return this._colHeaderPathCache.get(col);
  }
  setColHeaderPathCache(col, row, cache) {
    !this._useHeaderPathCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || this._colHeaderPathCache.set(col, cache);
  }
  getRowHeaderPathCache(col, row) {
    if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row) && this._rowHeaderPathCache.has(row)) return this._rowHeaderPathCache.get(row);
  }
  setRowHeaderPathCache(col, row, cache) {
    !this._useHeaderPathCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || this._rowHeaderPathCache.set(row, cache);
  }
  clearHeaderPathCache() {
    this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear();
  }
};
function scaleWholeRangeSize3(count, bandwidth, paddingInner, paddingOuter) {
  1 === paddingInner && (paddingInner = 0);
  const space = bandSpace3(count, paddingInner, paddingOuter), step = bandwidth / (1 - paddingInner);
  return Math.ceil(space * step);
}
function bandSpace3(count, paddingInner, paddingOuter) {
  let space;
  return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
}

// node_modules/@visactor/vtable/es/dataset/flatDataToObject.js
var FlatDataToObjects = class {
  constructor(dataConfig, records) {
    if (this.tree = {}, this.beforeChangedTree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, this.stringJoinChar = String.fromCharCode(0), this.rowsIsTotal = [], this.colsIsTotal = [], this.dataConfig = dataConfig, records) {
      this.records = records;
      "undefined" != typeof window && window.performance.now();
      this.setRecords(records);
      "undefined" != typeof window && window.performance.now();
    }
  }
  changeDataConfig(dataConfig) {
    this.dataConfig = dataConfig;
  }
  setRecords(records) {
    this.processRecords();
  }
  processRecords() {
    for (let i = 0, len = this.records.length; i < len; i++) {
      const record = this.records[i];
      this.processRecord(record);
    }
  }
  processRecord(record) {
    var _a;
    const colKey = [], rowKey = [];
    for (let l = 0, len1 = this.dataConfig.rows.length; l < len1; l++) {
      const rowAttr = this.dataConfig.rows[l];
      void 0 !== record[rowAttr] && rowAttr !== this.dataConfig.indicatorDimensionKey && rowKey.push(record[rowAttr]);
    }
    for (let n = 0, len2 = this.dataConfig.columns.length; n < len2; n++) {
      const colAttr = this.dataConfig.columns[n];
      void 0 !== record[colAttr] && colAttr !== this.dataConfig.indicatorDimensionKey && colKey.push(record[colAttr]);
    }
    null === (_a = this.dataConfig.indicators) || void 0 === _a || _a.forEach((indicatorKey) => {
      const recordValue = record[indicatorKey];
      void 0 !== recordValue && (this.dataConfig.indicatorsAsCol ? colKey.push(indicatorKey) : rowKey.push(indicatorKey));
      const flatRowKey = rowKey.join(this.stringJoinChar), flatColKey = colKey.join(this.stringJoinChar);
      0 !== rowKey.length && (this.rowFlatKeys[flatRowKey] || (this.rowFlatKeys[flatRowKey] = 1)), 0 !== colKey.length && (this.colFlatKeys[flatColKey] || (this.colFlatKeys[flatColKey] = 1)), 0 === colKey.length && 0 === rowKey.length || (this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), void 0 !== recordValue && (this.tree[flatRowKey][flatColKey] = {
        value: recordValue,
        record
      }, this.dataConfig.indicatorsAsCol ? colKey.pop() : rowKey.pop()));
    });
  }
  getTreeNode(rowKey = [], colKey = [], indicator, ifChangedValue = true) {
    var _a, _b, _c, _d;
    let flatRowKey, flatColKey;
    if ("string" == typeof rowKey) flatRowKey = rowKey;
    else {
      let isHasIndicator = false;
      rowKey.map((key, i) => {
        key === indicator && (rowKey.splice(i, 1), isHasIndicator = true);
      }), isHasIndicator && rowKey.push(indicator), flatRowKey = rowKey.join(this.stringJoinChar);
    }
    if ("string" == typeof colKey) flatColKey = colKey;
    else {
      let isHasIndicator = false;
      colKey.map((key, i) => {
        key === indicator && (colKey.splice(i, 1), isHasIndicator = true);
      }), isHasIndicator && colKey.push(indicator), flatColKey = colKey.join(this.stringJoinChar);
    }
    return ifChangedValue ? null !== (_c = null === (_b = null === (_a = this.tree) || void 0 === _a ? void 0 : _a[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) && void 0 !== _c ? _c : void 0 : isValid_default(null === (_d = this.beforeChangedTree[flatRowKey]) || void 0 === _d ? void 0 : _d[flatColKey]) ? {
      value: this.beforeChangedTree[flatRowKey][flatColKey].value,
      record: this.beforeChangedTree[flatRowKey][flatColKey].record
    } : void 0;
  }
  changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
    var _a, _b, _c, _d, _e, _f, _g;
    let flatRowKey, flatColKey;
    if ("string" == typeof rowKey) flatRowKey = rowKey;
    else {
      let isHasIndicator = false;
      rowKey.map((key, i) => {
        key === indicator && (rowKey.splice(i, 1), isHasIndicator = true);
      }), isHasIndicator && rowKey.push(indicator), flatRowKey = rowKey.join(this.stringJoinChar);
    }
    if ("string" == typeof colKey) flatColKey = colKey;
    else {
      let isHasIndicator = false;
      colKey.map((key, i) => {
        key === indicator && (colKey.splice(i, 1), isHasIndicator = true);
      }), isHasIndicator && colKey.push(indicator), flatColKey = colKey.join(this.stringJoinChar);
    }
    const oldValue = null === (_b = null === (_a = this.tree[flatRowKey]) || void 0 === _a ? void 0 : _a[flatColKey]) || void 0 === _b ? void 0 : _b.value, oldRecord = Object.assign({}, null === (_d = null === (_c = this.tree[flatRowKey]) || void 0 === _c ? void 0 : _c[flatColKey]) || void 0 === _d ? void 0 : _d.record);
    (null === (_f = null === (_e = this.tree[flatRowKey]) || void 0 === _e ? void 0 : _e[flatColKey]) || void 0 === _f ? void 0 : _f.record) ? (this.tree[flatRowKey][flatColKey].record[indicator] = newValue, this.tree[flatRowKey][flatColKey].value = newValue) : (this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), this.tree[flatRowKey][flatColKey] = {
      record: this._buildRecord(rowKey, colKey, indicator, newValue),
      value: newValue
    }), (null === (_g = this.beforeChangedTree[flatRowKey]) || void 0 === _g ? void 0 : _g[flatColKey]) || (this.beforeChangedTree[flatRowKey] = {}, this.beforeChangedTree[flatRowKey][flatColKey] = {
      record: void 0,
      value: void 0
    }, this.beforeChangedTree[flatRowKey][flatColKey].record = oldRecord, this.beforeChangedTree[flatRowKey][flatColKey].value = oldValue);
  }
  _buildRecord(rowKey = [], colKey = [], indicator, value) {
    const record = {}, rowDimensions = this.dataConfig.rows, colDimensions = this.dataConfig.columns;
    return rowDimensions.forEach((dimension, index) => {
      dimension !== this.dataConfig.indicatorDimensionKey && (record[dimension] = rowKey[index]);
    }), colDimensions.forEach((dimension, index) => {
      dimension !== this.dataConfig.indicatorDimensionKey && (record[dimension] = colKey[index]);
    }), record[indicator] = value, this.records.push(record), record;
  }
  addRecords(records) {
    for (let i = 0, len = records.length; i < len; i++) {
      const record = records[i];
      this.processRecord(record);
    }
    this.records.push(records);
  }
  changeRecordFieldValue(fieldName, oldValue, value) {
    let isIndicatorName = false;
    for (let i = 0; i < this.dataConfig.indicators.length; i++) this.dataConfig.indicators[i] === fieldName && (isIndicatorName = true);
    if (!isIndicatorName) {
      for (let i = 0, len = this.records.length; i < len; i++) {
        const record = this.records[i];
        record[fieldName] === oldValue && (record[fieldName] = value);
      }
      this.rowFlatKeys = {}, this.colFlatKeys = {}, this.tree = {}, this.processRecords();
    }
  }
};

// node_modules/@visactor/vtable/es/tools/join.js
function join(strArr, joinChar) {
  let str2 = "";
  for (let i = 0; i < strArr.length; i++) str2 += strArr[i], i !== strArr.length - 1 && (str2 += joinChar);
  return str2;
}

// node_modules/@visactor/vtable/es/dataset/dataset.js
var Dataset = class {
  constructor(dataConfig, rows, columns, indicatorKeys, indicators, indicatorsAsCol, records, rowHierarchyType, columnHierarchyType, customColTree, customRowTree, needSplitPositiveAndNegative, hasExtensionRowTree, parseCustomTreeToMatchRecords) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13;
    this.tree = {}, this.changedTree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, this.colKeys = [], this.rowKeys = [], this.colKeys_normal = [], this.rowKeys_normal = [], this.rowOrder = "key_a_to_z", this.colOrder = "key_a_to_z", this.sorted = false, this.indicatorStatistics = [], this.stringJoinChar = String.fromCharCode(0), this.rowsIsTotal = [], this.colsIsTotal = [], this.collectedValues = {}, this.cacheCollectedValues = {}, this.totalRecordsTree = {}, this.registerAggregators(), this.dataConfig = dataConfig, this.filterRules = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.filterRules, this.rowHierarchyType = null != rowHierarchyType ? rowHierarchyType : "grid", this.columnHierarchyType = null != columnHierarchyType ? columnHierarchyType : "grid", this.sortRules = null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.sortRules, this.aggregationRules = null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.aggregationRules, this.derivedFieldRules = null === (_d = this.dataConfig) || void 0 === _d ? void 0 : _d.derivedFieldRules, this.mappingRules = null === (_e = this.dataConfig) || void 0 === _e ? void 0 : _e.mappingRules, this.calculatedFieldRules = null === (_f = this.dataConfig) || void 0 === _f ? void 0 : _f.calculatedFieldRules, this.calculatedFiledKeys = null !== (_h = null === (_g = this.calculatedFieldRules) || void 0 === _g ? void 0 : _g.map((rule) => rule.key)) && void 0 !== _h ? _h : [], this.calculatedFieldDependIndicatorKeys = null !== (_k = null === (_j = this.calculatedFieldRules) || void 0 === _j ? void 0 : _j.reduce((arr, rule) => {
      for (let i = 0; i < rule.dependIndicatorKeys.length; i++) -1 === arr.indexOf(rule.dependIndicatorKeys[i]) && arr.push(rule.dependIndicatorKeys[i]);
      return arr;
    }, [])) && void 0 !== _k ? _k : [], this.totals = null === (_l = this.dataConfig) || void 0 === _l ? void 0 : _l.totals, this.rows = rows, this.columns = columns, this.indicatorKeys = indicatorKeys, this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys = [...indicatorKeys];
    for (let m3 = 0; m3 < this.calculatedFieldDependIndicatorKeys.length; m3++) -1 === this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.indexOf(this.calculatedFieldDependIndicatorKeys[m3]) && this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.push(this.calculatedFieldDependIndicatorKeys[m3]);
    if (this.indicatorsAsCol = indicatorsAsCol, this.indicators = indicators, this.customColTree = customColTree, this.customRowTree = customRowTree, this.hasExtensionRowTree = hasExtensionRowTree, this.parseCustomTreeToMatchRecords = parseCustomTreeToMatchRecords, this.parseCustomTreeToMatchRecords && (this.customColTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customColTree, "col"), this.hasExtensionRowTree || (this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, "row"))), this.colGrandTotalLabel = null !== (_p = null === (_o = null === (_m = this.totals) || void 0 === _m ? void 0 : _m.column) || void 0 === _o ? void 0 : _o.grandTotalLabel) && void 0 !== _p ? _p : "总计", this.colSubTotalLabel = null !== (_s = null === (_r = null === (_q = this.totals) || void 0 === _q ? void 0 : _q.column) || void 0 === _r ? void 0 : _r.subTotalLabel) && void 0 !== _s ? _s : "小计", this.rowGrandTotalLabel = null !== (_v = null === (_u = null === (_t = this.totals) || void 0 === _t ? void 0 : _t.row) || void 0 === _u ? void 0 : _u.grandTotalLabel) && void 0 !== _v ? _v : "总计", this.rowSubTotalLabel = null !== (_y = null === (_x = null === (_w = this.totals) || void 0 === _w ? void 0 : _w.row) || void 0 === _x ? void 0 : _x.subTotalLabel) && void 0 !== _y ? _y : "小计", this.collectValuesBy = null === (_z = this.dataConfig) || void 0 === _z ? void 0 : _z.collectValuesBy, this.needSplitPositiveAndNegative = null != needSplitPositiveAndNegative && needSplitPositiveAndNegative, this.rowsIsTotal = new Array(null !== (_1 = null === (_0 = this.rows) || void 0 === _0 ? void 0 : _0.length) && void 0 !== _1 ? _1 : 0).fill(false), this.colsIsTotal = new Array(null !== (_3 = null === (_2 = this.columns) || void 0 === _2 ? void 0 : _2.length) && void 0 !== _3 ? _3 : 0).fill(false), (null === (_4 = this.totals) || void 0 === _4 ? void 0 : _4.row) && false !== this.totals.row.showSubTotals && this.totals.row.subTotalsDimensions) for (let i = 0, len = null !== (_8 = null === (_7 = null === (_6 = null === (_5 = this.totals) || void 0 === _5 ? void 0 : _5.row) || void 0 === _6 ? void 0 : _6.subTotalsDimensions) || void 0 === _7 ? void 0 : _7.length) && void 0 !== _8 ? _8 : 0; i < len; i++) {
      const dimension = this.totals.row.subTotalsDimensions[i], dimensionIndex = this.rows.indexOf(dimension);
      this.rowsIsTotal[dimensionIndex] = true;
    }
    if ((null === (_9 = this.totals) || void 0 === _9 ? void 0 : _9.column) && false !== this.totals.column.showSubTotals && this.totals.column.subTotalsDimensions) for (let i = 0, len = null !== (_13 = null === (_12 = null === (_11 = null === (_10 = this.totals) || void 0 === _10 ? void 0 : _10.column) || void 0 === _11 ? void 0 : _11.subTotalsDimensions) || void 0 === _12 ? void 0 : _12.length) && void 0 !== _13 ? _13 : 0; i < len; i++) {
      const dimension = this.totals.column.subTotalsDimensions[i], dimensionIndex = this.columns.indexOf(dimension);
      this.colsIsTotal[dimensionIndex] = true;
    }
    this.setRecords(records);
  }
  setRecords(records) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    if (this.records = records, this.collectedValues = {}, this.cacheCollectedValues = {}, this.totalRecordsTree = {}, this.tree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, this.colKeys = [], this.rowKeys = [], this.rowsHasValue = [], this.columnsHasValue = [], this.sorted = false, records) {
      this.records = records;
      "undefined" != typeof window && window.performance.now();
      this.processRecords(), this.processCollectedValuesWithSumBy(), this.generateCollectedValuesSortRule(), this.processCollectedValuesWithSortBy();
      "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
      this.totalStatistics();
      "undefined" != typeof window && window.performance.now();
      this.rowKeys_normal = this.rowKeys.slice(), this.colKeys_normal = this.colKeys.slice();
      "undefined" != typeof window && window.performance.now();
      this.sortKeys();
      "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
      this.customRowTree ? this.rowHeaderTree = this.customRowTree : "tree" === this.rowHierarchyType ? this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter((key, index) => this.rowsHasValue[index]), this.indicatorsAsCol ? void 0 : this.indicators, (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, null !== (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.showGrandTotalsOnTop) && void 0 !== _e && _e) : this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter((key, index) => this.rowsHasValue[index]), this.indicatorsAsCol ? void 0 : this.indicators, this.rowsIsTotal, (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, this.rowSubTotalLabel, null !== (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.showGrandTotalsOnTop) && void 0 !== _k && _k, null !== (_o = null === (_m = null === (_l = this.totals) || void 0 === _l ? void 0 : _l.row) || void 0 === _m ? void 0 : _m.showSubTotalsOnTop) && void 0 !== _o && _o), this.customColTree ? this.colHeaderTree = this.customColTree : this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter((key, index) => this.columnsHasValue[index]), this.indicatorsAsCol ? this.indicators : void 0, this.colsIsTotal, (null === (_q = null === (_p = this.totals) || void 0 === _p ? void 0 : _p.column) || void 0 === _q ? void 0 : _q.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length, this.colGrandTotalLabel, this.colSubTotalLabel, null !== (_t = null === (_s = null === (_r = this.totals) || void 0 === _r ? void 0 : _r.column) || void 0 === _s ? void 0 : _s.showGrandTotalsOnLeft) && void 0 !== _t && _t, null !== (_w = null === (_v = null === (_u = this.totals) || void 0 === _u ? void 0 : _u.column) || void 0 === _v ? void 0 : _v.showSubTotalsOnLeft) && void 0 !== _w && _w);
      "undefined" != typeof window && window.performance.now();
      (null === (_x = this.dataConfig) || void 0 === _x ? void 0 : _x.isPivotChart) && this.cacheDeminsionCollectedValues();
    }
  }
  registerAggregator(type, aggregator2) {
    registeredAggregators[type] = aggregator2;
  }
  registerAggregators() {
    this.registerAggregator(AggregationType.RECORD, RecordAggregator), this.registerAggregator(AggregationType.SUM, SumAggregator), this.registerAggregator(AggregationType.COUNT, CountAggregator), this.registerAggregator(AggregationType.MAX, MaxAggregator), this.registerAggregator(AggregationType.MIN, MinAggregator), this.registerAggregator(AggregationType.AVG, AvgAggregator), this.registerAggregator(AggregationType.NONE, NoneAggregator), this.registerAggregator(AggregationType.RECALCULATE, RecalculateAggregator), this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
  }
  processCollectedValuesWithSumBy() {
    var _a, _b, _c, _d, _e, _f;
    for (const field in this.collectedValues) if (null === (_b = null === (_a = this.collectValuesBy) || void 0 === _a ? void 0 : _a[field]) || void 0 === _b ? void 0 : _b.sumBy) for (const byKeys in this.collectedValues[field]) {
      let max2;
      "sum" === (null === (_c = this.collectValuesBy[field]) || void 0 === _c ? void 0 : _c.extendRange) ? (max2 = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => acc + cur.value(), 0), max2 += Math.round(max2 / 20)) : (max2 = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => cur.value() > acc ? cur.value() : acc, Number.MIN_SAFE_INTEGER), "max" === (null === (_d = this.collectValuesBy[field]) || void 0 === _d ? void 0 : _d.extendRange) ? max2 += Math.round(max2 / 20) : "number" == typeof (null === (_e = this.collectValuesBy[field]) || void 0 === _e ? void 0 : _e.extendRange) && (max2 = Math.max(max2, null === (_f = this.collectValuesBy[field]) || void 0 === _f ? void 0 : _f.extendRange)));
      const min2 = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => cur.value() < acc ? cur.value() : acc, Number.MAX_SAFE_INTEGER);
      let positiveMax, negativeMin;
      this.needSplitPositiveAndNegative && (positiveMax = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => cur.positiveValue() > acc ? cur.positiveValue() : acc, Number.MIN_SAFE_INTEGER), negativeMin = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => cur.negativeValue() < acc ? cur.negativeValue() : acc, Number.MAX_SAFE_INTEGER)), this.collectedValues[field][byKeys] = {}, this.collectedValues[field][byKeys].max = max2, this.collectedValues[field][byKeys].min = min2, this.needSplitPositiveAndNegative && (this.collectedValues[field][byKeys].positiveMax = positiveMax, this.collectedValues[field][byKeys].negativeMin = negativeMin);
    }
  }
  processCollectedValuesWithSortBy() {
    var _a, _b;
    const that = this;
    for (const field in this.collectedValues) if (null === (_b = null === (_a = this.collectValuesBy) || void 0 === _a ? void 0 : _a[field]) || void 0 === _b ? void 0 : _b.sortBy) for (const byKeys in this.collectedValues[field]) this.collectedValues[field][byKeys] = this.collectedValues[field][byKeys].sort((a2, b) => {
      var _a2, _b2, _c, _d;
      return (null !== (_b2 = null === (_a2 = that.collectValuesBy[field].sortBy) || void 0 === _a2 ? void 0 : _a2.indexOf(a2)) && void 0 !== _b2 ? _b2 : -1) - (null !== (_d = null === (_c = that.collectValuesBy[field].sortBy) || void 0 === _c ? void 0 : _c.indexOf(b)) && void 0 !== _d ? _d : -1);
    });
  }
  generateCollectedValuesSortRule() {
    for (const field in this.collectedValues) if (this.collectValuesBy && this.collectValuesBy[field] && !this.collectValuesBy[field].sortBy) {
      let sortByRule = [];
      for (const byKeys in this.collectedValues[field]) Array.isArray(this.collectedValues[field][byKeys]) && (sortByRule.push(...this.collectedValues[field][byKeys]), sortByRule = Array.from(new Set(sortByRule)));
      sortByRule.length > 0 && (this.collectValuesBy[field].sortBy = sortByRule);
    }
  }
  processRecords() {
    var _a, _b;
    let isNeedFilter = false;
    if ((null !== (_b = null === (_a = this.filterRules) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0) >= 1 && (isNeedFilter = true), Array.isArray(this.records)) {
      this.filteredRecords || (this.filteredRecords = []);
      for (let i = 0, len = this.records.length; i < len; i++) {
        const record = this.records[i];
        isNeedFilter && !this.filterRecord(record) || (this.filteredRecords.push(record), this.processRecord(record));
      }
    } else {
      this.filteredRecords || (this.filteredRecords = {});
      for (const key in this.records) for (let i = 0, len = this.records[key].length; i < len; i++) {
        const record = this.records[key][i];
        isNeedFilter && !this.filterRecord(record) || (this.filteredRecords[key] || (this.filteredRecords[key] = []), this.filteredRecords[key].push(record), this.processRecord(record, key));
      }
    }
    this.rowFlatKeys = {}, this.colFlatKeys = {};
  }
  filterRecord(record) {
    var _a, _b;
    let isReserved = true;
    if (this.filterRules) for (let i = 0; i < this.filterRules.length; i++) {
      const filterRule = this.filterRules[i];
      if (filterRule.filterKey) {
        const filterValue = record[filterRule.filterKey];
        if (-1 === (null === (_a = filterRule.filteredValues) || void 0 === _a ? void 0 : _a.indexOf(filterValue))) {
          isReserved = false;
          break;
        }
      } else if (!(null === (_b = filterRule.filterFunc) || void 0 === _b ? void 0 : _b.call(filterRule, record))) {
        isReserved = false;
        break;
      }
    }
    return isReserved;
  }
  processRecord(record, assignedIndicatorKey) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41;
    null === (_a = this.derivedFieldRules) || void 0 === _a || _a.forEach((derivedFieldRule, i) => {
      derivedFieldRule.fieldName && derivedFieldRule.derivedFunc && (record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record));
    });
    for (const field in this.collectValuesBy) if (isValid_default(record[field])) {
      this.collectedValues[field] || (this.collectedValues[field] = {});
      const collectKeys = this.collectValuesBy[field].by.map((byField) => record[byField]).join(this.stringJoinChar);
      if (this.collectedValues[field][collectKeys] || (this.collectValuesBy[field].sumBy ? this.collectedValues[field][collectKeys] = {} : this.collectValuesBy[field].range ? this.collectedValues[field][collectKeys] = {
        min: Number.MAX_SAFE_INTEGER,
        max: Number.MIN_SAFE_INTEGER
      } : this.collectedValues[field][collectKeys] = []), this.collectValuesBy[field].sumBy) {
        const sumByKeys = null === (_b = this.collectValuesBy[field].sumBy) || void 0 === _b ? void 0 : _b.map((byField) => record[byField]).join(this.stringJoinChar);
        this.collectedValues[field][collectKeys][sumByKeys] || (this.collectedValues[field][collectKeys][sumByKeys] = new registeredAggregators[AggregationType.SUM]({
          key: field,
          field,
          isRecord: void 0,
          needSplitPositiveAndNegative: this.needSplitPositiveAndNegative
        })), this.collectedValues[field][collectKeys][sumByKeys].push(record);
      } else if (this.collectValuesBy[field].range) {
        const fieldRange = this.collectedValues[field][collectKeys], max2 = Math.max(record[field], fieldRange.max), min2 = Math.min(record[field], fieldRange.min);
        isNaN(max2) || (fieldRange.max = max2, fieldRange.min = min2);
      } else {
        const fieldRange = this.collectedValues[field][collectKeys];
        -1 === fieldRange.indexOf(record[field]) && fieldRange.push(record[field]);
      }
    }
    let isToTalRecord = false;
    const colKeys = [], rowKeys = [];
    if (!this.parseCustomTreeToMatchRecords || (null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.isPivotChart) || !(null === (_d = this.customRowTree) || void 0 === _d ? void 0 : _d.length) || assignedIndicatorKey || this.hasExtensionRowTree) {
      const rowKey = [];
      rowKeys.push({
        rowKey,
        indicatorKey: assignedIndicatorKey
      });
      for (let l = 0, len1 = this.rows.length; l < len1; l++) {
        const rowAttr = this.rows[l];
        if (rowAttr in record) this.rowsHasValue[l] = true, rowKey.push(record[rowAttr]);
        else if (rowAttr !== IndicatorDimensionKeyPlaceholder) {
          if ((null === (_g = null === (_f = null === (_e = this.dataConfig) || void 0 === _e ? void 0 : _e.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) && 0 === l && !this.rows.find((rk) => rk in record)) {
            rowKey.push(this.rowGrandTotalLabel), isToTalRecord = true;
            break;
          }
          if ((null === (_k = null === (_j = null === (_h = this.dataConfig) || void 0 === _h ? void 0 : _h.totals) || void 0 === _j ? void 0 : _j.row) || void 0 === _k ? void 0 : _k.subTotalsDimensions) && (null === (_o = null === (_m = null === (_l = this.dataConfig) || void 0 === _l ? void 0 : _l.totals) || void 0 === _m ? void 0 : _m.row) || void 0 === _o ? void 0 : _o.subTotalsDimensions.indexOf(this.rows[l - 1])) >= 0) {
            "tree" !== this.rowHierarchyType && rowKey.push(this.rowSubTotalLabel), isToTalRecord = true;
            break;
          }
        }
      }
    } else {
      const rowTreePath = this.getFieldMatchRowDimensionPaths(record);
      if (rowTreePath.length > 0) for (let i = 0, len = rowTreePath.length; i < len; i++) {
        const rowPath = rowTreePath[i], rowKey = [];
        let indicatorKey;
        for (let j = 0, len1 = rowPath.length; j < len1; j++) isValid_default(rowPath[j].indicatorKey) ? indicatorKey = rowPath[j].indicatorKey : rowKey.push(rowPath[j].value);
        rowKeys.push({
          rowKey,
          indicatorKey
        });
      }
    }
    if (!this.parseCustomTreeToMatchRecords || (null === (_p = this.dataConfig) || void 0 === _p ? void 0 : _p.isPivotChart) || !(null === (_q = this.customColTree) || void 0 === _q ? void 0 : _q.length) || assignedIndicatorKey || this.hasExtensionRowTree) {
      const colKey = [];
      colKeys.push({
        colKey,
        indicatorKey: assignedIndicatorKey
      });
      for (let n = 0, len2 = this.columns.length; n < len2; n++) {
        const colAttr = this.columns[n];
        if (colAttr in record) this.columnsHasValue[n] = true, colKey.push(record[colAttr]);
        else if (colAttr !== IndicatorDimensionKeyPlaceholder) {
          if ((null === (_t = null === (_s = null === (_r = this.dataConfig) || void 0 === _r ? void 0 : _r.totals) || void 0 === _s ? void 0 : _s.column) || void 0 === _t ? void 0 : _t.showGrandTotals) && 0 === n && !this.columns.find((ck) => ck in record)) {
            colKey.push(this.colGrandTotalLabel), isToTalRecord = true;
            break;
          }
          if ((null === (_w = null === (_v = null === (_u = this.dataConfig) || void 0 === _u ? void 0 : _u.totals) || void 0 === _v ? void 0 : _v.column) || void 0 === _w ? void 0 : _w.subTotalsDimensions) && (null === (_z = null === (_y = null === (_x = this.dataConfig) || void 0 === _x ? void 0 : _x.totals) || void 0 === _y ? void 0 : _y.column) || void 0 === _z ? void 0 : _z.subTotalsDimensions.indexOf(this.columns[n - 1])) >= 0) {
            colKey.push(this.colSubTotalLabel), isToTalRecord = true;
            break;
          }
        }
      }
    } else {
      const colTreePath = this.getFieldMatchColDimensionPaths(record);
      if (colTreePath.length > 0) for (let i = 0, len = colTreePath.length; i < len; i++) {
        const colPath = colTreePath[i], colKey = [];
        let indicatorKey;
        for (let j = 0, len1 = colPath.length; j < len1; j++) isValid_default(colPath[j].indicatorKey) ? indicatorKey = colPath[j].indicatorKey : colKey.push(colPath[j].value);
        colKeys.push({
          colKey,
          indicatorKey
        });
      }
    }
    for (let row_i = 0; row_i < rowKeys.length; row_i++) {
      const rowKey = rowKeys[row_i].rowKey;
      let assignedIndicatorKey_value;
      this.indicatorsAsCol || (assignedIndicatorKey_value = rowKeys[row_i].indicatorKey);
      for (let col_j = 0; col_j < colKeys.length; col_j++) {
        const colKey = colKeys[col_j].colKey;
        this.indicatorsAsCol && (assignedIndicatorKey_value = colKeys[col_j].indicatorKey);
        const flatRowKey = rowKey.join(this.stringJoinChar), flatColKey = colKey.join(this.stringJoinChar);
        if (isToTalRecord) {
          this.totalRecordsTree[flatRowKey] || (this.totalRecordsTree[flatRowKey] = {}), this.totalRecordsTree[flatRowKey][flatColKey] || (this.totalRecordsTree[flatRowKey][flatColKey] = []);
          const toComputeIndicatorKeys2 = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
          for (let i = 0; i < toComputeIndicatorKeys2.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys2[i]) >= 0) {
            const calculatedFieldRule = null === (_0 = this.calculatedFieldRules) || void 0 === _0 ? void 0 : _0.find((rule) => rule.key === toComputeIndicatorKeys2[i]);
            (null === (_2 = null === (_1 = this.totalRecordsTree[flatRowKey]) || void 0 === _1 ? void 0 : _1[flatColKey]) || void 0 === _2 ? void 0 : _2[i]) || (this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
              key: toComputeIndicatorKeys2[i],
              field: toComputeIndicatorKeys2[i],
              isRecord: true,
              formatFun: null === (_4 = null === (_3 = this.indicators) || void 0 === _3 ? void 0 : _3.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys2[i])) || void 0 === _4 ? void 0 : _4.format,
              calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
              dependAggregators: this.totalRecordsTree[flatRowKey][flatColKey],
              dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
            })), toComputeIndicatorKeys2[i] in record && (null === (_6 = null === (_5 = this.totalRecordsTree[flatRowKey]) || void 0 === _5 ? void 0 : _5[flatColKey]) || void 0 === _6 || _6[i].push(record));
          } else {
            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys2[i]);
            (null === (_8 = null === (_7 = this.totalRecordsTree[flatRowKey]) || void 0 === _7 ? void 0 : _7[flatColKey]) || void 0 === _8 ? void 0 : _8[i]) || (this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[null !== (_9 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _9 ? _9 : AggregationType.SUM]({
              key: toComputeIndicatorKeys2[i],
              field: null !== (_10 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _10 ? _10 : toComputeIndicatorKeys2[i],
              aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
              formatFun: null !== (_11 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _11 ? _11 : null === (_13 = null === (_12 = this.indicators) || void 0 === _12 ? void 0 : _12.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys2[i])) || void 0 === _13 ? void 0 : _13.format
            })), toComputeIndicatorKeys2[i] in record && (null === (_15 = null === (_14 = this.totalRecordsTree[flatRowKey]) || void 0 === _14 ? void 0 : _14[flatColKey]) || void 0 === _15 || _15[i].push(record));
          }
          return;
        }
        0 !== rowKey.length && (this.rowFlatKeys[flatRowKey] || (this.rowKeys.push(rowKey), this.rowFlatKeys[flatRowKey] = 1)), 0 !== colKey.length && (this.colFlatKeys[flatColKey] || (this.colKeys.push(colKey), this.colFlatKeys[flatColKey] = 1)), this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), (null === (_16 = this.tree[flatRowKey]) || void 0 === _16 ? void 0 : _16[flatColKey]) || (this.tree[flatRowKey][flatColKey] = []);
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
          const calculatedFieldRule = null === (_17 = this.calculatedFieldRules) || void 0 === _17 ? void 0 : _17.find((rule) => rule.key === toComputeIndicatorKeys[i]);
          (null === (_19 = null === (_18 = this.tree[flatRowKey]) || void 0 === _18 ? void 0 : _18[flatColKey]) || void 0 === _19 ? void 0 : _19[i]) || (this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
            key: toComputeIndicatorKeys[i],
            field: toComputeIndicatorKeys[i],
            isRecord: true,
            formatFun: null === (_21 = null === (_20 = this.indicators) || void 0 === _20 ? void 0 : _20.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _21 ? void 0 : _21.format,
            calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
            dependAggregators: this.tree[flatRowKey][flatColKey],
            dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
          })), null === (_23 = null === (_22 = this.tree[flatRowKey]) || void 0 === _22 ? void 0 : _22[flatColKey]) || void 0 === _23 || _23[i].push(record);
        } else {
          const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
          let needAddToAggregator = false;
          if (assignedIndicatorKey_value) assignedIndicatorKey === assignedIndicatorKey_value ? toComputeIndicatorKeys[i] === assignedIndicatorKey_value && (needAddToAggregator = true) : toComputeIndicatorKeys[i] === assignedIndicatorKey_value && toComputeIndicatorKeys[i] in record && (needAddToAggregator = true);
          else if (null == aggRule ? void 0 : aggRule.field) if ("string" == typeof (null == aggRule ? void 0 : aggRule.field)) (null == aggRule ? void 0 : aggRule.field) in record && (needAddToAggregator = true);
          else {
            (null == aggRule ? void 0 : aggRule.field.find((field) => field in record)) && (needAddToAggregator = true);
          }
          else toComputeIndicatorKeys[i] in record && (needAddToAggregator = true);
          !(null === (_25 = null === (_24 = this.tree[flatRowKey]) || void 0 === _24 ? void 0 : _24[flatColKey]) || void 0 === _25 ? void 0 : _25[i]) && needAddToAggregator && (this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[null !== (_26 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _26 ? _26 : AggregationType.SUM]({
            key: toComputeIndicatorKeys[i],
            field: null !== (_27 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _27 ? _27 : toComputeIndicatorKeys[i],
            aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
            formatFun: null !== (_28 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _28 ? _28 : null === (_30 = null === (_29 = this.indicators) || void 0 === _29 ? void 0 : _29.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _30 ? void 0 : _30.format
          })), needAddToAggregator && (null === (_32 = null === (_31 = this.tree[flatRowKey]) || void 0 === _31 ? void 0 : _31[flatColKey]) || void 0 === _32 || _32[i].push(record));
        }
        if (this.mappingRules) for (let i = 0; i < this.indicatorKeys.length; i++) {
          if (!this.indicatorStatistics[i]) {
            const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
            this.indicatorStatistics[i] = {
              max: new registeredAggregators[AggregationType.MAX]({
                key: this.indicatorKeys[i],
                field: this.indicatorKeys[i]
              }),
              min: new registeredAggregators[AggregationType.MIN]({
                key: this.indicatorKeys[i],
                field: this.indicatorKeys[i]
              }),
              total: new registeredAggregators[null !== (_33 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _33 ? _33 : AggregationType.SUM]({
                key: this.indicatorKeys[i],
                field: null !== (_34 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _34 ? _34 : this.indicatorKeys[i],
                aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                formatFun: null !== (_35 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _35 ? _35 : null === (_37 = null === (_36 = this.indicators) || void 0 === _36 ? void 0 : _36.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === this.indicatorKeys[i])) || void 0 === _37 ? void 0 : _37.format
              })
            };
          }
          this.indicatorStatistics[i].max.push(null === (_39 = null === (_38 = this.tree[flatRowKey]) || void 0 === _38 ? void 0 : _38[flatColKey]) || void 0 === _39 ? void 0 : _39[i].value()), this.indicatorStatistics[i].min.push(null === (_41 = null === (_40 = this.tree[flatRowKey]) || void 0 === _40 ? void 0 : _40[flatColKey]) || void 0 === _41 ? void 0 : _41[i].value()), this.indicatorStatistics[i].total.push(record);
        }
      }
    }
  }
  updateSortRules(sortRules) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    this.sorted = false, this.sortRules = sortRules, this.sortKeys(), this.customRowTree || ("tree" === this.rowHierarchyType ? this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter((key, index) => this.rowsHasValue[index]), this.indicatorsAsCol ? void 0 : this.indicators, (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, null !== (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.showGrandTotalsOnTop) && void 0 !== _e && _e) : this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter((key, index) => this.rowsHasValue[index]), this.indicatorsAsCol ? void 0 : this.indicators, this.rowsIsTotal, (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, this.rowSubTotalLabel, null !== (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.showGrandTotalsOnTop) && void 0 !== _k && _k, null !== (_o = null === (_m = null === (_l = this.totals) || void 0 === _l ? void 0 : _l.row) || void 0 === _m ? void 0 : _m.showSubTotalsOnTop) && void 0 !== _o && _o)), this.customColTree || (this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter((key, index) => this.columnsHasValue[index]), this.indicatorsAsCol ? this.indicators : void 0, this.colsIsTotal, (null === (_q = null === (_p = this.totals) || void 0 === _p ? void 0 : _p.column) || void 0 === _q ? void 0 : _q.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length, this.colGrandTotalLabel, this.colSubTotalLabel, null !== (_t = null === (_s = null === (_r = this.totals) || void 0 === _r ? void 0 : _r.column) || void 0 === _s ? void 0 : _s.showGrandTotalsOnLeft) && void 0 !== _t && _t, null !== (_w = null === (_v = null === (_u = this.totals) || void 0 === _u ? void 0 : _u.column) || void 0 === _v ? void 0 : _v.showSubTotalsOnLeft) && void 0 !== _w && _w));
  }
  updateFilterRules(filterRules, isResetTree = false) {
    var _a, _b;
    if (this.filterRules = filterRules, this.filteredRecords = void 0, isResetTree) this.tree = {};
    else for (const treeRowKey in this.tree) for (const treeColKey in this.tree[treeRowKey]) for (let i = 0; i < this.tree[treeRowKey][treeColKey].length; i++) null === (_a = this.tree[treeRowKey][treeColKey][i]) || void 0 === _a || _a.reset();
    this.collectedValues = {}, this.processRecords(), this.processCollectedValuesWithSumBy(), this.processCollectedValuesWithSortBy(), this.totalStatistics(), (null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.isPivotChart) && this.cacheDeminsionCollectedValues();
  }
  getAggregatorRule(indicatorKey) {
    var _a;
    return null === (_a = this.aggregationRules) || void 0 === _a ? void 0 : _a.find((value, index) => indicatorKey === value.indicatorKey);
  }
  getAggregator(rowKey = [], colKey = [], indicator, considerChangedValue = true, indicatorPosition) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const indicatorIndex = this.indicatorKeys.indexOf(indicator);
    let flatRowKey, flatColKey;
    "string" == typeof rowKey ? flatRowKey = rowKey : (indicatorPosition && "row" !== indicatorPosition.position || rowKey.map((key, i) => {
      key !== indicator || isValid_default(null == indicatorPosition ? void 0 : indicatorPosition.index) && i !== indicatorPosition.index || rowKey.splice(i, 1);
    }), rowKey.length < this.rows.length && "grid-tree" === this.rowHierarchyType && (rowKey[0] === this.rowGrandTotalLabel || (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.subTotalsDimensions) && (null === (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) >= 1 && rowKey[rowKey.length - 1] !== this.rowSubTotalLabel && rowKey.push(this.rowSubTotalLabel)), flatRowKey = join(rowKey, this.stringJoinChar)), "string" == typeof colKey ? flatColKey = colKey : (indicatorPosition && "col" !== indicatorPosition.position || colKey.map((key, i) => {
      key !== indicator || isValid_default(null == indicatorPosition ? void 0 : indicatorPosition.index) && i !== indicatorPosition.index || colKey.splice(i, 1);
    }), colKey.length < this.columns.length && "grid-tree" === this.columnHierarchyType && (colKey[0] === this.colGrandTotalLabel || (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.column) || void 0 === _g ? void 0 : _g.subTotalsDimensions) && (null === (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.column) || void 0 === _j ? void 0 : _j.subTotalsDimensions) || void 0 === _k ? void 0 : _k.length) >= 1 && colKey[colKey.length - 1] !== this.colSubTotalLabel && colKey.push(this.colSubTotalLabel)), flatColKey = join(colKey, this.stringJoinChar));
    const agg = null === (_m = null === (_l = this.tree[flatRowKey]) || void 0 === _l ? void 0 : _l[flatColKey]) || void 0 === _m ? void 0 : _m[indicatorIndex];
    if (considerChangedValue && isValid_default(null === (_p = null === (_o = this.changedTree[flatRowKey]) || void 0 === _o ? void 0 : _o[flatColKey]) || void 0 === _p ? void 0 : _p[indicatorIndex])) {
      const changeValue = this.changedTree[flatRowKey][flatColKey][indicatorIndex];
      return agg ? {
        value: () => changeValue,
        formatValue: agg.formatValue,
        formatFun: agg.formatFun,
        records: agg.records,
        recalculate() {
        },
        push() {
        },
        deleteRecord() {
        },
        updateRecord() {
        },
        clearCacheValue() {
        },
        reset() {
        }
      } : {
        records: [],
        value: () => changeValue,
        push() {
        },
        deleteRecord() {
        },
        updateRecord() {
        },
        recalculate() {
        },
        formatValue: () => changeValue,
        clearCacheValue() {
        },
        reset() {
        }
      };
    }
    return agg || {
      records: [],
      push() {
      },
      deleteRecord() {
      },
      updateRecord() {
      },
      recalculate() {
      },
      value: () => null,
      clearCacheValue() {
      },
      reset() {
      }
    };
  }
  sortKeys() {
    this.colKeys = this.colKeys_normal.slice(), this.rowKeys = this.rowKeys_normal.slice();
    if (!this.sorted) {
      this.sorted = true, this.rowKeys.sort(this.arrSort(this.rows, true));
      const sortfun = this.arrSort(this.columns, false);
      this.colKeys.sort(sortfun);
    }
  }
  arrSort(fieldArr, isRow) {
    let field;
    const that = this, sortersArr = (function(_this) {
      const results = [];
      for (let l = 0, len1 = fieldArr.length; l < len1; l++) {
        field = fieldArr[l];
        let isHasSortRule = false;
        if (that.sortRules) for (let m3 = 0, len2 = that.sortRules.length; m3 < len2; m3++) that.sortRules[m3].sortField === field && (isHasSortRule = true, results.push({
          field,
          fieldIndex: l,
          sortRule: that.sortRules[m3],
          func: that.getSort(that.sortRules[m3], isRow)
        }));
      }
      return results;
    }).call(this);
    return function(a2, b) {
      var _a, _b, _c, _d;
      let comparison, sorter;
      for (let i = 0; i < sortersArr.length; i++) {
        if (sorter = sortersArr[i], null === (_a = sorter.sortRule) || void 0 === _a ? void 0 : _a.sortByIndicator) {
          let aChanged = a2, bChanged = b;
          sorter.fieldIndex < fieldArr.length - 1 && (aChanged = a2.slice(0, sorter.fieldIndex + 1), "grid" === that.rowHierarchyType && isRow ? aChanged.push(that.rowSubTotalLabel) : isRow || aChanged.push(that.colSubTotalLabel), bChanged = b.slice(0, sorter.fieldIndex + 1), "grid" === that.rowHierarchyType && isRow ? bChanged.push(that.rowSubTotalLabel) : isRow || bChanged.push(that.colSubTotalLabel)), comparison = sorter.func(aChanged, bChanged, null === (_b = sorter.sortRule) || void 0 === _b ? void 0 : _b.sortType);
        } else comparison = null === (_c = sorter.func) || void 0 === _c ? void 0 : _c.call(sorter, a2[sorter.fieldIndex], b[sorter.fieldIndex], null === (_d = sorter.sortRule) || void 0 === _d ? void 0 : _d.sortType);
        if (0 !== comparison) return comparison;
      }
      return 0;
    };
  }
  getSort(sortRule, isSortRow) {
    const that = this;
    return sortRule.sortByIndicator ? (a2, b, sortType) => {
      const getValue2 = function(rowKey, colKey) {
        return "grid" === that.rowHierarchyType && rowKey.length < that.rows.length && rowKey[rowKey.length - 1] !== that.rowSubTotalLabel && rowKey[rowKey.length - 1] !== that.rowGrandTotalLabel && rowKey.push(that.rowSubTotalLabel), colKey.length < that.columns.length && colKey[colKey.length - 1] !== that.colSubTotalLabel && colKey[colKey.length - 1] !== that.colGrandTotalLabel && colKey.push(that.colSubTotalLabel), that.getAggregator(rowKey, colKey, sortRule.sortByIndicator).value();
      };
      return isSortRow ? sortRule.sortFunc ? sortRule.sortFunc(getValue2(a2, sortRule.query), getValue2(b, sortRule.query), a2, b, sortType) : naturalSort(getValue2(a2, sortRule.query), getValue2(b, sortRule.query), sortType) : sortRule.sortFunc ? sortRule.sortFunc(getValue2(sortRule.query, a2), getValue2(sortRule.query, b), a2, b, sortType) : naturalSort(getValue2(sortRule.query, a2), getValue2(sortRule.query, b), sortType);
    } : sortRule.sortBy ? sortBy(sortRule.sortBy) : sortRule.sortFunc ? sortRule.sortFunc : sortRule.sortType ? typeSort : naturalSort;
  }
  totalStatistics() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const that = this, colCompute = (flatRowKey, flatColKey) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25;
      if (null === (_b2 = null === (_a2 = this.totalRecordsTree) || void 0 === _a2 ? void 0 : _a2[flatRowKey]) || void 0 === _b2 ? void 0 : _b2[flatColKey]) return this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), void (this.tree[flatRowKey][flatColKey] = null === (_d2 = null === (_c2 = this.totalRecordsTree) || void 0 === _c2 ? void 0 : _c2[flatRowKey]) || void 0 === _d2 ? void 0 : _d2[flatColKey]);
      const colKey = flatColKey.split(this.stringJoinChar);
      if ((null === (_f2 = null === (_e2 = that.totals) || void 0 === _e2 ? void 0 : _e2.column) || void 0 === _f2 ? void 0 : _f2.subTotalsDimensions) && (null === (_j2 = null === (_h2 = null === (_g2 = that.totals) || void 0 === _g2 ? void 0 : _g2.column) || void 0 === _h2 ? void 0 : _h2.subTotalsDimensions) || void 0 === _j2 ? void 0 : _j2.length) > 0 && false !== that.totals.column.showSubTotals) for (let i = 0, len = null === (_m2 = null === (_l2 = null === (_k2 = that.totals) || void 0 === _k2 ? void 0 : _k2.column) || void 0 === _l2 ? void 0 : _l2.subTotalsDimensions) || void 0 === _m2 ? void 0 : _m2.length; i < len; i++) {
        const dimension = that.totals.column.subTotalsDimensions[i], dimensionIndex = that.columns.indexOf(dimension);
        if (dimensionIndex >= 0) {
          const colTotalKey = colKey.slice(0, dimensionIndex + 1);
          colTotalKey.push(that.colSubTotalLabel);
          const flatColTotalKey = colTotalKey.join(this.stringJoinChar);
          if (null === (_p2 = null === (_o2 = this.totalRecordsTree) || void 0 === _o2 ? void 0 : _o2[flatRowKey]) || void 0 === _p2 ? void 0 : _p2[flatColTotalKey]) return void (this.tree[flatRowKey][flatColTotalKey] = null === (_r = null === (_q = this.totalRecordsTree) || void 0 === _q ? void 0 : _q[flatRowKey]) || void 0 === _r ? void 0 : _r[flatColTotalKey]);
          this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
          const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
          for (let i2 = 0; i2 < toComputeIndicatorKeys.length; i2++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i2]) >= 0) {
            const calculatedFieldRule = null === (_s = this.calculatedFieldRules) || void 0 === _s ? void 0 : _s.find((rule) => rule.key === toComputeIndicatorKeys[i2]);
            (null === (_u = null === (_t = this.tree[flatRowKey]) || void 0 === _t ? void 0 : _t[flatColTotalKey]) || void 0 === _u ? void 0 : _u[i2]) || (this.tree[flatRowKey][flatColTotalKey][i2] = new registeredAggregators[AggregationType.RECALCULATE]({
              key: toComputeIndicatorKeys[i2],
              field: toComputeIndicatorKeys[i2],
              isRecord: true,
              formatFun: null === (_w = null === (_v = this.indicators) || void 0 === _v ? void 0 : _v.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i2])) || void 0 === _w ? void 0 : _w.format,
              calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
              dependAggregators: this.tree[flatRowKey][flatColTotalKey],
              dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
            })), flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i2].push(null === (_y = null === (_x = that.tree[flatRowKey]) || void 0 === _x ? void 0 : _x[flatColKey]) || void 0 === _y ? void 0 : _y[i2]);
          } else {
            if (!this.tree[flatRowKey][flatColTotalKey][i2]) {
              const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i2]);
              this.tree[flatRowKey][flatColTotalKey][i2] = new registeredAggregators[null !== (_z = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _z ? _z : AggregationType.SUM]({
                key: toComputeIndicatorKeys[i2],
                field: null !== (_0 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _0 ? _0 : toComputeIndicatorKeys[i2],
                aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                formatFun: null !== (_1 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _1 ? _1 : null === (_3 = null === (_2 = this.indicators) || void 0 === _2 ? void 0 : _2.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i2])) || void 0 === _3 ? void 0 : _3.format
              });
            }
            flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i2].push(null === (_5 = null === (_4 = that.tree[flatRowKey]) || void 0 === _4 ? void 0 : _4[flatColKey]) || void 0 === _5 ? void 0 : _5[i2]);
          }
        }
      }
      if ((null === (_7 = null === (_6 = that.totals) || void 0 === _6 ? void 0 : _6.column) || void 0 === _7 ? void 0 : _7.showGrandTotals) || 0 === this.rows.length) {
        const flatColTotalKey = that.colGrandTotalLabel;
        if (null === (_9 = null === (_8 = this.totalRecordsTree) || void 0 === _8 ? void 0 : _8[flatRowKey]) || void 0 === _9 ? void 0 : _9[flatColTotalKey]) return void (this.tree[flatRowKey][flatColTotalKey] = null === (_11 = null === (_10 = this.totalRecordsTree) || void 0 === _10 ? void 0 : _10[flatRowKey]) || void 0 === _11 ? void 0 : _11[flatColTotalKey]);
        this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
          const calculatedFieldRule = null === (_12 = this.calculatedFieldRules) || void 0 === _12 ? void 0 : _12.find((rule) => rule.key === toComputeIndicatorKeys[i]);
          (null === (_14 = null === (_13 = this.tree[flatRowKey]) || void 0 === _13 ? void 0 : _13[flatColTotalKey]) || void 0 === _14 ? void 0 : _14[i]) || (this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
            key: toComputeIndicatorKeys[i],
            field: toComputeIndicatorKeys[i],
            isRecord: true,
            formatFun: null === (_16 = null === (_15 = this.indicators) || void 0 === _15 ? void 0 : _15.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _16 ? void 0 : _16.format,
            calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
            dependAggregators: this.tree[flatRowKey][flatColTotalKey],
            dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
          })), flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_18 = null === (_17 = that.tree[flatRowKey]) || void 0 === _17 ? void 0 : _17[flatColKey]) || void 0 === _18 ? void 0 : _18[i]);
        } else {
          if (!this.tree[flatRowKey][flatColTotalKey][i]) {
            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
            this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[null !== (_19 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _19 ? _19 : AggregationType.SUM]({
              key: toComputeIndicatorKeys[i],
              field: null !== (_20 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _20 ? _20 : toComputeIndicatorKeys[i],
              formatFun: null !== (_21 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _21 ? _21 : null === (_23 = null === (_22 = this.indicators) || void 0 === _22 ? void 0 : _22.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _23 ? void 0 : _23.format
            });
          }
          flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_25 = null === (_24 = that.tree[flatRowKey]) || void 0 === _24 ? void 0 : _24[flatColKey]) || void 0 === _25 ? void 0 : _25[i]);
        }
      }
    };
    if ((null === (_b = null === (_a = null == that ? void 0 : that.totals) || void 0 === _a ? void 0 : _a.column) || void 0 === _b ? void 0 : _b.subTotalsDimensions) && (null === (_e = null === (_d = null === (_c = null == that ? void 0 : that.totals) || void 0 === _c ? void 0 : _c.column) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) >= 1 || (null === (_g = null === (_f = null == that ? void 0 : that.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.subTotalsDimensions) && (null === (_k = null === (_j = null === (_h = null == that ? void 0 : that.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.subTotalsDimensions) || void 0 === _k ? void 0 : _k.length) >= 1 || (null === (_m = null === (_l = null == that ? void 0 : that.totals) || void 0 === _l ? void 0 : _l.column) || void 0 === _m ? void 0 : _m.showGrandTotals) || (null === (_p = null === (_o = null == that ? void 0 : that.totals) || void 0 === _o ? void 0 : _o.row) || void 0 === _p ? void 0 : _p.showGrandTotals)) {
      const rowTotalKeys = [];
      Object.keys(that.tree).forEach((flatRowKey) => {
        const rowKey = flatRowKey.split(this.stringJoinChar);
        Object.keys(that.tree[flatRowKey]).forEach((flatColKey) => {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
          if ((null === (_b2 = null === (_a2 = that.totals) || void 0 === _a2 ? void 0 : _a2.row) || void 0 === _b2 ? void 0 : _b2.subTotalsDimensions) && (null === (_e2 = null === (_d2 = null === (_c2 = that.totals) || void 0 === _c2 ? void 0 : _c2.row) || void 0 === _d2 ? void 0 : _d2.subTotalsDimensions) || void 0 === _e2 ? void 0 : _e2.length) > 0 && false !== that.totals.row.showSubTotals) for (let i = 0, len = null === (_h2 = null === (_g2 = null === (_f2 = that.totals) || void 0 === _f2 ? void 0 : _f2.row) || void 0 === _g2 ? void 0 : _g2.subTotalsDimensions) || void 0 === _h2 ? void 0 : _h2.length; i < len; i++) {
            const dimension = that.totals.row.subTotalsDimensions[i], dimensionIndex = that.rows.indexOf(dimension);
            if (dimensionIndex >= 0 && dimensionIndex < that.rows.length - 1) {
              const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
              "tree" !== this.rowHierarchyType && rowTotalKey.push(that.rowSubTotalLabel);
              const flatRowTotalKey = rowTotalKey.join(this.stringJoinChar);
              this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), this.tree[flatRowTotalKey][flatColKey] || (this.tree[flatRowTotalKey][flatColKey] = []);
              const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
              for (let i2 = 0; i2 < toComputeIndicatorKeys.length; i2++) {
                if (!this.tree[flatRowTotalKey][flatColKey][i2]) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i2]) >= 0) {
                  const calculatedFieldRule = null === (_j2 = this.calculatedFieldRules) || void 0 === _j2 ? void 0 : _j2.find((rule) => rule.key === toComputeIndicatorKeys[i2]);
                  this.tree[flatRowTotalKey][flatColKey][i2] = new registeredAggregators[AggregationType.RECALCULATE]({
                    key: toComputeIndicatorKeys[i2],
                    field: toComputeIndicatorKeys[i2],
                    isRecord: true,
                    formatFun: null === (_l2 = null === (_k2 = this.indicators) || void 0 === _k2 ? void 0 : _k2.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i2])) || void 0 === _l2 ? void 0 : _l2.format,
                    calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                    dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                    dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                  });
                } else {
                  const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i2]);
                  this.tree[flatRowTotalKey][flatColKey][i2] = new registeredAggregators[null !== (_m2 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _m2 ? _m2 : AggregationType.SUM]({
                    key: toComputeIndicatorKeys[i2],
                    field: null !== (_o2 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _o2 ? _o2 : toComputeIndicatorKeys[i2],
                    formatFun: null !== (_p2 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _p2 ? _p2 : null === (_r = null === (_q = this.indicators) || void 0 === _q ? void 0 : _q.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i2])) || void 0 === _r ? void 0 : _r.format
                  });
                }
                flatRowTotalKey !== flatRowKey && this.tree[flatRowTotalKey][flatColKey][i2].push(null === (_t = null === (_s = that.tree[flatRowKey]) || void 0 === _s ? void 0 : _s[flatColKey]) || void 0 === _t ? void 0 : _t[i2]);
              }
            }
          }
          if ((null === (_v = null === (_u = that.totals) || void 0 === _u ? void 0 : _u.row) || void 0 === _v ? void 0 : _v.showGrandTotals) || 0 === this.columns.length) {
            const flatRowTotalKey = that.rowGrandTotalLabel;
            this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), this.tree[flatRowTotalKey][flatColKey] || (this.tree[flatRowTotalKey][flatColKey] = []);
            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
              if (!this.tree[flatRowTotalKey][flatColKey][i]) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                const calculatedFieldRule = null === (_w = this.calculatedFieldRules) || void 0 === _w ? void 0 : _w.find((rule) => rule.key === toComputeIndicatorKeys[i]);
                this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                  key: toComputeIndicatorKeys[i],
                  field: toComputeIndicatorKeys[i],
                  isRecord: true,
                  formatFun: null === (_y = null === (_x = this.indicators) || void 0 === _x ? void 0 : _x.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _y ? void 0 : _y.format,
                  calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                  dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                  dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                });
              } else {
                const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[null !== (_z = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _z ? _z : AggregationType.SUM]({
                  key: toComputeIndicatorKeys[i],
                  field: null !== (_0 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _0 ? _0 : toComputeIndicatorKeys[i],
                  formatFun: null !== (_1 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _1 ? _1 : null === (_3 = null === (_2 = this.indicators) || void 0 === _2 ? void 0 : _2.find((indicator) => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i])) || void 0 === _3 ? void 0 : _3.format
                });
              }
              flatRowTotalKey !== flatRowKey && this.tree[flatRowTotalKey][flatColKey][i].push(null === (_5 = null === (_4 = that.tree[flatRowKey]) || void 0 === _4 ? void 0 : _4[flatColKey]) || void 0 === _5 ? void 0 : _5[i]);
            }
          }
          colCompute(flatRowKey, flatColKey);
        });
      }), rowTotalKeys.forEach((flatRowKey) => {
        Object.keys(that.tree[flatRowKey]).forEach((flatColKey) => {
          colCompute(flatRowKey, flatColKey);
        });
      });
    }
    for (const flatRowKey in that.totalRecordsTree) for (const flatColKey in that.totalRecordsTree[flatRowKey]) colCompute(flatRowKey, flatColKey);
  }
  ArrToTree1(arr, rows, indicators, isGrandTotal, grandTotalLabel, showGrandTotalsOnTop) {
    const result2 = [], concatStr = this.stringJoinChar, map2 = /* @__PURE__ */ new Map();
    function addList(list, isGrandTotal2) {
      const path = [];
      let node;
      list.forEach((value, index) => {
        var _a;
        path.push(value);
        const flatKey = path.join(concatStr);
        let item = map2.get(flatKey);
        item || (item = {
          value,
          dimensionKey: rows[index],
          children: index === list.length - 1 && (null !== (_a = null == indicators ? void 0 : indicators.length) && void 0 !== _a ? _a : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator) => "string" == typeof indicator ? {
            indicatorKey: indicator,
            value: indicator
          } : {
            indicatorKey: indicator.indicatorKey,
            value: indicator.title
          }) : []
        }, map2.set(flatKey, item), node ? node.children.push(item) : showGrandTotalsOnTop && isGrandTotal2 ? result2.unshift(item) : result2.push(item)), node = item;
      });
    }
    return arr.forEach((item) => addList(item, false)), isGrandTotal && addList([grandTotalLabel], isGrandTotal), result2;
  }
  ArrToTree(arr, rows, indicators, subTotalFlags, isGrandTotal, grandTotalLabel, subTotalLabel, showGrandTotalsOnTop, showSubTotalsOnTop) {
    var _a;
    let result2 = [];
    const concatStr = this.stringJoinChar, map2 = /* @__PURE__ */ new Map();
    if ((null == arr ? void 0 : arr.length) ? arr.forEach((item) => function(list) {
      const path = [];
      let node;
      list.forEach((value, index) => {
        var _a2, _b, _c, _d;
        path.push(value);
        const flatKey = path.join(concatStr);
        let item2 = map2.get(flatKey);
        if (!item2) {
          if (item2 = {
            value,
            dimensionKey: rows[index],
            children: index === list.length - 1 && (null !== (_a2 = null == indicators ? void 0 : indicators.length) && void 0 !== _a2 ? _a2 : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator) => "string" == typeof indicator ? {
              indicatorKey: indicator,
              value: indicator
            } : {
              indicatorKey: indicator.indicatorKey,
              value: indicator.title
            }) : []
          }, subTotalFlags[index]) {
            let curChild = null !== (_b = item2.children) && void 0 !== _b ? _b : [];
            const totalChild = {
              value: subTotalLabel,
              dimensionKey: rows[index + 1],
              levelSpan: subTotalFlags.length - index - 1,
              children: (null !== (_c = null == indicators ? void 0 : indicators.length) && void 0 !== _c ? _c : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator) => "string" == typeof indicator ? {
                indicatorKey: indicator,
                value: indicator
              } : {
                indicatorKey: indicator.indicatorKey,
                value: indicator.title
              }) : [],
              role: "sub-total"
            };
            curChild.push(totalChild), curChild = null !== (_d = totalChild.children) && void 0 !== _d ? _d : [];
          }
          map2.set(flatKey, item2), node ? subTotalFlags[index - 1] && !showSubTotalsOnTop ? node.children.splice(node.children.length - 1, 0, item2) : node.children.push(item2) : result2.push(item2);
        }
        node = item2;
      });
    }(item)) : indicators && (result2 = null == indicators ? void 0 : indicators.map((indicator) => {
      var _a2;
      return "string" == typeof indicator ? {
        indicatorKey: indicator,
        value: indicator
      } : {
        indicatorKey: indicator.indicatorKey,
        value: null !== (_a2 = indicator.title) && void 0 !== _a2 ? _a2 : indicator.indicatorKey
      };
    })), isGrandTotal && (null == arr ? void 0 : arr.length)) {
      const node = {
        value: grandTotalLabel,
        dimensionKey: rows[0],
        levelSpan: subTotalFlags.length,
        children: null !== (_a = null == indicators ? void 0 : indicators.map((indicator) => "string" == typeof indicator ? {
          indicatorKey: indicator,
          value: indicator
        } : {
          indicatorKey: indicator.indicatorKey,
          value: indicator.title
        })) && void 0 !== _a ? _a : [],
        role: "grand-total"
      };
      showGrandTotalsOnTop ? result2.unshift(node) : result2.push(node);
    }
    return result2;
  }
  cacheDeminsionCollectedValues() {
    for (const key in this.collectValuesBy) "xField" !== this.collectValuesBy[key].type && "yField" !== this.collectValuesBy[key].type || (this.dataConfig.dimensionSortArray ? this.cacheCollectedValues[key] = arraySortByAnotherArray(this.collectedValues[key], this.dataConfig.dimensionSortArray) : this.cacheCollectedValues[key] = this.collectedValues[key]);
  }
  changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
    var _a, _b, _c;
    const indicatorIndex = this.indicatorKeys.indexOf(indicator);
    let flatRowKey, flatColKey;
    flatRowKey = "string" == typeof rowKey ? rowKey : rowKey.join(this.stringJoinChar), flatColKey = "string" == typeof colKey ? colKey : colKey.join(this.stringJoinChar), (null === (_a = this.changedTree[flatRowKey]) || void 0 === _a ? void 0 : _a[flatColKey]) ? this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue : this.changedTree[flatRowKey] ? (this.changedTree[flatRowKey][flatColKey] = [], this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue) : (this.changedTree[flatRowKey] = {}, this.changedTree[flatRowKey][flatColKey] = [], this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue);
    const cellAggregator = null === (_c = null === (_b = this.tree[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) || void 0 === _c ? void 0 : _c[indicatorIndex];
    1 === (null == cellAggregator ? void 0 : cellAggregator.records.length) && (cellAggregator.records[0][this.indicatorKeys[indicatorIndex]] = newValue);
  }
  changeRecordFieldValue(fieldName, oldValue, value) {
    let isIndicatorName = false;
    for (let i = 0; i < this.indicatorKeys.length; i++) this.indicatorKeys[i] === fieldName && (isIndicatorName = true);
    if (!isIndicatorName) {
      if (Array.isArray(this.records)) for (let i = 0, len = this.records.length; i < len; i++) {
        const record = this.records[i];
        record[fieldName] === oldValue && (record[fieldName] = value);
      }
      else for (const key in this.records) for (let i = 0, len = this.records[key].length; i < len; i++) {
        const record = this.records[key][i];
        record[fieldName] === oldValue && (record[fieldName] = value);
      }
      this.rowFlatKeys = {}, this.colFlatKeys = {}, this.tree = {}, this.processRecords();
    }
  }
  _rowTreeHasChanged() {
    this.hasExtensionRowTree || (this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, "row"));
  }
  changeDataConfig(dataConfig) {
    this.rows = dataConfig.rows, this.columns = dataConfig.columns;
  }
  addRecords(records) {
    for (let i = 0, len = records.length; i < len; i++) {
      const record = records[i];
      this.processRecord(record);
    }
    Array.isArray(this.records) && this.records.push(records);
  }
  customTreeToDimensionPathArr(tree, type) {
    const result2 = [], that = this;
    function getPath(node, arr) {
      var _a, _b, _c;
      node.virtual || ((null === (_a = arr[arr.length - 1]) || void 0 === _a ? void 0 : _a.childKeys) && node.dimensionKey && -1 === arr[arr.length - 1].childKeys.indexOf(node.dimensionKey) && node.dimensionKey !== arr[arr.length - 1].dimensionKey && arr[arr.length - 1].childKeys.push(node.dimensionKey), arr.push({
        dimensionKey: isValid_default(node.indicatorKey) ? void 0 : node.dimensionKey,
        value: node.value,
        indicatorKey: node.indicatorKey,
        virtual: node.virtual
      })), (null === (_b = node.children) || void 0 === _b ? void 0 : _b.length) > 0 ? ("tree" === that.rowHierarchyType && "row" === type && (arr[arr.length - 1].childKeys = [], result2.push([...arr])), null === (_c = node.children) || void 0 === _c || _c.forEach((childItem) => getPath(childItem, [...arr]))) : result2.push(arr);
    }
    return null == tree || tree.forEach((treeNode) => getPath(treeNode, [])), result2;
  }
  getFieldMatchColDimensionPaths(record) {
    var _a, _b;
    const fieldMatchDimensionPaths = [];
    for (let i = 0; i < (null !== (_b = null === (_a = this.customColTreeDimensionPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0); i++) {
      const dimensionPath = this.customColTreeDimensionPaths[i];
      let isMatch = true;
      for (let j = 0; j < dimensionPath.length; j++) {
        const dimension = dimensionPath[j];
        if (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value || dimension.indicatorKey && void 0 === record[dimension.indicatorKey]) {
          isMatch = false;
          break;
        }
      }
      isMatch && fieldMatchDimensionPaths.push(dimensionPath);
    }
    return fieldMatchDimensionPaths;
  }
  getFieldMatchRowDimensionPaths(record) {
    var _a, _b;
    const fieldMatchDimensionPaths = [];
    for (let i = 0; i < (null !== (_b = null === (_a = this.customRowTreeDimensionPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0); i++) {
      const dimensionPath = this.customRowTreeDimensionPaths[i];
      let isMatch = true;
      for (let j = 0; j < dimensionPath.length; j++) {
        const dimension = dimensionPath[j];
        if (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value || dimension.indicatorKey && void 0 === record[dimension.indicatorKey]) {
          isMatch = false;
          break;
        }
        if (dimension.childKeys && j === dimensionPath.length - 1 && dimension.childKeys.length > 0 && dimension.childKeys.find((key) => isValid_default(record[key]))) {
          isMatch = false;
          break;
        }
      }
      isMatch && (this.indicatorsAsCol || "tree" !== this.rowHierarchyType || dimensionPath.find((path) => path.indicatorKey) || (isMatch = false)), isMatch && fieldMatchDimensionPaths.push(dimensionPath);
    }
    return fieldMatchDimensionPaths;
  }
};
function arraySortByAnotherArray(array4, sortArray) {
  return array4.sort((a2, b) => {
    const aIndex = sortArray.indexOf(a2), bIndex = sortArray.indexOf(b);
    return aIndex < bIndex ? -1 : aIndex > bIndex ? 1 : 0;
  });
}

// node_modules/@visactor/vtable/es/PivotTable.js
var PivotTable = class extends BaseTable {
  constructor(container2, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (super(container2, options), this.layoutNodeId = {
      seqId: 0
    }, options = this.options) {
      options.rowHierarchyType || (options.rowHierarchyType = "grid"), options.columnHierarchyType || (options.columnHierarchyType = "grid"), options.layout && Object.assign(options, options.layout), this.internalProps.columns = cloneDeep(options.columns), this.internalProps.rows = cloneDeep(options.rows), this.internalProps.indicators = cloneDeepSpec(options.indicators), null === (_a = options.indicators) || void 0 === _a || _a.forEach((indicatorDefine, index) => {
        "object" == typeof indicatorDefine && (null == indicatorDefine ? void 0 : indicatorDefine.editor) && (this.internalProps.indicators[index].editor = indicatorDefine.editor);
      }), this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_b = options.columns) || void 0 === _b ? void 0 : _b.length) || options.columnTree ? cloneDeep(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_c = options.rows) || void 0 === _c ? void 0 : _c.length) || options.rowTree ? cloneDeep(options.rowTree) : [], this.internalProps.records = options.records, this.pagination = options.pagination, this.internalProps.columnResizeType = null !== (_f = null !== (_e = null === (_d = options.resize) || void 0 === _d ? void 0 : _d.columnResizeType) && void 0 !== _e ? _e : options.columnResizeType) && void 0 !== _f ? _f : "column", this.internalProps.rowResizeType = null !== (_j = null !== (_h = null === (_g = options.resize) || void 0 === _g ? void 0 : _g.rowResizeType) && void 0 !== _h ? _h : options.rowResizeType) && void 0 !== _j ? _j : "row", this.internalProps.dataConfig = cloneDeep(options.dataConfig), this.internalProps.columnWidthConfig = options.columnWidthConfig, this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader;
      const records = this.internalProps.records;
      if (this.internalProps.recordsIsTwoDimensionalArray = false, (null === (_k = null == records ? void 0 : records[0]) || void 0 === _k ? void 0 : _k.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = true), false === (null === (_l = options.customConfig) || void 0 === _l ? void 0 : _l.enableDataAnalysis)) {
        const columnDimensionTree = new DimensionTree(null !== (_m = this.internalProps.columnTree) && void 0 !== _m ? _m : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_o = this.options.columnExpandLevel) && void 0 !== _o ? _o : 1 : void 0), rowDimensionTree = new DimensionTree(null !== (_p = this.internalProps.rowTree) && void 0 !== _p ? _p : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_q = this.options.rowExpandLevel) && void 0 !== _q ? _q : 1 : void 0);
        this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree), false === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new FlatDataToObjects({
          rows: this.internalProps.layoutMap.fullRowDimensionKeys,
          columns: this.internalProps.layoutMap.colDimensionKeys,
          indicators: this.internalProps.layoutMap.indicatorKeys,
          indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
          indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
        }, records));
      } else {
        const keysResults = parseColKeyRowKeyForPivotTable(this, options), { rowKeys, columnKeys, indicatorKeys } = keysResults;
        let { columnDimensionTree, rowDimensionTree } = keysResults;
        this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_r = options.indicatorsAsCol) || void 0 === _r || _r, options.records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, false, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords), options.columnTree ? columnDimensionTree.hasHideNode && (deleteHideIndicatorNode(columnDimensionTree.tree.children, options.indicators, true, this), columnDimensionTree.reset(columnDimensionTree.tree.children)) : (false !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), false !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this), columnDimensionTree = new DimensionTree(null !== (_s = this.dataset.colHeaderTree) && void 0 !== _s ? _s : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_t = this.options.columnExpandLevel) && void 0 !== _t ? _t : 1 : void 0)), options.rowTree ? rowDimensionTree.hasHideNode && (deleteHideIndicatorNode(rowDimensionTree.tree.children, options.indicators, true, this), rowDimensionTree.reset(rowDimensionTree.tree.children)) : (false === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), false === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this), rowDimensionTree = new DimensionTree(null !== (_u = this.dataset.rowHeaderTree) && void 0 !== _u ? _u : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_v = this.options.rowExpandLevel) && void 0 !== _v ? _v : 1 : void 0)), this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
      }
      if (this._changePivotSortStateBySortRules(), (null !== (_x = null === (_w = options.pivotSortState) || void 0 === _w ? void 0 : _w.length) && void 0 !== _x ? _x : 0) > 0 && (this.pivotSortState = [], this.pivotSortState = options.pivotSortState), "node" !== Env.mode && (this.editorManager = new EditManager(this)), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.stateManager.initCheckedState(records), this.scenegraph.createSceneGraph(), options.title) {
        const Title3 = Factory2.getComponent("title");
        this.internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
      }
      if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_y = this.internalProps.emptyTip) || void 0 === _y || _y.resetVisible();
      else {
        const EmptyTip3 = Factory2.getComponent("emptyTip");
        this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_z = this.internalProps.emptyTip) || void 0 === _z || _z.resetVisible();
      }
      setTimeout(() => {
        this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
      }, 0);
    }
  }
  static get EVENT_TYPE() {
    return PIVOT_TABLE_EVENT_TYPE;
  }
  isListTable() {
    return false;
  }
  isPivotTable() {
    return true;
  }
  isPivotChart() {
    return false;
  }
  get recordsCount() {
    var _a;
    return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
  }
  _canResizeColumn(col, row) {
    const ifCan = super._canResizeColumn(col, row);
    if (ifCan) {
      if (this.internalProps.layoutMap.isSeriesNumber(col, row) && true === this.internalProps.rowSeriesNumber.disableColumnResize) return false;
      if (!this.internalProps.layoutMap.indicatorsAsCol) {
        const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
        if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return false;
      }
    }
    return ifCan;
  }
  updateOption(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
    const internalProps = this.internalProps;
    if (super.updateOption(options), options.rowHierarchyType || (options.rowHierarchyType = "grid"), options.columnHierarchyType || (options.columnHierarchyType = "grid"), this.layoutNodeId = {
      seqId: 0
    }, this.internalProps.columns = cloneDeep(options.columns), this.internalProps.rows = cloneDeep(options.rows), this.internalProps.indicators = (null === (_a = options.indicators) || void 0 === _a ? void 0 : _a.length) ? cloneDeepSpec(options.indicators) : [], null === (_b = options.indicators) || void 0 === _b || _b.forEach((indicatorDefine, index) => {
      "object" == typeof indicatorDefine && (null == indicatorDefine ? void 0 : indicatorDefine.editor) && (this.internalProps.indicators[index].editor = indicatorDefine.editor);
    }), this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_c = options.columns) || void 0 === _c ? void 0 : _c.length) || options.columnTree ? cloneDeep(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_d = options.rows) || void 0 === _d ? void 0 : _d.length) || options.rowTree ? cloneDeep(options.rowTree) : [], options.records && (this.internalProps.records = options.records), this.stateManager.initCheckedState(this.internalProps.records), this.stateManager.updateDrillState(void 0, void 0, false, false, -1, -1), this.pagination = options.pagination, internalProps.columnResizeType = null !== (_g = null !== (_f = null === (_e = options.resize) || void 0 === _e ? void 0 : _e.columnResizeType) && void 0 !== _f ? _f : options.columnResizeType) && void 0 !== _g ? _g : "column", internalProps.rowResizeType = null !== (_k = null !== (_j = null === (_h = options.resize) || void 0 === _h ? void 0 : _h.rowResizeType) && void 0 !== _j ? _j : options.rowResizeType) && void 0 !== _k ? _k : "row", internalProps.dataConfig = cloneDeep(options.dataConfig), this.internalProps.columnWidthConfig = options.columnWidthConfig, this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader, "grid" !== (null == options ? void 0 : options.rowHierarchyType) && "grid" !== this.internalProps.layoutMap.rowHierarchyType && this.internalProps.layoutMap.rowExpandLevel === (null == options ? void 0 : options.rowExpandLevel)) {
      const beforeRowDimensions = this.internalProps.layoutMap.rowDimensionTree.tree.children;
      null === (_l = this.internalProps.rowTree) || void 0 === _l || _l.forEach((node, index) => {
        const beforeRowDimension = beforeRowDimensions.find((item) => item.dimensionKey === node.dimensionKey && item.value === node.value);
        beforeRowDimension && this._syncHierarchyState(beforeRowDimension, node);
      });
    }
    const records = this.internalProps.records;
    if (this.internalProps.recordsIsTwoDimensionalArray = false, (null === (_m = null == records ? void 0 : records[0]) || void 0 === _m ? void 0 : _m.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = true), false === (null === (_o = options.customConfig) || void 0 === _o ? void 0 : _o.enableDataAnalysis)) {
      let columnDimensionTree, rowDimensionTree;
      options.columnTree && (columnDimensionTree = new DimensionTree(null !== (_p = this.internalProps.columnTree) && void 0 !== _p ? _p : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_q = this.options.columnExpandLevel) && void 0 !== _q ? _q : 1 : void 0)), options.rowTree && (rowDimensionTree = new DimensionTree(null !== (_r = this.internalProps.rowTree) && void 0 !== _r ? _r : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_s = this.options.rowExpandLevel) && void 0 !== _s ? _s : 1 : void 0)), internalProps.layoutMap.clearHeaderPathCache(), internalProps.layoutMap = new PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree), false === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new FlatDataToObjects({
        rows: internalProps.layoutMap.fullRowDimensionKeys,
        columns: internalProps.layoutMap.colDimensionKeys,
        indicators: internalProps.layoutMap.indicatorKeys,
        indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
        indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
      }, records));
    } else {
      const keysResults = parseColKeyRowKeyForPivotTable(this, options), { rowKeys, columnKeys, indicatorKeys } = keysResults;
      let { columnDimensionTree, rowDimensionTree } = keysResults;
      this.dataset = new Dataset(internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_t = options.indicatorsAsCol) || void 0 === _t || _t, records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, false, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords), options.columnTree ? columnDimensionTree.hasHideNode && (deleteHideIndicatorNode(columnDimensionTree.tree.children, options.indicators, true, this), columnDimensionTree.reset(columnDimensionTree.tree.children)) : (false !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), false !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this), columnDimensionTree = new DimensionTree(null !== (_u = this.dataset.colHeaderTree) && void 0 !== _u ? _u : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_v = this.options.columnExpandLevel) && void 0 !== _v ? _v : 1 : void 0)), options.rowTree ? rowDimensionTree.hasHideNode && (deleteHideIndicatorNode(rowDimensionTree.tree.children, options.indicators, true, this), rowDimensionTree.reset(rowDimensionTree.tree.children)) : (false === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), false === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this), rowDimensionTree = new DimensionTree(null !== (_w = this.dataset.rowHeaderTree) && void 0 !== _w ? _w : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_x = this.options.rowExpandLevel) && void 0 !== _x ? _x : 1 : void 0)), internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
    }
    if (this._changePivotSortStateBySortRules(), (null !== (_z = null === (_y = options.pivotSortState) || void 0 === _y ? void 0 : _y.length) && void 0 !== _z ? _z : 0) > 0 && (this.pivotSortState = [], this.pivotSortState = options.pivotSortState), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj) => {
      var _a2;
      return null === (_a2 = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a2 ? void 0 : _a2.call(releaseObj);
    }), internalProps.releaseList = null), this.scenegraph.clearCells(), this.scenegraph.createSceneGraph(), options.title) {
      const Title3 = Factory2.getComponent("title");
      this.internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
    }
    if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_0 = this.internalProps.emptyTip) || void 0 === _0 || _0.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_1 = this.internalProps.emptyTip) || void 0 === _1 || _1.resetVisible();
    }
    return new Promise((resolve) => {
      setTimeout(resolve, 0);
    });
  }
  updatePagination(pagination) {
    this.internalProps.layoutMap.clearHeaderPathCache(), pagination ? (this.pagination || (this.pagination = {
      currentPage: 0,
      perPageCount: 0
    }), "number" == typeof pagination.currentPage && pagination.currentPage >= 0 && (this.pagination.currentPage = pagination.currentPage), pagination.perPageCount && (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount), this.scenegraph.clearCells(), this.internalProps.layoutMap.setPagination(this.pagination), this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render()) : this.pagination && (this.pagination = void 0, this.scenegraph.clearCells(), this.internalProps.layoutMap.setPagination(void 0), this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render());
  }
  refreshHeader() {
    this.setMinMaxLimitWidth(true), this.refreshRowColCount();
  }
  refreshRowColCount() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const table = this, { layoutMap } = table.internalProps;
    layoutMap && (table.colCount = null !== (_a = layoutMap.colCount) && void 0 !== _a ? _a : 0, table.rowCount = null !== (_b = layoutMap.rowCount) && void 0 !== _b ? _b : 0, this.internalProps.frozenColCount = this.options.frozenColCount ? this.options.frozenColCount : (null !== (_c = layoutMap.rowHeaderLevelCount) && void 0 !== _c ? _c : 0) + layoutMap.leftRowSeriesNumberColumnCount, table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_d = this.options.frozenRowCount) && void 0 !== _d ? _d : 0), table.bottomFrozenRowCount !== (null !== (_e = this.options.bottomFrozenRowCount) && void 0 !== _e ? _e : 0) && (table.bottomFrozenRowCount = null !== (_f = this.options.bottomFrozenRowCount) && void 0 !== _f ? _f : 0), table.rightFrozenColCount !== (null !== (_g = this.options.rightFrozenColCount) && void 0 !== _g ? _g : 0) && (table.rightFrozenColCount = null !== (_h = this.options.rightFrozenColCount) && void 0 !== _h ? _h : 0), this.stateManager.setFrozenCol(this.internalProps.frozenColCount), this.stateManager.setFrozenRow(this.frozenRowCount));
  }
  _getSortFuncFromHeaderOption(columns, field, fieldKey) {
  }
  get rowHierarchyType() {
    return this.internalProps.layoutMap.rowHierarchyType;
  }
  get columnHierarchyType() {
    return this.internalProps.layoutMap.columnHierarchyType;
  }
  _syncHierarchyState(sourceNode, targetNode) {
    var _a, _b;
    sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey && (targetNode.hierarchyState = null !== (_a = targetNode.hierarchyState) && void 0 !== _a ? _a : (null == targetNode ? void 0 : targetNode.children) ? sourceNode.hierarchyState : void 0, null === (_b = null == targetNode ? void 0 : targetNode.children) || void 0 === _b || _b.forEach((targetChildNode, index) => {
      var _a2;
      if ((null === (_a2 = null == sourceNode ? void 0 : sourceNode.children) || void 0 === _a2 ? void 0 : _a2[index]) && targetChildNode) {
        const beforeRowDimension = sourceNode.children.find((item) => item.dimensionKey === targetChildNode.dimensionKey && item.value === targetChildNode.value);
        beforeRowDimension && this._syncHierarchyState(beforeRowDimension, targetChildNode);
      }
    }));
  }
  getRecordShowIndexByCell(col, row) {
  }
  getTableIndexByRecordIndex(recordIndex) {
  }
  getTableIndexByField(field) {
  }
  getCellAddrByFieldRecord(field, recordIndex) {
  }
  getBodyIndexByRow(row) {
    const { layoutMap } = this.internalProps;
    return layoutMap.getBodyIndexByRow(row);
  }
  getBodyIndexByCol(col) {
    const { layoutMap } = this.internalProps;
    return layoutMap.getBodyIndexByCol(col);
  }
  getFieldData(field, col, row) {
    var _a, _b, _c;
    if (!this.internalProps.layoutMap.isHeader(col, row)) {
      if (this.internalProps.recordsIsTwoDimensionalArray) {
        const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
        return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
      }
      if (this.dataset) {
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
        if (cellDimensionPath) {
          let indicatorPosition;
          const colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual).map((colPath, index) => {
            var _a2;
            return colPath.indicatorKey && (indicatorPosition = {
              position: "col",
              index
            }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
          }), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path) => !path.virtual).map((rowPath, index) => {
            var _a2;
            return rowPath.indicatorKey && (indicatorPosition = {
              position: "row",
              index
            }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
          }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
          if (aggregator2.records && aggregator2.records.length >= 1) return aggregator2.records[0][field];
        }
      } else if (this.flatDataToObjects) {
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
          var _a2;
          return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
          var _a2;
          return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        }), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
        if (null == treeNode ? void 0 : treeNode.record) return null == treeNode ? void 0 : treeNode.record[field];
      }
    }
  }
  getCellValue(col, row, skipCustomMerge) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!skipCustomMerge) {
      const customMergeText = this.getCustomMergeValue(col, row);
      if (customMergeText) return customMergeText;
    }
    if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
      if (this.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
        const { title } = this.internalProps.layoutMap.getSeriesNumberHeader(col, row);
        return title;
      }
      const { format } = this.internalProps.layoutMap.getSeriesNumberBody(col, row);
      return "function" == typeof format ? format(col, row, this) : row - this.columnHeaderLevelCount + 1;
    }
    if (this.internalProps.layoutMap.isHeader(col, row)) {
      const { title, fieldFormat } = this.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof fieldFormat ? fieldFormat(title, col, row, this) : title;
    }
    if (this.internalProps.recordsIsTwoDimensionalArray) {
      const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row), rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col), dataValue = null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
      if ("function" == typeof fieldFormat) {
        return fieldFormat(dataValue, col, row, this);
      }
      return dataValue;
    }
    if (this.dataset) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
      let indicatorPosition;
      const colKeys = null === (_c = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual)) || void 0 === _c ? void 0 : _c.map((colPath, index) => {
        var _a2;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = null === (_e = null === (_d = cellDimensionPath.rowHeaderPaths) || void 0 === _d ? void 0 : _d.filter((path) => !path.virtual)) || void 0 === _e ? void 0 : _e.map((rowPath, index) => {
        var _a2;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition), { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
      return aggregator2.formatValue ? aggregator2.formatValue(col, row, this) : "function" == typeof fieldFormat ? fieldFormat(null == aggregator2 ? void 0 : aggregator2.value(), col, row, this) : null !== (_f = null == aggregator2 ? void 0 : aggregator2.value()) && void 0 !== _f ? _f : "";
    }
    if (this.flatDataToObjects) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
        var _a2;
        return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
        var _a2;
        return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), valueNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey), { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
      return "function" == typeof fieldFormat ? fieldFormat(null == valueNode ? void 0 : valueNode.value, col, row, this) : null !== (_g = null == valueNode ? void 0 : valueNode.value) && void 0 !== _g ? _g : "";
    }
  }
  getCellOriginValue(col, row) {
    var _a, _b, _c;
    const table = this;
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    if (this.internalProps.recordsIsTwoDimensionalArray) {
      const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
      return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
    }
    if (this.dataset) {
      let indicatorPosition;
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual).map((colPath, index) => {
        var _a2;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path) => !path.virtual).map((rowPath, index) => {
        var _a2;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
      return aggregator2.value ? aggregator2.value() : void 0;
    }
    if (this.flatDataToObjects) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
        var _a2;
        return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
        var _a2;
        return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
      return null == treeNode ? void 0 : treeNode.value;
    }
  }
  getCellRawValue(col, row) {
    var _a, _b, _c;
    const table = this;
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    if (this.internalProps.recordsIsTwoDimensionalArray) {
      const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
      return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
    }
    if (this.dataset) {
      let indicatorPosition;
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual).map((colPath, index) => {
        var _a2;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path) => !path.virtual).map((rowPath, index) => {
        var _a2;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), false, indicatorPosition);
      return aggregator2.value ? aggregator2.value() : void 0;
    }
    if (this.flatDataToObjects) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
        var _a2;
        return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
        var _a2;
        return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
      return null == treeNode ? void 0 : treeNode.value;
    }
  }
  getCellOriginRecord(col, row) {
    var _a, _b, _c;
    if (!this.internalProps.layoutMap.isHeader(col, row)) {
      if (this.internalProps.recordsIsTwoDimensionalArray) {
        const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
        return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
      }
      if (this.dataset) {
        let indicatorPosition;
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual).map((colPath, index) => {
          var _a2;
          return colPath.indicatorKey && (indicatorPosition = {
            position: "col",
            index
          }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path) => !path.virtual).map((rowPath, index) => {
          var _a2;
          return rowPath.indicatorKey && (indicatorPosition = {
            position: "row",
            index
          }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        });
        return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition).records;
      }
      if (this.flatDataToObjects) {
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
          var _a2;
          return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
          var _a2;
          return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        }), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
        return null == treeNode ? void 0 : treeNode.record;
      }
    }
  }
  getCellRawRecord(col, row) {
    var _a, _b, _c;
    if (!this.internalProps.layoutMap.isHeader(col, row)) {
      if (this.internalProps.recordsIsTwoDimensionalArray) {
        const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
        return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
      }
      if (this.dataset) {
        let indicatorPosition;
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path) => !path.virtual).map((colPath, index) => {
          var _a2;
          return colPath.indicatorKey && (indicatorPosition = {
            position: "col",
            index
          }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path) => !path.virtual).map((rowPath, index) => {
          var _a2;
          return rowPath.indicatorKey && (indicatorPosition = {
            position: "row",
            index
          }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        });
        return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), false, indicatorPosition).records;
      }
      if (this.flatDataToObjects) {
        const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
          var _a2;
          return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
          var _a2;
          return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        }), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
        return null == treeNode ? void 0 : treeNode.record;
      }
    }
  }
  updateSortRules(sortRules, col, row) {
    this.internalProps.dataConfig ? this.internalProps.dataConfig.sortRules = sortRules : this.internalProps.dataConfig = {
      sortRules
    }, this.dataset.updateSortRules(sortRules), this._changePivotSortStateBySortRules();
    const { layoutMap } = this.internalProps;
    layoutMap.resetHeaderTree(), this.scenegraph.clearCells(), isNumber_default(col) && isNumber_default(row) ? (this.isRowHeader(col, row) ? (this.setMinMaxLimitWidth(true), this.internalProps._widthResizedColMap.clear()) : this.isCornerHeader(col, row) ? "column" === layoutMap.cornerSetting.titleOnDimension ? (this.setMinMaxLimitWidth(true), this.internalProps._widthResizedColMap.clear()) : "row" === layoutMap.cornerSetting.titleOnDimension && this.internalProps._heightResizedRowMap.clear() : this.isColumnHeader(col, row) && this.internalProps._heightResizedRowMap.clear(), this.refreshRowColCount()) : this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.createSceneGraph(true), this.render();
  }
  _changePivotSortStateBySortRules() {
    var _a, _b, _c, _d;
    this.pivotSortState = [];
    const sortRules = null !== (_b = null === (_a = this.internalProps.dataConfig) || void 0 === _a ? void 0 : _a.sortRules) && void 0 !== _b ? _b : [];
    for (let i = 0; i < sortRules.length; i++) {
      const sortRule = sortRules[i], dimensions = [];
      if (sortRule.sortByIndicator && sortRule.sortField === (this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1])) {
        for (let j = 0; j < sortRule.query.length; j++) dimensions.push({
          dimensionKey: this.dataset.indicatorsAsCol ? this.dataset.columns[j] : this.dataset.rows[j],
          value: sortRule.query[j]
        });
        dimensions.push({
          indicatorKey: sortRule.sortByIndicator,
          value: null !== (_d = null === (_c = this.internalProps.layoutMap.getIndicatorInfo(sortRule.sortByIndicator)) || void 0 === _c ? void 0 : _c.title) && void 0 !== _d ? _d : sortRule.sortByIndicator
        });
      } else dimensions.push({
        dimensionKey: sortRule.sortField,
        isPivotCorner: true,
        value: sortRule.sortField
      });
      const sortType = sortRule.sortType ? sortRule.sortType.toUpperCase() : "ASC";
      this.pivotSortState.push({
        dimensions,
        order: SortType[sortType]
      });
    }
  }
  _parseColumnWidthConfig(columnWidthConfig) {
    for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
      const item = columnWidthConfig[i], dimensions = item.dimensions, width = item.width, cell = this.getCellAddressByHeaderPaths(dimensions);
      if (cell && cell.col >= this.rowHeaderLevelCount) {
        const cellPath = this.getCellHeaderPaths(cell.col, this.columnHeaderLevelCount);
        if (cellPath.colHeaderPaths.length === dimensions.length) {
          let match = true;
          for (let i2 = 0; i2 < dimensions.length; i2++) {
            const dimension = dimensions[i2];
            if (cellPath.colHeaderPaths.findIndex((colPath, index) => colPath.indicatorKey === dimension.indicatorKey || colPath.dimensionKey === dimension.dimensionKey && colPath.value === dimension.value) < 0) {
              match = false;
              break;
            }
          }
          match && !this.internalProps._widthResizedColMap.has(cell.col) && (this._setColWidth(cell.col, width), this.internalProps._widthResizedColMap.add(cell.col));
        }
      } else cell && cell.col < this.rowHeaderLevelCount && (this.internalProps._widthResizedColMap.has(cell.col) || (this._setColWidth(cell.col, width), this.internalProps._widthResizedColMap.add(cell.col)));
    }
  }
  _parseColumnWidthConfigForRowHeader(columnWidthConfig) {
    for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
      const item = columnWidthConfig[i], dimensions = item.dimensions, width = item.width, cell = this.getCellAddressByHeaderPaths(dimensions);
      cell && cell.col < this.rowHeaderLevelCount && (this.internalProps._widthResizedColMap.has(cell.col) || (this._setColWidth(cell.col, width), this.internalProps._widthResizedColMap.add(cell.col)));
    }
  }
  updatePivotSortState(pivotSortStateConfig) {
    this.pivotSortState = pivotSortStateConfig;
  }
  sort(col, row, order) {
    var _a, _b;
    let dimensions;
    if (this.isCornerHeader(col, row)) {
      const dimensionInfo = this.getHeaderDefine(col, row);
      dimensions = [];
      const dimension = {
        isPivotCorner: true,
        dimensionKey: dimensionInfo.value,
        value: dimensionInfo.value
      };
      dimensions.push(dimension);
    } else dimensions = this.isColumnHeader(col, row) ? this.getCellHeaderPaths(col, row).colHeaderPaths : this.getCellHeaderPaths(col, row).rowHeaderPaths;
    const sortIndicator = dimensions[dimensions.length - 1].indicatorKey, headerDefine = this.getHeaderDefine(col, row);
    if (headerDefine.sort) {
      if (this.dataset.sortRules) {
        const cacheOldDimensionSortRule = {};
        for (let i = this.dataset.sortRules.length - 1; i >= 0; i--) {
          const sortRule = this.dataset.sortRules[i];
          (headerDefine.dimensionKey && sortRule.sortField === headerDefine.dimensionKey || sortIndicator && sortRule.sortField === (this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1])) && (cacheOldDimensionSortRule[sortRule.sortField] = sortRule, this.dataset.sortRules.splice(i, 1));
        }
        if (sortIndicator) {
          const sortField = this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1];
          this.dataset.sortRules.push({
            sortField,
            sortType: SortType[order],
            sortByIndicator: sortIndicator,
            query: dimensions.reduce((arr, dimension) => (dimension.dimensionKey && arr.push(dimension.value), arr), []),
            sortFunc: null === (_a = cacheOldDimensionSortRule[sortField]) || void 0 === _a ? void 0 : _a.sortFunc
          });
        } else this.dataset.sortRules.push(Object.assign(null !== (_b = cacheOldDimensionSortRule[headerDefine.dimensionKey]) && void 0 !== _b ? _b : {}, {
          sortField: headerDefine.dimensionKey,
          sortType: SortType[order]
        }));
      } else this.dataset.sortRules = sortIndicator ? [{
        sortField: this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1],
        sortType: SortType[order],
        sortByIndicator: sortIndicator,
        query: dimensions.reduce((arr, dimension) => (dimension.dimensionKey && arr.push(dimension.value), arr), [])
      }] : [{
        sortField: headerDefine.dimensionKey,
        sortType: SortType[order]
      }];
      this.updateSortRules(this.dataset.sortRules, col, row);
    }
  }
  getPivotSortState(col, row) {
    if (!this.pivotSortState) return;
    const cellRange = this.getCellRange(col, row);
    for (let i = 0; i < this.pivotSortState.length; i++) {
      const pivotState = this.pivotSortState[i], dimensions = pivotState.dimensions, cell = this.getCellAddressByHeaderPaths(dimensions), order = pivotState.order;
      if (cell && cellInRange(cellRange, cell.col, cell.row)) return order;
    }
  }
  _moveHeaderPosition(source, target) {
    const sourceCellRange = this.getCellRange(source.col, source.row), targetCellRange = this.getCellRange(target.col, target.row), moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
    if (moveContext) {
      if ("column" === moveContext.moveType) {
        if (this.internalProps.recordsIsTwoDimensionalArray) for (let row = 0; row < this.internalProps.records.length; row++) {
          const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
          sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
        }
        this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex), this.setMinMaxLimitWidth();
      } else if ("row" === moveContext.moveType) {
        if (this.internalProps.recordsIsTwoDimensionalArray) {
          const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
          sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records, sourceRows);
        }
        moveContext.targetIndex > moveContext.sourceIndex ? this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex) : this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex);
      }
      return moveContext;
    }
    return null;
  }
  toggleHierarchyState(col, row, recalculateColWidths = true) {
    this.internalProps.layoutMap.clearHeaderPathCache();
    const hierarchyState = this.getHierarchyState(col, row);
    if (hierarchyState === HierarchyState.expand) this._refreshHierarchyState(col, row, recalculateColWidths), this.fireListeners(PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
      col,
      row,
      hierarchyState: HierarchyState.collapse
    });
    else if (hierarchyState === HierarchyState.collapse) {
      const headerTreeNode = this.internalProps.layoutMap.getHeadNode(col, row);
      Array.isArray(headerTreeNode.children) && this._refreshHierarchyState(col, row, recalculateColWidths), this.fireListeners(PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
        col,
        row,
        hierarchyState: HierarchyState.expand,
        originData: headerTreeNode
      });
    }
  }
  _refreshHierarchyState(col, row, recalculateColWidths = true, beforeUpdateCell) {
    var _a, _b;
    this.frozenColCount, this.frozenRowCount;
    const visibleStartRow = this.getBodyVisibleRowRange().rowStart;
    this.internalProps._oldRowCount = this.rowCount, this.internalProps._oldColCount = this.colCount;
    let notFillWidth = false, notFillHeight = false;
    this.stateManager.updateHoverIcon(col, row, void 0, void 0);
    const checkHasChart2 = this.internalProps.layoutMap.checkHasChart();
    checkHasChart2 && (this.autoFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), this.autoFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight));
    const result2 = this.internalProps.layoutMap.isRowHeader(col, row) ? this.internalProps.layoutMap.toggleHierarchyState(col, row) : this.internalProps.layoutMap.toggleHierarchyStateForColumnTree(col, row);
    beforeUpdateCell && beforeUpdateCell(), this.refreshRowColCount();
    this.frozenColCount, this.frozenRowCount;
    this.clearCellStyleCache(), "tree" === this.rowHierarchyType && this.scenegraph.updateHierarchyIcon(col, row), null === (_a = this.reactCustomLayout) || void 0 === _a || _a.clearCache(), "grid-tree" !== this.rowHierarchyType && "grid-tree" !== this.columnHierarchyType ? this.scenegraph.updateRow(result2.removeCellPositionsRowDirection, result2.addCellPositionsRowDirection, result2.updateCellPositionsRowDirection, recalculateColWidths) : (this.internalProps.stick.changedCells.clear(), this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.scrollToRow(visibleStartRow)), null === (_b = this.reactCustomLayout) || void 0 === _b || _b.updateAllCustomCell(), checkHasChart2 && (this.autoFillWidth && !notFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), this.autoFillHeight && !notFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight), ("adaptive" === this.widthMode || notFillWidth || "adaptive" === this.heightMode || notFillHeight) && this.scenegraph.updateChartSizeForResizeColWidth(-1)), this.internalProps._oldRowCount = void 0, this.internalProps._oldColCount = void 0;
  }
  getHeaderCellAddressByPath(dimensionPaths) {
    return this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
  }
  getCellAddressByHeaderPaths(dimensionPaths) {
    return this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
  }
  getHeaderPathByXY(coordinate) {
    let cellAddr;
    cellAddr = coordinate ? this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1) : this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
    return this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
  }
  getHierarchyState(col, row) {
    var _a;
    return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
  }
  getLayoutColumnTree() {
    return this.internalProps.layoutMap.getLayoutColumnTree();
  }
  getLayoutColumnTreeCount() {
    return this.internalProps.layoutMap.getLayoutColumnTreeCount();
  }
  getLayoutRowTree() {
    return this.internalProps.layoutMap.getLayoutRowTree();
  }
  getLayoutRowTreeCount() {
    return this.internalProps.layoutMap.getLayoutRowTreeCount();
  }
  getCellHeaderTreeNodes(col, row) {
    return this.internalProps.layoutMap.getCellHeaderPathsWithTreeNode(col, row);
  }
  getMenuInfo(col, row, type) {
    const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
    return {
      dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
      value: this.getCellValue(col, row),
      cellLocation: this.getCellLocation(col, row),
      isPivotCorner: this.isCornerHeader(col, row),
      event: void 0
    };
  }
  setRecords(records) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    clearChartRenderQueue();
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    this.options.records = this.internalProps.records = records, this.internalProps.recordsIsTwoDimensionalArray = false, (null === (_a = null == records ? void 0 : records[0]) || void 0 === _a ? void 0 : _a.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = true);
    const options = this.options, internalProps = this.internalProps;
    if (false === (null === (_b = this.options.customConfig) || void 0 === _b ? void 0 : _b.enableDataAnalysis)) false === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new FlatDataToObjects({
      rows: internalProps.layoutMap.fullRowDimensionKeys,
      columns: internalProps.layoutMap.colDimensionKeys,
      indicators: internalProps.layoutMap.indicatorKeys,
      indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
      indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
    }, records));
    else {
      let columnDimensionTree, rowDimensionTree;
      this.dataset.setRecords(records), options.columnTree ? columnDimensionTree = internalProps.layoutMap.columnDimensionTree : (false !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this), columnDimensionTree = new DimensionTree(null !== (_c = this.dataset.colHeaderTree) && void 0 !== _c ? _c : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_d = this.options.columnExpandLevel) && void 0 !== _d ? _d : 1 : void 0)), options.rowTree ? rowDimensionTree = internalProps.layoutMap.rowDimensionTree : (false === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this), rowDimensionTree = new DimensionTree(null !== (_e = this.dataset.rowHeaderTree) && void 0 !== _e ? _e : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_f = this.options.rowExpandLevel) && void 0 !== _f ? _f : 1 : void 0)), internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), this.pivotSortState = [], options.pivotSortState && (this.pivotSortState = options.pivotSortState);
    }
    if (this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), this.internalProps.title.resize(), this.scenegraph.resize()), this.eventManager.updateEventBinder(), this.options.emptyTip) if (this.internalProps.emptyTip) null === (_g = this.internalProps.emptyTip) || void 0 === _g || _g.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible();
    }
  }
  startEditCell(col, row, value) {
    var _a;
    if (isValid_default(col) && isValid_default(row)) this.eventManager.isDraging = false, this.selectCell(col, row), this.editorManager.startEditCell(col, row, value);
    else if (null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.cellPos) {
      const { col: col2, row: row2 } = this.stateManager.select.cellPos;
      isValid_default(col2) && isValid_default(row2) && this.editorManager.startEditCell(col2, row2, value);
    }
  }
  completeEditCell() {
    this.editorManager.completeEdit();
  }
  getEditor(col, row) {
    var _a, _b, _c;
    let editorDefine;
    if (this.isCornerHeader(col, row)) {
      const define = this.getHeaderDefine(col, row);
      editorDefine = null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor;
    } else if (this.isHeader(col, row)) {
      const define = this.getHeaderDefine(col, row);
      editorDefine = null !== (_b = null == define ? void 0 : define.headerEditor) && void 0 !== _b ? _b : this.options.headerEditor;
    } else {
      const define = this.getBodyColumnDefine(col, row);
      editorDefine = null !== (_c = null == define ? void 0 : define.editor) && void 0 !== _c ? _c : this.options.editor;
    }
    if ("function" == typeof editorDefine) {
      editorDefine = editorDefine({
        col,
        row,
        dataValue: this.getCellOriginValue(col, row),
        value: this.getCellValue(col, row) || "",
        table: this
      });
    }
    return "string" == typeof editorDefine ? get5(editorDefine) : editorDefine;
  }
  isHasEditorDefine(col, row) {
    var _a;
    const define = this.getBodyColumnDefine(col, row);
    let editorDefine = null !== (_a = null == define ? void 0 : define.editor) && void 0 !== _a ? _a : this.options.editor;
    if ("function" == typeof editorDefine) {
      editorDefine = editorDefine({
        col,
        row,
        dataValue: this.getCellOriginValue(col, row),
        value: this.getCellValue(col, row) || "",
        table: this
      });
    }
    return isValid_default(editorDefine);
  }
  changeCellValue(col, row, value, workOnEditableCell = false) {
    if (workOnEditableCell && this.isHasEditorDefine(col, row) || false === workOnEditableCell) {
      let newValue = value;
      const oldValue = this.getCellOriginValue(col, row), rawValue = this.getCellRawValue(col, row);
      "number" == typeof rawValue && isAllDigits(value) && (newValue = parseFloat(value)), this._changeCellValueToDataSet(col, row, oldValue, newValue);
      const range5 = this.getCellRange(col, row);
      for (let sCol = range5.start.col; sCol <= range5.end.col; sCol++) for (let sRow = range5.start.row; sRow <= range5.end.row; sRow++) this.scenegraph.updateCellContent(sCol, sRow);
      if ("adaptive" === this.widthMode || this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth) 0 === this.internalProps._widthResizedColMap.size && this.scenegraph.recalculateColWidths();
      else if (!this.internalProps._widthResizedColMap.has(col)) {
        const oldWidth = this.getColWidth(col), newWidth = computeColWidth(col, 0, this.rowCount - 1, this, false);
        newWidth !== oldWidth && this.scenegraph.updateColWidth(col, newWidth - oldWidth);
      }
      if ("adaptive" === this.heightMode || this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight) 0 === this.internalProps._heightResizedRowMap.size && this.scenegraph.recalculateRowHeights();
      else if (this.isAutoRowHeight(row) && !this.internalProps._heightResizedRowMap.has(row)) {
        const oldHeight = this.getRowHeight(row), newHeight = computeRowHeight(row, 0, this.colCount - 1, this);
        this.scenegraph.updateRowHeight(row, newHeight - oldHeight);
      }
      oldValue !== newValue && this.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
        col,
        row,
        rawValue,
        currentValue: oldValue,
        changedValue: newValue
      }), this.scenegraph.updateNextFrame();
    }
  }
  changeCellValues(startCol, startRow, values, workOnEditableCell = false) {
    let pasteColEnd = startCol, pasteRowEnd = startRow;
    const beforeChangeValues = [], oldValues = [];
    for (let i = 0; i < values.length && !(startRow + i > this.rowCount - 1); i++) {
      const rowValues = values[i], rawRowValues = [], oldRowValues = [];
      beforeChangeValues.push(rawRowValues), oldValues.push(oldRowValues);
      for (let j = 0; j < rowValues.length && !(startCol + j > this.colCount - 1); j++) {
        const beforeChangeValue = this.getCellRawValue(startCol + j, startRow + i);
        rawRowValues.push(beforeChangeValue);
        const oldValue = this.getCellOriginValue(startCol + j, startRow + i);
        oldRowValues.push(oldValue);
      }
    }
    for (let i = 0; i < values.length && !(startRow + i > this.rowCount - 1); i++) {
      pasteRowEnd = startRow + i;
      const rowValues = values[i];
      let thisRowPasteColEnd = startCol;
      for (let j = 0; j < rowValues.length && !(startCol + j > this.colCount - 1); j++) if (thisRowPasteColEnd = startCol + j, workOnEditableCell && this.isHasEditorDefine(startCol + j, startRow + i) || false === workOnEditableCell) {
        const value = rowValues[j];
        let newValue = value;
        const oldValue = oldValues[i][j], rawValue = beforeChangeValues[i][j];
        "number" == typeof rawValue && isAllDigits(value) && (newValue = parseFloat(value)), this._changeCellValueToDataSet(startCol + j, startRow + i, oldValue, newValue);
        const changedValue = this.getCellOriginValue(startCol + j, startRow + i);
        changedValue !== oldValue && this.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
          col: startCol + j,
          row: startRow + i,
          rawValue,
          currentValue: oldValue,
          changedValue
        });
      }
      pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
    }
    const startRange = this.getCellRange(startCol, startRow), range5 = this.getCellRange(pasteColEnd, pasteRowEnd);
    for (let sCol = startRange.start.col; sCol <= range5.end.col; sCol++) for (let sRow = startRange.start.row; sRow <= range5.end.row; sRow++) this.scenegraph.updateCellContent(sCol, sRow);
    if ("adaptive" === this.widthMode || this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth) 0 === this.internalProps._widthResizedColMap.size && this.scenegraph.recalculateColWidths();
    else for (let sCol = startCol; sCol <= range5.end.col; sCol++) if (!this.internalProps._widthResizedColMap.has(sCol)) {
      const oldWidth = this.getColWidth(sCol), newWidth = computeColWidth(sCol, 0, this.rowCount - 1, this, false);
      newWidth !== oldWidth && this.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
    }
    if ("adaptive" === this.heightMode || this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight) this.scenegraph.recalculateRowHeights();
    else if (this.isAutoRowHeight(startRow)) {
      const rows = [], deltaYs = [];
      for (let sRow = startRow; sRow <= range5.end.row; sRow++) if (this.rowHeightsMap.get(sRow)) {
        const oldHeight = this.getRowHeight(sRow), newHeight = computeRowHeight(sRow, 0, this.colCount - 1, this);
        rows.push(sRow), deltaYs.push(newHeight - oldHeight);
      }
      this.scenegraph.updateRowsHeight(rows, deltaYs);
    }
    this.scenegraph.updateNextFrame();
  }
  _changeCellValueToDataSet(col, row, oldValue, newValue) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.internalProps.recordsIsTwoDimensionalArray) {
      const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
      this.records[rowIndex][colIndex] = newValue;
    } else if (this.dataset) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
      if (this.isCornerHeader(col, row)) this.internalProps.layoutMap.changeCornerTitle(col, row, newValue);
      else if (this.isHeader(col, row)) this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue), !this.isCornerHeader(col, row) && this.dataset.changeRecordFieldValue((null === (_a = cellDimensionPath.colHeaderPaths) || void 0 === _a ? void 0 : _a.length) ? null !== (_b = cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey) && void 0 !== _b ? _b : cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey : null !== (_c = cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey) && void 0 !== _c ? _c : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue);
      else {
        const colKeys = null === (_d = cellDimensionPath.colHeaderPaths) || void 0 === _d ? void 0 : _d.filter((path) => !path.virtual).map((colPath) => {
          var _a2;
          return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = null === (_e = cellDimensionPath.rowHeaderPaths) || void 0 === _e ? void 0 : _e.filter((path) => !path.virtual).map((rowPath) => {
          var _a2;
          return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        });
        this.dataset.changeTreeNodeValue(this.internalProps.layoutMap.indicatorsAsCol ? rowKeys : rowKeys.slice(0, -1), this.internalProps.layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), newValue);
      }
    } else if (this.flatDataToObjects) {
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
      if (this.isHeader(col, row)) this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue), !this.isCornerHeader(col, row) && this.flatDataToObjects.changeRecordFieldValue((null === (_f = cellDimensionPath.colHeaderPaths) || void 0 === _f ? void 0 : _f.length) ? null !== (_g = cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey) && void 0 !== _g ? _g : cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey : null !== (_h = cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey) && void 0 !== _h ? _h : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue);
      else {
        const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
          var _a2;
          return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
        }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
          var _a2;
          return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
        });
        this.flatDataToObjects.changeTreeNodeValue(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, newValue);
      }
    }
  }
  _hasCustomRenderOrLayout() {
    if (this.options.customRender) return true;
    const { columnsDefine, rowsDefine, indicatorsDefine } = this.internalProps.layoutMap;
    for (let i = 0; i < columnsDefine.length; i++) {
      const columnDefine = columnsDefine[i];
      if ("string" != typeof columnDefine && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) return true;
    }
    for (let i = 0; i < rowsDefine.length; i++) {
      const rowDefine = rowsDefine[i];
      if ("string" != typeof rowDefine && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) return true;
    }
    for (let i = 0; i < indicatorsDefine.length; i++) {
      const indicatorDefine = indicatorsDefine[i];
      if ("string" != typeof indicatorDefine && (indicatorDefine.customLayout || indicatorDefine.headerCustomLayout || indicatorDefine.customRender || indicatorDefine.headerCustomRender)) return true;
    }
    return false;
  }
  changeRecordOrder(source, target) {
  }
  setTreeNodeChildren(children, records, col, row) {
    if (this.flatDataToObjects) {
      this.internalProps.layoutMap.getHeadNode(col, row).children = children, this._refreshHierarchyState(col, row, true, () => {
        this.flatDataToObjects.changeDataConfig({
          rows: this.internalProps.layoutMap.fullRowDimensionKeys,
          columns: this.internalProps.layoutMap.colDimensionKeys,
          indicators: this.internalProps.layoutMap.indicatorKeys,
          indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
          indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
        }), this.flatDataToObjects.addRecords(records);
      });
    } else {
      this.internalProps.layoutMap.getHeadNode(col, row).children = children, this._refreshHierarchyState(col, row, true, () => {
        this.dataset._rowTreeHasChanged(), this.dataset.changeDataConfig({
          rows: this.internalProps.layoutMap.fullRowDimensionKeys,
          columns: this.internalProps.layoutMap.colDimensionKeys
        }), this.dataset.addRecords(records);
      });
    }
  }
  updateFilterRules(filterRules) {
    this.internalProps.dataConfig.filterRules = filterRules, this.dataset.updateFilterRules(filterRules), this.renderWithRecreateCells();
  }
  getFilteredRecords() {
    var _a;
    return null === (_a = this.dataset) || void 0 === _a ? void 0 : _a.filterRules;
  }
  getCellPivotRole(col, row) {
    const path = this.getCellHeaderPaths(col, row), { cellLocation, colHeaderPaths, rowHeaderPaths } = path;
    let colRole = colHeaderPaths.length ? "normal" : void 0, rowRole = rowHeaderPaths.length ? "normal" : void 0;
    return colHeaderPaths.forEach((path2) => {
      "sub-total" === path2.role ? colRole = "sub-total" : "grand-total" === path2.role && (colRole = "grand-total");
    }), rowHeaderPaths.forEach((path2) => {
      "sub-total" === path2.role ? rowRole = "sub-total" : "grand-total" === path2.role && (rowRole = "grand-total");
    }), {
      colRole,
      rowRole,
      cellLocation
    };
  }
  setLoadingHierarchyState(col, row) {
    this.scenegraph.setLoadingHierarchyState(col, row);
  }
  release() {
    this.internalProps.layoutMap.clearHeaderPathCache(), this.editorManager.release(), super.release();
  }
};

// node_modules/@visactor/vtable/es/PivotTable-all.js
registerAxis(), registerEmptyTip(), registerLegend(), registerMenu(), registerTitle(), registerTooltip(), registerChartCell(), registerCheckboxCell(), registerImageCell(), registerProgressBarCell(), registerRadioCell(), registerSparkLineCell(), registerTextCell(), registerVideoCell();
var PivotTableAll = class extends PivotTable {
};

// node_modules/@visactor/vtable/es/PivotTable-simple.js
registerTextCell();
var PivotTableSimple = class extends PivotTable {
};

// node_modules/@visactor/vtable/es/PivotChart.js
registerAxis(), registerEmptyTip(), registerLegend(), registerMenu(), registerTitle(), registerTooltip(), registerChartCell(), registerCheckboxCell(), registerImageCell(), registerProgressBarCell(), registerRadioCell(), registerSparkLineCell(), registerTextCell(), registerVideoCell();
var PivotChart = class extends BaseTable {
  constructor(container2, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    let columnDimensionTree, rowDimensionTree;
    super(container2, options), this.layoutNodeId = {
      seqId: 0
    }, this._selectedDataItemsInChart = [], this._selectedDimensionInChart = [], this._chartEventMap = {}, (options = this.options).layout && Object.assign(options, options.layout), this.internalProps.columns = cloneDeep(options.columns), this.internalProps.rows = cloneDeep(options.rows), this.internalProps.indicators = cloneDeepSpec(options.indicators), this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_a = options.columns) || void 0 === _a ? void 0 : _a.length) || options.columnTree ? cloneDeep(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_b = options.rows) || void 0 === _b ? void 0 : _b.length) || options.rowTree ? cloneDeep(options.rowTree) : [], this.internalProps.records = options.records, this.setCustomStateNameToSpec(), this.internalProps.columnResizeType = null !== (_e = null !== (_d = null === (_c = options.resize) || void 0 === _c ? void 0 : _c.columnResizeType) && void 0 !== _d ? _d : options.columnResizeType) && void 0 !== _e ? _e : "column", this.internalProps.rowResizeType = null !== (_h = null !== (_g = null === (_f = options.resize) || void 0 === _f ? void 0 : _f.rowResizeType) && void 0 !== _g ? _g : options.rowResizeType) && void 0 !== _h ? _h : "row", this.internalProps.dataConfig = {
      isPivotChart: true
    }, this._axes = isArray_default(options.axes) ? options.axes : [], options.columnTree && (false !== options.indicatorsAsCol && (this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_j = this.internalProps.columnTree) && void 0 !== _j ? _j : [], this.layoutNodeId)), options.rowTree && (false === options.indicatorsAsCol && (this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators)), rowDimensionTree = new DimensionTree(null !== (_k = this.internalProps.rowTree) && void 0 !== _k ? _k : [], this.layoutNodeId));
    const rowKeys = (null === (_l = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _l ? void 0 : _l.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_o = null === (_m = options.rows) || void 0 === _m ? void 0 : _m.reduce((keys2, rowObj) => ("string" == typeof rowObj ? keys2.push(rowObj) : keys2.push(rowObj.dimensionKey), keys2), [])) && void 0 !== _o ? _o : [], columnKeys = (null === (_p = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _p ? void 0 : _p.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_r = null === (_q = options.columns) || void 0 === _q ? void 0 : _q.reduce((keys2, columnObj) => ("string" == typeof columnObj ? keys2.push(columnObj) : keys2.push(columnObj.dimensionKey), keys2), [])) && void 0 !== _r ? _r : [], indicatorKeys = null !== (_t = null === (_s = options.indicators) || void 0 === _s ? void 0 : _s.reduce((keys2, indicatorObj) => ("string" == typeof indicatorObj ? keys2.push(indicatorObj) : keys2.push(indicatorObj.indicatorKey), keys2), [])) && void 0 !== _t ? _t : [];
    if (this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys), this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules(), this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray(), this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_u = options.indicatorsAsCol) || void 0 === _u || _u, options.records, void 0, void 0, this.internalProps.columnTree, this.internalProps.rowTree, true), this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
      const supplyAxisNode = (nodes) => {
        nodes.forEach((node) => {
          var _a2;
          (null === (_a2 = node.children) || void 0 === _a2 ? void 0 : _a2.length) ? supplyAxisNode(node.children) : node.children = [{
            dimensionKey: "axis",
            value: ""
          }];
        });
      };
      (null === (_v = this.dataset.rowHeaderTree) || void 0 === _v ? void 0 : _v.length) ? supplyAxisNode(this.dataset.rowHeaderTree) : this.dataset.rowHeaderTree = [{
        dimensionKey: "axis",
        value: ""
      }];
    }
    if (options.columnTree || false !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), options.rowTree || false === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_w = this.dataset.colHeaderTree) && void 0 !== _w ? _w : [], this.layoutNodeId), rowDimensionTree = new DimensionTree(null !== (_x = this.dataset.rowHeaderTree) && void 0 !== _x ? _x : [], this.layoutNodeId), this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.createSceneGraph(), options.title) {
      const Title3 = Factory2.getComponent("title");
      this.internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
    }
    if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_y = this.internalProps.emptyTip) || void 0 === _y || _y.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_z = this.internalProps.emptyTip) || void 0 === _z || _z.resetVisible();
    }
    setTimeout(() => {
      this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
    }, 0);
  }
  static get EVENT_TYPE() {
    return PIVOT_CHART_EVENT_TYPE;
  }
  get pivotChartAxes() {
    return this._axes;
  }
  get recordsCount() {
    var _a;
    return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
  }
  isListTable() {
    return false;
  }
  isPivotTable() {
    return true;
  }
  isPivotChart() {
    return true;
  }
  _canResizeColumn(col, row) {
    const ifCan = super._canResizeColumn(col, row);
    if (ifCan && !this.internalProps.layoutMap.indicatorsAsCol) {
      const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
      if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return false;
    }
    return ifCan;
  }
  updateOption(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
    const internalProps = this.internalProps;
    let columnDimensionTree, rowDimensionTree;
    super.updateOption(options), this.layoutNodeId = {
      seqId: 0
    }, this.internalProps.columns = cloneDeep(options.columns), this.internalProps.rows = cloneDeep(options.rows), this.internalProps.indicators = (null === (_a = options.indicators) || void 0 === _a ? void 0 : _a.length) ? cloneDeepSpec(options.indicators) : [], this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_b = options.columns) || void 0 === _b ? void 0 : _b.length) || options.columnTree ? cloneDeep(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_c = options.rows) || void 0 === _c ? void 0 : _c.length) || options.rowTree ? cloneDeep(options.rowTree) : [], options.records && (this.internalProps.records = options.records), this.setCustomStateNameToSpec(), this._selectedDataItemsInChart = [], internalProps.columnResizeType = null !== (_f = null !== (_e = null === (_d = options.resize) || void 0 === _d ? void 0 : _d.columnResizeType) && void 0 !== _e ? _e : options.columnResizeType) && void 0 !== _f ? _f : "column", internalProps.rowResizeType = null !== (_j = null !== (_h = null === (_g = options.resize) || void 0 === _g ? void 0 : _g.rowResizeType) && void 0 !== _h ? _h : options.rowResizeType) && void 0 !== _j ? _j : "row", internalProps.dataConfig = {
      isPivotChart: true
    }, this._axes = isArray_default(options.axes) ? options.axes : [], options.columnTree && (false !== options.indicatorsAsCol && (this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_k = this.internalProps.columnTree) && void 0 !== _k ? _k : [], this.layoutNodeId)), options.rowTree && (false === options.indicatorsAsCol && (this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators)), rowDimensionTree = new DimensionTree(null !== (_l = this.internalProps.rowTree) && void 0 !== _l ? _l : [], this.layoutNodeId));
    const rowKeys = (null === (_m = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _m ? void 0 : _m.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_p = null === (_o = options.rows) || void 0 === _o ? void 0 : _o.reduce((keys2, rowObj) => ("string" == typeof rowObj ? keys2.push(rowObj) : keys2.push(rowObj.dimensionKey), keys2), [])) && void 0 !== _p ? _p : [], columnKeys = (null === (_q = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _q ? void 0 : _q.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_s = null === (_r = options.columns) || void 0 === _r ? void 0 : _r.reduce((keys2, columnObj) => ("string" == typeof columnObj ? keys2.push(columnObj) : keys2.push(columnObj.dimensionKey), keys2), [])) && void 0 !== _s ? _s : [], indicatorKeys = null !== (_u = null === (_t = options.indicators) || void 0 === _t ? void 0 : _t.reduce((keys2, indicatorObj) => ("string" == typeof indicatorObj ? keys2.push(indicatorObj) : keys2.push(indicatorObj.indicatorKey), keys2), [])) && void 0 !== _u ? _u : [];
    if (this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys), this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules(), this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray(), this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_v = options.indicatorsAsCol) || void 0 === _v || _v, null !== (_w = options.records) && void 0 !== _w ? _w : this.internalProps.records, void 0, void 0, this.internalProps.columnTree, this.internalProps.rowTree, true), this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
      const supplyAxisNode = (nodes) => {
        nodes.forEach((node) => {
          var _a2;
          (null === (_a2 = node.children) || void 0 === _a2 ? void 0 : _a2.length) ? supplyAxisNode(node.children) : node.children = [{
            dimensionKey: "axis",
            value: ""
          }];
        });
      };
      (null === (_x = this.dataset.rowHeaderTree) || void 0 === _x ? void 0 : _x.length) ? supplyAxisNode(this.dataset.rowHeaderTree) : this.dataset.rowHeaderTree = [{
        dimensionKey: "axis",
        value: ""
      }];
    }
    if (options.columnTree || false !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), options.rowTree || false === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_y = this.dataset.colHeaderTree) && void 0 !== _y ? _y : [], this.layoutNodeId), rowDimensionTree = new DimensionTree(null !== (_z = this.dataset.rowHeaderTree) && void 0 !== _z ? _z : [], this.layoutNodeId), internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj) => {
      var _a2;
      return null === (_a2 = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a2 ? void 0 : _a2.call(releaseObj);
    }), internalProps.releaseList = null), this.scenegraph.clearCells(), this.scenegraph.createSceneGraph(), options.title) {
      const Title3 = Factory2.getComponent("title");
      this.internalProps.title = new Title3(options.title, this), this.scenegraph.resize();
    }
    if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_0 = this.internalProps.emptyTip) || void 0 === _0 || _0.resetVisible();
    else {
      const EmptyTip3 = Factory2.getComponent("emptyTip");
      this.internalProps.emptyTip = new EmptyTip3(this.options.emptyTip, this), null === (_1 = this.internalProps.emptyTip) || void 0 === _1 || _1.resetVisible();
    }
    return new Promise((resolve) => {
      setTimeout(resolve, 0);
    });
  }
  updatePagination() {
  }
  refreshHeader() {
    this.setMinMaxLimitWidth(true), this.refreshRowColCount();
  }
  refreshRowColCount() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const table = this, { layoutMap } = table.internalProps;
    layoutMap && (table.colCount = null !== (_a = layoutMap.colCount) && void 0 !== _a ? _a : 0, table.rowCount = null !== (_b = layoutMap.rowCount) && void 0 !== _b ? _b : 0, table.internalProps.frozenColCount = null !== (_c = layoutMap.rowHeaderLevelCount) && void 0 !== _c ? _c : 0, table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_d = this.options.frozenRowCount) && void 0 !== _d ? _d : 0), table.bottomFrozenRowCount !== (null !== (_e = null == layoutMap ? void 0 : layoutMap.bottomFrozenRowCount) && void 0 !== _e ? _e : 0) && (table.bottomFrozenRowCount = null !== (_f = null == layoutMap ? void 0 : layoutMap.bottomFrozenRowCount) && void 0 !== _f ? _f : 0), table.rightFrozenColCount !== (null !== (_g = null == layoutMap ? void 0 : layoutMap.rightFrozenColCount) && void 0 !== _g ? _g : 0) && (table.rightFrozenColCount = null !== (_h = null == layoutMap ? void 0 : layoutMap.rightFrozenColCount) && void 0 !== _h ? _h : 0), this.stateManager.setFrozenCol(this.internalProps.frozenColCount));
  }
  _getSortFuncFromHeaderOption(columns, field, fieldKey) {
  }
  syncHierarchyState(sourceNode, targetNode) {
    var _a, _b;
    sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey && (targetNode.hierarchyState = null !== (_a = targetNode.hierarchyState) && void 0 !== _a ? _a : (null == targetNode ? void 0 : targetNode.children) ? sourceNode.hierarchyState : void 0, null === (_b = null == targetNode ? void 0 : targetNode.children) || void 0 === _b || _b.forEach((targetChildNode, index) => {
      var _a2;
      (null === (_a2 = null == sourceNode ? void 0 : sourceNode.children) || void 0 === _a2 ? void 0 : _a2[index]) && targetChildNode && this.syncHierarchyState(sourceNode.children[index], targetChildNode);
    }));
  }
  getRecordShowIndexByCell(col, row) {
  }
  getTableIndexByRecordIndex(recordIndex) {
  }
  getTableIndexByField(field) {
  }
  getCellAddrByFieldRecord(field, recordIndex) {
  }
  getBodyIndexByRow(row) {
    const { layoutMap } = this.internalProps;
    return layoutMap.getBodyIndexByRow(row);
  }
  getBodyIndexByCol(col) {
    const { layoutMap } = this.internalProps;
    return layoutMap.getBodyIndexByCol(col);
  }
  getCellValue(col, row, skipCustomMerge) {
    var _a, _b, _c;
    if (!skipCustomMerge) {
      const customMergeText = this.getCustomMergeValue(col, row);
      if (customMergeText) return customMergeText;
    }
    if (this.internalProps.layoutMap.isHeader(col, row)) {
      if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) || this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
        const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
        let indicatorInfo;
        return null == indicatorKeys || indicatorKeys.forEach((key) => {
          const info = this.internalProps.layoutMap.getIndicatorInfo(key);
          info && (indicatorInfo = info);
        }), null !== (_b = null !== (_a = null == indicatorInfo ? void 0 : indicatorInfo.title) && void 0 !== _a ? _a : null == indicatorInfo ? void 0 : indicatorInfo.indicatorKey) && void 0 !== _b ? _b : "";
      }
      const { title, fieldFormat: fieldFormat2 } = this.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof fieldFormat2 ? fieldFormat2(title, col, row, this) : title;
    }
    if (this.dataset) {
      let indicatorPosition;
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
        var _a2;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
        var _a2;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
      return aggregator2.value ? aggregator2.value() : void 0;
    }
    const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row), rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col), dataValue = null === (_c = this.records[rowIndex]) || void 0 === _c ? void 0 : _c[colIndex];
    if ("function" == typeof fieldFormat) {
      return fieldFormat(dataValue, col, row, this);
    }
    return dataValue;
  }
  getCellOriginValue(col, row) {
    var _a, _b, _c;
    const table = this;
    if (table.internalProps.layoutMap.isHeader(col, row)) {
      if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) || this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
        const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
        let indicatorInfo;
        return null == indicatorKeys || indicatorKeys.forEach((key) => {
          const info = this.internalProps.layoutMap.getIndicatorInfo(key);
          info && (indicatorInfo = info);
        }), null !== (_b = null !== (_a = null == indicatorInfo ? void 0 : indicatorInfo.title) && void 0 !== _a ? _a : null == indicatorInfo ? void 0 : indicatorInfo.indicatorKey) && void 0 !== _b ? _b : "";
      }
      const { title } = table.internalProps.layoutMap.getHeader(col, row);
      return "function" == typeof title ? title() : title;
    }
    if (this.dataset) {
      let indicatorPosition;
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
        var _a2;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
        var _a2;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
      }), aggregator2 = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
      return aggregator2.value ? aggregator2.value() : void 0;
    }
    const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
    return null === (_c = this.records[rowIndex]) || void 0 === _c ? void 0 : _c[colIndex];
  }
  getCellRawValue(col, row) {
    return this.getCellOriginValue(col, row);
  }
  getCellOriginRecord(col, row) {
    if (!this.internalProps.layoutMap.isHeader(col, row) && this.dataset) {
      let indicatorPosition;
      const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
        var _a;
        return colPath.indicatorKey && (indicatorPosition = {
          position: "col",
          index
        }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
      }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
        var _a;
        return rowPath.indicatorKey && (indicatorPosition = {
          position: "row",
          index
        }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
      });
      return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition).records;
    }
  }
  getCellRawRecord(col, row) {
    return this.getCellOriginRecord(col, row);
  }
  getPivotSortState(col, row) {
    if (!this.pivotSortState) return;
    const cellRange = this.getCellRange(col, row);
    for (let i = 0; i < this.pivotSortState.length; i++) {
      const { col: sortCol, row: sortRow, order } = this.pivotSortState[i];
      if (cellInRange(cellRange, sortCol, sortRow)) return order;
    }
  }
  _moveHeaderPosition(source, target) {
    var _a, _b, _c, _d;
    const moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
    if (moveContext) {
      if ("column" === moveContext.moveType) {
        if ((null === (_b = null === (_a = this.options.records) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.constructor) === Array) for (let row = 0; row < this.internalProps.records.length; row++) {
          const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
          sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
        }
        this.colWidthsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize), this.setMinMaxLimitWidth();
      } else if ("row" === moveContext.moveType) {
        if ((null === (_d = null === (_c = this.options.records) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.constructor) === Array) {
          const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
          sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records, sourceRows);
        }
        this.rowHeightsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize);
      }
      return moveContext;
    }
    return null;
  }
  toggleHierarchyState(col, row, recalculateColWidths = true) {
  }
  getHeaderCellAddressByPath(dimensionPaths) {
    return this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
  }
  getCellAddressByHeaderPaths(dimensionPaths) {
    return this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
  }
  getHeaderPathByXY(coordinate) {
    let cellAddr;
    cellAddr = coordinate ? this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1) : this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
    return this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
  }
  getHierarchyState(col, row) {
    var _a;
    return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
  }
  getMenuInfo(col, row, type) {
    const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
    return {
      dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
      value: this.getCellValue(col, row),
      cellLocation: this.getCellLocation(col, row),
      isPivotCorner: this.isCornerHeader(col, row),
      event: void 0
    };
  }
  _generateCollectValuesConfig(columnKeys, rowKeys) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    columnKeys = columnKeys.filter((key) => key !== IndicatorDimensionKeyPlaceholder), rowKeys = rowKeys.filter((key) => key !== IndicatorDimensionKeyPlaceholder);
    const indicators = this.internalProps.indicators, collectValuesBy = {};
    for (let i = 0, len = null == indicators ? void 0 : indicators.length; i < len; i++) if ("string" != typeof indicators[i] && indicators[i].chartSpec) {
      if ("pie" === (null === (_a = indicators[i].chartSpec) || void 0 === _a ? void 0 : _a.type) || "rose" === (null === (_b = indicators[i].chartSpec) || void 0 === _b ? void 0 : _b.type) || "radar" === (null === (_c = indicators[i].chartSpec) || void 0 === _c ? void 0 : _c.type) || "gauge" === (null === (_d = indicators[i].chartSpec) || void 0 === _d ? void 0 : _d.type) || "wordCloud" === (null === (_e = indicators[i].chartSpec) || void 0 === _e ? void 0 : _e.type)) continue;
      const indicatorDefine = indicators[i], indicatorSpec = indicatorDefine.chartSpec;
      if (false === this.options.indicatorsAsCol) if (false !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = true), collectValuesBy[indicatorDefine.indicatorKey] = {
        by: rowKeys,
        range: true,
        sumBy: (null == indicatorSpec ? void 0 : indicatorSpec.stack) && columnKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.xField)
      }, indicatorSpec.series) indicatorSpec.series.forEach((chartSeries) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2;
        const xField = "string" == typeof chartSeries.xField ? chartSeries.xField : chartSeries.xField[0];
        collectValuesBy[xField] = {
          by: columnKeys,
          type: "horizontal" !== chartSeries.direction ? "xField" : void 0,
          range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, true),
          sortBy: "horizontal" !== chartSeries.direction ? null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a2 ? void 0 : _a2.fields) || void 0 === _b2 ? void 0 : _b2[xField]) || void 0 === _c2 ? void 0 : _c2.domain) && void 0 !== _d2 ? _d2 : null === (_g2 = null === (_f2 = null === (_e2 = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _e2 ? void 0 : _e2.fields) || void 0 === _f2 ? void 0 : _f2[xField]) || void 0 === _g2 ? void 0 : _g2.domain : void 0
        };
        const yField = chartSeries.yField;
        false !== chartSeries.stack && ("bar" === chartSeries.type || "area" === chartSeries.type) && (chartSeries.stack = true), collectValuesBy[yField] = {
          by: rowKeys,
          range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, false),
          sumBy: chartSeries.stack && columnKeys.concat(null == chartSeries ? void 0 : chartSeries.xField),
          sortBy: "horizontal" === chartSeries.direction ? null !== (_l2 = null === (_k2 = null === (_j2 = null === (_h2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _h2 ? void 0 : _h2.fields) || void 0 === _j2 ? void 0 : _j2[yField]) || void 0 === _k2 ? void 0 : _k2.domain) && void 0 !== _l2 ? _l2 : null === (_p2 = null === (_o2 = null === (_m2 = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m2 ? void 0 : _m2.fields) || void 0 === _o2 ? void 0 : _o2[yField]) || void 0 === _p2 ? void 0 : _p2.domain : void 0,
          extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
        };
      });
      else {
        const xField = "string" == typeof indicatorSpec.xField ? indicatorSpec.xField : indicatorSpec.xField[0];
        collectValuesBy[xField] = {
          by: columnKeys,
          type: "horizontal" !== indicatorSpec.direction ? "xField" : void 0,
          range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, true),
          sortBy: "horizontal" !== indicatorSpec.direction ? null === (_h = null === (_g = null === (_f = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _f ? void 0 : _f.fields) || void 0 === _g ? void 0 : _g[xField]) || void 0 === _h ? void 0 : _h.domain : void 0
        }, false !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = true);
        const yField = indicatorSpec.yField;
        collectValuesBy[yField] = {
          by: rowKeys,
          range: "horizontal" !== indicatorSpec.direction,
          sumBy: indicatorSpec.stack && columnKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.xField),
          sortBy: "horizontal" === indicatorSpec.direction ? null === (_l = null === (_k = null === (_j = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _j ? void 0 : _j.fields) || void 0 === _k ? void 0 : _k[yField]) || void 0 === _l ? void 0 : _l.domain : void 0,
          extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
        };
      }
      else {
        const indicatorDefine2 = indicators[i];
        if (false !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = true), collectValuesBy[indicatorDefine2.indicatorKey] = {
          by: columnKeys,
          range: true,
          sumBy: (null == indicatorSpec ? void 0 : indicatorSpec.stack) && rowKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.yField)
        }, indicatorSpec.series) indicatorSpec.series.forEach((chartSeries) => {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2;
          const yField = "string" == typeof chartSeries.yField ? chartSeries.yField : chartSeries.yField[0];
          collectValuesBy[yField] = {
            by: rowKeys,
            type: "horizontal" === chartSeries.direction ? "yField" : void 0,
            range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, false),
            sortBy: "horizontal" === chartSeries.direction ? null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a2 ? void 0 : _a2.fields) || void 0 === _b2 ? void 0 : _b2[yField]) || void 0 === _c2 ? void 0 : _c2.domain) && void 0 !== _d2 ? _d2 : null === (_g2 = null === (_f2 = null === (_e2 = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _e2 ? void 0 : _e2.fields) || void 0 === _f2 ? void 0 : _f2[yField]) || void 0 === _g2 ? void 0 : _g2.domain : void 0
          };
          const xField = chartSeries.xField;
          false !== chartSeries.stack && ("bar" === chartSeries.type || "area" === chartSeries.type) && (chartSeries.stack = true), collectValuesBy[xField] = {
            by: columnKeys,
            range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, true),
            sumBy: chartSeries.stack && rowKeys.concat(null == chartSeries ? void 0 : chartSeries.yField),
            sortBy: "horizontal" !== chartSeries.direction ? null !== (_l2 = null === (_k2 = null === (_j2 = null === (_h2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _h2 ? void 0 : _h2.fields) || void 0 === _j2 ? void 0 : _j2[xField]) || void 0 === _k2 ? void 0 : _k2.domain) && void 0 !== _l2 ? _l2 : null === (_p2 = null === (_o2 = null === (_m2 = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m2 ? void 0 : _m2.fields) || void 0 === _o2 ? void 0 : _o2[xField]) || void 0 === _p2 ? void 0 : _p2.domain : void 0,
            extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
          };
        });
        else {
          const yField = "string" == typeof indicatorSpec.yField ? indicatorSpec.yField : indicatorSpec.yField[0];
          collectValuesBy[yField] = {
            by: rowKeys,
            type: "horizontal" === indicatorSpec.direction ? "yField" : void 0,
            range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, false),
            sortBy: "horizontal" === indicatorSpec.direction ? null === (_p = null === (_o = null === (_m = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m ? void 0 : _m.fields) || void 0 === _o ? void 0 : _o[yField]) || void 0 === _p ? void 0 : _p.domain : void 0
          }, false !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = true);
          const xField = indicatorSpec.xField;
          collectValuesBy[xField] = {
            by: columnKeys,
            range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, true),
            sumBy: indicatorSpec.stack && rowKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.yField),
            sortBy: "horizontal" !== indicatorSpec.direction ? null === (_s = null === (_r = null === (_q = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _q ? void 0 : _q.fields) || void 0 === _r ? void 0 : _r[xField]) || void 0 === _s ? void 0 : _s.domain : void 0,
            extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
          };
        }
      }
    }
    return collectValuesBy;
  }
  _generateAggregationRules() {
    var _a;
    const aggregationRules = [];
    return null === (_a = this.internalProps.indicators) || void 0 === _a || _a.forEach((indicator) => {
      var _a2, _b;
      if ("string" == typeof indicator) aggregationRules.push({
        indicatorKey: indicator,
        field: indicator,
        aggregationType: AggregationType.RECORD
      });
      else if (null === (_a2 = indicator.chartSpec) || void 0 === _a2 ? void 0 : _a2.series) {
        const fields2 = [];
        null === (_b = indicator.chartSpec) || void 0 === _b || _b.series.forEach((seriesSpec) => {
          const seriesField = false === this.options.indicatorsAsCol ? seriesSpec.yField : seriesSpec.xField;
          -1 === fields2.indexOf(seriesField) && fields2.push(seriesField);
        }), aggregationRules.push({
          indicatorKey: indicator.indicatorKey,
          field: fields2,
          aggregationType: AggregationType.RECORD
        });
      } else {
        const field = false === this.options.indicatorsAsCol ? indicator.chartSpec.yField : indicator.chartSpec.xField;
        aggregationRules.push({
          indicatorKey: indicator.indicatorKey,
          field: null != field ? field : indicator.indicatorKey,
          aggregationType: AggregationType.RECORD
        });
      }
    }), aggregationRules;
  }
  setCustomStateNameToSpec() {
    var _a;
    const setCustomStateName = (spec) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      (null === (_b = null === (_a2 = spec.bar) || void 0 === _a2 ? void 0 : _a2.state) || void 0 === _b ? void 0 : _b.selected) && (spec.bar.state.vtable_selected = spec.bar.state.selected, spec.bar.state.vtable_selected_reverse = spec.bar.state.selected_reverse, delete spec.bar.state.selected, delete spec.bar.state.selected_reverse), (null === (_d = null === (_c = spec.point) || void 0 === _c ? void 0 : _c.state) || void 0 === _d ? void 0 : _d.selected) && (spec.point.state.vtable_selected = spec.point.state.selected, spec.point.state.vtable_selected_reverse = spec.point.state.selected_reverse, delete spec.point.state.selected, delete spec.point.state.selected_reverse), (null === (_f = null === (_e = spec.line) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f.selected) && (spec.line.state.vtable_selected = spec.line.state.selected, spec.line.state.vtable_selected_reverse = spec.line.state.selected_reverse, delete spec.line.state.selected, delete spec.line.state.selected_reverse), (null === (_h = null === (_g = spec.area) || void 0 === _g ? void 0 : _g.state) || void 0 === _h ? void 0 : _h.selected) && (spec.area.state.vtable_selected = spec.area.state.selected, spec.area.state.vtable_selected_reverse = spec.area.state.selected_reverse, delete spec.area.state.selected, delete spec.area.state.selected_reverse), (null === (_k = null === (_j = spec.pie) || void 0 === _j ? void 0 : _j.state) || void 0 === _k ? void 0 : _k.selected) && (spec.pie.state.vtable_selected = spec.pie.state.selected, spec.pie.state.vtable_selected_reverse = spec.pie.state.selected_reverse, delete spec.pie.state.selected, delete spec.pie.state.selected_reverse);
    };
    null === (_a = this.internalProps.indicators) || void 0 === _a || _a.forEach((indicator) => {
      if (indicator.chartSpec) {
        const spec = indicator.chartSpec;
        spec.series ? spec.series.forEach((series) => {
          setCustomStateName(series);
        }) : setCustomStateName(spec);
      }
    });
  }
  updateFilterRules(filterRules) {
    this.internalProps.dataConfig.filterRules = filterRules, this.dataset.updateFilterRules(filterRules), clearChartCacheImage(this.scenegraph), updateChartData(this.scenegraph), this.render();
  }
  clearChartCacheImage(col, row) {
    isNumber_default(col) && isNumber_default(row) ? clearCellChartCacheImage(col, row, this.scenegraph) : clearChartCacheImage(this.scenegraph);
  }
  getLegendSelected() {
    var _a;
    const selected = [];
    return null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend) => {
      const data = legend.legendComponent._getSelectedLegends().map((d) => d.label);
      selected.push(...data);
    }), selected;
  }
  setLegendSelected(selectedData) {
    var _a;
    null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend) => {
      legend.legendComponent.setSelected(selectedData);
    });
  }
  getChartDatumPosition(datum, cellHeaderPaths) {
    const { chartInstance, bounds } = this.getChartInstance(cellHeaderPaths);
    if (chartInstance) {
      const position = chartInstance.convertDatumToPosition(datum);
      return position ? {
        x: Math.round(position.x + bounds.x1),
        y: Math.round(position.y + bounds.y1)
      } : null;
    }
    return null;
  }
  getCellAddressByRecord(record) {
    const rowHeaderPaths = [], colHeaderPaths = [], recordKeyMapToIndicatorKeys = {}, indicatorRecordKeys = [];
    this.dataset.dataConfig.aggregationRules.forEach((aggregationRule) => {
      if ("string" == typeof aggregationRule.field) recordKeyMapToIndicatorKeys[aggregationRule.field] = aggregationRule.indicatorKey, indicatorRecordKeys.push(aggregationRule.field);
      else for (let i = 0; i < aggregationRule.field.length; i++) recordKeyMapToIndicatorKeys[aggregationRule.field[i]] = aggregationRule.indicatorKey, indicatorRecordKeys.push(aggregationRule.field[i]);
    });
    for (const key in record) this.dataset.rows.indexOf(key) >= 0 && rowHeaderPaths.push({
      dimensionKey: key,
      value: record[key]
    }), this.dataset.columns.indexOf(key) >= 0 && colHeaderPaths.push({
      dimensionKey: key,
      value: record[key]
    }), indicatorRecordKeys.indexOf(key) >= 0 && (this.dataset.indicatorsAsCol ? colHeaderPaths.push({
      indicatorKey: recordKeyMapToIndicatorKeys[key]
    }) : rowHeaderPaths.push({
      indicatorKey: recordKeyMapToIndicatorKeys[key]
    }));
    return this.getCellAddressByHeaderPaths({
      rowHeaderPaths,
      colHeaderPaths,
      cellLocation: "body"
    });
  }
  getChartInstance(cellHeaderPaths) {
    var _a, _b, _c, _d, _e;
    const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
    if (cellAddr) {
      const cellPosition = this.getCellRelativeRect(cellAddr.col, cellAddr.row), cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row);
      let chartInstance;
      const chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0];
      if (chartNode.attribute.chartInstance) {
        chartInstance = chartNode.attribute.chartInstance;
        const { dataId, data, axes, spec } = chartNode.attribute, viewBox = chartNode.getViewBox();
        null == axes || axes.forEach((axis, index) => {
          var _a2, _b2, _c2, _d2, _e2;
          "linear" === axis.type ? chartInstance.updateModelSpecSync({
            type: "axes",
            index
          }, {
            min: null !== (_b2 = null === (_a2 = axis.range) || void 0 === _a2 ? void 0 : _a2.min) && void 0 !== _b2 ? _b2 : 0,
            max: null !== (_d2 = null === (_c2 = axis.range) || void 0 === _c2 ? void 0 : _c2.max) && void 0 !== _d2 ? _d2 : 0,
            tick: {
              tickMode: null === (_e2 = axis.tick) || void 0 === _e2 ? void 0 : _e2.tickMode
            }
          }, true) : "band" === axis.type && chartInstance.updateModelSpec({
            type: "axes",
            index
          }, {
            domain: axis.domain.slice(0)
          }, true);
        }), chartInstance.updateViewBox({
          x1: 0,
          x2: viewBox.x2 - viewBox.x1,
          y1: 0,
          y2: viewBox.y2 - viewBox.y1
        }, false, false);
        const chartStage = chartInstance.getStage(), matrix = chartNode.globalTransMatrix.clone(), stageMatrix = chartNode.stage.window.getViewBoxTransform();
        if (matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), chartStage.window.setViewBoxTransform && chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), "string" == typeof dataId) chartInstance.updateDataSync(dataId, null != data ? data : []);
        else {
          const dataBatch = [];
          for (const dataIdStr in dataId) {
            const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item) => {
              var _a2;
              return (null === (_a2 = null == item ? void 0 : item.data) || void 0 === _a2 ? void 0 : _a2.id) === dataIdStr;
            });
            dataBatch.push({
              id: dataIdStr,
              values: dataIdAndField ? null !== (_b = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _b ? _b : [] : null != data ? data : [],
              fields: null === (_c = null == series ? void 0 : series.data) || void 0 === _c ? void 0 : _c.fields
            }), chartInstance.updateFullDataSync || chartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_d = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _d ? _d : [] : null != data ? data : []);
          }
          null === (_e = chartInstance.updateFullDataSync) || void 0 === _e || _e.call(chartInstance, dataBatch);
        }
        this.render();
      }
      return {
        chartInstance,
        bounds: cellPosition.bounds
      };
    }
    return {};
  }
  activateChartInstance(cellHeaderPaths) {
    var _a, _b, _c, _d, _e;
    const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
    if (cellAddr) {
      const col = cellAddr.col, row = cellAddr.row, cellGroup = this.scenegraph.getCell(col, row), chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0], activeChartInstance = this.scenegraph.activateChart(col, row), { dataId, data, axes, spec } = chartNode.attribute, viewBox = chartNode.getViewBox();
      null == axes || axes.forEach((axis, index) => {
        var _a2, _b2, _c2, _d2, _e2;
        "linear" === axis.type ? activeChartInstance.updateModelSpecSync({
          type: "axes",
          index
        }, {
          min: null !== (_b2 = null === (_a2 = axis.range) || void 0 === _a2 ? void 0 : _a2.min) && void 0 !== _b2 ? _b2 : 0,
          max: null !== (_d2 = null === (_c2 = axis.range) || void 0 === _c2 ? void 0 : _c2.max) && void 0 !== _d2 ? _d2 : 0,
          tick: {
            tickMode: null === (_e2 = axis.tick) || void 0 === _e2 ? void 0 : _e2.tickMode
          }
        }, true) : "band" === axis.type && activeChartInstance.updateModelSpec({
          type: "axes",
          index
        }, {
          domain: axis.domain.slice(0)
        }, true);
      }), activeChartInstance.updateViewBox({
        x1: 0,
        x2: viewBox.x2 - viewBox.x1,
        y1: 0,
        y2: viewBox.y2 - viewBox.y1
      }, false, false);
      const chartStage = activeChartInstance.getStage();
      chartStage.needRender = true;
      const matrix = chartNode.globalTransMatrix.clone(), stageMatrix = chartNode.stage.window.getViewBoxTransform().clone();
      if (stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), "string" == typeof dataId) activeChartInstance.updateDataSync(dataId, null != data ? data : []);
      else {
        const dataBatch = [];
        for (const dataIdStr in dataId) {
          const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item) => {
            var _a2;
            return (null === (_a2 = null == item ? void 0 : item.data) || void 0 === _a2 ? void 0 : _a2.id) === dataIdStr;
          });
          dataBatch.push({
            id: dataIdStr,
            values: dataIdAndField ? null !== (_b = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _b ? _b : [] : null != data ? data : [],
            fields: null === (_c = null == series ? void 0 : series.data) || void 0 === _c ? void 0 : _c.fields
          }), activeChartInstance.updateFullDataSync || activeChartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_d = null == data ? void 0 : data.filter((item) => item.hasOwnProperty(dataIdAndField))) && void 0 !== _d ? _d : [] : null != data ? data : []);
        }
        null === (_e = activeChartInstance.updateFullDataSync) || void 0 === _e || _e.call(activeChartInstance, dataBatch);
      }
      return activeChartInstance;
    }
  }
  replaceChartCacheImage(cellHeaderPaths, chartInstance) {
    var _a;
    const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
    if (cellAddr) {
      const cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row), chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0];
      cacheStageCanvas(chartInstance.getStage(), chartNode);
    }
  }
  _getDimensionSortArray() {
    var _a, _b;
    if (null === (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.axes) || void 0 === _b ? void 0 : _b.length) {
      const dimensionAxisOrient = this.options.indicatorsAsCol ? "left" : "bottom", dimensionAxisOption = this.options.axes.find((axis) => axis.orient === dimensionAxisOrient);
      if (dimensionAxisOption && isArray_default(dimensionAxisOption.domain)) return dimensionAxisOption.domain;
    }
  }
  setRecords(records) {
    var _a, _b;
    this.internalProps.layoutMap.release(), clearChartRenderQueue();
    const oldHoverState = {
      col: this.stateManager.hover.cellPos.col,
      row: this.stateManager.hover.cellPos.row
    };
    this.options.records = this.internalProps.records = records;
    const options = this.options, internalProps = this.internalProps;
    let columnDimensionTree, rowDimensionTree;
    this.dataset.setRecords(records), columnDimensionTree = options.columnTree ? internalProps.layoutMap.columnDimensionTree : new DimensionTree(null !== (_a = this.dataset.colHeaderTree) && void 0 !== _a ? _a : [], this.layoutNodeId), rowDimensionTree = options.rowTree ? internalProps.layoutMap.rowDimensionTree : new DimensionTree(null !== (_b = this.dataset.rowHeaderTree) && void 0 !== _b ? _b : [], this.layoutNodeId), internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = false, this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), this.internalProps.title.resize(), this.scenegraph.resize()), this.eventManager.updateEventBinder();
  }
  _hasCustomRenderOrLayout() {
    if (this.options.customRender) return true;
    const { columnsDefine, rowsDefine, indicatorsDefine } = this.internalProps.layoutMap;
    for (let i = 0; i < columnsDefine.length; i++) {
      const columnDefine = columnsDefine[i];
      if ("string" != typeof columnDefine && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) return true;
    }
    for (let i = 0; i < rowsDefine.length; i++) {
      const rowDefine = rowsDefine[i];
      if ("string" != typeof rowDefine && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) return true;
    }
    for (let i = 0; i < indicatorsDefine.length; i++) {
      const indicatorDefine = indicatorsDefine[i];
      if ("string" != typeof indicatorDefine && (indicatorDefine.customLayout || indicatorDefine.headerCustomLayout || indicatorDefine.customRender || indicatorDefine.headerCustomRender)) return true;
    }
    return false;
  }
  changeRecordOrder(source, target) {
  }
  getLayoutColumnTree() {
    return this.internalProps.layoutMap.getLayoutColumnTree();
  }
  getLayoutColumnTreeCount() {
    return this.internalProps.layoutMap.getLayoutColumnTreeCount();
  }
  getLayoutRowTree() {
    return this.internalProps.layoutMap.getLayoutRowTree();
  }
  getLayoutRowTreeCount() {
    return this.internalProps.layoutMap.getLayoutRowTreeCount();
  }
  getCellHeaderTreeNodes(col, row) {
    return this.internalProps.layoutMap.getCellHeaderPathsWithTreeNode(col, row);
  }
};

// node_modules/@visactor/vtable/es/render/layout/index.js
var layout_exports = {};
__export(layout_exports, {
  Arc: () => Arc2,
  CheckBox: () => CheckBox,
  Circle: () => Circle2,
  Container: () => Container3,
  Group: () => Group3,
  GroupElement: () => GroupElement,
  Icon: () => Icon2,
  Image: () => Image3,
  Line: () => Line,
  Radio: () => Radio,
  Rect: () => Rect3,
  Tag: () => Tag2,
  Text: () => Text2,
  percentCalc: () => percentCalc
});

// node_modules/@visactor/vtable/es/render/layout/circle.js
var Circle2 = class extends Circle {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
};

// node_modules/@visactor/vtable/es/render/layout/container.js
var Container3 = class extends Group {
  constructor(containerOptions) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    containerOptions.direction && (containerOptions.flexDirection = containerOptions.direction), !containerOptions.justifyContent || "start" !== containerOptions.justifyContent && "end" !== containerOptions.justifyContent || (containerOptions.justifyContent = "flex-" + containerOptions.justifyContent), !containerOptions.alignItems || "start" !== containerOptions.alignItems && "end" !== containerOptions.alignItems || (containerOptions.alignItems = "flex-" + containerOptions.alignItems), !containerOptions.alignContent || "start" !== containerOptions.alignContent && "end" !== containerOptions.alignContent || (containerOptions.alignContent = "flex-" + containerOptions.alignContent), containerOptions.display = "flex", containerOptions.flexDirection || (containerOptions.flexDirection = "row"), containerOptions.clip = true, containerOptions.fill = null === (_a = null == containerOptions ? void 0 : containerOptions.background) || void 0 === _a ? void 0 : _a.fill, containerOptions.stroke = null === (_b = null == containerOptions ? void 0 : containerOptions.background) || void 0 === _b ? void 0 : _b.stroke, containerOptions.lineWidth = null === (_c = null == containerOptions ? void 0 : containerOptions.background) || void 0 === _c ? void 0 : _c.lineWidth, containerOptions.cornerRadius = null === (_d = null == containerOptions ? void 0 : containerOptions.background) || void 0 === _d ? void 0 : _d.cornerRadius;
    const isPaddingNumber = isArray_default(containerOptions.boundsPadding), padding = [null !== (_f = null !== (_e = containerOptions.marginTop) && void 0 !== _e ? _e : isPaddingNumber ? containerOptions.boundsPadding[0] : containerOptions.boundsPadding) && void 0 !== _f ? _f : 0, null !== (_h = null !== (_g = containerOptions.marginRight) && void 0 !== _g ? _g : isPaddingNumber ? containerOptions.boundsPadding[1] : containerOptions.boundsPadding) && void 0 !== _h ? _h : 0, null !== (_l = null !== (_j = containerOptions.marginBottom) && void 0 !== _j ? _j : isPaddingNumber ? null !== (_k = containerOptions.boundsPadding[2]) && void 0 !== _k ? _k : containerOptions.boundsPadding[0] : containerOptions.boundsPadding) && void 0 !== _l ? _l : 0, null !== (_p = null !== (_m = containerOptions.marginLeft) && void 0 !== _m ? _m : isPaddingNumber ? null !== (_o = containerOptions.boundsPadding[3]) && void 0 !== _o ? _o : containerOptions.boundsPadding[1] : containerOptions.boundsPadding) && void 0 !== _p ? _p : 0];
    containerOptions.boundsPadding = padding, super(containerOptions);
  }
};

// node_modules/@visactor/vtable/es/render/layout/group-element.js
var GroupElement = class extends Container3 {
  constructor(option) {
    option.flexWrap = "nowrap", super(option);
  }
};

// node_modules/@visactor/vtable/es/render/layout/icon.js
var Icon2 = class extends Image2 {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let cache;
    if (isString_default(options.iconName)) {
      cache = get3()[options.iconName], cache && (options.width = null !== (_a = options.width) && void 0 !== _a ? _a : cache.width, options.height = null !== (_b = options.height) && void 0 !== _b ? _b : cache.height, options.svg = cache.svg, options.cursor = cache.cursor);
    }
    options.svg && (options.image = options.svg);
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_d = null !== (_c = options.marginTop) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_f = null !== (_e = options.marginRight) && void 0 !== _e ? _e : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _f ? _f : 0, null !== (_j = null !== (_g = options.marginBottom) && void 0 !== _g ? _g : isPaddingNumber ? null !== (_h = options.boundsPadding[2]) && void 0 !== _h ? _h : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _j ? _j : 0, null !== (_m = null !== (_k = options.marginLeft) && void 0 !== _k ? _k : isPaddingNumber ? null !== (_l = options.boundsPadding[3]) && void 0 !== _l ? _l : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _m ? _m : 0];
    options.boundsPadding = padding, super(options), this.cache = cache;
  }
};

// node_modules/@visactor/vtable/es/render/layout/image.js
var Image3 = class extends Image2 {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    options.src && (options.image = options.src), "circle" === options.shape && (options.cornerRadius = options.width / 2);
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
};

// node_modules/@visactor/vtable/es/render/layout/rect.js
var Rect3 = class extends Rect {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
};

// node_modules/@visactor/vtable/es/render/layout/text.js
var Text2 = class extends Text {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    options.textBaseline || (options.textBaseline = "top");
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, options.fill = null !== (_l = options.fill) && void 0 !== _l ? _l : "#000", super(options);
  }
  getSize(table) {
    this.AABBBounds.width();
  }
};

// node_modules/@visactor/vtable/es/render/layout/percent-calc.js
function percentCalc(percent, delta = 0) {
  return {
    percent,
    delta
  };
}

// node_modules/@visactor/vtable/es/render/layout/arc.js
var Arc2 = class extends Arc {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
};

// node_modules/@visactor/vtable/es/render/layout/tag.js
var Tag2 = class extends Tag {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
  getSize(table) {
    this.AABBBounds.width();
  }
};

// node_modules/@visactor/vtable/es/render/layout/group.js
var Group3 = class extends Group {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isPaddingNumber = isArray_default(options.boundsPadding), padding = [null !== (_b = null !== (_a = options.marginTop) && void 0 !== _a ? _a : isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) && void 0 !== _b ? _b : 0, null !== (_d = null !== (_c = options.marginRight) && void 0 !== _c ? _c : isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) && void 0 !== _d ? _d : 0, null !== (_g = null !== (_e = options.marginBottom) && void 0 !== _e ? _e : isPaddingNumber ? null !== (_f = options.boundsPadding[2]) && void 0 !== _f ? _f : options.boundsPadding[0] : options.boundsPadding) && void 0 !== _g ? _g : 0, null !== (_k = null !== (_h = options.marginLeft) && void 0 !== _h ? _h : isPaddingNumber ? null !== (_j = options.boundsPadding[3]) && void 0 !== _j ? _j : options.boundsPadding[1] : options.boundsPadding) && void 0 !== _k ? _k : 0];
    options.boundsPadding = padding, super(options);
  }
};

// node_modules/@visactor/vtable/es/tools/get-data-path/create-dataset.js
function createDataset(options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const layoutNodeId = {
    seqId: 0
  }, dataConfig = {
    isPivotChart: true
  };
  let columnDimensionTree, rowDimensionTree, columnTree, rowTree;
  options.columnTree && (false !== options.indicatorsAsCol && (columnTree = supplementIndicatorNodesForCustomTree(options.columnTree, options.indicators)), columnDimensionTree = new DimensionTree(null !== (_a = options.columnTree) && void 0 !== _a ? _a : [], layoutNodeId)), options.rowTree && (false === options.indicatorsAsCol && (rowTree = supplementIndicatorNodesForCustomTree(options.rowTree, options.indicators)), rowDimensionTree = new DimensionTree(null !== (_b = options.rowTree) && void 0 !== _b ? _b : [], layoutNodeId));
  const rowKeys = (null === (_c = rowDimensionTree.dimensionKeys) || void 0 === _c ? void 0 : _c.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_e = null === (_d = options.rows) || void 0 === _d ? void 0 : _d.reduce((keys2, rowObj) => ("string" == typeof rowObj ? keys2.push(rowObj) : keys2.push(rowObj.dimensionKey), keys2), [])) && void 0 !== _e ? _e : [], columnKeys = (null === (_f = columnDimensionTree.dimensionKeys) || void 0 === _f ? void 0 : _f.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_h = null === (_g = options.columns) || void 0 === _g ? void 0 : _g.reduce((keys2, columnObj) => ("string" == typeof columnObj ? keys2.push(columnObj) : keys2.push(columnObj.dimensionKey), keys2), [])) && void 0 !== _h ? _h : [], indicatorKeys = null !== (_k = null === (_j = options.indicators) || void 0 === _j ? void 0 : _j.reduce((keys2, indicatorObj) => ("string" == typeof indicatorObj ? keys2.push(indicatorObj) : keys2.push(indicatorObj.indicatorKey), keys2), [])) && void 0 !== _k ? _k : [];
  dataConfig.collectValuesBy = _generateCollectValuesConfig(options, columnKeys, rowKeys), dataConfig.aggregationRules = _generateAggregationRules(options);
  return {
    dataset: new Dataset(dataConfig, rowKeys, columnKeys, indicatorKeys, options.indicators, null === (_l = options.indicatorsAsCol) || void 0 === _l || _l, options.records, void 0, void 0, columnTree || options.columnTree, rowTree || options.rowTree, true),
    columnDimensionTree,
    rowDimensionTree,
    layoutNodeId
  };
}
function _generateCollectValuesConfig(option, columnKeys, rowKeys) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
  const collectValuesBy = {};
  for (let i = 0, len = null === (_a = option.indicators) || void 0 === _a ? void 0 : _a.length; i < len; i++) if ("string" != typeof option.indicators[i] && option.indicators[i].chartSpec) if (false === option.indicatorsAsCol) {
    const indicatorDefine = option.indicators[i];
    if (collectValuesBy[indicatorDefine.indicatorKey] = {
      by: rowKeys,
      range: true,
      sumBy: false !== (null === (_b = indicatorDefine.chartSpec) || void 0 === _b ? void 0 : _b.stack) && columnKeys.concat(null === (_c = indicatorDefine.chartSpec) || void 0 === _c ? void 0 : _c.xField)
    }, indicatorDefine.chartSpec.series) indicatorDefine.chartSpec.series.forEach((chartSeries) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
      const xField = "string" == typeof chartSeries.xField ? chartSeries.xField : chartSeries.xField[0];
      collectValuesBy[xField] = {
        by: columnKeys,
        type: "horizontal" !== chartSeries.direction ? "xField" : void 0,
        range: "horizontal" === chartSeries.direction,
        sortBy: "horizontal" !== chartSeries.direction ? null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a2 ? void 0 : _a2.fields) || void 0 === _b2 ? void 0 : _b2[xField]) || void 0 === _c2 ? void 0 : _c2.domain) && void 0 !== _d2 ? _d2 : null === (_h2 = null === (_g2 = null === (_f2 = null === (_e2 = indicatorDefine.chartSpec) || void 0 === _e2 ? void 0 : _e2.data) || void 0 === _f2 ? void 0 : _f2.fields) || void 0 === _g2 ? void 0 : _g2[xField]) || void 0 === _h2 ? void 0 : _h2.domain : void 0
      };
      const yField = chartSeries.yField;
      collectValuesBy[yField] = {
        by: rowKeys,
        range: "horizontal" !== chartSeries.direction,
        sumBy: false !== chartSeries.stack && columnKeys.concat(null == chartSeries ? void 0 : chartSeries.xField),
        sortBy: "horizontal" === chartSeries.direction ? null !== (_m2 = null === (_l2 = null === (_k2 = null === (_j2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _j2 ? void 0 : _j2.fields) || void 0 === _k2 ? void 0 : _k2[yField]) || void 0 === _l2 ? void 0 : _l2.domain) && void 0 !== _m2 ? _m2 : null === (_r2 = null === (_q2 = null === (_p2 = null === (_o2 = indicatorDefine.chartSpec) || void 0 === _o2 ? void 0 : _o2.data) || void 0 === _p2 ? void 0 : _p2.fields) || void 0 === _q2 ? void 0 : _q2[yField]) || void 0 === _r2 ? void 0 : _r2.domain : void 0
      };
    });
    else {
      const xField = "string" == typeof indicatorDefine.chartSpec.xField ? indicatorDefine.chartSpec.xField : indicatorDefine.chartSpec.xField[0];
      collectValuesBy[xField] = {
        by: columnKeys,
        type: "horizontal" !== indicatorDefine.chartSpec.direction ? "xField" : void 0,
        range: "horizontal" === indicatorDefine.chartSpec.direction,
        sortBy: "horizontal" !== indicatorDefine.chartSpec.direction ? null === (_g = null === (_f = null === (_e = null === (_d = indicatorDefine.chartSpec) || void 0 === _d ? void 0 : _d.data) || void 0 === _e ? void 0 : _e.fields) || void 0 === _f ? void 0 : _f[xField]) || void 0 === _g ? void 0 : _g.domain : void 0
      };
      const yField = indicatorDefine.chartSpec.yField;
      collectValuesBy[yField] = {
        by: rowKeys,
        range: "horizontal" !== option.indicators[i].chartSpec.direction,
        sumBy: false !== indicatorDefine.chartSpec.stack && columnKeys.concat(null === (_h = indicatorDefine.chartSpec) || void 0 === _h ? void 0 : _h.xField),
        sortBy: "horizontal" === indicatorDefine.chartSpec.direction ? null === (_m = null === (_l = null === (_k = null === (_j = indicatorDefine.chartSpec) || void 0 === _j ? void 0 : _j.data) || void 0 === _k ? void 0 : _k.fields) || void 0 === _l ? void 0 : _l[yField]) || void 0 === _m ? void 0 : _m.domain : void 0
      };
    }
  } else {
    const indicatorDefine = option.indicators[i];
    if (collectValuesBy[indicatorDefine.indicatorKey] = {
      by: columnKeys,
      range: true,
      sumBy: false !== (null === (_o = indicatorDefine.chartSpec) || void 0 === _o ? void 0 : _o.stack) && rowKeys.concat(null === (_p = indicatorDefine.chartSpec) || void 0 === _p ? void 0 : _p.yField)
    }, indicatorDefine.chartSpec.series) indicatorDefine.chartSpec.series.forEach((chartSeries) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k2, _l2, _m2, _o2, _p2, _q2, _r2;
      const yField = "string" == typeof chartSeries.yField ? chartSeries.yField : chartSeries.yField[0];
      collectValuesBy[yField] = {
        by: rowKeys,
        type: "horizontal" === chartSeries.direction ? "yField" : void 0,
        range: "horizontal" !== chartSeries.direction,
        sortBy: "horizontal" === chartSeries.direction ? null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a2 ? void 0 : _a2.fields) || void 0 === _b2 ? void 0 : _b2[yField]) || void 0 === _c2 ? void 0 : _c2.domain) && void 0 !== _d2 ? _d2 : null === (_h2 = null === (_g2 = null === (_f2 = null === (_e2 = indicatorDefine.chartSpec) || void 0 === _e2 ? void 0 : _e2.data) || void 0 === _f2 ? void 0 : _f2.fields) || void 0 === _g2 ? void 0 : _g2[yField]) || void 0 === _h2 ? void 0 : _h2.domain : void 0
      };
      const xField = chartSeries.xField;
      collectValuesBy[xField] = {
        by: columnKeys,
        range: "horizontal" === chartSeries.direction,
        sumBy: false !== chartSeries.stack && rowKeys.concat(null == chartSeries ? void 0 : chartSeries.yField),
        sortBy: "horizontal" !== chartSeries.direction ? null !== (_m2 = null === (_l2 = null === (_k2 = null === (_j2 = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _j2 ? void 0 : _j2.fields) || void 0 === _k2 ? void 0 : _k2[xField]) || void 0 === _l2 ? void 0 : _l2.domain) && void 0 !== _m2 ? _m2 : null === (_r2 = null === (_q2 = null === (_p2 = null === (_o2 = indicatorDefine.chartSpec) || void 0 === _o2 ? void 0 : _o2.data) || void 0 === _p2 ? void 0 : _p2.fields) || void 0 === _q2 ? void 0 : _q2[xField]) || void 0 === _r2 ? void 0 : _r2.domain : void 0
      };
    });
    else {
      const yField = "string" == typeof indicatorDefine.chartSpec.yField ? indicatorDefine.chartSpec.yField : indicatorDefine.chartSpec.yField[0];
      collectValuesBy[yField] = {
        by: rowKeys,
        type: "horizontal" === indicatorDefine.chartSpec.direction ? "yField" : void 0,
        range: "horizontal" !== indicatorDefine.chartSpec.direction,
        sortBy: "horizontal" === indicatorDefine.chartSpec.direction ? null === (_t = null === (_s = null === (_r = null === (_q = indicatorDefine.chartSpec) || void 0 === _q ? void 0 : _q.data) || void 0 === _r ? void 0 : _r.fields) || void 0 === _s ? void 0 : _s[yField]) || void 0 === _t ? void 0 : _t.domain : void 0
      };
      const xField = indicatorDefine.chartSpec.xField;
      collectValuesBy[xField] = {
        by: columnKeys,
        range: "horizontal" === option.indicators[i].chartSpec.direction,
        sumBy: false !== indicatorDefine.chartSpec.stack && rowKeys.concat(null === (_u = indicatorDefine.chartSpec) || void 0 === _u ? void 0 : _u.yField),
        sortBy: "horizontal" !== indicatorDefine.chartSpec.direction ? null === (_y = null === (_x = null === (_w = null === (_v = indicatorDefine.chartSpec) || void 0 === _v ? void 0 : _v.data) || void 0 === _w ? void 0 : _w.fields) || void 0 === _x ? void 0 : _x[xField]) || void 0 === _y ? void 0 : _y.domain : void 0
      };
    }
  }
  return collectValuesBy;
}
function _generateAggregationRules(options) {
  var _a;
  const aggregationRules = [];
  return null === (_a = options.indicators) || void 0 === _a || _a.forEach((indicator) => {
    var _a2, _b;
    if ("string" == typeof indicator) aggregationRules.push({
      indicatorKey: indicator,
      field: indicator,
      aggregationType: AggregationType.RECORD
    });
    else if (null === (_a2 = indicator.chartSpec) || void 0 === _a2 ? void 0 : _a2.series) {
      const fields2 = [];
      null === (_b = indicator.chartSpec) || void 0 === _b || _b.series.forEach((seriesSpec) => {
        const seriesField = false === options.indicatorsAsCol ? seriesSpec.yField : seriesSpec.xField;
        -1 === fields2.indexOf(seriesField) && fields2.push(seriesField);
      }), aggregationRules.push({
        indicatorKey: indicator.indicatorKey,
        field: fields2,
        aggregationType: AggregationType.RECORD
      });
    } else {
      const field = false === options.indicatorsAsCol ? indicator.chartSpec.yField : indicator.chartSpec.xField;
      aggregationRules.push({
        indicatorKey: indicator.indicatorKey,
        field: null != field ? field : indicator.indicatorKey,
        aggregationType: AggregationType.RECORD
      });
    }
  }), aggregationRules;
}

// node_modules/@visactor/vtable/es/tools/get-data-path/index.js
function getDataCellPath(options, data, compareFunc) {
  var _a, _b;
  const results = createDataset(options);
  let columnDimensionTree = results.columnDimensionTree, rowDimensionTree = results.rowDimensionTree, isNeedResetColumnDimensionTree = false, isNeedResetRowDimensionTree = false;
  options.columnTree && options.indicatorsAsCol && !columnDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder) && (isNeedResetColumnDimensionTree = true), options.rowTree && (options.indicatorsAsCol || rowDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder) || (isNeedResetRowDimensionTree = true));
  const { dataset, layoutNodeId } = results, mockTable = {
    options,
    layoutNodeId,
    internalProps: options,
    isPivotChart: () => true,
    pivotChartAxes: [],
    _selectedDataItemsInChart: [],
    _getActiveChartInstance: () => ({
      updateState: () => {
      }
    })
  };
  options.columnTree && !isNeedResetColumnDimensionTree || (columnDimensionTree = new DimensionTree(null !== (_a = dataset.colHeaderTree) && void 0 !== _a ? _a : [], layoutNodeId)), options.rowTree && !isNeedResetRowDimensionTree || (rowDimensionTree = new DimensionTree(null !== (_b = dataset.rowHeaderTree) && void 0 !== _b ? _b : [], layoutNodeId));
  const layoutMap = new PivotHeaderLayoutMap(mockTable, dataset, columnDimensionTree, rowDimensionTree);
  for (let col = 0; col < layoutMap.colCount; col++) for (let row = 0; row < layoutMap.rowCount; row++) {
    if (layoutMap.isHeader(col, row)) continue;
    const cellDimensionPath = layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
      var _a2;
      return null !== (_a2 = colPath.indicatorKey) && void 0 !== _a2 ? _a2 : colPath.value;
    }), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
      var _a2;
      return null !== (_a2 = rowPath.indicatorKey) && void 0 !== _a2 ? _a2 : rowPath.value;
    }), aggregator2 = dataset.getAggregator(layoutMap.indicatorsAsCol ? rowKeys : rowKeys.slice(0, -1), layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, layoutMap.getIndicatorKey(col, row)), result2 = compareData(aggregator2.value ? aggregator2.value() : void 0, data, col, row, layoutMap, compareFunc);
    if (result2) return result2;
  }
}
function compareData(data1, data2, col, row, layoutMap, compareFunc) {
  if (isArray_default(data1)) {
    for (let i = 0; i < data1.length; i++) if (compareFunc ? compareFunc(data1[i], data2) : defaultCompare(data1[i], data2)) return layoutMap.getCellHeaderPaths(col, row);
  }
}
function defaultCompare(a2, b) {
  return JSON.stringify(a2) === JSON.stringify(b);
}

// node_modules/@visactor/vtable/es/render/jsx/index.js
function VTag(params2) {
  return new Tag(params2 ? params2.attribute : {});
}
function VCheckBox(params2) {
  return new CheckBox(params2 ? params2.attribute : {});
}
function VRadio(params2) {
  return new Radio(params2 ? params2.attribute : {});
}

// node_modules/@visactor/vtable/es/index.js
registerForVrender();
var version = "1.18.3";
function getIcons() {
  return get3();
}
function clearGlobal() {
  clearAll();
}
export {
  layout_exports as CustomLayout,
  DataStatistics_exports as DataStatistics,
  EventTarget3 as EventTarget,
  Icon,
  ListTableAll as ListTable,
  ListTableSimple,
  PIVOT_CHART_EVENT_TYPE,
  PIVOT_TABLE_EVENT_TYPE,
  PivotChart,
  PivotTableAll as PivotTable,
  PivotTableSimple,
  TABLE_EVENT_TYPE,
  ts_types_exports as TYPES,
  VArc,
  VArea,
  VCheckBox,
  VCircle,
  VGlyph,
  VGroup,
  VImage,
  VLine,
  VPath,
  VPolygon,
  VRadio,
  VRect,
  VSymbol,
  VTag,
  VText,
  clearGlobal,
  core_exports as core,
  data_exports as data,
  getDataCellPath,
  getIcons,
  getTargetCell,
  graphicUtil,
  jsx,
  plugins_exports as plugins,
  register_exports as register,
  registerAxis,
  registerButtonCell,
  registerChartCell,
  registerCheckboxCell,
  registerEmptyTip,
  registerImageCell,
  registerLegend,
  registerMenu,
  registerProgressBarCell,
  registerRadioCell,
  registerSparkLineCell,
  registerSwitchCell,
  registerTextCell,
  registerTitle,
  registerTooltip,
  registerVideoCell,
  renderChart,
  restoreMeasureText,
  setCustomAlphabetCharSet,
  textMeasure,
  themes_exports as themes,
  updateCell,
  version
};
//# sourceMappingURL=@visactor_vtable.js.map
