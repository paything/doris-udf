import {
  AABBBounds,
  Bounds,
  Color,
  DAY,
  DEFAULT_COLORS,
  HOUR,
  LRU,
  Logger,
  LoggerLevel,
  MINUTE,
  MONTH,
  Matrix,
  NumberUtil,
  OBBBounds,
  Point,
  PointService,
  SECOND,
  SMALL,
  TextMeasure,
  TimeUtil,
  U,
  aabbSeparation,
  abs,
  acos,
  albersUsa_default,
  albers_default,
  array,
  arrayEqual,
  asin,
  atan2,
  azimuthalEqualArea_default,
  azimuthalEquidistant_default,
  baseMerge,
  binaryFuzzySearch,
  binaryFuzzySearchInNumberRange,
  bisect,
  calculateAnchorOfBounds,
  calculateMaxRadius,
  cartesianToPolar,
  circleCircleIntersection,
  circleOverlap,
  clampAngleByRadian,
  clampRadian,
  clampRange_default,
  clamp_default,
  clamper,
  cloneDeep,
  color_exports,
  computeQuadrant,
  conicConformal_default,
  conicEqualArea_default,
  conicEquidistant_default,
  conjugateGradient,
  cos,
  crossProduct,
  csvParse,
  debounce_default,
  degreeToRadian,
  destination,
  dsv_default,
  epsilon,
  equalEarth_default,
  equirectangular_default,
  es_default,
  es_default2,
  feature_default,
  findZeroOfFunction,
  flattenArray,
  getAABBFromPoints,
  getAngleByPoint,
  getCenter,
  getContainerSize,
  getContextFont,
  getDecimalPlaces,
  getElementAbsolutePosition,
  getIntersectPoint,
  getRectIntersect,
  get_default,
  gnomonic_default,
  halfPi,
  has_default,
  hexToRgb,
  hslToRgb,
  identity_default,
  import_eventemitter3,
  init_src,
  interpolateDate,
  interpolateNumber,
  interpolateNumberRound,
  interpolateString,
  intersectionArea,
  isArray_default,
  isBase64_default,
  isBoolean_default,
  isEmpty_default,
  isEqual,
  isFunction_default,
  isGreater,
  isHTMLElement,
  isLess,
  isNil_default,
  isNumberClose,
  isNumber_default,
  isNumeric_default,
  isObjectLike_default,
  isObject_default,
  isPlainObject_default,
  isPointInLine,
  isPointInPolygon,
  isRectIntersect,
  isRotateAABBIntersect,
  isString_default,
  isUndefined_default,
  isValidNumber_default,
  isValidUrl_default,
  isValid_default,
  last,
  lowerCamelCaseToMiddle,
  max,
  maxInArray,
  median,
  memoize,
  mercator_default,
  merge,
  min,
  minInArray,
  mixin,
  naturalEarth1_default,
  nelderMead,
  norm2,
  normalTransform,
  normalizeAngle,
  normalizePadding,
  numberSpecifierReg,
  obbSeparation,
  orthographic_default,
  path_default,
  pi,
  pi2,
  pickWithout,
  pointAt,
  pointInRect,
  polarToCartesian,
  polygonContainPoint,
  polygonIntersectPolygon,
  precisionAdd,
  precisionSub,
  radianToDegree,
  range,
  rectInsideAnotherRect,
  require_geobuf,
  require_geojson_dissolve,
  require_lib,
  require_lottie,
  require_pbf,
  require_simplify_geojson,
  rgbToHsl,
  rotatePoint,
  scale,
  seedRandom,
  shuffleArray,
  simple_statistics_exports,
  sin,
  sqrt,
  stereographic_default,
  styleStringToObject,
  tau,
  throttle_default,
  toCamelCase,
  toNumber,
  toValidNumber,
  transformBoundsWithMatrix,
  transverseMercator_default,
  tsvParse,
  uniqArray,
  zeros,
  zerosM
} from "./chunk-OFTBKGPI.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@visactor/vchart/esm/data/parser/array.js
var arrayParser = (array2) => array2;

// node_modules/@visactor/vchart/esm/typings/spec/common.js
var RenderModeEnum;
!function(RenderModeEnum2) {
  RenderModeEnum2["desktop-browser"] = "desktop-browser", RenderModeEnum2["mobile-browser"] = "mobile-browser", RenderModeEnum2.node = "node", RenderModeEnum2.worker = "worker", RenderModeEnum2.miniApp = "miniApp", RenderModeEnum2.wx = "wx", RenderModeEnum2.tt = "tt", RenderModeEnum2.harmony = "harmony", RenderModeEnum2["desktop-miniApp"] = "desktop-miniApp", RenderModeEnum2.lynx = "lynx";
}(RenderModeEnum || (RenderModeEnum = {}));

// node_modules/@visactor/vchart/esm/component/interface/type.js
var ComponentTypeEnum;
!function(ComponentTypeEnum2) {
  ComponentTypeEnum2.cartesianAxis = "cartesianAxis", ComponentTypeEnum2.cartesianBandAxis = "cartesianAxis-band", ComponentTypeEnum2.cartesianLinearAxis = "cartesianAxis-linear", ComponentTypeEnum2.cartesianTimeAxis = "cartesianAxis-time", ComponentTypeEnum2.cartesianLogAxis = "cartesianAxis-log", ComponentTypeEnum2.cartesianSymlogAxis = "cartesianAxis-symlog", ComponentTypeEnum2.polarAxis = "polarAxis", ComponentTypeEnum2.polarBandAxis = "polarAxis-band", ComponentTypeEnum2.polarLinearAxis = "polarAxis-linear", ComponentTypeEnum2.crosshair = "crosshair", ComponentTypeEnum2.cartesianCrosshair = "cartesianCrosshair", ComponentTypeEnum2.polarCrosshair = "polarCrosshair", ComponentTypeEnum2.dataZoom = "dataZoom", ComponentTypeEnum2.geoCoordinate = "geoCoordinate", ComponentTypeEnum2.indicator = "indicator", ComponentTypeEnum2.discreteLegend = "discreteLegend", ComponentTypeEnum2.continuousLegend = "continuousLegend", ComponentTypeEnum2.colorLegend = "colorLegend", ComponentTypeEnum2.sizeLegend = "sizeLegend", ComponentTypeEnum2.mapLabel = "mapLabel", ComponentTypeEnum2.markLine = "markLine", ComponentTypeEnum2.markArea = "markArea", ComponentTypeEnum2.markPoint = "markPoint", ComponentTypeEnum2.polarMarkLine = "polarMarkLine", ComponentTypeEnum2.polarMarkArea = "polarMarkArea", ComponentTypeEnum2.polarMarkPoint = "polarMarkPoint", ComponentTypeEnum2.geoMarkPoint = "geoMarkPoint", ComponentTypeEnum2.tooltip = "tooltip", ComponentTypeEnum2.title = "title", ComponentTypeEnum2.player = "player", ComponentTypeEnum2.scrollBar = "scrollBar", ComponentTypeEnum2.label = "label", ComponentTypeEnum2.totalLabel = "totalLabel", ComponentTypeEnum2.brush = "brush", ComponentTypeEnum2.poptip = "poptip", ComponentTypeEnum2.customMark = "customMark";
}(ComponentTypeEnum || (ComponentTypeEnum = {}));

// node_modules/@visactor/vdataset/es/transform/filter.js
var filter = (data, options) => {
  const { callback } = options;
  return callback && (data = data.filter(callback)), data;
};

// node_modules/@visactor/vdataset/es/utils/geo.js
var WORLD_SIZE = 63781 * Math.PI * 2;
var fov = 0.25 * Math.PI;
var WORLD_HEIGHT = WORLD_SIZE / 2 / Math.tan(fov);
var PROJECTION_MERCATOR = mercator_default().translate([0, 0]).center([0, 0]).scale(63781);

// node_modules/@visactor/vdataset/es/transform/geo/dissolve.js
var import_geojson_dissolve = __toESM(require_geojson_dissolve());

// node_modules/@visactor/vdataset/es/transform/geo/simplify.js
var import_simplify_geojson = __toESM(require_simplify_geojson());

// node_modules/@visactor/vdataset/es/utils/js.js
var mergeDeepImmer = function(target, ...sources) {
  return mergeOption(cloneDeep(target), ...sources);
};
function _mergeOptionDeep(target, source, key) {
  const sourceValue = source[key];
  if (void 0 === sourceValue) target[key] = null;
  else if (isObject_default(sourceValue)) {
    isObject_default(target[key]) || (target[key] = {});
    for (const _key in sourceValue) _mergeOptionDeep(target[key], sourceValue, _key);
  } else target[key] = sourceValue;
}
function _mergeOptionBase(target, source) {
  if (isObject_default(source) && target !== source) for (const key in source) _mergeOptionDeep(target, source, key);
}
function mergeOption(target, ...sources) {
  target || (target = {});
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    _mergeOptionBase(target, sources[sourceIndex]);
  }
  return target;
}

// node_modules/@visactor/vdataset/es/transform/geo/simplify.js
var DEFAULT_SIMPLIFY_OPTIONS = {
  tolerance: 0.01
};
var simplify = (data, options) => {
  const mergeOptions = mergeDeepImmer(DEFAULT_SIMPLIFY_OPTIONS, options), { tolerance } = mergeOptions;
  return (0, import_simplify_geojson.default)(data, tolerance);
};

// node_modules/@visactor/vdataset/es/constants.js
var DATAVIEW_TYPE;
!function(DATAVIEW_TYPE2) {
  DATAVIEW_TYPE2.DSV = "dsv", DATAVIEW_TYPE2.TREE = "tree", DATAVIEW_TYPE2.GEO = "geo", DATAVIEW_TYPE2.BYTE = "bytejson", DATAVIEW_TYPE2.HEX = "hex", DATAVIEW_TYPE2.GRAPH = "graph", DATAVIEW_TYPE2.TABLE = "table", DATAVIEW_TYPE2.GEO_GRATICULE = "geo-graticule";
}(DATAVIEW_TYPE || (DATAVIEW_TYPE = {}));
var STATISTICS_METHODS = ["max", "mean", "median", "min", "mode", "product", "standardDeviation", "sum", "sumSimple", "variance"];

// node_modules/@visactor/vdataset/es/transform/statistics.js
var aggregates = {
  count: (data) => data.length,
  distinct: (data, field5) => uniqArray(data.map((row) => +row[field5])).length
};
STATISTICS_METHODS.forEach((method) => {
  aggregates[method] = (data, field5) => {
    let values = data.map((row) => +row[field5]);
    return isArray_default(values) && isArray_default(values[0]) && (values = flattenArray(values)), simple_statistics_exports[method](values);
  };
}), aggregates.average = aggregates.mean;

// node_modules/@visactor/vdataset/es/transform/fold.js
var fold = (data, options) => {
  const { fields: fields2, key, value, retains } = options, results = [];
  for (let i = 0; i < data.length; i++) fields2.forEach((field5) => {
    const item = {};
    if (item[key] = field5, item[value] = data[i][field5], retains) retains.forEach((retain) => {
      item[retain] = data[i][retain];
    });
    else for (const prop in data[i]) -1 === fields2.indexOf(prop) && (item[prop] = data[i][prop]);
    results.push(item);
  });
  return results;
};

// node_modules/@visactor/vdataset/es/transform/fields.js
var fields = (data, options) => {
  var _a, _b;
  if (!(null == options ? void 0 : options.fields)) return data;
  if (0 === data.length) return data;
  const fields2 = options.fields, dataTemp = data[0], filterFields = {}, sortFields = [];
  for (const key in fields2) if (Object.prototype.hasOwnProperty.call(fields2, key)) {
    const fieldInfo = fields2[key];
    if (!fieldInfo.type) {
      let dataCheck = dataTemp;
      key in dataTemp || (dataCheck = null !== (_a = data.find((d) => key in d)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
    }
    let sortInfo;
    if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
      key,
      type: fieldInfo.type,
      index: fieldInfo.sortIndex,
      sortIndex: {},
      sortIndexCount: 0,
      sortReverse: true === fieldInfo.sortReverse
    }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0) if ("ordinal" === fieldInfo.type) {
      fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
      const _domainCache = {};
      fieldInfo.domain.forEach((d, i) => {
        _domainCache[d] = i, fieldInfo._domainCache[d] = i;
      }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
    } else fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
  }
  return Object.keys(filterFields).length > 0 && (data = data.filter((d) => {
    for (const key in filterFields) {
      const fieldInfo = filterFields[key];
      if ("ordinal" === fieldInfo.type) {
        if (!(d[key] in fieldInfo._domainCache)) return false;
      } else if (fieldInfo.domain[0] > d[key] || fieldInfo.domain[1] < d[key]) return false;
    }
    return true;
  })), sortFields.sort((a3, b) => a3.index - b.index), data.sort((a3, b) => sortData(a3, b, sortFields)), data;
};
function sortData(a3, b, sortFields) {
  for (let i = 0; i < sortFields.length; i++) {
    const sortInfo = sortFields[i];
    let v = 0;
    if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b[sortInfo.key]] && (sortInfo.sortIndex[b[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a3[sortInfo.key]] && (sortInfo.sortIndex[a3[sortInfo.key]] = sortInfo.sortIndexCount++), v = sortInfo.sortIndex[a3[sortInfo.key]] - sortInfo.sortIndex[b[sortInfo.key]]) : "linear" === sortInfo.type && (v = a3[sortInfo.key] - b[sortInfo.key]), sortInfo.sortReverse && (v = -v), 0 !== v) return v;
  }
  return 0;
}

// node_modules/@visactor/vdataset/es/parser/dsv.js
var DEFAULT_DSV_PARSER_OPTIONS = {
  delimiter: ","
};
var dsvParser = (data, options = {}, dataView) => {
  dataView.type = DATAVIEW_TYPE.DSV;
  const mergeOptions = mergeDeepImmer(DEFAULT_DSV_PARSER_OPTIONS, options), { delimiter } = mergeOptions;
  if (!isString_default(delimiter)) throw new TypeError("Invalid delimiter: must be a string!");
  return dsv_default(delimiter).parse(data);
};
var csvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, csvParse(data));
var tsvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, tsvParse(data));

// node_modules/@visactor/vdataset/es/parser/geo/geobuf.js
var geobuf = __toESM(require_geobuf());
var import_pbf = __toESM(require_pbf());

// node_modules/@visactor/vdataset/es/parser/geo/geojson.js
var geoPathInstance = path_default();
var DEFAULT_GEOJSON_OPTIONS = {
  centroid: false,
  name: false,
  bbox: false,
  rewind: false
};
var MultiToSingle = (feature) => {
  if (feature.geometry.type.startsWith("Multi")) {
    const f = es_default2(feature).features[0];
    return Object.assign(Object.assign({}, f), f.properties);
  }
  return Object.assign(Object.assign({}, feature), feature.properties);
};
var flattenFeature = (data) => {
  const featuresArr = [];
  return data.forEach((item) => {
    "FeatureCollection" === item.type ? item.features.forEach((feature) => {
      featuresArr.push(MultiToSingle(feature));
    }) : featuresArr.push(MultiToSingle(item));
  }), featuresArr;
};
var geoJSONParser = (data, options = {}, dataView) => {
  dataView.type = DATAVIEW_TYPE.GEO;
  const mergeOptions = mergeDeepImmer(DEFAULT_GEOJSON_OPTIONS, options), { centroid, name, bbox, rewind } = mergeOptions;
  if (Array.isArray(data)) return flattenFeature(data);
  let features = data.features;
  return rewind && (features = es_default(data, {
    reverse: !isObject_default(rewind) || rewind.reverse
  }).features), features.forEach((feature) => {
    if (centroid) {
      const centroid2 = geoPathInstance.centroid(feature);
      feature.centroidX = centroid2[0], feature.centroidY = centroid2[1];
    }
    if (name && (feature.name = feature.properties.name), bbox) {
      const bbox2 = geoPathInstance.bounds(feature);
      feature.bbox = bbox2;
    }
  }), data.features = features, data;
};

// node_modules/@visactor/vdataset/es/parser/geo/topojson.js
init_src();
var DEFAULT_TOPOJSON_OPTIONS = {};
var topoJSONParser = (data, options, dataView) => {
  dataView.type = DATAVIEW_TYPE.GEO;
  const mergeOptions = mergeDeepImmer(DEFAULT_GEOJSON_OPTIONS, DEFAULT_TOPOJSON_OPTIONS, options), { object } = mergeOptions;
  if (!isString_default(object)) throw new TypeError("Invalid object: must be a string!");
  const geoData = feature_default(data, data.objects[object]);
  return geoJSONParser(geoData, mergeOptions, dataView);
};

// node_modules/@visactor/vdataset/es/parser/data-view.js
var dataViewParser = (data, options, dataView) => {
  const dependencyUpdate = !isBoolean_default(null == options ? void 0 : options.dependencyUpdate) || (null == options ? void 0 : options.dependencyUpdate);
  if (!data || !isArray_default(data)) throw new TypeError("Invalid data: must be DataView array!");
  return isArray_default(dataView.rawData) && dataView.rawData.forEach((rd) => {
    rd.target && (rd.target.removeListener("change", dataView.reRunAllTransform), rd.target.removeListener("markRunning", dataView.markRunning));
  }), dependencyUpdate && data.forEach((d) => {
    d.target.addListener("change", dataView.reRunAllTransform), d.target.addListener("markRunning", dataView.markRunning);
  }), data;
};

// node_modules/@visactor/vdataset/es/parser/svg.js
var tagNameToType = {
  svg: "group",
  rect: "rect",
  line: "rule",
  polygon: "polygon",
  path: "path",
  polyline: "line",
  g: "group",
  circle: "arc",
  ellipse: "arc"
};
var validTagName = Object.keys(tagNameToType);
var validGroupNode = ["g", "svg", "text", "tspan", "switch"];
var validTextAttributes = ["font-size", "font-family", "font-weight", "font-style", "text-align", "text-anchor"];
var validCircleAttributes = ["cx", "cy", "r"];
var validEllipseAttributes = ["cx", "cy", "rx", "ry"];
var validLineAttributes = ["x1", "x2", "y1", "y2"];
var validAttributes = ["visibility", "x", "y", "width", "height", "d", "points", "stroke", "stroke-width", "fill", "fill-opacity", "stroke-opacity", ...validTextAttributes, ...validCircleAttributes, ...validEllipseAttributes, ...validLineAttributes];
var validInheritAttributes = ["visible", "fill", "stroke", "stroke-width", "fill-opacity", "stroke-opacity", ...validTextAttributes];
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg) || [];
}
var svgParser = (data, option = {}, dataView) => {
  let parser = option.customDOMParser;
  if (parser || (null === window || void 0 === window ? void 0 : window.DOMParser) && (parser = (svg2) => new DOMParser().parseFromString(svg2, "text/xml")), !parser) throw new Error("No Available DOMParser!");
  const svg = parser(data);
  let node = 9 === svg.nodeType ? svg.firstChild : svg;
  for (; node && ("svg" !== node.nodeName.toLowerCase() || 1 !== node.nodeType); ) node = node.nextSibling;
  if (node) {
    return parseSvgNode(node);
  }
  return null;
};
var idx = 0;
function parseSvgNode(svg, opt = {}) {
  const elements = [], root = parseNode(svg, null);
  let width = parseFloat(svg.getAttribute("width") || opt.width), height = parseFloat(svg.getAttribute("height") || opt.height);
  !isValidNumber_default(width) && (width = null), !isValidNumber_default(height) && (height = null);
  const viewBox = svg.getAttribute("viewBox");
  let viewBoxRect;
  if (viewBox) {
    const viewBoxArr = splitNumberSequence(viewBox);
    if (viewBoxArr.length >= 4 && (viewBoxRect = {
      x: parseFloat(viewBoxArr[0] || 0),
      y: parseFloat(viewBoxArr[1] || 0),
      width: parseFloat(viewBoxArr[2]),
      height: parseFloat(viewBoxArr[3])
    }, width || height)) {
      const boundingRect = {
        x: 0,
        y: 0,
        width,
        height
      }, scaleX = boundingRect.width / viewBoxRect.width, scaleY = boundingRect.height / viewBoxRect.height, scale4 = Math.min(scaleX, scaleY), transLateX = -(viewBoxRect.x + viewBoxRect.width / 2) * scale4 + (boundingRect.x + boundingRect.width / 2), transLateY = -(viewBoxRect.y + viewBoxRect.height / 2) * scale4 + (boundingRect.y + boundingRect.height / 2), viewBoxTransform = new Matrix().translate(transLateX, transLateY).scale(scale4, scale4);
      root.transform = viewBoxTransform;
    }
  }
  return traverse(svg, root, elements), {
    root,
    width,
    height,
    elements,
    viewBoxRect
  };
}
function parseInheritAttributes(parsedElement) {
  let inheritedAttrs;
  const { parent, attributes } = parsedElement, parse2 = (parent2) => parent2 ? validInheritAttributes.reduce((acc, attrName) => {
    const camelAttrName = toCamelCase(attrName);
    return isValid_default(parent2[camelAttrName]) && (acc[camelAttrName] = parent2[camelAttrName]), acc;
  }, {}) : {};
  return parent ? (parent._inheritStyle || (parent._inheritStyle = parse2(parent.attributes)), inheritedAttrs = merge({}, parent._inheritStyle, parse2(attributes))) : inheritedAttrs = parse2(attributes), inheritedAttrs;
}
function parseAttributes(el) {
  var _a, _b, _c;
  const attrs = {}, attributes = null !== (_a = el.attributes) && void 0 !== _a ? _a : {}, style = null !== (_b = el.style) && void 0 !== _b ? _b : {};
  for (let i = 0; i < validAttributes.length; i++) {
    const attrName = validAttributes[i], attrValue = isValid_default(style[attrName]) && "" !== style[attrName] ? style[attrName] : null === (_c = attributes[attrName]) || void 0 === _c ? void 0 : _c.value;
    isValid_default(attrValue) && (attrs[toCamelCase(attrName)] = isNaN(+attrValue) ? attrValue : parseFloat(attrValue));
  }
  return "none" === style.display && (attrs.visible = false), ["fontSize", "strokeWidth", "width", "height"].forEach((attr) => {
    const attrValue = attrs[attr];
    isString_default(attrs[attr]) && (attrs[attr] = parseFloat(attrValue));
  }), attrs;
}
function parseNode(node, parent) {
  var _a, _b, _c, _d, _e;
  const tagName = null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLowerCase();
  if (3 === node.nodeType || "text" === tagName || "tspan" === tagName) return parseText(node, parent);
  if (!validTagName.includes(tagName)) return null;
  const parsed = {
    tagName,
    graphicType: tagNameToType[tagName],
    attributes: parseAttributes(node),
    parent,
    name: null !== (_b = node.getAttribute("name")) && void 0 !== _b ? _b : null === (_c = null == parent ? void 0 : parent.attributes) || void 0 === _c ? void 0 : _c.name,
    id: null !== (_d = node.getAttribute("id")) && void 0 !== _d ? _d : `${tagName}-${idx++}`,
    transform: parseTransform(node)
  };
  return parsed._inheritStyle = parseInheritAttributes(parsed), parent && !isValid_default(parsed.name) && (parsed._nameFromParent = null !== (_e = parent.name) && void 0 !== _e ? _e : parent._nameFromParent), parsed;
}
function parseText(node, parent) {
  var _a, _b, _c, _d, _e, _f;
  if (!parent) return null;
  const tagName = null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLowerCase();
  if (!tagName && "group" !== parent.graphicType) return null;
  const nodeAsGroup = "text" === tagName || "tspan" === tagName, elType = nodeAsGroup ? "group" : "text", value = nodeAsGroup || null === (_b = node.textContent) || void 0 === _b ? void 0 : _b.replace(/\n/g, " ").replace(/\s+/g, " ");
  if (" " === value) return null;
  let parsed;
  return parsed = nodeAsGroup ? {
    tagName,
    graphicType: elType,
    attributes: parseAttributes(node),
    parent,
    name: node.getAttribute("name"),
    id: null !== (_c = node.getAttribute("id")) && void 0 !== _c ? _c : `${tagName}-${idx++}`,
    transform: parseTransform(node),
    value
  } : {
    tagName,
    graphicType: "text",
    attributes: parseAttributes(node),
    parent,
    name: null == parent ? void 0 : parent.name,
    id: null !== (_e = null === (_d = node.getAttribute) || void 0 === _d ? void 0 : _d.call(node, "id")) && void 0 !== _e ? _e : `${tagName}-${idx++}`,
    value
  }, parsed._inheritStyle = parseInheritAttributes(parsed), isValid_default(parsed.name) || (parsed._nameFromParent = null !== (_f = parent.name) && void 0 !== _f ? _f : parent._nameFromParent), nodeAsGroup ? parent._textGroupStyle ? parsed._textGroupStyle = merge({}, parent._textGroupStyle, parseAttributes(node)) : parsed._textGroupStyle = parseAttributes(node) : parsed.attributes = parsed._inheritStyle, parsed;
}
function parseTransform(node) {
  var _a, _b;
  const transforms = null === (_a = node.transform) || void 0 === _a ? void 0 : _a.baseVal;
  if (!transforms) return null;
  const matrix = null === (_b = transforms.consolidate()) || void 0 === _b ? void 0 : _b.matrix;
  if (!matrix) return null;
  const { a: a3, b, c: c3, d, e, f } = matrix;
  return new Matrix(a3, b, c3, d, e, f);
}
function traverse(node, parsedParent, result2 = []) {
  var _a;
  if (!node) return;
  let parseResult;
  "svg" !== node.nodeName && (parseResult = parseNode(node, parsedParent)), parseResult && result2.push(parseResult);
  let child = validGroupNode.includes(null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLocaleLowerCase()) ? node.firstChild : null;
  for (; child; ) traverse(child, null != parseResult ? parseResult : parsedParent, result2), child = child.nextSibling;
}

// node_modules/@visactor/vdataset/es/utils/uuid.js
var idIndex = 0;
var maxId = 1e8;
function getUUID(prefix = "dataset") {
  return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
}

// node_modules/@visactor/vdataset/es/data-set.js
var DataSet = class {
  constructor(options) {
    var _a;
    let name;
    this.options = options, this.isDataSet = true, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new import_eventemitter3.default(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger.getInstance();
  }
  setLogger(logger) {
    this._logger = logger;
  }
  getDataView(name) {
    return this.dataViewMap[name];
  }
  setDataView(name, dataView) {
    var _a;
    this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} 之前已存在，请重新命名`)), this.dataViewMap[name] = dataView;
  }
  removeDataView(name) {
    this.dataViewMap[name] = null, delete this.dataViewMap[name];
  }
  registerParser(name, parser) {
    var _a;
    this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.parserMap[name] = parser;
  }
  removeParser(name) {
    this.parserMap[name] = null, delete this.parserMap[name];
  }
  getParser(name) {
    return this.parserMap[name] || this.parserMap.default;
  }
  registerTransform(name, transform30) {
    var _a;
    this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.transformMap[name] = transform30;
  }
  removeTransform(name) {
    this.transformMap[name] = null, delete this.transformMap[name];
  }
  getTransform(name) {
    return this.transformMap[name];
  }
  multipleDataViewAddListener(list, event, call) {
    this._callMap || (this._callMap = /* @__PURE__ */ new Map());
    let callAd = this._callMap.get(call);
    callAd || (callAd = () => {
      list.some((l) => l.isRunning) || call();
    }), list.forEach((l) => {
      l.target.addListener(event, callAd);
    }), this._callMap.set(call, callAd);
  }
  allDataViewAddListener(event, call) {
    this.multipleDataViewAddListener(Object.values(this.dataViewMap), event, call);
  }
  multipleDataViewRemoveListener(list, event, call) {
    if (this._callMap) {
      const callAd = this._callMap.get(call);
      callAd && list.forEach((l) => {
        l.target.removeListener(event, callAd);
      }), this._callMap.delete(call);
    }
  }
  multipleDataViewUpdateInParse(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.parseNewData(d.data, d.options);
    });
  }
  multipleDataViewUpdateInRawData(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.updateRawData(d.data, d.options);
    });
  }
  destroy() {
    this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
  }
};

// node_modules/@visactor/vdataset/es/data-view.js
var DataViewDiffRank = "_data-view-diff-rank";
var DataView = class _DataView {
  constructor(dataSet, options) {
    let name;
    this.dataSet = dataSet, this.options = options, this.isDataView = true, this.target = new import_eventemitter3.default(), this.parseOption = null, this.transformsArr = [], this.isRunning = false, this.rawData = {}, this.history = false, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = (opt = {
      pushHistory: true,
      emitMessage: true
    }) => (this.isRunning = true, this.resetTransformData(), this.transformsArr.forEach((t) => {
      this.executeTransform(t, {
        pushHistory: opt.pushHistory,
        emitMessage: false
      }), this.isLastTransform(t) && this.diffLastData();
    }), this.isRunning = false, false !== opt.emitMessage && this.target.emit("change", []), this), this.markRunning = () => {
      this.isRunning = true, this.target.emit("markRunning", []);
    }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
  }
  parse(data, options, emit = false) {
    var _a;
    this.isRunning = true, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
    const cloneData = this.cloneParseData(data, options);
    if (null == options ? void 0 : options.type) {
      const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
      this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
    } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
    return this.isRunning = false, emit && this.target.emit("afterParse", []), this;
  }
  transform(options, execute = true) {
    if (this.isRunning = true, options && options.type) {
      let pushOption = true;
      if ("fields" === options.type) {
        this._fields = options.options.fields;
        const index = this.transformsArr.findIndex((_op) => _op.type === options.type);
        index >= 0 && (pushOption = false, this.transformsArr[index].options.fields = this._fields);
      }
      if (pushOption && this.transformsArr.push(options), execute) {
        const lastTag = this.isLastTransform(options);
        this.executeTransform(options), lastTag && this.diffLastData();
      }
    }
    return this.sortTransform(), this.isRunning = false, this;
  }
  isLastTransform(options) {
    return this.transformsArr[this.transformsArr.length - 1] === options;
  }
  sortTransform() {
    this.transformsArr.length >= 2 && this.transformsArr.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
    });
  }
  executeTransform(options, opt = {
    pushHistory: true,
    emitMessage: true
  }) {
    const { pushHistory, emitMessage } = opt, transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
    this.history && false !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, false !== emitMessage && this.target.emit("change", []);
  }
  resetTransformData() {
    this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
  }
  enableDiff(keys) {
    this._diffData = true, this._diffKeys = keys, this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  disableDiff() {
    this._diffData = false, this._diffMap = null, this._diffRank = null;
  }
  resetDiff() {
    this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  diffLastData() {
    var _a;
    if (!this._diffData) return;
    if (!this.latestData.forEach) return;
    if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length)) return;
    const next = this._diffRank + 1;
    if (0 === this._diffRank) this.latestData.forEach((d) => {
      d[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), d);
    }), this.latestDataAUD = {
      add: Array.from(this.latestData),
      del: [],
      update: []
    };
    else {
      let tempKey;
      this.latestDataAUD = {
        add: [],
        del: [],
        update: []
      }, this.latestData.forEach((d) => {
        d[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d) : this.latestDataAUD.add.push(d), this._diffMap.set(tempKey, d);
      }), this._diffMap.forEach((v, k2) => {
        v[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v), this._diffMap.delete(k2));
      });
    }
    this._diffRank = next;
  }
  cloneParseData(data, options) {
    let clone = false;
    return data instanceof _DataView || true !== (null == options ? void 0 : options.clone) || (clone = true), clone ? cloneDeep(data) : data;
  }
  parseNewData(data, options) {
    this.parse(data, options || this.parseOption), this.reRunAllTransform();
  }
  updateRawData(data, options) {
    const cloneData = this.cloneParseData(data, options);
    this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
  }
  getFields() {
    var _a;
    return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
  }
  setFields(f, foreMerge = false) {
    this._fields = f && foreMerge ? merge({}, this._fields, f) : f;
    const fieldsOption = this.transformsArr.find((_op) => "fields" === _op.type);
    !isNil_default(this._fields) && isNil_default(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
      type: "fields",
      options: {
        fields: this._fields
      }
    }, false)) : fieldsOption && (fieldsOption.options.fields = this._fields);
  }
  destroy() {
    this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
  }
};
function isDataView(obj) {
  return obj instanceof DataView;
}

// node_modules/@visactor/vdataset/es/projection/projections.js
var defaultPath = path_default();

// node_modules/@visactor/vrender-core/es/common/generator.js
var Generator = class _Generator {
  static GenAutoIncrementId() {
    return _Generator.auto_increment_id++;
  }
};
Generator.auto_increment_id = 0;

// node_modules/@visactor/vrender-core/es/common/inversify/cotainer-module.js
var ContainerModule = class {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/metadata_keys.js
var NAMED_TAG = "named";
var INJECT_TAG = "inject";
var MULTI_INJECT_TAG = "multi_inject";
var TAGGED = "inversify:tagged";
var PARAM_TYPES = "inversify:paramtypes";
function getNonCustomTagKeys() {
  return ["inject", "multi_inject", "name", "unmanaged", "named", "optional"];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

// node_modules/@visactor/vrender-core/es/common/inversify/meta-data.js
var Metadata = class {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};

// node_modules/@visactor/vrender-core/es/common/Reflect-metadata.js
var Reflect_metadata_default = function(Reflect2) {
  var target, previous;
  return function(exporter) {
    Object.prototype.hasOwnProperty;
    const supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", functionPrototype = (supportsSymbol && void 0 !== Symbol.iterator && Symbol.iterator, Object.create, Object.getPrototypeOf(Function)), _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map), Metadata2 = (Set, /* @__PURE__ */ new WeakMap());
    function defineMetadata(metadataKey, metadataValue, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
    }
    function hasMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target2, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target2, propertyKey);
    }
    function getMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target2, propertyKey);
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      let targetMetadata = Metadata2.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map(), Metadata2.set(O, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return true;
      const parent = OrdinaryGetPrototypeOf(O);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      const parent = OrdinaryGetPrototypeOf(O);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      GetOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
    }
    function Type(x) {
      if (null === x) return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return void 0 === x;
    }
    function IsNull(x) {
      return null === x;
    }
    function IsSymbol(x) {
      return "symbol" == typeof x;
    }
    function IsObject(x) {
      return "object" == typeof x ? null !== x : "function" == typeof x;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result2 = exoticToPrim.call(input, hint);
        if (IsObject(result2)) throw new TypeError();
        return result2;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if ("string" === hint) {
        const toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          const result2 = toString_1.call(O);
          if (!IsObject(result2)) return result2;
        }
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2)) return result2;
        }
      } else {
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2)) return result2;
        }
        const toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          const result2 = toString_2.call(O);
          if (!IsObject(result2)) return result2;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V, P) {
      const func = V[P];
      if (null != func) {
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O) {
      const proto = Object.getPrototypeOf(O);
      if ("function" != typeof O || O === functionPrototype) return proto;
      if (proto !== functionPrototype) return proto;
      const prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O ? proto : constructor;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect2, function(key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: true,
      writable: true,
      value
    }), previous && previous(key, value);
  })), Reflect2;
}({});

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject_base.js
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect_metadata_default.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect_metadata_default.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect_metadata_default.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return (serviceIdentifier) => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject.js
var inject = injectBase(INJECT_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/multi_inject.js
var multiInject = injectBase(MULTI_INJECT_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/injectable.js
function injectable() {
  return function(target) {
    return Reflect_metadata_default.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/named.js
function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

// node_modules/@visactor/vrender-core/es/common/inversify/literal_types.js
var BindingScopeEnum = {
  Singleton: "Singleton",
  Transient: "Transient"
};
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};

// node_modules/@visactor/vrender-core/es/common/inversify/binding.js
var Binding = class _Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = false, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = (request) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone = new _Binding(this.serviceIdentifier, this.scope);
    return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/metadata_reader.js
var MetadataReader = class {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect_metadata_default.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect_metadata_default.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("暂未实现");
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/constraint_helpers.js
var taggedConstraint = (key) => (value) => {
  const constraint = (request) => {
    if (null == request) return false;
    if (request.key === key && request.value === value) return true;
    if (null == request.constructorArgsMetadata) return false;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return true;
    return false;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
var namedConstraint = taggedConstraint(NAMED_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_in_syntax.js
var BindingInSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("暂未实现");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_to_syntax.js
var BindingToSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self = this._binding.serviceIdentifier;
    return this.to(self);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue((context) => context.container.get(service));
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/container.js
var Container = class {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = /* @__PURE__ */ new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named2) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named2);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope, binding = new Binding(serviceIdentifier, scope), list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
      bindingToSyntax._binding.moduleId = moduleId;
    }, getBindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.bind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    }, getUnbindFunction = () => (serviceIdentifier) => this.unbind(serviceIdentifier), getIsboundFunction = () => (serviceIdentifier) => this.isBound(serviceIdentifier), getRebindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.rebind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    };
    return (mId) => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: (serviceIdentifier) => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier
    };
  }
  _get(getArgs) {
    const result2 = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter((b) => b.constraint(getArgs)).forEach((binding) => {
      result2.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result2.length ? result2 : result2[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType, { userGeneratedMetadata } = this._metadataReader.getConstructorMetadata(constr), keys = Object.keys(userGeneratedMetadata), arr = [];
    for (let i = 0; i < keys.length; i++) {
      const constructorArgsMetadata = userGeneratedMetadata[i], targetMetadataMap = {};
      constructorArgsMetadata.forEach((md) => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
        inject: targetMetadataMap[INJECT_TAG],
        multiInject: targetMetadataMap[MULTI_INJECT_TAG]
      }, injectIdentifier = metadata.inject || metadata.multiInject, target = {
        serviceIdentifier: injectIdentifier,
        constructorArgsMetadata
      }, bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter((b) => b.constraint(target));
      if (bindings.length) {
        const request = {
          injectIdentifier,
          metadata: constructorArgsMetadata,
          bindings
        };
        arr.push(request);
      }
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result2 = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result2), result2;
  }
  _getResolvedFromBinding(binding) {
    let result2;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result2 = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result2 = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result2 = binding.dynamicValue({
          container: this
        });
    }
    return result2;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated) return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map((request) => request.bindings.length > 1 ? request.bindings.map((binding) => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result2) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result2, binding.activated = true);
  }
};

// node_modules/@visactor/vrender-core/es/common/contribution-provider.js
var ContributionProvider = Symbol("ContributionProvider");
var ContributionProviderCache = class {
  constructor(serviceIdentifier, container2) {
    this.serviceIdentifier = serviceIdentifier, this.container = container2;
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
};
function bindContributionProvider(bind, id) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id, container2)).inSingletonScope().whenTargetNamed(id);
}
function bindContributionProviderNoSingletonScope(bind, id) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id, container2)).whenTargetNamed(id);
}

// node_modules/@visactor/vrender-core/es/tapable/Hook.js
var Hook = class {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter((tap) => !(tap.name === name && (!fn || tap.fn === fn))));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options) _options = {
      name: options.trim()
    };
    else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
    return _options = Object.assign({
      type,
      fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = /* @__PURE__ */ new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i = this.taps.length;
    for (; i > 0; ) {
      i--;
      const x = this.taps[i];
      this.taps[i + 1] = x;
      const xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) continue;
      }
      if (!(xStage > stage)) {
        i++;
        break;
      }
    }
    this.taps[i] = item;
  }
};

// node_modules/@visactor/vrender-core/es/tapable/SyncHook.js
var SyncHook = class extends Hook {
  call(...args) {
    this.taps.map((t) => t.fn).forEach((cb) => cb(...args));
  }
};

// node_modules/@visactor/vrender-core/es/constants.js
var EnvContribution = Symbol.for("EnvContribution");
var VGlobal = Symbol.for("VGlobal");
var DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

// node_modules/@visactor/vrender-core/es/core/global.js
var __decorate = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DefaultGlobal = class {
  get env() {
    return this._env;
  }
  get isImageAnonymous() {
    return this._isImageAnonymous;
  }
  set isImageAnonymous(isImageAnonymous) {
    this._isImageAnonymous = isImageAnonymous;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    this.contributions = contributions, this._isImageAnonymous = true, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = false;
  }
  bindContribution(params2) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach((contribution) => {
      const data = contribution.configure(this, params2);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length) return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params2) {
    if (params2 && true === params2.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params2);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params2) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params2);
    if (data && data.then) return data.then(() => {
      this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
    });
    this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params2);
  }
  createOffscreenCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params2);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  addEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  loadFont(name, source, descriptors) {
    return __awaiter(this, void 0, void 0, function* () {
      return this._env || this.setEnv("browser"), this.envContribution.loadFont(name, source, descriptors);
    });
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params2);
  }
  updateDom(dom, params2) {
    return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params2);
  }
  getElementTop(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
  isMacOS() {
    return this._env || this.setEnv("browser"), this.envContribution.isMacOS();
  }
  copyToClipBoard(text2) {
    return this._env || this.setEnv("browser"), this.envContribution.copyToClipBoard(text2);
  }
};
DefaultGlobal = __decorate([injectable(), __param(0, inject(ContributionProvider)), __param(0, named(EnvContribution)), __metadata("design:paramtypes", [Object])], DefaultGlobal);

// node_modules/@visactor/vrender-core/es/interface/graphic/bounds.js
var params;
!function(params2) {
  params2[params2.W = 1] = "W", params2[params2.H = 2] = "H", params2[params2.WH = 3] = "WH";
}(params || (params = {}));

// node_modules/@visactor/vrender-core/es/interface/graphic/text.js
var MeasureModeEnum;
!function(MeasureModeEnum2) {
  MeasureModeEnum2[MeasureModeEnum2.estimate = 0] = "estimate", MeasureModeEnum2[MeasureModeEnum2.actualBounding = 1] = "actualBounding", MeasureModeEnum2[MeasureModeEnum2.fontBounding = 2] = "fontBounding";
}(MeasureModeEnum || (MeasureModeEnum = {}));

// node_modules/@visactor/vrender-core/es/common/bounds-context.js
var circleThreshold = tau - 1e-8;
var BoundsContext = class {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
    let s2, i, x, y, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;
    function update3(a3) {
      x = r * Math.cos(a3), y = r * Math.sin(a3), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
    }
    if (update3(sa), update3(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s2 = sa, sa = ea, ea = s2), ccw) for (ea -= tau, s2 = sa - sa % halfPi, i = 0; i < 4 && s2 > ea; ++i, s2 -= halfPi) update3(s2);
    else for (s2 = sa - sa % halfPi + halfPi, i = 0; i < 4 && s2 < ea; ++i, s2 += halfPi) update3(s2);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this.bounds.add(x1, y1);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
  }
  closePath() {
  }
  ellipse() {
    throw new Error("不支持ellipse");
  }
  lineTo(x, y) {
    this.bounds.add(x, y);
  }
  moveTo(x, y) {
    this.bounds.add(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
  }
  rect(x, y, w, h) {
    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
  }
  clear() {
    this.bounds.clear();
  }
  release(...params2) {
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/curve/path.js
var CurvePath = class {
  constructor() {
    this._curves = [], this.bounds = new AABBBounds();
  }
  get curves() {
    return this._curves;
  }
  getCurveLengths() {
    return this._curves.map((curve) => curve.getLength());
  }
  getPointAt(t) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
};

// node_modules/@visactor/vrender-core/es/common/path-svg.js
var rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
var commandLengths = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7,
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7
};
var enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
var currPath;
var coordsStr;
var commandChar;
var coordStr;
var coordNumber;
var standardCommandLen;
function parseSvgPath(str) {
  if (!str) return [];
  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths) return [];
  let currCommandData, coordsStrArr;
  const result2 = [];
  for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
    for (let i2 = 0, len2 = coordsStrArr.length; i2 < len2; i2++) coordStr = coordsStrArr[i2], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
      let subCommand, bestCommandChar = commandChar;
      for (let i2 = 1, len2 = currCommandData.length; i2 < len2; i2 += standardCommandLen) {
        subCommand = [bestCommandChar];
        for (let j = i2, subLen = i2 + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
        result2.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
      }
    } else result2.push(currCommandData);
  } else result2.push(currCommandData);
  return result2;
}

// node_modules/@visactor/vrender-core/es/common/enums.js
var UpdateTag;
!function(UpdateTag2) {
  UpdateTag2[UpdateTag2.NONE = 0] = "NONE", UpdateTag2[UpdateTag2.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag2[UpdateTag2.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag2[UpdateTag2.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag2[UpdateTag2.INIT = 179] = "INIT", UpdateTag2[UpdateTag2.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag2[UpdateTag2.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function(IContainPointMode2) {
  IContainPointMode2[IContainPointMode2.GLOBAL = 1] = "GLOBAL", IContainPointMode2[IContainPointMode2.LOCAL = 16] = "LOCAL", IContainPointMode2[IContainPointMode2.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode2[IContainPointMode2.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function(AttributeUpdateType2) {
  AttributeUpdateType2[AttributeUpdateType2.INIT = 0] = "INIT", AttributeUpdateType2[AttributeUpdateType2.DEFAULT = 1] = "DEFAULT", AttributeUpdateType2[AttributeUpdateType2.STATE = 2] = "STATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType2[AttributeUpdateType2.SCALE = 22] = "SCALE", AttributeUpdateType2[AttributeUpdateType2.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType2[AttributeUpdateType2.ROTATE = 24] = "ROTATE", AttributeUpdateType2[AttributeUpdateType2.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var AnimateStatus;
!function(AnimateStatus2) {
  AnimateStatus2[AnimateStatus2.INITIAL = 0] = "INITIAL", AnimateStatus2[AnimateStatus2.RUNNING = 1] = "RUNNING", AnimateStatus2[AnimateStatus2.PAUSED = 2] = "PAUSED", AnimateStatus2[AnimateStatus2.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));
var AnimateMode;
!function(AnimateMode2) {
  AnimateMode2[AnimateMode2.NORMAL = 0] = "NORMAL", AnimateMode2[AnimateMode2.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));
var AnimateStepType;
!function(AnimateStepType2) {
  AnimateStepType2.wait = "wait", AnimateStepType2.from = "from", AnimateStepType2.to = "to", AnimateStepType2.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var Direction;
!function(Direction3) {
  Direction3[Direction3.ROW = 1] = "ROW", Direction3[Direction3.COLUMN = 2] = "COLUMN";
}(Direction || (Direction = {}));
var CurveTypeEnum;
!function(CurveTypeEnum2) {
  CurveTypeEnum2[CurveTypeEnum2.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum2[CurveTypeEnum2.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum2[CurveTypeEnum2.ArcCurve = 2] = "ArcCurve", CurveTypeEnum2[CurveTypeEnum2.LineCurve = 3] = "LineCurve", CurveTypeEnum2[CurveTypeEnum2.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum2[CurveTypeEnum2.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function(BaseRenderContributionTime2) {
  BaseRenderContributionTime2[BaseRenderContributionTime2.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime2[BaseRenderContributionTime2.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

// node_modules/@visactor/vrender-core/es/common/shape/arc.js
function segments(x, y, rx, ry, large, sweep, rotateX2, ox, oy) {
  const th = degreeToRadian(rotateX2), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5, py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x0 = a00 * ox + a01 * oy, y0 = a10 * ox + a11 * oy, x1 = a00 * x + a01 * y, y1 = a10 * x + a11 * y;
  let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - 0.25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0), yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0), th0 = Math.atan2(y0 - yc, x0 - xc);
  let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi + 1e-3))), result2 = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs, th3 = th0 + (i + 1) * th_arc / segs;
    result2[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result2;
}
function bezier(params2) {
  const cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = 0.5 * (th1 - th0), sin_th_h2 = Math.sin(0.5 * th_half), t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x1 = cx + cos_th0 - t * sin_th0, y1 = cy + sin_th0 + t * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x2 = x3 + t * sin_th1, y2 = y3 - t * cos_th1;
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
  const delta = Math.abs(endAngle - startAngle), count = delta > 0.5 * Math.PI ? Math.ceil(2 * delta / Math.PI) : 1, stepAngle = (endAngle - startAngle) / count;
  for (let i = 0; i < count; i++) {
    const sa = startAngle + stepAngle * i, ea = startAngle + stepAngle * (i + 1), len = 4 * Math.tan(Math.abs(stepAngle) / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c22 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c22, x4, y4);
  }
};

// node_modules/@visactor/vrender-core/es/common/render-command-list.js
var commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
  for (let i = 0; i < commandList.length; i++) {
    const command = commandList[i];
    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
  }
}

// node_modules/@visactor/vrender-core/es/common/segment/curve/base.js
var Curve = class {
  getLength(direction) {
    return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
};

// node_modules/@visactor/vrender-core/es/common/bezier-utils.js
function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i = 0; i < count; i++) {
    const x = xArr[i], y = yArr[i], nextX = xArr[(i + 1) % count], nextY = yArr[(i + 1) % count];
    totalLength += PointService.distanceNN(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
  const one = 1 - t;
  return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t), y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
  return new Point(x, y);
}
function quadCalc(p0, p1, p2, t) {
  const one = 1 - t;
  return one * one * p0 + 2 * one * t * p1 + t * t * p2;
}
function quadPointAt(p0, p1, p2, t) {
  const x = quadCalc(p0.x, p1.x, p2.x, t), y = quadCalc(p0.y, p1.y, p2.y, t);
  return new Point(x, y);
}
function quadLength(p0, p1, p2, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
}

// node_modules/@visactor/vrender-core/es/common/segment/curve/quadratic-bezier.js
var QuadraticBezierCurve = class extends Curve {
  constructor(p0, p1, p2) {
    super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
  }
  getPointAt(t) {
    if (false !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? quadLength(this.p0, this.p1, this.p2, 0) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - 0.01, 0), maxT = min(t + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);
    else if (percent > 0) {
      const [curve1] = divideQuad(this, percent);
      path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
    }
  }
  getYAt(x) {
    throw new Error("QuadraticBezierCurve暂不支持getYAt");
  }
  includeX(x) {
    throw new Error("QuadraticBezierCurve暂不支持includeX");
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/curve/cubic-bezier.js
function divideCubic(curve, t) {
  const { p0, p1, p2, p3 } = curve, pt = cubicPointAt(p0, p1, p2, p3, t), c1 = PointService.pointAtPP(p0, p1, t), c22 = PointService.pointAtPP(p1, p2, t), c3 = PointService.pointAtPP(p2, p3, t), c12 = PointService.pointAtPP(c1, c22, t), c23 = PointService.pointAtPP(c22, c3, t);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
}
function divideQuad(curve, t) {
  const { p0, p1, p2 } = curve, pt = quadPointAt(p0, p1, p2, t), c1 = PointService.pointAtPP(p0, p1, t), c22 = PointService.pointAtPP(p1, p2, t);
  return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c22, p2)];
}
var CubicBezierCurve = class extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t) {
    if (false !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3, 0) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - 0.01, 0), maxT = min(t + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);
    else if (percent > 0) {
      const [curve1] = divideCubic(this, percent);
      path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
    }
  }
  includeX(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x), maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
    return x >= minX && x <= maxX;
  }
  getYAt(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x), t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
    return this.getPointAt(t).y;
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/curve/line.js
function divideLinear(curve, t) {
  const { p0, p1 } = curve, c1 = PointService.pointAtPP(p0, p1, t);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
var LineCurve = class extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t) {
    if (false !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  getAngleAt(t) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);
    else if (percent > 0) {
      const p = this.getPointAt(percent);
      path.lineTo(p.x * sx + x, p.y * sy + y);
    }
  }
  includeX(x) {
    return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
  }
  getYAt(x) {
    if (this.includeX(x)) {
      let minP = this.p0, maxP = this.p1;
      this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
      const percent = (x - minP.x) / (maxP.x - minP.x);
      return minP.y + percent * (maxP.y - minP.y);
    }
    return 1 / 0;
  }
};

// node_modules/@visactor/vrender-core/es/common/seg-context.js
var SegContext = class {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction) {
    this.init(curveType, direction);
  }
  init(curveType, direction) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  closePath() {
    if (this.curves.length < 2) return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext不支持调用ellipse");
  }
  lineTo(x, y, defined, p) {
    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  moveTo(x, y, p) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    throw new Error("SegContext不支持调用quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction) {
    return this.getLength(direction);
  }
  addLinearCurve(x, y, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t) {
    throw new Error("暂未实现");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction) {
    var _a, _b;
    if (direction === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction === Direction.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c3) => l + c3.getLength(), 0)), this.length;
  }
};
var ReflectSegContext = class extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
  }
  lineTo(x, y, defined, p) {
    return super.lineTo(y, x, defined, p);
  }
  moveTo(x, y, p) {
    return super.moveTo(y, x, p);
  }
  clear() {
    return super.clear();
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/common.js
function genCurveSegments(path, points, step = 1) {
  let defined0 = false;
  for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
}
function genSegContext(curveType, direction, points) {
  const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

// node_modules/@visactor/vrender-core/es/common/segment/linear.js
var Linear = class {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
    }
    this._lastDefined = p.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genLinearSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vrender-core/es/common/segment/basis.js
function point(curveClass, x, y, defined, p) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
var Basis = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point) point(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("basis", direction, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vrender-core/es/common/segment/monotone.js
function sign(x) {
  return x < 0 ? -1 : 1;
}
function slope3(curveClass, x2, y2) {
  const h0 = curveClass._x1 - curveClass._x0, h1 = x2 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
  const h = curveClass._x1 - curveClass._x0;
  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}
function point2(curveClass, t0, t1, defined, p) {
  const x0 = curveClass._x0, y0 = curveClass._y0, x1 = curveClass._x1, y1 = curveClass._y1, dx = (x1 - x0) / 3;
  curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
}
var MonotoneX = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point2(this, this._t0, slope2(this, this._t0), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    let t1 = NaN;
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point2(this, slope2(this, t1 = slope3(this, x, y)), t1, false !== this._lastDefined1 && false !== this._lastDefined2, p);
        break;
      default:
        point2(this, this._t0, t1 = slope3(this, x, y), false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = false !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var MonotoneY = class extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p) {
    return super.point({
      y: p.x,
      x: p.y,
      defined: p.defined
    });
  }
};
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneX", direction, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneY", direction, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vrender-core/es/common/segment/step.js
var Step = class {
  constructor(context, t = 0.5, startPoint) {
    this.context = context, this._t = t, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, false !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0) this.context.lineTo(this._x, y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
        else {
          const x1 = this._x * (1 - this._t) + x * this._t;
          0.5 === this._t ? this.context.lineTo(x1, this._y, false !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x1, y, false !== this._lastDefined && false !== p.defined, p);
        }
    }
    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var StepClosed = class extends Step {
  lineEnd() {
    this.context.closePath();
  }
};
function genStepSegments(points, t, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}
function genStepClosedSegments(points, t, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
}

// node_modules/@visactor/vrender-core/es/common/segment/linear-closed.js
var LinearClosed = class extends Linear {
  lineEnd() {
    this.context.closePath();
  }
};
function genLinearClosedSegments(points, params2 = {}) {
  const { direction, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vrender-core/es/common/segment/catmull-rom.js
function point3(curveClass, x, y, defined, p) {
  let x1 = curveClass._x1, y1 = curveClass._y1, x2 = curveClass._x2, y2 = curveClass._y2;
  if (curveClass._l01_a > epsilon) {
    const a3 = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a, n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
    x1 = (x1 * a3 - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a3 - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
  }
  if (curveClass._l23_a > epsilon) {
    const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a, m4 = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
    x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m4, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m4;
  }
  curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
}
var CatmullRom = class {
  constructor(context, alpha = 0.5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x2, this._y2, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2
        });
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const { x, y } = p;
    if (this._point) {
      const x23 = this._x2 - x, y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2) : this.context.moveTo(x, y);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function commonGenCatmullRomSegments(type, cons) {
  return function(points, alpha, params2 = {}) {
    const { direction, startPoint } = params2;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
    const segContext = genSegContext(type, direction, points), gatmullRom = new cons(segContext, alpha, startPoint);
    return genCurveSegments(gatmullRom, points, 2), segContext;
  };
}
var genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

// node_modules/@visactor/vrender-core/es/common/segment/catmull-rom-close.js
var CatmullRomClosed = class {
  constructor(context, alpha = 0.5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
        break;
      case 2:
        this.context.lineTo(this._x3, this._y3, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1), this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3
        }), this.point({
          x: this._x4,
          y: this._y4
        }), this.point({
          x: this._x5,
          y: this._y5
        });
    }
  }
  point(p) {
    const { x, y } = p;
    if (this._point) {
      const x23 = this._x2 - x, y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = x, this._y3 = y;
        break;
      case 1:
        this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
        break;
      case 2:
        this._point = 3, this._x5 = x, this._y5 = y;
        break;
      default:
        point3(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

// node_modules/@visactor/vrender-core/es/common/segment/curve/curve-context.js
var CurveContext = class {
  constructor(path) {
    this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
  }
  moveTo(x, y) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
  }
  lineTo(x, y) {
    const curve = this.addLinearCurve(x, y);
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  addLinearCurve(x, y) {
    return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
    this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    throw new Error("CurveContext不支持调用arcTo");
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    throw new Error("CurveContext不支持调用ellipse");
  }
  rect(x, y, w, h) {
    throw new Error("CurveContext不支持调用rect");
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    throw new Error("CurveContext不支持调用arc");
  }
  closePath() {
    this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/index.js
function calcLineCache(points, curveType, params2) {
  var _a, _b;
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepClosed":
      return genStepClosedSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "catmullRom":
      return genCatmullRomSegments(points, null !== (_a = null == params2 ? void 0 : params2.curveTension) && void 0 !== _a ? _a : 0.5, params2);
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(points, null !== (_b = null == params2 ? void 0 : params2.curveTension) && void 0 !== _b ? _b : 0.5, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}

// node_modules/@visactor/vrender-core/es/common/custom-path2d.js
var CustomPath2D = class extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  get curves() {
    return this.tryBuildCurves();
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x, y) {
    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
  }
  lineTo(x, y) {
    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x, y, w, h) {
    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this._curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
  }
  beginPath() {
    this.clear();
  }
  tryBuildCurves() {
    if (!this._curves || !this._curves.length) {
      const curveContext = new CurveContext(this);
      renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
    }
    return this._curves;
  }
  toString() {
    if (!this.toStringCbList) {
      const list2 = [];
      list2[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list2[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list2[enumCommandMap.A] = (cmd) => {
        const bezierPathList = [];
        addArcToBezierPath(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
        let path2 = "";
        for (let i = 0; i < bezierPathList.length; i += 6) path2 += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
        return path2;
      }, list2[enumCommandMap.R] = (cmd) => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list2[enumCommandMap.Z] = (cmd) => "Z", this.toStringCbList = list2;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach((c3) => {
      path += list[c3[0]](c3);
    }), path;
  }
  fromString(str, x, y, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str);
    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
  }
  fromLine(line2) {
    const { points, curveType, clipRangeByDimension } = line2.attribute;
    if (!points) return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
  }
  fromCustomPath2D(path, x, y, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
  }
  transform(x, y, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach((cmd) => {
      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  lineToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  quadraticCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
  }
  bezierCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
  }
  arcToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {
  }
  _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
    let current, tempX, tempY, tempControlX, tempControlY, previous = null, x = 0, y = 0, controlX = 0, controlY = 0;
    for (let i = 0, len = commandStrList.length; i < len; ++i) {
      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale2(current, sX, sY)), current[0]) {
        case "l":
          x += current[1], y += current[2], this.lineTo(x + l, y + t);
          break;
        case "L":
          x = current[1], y = current[2], this.lineTo(x + l, y + t);
          break;
        case "h":
          x += current[1], this.lineTo(x + l, y + t);
          break;
        case "H":
          x = current[1], this.lineTo(x + l, y + t);
          break;
        case "v":
          y += current[1], this.lineTo(x + l, y + t);
          break;
        case "V":
          y = current[1], this.lineTo(x + l, y + t);
          break;
        case "m":
          x += current[1], y += current[2], this.moveTo(x + l, y + t);
          break;
        case "M":
          x = current[1], y = current[2], this.moveTo(x + l, y + t);
          break;
        case "c":
          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "C":
          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
          break;
        case "s":
          tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "q":
          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "a":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
          break;
        case "A":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
      const current = commandList[i].slice();
      switch (current[0]) {
        case enumCommandMap.L:
          this.lineToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.M:
          this.moveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.C:
          this.bezierCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Q:
          this.quadraticCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.A:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.E:
          this.ellipseTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.R:
          this.rectTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.AT:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Z:
          this.closePath();
      }
    }
    else this.commandList = commandList.map((entry) => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0], ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0], ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this._curves.reduce((l, c3) => l + c3.getLength(), 0);
  }
  getYAt(x) {
    if (!this.curves) return 1 / 0;
    for (let i = 0; i < this.curves.length; i++) {
      const curve = this.curves[i];
      if (curve.includeX(x)) return curve.getYAt(x);
    }
    return 1 / 0;
  }
  getAttrAt(distance2) {
    if (!this._curves) return {
      pos: {
        x: 0,
        y: 0
      },
      angle: 0
    };
    let curve, _dis = 0;
    for (let i = 0; i < this._curves.length; i++) {
      curve = this._curves[i];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance2) break;
      _dis += cl;
    }
    const t = (distance2 - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t),
      angle: curve.getAngleAt(t)
    };
  }
  drawWithClipRange(ctx, size, x, y, clipRange) {
    this.tryBuildCurves();
    const totalLen = this.getLength() * clipRange;
    let currLen = 0;
    for (let i = 0; i < this._curves.length; i++) {
      const curve = this._curves[i], cl = curve.getLength(this.direction);
      if (!(currLen + cl <= totalLen)) {
        const percent = 1 - (currLen + cl - totalLen) / cl;
        curve.draw(ctx, x, y, size, size, percent);
        break;
      }
      curve.draw(ctx, x, y, size, size, 1), currLen += cl;
    }
  }
};
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale2(current, sX, sY) {
  const c3 = temp[0] = current[0];
  if ("a" === c3 || "A" === c3) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];
  else if ("h" === c3 || "H" === c3) temp[1] = sX * current[1];
  else if ("v" === c3 || "V" === c3) temp[1] = sY * current[1];
  else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
  return temp;
}

// node_modules/@visactor/vrender-core/es/graphic/config.js
var DefaultLayout = {
  alignSelf: "auto"
};
var DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
var DefaultFillStyle = {
  fillOpacity: 1,
  fill: false,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: false
};
var DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
var DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  maxWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "…",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: false,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: false,
  verticalMode: 0,
  wrap: false,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  underlineDash: [],
  underlineOffset: 0,
  disableAutoClipedPoptip: void 0,
  measureMode: MeasureModeEnum.fontBounding,
  keepCenterInLine: false
};
var DefaultPickStyle = {
  pickStrokeBuffer: 0
};
var DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  forceBoundsWidth: void 0,
  forceBoundsHeight: void 0,
  opacity: 1,
  background: null,
  autoAnimateTexture: false,
  textureRatio: 1,
  textureOptions: null,
  backgroundOpacity: 1,
  backgroundCornerRadius: 0,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: true,
  backgroundKeepAspectRatio: false,
  backgroundClip: true,
  backgroundScale: 1,
  backgroundOffsetX: 0,
  backgroundOffsetY: 0,
  blur: 0,
  filter: "",
  cursor: null,
  html: null,
  react: null,
  vue: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
var DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
var DefaultDebugAttribute = {
  _debug_bounds: false
};
var DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  renderable: true,
  pickable: true,
  shadowGraphic: void 0,
  childrenPickable: true,
  fillPickable: true,
  strokePickable: true,
  visible: true,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  fillStrokeOrder: 0,
  renderStyle: "default",
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: true,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden",
  shadowPickMode: "graphic",
  keepStrokeScale: false,
  clipConfig: null
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
var DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  innerPadding: 0,
  outerPadding: 0,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: false,
  forceShowCap: false
});
var DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: false,
  curveTension: 1
});
var DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
var DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: false,
  visibleAll: true,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start",
  baseOpacity: 1,
  cornerType: "round"
});
var DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: false
});
var DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: false,
  curveTension: 1
});
var DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  fillStrokeOrder: 1,
  clipRange: 1,
  customPath: () => {
    Logger.getInstance().warn("空函数");
  }
});
var DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: true
});
var DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 100,
  height: 100,
  spikes: 5,
  thickness: 0.5
});
var DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0,
  cornerType: "round"
});
var DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
  cornerType: "round"
});
var DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: true,
  clipRange: 1
});
var DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: true
});
var DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  upgradeAttrs: null,
  editable: false,
  editOptions: null,
  ascentDescentMode: "actual",
  width: 300,
  height: 300,
  ellipsis: true,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  disableAutoWrapLine: false,
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: false
});
var DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0,
  maxWidth: 500,
  maxHeight: 500
}, DefaultAttribute), {
  fill: true,
  cornerRadius: 0,
  cornerType: "round"
});
var DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: false,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

// node_modules/@visactor/vrender-core/es/application.js
var Application = class {
};
var application = new Application();

// node_modules/@visactor/vrender-core/es/common/color-utils.js
var parse = /* @__PURE__ */ function() {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error3(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error3("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function(pattern2, callback) {
      const captures = scan(pattern2);
      if (captures) {
        scan(tokens.startCall) || error3("Missing (");
        const result2 = callback(captures);
        return scan(tokens.endCall) || error3("Missing )"), result2;
      }
    }(pattern, function(captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error3("Missing comma before color stops")), {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations, lookaheadCache, radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function() {
      const circle3 = match("shape", /^(circle)/i, 0);
      circle3 && (circle3.style = matchLength() || matchExtentKeyword());
      return circle3;
    }() || function() {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType) radialType.at = matchAtPosition();
    else {
      const extent4 = matchExtentKeyword();
      if (extent4) {
        radialType = extent4;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error3("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y) return {
      type: "position",
      value: location
    };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result2 = [];
    if (captures) for (result2.push(captures); scan(tokens.comma); ) captures = matcher(), captures ? result2.push(captures) : error3("One extra comma");
    return result2;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error3("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) return {
      type,
      value: captures[captureIndex]
    };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    return input = code.toString(), getAST();
  };
}();
var GradientParser = class _GradientParser {
  static IsGradient(c3) {
    return !("string" == typeof c3 && !c3.includes("gradient"));
  }
  static IsGradientStr(c3) {
    return "string" == typeof c3 && c3.includes("gradient");
  }
  static Parse(c3) {
    if (_GradientParser.IsGradientStr(c3)) try {
      const datum = parse(c3)[0];
      if (datum) {
        if ("linear" === datum.type) return _GradientParser.ParseLinear(datum);
        if ("radial" === datum.type) return _GradientParser.ParseRadial(datum);
        if ("conic" === datum.type) return _GradientParser.ParseConic(datum);
      }
    } catch (err) {
      return c3;
    }
    return c3;
  }
  static ParseConic(datum) {
    const { orientation, colorStops = [] } = datum, halfPi3 = pi / 2, sa = parseFloat(orientation.value) / 180 * pi - halfPi3;
    return {
      gradient: "conical",
      x: 0.5,
      y: 0.5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseRadial(datum) {
    const { colorStops = [] } = datum;
    return {
      gradient: "radial",
      x0: 0.5,
      y0: 0.5,
      x1: 0.5,
      y1: 0.5,
      r0: 0,
      r1: 1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseLinear(datum) {
    const { orientation, colorStops = [] } = datum, halfPi3 = pi / 2;
    let angle2 = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle2 < 0; ) angle2 += pi2;
    for (; angle2 >= pi2; ) angle2 -= pi2;
    let x0 = 0, y0 = 0, x1 = 0, y1 = 0;
    return angle2 < halfPi3 ? (x0 = 0, y0 = 1, x1 = Math.sin(angle2), y1 = y0 - Math.cos(angle2)) : angle2 < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle2 - halfPi3), y1 = Math.sin(angle2 - halfPi3)) : angle2 < pi + halfPi3 ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle2 - pi), y1 = Math.cos(angle2 - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle2 - halfPi3 - pi), y1 -= Math.sin(angle2 - halfPi3 - pi)), {
      gradient: "linear",
      x0,
      y0,
      x1,
      y1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
};

// node_modules/@visactor/vrender-core/es/common/canvas-utils.js
function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const { a: a3, b, c: c3, d } = context.currentMatrix, scaleX = Math.sign(a3) * Math.sqrt(a3 * a3 + b * b), scaleY = Math.sign(d) * Math.sqrt(c3 * c3 + d * d);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c3, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d;
  if (!c3 || true === c3) return "black";
  let result2, color;
  if (isArray_default(c3)) for (let i = 0; i < c3.length && (color = c3[i], !color); i++) ;
  else color = c3;
  if (color = GradientParser.Parse(color), "string" == typeof color) return color;
  if (params2.AABBBounds && (!params2.attribute || 0 !== params2.attribute.scaleX || 0 !== params2.attribute.scaleY)) {
    const bounds = params2.AABBBounds;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params2.attribute) {
      const { scaleX = 1, scaleY = 1, angle: angle2 = 0 } = params2.attribute;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle2 || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params2.x1WithoutTransform) && void 0 !== _a ? _a : 0, y = null !== (_b = params2.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params2.widthWithoutTransform) && void 0 !== _c ? _c : w, h = null !== (_d = params2.heightWithoutTransform) && void 0 !== _d ? _d : h);
    }
    "linear" === color.gradient ? result2 = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result2 = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result2 = createRadialGradient(context, color, x, y, w, h));
  }
  return result2 || "orange";
}
function createLinearGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d;
  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d, _e, _f;
  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0.5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0.5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : 0.5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : 0.5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : 0.5));
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, x, y, w, h) {
  var _a, _b;
  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, void 0) : canvasGradient;
}

// node_modules/@visactor/vrender-core/es/graphic/richtext/utils.js
var DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
var defaultFormatting = {
  fontSize: 16,
  fontFamily: DEFAULT_TEXT_FONT_FAMILY,
  fill: true,
  stroke: false,
  fontWeight: "normal",
  lineHeight: "normal",
  fontStyle: "normal",
  textDecoration: "none",
  textAlign: "left",
  script: "normal"
};
var nbsp = String.fromCharCode(160);
var regLetter = /\w|\(|\)|-/;
var regPunctuation = /[.?!,;:/，。？！、；：]/;
var regFirstSpace = /\S/;
var setTextStyle = (ctx, character) => {
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily
  });
};
function applyFillStyle(ctx, character, b) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle) return void (ctx.globalAlpha = 0);
  const { fillOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
    AABBBounds: b
  }) : fillStyle, setTextStyle(ctx, character);
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle) return void (ctx.globalAlpha = 0);
  const { strokeOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (desc.length <= 1) return 0;
  if (!width || width <= 0) return 0;
  const textMeasure = application.graphicUtil.textMeasure;
  let index = guessIndex, temp2 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp2, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width; ) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp2 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp2, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function testLetter(string, index, negativeWrongMatch = false) {
  let i = index;
  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
  return i;
}
function testLetter2(string, index) {
  let i = index;
  for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i++, i >= string.length) return i;
  return i + 1;
}
function measureTextCanvas(text2, character, mode = "actual") {
  var _a;
  if ("" === text2) return {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  };
  const measurement = application.graphicUtil.textMeasure.measureText(text2, character), result2 = {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  }, ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent, descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
  "number" != typeof ascent || "number" != typeof descent ? (result2.width = Math.floor(measurement.width), result2.height = character.fontSize || 0, result2.ascent = result2.height, result2.descent = 0) : (result2.width = Math.floor(measurement.width), result2.height = Math.floor(ascent + descent), result2.ascent = Math.floor(ascent), result2.descent = result2.height - result2.ascent);
  const space = null !== (_a = character.space) && void 0 !== _a ? _a : 0;
  return result2.width += space, result2;
}

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/AtextMeasure.js
var __decorate2 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  _measureTextWithoutAlignBaseline(text2, options, compatible) {
    this.context.setTextStyleWithoutAlignBaseline(options);
    const metrics = this.context.measureText(text2);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  _measureTextWithAlignBaseline(text2, options, compatible) {
    this.context.setTextStyle(options);
    const metrics = this.context.measureText(text2);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  compatibleMetrics(metrics, options) {
    if (null == metrics.actualBoundingBoxAscent || null == metrics.actualBoundingBoxDescent || null == metrics.fontBoundingBoxAscent || null == metrics.fontBoundingBoxDescent) {
      metrics = {
        width: metrics.width
      };
      const { ascent, descent } = this.measureTextBoundADscentEstimate(options);
      metrics.actualBoundingBoxAscent = ascent, metrics.actualBoundingBoxDescent = descent, metrics.fontBoundingBoxAscent = ascent, metrics.fontBoundingBoxDescent = descent;
    }
    if (null == metrics.actualBoundingBoxLeft || null == metrics.actualBoundingBoxRight) {
      metrics = {
        width: metrics.width,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
      const { left: left2, right: right2 } = this.measureTextBoundLeftRightEstimate(options);
      metrics.actualBoundingBoxLeft = left2, metrics.actualBoundingBoxRight = right2;
    }
    return metrics;
  }
  estimate(text2, { fontSize = DefaultTextAttribute.fontSize }) {
    let eCharLen = 0, cCharLen = 0;
    for (let i = 0; i < text2.length; i++) text2.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextWidth(text2, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text2, options)).width : this.estimate(text2, options).width;
  }
  measureTextBoundsWidth(text2, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text2, options)).width : this.estimate(text2, options).width;
  }
  measureTextBoundsLeftRight(text2, options, textMeasure) {
    return this.context ? {
      left: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text2, options, true)).actualBoundingBoxLeft,
      right: textMeasure.actualBoundingBoxRight
    } : this.measureTextBoundLeftRightEstimate(options);
  }
  measureTextPixelHeight(text2, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text2, options, true), Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextPixelADscent(text2, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text2, options, true)).actualBoundingBoxAscent,
      descent: textMeasure.actualBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundHieght(text2, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text2, options, true), Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextBoundADscent(text2, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text2, options, true)).fontBoundingBoxAscent,
      descent: textMeasure.fontBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundADscentEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    return {
      ascent: 0.79 * fontSize,
      descent: 0.21 * fontSize
    };
  }
  measureTextBoundLeftRightEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize, { textAlign } = options;
    return "center" === textAlign ? {
      left: fontSize / 2,
      right: fontSize / 2
    } : "right" === textAlign || "end" === textAlign ? {
      left: fontSize,
      right: 0
    } : {
      left: 0,
      right: fontSize
    };
  }
  measureTextPixelADscentAndWidth(text2, options, mode) {
    if (!this.context) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: this.estimate(text2, options).width
    });
    const out = this._measureTextWithoutAlignBaseline(text2, options, true);
    if (mode === MeasureModeEnum.actualBounding) return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
    if (mode === MeasureModeEnum.estimate) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: out.width
    });
    if (mode === MeasureModeEnum.fontBounding) {
      let ascent = out.fontBoundingBoxAscent, descent = out.fontBoundingBoxDescent;
      if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
        const delta = out.actualBoundingBoxDescent - descent;
        descent += delta, ascent -= delta;
      } else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
        const delta = out.actualBoundingBoxAscent - ascent;
        ascent += delta, descent -= delta;
      }
      return {
        ascent,
        descent,
        width: out.width
      };
    }
    return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
  }
  measureText(text2, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text2)) : this.estimate(text2, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const { fontSize = 12 } = options;
    verticalList.forEach((item) => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length2 = 0, i = 0;
    for (; i < verticalList.length && length2 + verticalList[i].width < width; i++) length2 += verticalList[i].width, out.push(verticalList[i]);
    if (verticalList[i] && verticalList[i].text.length > 1) {
      const clipedData = this._clipText(verticalList[i].text, options, width - length2, 0, verticalList[i].text.length - 1, "end", false);
      if (wordBreak && clipedData.str !== verticalList[i].text) {
        let text2 = "", length3 = 0;
        for (let j = 0; j < i; j++) {
          const item = verticalList[j];
          text2 += item.text, length3 += item.text.length;
        }
        text2 += verticalList[i].text;
        const totalLength = length3 + clipedData.str.length;
        let index = testLetter(text2, totalLength);
        index -= length3, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i]), {
        text: clipedData.str,
        width: clipedData.width
      })), length2 += clipedData.width;
    }
    return {
      verticalList: out,
      width: length2
    };
  }
  clipText(text2, options, width, wordBreak, keepAllBreak) {
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    let length2 = this.measureTextWidth(text2, options);
    if (length2 <= width) return {
      str: text2,
      width: length2
    };
    if (length2 = this.measureTextWidth(text2[0], options), length2 > width) return {
      str: "",
      width: 0
    };
    const data = this._clipText(text2, options, width, 0, text2.length - 1, "end", false);
    if (wordBreak && data.str !== text2) {
      let index = testLetter(text2, data.str.length, keepAllBreak);
      index !== data.str.length && (index > data.str.length && (data.wordBreaked = index, index = data.str.length), data.str = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text2, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position) data = this._clipTextStart(text2, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);
    else if ("middle" === position) {
      const d = this._clipTextMiddle(text2, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d.width,
        result: d.left + suffix + d.right
      };
    } else data = this._clipTextEnd(text2, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text2, options, width, leftIdx, rightIdx) {
    if (leftIdx === rightIdx) {
      Logger.getInstance().warn(`【_clipTextEnd】不应该走到这里${text2}, ${leftIdx}, ${rightIdx}`);
      const subText2 = text2.substring(0, rightIdx + 1);
      return {
        str: subText2,
        width: this.measureTextWidth(subText2, options)
      };
    }
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text2.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text2.substring(0, middleIdx);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextEnd(text2, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text2.length - 1) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str = text2.substring(0, middleIdx + 2);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text2, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2), subText = text2.substring(middleIdx - 1, text2.length), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text2.substring(middleIdx, text2.length);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextStart(text2, options, width, middleIdx, text2.length);
    }
    if (strWidth < width) {
      if (middleIdx <= 0) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str = text2.substring(middleIdx - 2, text2.length);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text2, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text2, options, width, left2, right2, leftW, rightW, buffer) {
    const subLeftText = text2.substring(0, buffer), strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width) return {
      left: left2,
      right: right2,
      width: leftW + rightW
    };
    const subRightText = text2.substring(text2.length - buffer, text2.length), strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right: right2,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text2, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v = this.revertVerticalList(out.verticalList);
      v.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak), nextVerticalList = this.revertVerticalList(verticalList), rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach((v) => leftOut.verticalList.push(v)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
      text: suffix,
      direction: 1,
      width: suffixWidth
    });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map((l) => {
      const t = l.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l), {
        text: t
      });
    });
  }
  clipTextWithSuffix(text2, options, width, suffix, wordBreak, position, forceSuffix = false) {
    if ("" === suffix) return this.clipText(text2, options, width, wordBreak);
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    const length2 = this.measureTextWidth(text2, options);
    if (!forceSuffix && length2 <= width) return {
      str: text2,
      width: length2
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    if (forceSuffix && length2 + suffixWidth <= width) return {
      str: text2 + suffix,
      width: length2 + suffixWidth
    };
    width -= suffixWidth;
    const data = this._clipText(text2, options, width, 0, text2.length - 1, position, suffix);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.result = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    } else forceSuffix && data.str === text2 && (data.result = text2 + suffix);
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate2([injectable()], ATextMeasure);

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/textMeasure-contribution.js
var __decorate3 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TextMeasureContribution = Symbol.for("TextMeasureContribution");
var DefaultTextMeasureContribution = class extends ATextMeasure {
};
DefaultTextMeasureContribution = __decorate3([injectable()], DefaultTextMeasureContribution);

// node_modules/@visactor/vrender-core/es/container.js
var container = new Container();

// node_modules/@visactor/vrender-core/es/canvas/constants.js
var CanvasFactory = Symbol.for("CanvasFactory");
var Context2dFactory = Symbol.for("Context2dFactory");

// node_modules/@visactor/vrender-core/es/canvas/util.js
function wrapCanvas(params2) {
  return container.getNamed(CanvasFactory, application.global.env)(params2);
}
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = Math.sqrt(3);
var ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
var _v0 = [0, 0];
var _v1 = [0, 0];
var _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a3 = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c3 = p0 - val;
  let n = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero(b)) {
      const t1 = -c3 / b;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a3), t2 = (-b - discSqrt) / (2 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? 0.5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  let t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d && (t = _t, d = d1);
  }
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
    const prev = t - interval, next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) t = prev, d = d1;
    else {
      _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distanceSquare(_v2, _v0);
      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5;
    }
  }
  return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  let prev, next, d1, d2, t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5);
  return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
}
function normalizeRadian(angle2) {
  return (angle2 %= pi2) < 0 && (angle2 += pi2), angle2;
}
function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return false;
  return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}
function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return false;
  return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  x -= cx, y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) return false;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return true;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle2 = Math.atan2(y, x);
  return angle2 < 0 && (angle2 += pi2), angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle;
}
function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (0 === lineWidth) return false;
  const _l = lineWidth, _halfL = lineWidth / 2;
  let _a = 0, _b = x0;
  if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return false;
  if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
  _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  const tmp = _a * x - y + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
var EPSILON = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a3 = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c3 = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a3 * c3, B = b * c3 - 9 * a3 * d, C = c3 * c3 - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) if (isAroundZero(b)) roots2[0] = 0;
  else {
    const t1 = -c3 / b;
    t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
  }
  else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A, t1 = -b / a3 + K, t2 = -K / 2;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y1 = A * b + 1.5 * a3 * (-B + discSqrt), Y2 = A * b + 1.5 * a3 * (-B - discSqrt);
      Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
      const t1 = (-b - (Y1 + Y2)) / (3 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else {
      const T = (2 * A * b - 3 * a3 * B) / (2 * Math.sqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = Math.sqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a3), t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a3), t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2), t3 >= 0 && t3 <= 1 && (roots2[n++] = t3);
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b = 6 * p2 - 12 * p1 + 6 * p0, a3 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c3 = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero(b)) {
      const t1 = -c3 / b;
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc)) extrema2[0] = -b / (2 * a3);
    else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a3), t2 = (-b - discSqrt) / (2 * a3);
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema2[n++] = t2);
    }
  }
  return n;
}
function isAroundEqual(a3, b) {
  return Math.abs(a3 - b) < EPSILON;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (0 === nRoots) return 0;
  let w = 0, nExtrema = -1, y0_ = 0, y1_ = 0;
  for (let i = 0; i < nRoots; i++) {
    const t = roots[i], unit = 0 === t || 1 === t ? 0.5 : 1;
    cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
  }
  return w;
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (0 === nRoots) return 0;
  const t = quadraticExtremum(y0, y1, y2);
  if (t >= 0 && t <= 1) {
    let w = 0;
    const y_ = quadraticAt(y0, y1, y2, t);
    for (let i = 0; i < nRoots; i++) {
      const unit2 = 0 === roots[i] || 1 === roots[i] ? 0.5 : 1;
      quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit2 : -unit2 : w += y2 < y_ ? unit2 : -unit2);
    }
    return w;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? 0.5 : 1;
  return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  if ((y -= cy) > r || y < -r) return 0;
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle, endAngle = tmp2;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle2 = Math.atan2(y, x_), dir = anticlockwise ? 1 : -1;
      angle2 < 0 && (angle2 = pi2 + angle2), (angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle) && (angle2 > pi / 2 && angle2 < 1.5 * pi && (dir = -dir), w += dir);
    }
  }
  return w;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modpi2(angles[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
}
var tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
  const data = commands, len = commands.length;
  let x1, y1, w = 0, xi = 0, yi = 0, x0 = 0, y0 = 0;
  for (let i = 0; i < len; i++) {
    const command = data[i], isFirst = 0 === i;
    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += isPointInLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
    const c0 = command[0], c1 = command[1], c22 = command[2], c3 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];
    let startAngle = c4, endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x - c1) * c3 / c3 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x0 = c1, y0 = c22, xi = x0, yi = y0;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c22, lineWidth, x, y)) return true;
        } else w += isPointInLine(xi, yi, c1, c22, x, y) || 0;
        xi = c1, yi = c22;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c22, c3, c4, c5, c6, lineWidth, x, y)) return true;
        } else w += windingCubic(xi, yi, c1, c22, c3, c4, c5, c6, x, y) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c22, c3, c4, lineWidth, x, y)) return true;
        } else w += windingQuadratic(xi, yi, c1, c22, c3, c4, x, y) || 0;
        xi = c3, yi = c4;
        break;
      case enumCommandMap.A:
        if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c22, isFirst ? (x0 = x1, y0 = y1) : w += isPointInLine(xi, yi, x1, y1, x, y), isStroke) {
          if (containArcStroke(c1, c22, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return true;
        } else w += windingArc(c1, c22, c3, theta, theta + dTheta, anticlockwise, _x, y);
        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c22;
        break;
      case enumCommandMap.R:
        if (x0 = xi = c1, y0 = yi = c22, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
          if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return true;
        } else w += isPointInLine(x1, y0, x1, y1, x, y), w += isPointInLine(x0, y1, x0, y0, x, y);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return true;
        } else w += isPointInLine(xi, yi, x0, y0, x, y);
        xi = x0, yi = y0;
    }
  }
  return isStroke || isAroundEqual(yi, y0) || (w += isPointInLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
}
function contain(commands, x, y) {
  return containPath(commands, 0, false, x, y);
}
function containStroke(commands, lineWidth, x, y) {
  return containPath(commands, lineWidth, true, x, y);
}

// node_modules/@visactor/vrender-core/es/allocator/canvas-allocate.js
var DefaultCanvasAllocate = class {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c3 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c3), c3;
    }
    const m4 = this.pools.pop();
    return m4.resize(data.width, data.height), m4.dpr = data.dpr, m4;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
        width: canvas.width / canvas.dpr,
        height: canvas.height / canvas.dpr,
        dpr: canvas.dpr
      }, c3 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c3), c3;
    }
    const m4 = this.pools.pop();
    return m4.width = canvas.width, m4.height = canvas.height, m4;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var canvasAllocate = new DefaultCanvasAllocate();

// node_modules/@visactor/vrender-core/es/core/window.js
var __decorate4 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata2 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var VWindow = Symbol.for("VWindow");
var WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
var DefaultWindow = class {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this.active = () => {
      const global = this.global;
      if (!global.env || this.actived) return;
      container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = true;
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var _a;
    return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
  }
  set style(style) {
    this._handler.setStyle(style);
  }
  create(params2) {
    var _a, _b;
    this._handler.createWindow(params2);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, params2.viewBox ? this.setViewBox(params2.viewBox) : false !== params2.canvasControled ? this.setViewBox({
      x1: 0,
      y1: 0,
      x2: this._width,
      y2: this._height
    }) : this.setViewBox({
      x1: 0,
      y1: 0,
      x2: null !== (_a = params2.width) && void 0 !== _a ? _a : this._width,
      y2: null !== (_b = params2.height) && void 0 !== _b ? _b : this._height
    }), this.title = this._handler.getTitle(), this.resizable = true;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w, h) {
    return this._handler.resizeWindow(w, h);
  }
  configure() {
    throw new Error("暂不支持");
  }
  release() {
    return this.global.hooks.onSetEnv.unTap("window", this.active), this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  addEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._handler.dispatchEvent(event);
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(color) {
    this._handler.clearViewBox(color);
  }
  setViewBox(viewBox) {
    this._handler.setViewBox(viewBox);
  }
  setViewBoxTransform(a3, b, c3, d, e, f) {
    this._handler.setViewBoxTransform(a3, b, c3, d, e, f);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(x, y) {
    const vb = this._handler.getViewBox(), nextP = {
      x,
      y
    };
    return this._handler.getViewBoxTransform().transformPoint({
      x,
      y
    }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
  }
  hasSubView() {
    const viewBox = this._handler.getViewBox();
    return !(0 === viewBox.x1 && 0 === viewBox.y1 && isNumberClose(this.width, viewBox.width()) && isNumberClose(this.height, viewBox.height()));
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate4([injectable(), __metadata2("design:paramtypes", [])], DefaultWindow);

// node_modules/@visactor/vrender-core/es/core/graphic-utils.js
var __decorate5 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata3 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = false, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
      this.configured = false, this.configure(global, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global, env) {
    this.configured || (this.contributions.getContributions().forEach((contribution) => {
      contribution.configure(this, env);
    }), this.configured = true);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text2, tc, method = "native") {
    var _a;
    this.configure(this.global, this.global.env);
    const m4 = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text2, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m4, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer) return null;
    const window2 = container.get(VWindow), bounds = graphic.AABBBounds, width = bounds.width(), height = bounds.height(), x1 = -bounds.x1, y1 = -bounds.y1;
    window2.create({
      viewBox: {
        x1,
        y1,
        x2: bounds.x2,
        y2: bounds.y2
      },
      width,
      height,
      canvas,
      dpr: stage.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    });
    const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = true, stage.defaultLayer.getNativeHandler().drawTo(window2, [graphic], {
      transMatrix: window2.getViewBoxTransform(),
      viewBox: window2.getViewBox(),
      stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: true,
      updateBounds: false
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c3 = window2.getNativeHandler();
    return c3.nativeCanvas ? c3.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate5([injectable(), __param2(0, inject(ContributionProvider)), __param2(0, named(TextMeasureContribution)), __metadata3("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function(TransformMode2) {
  TransformMode2[TransformMode2.transform = 0] = "transform", TransformMode2[TransformMode2.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
var _matrix = new Matrix();
var DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x, y } = center2;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle2, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x, y } = center2;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle2), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.rotate(angle2);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center2) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center2) : this;
  }
  rotate(angle2, center2) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle2, center2) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate5([injectable(), __metadata3("design:paramtypes", [])], DefaultTransformUtil);

// node_modules/@visactor/vrender-core/es/graphic/theme.js
var defaultThemeObj = {
  arc: DefaultArcAttribute,
  area: DefaultAreaAttribute,
  circle: DefaultCircleAttribute,
  line: DefaultLineAttribute,
  path: DefaultPathAttribute,
  symbol: DefaultSymbolAttribute,
  text: DefaultTextAttribute,
  rect: DefaultRectAttribute,
  polygon: DefaultPolygonAttribute,
  star: DefaultStarAttribute,
  richtext: DefaultRichTextAttribute,
  richtextIcon: DefaultRichTextIconAttribute,
  image: DefaultImageAttribute,
  group: DefaultGroupAttribute,
  glyph: DefaultGlyphAttribute
};
var themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    star: Object.assign({}, defaultThemeObj.star),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t) {
  Object.keys(t).forEach((k2) => {
    out[k2] = t[k2];
  });
}
var globalThemeObj = newThemeObj();
var Theme = class {
  constructor() {
    this.initTheme(), this.dirty = false;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach((key) => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent; ) if ((group = group.parent).theme) return group;
    return null;
  }
  applyTheme(group, pt, force = false) {
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, true);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = false);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme, combinedTheme = this.combinedTheme;
    themeKeys.forEach((k2) => {
      const obj = Object.create(globalThemeObj[k2]);
      parentCombinedTheme && parentCombinedTheme[k2] && combine(obj, parentCombinedTheme[k2]), combinedTheme[k2] && combine(obj, combinedTheme[k2]), userTheme[k2] && combine(obj, userTheme[k2]), this.combinedTheme[k2] = obj;
    }), userTheme.common && themeKeys.forEach((k2) => {
      combine(this.combinedTheme[k2], userTheme.common);
    }), this.dirty = false;
  }
  setTheme(t, g) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t).forEach((k2) => {
      userTheme[k2] ? Object.assign(userTheme[k2], t[k2]) : userTheme[k2] = Object.assign({}, t[k2]);
    }) : userTheme = t, this.userTheme = userTheme, this.dirty = true, this.dirtyChildren(g);
  }
  resetTheme(t, g) {
    this.userTheme = t, this.dirty = true, this.dirtyChildren(g);
  }
  dirtyChildren(g) {
    g.forEachChildren((item) => {
      item.isContainer && (item.theme && (item.theme.dirty = true), this.dirtyChildren(item));
    });
  }
};
var globalTheme = new Theme();
function getTheme(graphic, theme2) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme2 ? (graphic.isContainer, theme2) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g;
  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
    for (; g && !g.theme; ) g = g.parent;
    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
  }
  return null;
}

// node_modules/@visactor/vrender-core/es/graphic/node-tree.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Node = class extends import_eventemitter3.default {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb, reverse = false) {
    if (reverse) {
      let child = this._lastChild, i = 0;
      for (; child; ) {
        if (cb(child, i++)) return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild, i = 0;
      for (; child; ) {
        if (cb(child, i++)) return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb, reverse = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (reverse) {
        let child = this._lastChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node, highPerformance = true) {
    if (this._uid === node._uid) return null;
    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = true, node;
  }
  appendChildArrHighPerformance(nodes, replace = false) {
    return console.error("暂不支持该函数"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx2) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx2 >= this.childrenCount) return this.appendChild(newNode);
    if (this === newNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx2) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;
    else {
      let child = this._firstChild;
      for (let i = 0; i < idx2; i++) {
        if (!child) return null;
        i > 0 && (child = child._next);
      }
      if (!child) return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx2) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx2]) {
      const node2 = this._nodeList[idx2];
      return this._nodeList.splice(idx2, 0, newNode), this.insertBefore(newNode, node2);
    }
    let node;
    this._nodeList[idx2] = newNode;
    for (let i = idx2 - 1; i >= 0 && (node = this._nodeList[i], !node); i--) ;
    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = true;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = false, data;
  }
  removeChild(child) {
    if (!this._idMap) return null;
    if (!this._idMap.has(child._uid)) return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx2 = this._nodeList.findIndex((n) => n === child);
      idx2 >= 0 && this._nodeList.splice(idx2, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = true, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(deep) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let child = this._firstChild;
    for (; child; ) {
      const next = child._next;
      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
    }
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = true, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("暂不支持");
  }
  find(callback, deep = false) {
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, true)), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const node = child.find(callback, true);
        if (node) return target = node, true;
      }
      return false;
    }), target;
  }
  findAll(callback, deep = false) {
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const targets = child.findAll(callback, true);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id) {
    return this.find((node) => node.id === id, true);
  }
  findChildById(id) {
    return this.getElementById(id);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll((node) => node.name === name, true);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll((node) => node.type === type, true);
  }
  getChildByName(name, deep = false) {
    return this.find((node) => node.name === name, deep);
  }
  getChildAt(idx2) {
    let c3 = this._firstChild;
    if (!c3) return null;
    for (let i = 0; i < idx2; i++) {
      if (!c3._next) return null;
      c3 = c3._next;
    }
    return c3;
  }
  at(idx2) {
    return this.getChildAt(idx2);
  }
  containNode(node) {
    if (!this._idMap) return false;
    if (this._idMap.has(node._uid)) return true;
    let child = this._firstChild;
    for (; child; ) {
      if (child.containNode(node)) return true;
      child = child._next;
    }
    return false;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent; ) parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child; ) nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent) return false;
    do {
      if (parent._uid === node._uid) return true;
      parent = parent.parent;
    } while (null !== parent);
    return false;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx2) {
    throw new Error("暂不支持");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent) do {
      parent._count += deltaCount, parent = parent.parent;
    } while (null !== parent);
  }
  clone() {
    throw new Error("暂不支持");
  }
  cloneTo(node) {
    throw new Error("暂不支持");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, once = isObject_default(options) && options.once, context = isFunction_default(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, context = isFunction_default(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent;
    const once = isObject_default(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject_default(options) ? (options.once = true, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: true
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event, ...args) {
    return super.emit(event.type, event, ...args), !event.defaultPrevented;
  }
  emit(event, data) {
    return this.dispatchEvent(event, data);
  }
  release() {
    this.removeAllListeners();
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/base-event.js
var FederatedEvent = class _FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = _FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
  }
  composedDetailPath() {
    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
  }
  _composedDetailPath(params2) {
    if (params2 && params2.graphic) {
      const g = params2.graphic;
      if (g.stage) {
        const path = g.stage.eventSystem.manager.propagationPath(g);
        this.detailPath.push(path), this._composedDetailPath(params2.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
    } catch (err) {
      this.nativeEvent.preventDefault && isFunction_default(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
    } catch (err) {
      this.nativeEvent.stopPropagation && isFunction_default(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = true;
  }
  initEvent() {
  }
  initUIEvent() {
  }
  clone() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/mouse-event.js
var FederatedMouseEvent = class extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = {
      x: 0,
      y: 0
    }, this.movement = {
      x: 0,
      y: 0
    }, this.offset = {
      x: 0,
      y: 0
    }, this.global = {
      x: 0,
      y: 0
    }, this.screen = {
      x: 0,
      y: 0
    };
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/pointer-event.js
var FederatedPointerEvent = class _FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
  }
  getCoalescedEvents() {
    return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedPointerEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/wheel-event.js
var FederatedWheelEvent = class _FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedWheelEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
};
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

// node_modules/@visactor/vrender-core/es/event/federated-event/custom-event.js
var CustomEvent = class extends FederatedEvent {
  constructor(eventName, object) {
    super(), this.type = eventName, this.detail = object;
  }
};

// node_modules/@visactor/vrender-core/es/event/constant.js
var WILDCARD = "*";

// node_modules/@visactor/vrender-core/es/event/util.js
var clock = "object" == typeof performance && performance.now ? performance : Date;

// node_modules/@visactor/vrender-core/es/event/event-manager.js
function isMouseLike(pointerType) {
  return "mouse" === pointerType || "pen" === pointerType;
}
var EventManager = class {
  constructor(root, config2) {
    this.dispatch = new import_eventemitter3.default(), this.cursorTarget = null, this.pauseNotify = false, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this.onPointerDown = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) this.dispatchEvent(e, "touchstart");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
    }, this.onPointerMove = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
        const outType = "mousemove" === from.type ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
        if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        const overType = "mousemove" === from.type ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);
        this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
        for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; ) overTargetAncestor = overTargetAncestor.parent;
        if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          let currentTarget = enterEvent.target;
          const outTargetAncestors = /* @__PURE__ */ new Set();
          let ancestor = outTarget;
          for (; ancestor && ancestor !== this.rootTarget; ) outTargetAncestors.add(ancestor), ancestor = ancestor.parent;
          for (; currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent; ) outTargetAncestors.has(currentTarget) || (enterEvent.currentTarget = currentTarget, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter")), currentTarget = currentTarget.parent;
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), isMouse && (this.dispatchEvent(e, "mousemove"), this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), this.freeEvent(e);
    }, this.onPointerOver = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType);
      this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
      const enterEvent = this.clonePointerEvent(e, "pointerenter");
      for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
      trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
    }, this.onPointerOut = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
        this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
      }
      this.cursorTarget = null, this.cursor = "";
    }, this.onPointerUp = (from, target) => {
      var _a;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const now = clock.now(), e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        for (; currentTarget && !e.composedPath().includes(currentTarget); ) {
          if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside");
          else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget, clickEvent.path = [], clickEvent.detailPath = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        });
        const clickHistory = trackingData.clicksByButton[from.button];
        clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && this._config.supportsTouchEvents && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
      }
      this.freeEvent(e);
    }, this.onPointerUpOutside = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from, from.type, target);
      if (pressTarget) {
        let currentTarget = pressTarget;
        for (; currentTarget; ) e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e);
    }, this.onWheel = (from, target) => {
      if (!(from instanceof FederatedWheelEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
      const wheelEvent = this.createWheelEvent(from, target);
      this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
    }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
      clickInterval: 200
    }, config2), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
  }
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn,
      priority: 0
    }), this.mappingTable[type].sort((a3, b) => a3.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false, e.propagationImmediatelyStopped = false, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.rootTarget) return;
    const mappers = this.mappingTable[e.type];
    let target;
    const cacheKey = `${e.canvasX}-${e.canvasY}`;
    if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = {
      [cacheKey]: target,
      stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
    })), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target);
    else Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
  }
  propagate(e, type) {
    if (!e.target) return;
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
      if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  notifyTarget(e, type) {
    if (this.pauseNotify) return;
    type = null != type ? type : e.type;
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) return null;
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), "string" == typeof type && (event.type = type), event;
  }
  createWheelEvent(from, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice();
    const p = from.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = null != type ? type : event.type, event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach((key) => {
      to[key].x = from[key].x, to[key].y = from[key].y;
    }));
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
  }
  trackingData(id) {
    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    var _a;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event;
  }
  freeEvent(event) {
    var _a;
    if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
      once: true
    }), listeners.fn.call(listeners.context, e);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
      once: true
    }), listeners[i].fn.call(listeners[i].context, e);
    this.emitDelegation(e, type);
  }
  emitDelegation(e, type) {
    const listeners = e.currentTarget._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
  }
  pickTarget(x, y, e) {
    let target;
    const pickResult = this.rootTarget.pick(x, y);
    return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
  }
  release() {
    this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
  }
};

// node_modules/@visactor/vrender-core/es/event/event-target.js
var EventTarget = {
  dispatchEvent(e) {
    var _a;
    if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = false, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
  },
  emit(eventName, object) {
    return this.dispatchEvent(new CustomEvent(eventName, object));
  }
};

// node_modules/@visactor/vrender-core/es/event/event-system.js
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var EventSystem = class {
  constructor(params2) {
    this.resolution = 1, this.onPointerDown = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
      }
      for (let i = 0, j = events.length; i < j; i++) {
        const nativeEvent2 = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
        this.manager.mapEvent(federatedEvent);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerMove = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerUp = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        event.type += outside, this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerOverOut = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onWheel = (nativeEvent) => {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.manager.mapEvent(wheelEvent);
    };
    const { targetElement, resolution, rootNode, global, autoPreventDefault = false, clickInterval, supportsTouchEvents = global.supportsTouchEvents, supportsPointerEvents = global.supportsPointerEvents } = params2;
    this.manager = new EventManager(rootNode, {
      clickInterval,
      supportsTouchEvents
    }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = false, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.resolution = resolution, this.setTargetElement(targetElement);
  }
  release() {
    this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
  }
  setCursor(mode, target) {
    if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
    mode || (mode = "default");
    const { applyStyles, domElement } = this;
    if (this.currentCursor === mode) return;
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString_default(mode) && !has_default(this.cursorStyles, mode) && (domElement.style.cursor = mode);
  }
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, true), globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, true)) : (domElement.addEventListener("pointermove", this.onPointerMove, true), domElement.addEventListener("pointerup", this.onPointerUp, true)), domElement.addEventListener("pointerdown", this.onPointerDown, true), domElement.addEventListener("pointerleave", this.onPointerOverOut, true), domElement.addEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, true), globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, true)) : (domElement.addEventListener("mousemove", this.onPointerMove, true), domElement.addEventListener("mouseup", this.onPointerUp, true)), domElement.addEventListener("mousedown", this.onPointerDown, true), domElement.addEventListener("mouseout", this.onPointerOverOut, true), domElement.addEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, true), domElement.addEventListener("touchend", this.onPointerUp, true), domElement.addEventListener("touchmove", this.onPointerMove, true)), domElement.addEventListener("wheel", this.onWheel, {
      capture: true
    }), this.eventsAdded = true;
  }
  removeEvents() {
    var _a;
    if (!this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this, globalDocument = null !== (_a = globalObj.getDocument()) && void 0 !== _a ? _a : domElement;
    this.supportsPointerEvents ? (globalDocument.removeEventListener("pointermove", this.onPointerMove, true), globalDocument.removeEventListener("pointerup", this.onPointerUp, true), domElement.removeEventListener("pointerdown", this.onPointerDown, true), domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), domElement.removeEventListener("pointerover", this.onPointerOverOut, true)) : (globalDocument.removeEventListener("mousemove", this.onPointerMove, true), globalDocument.removeEventListener("mouseup", this.onPointerUp, true), domElement.removeEventListener("mousedown", this.onPointerDown, true), domElement.removeEventListener("mouseout", this.onPointerOverOut, true), domElement.removeEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, true), domElement.removeEventListener("touchend", this.onPointerUp, true), domElement.removeEventListener("touchmove", this.onPointerMove, true)), domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
  }
  mapToViewportPoint(event) {
    return this.domElement.pointTransform ? this.domElement.pointTransform(event.x, event.y) : event;
  }
  mapToCanvasPoint(nativeEvent) {
    var _a, _b;
    const point6 = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
    if (point6) return point6;
    let x = 0, y = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
      x = data.clientX || 0, y = data.clientY || 0;
    } else x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: x - rect.left,
      y: y - rect.top
    };
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i = 0, li = event.changedTouches.length; i < li; i++) {
      const touch = event.changedTouches[i];
      isUndefined_default(touch.button) && (touch.button = 0), isUndefined_default(touch.buttons) && (touch.buttons = 1), isUndefined_default(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined_default(touch.width) && (touch.width = touch.radiusX || 1), isUndefined_default(touch.height) && (touch.height = touch.radiusY || 1), isUndefined_default(touch.tiltX) && (touch.tiltX = 0), isUndefined_default(touch.tiltY) && (touch.tiltY = 0), isUndefined_default(touch.pointerType) && (touch.pointerType = "touch"), isUndefined_default(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined_default(touch.pressure) && (touch.pressure = touch.force || 0.5), isUndefined_default(touch.twist) && (touch.twist = 0), isUndefined_default(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined_default(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined_default(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = true, touch.type = event.type, normalizedEvents.push(touch);
    }
    else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event);
    else {
      const tempEvent = event;
      isUndefined_default(tempEvent.isPrimary) && (tempEvent.isPrimary = true), isUndefined_default(tempEvent.width) && (tempEvent.width = 1), isUndefined_default(tempEvent.height) && (tempEvent.height = 1), isUndefined_default(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined_default(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined_default(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined_default(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined_default(tempEvent.pressure) && (tempEvent.pressure = 0.5), isUndefined_default(tempEvent.twist) && (tempEvent.twist = 0), isUndefined_default(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
  }
  isEventOutsideOfTargetViewPort(nativeEvent) {
    if (this.isEventOutsideOfTargetElement(nativeEvent)) return true;
    if (this.domElement.getViewBox) {
      const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)), b = this.domElement.getViewBox(), w = b.width(), h = b.height();
      return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
    }
    return false;
  }
  isEventOutsideOfTargetElement(nativeEvent) {
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
  }
  pauseTriggerEvent() {
    this.manager.pauseNotify = true;
  }
  resumeTriggerEvent() {
    this.manager.pauseNotify = false;
  }
};

// node_modules/@visactor/vrender-core/es/animate/Ticker/type.js
var STATUS;
!function(STATUS3) {
  STATUS3[STATUS3.INITIAL = 0] = "INITIAL", STATUS3[STATUS3.RUNNING = 1] = "RUNNING", STATUS3[STATUS3.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));

// node_modules/@visactor/vrender-core/es/animate/Ticker/raf-tick-handler.js
var RAFTickHandler = class _RAFTickHandler {
  static Avaliable() {
    return !!application.global.getRequestAnimationFrame();
  }
  avaliable() {
    return _RAFTickHandler.Avaliable();
  }
  tick(interval, cb) {
    application.global.getRequestAnimationFrame()(() => {
      this.released || cb(this);
    });
  }
  release() {
    this.released = true;
  }
  getTime() {
    return Date.now();
  }
};

// node_modules/@visactor/vrender-core/es/animate/Ticker/timeout-tick-handler.js
var TimeOutTickHandler = class _TimeOutTickHandler {
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _TimeOutTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.timerId = setTimeout(() => {
      cb(this);
    }, interval);
  }
  release() {
    this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
  }
  getTime() {
    return Date.now();
  }
};

// node_modules/@visactor/vrender-core/es/animate/Ticker/default-ticker.js
var DefaultTicker = class extends import_eventemitter3.default {
  set mode(m4) {
    this._mode !== m4 && (this._mode = m4, this.setupTickHandler());
  }
  get mode() {
    return this._mode;
  }
  constructor(timelines = []) {
    super(), this.handleTick = (handler, params2) => {
      const { once = false } = null != params2 ? params2 : {};
      this.ifCanStop() ? this.stop() : (this._handlerTick(), once || handler.tick(this.interval, this.handleTick));
    }, this._handlerTick = () => {
      const time = this.tickerHandler.getTime();
      let delta = 0;
      this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t) => {
        t.tick(delta);
      }), this.emit("tick"));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = true;
  }
  init() {
    this.interval = NaN, this.status = STATUS.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
      this.initHandler();
    }), application.global.env && this.initHandler();
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter((t) => t !== timeline);
  }
  getTimelines() {
    return this.timelines;
  }
  initHandler() {
    if (this._mode) return null;
    const ticks4 = [{
      mode: "raf",
      cons: RAFTickHandler
    }, {
      mode: "timeout",
      cons: TimeOutTickHandler
    }];
    for (let i = 0; i < ticks4.length; i++) if (ticks4[i].cons.Avaliable()) {
      this.mode = ticks4[i].mode;
      break;
    }
    return null;
  }
  setupTickHandler() {
    let handler;
    switch (this._mode) {
      case "raf":
        handler = new RAFTickHandler();
        break;
      case "timeout":
        handler = new TimeOutTickHandler();
        break;
      default:
        Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
    }
    return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, true);
  }
  setInterval(interval) {
    this.interval = interval;
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(1e3 / fps);
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  tickTo(t) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  pause() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, true);
  }
  resume() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, true);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length) return true;
      if (0 === this.timelines.reduce((a3, b) => a3 + b.animateCount, 0)) return true;
    }
    return false;
  }
  start(force = false) {
    if (this.status === STATUS.RUNNING) return false;
    if (!this.tickerHandler) return false;
    if (!force) {
      if (this.status === STATUS.PAUSE) return false;
      if (!this.timelines.length) return false;
      if (0 === this.timelines.reduce((a3, b) => a3 + b.animateCount, 0)) return false;
    }
    return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), true;
  }
  stop() {
    this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
  }
  release() {
    this.stop(), this.timelines = [], this.tickerHandler.release(), this.emit("afterTick");
  }
  trySyncTickStatus() {
    this.status === STATUS.RUNNING && this._handlerTick();
  }
};

// node_modules/@visactor/vrender-core/es/animate/easing.js
var Easing = class _Easing {
  constructor() {
  }
  static linear(t) {
    return t;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t) {
      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
    };
  }
  static getPowIn(pow) {
    return function(t) {
      return Math.pow(t, pow);
    };
  }
  static getPowOut(pow) {
    return function(t) {
      return 1 - Math.pow(1 - t, pow);
    };
  }
  static getPowInOut(pow) {
    return function(t) {
      return (t *= 2) < 1 ? 0.5 * Math.pow(t, pow) : 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
    };
  }
  static getBackIn(amount) {
    return function(t) {
      return t * t * ((amount + 1) * t - amount);
    };
  }
  static getBackOut(amount) {
    return function(t) {
      return --t * t * ((amount + 1) * t + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function(t) {
      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * 0.5 : 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
    };
  }
  static sineIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static sineOut(t) {
    return Math.sin(t * Math.PI / 2);
  }
  static sineInOut(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }
  static expoIn(t) {
    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
  }
  static expoOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }
  static expoInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  }
  static circIn(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  }
  static circOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  static circInOut(t) {
    return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }
  static bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  }
  static bounceIn(t) {
    return 1 - _Easing.bounceOut(1 - t);
  }
  static bounceInOut(t) {
    return t < 0.5 ? 0.5 * _Easing.bounceIn(2 * t) : 0.5 * _Easing.bounceOut(2 * t - 1) + 0.5;
  }
  static getElasticIn(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t) return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t) return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s2) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function(t) {
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * -0.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * 0.5 + 1;
    };
  }
  static registerFunc(name, func) {
    _Easing[name] = func;
  }
};
function flicker(t, n) {
  const step = 1 / n;
  let flag = 1;
  for (; t > step; ) t -= step, flag *= -1;
  const v = flag * t / step;
  return v > 0 ? v : 1 + v;
}
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, 0.3), Easing.elasticOut = Easing.getElasticOut(1, 0.3), Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5), Easing.easeInOutQuad = (t) => (t /= 0.5) < 1 ? 0.5 * Math.pow(t, 2) : -0.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = (x) => {
  const c4 = 2 * Math.PI / 3;
  return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - 0.75) * c4) + 1;
}, Easing.easeInOutElastic = (x) => {
  const c5 = 2 * Math.PI / 4.5;
  return 0 === x ? 0 : 1 === x ? 1 : x < 0.5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
};
for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = (t) => flicker(t, i);
for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = (t) => i * t * t + (1 - i) * t;

// node_modules/@visactor/vrender-core/es/animate/timeline.js
var DefaultTimeline = class {
  constructor() {
    this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = false;
  }
  addAnimate(animate) {
    this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  tick(delta) {
    if (this.paused) return;
    let animate = this.animateHead;
    for (this.animateCount = 0; animate; ) animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
  }
  clear() {
    let animate = this.animateHead;
    for (; animate; ) animate.release(), animate = animate.nextAnimate;
    this.animateHead = null, this.animateTail = null, this.animateCount = 0;
  }
  removeAnimate(animate, release = true) {
    animate._onRemove && animate._onRemove.forEach((cb) => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
  }
};
var defaultTimeline = new DefaultTimeline();

// node_modules/@visactor/vrender-core/es/animate/animate.js
var ACustomAnimate = class {
  constructor(from, to, duration, easing, params2) {
    this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params2, this.updateCount = 0;
  }
  bind(target, subAni) {
    this.target = target, this.subAnimate = subAni, this.onBind();
  }
  onBind() {
  }
  onFirstRun() {
  }
  onStart() {
  }
  onEnd() {
  }
  getEndProps() {
    return this.to;
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var _a;
    const thisEndProps = this.getEndProps();
    return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
  }
  update(end, ratio, out) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const props = this.step.getLastProps();
      Object.keys(props).forEach((k2) => {
        this.subAnimate.animate.validAttr(k2) && (out[k2] = props[k2]);
      });
    }
    this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
  }
};
var CbAnimate = class extends ACustomAnimate {
  constructor(cb) {
    super(null, null, 0, "linear"), this.cb = cb;
  }
  onUpdate(end, ratio, out) {
  }
  onStart() {
    this.cb();
  }
};
var Animate = class _Animate {
  constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline, slience) {
    this.id = id, this.timeline = timeline || defaultTimeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this), this.slience = slience;
  }
  setTimeline(timeline) {
    timeline !== this.timeline && (this.timeline.removeAnimate(this, false), timeline.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
  }
  after(animate) {
    const t = animate.getDuration();
    return this._startTime = t, this;
  }
  afterAll(list) {
    let maxT = -1 / 0;
    return list.forEach((a3) => {
      maxT = max(a3.getDuration(), maxT);
    }), this._startTime = maxT, this;
  }
  parallel(animate) {
    return this._startTime = animate.getStartTime(), this;
  }
  static AddInterpolate(name, cb) {
    _Animate.interpolateMap.set(name, cb);
  }
  play(customAnimate) {
    if (this.tailAnimate.play(customAnimate), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return 1 === this.subAnimates.length && this.tailAnimate.totalDuration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
  }
  trySetAttribute(attr, mode = _Animate.mode) {
    attr && mode & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, false, {
      type: AttributeUpdateType.ANIMATE_PLAY
    });
  }
  runCb(cb) {
    const customAnimate = new CbAnimate(() => {
      cb(this, customAnimate.step.prev);
    });
    return this.tailAnimate.play(customAnimate), this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    const func = _Animate.interpolateMap.get(key) || _Animate.interpolateMap.get("");
    return !!func && func(key, ratio, from, to, target, ret);
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  to(props, duration, easing, params2) {
    if (this.tailAnimate.to(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  from(props, duration, easing, params2) {
    if (this.tailAnimate.from(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  wait(duration) {
    if (this.tailAnimate.wait(duration), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  startAt(t) {
    if (this.tailAnimate.startAt(t), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  loop(l) {
    if (this.tailAnimate.loop = l, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  reversed(r) {
    if (this.tailAnimate.reversed = r, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  bounce(b) {
    if (this.tailAnimate.bounce = b, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const sa = new SubAnimate(this, this.tailAnimate);
    return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(key) {
    this._preventAttrs && this._preventAttrs.delete(key);
  }
  preventAttr(key) {
    this._preventAttrs || (this._preventAttrs = /* @__PURE__ */ new Set()), this._preventAttrs.add(key);
  }
  preventAttrs(keys) {
    keys.forEach((key) => this.preventAttr(key));
  }
  validAttr(key) {
    return !this._preventAttrs || !this._preventAttrs.has(key);
  }
  bind(target) {
    return this.target = target, this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.subAnimates.forEach((sa) => {
      sa.bind(target);
    }), this;
  }
  advance(delta) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
      delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
    }
    this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach((cb) => cb()));
    this.setPosition(Math.max(this.rawPosition, 0) + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach((cb) => cb()));
  }
  setPosition(rawPosition) {
    let sa, d = 0;
    const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce((a3, b) => a3 + b.totalDuration, 0);
    rawPosition < 0 && (rawPosition = 0);
    const end = rawPosition >= maxRawPos;
    if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
    for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, sa = void 0;
    return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
  }
  onStart(cb) {
    this._onStart || (this._onStart = []), this._onStart.push(cb);
  }
  onEnd(cb) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
  }
  onRemove(cb) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
  }
  onFrame(cb) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(nextVal) {
    nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
  }
};
Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = /* @__PURE__ */ new Map();
var SubAnimate = class {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(animate, lastSubAnimate) {
    this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step2(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = true, this._startAt = 0;
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(target) {
    return this.target = target, this;
  }
  play(customAnimate) {
    let duration = customAnimate.duration;
    (null == duration || duration < 0) && (duration = 0);
    const easing = customAnimate.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, false), this._appendCustomAnimate(customAnimate, step), this;
  }
  to(props, duration, easing, params2) {
    (null == duration || duration < 0) && (duration = 0);
    const easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.to, this._appendProps(props, step, !!params2 && params2.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params2 && params2.noPreventAttrs || this.target.animates && this.target.animates.forEach((a3) => {
      a3.id !== this.animate.id && a3.preventAttrs(step.propKeys);
    }), this;
  }
  from(props, duration, easing, params2) {
    this.to(props, 0, easing, params2);
    const toProps = {};
    this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach((k2) => {
      toProps[k2] = this.getLastPropByName(k2, this.stepTail);
    }), this.to(toProps, duration, easing, params2), this.stepTail.type = AnimateStepType.from;
  }
  startAt(t) {
    return t < 0 && (t = 0), this._startAt = t, this;
  }
  getStartProps() {
    var _a;
    return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(duration) {
    if (duration > 0) {
      const step = this._addStep(+duration, null);
      step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
    }
    return this;
  }
  _addStep(duration, props, easingFunc) {
    const step = new Step2(this.duration, duration, props, easingFunc);
    return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
  }
  _appendProps(props, step, tempProps) {
    step.props = tempProps ? props : Object.assign({}, props);
    let lastStep = step.prev;
    const _props = step.props;
    for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k2) => {
      void 0 === step.props[k2] && (step.props[k2] = this.target.getDefaultAttribute(k2));
    }); lastStep.prev; ) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach((key) => {
      void 0 === _props[key] && (_props[key] = lastStep.props[key]);
    })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
    const initProps = this.stepHead.props;
    step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key) => {
      if (void 0 === initProps[key]) {
        const parentAnimateInitProps = this.animate.getStartProps();
        initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
      }
    }), this.target.onAddStep && this.target.onAddStep(step);
  }
  _appendCustomAnimate(customAnimate, step) {
    step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
  }
  setPosition(rawPosition) {
    var _a;
    const d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
    let loop, position, end = false;
    const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
    if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, false;
    if (rawPosition -= startAt, d <= 0 && (end = true, d < 0)) return end;
    if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
    const rev = !this.reversed != !(this.bounce && loop % 2);
    return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
  }
  updatePosition(end, rev) {
    if (!this.stepHead) return;
    let step = this.stepHead.next;
    const position = this.position, duration = this.duration;
    if (this.target && step) {
      let stepNext = step.next;
      for (; stepNext && stepNext.position <= position; ) step = stepNext, stepNext = step.next;
      let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
      step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb) => cb(step, ratio));
    }
  }
  tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
    if (step !== lastStep) if (rev) {
      let _step = lastStep.prev;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    } else {
      let _step = lastStep.next;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    }
  }
  getLastPropByName(name, step) {
    let lastStep = step.prev;
    for (; lastStep; ) {
      if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
      if (lastStep.customAnimate) {
        const val = lastStep.customAnimate.getEndProps()[name];
        if (void 0 !== val) return val;
      }
      lastStep = lastStep.prev;
    }
    return Logger.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
  }
  updateTarget(step, ratio, end) {
    null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
  }
};
var Step2 = class {
  constructor(position, duration, props, easing) {
    this.duration = duration, this.position = position, this.props = props, this.easing = easing;
  }
  append(step) {
    step.prev = this, step.next = this.next, this.next = step;
  }
  getLastProps() {
    let step = this.prev;
    for (; step; ) {
      if (step.props) return step.props;
      if (step.customAnimate) return step.customAnimate.getMergedEndProps();
      step = step.prev;
    }
    return null;
  }
};

// node_modules/@visactor/vrender-core/es/animate/config.js
var DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};
var DefaultMorphingAnimateConfig = {
  duration: 1e3,
  easing: "quadInOut"
};

// node_modules/@visactor/vrender-core/es/common/utils.js
var Edge;
!function(Edge2) {
  Edge2[Edge2.Top = 1] = "Top", Edge2[Edge2.Right = 2] = "Right", Edge2[Edge2.Bottom = 4] = "Bottom", Edge2[Edge2.Left = 8] = "Left", Edge2[Edge2.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
var _strokeVec4 = [false, false, false, false];
var parseStroke = (stroke2) => {
  var _a;
  let isFullStroke = true;
  if (isBoolean_default(stroke2, true)) {
    for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke2, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
    isFullStroke = stroke2;
  } else if (Array.isArray(stroke2)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke2[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);
  else _strokeVec4[0] = false, _strokeVec4[1] = false, _strokeVec4[2] = false, _strokeVec4[3] = false;
  return {
    isFullStroke,
    stroke: _strokeVec4
  };
};
var _paddingVec4 = [0, 0, 0, 0];
var parsePadding = (padding) => padding ? isArray_default(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
var _coords = [{
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}];
var indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2; ) startAngle -= pi2;
  for (; startAngle < 0; ) startAngle += pi2;
  for (; startAngle > endAngle; ) endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi) % 4, endIdx = Math.ceil(endAngle / halfPi) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = false;
    for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
      if (match && endIdx === indexList[i]) break;
      if (match) {
        const p = _coords[indexList[i]];
        bounds.add(p.x, p.y);
      }
    } else {
      match = true;
      const p = _coords[startIdx];
      bounds.add(p.x, p.y);
    }
  }
}
function pointInterpolation(pointA, pointB, ratio) {
  const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point6 = new Point(x, y, x1, y1);
  return point6.defined = pointB.defined, point6;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB) return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map((point6) => {
      const p = new Point(point6.x, point6.y, point6.x1, point6.y1);
      return p.defined = point6.defined, p;
    });
    for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  } else {
    points = pointsB.map((point6) => {
      const p = new Point(point6.x, point6.y, point6.x1, point6.y1);
      return p.defined = point6.defined, p;
    });
    for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  }
  return points;
}
var transformKeys = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY"];
var isTransformKey = (key) => transformKeys.includes(key);
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray_default(attr)) {
    let val;
    for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
    return val;
  }
  return attr[key];
}
var RafBasedSTO = class _RafBasedSTO {
  constructor(timeout = _RafBasedSTO.TimeOut) {
    this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
  }
  call(cb) {
    return this.lastDate = Date.now(), setTimeout(() => {
      this.appendDuration(Date.now() - this.lastDate), cb(0);
    }, this.timeout, true);
  }
  clear(h) {
    clearTimeout(h);
  }
  appendDuration(d) {
    this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a3, b) => a3 + b, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
  }
};
RafBasedSTO.TimeOut = 1e3 / 60;
var rafBasedSto = new RafBasedSTO();
var _calculateLineHeight = (lineHeight, fontSize) => {
  if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};
var calculateLineHeight = (lineHeight, fontSize) => {
  const _lh = _calculateLineHeight(lineHeight, fontSize);
  return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

// node_modules/@visactor/vrender-core/es/animate/custom-animate.js
var IncreaseCount = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2);
  }
  getEndProps() {
    return false === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.fromNumber = isNumber_default(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), this.toNumber = isNumber_default(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = false), false !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    var _a;
    false !== this.valid && (out.text = end ? null === (_a = this.to) || void 0 === _a ? void 0 : _a.text : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
  }
};
var Direction2;
!function(Direction3) {
  Direction3[Direction3.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction3[Direction3.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction3[Direction3.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction3[Direction3.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction3[Direction3.STROKE = 4] = "STROKE";
}(Direction2 || (Direction2 = {}));
var InputText = class extends ACustomAnimate {
  constructor() {
    super(...arguments), this.fromText = "", this.toText = "";
  }
  getEndProps() {
    return false === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c;
    this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", this.toText = (null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) || "", (!this.toText || isArray_default(this.toText) && 0 === this.toText.length) && (this.valid = false), isArray_default(this.toText) && (this.toText = this.toText.map((item) => (item || "").toString()));
  }
  onEnd() {
    this.target.detachShadow();
  }
  onUpdate(end, ratio, out) {
    if (false === this.valid) return;
    const fromCount = this.fromText.length, toTextIsArray = isArray_default(this.toText), toCount = toTextIsArray ? this.toText.reduce((c3, t) => c3 + (t || "").length, 0) : this.toText.length, count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
    if (toTextIsArray) {
      out.text = [];
      let len = 0;
      this.toText.forEach((t) => {
        len + t.length > count ? (out.text.push(t.substr(0, count - len)), len = count) : (out.text.push(t), len += t.length);
      });
    } else out.text = this.toText.substr(0, count);
  }
};
var TagPointsUpdate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    var _a, _b;
    super(from, to, duration, easing, params2), this.newPointAnimateType = null !== (_a = null == params2 ? void 0 : params2.newPointAnimateType) && void 0 !== _a ? _a : "grow", this.clipRangeByDimension = null !== (_b = null == params2 ? void 0 : params2.clipRangeByDimension) && void 0 !== _b ? _b : "x";
  }
  getPoints(attribute, cache = false) {
    if (attribute.points) return attribute.points;
    if (attribute.segments) {
      const points = [];
      return this.segmentsCache || (this.segmentsCache = []), attribute.segments.map((segment) => {
        var _a, _b;
        segment.points && points.push(...segment.points), cache && this.segmentsCache.push(null !== (_b = null === (_a = segment.points) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0);
      }), points;
    }
    return [];
  }
  onBind() {
    const originFromPoints = this.getPoints(this.from), originToPoints = this.getPoints(this.to, true);
    this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [originFromPoints] : [], this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [originToPoints] : [];
    const tagMap = /* @__PURE__ */ new Map();
    this.fromPoints.forEach((point6) => {
      point6.context && tagMap.set(point6.context, point6);
    });
    let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
    for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
      firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
      break;
    }
    for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {
      lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
      break;
    }
    "clip" === this.newPointAnimateType && 0 !== this.toPoints.length && (Number.isFinite(lastMatchedIndex) ? (this.clipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.toPoints[this.toPoints.length - 1][this.clipRangeByDimension], 1 === this.clipRange && (this.shrinkClipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.fromPoints[this.fromPoints.length - 1][this.clipRangeByDimension]), isValidNumber_default(this.clipRange) ? this.clipRange = clamp_default(this.clipRange, 0, 1) : this.clipRange = 0) : this.clipRange = 0);
    let prevMatchedPoint = this.toPoints[0];
    this.interpolatePoints = this.toPoints.map((point6, index) => {
      const matchedPoint = tagMap.get(point6.context);
      return matchedPoint ? (prevMatchedPoint = matchedPoint, [matchedPoint, point6]) : "appear" === this.newPointAnimateType || "clip" === this.newPointAnimateType ? [point6, point6] : index < firstMatchedIndex && firstMatchedPoint ? [firstMatchedPoint, point6] : index > lastMatchedIndex && lastMatchedPoint ? [lastMatchedPoint, point6] : [prevMatchedPoint, point6];
    }), this.points = this.interpolatePoints.map((interpolate2) => {
      const fromPoint = interpolate2[0], toPoint = interpolate2[1], newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
      return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
    });
  }
  onFirstRun() {
    const lastClipRange = this.target.attribute.clipRange;
    isValidNumber_default(lastClipRange * this.clipRange) && (this.clipRange *= lastClipRange);
  }
  onUpdate(end, ratio, out) {
    if (this.points = this.points.map((point6, index) => {
      const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return newPoint.context = point6.context, newPoint;
    }), this.clipRange) {
      if (this.shrinkClipRange) return void (end ? (out.points = this.toPoints, out.clipRange = 1) : (out.points = this.fromPoints, out.clipRange = this.clipRange - (this.clipRange - this.shrinkClipRange) * ratio));
      out.clipRange = this.clipRange + (1 - this.clipRange) * ratio;
    }
    if (this.segmentsCache && this.to.segments) {
      let start = 0;
      out.segments = this.to.segments.map((segment, index) => {
        const end2 = start + this.segmentsCache[index], points = this.points.slice(start, end2);
        return start = end2, Object.assign(Object.assign({}, segment), {
          points
        });
      });
    } else out.points = this.points;
  }
};
var ClipGraphicAnimate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(null, null, duration, easing, params2), this.clipFromAttribute = from, this.clipToAttribute = to, this._group = null == params2 ? void 0 : params2.group, this._clipGraphic = null == params2 ? void 0 : params2.clipGraphic;
  }
  onBind() {
    this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, this._lastPath = this._group.attribute.path, this._group.setAttributes({
      clip: true,
      path: [this._clipGraphic]
    }, false, {
      type: AttributeUpdateType.ANIMATE_BIND
    }));
  }
  onEnd() {
    this._group && this._group.setAttributes({
      clip: this._lastClip,
      path: this._lastPath
    }, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onUpdate(end, ratio, out) {
    if (!this._clipGraphic) return;
    const res = {};
    Object.keys(this.clipFromAttribute).forEach((k2) => {
      res[k2] = this.clipFromAttribute[k2] + (this.clipToAttribute[k2] - this.clipFromAttribute[k2]) * ratio;
    }), this._clipGraphic.setAttributes(res, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end
      }
    });
  }
};
var ClipAngleAnimate = class extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const groupAttribute = null !== (_b = null === (_a = null == params2 ? void 0 : params2.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params2 ? void 0 : params2.animationType) && void 0 !== _e ? _e : "in", startAngle = null !== (_f = null == params2 ? void 0 : params2.startAngle) && void 0 !== _f ? _f : 0, orient = null !== (_g = null == params2 ? void 0 : params2.orient) && void 0 !== _g ? _g : "clockwise";
    let arcStartAngle = 0, arcEndAngle = 0;
    "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
    const arc = application.graphicService.creator.arc({
      x: null !== (_j = null === (_h = null == params2 ? void 0 : params2.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
      y: null !== (_l = null === (_k = null == params2 ? void 0 : params2.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
      outerRadius: null !== (_m = null == params2 ? void 0 : params2.radius) && void 0 !== _m ? _m : (width + height) / 2,
      innerRadius: 0,
      startAngle: arcStartAngle,
      endAngle: arcEndAngle,
      fill: true
    });
    let fromAttributes, toAttributes;
    "anticlockwise" === orient ? (fromAttributes = {
      startAngle: startAngle + 2 * Math.PI
    }, toAttributes = {
      startAngle
    }) : (fromAttributes = {
      endAngle: startAngle
    }, toAttributes = {
      endAngle: startAngle + 2 * Math.PI
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params2 ? void 0 : params2.group,
      clipGraphic: arc
    });
  }
};
var ClipDirectionAnimate = class extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const groupAttribute = null !== (_b = null === (_a = null == params2 ? void 0 : params2.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_d = null !== (_c = null == params2 ? void 0 : params2.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0, height = null !== (_f = null !== (_e = null == params2 ? void 0 : params2.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0, animationType = null !== (_g = null == params2 ? void 0 : params2.animationType) && void 0 !== _g ? _g : "in", direction = null !== (_h = null == params2 ? void 0 : params2.direction) && void 0 !== _h ? _h : "x", orient = null !== (_j = null == params2 ? void 0 : params2.orient) && void 0 !== _j ? _j : "positive", rect = application.graphicService.creator.rect({
      x: 0,
      y: 0,
      width: "in" === animationType && "x" === direction ? 0 : width,
      height: "in" === animationType && "y" === direction ? 0 : height,
      fill: true
    });
    let fromAttributes = {}, toAttributes = {};
    "y" === direction ? "negative" === orient ? (fromAttributes = {
      y: height,
      height: 0
    }, toAttributes = {
      y: 0,
      height
    }) : (fromAttributes = {
      height: 0
    }, toAttributes = {
      height
    }) : "negative" === orient ? (fromAttributes = {
      x: width,
      width: 0
    }, toAttributes = {
      x: 0,
      width
    }) : (fromAttributes = {
      width: 0
    }, toAttributes = {
      width
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params2 ? void 0 : params2.group,
      clipGraphic: rect
    });
  }
};
var RotateBySphereAnimate = class extends ACustomAnimate {
  onStart() {
    const { center: center2, r } = "function" == typeof this.params ? this.params() : this.params, startX = this.target.getComputedAttribute("x"), startY = this.target.getComputedAttribute("y"), startZ = this.target.getComputedAttribute("z"), phi = Math.acos((startY - center2.y) / r);
    let theta = Math.acos((startX - center2.x) / r / Math.sin(phi));
    startZ - center2.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
  }
  onBind() {
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    if (null == this.phi || null == this.theta) return;
    const { center: center2, r, cb } = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center2.x, y = r * Math.cos(phi) + center2.y, z = r * Math.sin(phi) * Math.sin(theta) + center2.z;
    for (out.x = x, out.y = y, out.z = z, out.alpha = theta + pi / 2; out.alpha > pi2; ) out.alpha -= pi2;
    out.alpha = pi2 - out.alpha, out.zIndex = -1e4 * out.z, cb && cb(out);
  }
};
var AnimateGroup = class extends ACustomAnimate {
  constructor(duration, customAnimates) {
    super(null, null, duration, "linear"), this.customAnimates = customAnimates;
  }
  initAnimates() {
    this.customAnimates.forEach((a3) => {
      a3.step = this.step, a3.subAnimate = this.subAnimate, a3.target = this.target;
    });
  }
  getEndProps() {
    const props = {};
    return this.customAnimates.forEach((a3) => {
      Object.assign(props, a3.getEndProps());
    }), props;
  }
  onBind() {
    this.initAnimates(), this.customAnimates.forEach((a3) => {
      a3.onBind();
    });
  }
  onEnd() {
    this.customAnimates.forEach((a3) => {
      a3.onEnd();
    });
  }
  onStart() {
    this.customAnimates.forEach((a3) => {
      a3.onStart();
    });
  }
  onUpdate(end, ratio, out) {
    this.updating || (this.updating = true, this.customAnimates.forEach((a3) => {
      const easing = a3.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing;
      ratio = easingFunc(ratio), a3.onUpdate(end, ratio, out);
    }), this.updating = false);
  }
};

// node_modules/@visactor/vrender-core/es/common/morphing-utils.js
function cubicSubdivide(p0, p1, p2, p3, t, out) {
  const p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p23 = (p3 - p2) * t + p2, p012 = (p12 - p01) * t + p01, p123 = (p23 - p12) * t + p12, p0123 = (p123 - p012) * t + p012;
  out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, out[6] = p23, out[7] = p3;
}
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length, len2 = subpath2.length;
  if (len1 === len2) return [subpath1, subpath2];
  const tmpSegX = [], tmpSegY = [], shorterPath = len1 < len2 ? subpath1 : subpath2, shorterLen = Math.min(len1, len2), diff = Math.abs(len2 - len1) / 6, shorterBezierCount = (shorterLen - 2) / 6, eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount), newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i = 2; i < shorterLen; i += 6) {
    let x0 = shorterPath[i - 2], y0 = shorterPath[i - 1], x1 = shorterPath[i], y1 = shorterPath[i + 1], x2 = shorterPath[i + 2], y2 = shorterPath[i + 3];
    const x3 = shorterPath[i + 4], y3 = shorterPath[i + 5];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
    for (let k2 = 1; k2 <= actualSubDivCount; k2++) {
      const p = k2 / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX), cubicSubdivide(y0, y1, y2, y3, p, tmpSegY), x0 = tmpSegX[3], y0 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0), x1 = tmpSegX[5], y1 = tmpSegY[5], x2 = tmpSegX[6], y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpath, otherSubpath) {
  const prevSubPath = lastSubpath || otherSubpath, len = prevSubPath.length, lastX = prevSubPath[len - 2], lastY = prevSubPath[len - 1], newSubpath = [];
  for (let i = 0; i < otherSubpath.length; i += 2) newSubpath[i] = lastX, newSubpath[i + 1] = lastY;
  return newSubpath;
}
function reverseSubpath(array2) {
  const newArr = [], len = array2.length;
  for (let i = 0; i < len; i += 2) newArr[i] = array2[len - i - 2], newArr[i + 1] = array2[len - i - 1];
  return newArr;
}
function centroidOfSubpath(array2) {
  let signedArea = 0, cx = 0, cy = 0;
  const len = array2.length;
  for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
    const x0 = array2[j], y0 = array2[j + 1], x1 = array2[i], y1 = array2[i + 1], a3 = x0 * y1 - x1 * y0;
    signedArea += a3, cx += (x0 + x1) * a3, cy += (y0 + y1) * a3;
  }
  return 0 === signedArea ? [array2[0] || 0, array2[1] || 0, 0] : [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = 1 / 0, bestOffset = 0;
  const len = fromSubBeziers.length, len2 = len - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = 6 * offset;
    let score2 = 0;
    for (let k2 = 0; k2 < len; k2 += 2) {
      const idx2 = 0 === k2 ? cursorOffset : (cursorOffset + k2 - 2) % len2 + 2, x0 = fromSubBeziers[idx2] - fromCp[0], y0 = fromSubBeziers[idx2 + 1] - fromCp[1], dx = toSubBeziers[k2] - toCp[0] - x0, dy = toSubBeziers[k2 + 1] - toCp[1] - y0;
      score2 += dx * dx + dy * dy;
    }
    score2 < bestScore && (bestScore = score2, bestOffset = offset);
  }
  return bestOffset;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
  const result2 = [];
  let fromNeedsReverse;
  for (let i = 0; i < fromArr.length; i++) {
    let fromSubpathBezier = fromArr[i];
    const toSubpathBezier = toArr[i], fromCp = centroidOfSubpath(fromSubpathBezier), toCp = centroidOfSubpath(toSubpathBezier);
    null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
    const newFromSubpathBezier = [], newToSubpathBezier = [];
    let bestAngle = 0, bestScore = 1 / 0;
    const tmpArr = [], len = fromSubpathBezier.length;
    fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
    const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp), len2 = len - 2;
    for (let k2 = 0; k2 < len2; k2 += 2) {
      const idx2 = (offset + k2) % len2 + 2;
      newFromSubpathBezier[k2 + 2] = fromSubpathBezier[idx2] - fromCp[0], newFromSubpathBezier[k2 + 3] = fromSubpathBezier[idx2 + 1] - fromCp[1];
    }
    if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle2 = -searchAngleRange / 2; angle2 <= searchAngleRange / 2; angle2 += step) {
        const sa = Math.sin(angle2), ca = Math.cos(angle2);
        let score2 = 0;
        for (let k2 = 0; k2 < fromSubpathBezier.length; k2 += 2) {
          const x0 = newFromSubpathBezier[k2], y0 = newFromSubpathBezier[k2 + 1], x1 = toSubpathBezier[k2] - toCp[0], y1 = toSubpathBezier[k2 + 1] - toCp[1], newX1 = x1 * ca - y1 * sa, newY1 = x1 * sa + y1 * ca;
          tmpArr[k2] = newX1, tmpArr[k2 + 1] = newY1;
          const dx = newX1 - x0, dy = newY1 - y0;
          score2 += dx * dx + dy * dy;
        }
        if (score2 < bestScore) {
          bestScore = score2, bestAngle = angle2;
          for (let m4 = 0; m4 < tmpArr.length; m4++) newToSubpathBezier[m4] = tmpArr[m4];
        }
      }
    } else for (let i2 = 0; i2 < len; i2 += 2) newToSubpathBezier[i2] = toSubpathBezier[i2] - toCp[0], newToSubpathBezier[i2 + 1] = toSubpathBezier[i2 + 1] - toCp[1];
    result2.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result2;
}
function alignBezierCurves(array1, array2) {
  let lastSubpath1, lastSubpath2;
  const newArray1 = [], newArray2 = [];
  for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
    const subpath1 = array1[i], subpath2 = array2[i];
    let newSubpath1, newSubpath2;
    subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
var addLineToBezierPath = (bezierPath, x0, y0, x1, y1) => {
  isNumberClose(x0, x1) && isNumberClose(y0, y1) || bezierPath.push(x0, y0, x1, y1, x1, y1);
};
function pathToBezierCurves(path) {
  const commandList = path.commandList, bezierArrayGroups = [];
  let currentSubpath, xi = 0, yi = 0, x0 = 0, y0 = 0;
  const createNewSubpath = (x, y) => {
    currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), currentSubpath = [x, y];
  };
  let x1, y1, x2, y2;
  for (let i = 0, len = commandList.length; i < len; i++) {
    const cmd = commandList[i], isFirst = 0 === i;
    switch (isFirst && (x0 = xi = cmd[1], y0 = yi = cmd[2], [enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0]) && (currentSubpath = [x0, y0])), cmd[0]) {
      case enumCommandMap.M:
        xi = x0 = cmd[1], yi = y0 = cmd[2], createNewSubpath(x0, y0);
        break;
      case enumCommandMap.L:
        x1 = cmd[1], y1 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = x1, yi = y1;
        break;
      case enumCommandMap.C:
        currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
        break;
      case enumCommandMap.Q:
        x1 = cmd[1], y1 = cmd[2], x2 = cmd[3], y2 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2), xi = x2, yi = y2;
        break;
      case enumCommandMap.A: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = rx, startAngle = cmd[4], endAngle = cmd[5], counterClockwise = !!cmd[6];
        x1 = Math.cos(startAngle) * rx + cx, y1 = Math.sin(startAngle) * rx + cy, isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
        const step = (counterClockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; counterClockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = counterClockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry);
        }
        break;
      }
      case enumCommandMap.E: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = cmd[4], rotate = cmd[5], startAngle = cmd[6], endAngle = cmd[7] + startAngle, anticlockwise = !!cmd[8], hasRotate = !isNumberClose(rotate, 0), rc = Math.cos(rotate), rs = Math.sin(rotate);
        let xTemp = Math.cos(startAngle) * rx, yTemp = Math.sin(startAngle) * ry;
        hasRotate ? (x1 = xTemp * rc - yTemp * rs + cx, y1 = xTemp * rs + yTemp * rc + cy) : (x1 = xTemp + cx, y1 = yTemp + cy), isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);
        const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; anticlockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = anticlockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          if (addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry), hasRotate) {
            const curLen = currentSubpath.length;
            for (let j = curLen - 6; j <= curLen - 1; j += 2) xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
          }
        }
        break;
      }
      case enumCommandMap.R:
        x0 = xi = cmd[1], y0 = yi = cmd[2], x1 = x0 + cmd[3], y1 = y0 + cmd[4], createNewSubpath(x1, y0), addLineToBezierPath(currentSubpath, x1, y0, x1, y1), addLineToBezierPath(currentSubpath, x1, y1, x0, y1), addLineToBezierPath(currentSubpath, x0, y1, x0, y0), addLineToBezierPath(currentSubpath, x0, y0, x1, y0);
        break;
      case enumCommandMap.AT: {
        const tx1 = cmd[1], ty1 = cmd[2], tx2 = cmd[3], ty2 = cmd[4], r = cmd[5], dis1 = PointService.distancePP({
          x: xi,
          y: yi
        }, {
          x: tx1,
          y: ty1
        }), dis2 = PointService.distancePP({
          x: tx2,
          y: ty2
        }, {
          x: tx1,
          y: ty1
        }), theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2), dis = r / Math.sin(theta / 2), midX = (xi + tx2 - 2 * tx1) / 2, midY = (yi + ty2 - 2 * ty1) / 2, midLen = PointService.distancePP({
          x: midX,
          y: midY
        }, {
          x: 0,
          y: 0
        }), cx = tx1 + dis * midX / midLen, cy = tx2 + dis * midY / midLen, disP = Math.sqrt(dis * dis - r * r);
        x0 = tx1 + disP * (xi - tx1) / dis1, y0 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
        const startAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: x0,
          y: y0
        }), endAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: xi,
          y: yi
        });
        addArcToBezierPath(currentSubpath, startAngle, endAngle, cx, cy, r, r);
        break;
      }
      case enumCommandMap.Z:
        currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = x0, yi = y0;
    }
  }
  return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), bezierArrayGroups;
}
function applyTransformOnBezierCurves(bezierCurves, martrix) {
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    for (let k2 = 0; k2 < subPath.length; k2 += 2) {
      const x = subPath[k2], y = subPath[k2 + 1], res = {
        x,
        y
      };
      martrix.transformPoint({
        x,
        y
      }, res), subPath[k2] = res.x, subPath[k2 + 1] = res.y;
    }
  }
}
function bezierCurversToPath(bezierCurves) {
  const path = new CustomPath2D();
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    if (subPath.length > 2) {
      path.moveTo(subPath[0], subPath[1]);
      for (let k2 = 2; k2 < subPath.length; k2 += 6) path.bezierCurveTo(subPath[k2], subPath[k2 + 1], subPath[k2 + 2], subPath[k2 + 3], subPath[k2 + 4], subPath[k2 + 5]);
    }
  }
  return path;
}

// node_modules/@visactor/vrender-core/es/common/rect-utils.js
var normalizeRectAttributes = (attribute) => {
  if (!attribute) return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  let width = isNil_default(attribute.width) ? attribute.x1 - attribute.x : attribute.width, height = isNil_default(attribute.height) ? attribute.y1 - attribute.y : attribute.height, x = 0, y = 0;
  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x,
    y,
    width,
    height
  };
};

// node_modules/@visactor/vrender-core/es/common/split-path.js
function splitToGrids(width, height, count) {
  const ratio = width / height;
  let rowCount, columnCount;
  width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, rowCount = count));
  const grids = [];
  for (let i = 0; i < rowCount; i++) grids.push(columnCount);
  const remained = count - rowCount * columnCount;
  if (remained > 0) for (let i = 0; i < remained; i += columnCount) i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i);
  return grids;
}
var splitRect = (rect, count) => {
  const { width, height } = normalizeRectAttributes(rect.attribute), grids = splitToGrids(width, height, count), res = [], gridHeight = height / grids.length;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i], gridWidth = width / columnCount;
    for (let j = 0; j < columnCount; j++) res.push({
      x: 0 + j * gridWidth,
      y: 0 + i * gridHeight,
      width: gridWidth,
      height: gridHeight
    });
  }
  return res;
};
var splitArc = (arc, count) => {
  const angles = arc.getParsedAngle(), startAngle = angles.startAngle, endAngle = angles.endAngle, innerRadius = arc.getComputedAttribute("innerRadius"), outerRadius = arc.getComputedAttribute("outerRadius"), angleDelta = Math.abs(startAngle - endAngle), radiusDelta = Math.abs(outerRadius - innerRadius), grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count), res = [], gridRadius = radiusDelta / grids.length, radiusSign = outerRadius >= innerRadius ? 1 : -1, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i], gridAngle = angleDelta / columnCount;
    for (let j = 0; j < columnCount; j++) res.push({
      innerRadius: outerRadius - gridRadius * i * radiusSign,
      outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
      startAngle: startAngle + gridAngle * j * angleSign,
      endAngle: startAngle + gridAngle * (j + 1) * angleSign
    });
  }
  return res;
};
var splitCircle = (arc, count) => {
  const startAngle = arc.getComputedAttribute("startAngle"), endAngle = arc.getComputedAttribute("endAngle"), radius = arc.getComputedAttribute("radius"), angleDelta = Math.abs(startAngle - endAngle), grids = splitToGrids(angleDelta * radius, radius, count), res = [], gridAngle = angleDelta / grids[0], gridRadius = radius / grids.length, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) for (let j = 0, columnCount = grids[i]; j < columnCount; j++) res.push({
    innerRadius: gridRadius * i,
    outerRadius: gridRadius * (i + 1),
    startAngle: startAngle + gridAngle * j * angleSign,
    endAngle: startAngle + gridAngle * (j + 1) * angleSign
  });
  return res;
};
var samplingPoints = (points, count) => {
  const validatePoints = points.filter((point6) => false !== point6.defined && isNumber_default(point6.x) && isNumber_default(point6.y));
  if (0 === validatePoints.length) return [];
  if (1 === validatePoints.length) return new Array(count).fill(0).map((i) => validatePoints[0]);
  const res = [];
  if (count <= validatePoints.length) {
    const step = validatePoints.length / count;
    let i = 0, cur = 0;
    for (; i < count; ) res.push(validatePoints[Math.floor(cur)]), cur += step, i++;
    return res;
  }
  const insertCount = count - validatePoints.length, insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
  let curCount = 0;
  for (let i = 0, len = points.length; i < len; i++) if (res.push(points[i]), i < len - 1) {
    let cur = insetRatio;
    const xCur = points[i].x, yCur = points[i].y, xNext = points[i + 1].x, yNext = points[i + 1].y;
    for (; cur < 1 && curCount < insertCount; ) res.push({
      x: xCur + (xNext - xCur) * cur,
      y: yCur + (yNext - yCur) * cur
    }), cur += insetRatio, curCount += 1;
  }
  return res;
};
var splitArea = (area2, count) => {
  var _a, _b;
  const attribute = area2.attribute;
  let points = attribute.points;
  const segements = attribute.segments;
  points || (points = segements.reduce((res2, seg) => {
    var _a2;
    return res2.concat(null !== (_a2 = seg.points) && void 0 !== _a2 ? _a2 : []);
  }, []));
  const validatePoints = points.filter((point6) => false !== point6.defined && isNumber_default(point6.x) && isNumber_default(point6.y));
  if (!validatePoints.length) return [];
  const allPoints = [];
  validatePoints.forEach((point6) => {
    allPoints.push({
      x: point6.x,
      y: point6.y
    });
  });
  for (let i = validatePoints.length - 1; i >= 0; i--) {
    const point6 = validatePoints[i];
    allPoints.push({
      x: null !== (_a = point6.x1) && void 0 !== _a ? _a : point6.x,
      y: null !== (_b = point6.y1) && void 0 !== _b ? _b : point6.y
    });
  }
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitLine = (line2, count) => {
  const attribute = line2.attribute, points = attribute.points;
  if (points) return samplingPoints(points, count);
  if (attribute.segments) {
    const allPoints = attribute.segments.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, []);
    return samplingPoints(allPoints, count);
  }
  return [];
};
function crossProduct2(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
var clonePoints = (points) => points.map((p) => ({
  x: p.x,
  y: p.y
}));
var splitPolygonByLine = (points, p0, p1) => {
  const len = points.length, intersections = [];
  for (let i = 0; i < len; i++) {
    const cur = points[i], next = i === len - 1 ? points[0] : points[i + 1], res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
    res && "boolean" != typeof res && intersections.push({
      dot: crossProduct2([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
      point: {
        x: res[0],
        y: res[1]
      },
      edgeIndex: i
    });
  }
  if (intersections.length < 2) return [clonePoints(points), clonePoints(points)];
  intersections.sort((a3, b) => a3.dot - b.dot);
  let is0 = intersections[0], is1 = intersections[intersections.length - 1];
  is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [is1, is0]);
  const newP0 = is0.point, newP1 = is1.point, newPointsA = [{
    x: newP0.x,
    y: newP0.y
  }];
  for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) newPointsA.push({
    x: points[i].x,
    y: points[i].y
  });
  newPointsA.push({
    x: newP1.x,
    y: newP1.y
  });
  const newPointsB = [{
    x: newP1.x,
    y: newP1.y
  }];
  for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
    const p = points[i % len];
    newPointsB.push({
      x: p.x,
      y: p.y
    });
  }
  return newPointsB.push({
    x: newP0.x,
    y: newP0.y
  }), [newPointsA, newPointsB];
};
var binarySplitPolygon = (points) => {
  const box = new Bounds();
  points.forEach((point6) => {
    box.add(point6.x, point6.y);
  });
  const width = box.width(), height = box.height();
  if (width >= height) {
    const midX = box.x1 + width / 2;
    return splitPolygonByLine(points, {
      x: midX,
      y: box.y1
    }, {
      x: midX,
      y: box.y2
    });
  }
  const midY = box.y1 + height / 2;
  return splitPolygonByLine(points, {
    x: box.x1,
    y: midY
  }, {
    x: box.x2,
    y: midY
  });
};
var recursiveCallBinarySplit = (points, count, out) => {
  if (1 === count) out.push({
    points
  });
  else {
    const half = Math.floor(count / 2), res = binarySplitPolygon(points);
    recursiveCallBinarySplit(res[0], half, out), recursiveCallBinarySplit(res[1], count - half, out);
  }
};
var splitPolygon = (polygon, count) => {
  const points = polygon.attribute.points;
  if (!points || !points.length) return [];
  if (1 === count) return [{
    points: clonePoints(points)
  }];
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitPath = (path, count) => {
  const pathShape = path.getParsedPathShape(), bezierCurves = pathToBezierCurves(pathShape);
  if (!bezierCurves.length || count < 0) return [];
  const subPathCnt = bezierCurves.length;
  if (bezierCurves.length >= count) {
    const res2 = [], stepCount2 = Math.floor(bezierCurves.length / count);
    for (let i = 0; i < count; i++) {
      const curves = bezierCurves.slice(i * stepCount2, i === count - 1 ? subPathCnt : (i + 1) * stepCount2);
      res2.push({
        path: bezierCurversToPath(curves)
      });
    }
    return res2;
  }
  const res = [], stepCount = Math.floor(count / subPathCnt);
  let remain = count;
  for (let c3 = 0; c3 < subPathCnt; c3++) {
    const points = [];
    for (let i = 2, len = bezierCurves[c3].length; i < len; i += 2) points.push({
      x: bezierCurves[0][i],
      y: bezierCurves[0][i + 1]
    });
    recursiveCallBinarySplit(points, c3 === subPathCnt - 1 ? remain : stepCount, res), remain -= stepCount;
  }
  return res;
};

// node_modules/@visactor/vrender-core/es/color-string/store.js
var ColorType;
!function(ColorType2) {
  ColorType2[ColorType2.Color255 = 0] = "Color255", ColorType2[ColorType2.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
var ColorStore = class _ColorStore {
  static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
    if (size === ColorType.Color1) {
      const color2 = _ColorStore.store1[str];
      if (color2) return arr[0] = color2[0], arr[1] = color2[1], arr[2] = color2[2], arr[3] = color2[3], arr;
      const c4 = Color.parseColorString(str);
      if (c4) {
        const data = [c4.r / 255, c4.g / 255, c4.b / 255, c4.opacity];
        _ColorStore.store1[str] = data, _ColorStore.store255[str] = [c4.r, c4.g, c4.b, c4.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = _ColorStore.store255[str];
    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c3 = Color.parseColorString(str);
    return c3 && (_ColorStore.store1[str] = [c3.r / 255, c3.g / 255, c3.b / 255, c3.opacity], _ColorStore.store255[str] = [c3.r, c3.g, c3.b, c3.opacity], arr[0] = c3.r, arr[1] = c3.g, arr[2] = c3.b, arr[3] = c3.opacity), arr;
  }
  static Set(str, size, arr) {
    if (size === ColorType.Color1) {
      if (_ColorStore.store1[str]) return;
      _ColorStore.store1[str] = arr, _ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (_ColorStore.store255[str]) return;
      _ColorStore.store255[str] = arr, _ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
};
ColorStore.store255 = {}, ColorStore.store1 = {};

// node_modules/@visactor/vrender-core/es/color-string/interpolate.js
function colorArrayToString(color, alphaChannel = false) {
  return Array.isArray(color) && isNumber_default(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (Array.isArray(from) && !isNumber_default(from[0]) || Array.isArray(to) && !isNumber_default(to[0])) {
    return new Array(4).fill(0).map((_, index) => _interpolateColor(isArray_default(from) ? from[index] : from, isArray_default(to) ? to[index] : to, ratio, alphaChannel));
  }
  return _interpolateColor(from, to, ratio, alphaChannel, cb);
}
function _interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || false;
  let fromArray, toArray, fromGradient = false, toGradient = false;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = true, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = true, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
      stops: gradient.stops.map((v) => Object.assign(Object.assign({}, v), {
        color: colorArrayToString(pure)
      }))
    });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
      if (fromStops.length !== toStops.length) return false;
      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return false;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
var _fromColorRGB = [0, 0, 0, 0];
var _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

// node_modules/@visactor/vrender-core/es/color-string/colorName.js
var parsedColors = {};
Object.keys(DEFAULT_COLORS).forEach((k2) => {
  const c3 = DEFAULT_COLORS[k2];
  parsedColors[k2] = [c3 >> 16 & 255, c3 >> 8 & 255, 255 & c3];
});

// node_modules/@visactor/vrender-core/es/animate/morphing.js
var interpolateOtherAttrs = (attrs, out, ratio) => {
  attrs.forEach((entry) => {
    if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio;
    else if ("fill" === entry.key || "stroke" === entry.key) {
      const color = interpolateColor(entry.from, entry.to, ratio, false);
      color && (out[entry.key] = color);
    }
  });
};
var interpolateMorphingData = (morphingData, path, ratio) => {
  const tmpArr = [], newCp = [];
  path.clear();
  for (let i = 0; i < morphingData.length; i++) {
    const item = morphingData[i], from = item.from, to = item.to, angle2 = item.rotation * ratio, fromCp = item.fromCp, toCp = item.toCp, sa = Math.sin(angle2), ca = Math.cos(angle2);
    newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
    for (let m4 = 0; m4 < from.length; m4 += 2) {
      const x02 = from[m4], y02 = from[m4 + 1], x = x02 * (1 - ratio) + to[m4] * ratio, y = y02 * (1 - ratio) + to[m4 + 1] * ratio;
      tmpArr[m4] = x * ca - y * sa + newCp[0], tmpArr[m4 + 1] = x * sa + y * ca + newCp[1];
    }
    let x0 = tmpArr[0], y0 = tmpArr[1];
    path.moveTo(x0, y0);
    for (let m4 = 2; m4 < from.length; m4 += 6) {
      const x1 = tmpArr[m4], y1 = tmpArr[m4 + 1], x2 = tmpArr[m4 + 2], y2 = tmpArr[m4 + 3], x3 = tmpArr[m4 + 4], y3 = tmpArr[m4 + 5];
      x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x1, y1, x2, y2, x3, y3), x0 = x3, y0 = y3;
    }
  }
};
var parseMorphingData = (fromPath, toPath, config2) => {
  const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [], toBezier = pathToBezierCurves(toPath);
  config2 && fromBezier && (config2.fromTransform && applyTransformOnBezierCurves(fromBezier, config2.fromTransform.clone().getInverse()), applyTransformOnBezierCurves(fromBezier, config2.toTransfrom));
  const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
  return fromPath ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map((to, index) => ({
    from: fromBezierCurves[index],
    to,
    fromCp: [0, 0],
    toCp: [0, 0],
    rotation: 0
  }));
};
var validateOtherAttrs = ["fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset"];
var parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
  if (!fromAttrs || !toAttrs) return null;
  const res = [];
  let hasAttr = false;
  return Object.keys(fromAttrs).forEach((fromKey) => {
    if (!validateOtherAttrs.includes(fromKey)) return;
    const toValue = toAttrs[fromKey];
    isNil_default(toValue) || isNil_default(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
      from: "string" == typeof fromAttrs[fromKey] ? ColorStore.Get(fromAttrs[fromKey], ColorType.Color255) : fromAttrs[fromKey],
      to: "string" == typeof toValue ? ColorStore.Get(toValue, ColorType.Color255) : toValue,
      key: fromKey
    }) : res.push({
      from: fromAttrs[fromKey],
      to: toValue,
      key: fromKey
    }), hasAttr = true);
  }), hasAttr ? res : null;
};
var MorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs, this.saveOnEnd = config2.saveOnEnd;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.createPathProxy(), this.onUpdate(false, 0, this.target.attribute);
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    const target = this.target, pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
    interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), end && !this.saveOnEnd && (this.target.pathProxy = null);
  }
};
var morphPath = (fromGraphic, toGraphic, animationConfig2, fromGraphicTransform) => {
  var _a, _b, _c;
  if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, " is not validate"), null;
  if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, " is not validate"), null;
  let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
  fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
  const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
    fromTransform,
    toTransfrom: toGraphic.globalTransMatrix
  }), attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute), animate = toGraphic.animate(animationConfig2);
  return (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MorphingPath({
    morphingData,
    otherAttrs: attrs
  }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing)), animate;
};
var oneToMultiMorph = (fromGraphic, toGraphics, animationConfig2) => {
  var _a;
  const validateToGraphics = toGraphics.filter((graphic) => graphic && graphic.toCustomPath && graphic.valid);
  validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, false), oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd;
  let count = validateToGraphics.length;
  const onEachEnd = () => {
    count--, 0 === count && oldOnEnd && oldOnEnd();
  };
  validateToGraphics.forEach((toChild, index) => {
    var _a2;
    const fromChild = childGraphics[index], delay = (null !== (_a2 = null == animationConfig2 ? void 0 : animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + ((null == animationConfig2 ? void 0 : animationConfig2.individualDelay) ? animationConfig2.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
    morphPath(fromChild, toChild, Object.assign({}, animationConfig2, {
      onEnd: onEachEnd,
      delay
    }), fromGraphic.globalTransMatrix);
  });
};
var MultiToOneMorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.addPathProxy();
  }
  addPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.createPathProxy();
    }), this.onUpdate(false, 0, this.target.attribute);
  }
  clearPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.pathProxy = null;
    });
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    this.target.shadowRoot.forEachChildren((child, index) => {
      var _a;
      interpolateMorphingData(this.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
    }), end && (this.clearPathProxy(), this.morphingData = null);
  }
};
var parseShadowChildAttrs = (graphicAttrs) => {
  const attrs = {};
  return Object.keys(graphicAttrs).forEach((key) => {
    isTransformKey(key) || (attrs[key] = graphicAttrs[key]);
  }), attrs;
};
var appendShadowChildrenToGraphic = (graphic, children, count) => {
  const childAttrs = parseShadowChildAttrs(graphic.attribute), shadowRoot = graphic.attachShadow();
  if (children.length) shadowRoot.setTheme({
    [children[0].type]: childAttrs
  }), children.forEach((element) => {
    element.setAttributes({
      pickable: false
    }), shadowRoot.appendChild(element);
  });
  else {
    const box = graphic.AABBBounds, width = box.width(), height = box.height();
    shadowRoot.setTheme({
      rect: childAttrs
    }), new Array(count).fill(0).forEach((el) => {
      const child = application.graphicService.creator.rect({
        x: 0,
        y: 0,
        width,
        height,
        pickable: false
      });
      shadowRoot.appendChild(child), children.push(child);
    });
  }
};
var cloneGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute), path = graphic.toCustomPath();
  for (let i = 0; i < count; i++) {
    const element = {
      path: new CustomPath2D().fromCustomPath2D(path)
    };
    children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var splitGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
  if ("rect" === graphic.type) {
    splitRect(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("arc" === graphic.type) {
    splitArc(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("circle" === graphic.type) {
    splitCircle(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("line" === graphic.type) {
    const childrenAttrs = splitLine(graphic, count), defaultSymbol = {
      size: 10,
      symbolType: "circle"
    };
    childrenAttrs.forEach((element) => {
      children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
    });
  } else if ("polygon" === graphic.type) {
    splitPolygon(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("area" === graphic.type) {
    splitArea(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("path" === graphic.type) {
    splitPath(graphic, count).forEach((element) => {
      "path" in element ? children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var multiToOneMorph = (fromGraphics, toGraphic, animationConfig2) => {
  var _a, _b, _c;
  const validateFromGraphics = fromGraphics.filter((graphic) => graphic.toCustomPath && graphic.valid);
  validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, true), toAttrs = toGraphic.attribute;
  toGraphic.setAttribute("visible", false);
  const morphingData = validateFromGraphics.map((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
    fromTransform: graphic.globalTransMatrix,
    toTransfrom: childGraphics[index].globalTransMatrix
  })), otherAttrs = validateFromGraphics.map((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs));
  if (null == animationConfig2 ? void 0 : animationConfig2.individualDelay) {
    const oldOnEnd = animationConfig2.onEnd;
    let count = validateFromGraphics.length;
    const onEachEnd = () => {
      count--, 0 === count && (toGraphic.setAttributes({
        visible: true,
        ratio: null
      }, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
    };
    childGraphics.forEach((to, index) => {
      var _a2, _b2, _c2;
      const delay = (null !== (_a2 = animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + animationConfig2.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to), animate = to.animate(Object.assign({}, animationConfig2, {
        onEnd: onEachEnd
      }));
      animate.wait(delay), animate.play(new MorphingPath({
        morphingData: morphingData[index],
        saveOnEnd: true,
        otherAttrs: otherAttrs[index]
      }, null !== (_b2 = animationConfig2.duration) && void 0 !== _b2 ? _b2 : DefaultMorphingAnimateConfig.duration, null !== (_c2 = animationConfig2.easing) && void 0 !== _c2 ? _c2 : DefaultMorphingAnimateConfig.easing));
    });
  } else {
    const oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd, config2 = animationConfig2 ? Object.assign({}, animationConfig2) : {};
    config2.onEnd = () => {
      toGraphic.setAttribute("visible", true, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();
    };
    const animate = toGraphic.animate(config2);
    (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MultiToOneMorphingPath({
      morphingData,
      otherAttrs
    }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
  }
};

// node_modules/@visactor/vrender-core/es/animate/group-fade.js
var GroupFadeIn = class extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: ratio
      }
    });
  }
};
var GroupFadeOut = class extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: 1 - ratio
      }
    });
  }
};

// node_modules/@visactor/vrender-core/es/resource-loader/loader.js
var ResourceLoader = class _ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    const data = _ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : _ResourceLoader.loadImage(url, mark);
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = _ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, _ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then((res) => {
      var _a2;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a2 = data.waitingMark) || void 0 === _a2 || _a2.map((mark2, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark2.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark2.imageLoadFail(svgStr));
      }), data.waitingMark && (data.waitingMark = []);
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = _ResourceLoader.cache.get(url);
    return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then((data2) => data2.data) : Promise.resolve(data.data) : (data = {
      type,
      loadState: "init"
    }, _ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then((data2) => data2.data));
  }
  static loading() {
    setTimeout(() => {
      if (!_ResourceLoader.isLoading && _ResourceLoader.toLoadAueue.length) {
        _ResourceLoader.isLoading = true;
        const tasks = _ResourceLoader.toLoadAueue.splice(0, 10), promises = [];
        tasks.forEach((task) => {
          const { url, marks } = task, data = {
            type: "image",
            loadState: "init"
          };
          if (_ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
            data.waitingMark = marks;
            const end = data.dataPromise.then((res) => {
              var _a;
              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
              }), data.waitingMark && (data.waitingMark = []);
            });
            promises.push(end);
          } else data.loadState = "fail", marks.forEach((mark) => mark.imageLoadFail(url));
        }), Promise.all(promises).then(() => {
          _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        }).catch((error3) => {
          console.error(error3), _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        });
      }
    }, 0);
  }
  static loadImage(url, mark) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index) return _ResourceLoader.toLoadAueue[index].marks.push(mark), void _ResourceLoader.loading();
    _ResourceLoader.toLoadAueue.push({
      url,
      marks: [mark]
    }), _ResourceLoader.loading();
  }
  static improveImageLoading(url) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index) {
      const elememt = _ResourceLoader.toLoadAueue.splice(index, 1);
      _ResourceLoader.toLoadAueue.unshift(elememt[0]);
    }
  }
  static onLoadSuccess(cb) {
    this.onLoadSuccessCb.push(cb);
  }
};
function getIndex(url, arr) {
  for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
  return -1;
}
ResourceLoader.cache = /* @__PURE__ */ new Map(), ResourceLoader.isLoading = false, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/base.js
var BaseSymbol = class {
  bounds(size, bounds) {
    if (isNumber_default(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
  parseSize(size) {
    return isNumber_default(size) ? size : Math.min(size[0], size[1]);
  }
};

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/circle.js
function circle(ctx, r, x, y, z) {
  return z ? ctx.arc(x, y, r, 0, tau, false, z) : ctx.arc(x, y, r, 0, tau), false;
}
var CircleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return circle(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return circle(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
  }
};
var circle_default = new CircleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/cross.js
function cross(ctx, r, x, y, z) {
  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), true;
}
function crossOffset(ctx, r, x, y, offset, z) {
  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), true;
}
var CrossSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x, y, z) {
    return cross(ctx, this.parseSize(size) / 6, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
  }
};
var cross_default = new CrossSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/diamond.js
function diamond(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), true;
}
var DiamondSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawFitDir(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return diamond(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
};
var diamond_default = new DiamondSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/square.js
function square(ctx, r, x, y) {
  const wh = 2 * r;
  return ctx.rect(x - r, y - r, wh, wh), false;
}
var SquareSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x, y) {
    return square(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return square(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
};
var square_default = new SquareSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-up.js
function trianglUpOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleUpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_up_default = new TriangleUpSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle.js
var TriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
};
var triangle_default = new TriangleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/star.js
var kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
  const x = kx * r, y = ky * r;
  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
  for (let i = 1; i < 5; ++i) {
    const a3 = tau * i / 5, c3 = Math.cos(a3), s2 = Math.sin(a3);
    ctx.lineTo(s2 * r + transX, -c3 * r + transY), ctx.lineTo(c3 * x - s2 * y + transX, s2 * x + c3 * y + transY);
  }
  return ctx.closePath(), true;
}
var StarSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var star_default = new StarSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow.js
var sqrt3 = sqrt(3);
function arrow(ctx, r, transX, transY) {
  const triangleH = r, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), true;
}
var ArrowSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var arrow_default = new ArrowSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wedge.js
function wedge(ctx, r, transX, transY) {
  const h = 2 * r;
  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), true;
}
var WedgeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var wedge_default = new WedgeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/stroke.js
function stroke(ctx, r, transX, transY) {
  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), false;
}
var StrokeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var stroke_default = new StrokeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wye.js
var c = -0.5;
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = 3 * (k / 2 + 1);
function wye(ctx, r, transX, transY) {
  const x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
  return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), false;
}
var WyeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
};
var wye_default = new WyeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-left.js
function trianglLeftOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleLeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_left_default = new TriangleLeftSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-right.js
function trianglRightOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleRightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_right_default = new TriangleRightSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-down.js
function trianglDownOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), true;
}
var TriangleDownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
};
var triangle_down_default = new TriangleDownSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/thin-triangle.js
var sqrt32 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
  const h = r * sqrt32;
  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), true;
}
var ThinTriangleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x, y) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt32, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt32 + offset, x, y);
  }
};
var thin_triangle_default = new ThinTriangleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-left.js
function arrow2Left(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), true;
}
var Arrow2LeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_left_default = new Arrow2LeftSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-right.js
function arrow2Right(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), true;
}
var Arrow2RightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_right_default = new Arrow2RightSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-up.js
function arrow2Up(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), true;
}
var Arrow2UpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_up_default = new Arrow2UpSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-down.js
function arrow2Down(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), true;
}
var Arrow2DownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
};
var arrow2_down_default = new Arrow2DownSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-v.js
function lineV(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), true;
}
var LineVSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x, y, z) {
    return lineV(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineV(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x}, ${y - r} L ${x},${y + r}`;
  }
};
var line_v_default = new LineVSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-h.js
function lineH(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), true;
}
var LineHSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return lineH(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineH(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} L ${x + r},${y}`;
  }
};
var line_h_default = new LineHSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/close.js
function close(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), true;
}
var CloseSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x, y, z) {
    return close(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return close(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
  }
};
var close_default = new CloseSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/rect.js
function rectSizeArray(ctx, size, x, y) {
  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), false;
}
function rectSize(ctx, size, x, y) {
  const w = size, h = size / 2;
  return ctx.rect(x - w / 2, y - h / 2, w, h), false;
}
var RectSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x, y) {
    return isNumber_default(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    isNumber_default(size) && (size = [size, size / 2]);
    const drawLength = 2 * (size[0] + size[1]) * clipRange, points = [{
      x: x + size[0] / 2,
      y: y - size[1] / 2
    }, {
      x: x + size[0] / 2,
      y: y + size[1] / 2
    }, {
      x: x - size[0] / 2,
      y: y + size[1] / 2
    }, {
      x: x - size[0] / 2,
      y: y - size[1] / 2
    }];
    let currLength = 0, lastP = points[3];
    ctx.moveTo(lastP.x, lastP.y);
    for (let i = 0; i < points.length; i++) {
      const p = points[i], len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
      if (currLength + len > drawLength) {
        const dx = (p.x - lastP.x) * (drawLength - currLength) / len, dy = (p.y - lastP.y) * (drawLength - currLength) / len;
        ctx.lineTo(lastP.x + dx, lastP.y + dy);
        break;
      }
      ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
    }
    return false;
  }
  drawOffset(ctx, size, x, y, offset) {
    return isNumber_default(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
  }
};
var rect_default = new RectSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/utils.js
var tempBounds = new AABBBounds();
var CustomSymbolClass = class {
  constructor(type, path, isSvg2 = false) {
    this.pathStr = "", this.type = type, isArray_default(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg2;
  }
  drawOffset(ctx, size, x, y, offset, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), false);
  }
  draw(ctx, size, x, y, z, cb) {
    return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
  }
  parseSize(size) {
    return isNumber_default(size) ? size : Math.min(size[0], size[1]);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
    }), false) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), false);
  }
  bounds(size, bounds) {
    if (size = this.parseSize(size), this.isSvg) {
      if (!this.svgCache) return;
      return bounds.clear(), void this.svgCache.forEach(({ path }) => {
        tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, bounds.union(tempBounds);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
};

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/index.js
var builtinSymbols = [circle_default, cross_default, diamond_default, square_default, thin_triangle_default, triangle_default, star_default, arrow_default, wedge_default, stroke_default, wye_default, triangle_left_default, triangle_right_default, triangle_up_default, triangle_down_default, arrow2_left_default, arrow2_right_default, arrow2_up_default, arrow2_down_default, rect_default, line_v_default, line_h_default, close_default];
var builtinSymbolsMap = {};
builtinSymbols.forEach((symbol) => {
  builtinSymbolsMap[symbol.type] = symbol;
});
var builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

// node_modules/@visactor/vrender-core/es/common/xml/utils.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match; ) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

// node_modules/@visactor/vrender-core/es/common/xml/OrderedObjParser.js
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
};
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (-1 === closingIndex) throw new Error(errMsg);
  return closingIndex + str.length - 1;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary, tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");
    else if ('"' === ch || "'" === ch) attrBoundary = ch;
    else if (ch === closingChar[0]) {
      if (!closingChar[1]) return {
        data: tagExp,
        index
      };
      if (xmlData[index + 1] === closingChar[1]) return {
        data: tagExp,
        index
      };
    } else "	" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result2 = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result2) return;
  let tagExp = result2.data;
  const closeIndex = result2.index, separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp, attrExpPresent = true;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result2.data.substr(colonIndex + 1));
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
var OrderedObjParser = class {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result2 = childNode.tagname;
    "string" == typeof result2 ? (childNode.tagname = result2, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr) return;
    const matches = getAllMatches(attrStr, attrsRegx), len = matches.length;
    for (let i = 0; i < len; i++) {
      const attrName = matches[i][1], oldVal = matches[i][4], aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj, textData = "", jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      if ("<" === xmlData[i]) if ("/" === xmlData[i + 1]) {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."), propIndex = jPath.lastIndexOf(".");
        jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
      } else if ("?" === xmlData[i + 1]) {
        i = readTagExp(xmlData, i, false, "?>").closeIndex + 1;
      } else if ("!--" === xmlData.substr(i + 1, 3)) {
        i = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
      } else {
        const result2 = readTagExp(xmlData, i, false);
        let tagName = result2.tagName, tagExp = result2.tagExp;
        const attrExpPresent = result2.attrExpPresent, closeIndex = result2.closeIndex;
        if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
          "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
          const childNode = new XmlNode(tagName);
          tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
        } else {
          const childNode = new XmlNode(tagName);
          this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
        }
        textData = "", i = closeIndex;
      }
      else textData += xmlData[i];
    }
    return xmlObj.child;
  }
};

// node_modules/@visactor/vrender-core/es/common/xml/node2json.js
function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i], property = propName(tagObj);
    let newJpath = "";
    if (newJpath = void 0 === jPath ? property : jPath + "." + property, void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property], newJpath);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"], newJpath), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (":@" !== key) return key;
  }
}
function assignAttributes(obj, attrMap, jpath) {
  if (attrMap) {
    const keys = Object.keys(attrMap), len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      obj[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj) {
  return 0 === Object.keys(obj).length;
}

// node_modules/@visactor/vrender-core/es/common/xml/parser.js
var XMLParser = class _XMLParser {
  constructor(options) {
    this.options = Object.assign({}, _XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid) return false;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
};
XMLParser.defaultOptions = {};
function isSvg(str) {
  return str.startsWith("<svg") || str.startsWith("<?xml");
}

// node_modules/@visactor/vrender-core/es/graphic/tools.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function waitForAllSubLayers(stage) {
  return __awaiter3(this, void 0, void 0, function* () {
    const promiseList = [], layers = stage.getChildren();
    yield new Promise((resolve) => {
      application.global.getRequestAnimationFrame()(() => {
        resolve(null);
      });
    }), layers.forEach((l) => {
      l.subLayers.size && l.subLayers.forEach((sl) => {
        sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise((resolve) => {
          sl.drawContribution.hooks.completeDraw.tap("outWait", () => {
            sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter((i) => "outWait" !== i.name), resolve(null);
          });
        }));
      });
    }), yield Promise.all(promiseList);
  });
}
function boundStroke(bounds, halfW, miter, pad = 0) {
  return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
var NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function(TextDirection2) {
  TextDirection2[TextDirection2.HORIZONTAL = 0] = "HORIZONTAL", TextDirection2[TextDirection2.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text2) {
  const nextCharacter = [];
  let flag = 0, currStr = "";
  for (let i = 0; i < text2.length; i++) rotateText(text2[i]) ? flag ? currStr += text2[i] : (flag = 1, currStr = text2[i]) : (flag && (nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), currStr = "", flag = 0), nextCharacter.push({
    text: text2[i],
    direction: TextDirection.HORIZONTAL
  }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
var rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"];
var rotateCharMap = /* @__PURE__ */ new Map();
rotateCharList.forEach((c3) => rotateCharMap.set(c3, true));
var noRotateCharList = [""];
var noRotateCharMap = /* @__PURE__ */ new Map();
function rotateText(c3) {
  if (rotateCharMap.has(c3)) return true;
  if (noRotateCharMap.has(c3)) return false;
  let rotate = false;
  return c3.codePointAt(0) < 256 && (rotate = true), rotate;
}
noRotateCharList.forEach((c3) => noRotateCharMap.set(c3, true));

// node_modules/@visactor/vrender-core/es/graphic/constants.js
var ARC_NUMBER_TYPE = genNumberType();
var ARC3D_NUMBER_TYPE = genNumberType();
var AREA_NUMBER_TYPE = genNumberType();
var CIRCLE_NUMBER_TYPE = genNumberType();
var GLYPH_NUMBER_TYPE = genNumberType();
var GROUP_NUMBER_TYPE = genNumberType();
var IMAGE_NUMBER_TYPE = genNumberType();
var LINE_NUMBER_TYPE = genNumberType();
var PATH_NUMBER_TYPE = genNumberType();
var POLYGON_NUMBER_TYPE = genNumberType();
var PYRAMID3D_NUMBER_TYPE = genNumberType();
var RECT_NUMBER_TYPE = genNumberType();
var RECT3D_NUMBER_TYPE = genNumberType();
var RICHTEXT_NUMBER_TYPE = genNumberType();
var STAR_NUMBER_TYPE = genNumberType();
var SYMBOL_NUMBER_TYPE = genNumberType();
var TEXT_NUMBER_TYPE = genNumberType();
var GraphicService = Symbol.for("GraphicService");
var GraphicCreator = Symbol.for("GraphicCreator");
var SVG_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity"
};
var SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
var SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
var SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

// node_modules/@visactor/vrender-core/es/graphic/graphic.js
var _tempBounds = new AABBBounds();
var tempMatrix = new Matrix();
var tempBounds2 = new AABBBounds();
var GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
var tempConstantXYKey = ["x", "y"];
var tempConstantScaleXYKey = ["scaleX", "scaleY"];
var tempConstantAngleKey = ["angle"];
var point4 = new Point();
var NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  globalZIndex: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
var Graphic = class _Graphic extends Node {
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(_Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds();
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(true);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(true);
  }
  constructor(params2 = {}) {
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params2, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params2.background ? this.loadImage(null !== (_a = params2.background.background) && void 0 !== _a ? _a : params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic);
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  getOffsetXY(attr, includeScroll = false) {
    var _a, _b;
    const { dx = attr.dx, dy = attr.dy } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point4.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point4.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else point4.x = dx, point4.y = dy;
    return point4;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds() {
    const full = "imprecise" === this.attribute.boundsMode;
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  tryUpdateOBBBounds() {
    if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
    if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
    return this.doUpdateOBBBounds();
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b = this.shadowRoot.AABBBounds.clone();
      bounds.union(b);
    }
  }
  doUpdateOBBBounds() {
    return this._OBBBounds;
  }
  getClipPath() {
    const { clipConfig } = this.attribute;
    if (!clipConfig) return null;
    this.clipPathMap || (this.clipPathMap = /* @__PURE__ */ new Map());
    const { shape } = clipConfig;
    let path = this.clipPathMap.get(shape) || null;
    return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
  }
  parsePath(symbolType) {
    if (!symbolType) return null;
    let path = builtinSymbolsMap[symbolType];
    if (path) return path;
    if (path = _Graphic.userSymbolMap[symbolType], path) return path;
    const _symbolType = builtInSymbolStrMap[symbolType];
    if (true === isSvg(symbolType = _symbolType || symbolType)) {
      const parser = new XMLParser(), { svg } = parser.parse(symbolType);
      if (!svg) return null;
      const path2 = isArray_default(svg.path) ? svg.path : [svg.path];
      _tempBounds.clear();
      const cacheList = [];
      path2.forEach((item) => {
        const cache2 = new CustomPath2D().fromString(item.d), attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((k2) => {
          item[k2] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k2]] = item[k2]);
        }), cacheList.push({
          path: cache2,
          attribute
        }), _tempBounds.union(cache2.bounds);
      });
      const width2 = _tempBounds.width(), height2 = _tempBounds.height(), scale5 = 1 / max(width2, height2);
      cacheList.forEach((cache2) => cache2.path.transform(0, 0, scale5, scale5));
      const _parsedPath2 = new CustomSymbolClass(symbolType, cacheList, true);
      return _Graphic.userSymbolMap[symbolType] = _parsedPath2, _parsedPath2;
    }
    const cache = new CustomPath2D().fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale4 = 1 / max(width, height);
    cache.transform(0, 0, scale4, scale4);
    const _parsedPath = new CustomSymbolClass(symbolType, cache);
    return _Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
  }
  doUpdateAABBBounds(full) {
    this.updateAABBBoundsStamp++;
    const graphicTheme = this.getGraphicTheme();
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full), { boundsPadding = graphicTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updatePathProxyAABBBounds(aabbBounds) {
    const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
    if (!path) return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  tryUpdateGlobalAABBBounds() {
    const b = this.AABBBounds;
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m4 = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
      }
    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return true;
  }
  tryUpdateLocalTransMatrix(clearTag = true) {
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x, y, mode, picker) {
    if (!picker) return false;
    if (mode === IContainPointMode.GLOBAL) {
      const point6 = new Point(x, y);
      this.parent && this.parent.globalTransMatrix.transformPoint(point6, point6), x = point6.x, y = point6.y;
    }
    return picker.containsPoint(this, {
      x,
      y
    });
  }
  setWidthHeightWithoutTransform(aabbBounds) {
    this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    (params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2).background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._setAttributes(params2, forceUpdateTag, context);
  }
  _setAttributes(params2, forceUpdateTag = false, context) {
    const keys = Object.keys(params2);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.attribute[key] = params2[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params2 ? this._setAttributes(params2, forceUpdateTag, context) : isNil_default(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, true) : "shadowGraphic" === key && this.setShadowGraphic(value);
  }
  needUpdateTags(keys, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      const attrKey = k2[i];
      if (-1 !== keys.indexOf(attrKey)) return true;
    }
    return false;
  }
  needUpdateTag(key, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      if (key === k2[i]) return true;
    }
    return false;
  }
  initAttributes(params2) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this.attribute = params2, params2.background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x, y) {
    var _a, _b;
    if (0 === x && 0 === y) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    params2 && (x = params2.x, y = params2.y, delete params2.x, delete params2.y, this._setAttributes(params2));
    const attribute = this.attribute, postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x, y) {
    const attribute = this.attribute;
    if (attribute.x === x && attribute.y === y) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY,
      scaleCenter
    }, this.attribute, tempConstantScaleXYKey, context);
    params2 && (scaleX = params2.scaleX, scaleY = params2.scaleY, delete params2.scaleX, delete params2.scaleY, this._setAttributes(params2));
    const attribute = this.attribute;
    if (scaleCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY
    }, this.attribute, tempConstantScaleXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle2, rotateCenter) {
    var _a;
    if (0 === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      angle: angle2,
      rotateCenter
    }, this.attribute, tempConstantAngleKey, context);
    params2 && (delete params2.angle, this._setAttributes(params2, false, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle2, rotateCenter);
    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle2;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle2) {
    const attribute = this.attribute;
    if (attribute.angle === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle2, this.attribute, tempConstantAngleKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.angle = angle2, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b, c3) {
    return this;
  }
  animate(params2) {
    var _a;
    this.animates || (this.animates = /* @__PURE__ */ new Map());
    const animate = new Animate(null == params2 ? void 0 : params2.id, null !== (_a = null == params2 ? void 0 : params2.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline(), null == params2 ? void 0 : params2.slience);
    if (animate.bind(this), params2) {
      const { onStart, onFrame, onEnd, onRemove } = params2;
      null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params2.interpolate;
    }
    return this.animates.set(animate.id, animate), animate.onRemove(() => {
      animate.stop(), this.animates.delete(animate.id);
    }), animate;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d) {
    d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil_default(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b, _c, _d;
    if (hasAnimation) {
      const keys = Object.keys(attrs), noWorkAttrs = this.getNoWorkAnimateAttr(), animateAttrs = {};
      let noAnimateAttrs;
      keys.forEach((key) => {
        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      });
      const animate = this.animate({
        slience: true
      });
      animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, false, {
        type: AttributeUpdateType.STATE
      });
    } else this.stopStateAnimates(), this.setAttributes(attrs, false, {
      type: AttributeUpdateType.STATE
    });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach((key) => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach((key) => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach((key) => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  stopStateAnimates(type = "end") {
    this.animates && this.animates.forEach((animate) => {
      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
    });
  }
  getNormalAttribute(key) {
    let value = this.attribute[key];
    return this.animates && this.animates.forEach((animate) => {
      if (animate.stateNames) {
        const endProps = animate.getEndProps();
        has_default(endProps, key) && (value = endProps[key]);
      }
    }), value;
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if (this.currentStates) {
      const filter2 = isArray_default(stateName) ? (s2) => !stateName.includes(s2) : (s2) => s2 !== stateName, newStates = this.currentStates.filter(filter2);
      newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);
    else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {};
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a2 = this.states) || void 0 === _a2 ? void 0 : _a2[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params2, resetScale) {
    const _anchor = [0, 0], getBounds = () => {
      if (params2.b) return params2.b;
      const graphic = this.clone();
      return graphic.attribute.angle = 0, graphic.attribute.scaleCenter = null, resetScale && (graphic.attribute.scaleX = 1, graphic.attribute.scaleY = 1), params2.b = graphic.AABBBounds, params2.b;
    };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100, bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100, bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, scaleCenter, anchor, postMatrix } = this.attribute;
    let _anchor = [0, 0];
    const params2 = {};
    if (anchor && angle2 && (_anchor = this.getAnchor(anchor, params2)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle2, anchor && _anchor);
    else {
      const m4 = this._transMatrix;
      m4.reset(), m4.translate(_anchor[0], _anchor[1]), m4.rotate(angle2), m4.translate(-_anchor[0], -_anchor[1]), m4.translate(x, y), _anchor = this.getAnchor(scaleCenter, params2, true), application.transformUtil.fromMatrix(m4, m4).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m22 = this._transMatrix;
      m1.multiply(m22.a, m22.b, m22.c, m22.d, m22.e, m22.f), m22.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach((a3) => {
          a3.timeline === defaultTimeline && a3.setTimeline(timeline);
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {
  }
  onStop(props) {
    props && this.setAttributes(props, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onStep(subAnimate, animate, step, ratio, end) {
    const nextAttributes = {};
    if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);
    else {
      const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;
      this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
    }
    this.setAttributes(nextAttributes, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end,
        step,
        isFirstFrameOfStep: subAnimate.getLastStep() !== step
      }
    }), this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
    propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key) => {
      animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
    }) : propKeys.forEach((key) => {
      var _a;
      if (!animate.validAttr(key)) return;
      const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
      if (null == nextStepVal || null == lastStepVal || nextStepVal === lastStepVal) return void (nextAttributes[key] = nextStepVal);
      let match;
      match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
    }), step.parsedProps = nextParsedProps;
  }
  defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
    if (Number.isFinite(nextStepVal) && Number.isFinite(lastStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, true;
    if ("fill" === key) {
      nextParsedProps || (nextParsedProps = {});
      const fillColorArray = nextParsedProps.fillColorArray, color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.fillColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("stroke" === key) {
      nextParsedProps || (nextParsedProps = {});
      const strokeColorArray = nextParsedProps.strokeColorArray, color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.strokeColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("shadowColor" === key) {
      nextParsedProps || (nextParsedProps = {});
      const shadowColorArray = nextParsedProps.shadowColorArray, color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, true, (fArray, tArray) => {
        nextParsedProps.shadowColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if (Array.isArray(nextStepVal) && nextStepVal.length === lastStepVal.length) {
      const nextList = [];
      let valid = true;
      for (let i = 0; i < nextStepVal.length; i++) {
        const v = lastStepVal[i], val = v + (nextStepVal[i] - v) * ratio;
        if (!Number.isFinite(val)) {
          valid = false;
          break;
        }
        nextList.push(val);
      }
      valid && (nextAttributes[key] = nextList);
    }
    return false;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
  }
  getDefaultAttribute(name) {
    return this.getGraphicTheme()[name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb, immediate = false) {
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(true), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((item) => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString_default(path, true) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image, background = false) {
    if (!image || background && backgroundNotImage(image)) return;
    const url = image;
    this.resources || (this.resources = /* @__PURE__ */ new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl_default(image) || image.includes("/") || isBase64_default(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject_default(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
  }
  setShadowGraphic(graphic) {
    if (graphic) {
      this.attachShadow().add(graphic);
    } else this.detachShadow();
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach((animate) => {
      animate.stop();
    });
  }
  stopAnimates(stopChildren = false) {
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(true), this.isContainer && stopChildren && this.forEachChildren((c3) => {
      c3.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = false, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
};
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget);

// node_modules/@visactor/vrender-core/es/graphic/group.js
var GroupUpdateAABBBoundsMode;
!function(GroupUpdateAABBBoundsMode2) {
  GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
var Group = class _Group extends Graphic {
  constructor(params2) {
    super(params2), this.type = "group", this.parent = null, this.isContainer = true, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  setTheme(t) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  visibleAll(visible) {
    this.setAttribute("visible", visible), this.forEachChildren((item) => {
      item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
    });
  }
  hideAll() {
    this.visibleAll(false);
  }
  showAll() {
    this.visibleAll(true);
  }
  containsPoint(x, y, mode) {
    if (mode === IContainPointMode.GLOBAL) {
      const point6 = new Point(x, y);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point6, point6), this.AABBBounds.contains(point6.x, point6.y);
    }
    return this.AABBBounds.contains(x, y);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, dx = DefaultTransform.dx, dy = DefaultTransform.dy, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, postMatrix } = this.attribute;
    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle2 || postMatrix) return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  getGraphicTheme() {
    return getTheme(this).group;
  }
  updateAABBBounds(attribute, groupTheme, aabbBounds) {
    const originalAABBBounds = aabbBounds;
    aabbBounds = aabbBounds.clone();
    const { width, height, path, clip = groupTheme.clip } = attribute;
    if (path && path.length ? path.forEach((g) => {
      aabbBounds.union(g.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
      this.forEachChildren((node) => {
        aabbBounds.union(node.AABBBounds);
      });
      const { scrollX = 0, scrollY = 0 } = attribute;
      aabbBounds.translate(scrollX, scrollY);
    }
    return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, false, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++;
    const bounds = super.doUpdateAABBBounds();
    return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
  }
  _updateChildToStage(child) {
    return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
  }
  appendChild(node, addStage = true) {
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
  }
  insertAfter(newNode, referenceNode) {
    return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
  }
  insertInto(newNode, idx2) {
    return this._updateChildToStage(super.insertInto(newNode, idx2));
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
  }
  removeAllChild(deep = false) {
    this.forEachChildren((child) => {
      application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren((item) => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m4 = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find((node) => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new _Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Group.NOWORK_ANIMATE_ATTR;
  }
  release(all) {
    all && this.forEachChildren((g) => {
      g.release(all);
    }), super.release();
  }
};
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

// node_modules/@visactor/vrender-core/es/core/layer.js
var Layer = class extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("暂不支持");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global, window2, params2) {
    var _a;
    super({}), this.stage = stage, this.global = global, this.window = window2, this.main = params2.main, this.layerHandler = params2.layerHandler, this.layerHandler.init(this, window2, {
      main: params2.main,
      canvasId: params2.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params2.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = /* @__PURE__ */ new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer(removeIncrementalKey = true) {
    const subLayers = Array.from(this.subLayers.values()).sort((a3, b) => a3.zIndex - b.zIndex);
    this.layerHandler.merge(subLayers.map((l) => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach((l) => {
      l.group && (l.group.incremental = 0);
    }), subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x, y) {
    throw new Error("暂不支持");
  }
  tryRenderSecondaryLayer(params2, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach((h) => {
      h.layer.renderCount = this.renderCount, h.layer.render(params2, userParams);
    });
  }
  render(params2, userParams) {
    var _a;
    this.layerHandler.render([this], {
      renderService: params2.renderService,
      stage: this.stage,
      layer: this,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params2.updateBounds
    }, userParams), this.afterDrawCbs.forEach((c3) => c3(this)), this.tryRenderSecondaryLayer(params2, userParams);
  }
  resize(w, h) {
    this.layerHandler.resize(w, h);
  }
  resizeView(w, h) {
    this.layerHandler.resizeView(w, h);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  prepare(dirtyBounds, params2) {
  }
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    });
  }
  drawTo(target, params2) {
    var _a;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      renderService: params2.renderService,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      stage: this.stage,
      layer: this
    }, params2)), this.afterDrawCbs.forEach((c3) => c3(this));
  }
};

// node_modules/@visactor/vrender-core/es/core/constants.js
var TransformUtil = Symbol.for("TransformUtil");
var GraphicUtil = Symbol.for("GraphicUtil");
var LayerService = Symbol.for("LayerService");
var StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
var DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
var VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

// node_modules/@visactor/vrender-core/es/core/layer-service.js
var DefaultLayerService_1;
var __decorate6 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata4 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = /* @__PURE__ */ new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = true);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage, options = {
    main: false
  }) {
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode), layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
      main: false
    }, options), {
      layerMode,
      canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
      layerHandler
    })), stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren((l) => {
      const handler = l.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter((l) => l !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(stage) {
    this.layerMap.delete(stage);
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate6([injectable(), __metadata4("design:paramtypes", [])], DefaultLayerService);

// node_modules/@visactor/vrender-core/es/core/core-modules.js
var core_modules_default = new ContainerModule((bind) => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/utils.js
function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke2, lineWidth) {
  let s2;
  return s2 = isArray_default(stroke2) ? stroke2.some((item) => item || void 0 === item) : !!stroke2, s2 && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height) {
  return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
  let t = y32 * x10 - x32 * y10;
  return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
}
function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
  const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
  let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
  const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
  const deltaAngle = abs(endAngle - startAngle), cornerRadius = arc.getParsedCornerRadius(), cornerRadiusIsArray = isArray_default(cornerRadius), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius, outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius, innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius, innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
  let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
  const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
  let xore, yore, xirs, yirs;
  if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
    const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
    if (oc) {
      const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
    }
  }
  return {
    outerDeltaAngle,
    xors,
    yors,
    xirs,
    yirs,
    xore,
    yore,
    xire,
    yire,
    limitedOcr,
    limitedIcr,
    outerCornerRadiusStart,
    outerCornerRadiusEnd,
    maxOuterCornerRadius,
    maxInnerCornerRadius,
    outerStartAngle,
    outerEndAngle,
    innerDeltaAngle,
    innerEndAngle,
    innerStartAngle,
    innerCornerRadiusStart,
    innerCornerRadiusEnd
  };
}
function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp2 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp2;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));
  else {
    const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, outerStartAngle, outerEndAngle, limitedIcr, innerDeltaAngle, innerEndAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (outerDeltaAngle < 1e-3) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = true;
    else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

// node_modules/@visactor/vrender-core/es/canvas/conical-gradient.js
var ConicalCanvas = class _ConicalCanvas {
  static GetCanvas() {
    try {
      return _ConicalCanvas.canvas || (_ConicalCanvas.canvas = application.global.createCanvas({})), _ConicalCanvas.canvas;
    } catch (err) {
      return null;
    }
  }
  static GetCtx() {
    if (!_ConicalCanvas.ctx) {
      const conicalCanvas = _ConicalCanvas.GetCanvas();
      _ConicalCanvas.ctx = conicalCanvas.getContext("2d");
    }
    return _ConicalCanvas.ctx;
  }
};
var ColorInterpolate = class _ColorInterpolate extends LRU {
  static getInstance() {
    return _ColorInterpolate._instance || (_ColorInterpolate._instance = new _ColorInterpolate()), _ColorInterpolate._instance;
  }
  constructor(stops = [], precision = 100) {
    super(), this.cacheParams = {
      CLEAN_THRESHOLD: 100,
      L_TIME: 1e3
    }, this.dataMap = /* @__PURE__ */ new Map();
    const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
    if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;
    if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
    const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
    stops.forEach((stop) => {
      gradient.addColorStop(stop[0], stop[1]);
    }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
  }
  getColor(offset) {
    const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
    return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
  }
  GetOrCreate(x, y, w, h, stops = [], precision = 100) {
    let str = `${x}${y}${w}${h}`;
    stops.forEach((item) => str += item.join()), str += precision;
    let colorInter = this.dataMap.get(str);
    if (!colorInter) {
      colorInter = {
        data: new _ColorInterpolate(stops, precision),
        timestamp: []
      }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
    }
    return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
  }
};
var ConicalPatternStore = class _ConicalPatternStore {
  static GetSize(minSize) {
    for (let i = 0; i < _ConicalPatternStore.ImageSize.length; i++) if (_ConicalPatternStore.ImageSize[i] >= minSize) return _ConicalPatternStore.ImageSize[i];
    return minSize;
  }
  static Get(stops, x, y, startAngle, endAngle, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle), data = _ConicalPatternStore.cache[key];
    if (!data || 0 === data.length) return null;
    for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
    return null;
  }
  static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
    _ConicalPatternStore.cache[key] ? _ConicalPatternStore.cache[key].push({
      width: w,
      height: h,
      pattern
    }) : _ConicalPatternStore.cache[key] = [{
      width: w,
      height: h,
      pattern
    }];
  }
  static GenKey(stops, x, y, startAngle, endAngle) {
    return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
  }
};
ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x, y, angle2, color) {
  const { stops, startAngle, endAngle } = color;
  for (; angle2 < 0; ) angle2 += pi2;
  for (; angle2 > pi2; ) angle2 -= pi2;
  if (angle2 < startAngle) return stops[0].color;
  if (angle2 > endAngle) return stops[0].color;
  let startStop, endStop, percent = (angle2 - startAngle) / (endAngle - startAngle);
  for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
    startStop = stops[i - 1], endStop = stops[i];
    break;
  }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, false);
}
function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
  const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
  if (!conicalCtx) return null;
  const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);
  let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
  if (pattern) return pattern;
  const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum), lineWidth = 2 * Math.PI * r / 360;
  conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
  for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
    const color = colorInter.getColor(i);
    conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
  }
  const imageData = conicalCtx.getImageData(0, 0, width, height);
  return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/constants.js
var ArcRenderContribution = Symbol.for("ArcRenderContribution");
var AreaRenderContribution = Symbol.for("AreaRenderContribution");
var CircleRenderContribution = Symbol.for("CircleRenderContribution");
var GroupRenderContribution = Symbol.for("GroupRenderContribution");
var ImageRenderContribution = Symbol.for("ImageRenderContribution");
var PathRenderContribution = Symbol.for("PathRenderContribution");
var PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
var RectRenderContribution = Symbol.for("RectRenderContribution");
var SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
var TextRenderContribution = Symbol.for("TextRenderContribution");
var StarRenderContribution = Symbol.for("StarRenderContribution");
var CommonRenderContribution = Symbol.for("CommonRenderContribution");
var InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

// node_modules/@visactor/vrender-core/es/common/text.js
function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - 0.79 * fontSize);
}
function textAttributesToStyle(attrs) {
  const style = {}, parsePxValue = (value) => /^\d+(\.\d+)?$/.test(`${value}`) ? `${value}px` : `${value}`;
  return ["textAlign", "fontFamily", "fontVariant", "fontStyle", "fontWeight"].forEach((key) => {
    attrs[key] && (style[lowerCamelCaseToMiddle(key)] = attrs[key]);
  }), ["fontSize", "lineHeight"].forEach((key) => {
    const styleKey = lowerCamelCaseToMiddle(key);
    isNil_default(attrs[key]) || (style[styleKey] = parsePxValue(attrs[key]));
  }), isValid_default(attrs.maxLineWidth) && (style["max-width"] = parsePxValue(attrs.maxLineWidth)), attrs.underline ? style["text-decoration"] = "underline" : attrs.lineThrough && (style["text-decoration"] = "line-through"), attrs.fill && isString_default(attrs.fill) && (style.color = attrs.fill), style;
}

// node_modules/@visactor/vrender-core/es/common/matrix.js
function identityMat4(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  return a3 !== out && (out[0] = a3[0], out[1] = a3[1], out[2] = a3[2], out[3] = a3[3], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[4] = a10 * c3 + a20 * s2, out[5] = a11 * c3 + a21 * s2, out[6] = a12 * c3 + a22 * s2, out[7] = a13 * c3 + a23 * s2, out[8] = a20 * c3 - a10 * s2, out[9] = a21 * c3 - a11 * s2, out[10] = a22 * c3 - a12 * s2, out[11] = a23 * c3 - a13 * s2, out;
}
function rotateY(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  return a3 !== out && (out[4] = a3[4], out[5] = a3[5], out[6] = a3[6], out[7] = a3[7], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[0] = a00 * c3 - a20 * s2, out[1] = a01 * c3 - a21 * s2, out[2] = a02 * c3 - a22 * s2, out[3] = a03 * c3 - a23 * s2, out[8] = a00 * s2 + a20 * c3, out[9] = a01 * s2 + a21 * c3, out[10] = a02 * s2 + a22 * c3, out[11] = a03 * s2 + a23 * c3, out;
}
function rotateZ(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  return a3 !== out && (out[8] = a3[8], out[9] = a3[9], out[10] = a3[10], out[11] = a3[11], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[0] = a00 * c3 + a10 * s2, out[1] = a01 * c3 + a11 * s2, out[2] = a02 * c3 + a12 * s2, out[3] = a03 * c3 + a13 * s2, out[4] = a10 * c3 - a00 * s2, out[5] = a11 * c3 - a01 * s2, out[6] = a12 * c3 - a02 * s2, out[7] = a13 * c3 - a03 * s2, out;
}
function translate(out, a3, v) {
  const x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a3 === out ? (out[12] = a3[0] * x + a3[4] * y + a3[8] * z + a3[12], out[13] = a3[1] * x + a3[5] * y + a3[9] * z + a3[13], out[14] = a3[2] * x + a3[6] * y + a3[10] * z + a3[14], out[15] = a3[3] * x + a3[7] * y + a3[11] * z + a3[15]) : (a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a3[12], out[13] = a01 * x + a11 * y + a21 * z + a3[13], out[14] = a02 * x + a12 * y + a22 * z + a3[14], out[15] = a03 * x + a13 * y + a23 * z + a3[15]), out;
}
function mat3Tomat4(out, b) {
  out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
}
function scaleMat4(out, a3, v) {
  const x = v[0], y = v[1], z = v[2];
  return out[0] = a3[0] * x, out[1] = a3[1] * x, out[2] = a3[2] * x, out[3] = a3[3] * x, out[4] = a3[4] * y, out[5] = a3[5] * y, out[6] = a3[6] * y, out[7] = a3[7] * y, out[8] = a3[8] * z, out[9] = a3[9] * z, out[10] = a3[10] * z, out[11] = a3[11] * z, out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15], out;
}
function multiplyMat4Mat4(out, a3, b) {
  const a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11], a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function lookAt(out, eye, center2, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center2[0], centery = center2[1], centerz = center2[2];
  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? identityMat4(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}
function ortho(out, left2, right2, bottom, top, near, far) {
  const lr = 1 / (left2 - right2), bt = 1 / (bottom - top), nf = 1 / (near - far);
  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left2 + right2) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}
function transformMat4(out, a3, m4) {
  const x = a3[0], y = a3[1], z = a3[2];
  let w = m4[3] * x + m4[7] * y + m4[11] * z + m4[15];
  return w = w || 1, out[0] = (m4[0] * x + m4[4] * y + m4[8] * z + m4[12]) / w, out[1] = (m4[1] * x + m4[5] * y + m4[9] * z + m4[13]) / w, out[2] = (m4[2] * x + m4[6] * y + m4[10] * z + m4[14]) / w, out;
}

// node_modules/@visactor/vrender-core/es/allocator/matrix-allocate.js
var MatrixAllocate = Symbol.for("MatrixAllocate");
var Mat4Allocate = Symbol.for("Mat4Allocate");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
var DefaultMatrixAllocate = class {
  constructor() {
    this.pools = [];
  }
  allocate(a3, b, c3, d, e, f) {
    if (!this.pools.length) return new Matrix(a3, b, c3, d, e, f);
    const m4 = this.pools.pop();
    return m4.a = a3, m4.b = b, m4.c = c3, m4.d = d, m4.e = e, m4.f = f, m4;
  }
  allocateByObj(matrix) {
    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m4 = this.pools.pop();
    return m4.a = matrix.a, m4.b = matrix.b, m4.c = matrix.c, m4.d = matrix.d, m4.e = matrix.e, m4.f = matrix.f, m4;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultMat4Allocate = class _DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return identityMat4(out);
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const m4 = this.pools.pop();
    return _DefaultMat4Allocate.identity(m4), m4;
  }
  allocateByObj(d) {
    let m4;
    m4 = this.pools.length ? this.pools.pop() : createMat4();
    for (let i = 0; i < m4.length; i++) m4[i] = d[i];
    return m4;
  }
  free(m4) {
    m4 && this.pools.push(m4);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var matrixAllocate = new DefaultMatrixAllocate();
var mat4Allocate = new DefaultMat4Allocate();

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-service.js
var __decorate7 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata5 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function getModelMatrix(out, graphic, theme2) {
  var _a;
  const { x = theme2.x, y = theme2.y, z = theme2.z, dx = theme2.dx, dy = theme2.dy, dz = theme2.dz, scaleX = theme2.scaleX, scaleY = theme2.scaleY, scaleZ = theme2.scaleZ, alpha = theme2.alpha, beta = theme2.beta, angle: angle2 = theme2.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute, _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle2) {
    const m4 = mat4Allocate.allocate(), _anchor2 = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
        _anchor2[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
        _anchor2[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[1] = anchor3d[1];
    }
    translate(m4, m4, [_anchor2[0], _anchor2[1], 0]), rotateZ(m4, m4, angle2), translate(m4, m4, [-_anchor2[0], -_anchor2[1], 0]), multiplyMat4Mat4(out, out, m4);
  }
}
function shouldUseMat4(graphic) {
  const { alpha, beta } = graphic.attribute;
  return alpha || beta;
}
var DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
      clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds();
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params2, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params2, selfChange);
  }
  clearAABBBounds(graphic, stage, b) {
    this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path) return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    const { textAlign, textBaseline } = attribute;
    if (null != attribute.forceBoundsHeight) {
      const h = isNumber_default(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(), dy = textLayoutOffsetY(textBaseline, h, h);
      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
    }
    if (null != attribute.forceBoundsWidth) {
      const w = isNumber_default(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(), dx = textDrawOffsetX(textAlign, w);
      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
    }
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b = graphic.shadowRoot.AABBBounds;
      bounds.union(b);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme2, miter, graphic) {
    if (!aabbBounds.empty()) {
      const { scaleX = theme2.scaleX, scaleY = theme2.scaleY, stroke: stroke2 = theme2.stroke, shadowBlur = theme2.shadowBlur, lineWidth = theme2.lineWidth, pickStrokeBuffer = theme2.pickStrokeBuffer, strokeBoundsBuffer = theme2.strokeBoundsBuffer } = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
      if (stroke2 && lineWidth) {
        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
      }
      if (shadowBlur) {
        const { shadowOffsetX = theme2.shadowOffsetX, shadowOffsetY = theme2.shadowOffsetY } = attribute, shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
        boundStroke(tb1, shadowBlurWidth, false, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
      }
    }
    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
    let updateMatrix = true;
    const m4 = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m4.a && 0 === m4.b && 0 === m4.c && 1 === m4.d && 0 === m4.e && 0 === m4.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m4);
  }
  validCheck(attribute, theme2, aabbBounds, graphic) {
    if (!graphic) return true;
    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return true;
    if (graphic.shadowRoot || graphic.isContainer) return true;
    const { visible = theme2.visible } = attribute;
    return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), application.graphicService.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), false);
  }
  updateTempAABBBounds(aabbBounds) {
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
      tb1,
      tb2
    };
  }
};
DefaultGraphicService = __decorate7([injectable(), __param3(0, inject(GraphicCreator)), __metadata5("design:paramtypes", [Object])], DefaultGraphicService);

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/common-outer-boder-bounds.js
var updateBoundsOfCommonOuterBorder = (attribute, theme2, aabbBounds) => {
  const { outerBorder, shadowBlur = theme2.shadowBlur } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = theme2.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
    aabbBounds.expand(distance2 + (shadowBlur + lineWidth) / 2);
  }
  return aabbBounds;
};

// node_modules/@visactor/vrender-core/es/graphic/circle.js
var CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
var Circle = class _Circle extends Graphic {
  constructor(params2 = {
    radius: 1
  }) {
    super(params2), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, radius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  getGraphicTheme() {
    return getTheme(this).circle;
  }
  updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, false, this), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
    const { radius = circleTheme.radius } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
    const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"), path = new CustomPath2D();
    return path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new _Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Circle.NOWORK_ANIMATE_ATTR;
  }
};
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/layout.js
var CanvasTextLayout = class {
  constructor(fontFamily, options, textMeasure) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
  }
  LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
    if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;
    else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;
    else if ("alphabetic" === textBaseline) {
      let percent = 0.79;
      if (1 === linesLayout.length) {
        const lineInfo = linesLayout[0];
        percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
      }
      bbox.yOffset = bbox.height * -percent;
    } else bbox.yOffset = -bbox.height;
    return bbox;
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, params2) {
    const { lineWidth, suffixPosition = "end", measureMode = MeasureModeEnum.actualBounding, keepCenterInLine = false } = null != params2 ? params2 : {};
    lines = lines.map((l) => l.toString());
    const linesLayout = [], bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i = 0, len = lines.length; i < len; i++) {
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        let str = lines[i].toString();
        if (metrics.width > lineWidth) {
          const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
          str = data.str, width = data.width;
        } else width = metrics.width;
        linesLayout.push({
          str,
          width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    } else {
      let width, text2, _lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        text2 = lines[i];
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
          str: text2,
          width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = _lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a3, b) => Math.max(a3, b.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0], totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox,
      lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight,
      textAlign,
      textBaseline
    };
  }
  lineOffset(bbox, line2, textAlign, textBaseline, lineHeight, origin) {
    if ("left" === textAlign || "start" === textAlign ? line2.leftOffset = 0 : "center" === textAlign ? line2.leftOffset = (bbox.width - line2.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line2.leftOffset = bbox.width - line2.width), line2.topOffset = lineHeight / 2 + (line2.ascent - line2.descent) / 2 + origin[1], !line2.keepCenterInLine) {
      const buf = 0, actualHeightWithBuf = line2.ascent + line2.descent + buf;
      if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line2.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line2.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
        const ratio = lineHeight / (line2.ascent + line2.descent);
        line2.topOffset = lineHeight / 2 + (line2.ascent - line2.descent) / 2 * ratio + origin[1];
      }
    }
    return origin[1] += lineHeight, line2;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/text.js
var TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
var Text = class _Text extends Graphic {
  get font() {
    const textTheme = this.getGraphicTheme();
    return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute, textTheme = this.getGraphicTheme(), maxWidth = this.getMaxWidth(textTheme);
    return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    var _a, _b;
    const textTheme = this.getGraphicTheme(), attribute = this.attribute, maxWidth = this.getMaxWidth(textTheme);
    if (!Number.isFinite(maxWidth)) return false;
    const { text: text2 } = this.attribute;
    if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
      let mergedText = "";
      this.cache.layoutData.lines.forEach((item) => {
        mergedText += item.str;
      });
      return (Array.isArray(text2) ? text2.join("") : text2) !== mergedText;
    }
    return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map((item) => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
  }
  get multilineLayout() {
    return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor(params2 = {
    text: "",
    fontSize: 16
  }) {
    super(params2), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t) => null == t || "" === t) : null != text2 && "" !== text2;
  }
  getGraphicTheme() {
    return getTheme(this).text;
  }
  doUpdateOBBBounds() {
    const graphicTheme = this.getGraphicTheme();
    this._OBBBounds.clear();
    const attribute = this.attribute, { angle: angle2 = graphicTheme.angle } = attribute;
    if (!angle2) {
      const b = this.AABBBounds;
      return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
    }
    this.obbText || (this.obbText = new _Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
      angle: 0
    }));
    const bounds1 = this.obbText.AABBBounds, { x, y } = attribute, boundsCenter = {
      x: (bounds1.x1 + bounds1.x2) / 2,
      y: (bounds1.y1 + bounds1.y2) / 2
    }, center2 = rotatePoint(boundsCenter, angle2, {
      x,
      y
    });
    return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center2.x - boundsCenter.x, center2.y - boundsCenter.y), this._OBBBounds.angle = angle2, this._OBBBounds;
  }
  updateAABBBounds(attribute, textTheme, aabbBounds) {
    const { text: text2 = textTheme.text } = this.attribute;
    Array.isArray(text2) ? this.updateMultilineAABBBounds(text2) : this.updateSingallineAABBBounds(text2);
    const { tb1 } = application.graphicService.updateTempAABBBounds(aabbBounds), { scaleX = textTheme.scaleX, scaleY = textTheme.scaleY, shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer = textTheme.strokeBoundsBuffer } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, true, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
  }
  updateSingallineAABBBounds(text2) {
    this.updateMultilineAABBBounds([text2]);
    const layoutData = this.cache.layoutData;
    if (layoutData && layoutData.lines && layoutData.lines.length) {
      const line2 = layoutData.lines[0];
      this.cache.clipedText = line2.str, this.cache.clipedWidth = line2.width;
    }
    return this._AABBBounds;
  }
  updateMultilineAABBBounds(text2) {
    const textTheme = this.getGraphicTheme(), { direction = textTheme.direction, underlineOffset = textTheme.underlineOffset } = this.attribute, b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text2) : this.updateVerticalMultilineAABBBounds(text2);
    return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  guessLineHeightBuf(fontSize) {
    return fontSize ? 0.1 * fontSize : 0;
  }
  updateHorizontalMultilineAABBBounds(text2) {
    var _a;
    const textTheme = this.getGraphicTheme(), attribute = this.attribute, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, wrap = textTheme.wrap, measureMode = textTheme.measureMode, lineWidth = textTheme.lineWidth, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition, ignoreBuf = textTheme.ignoreBuf, keepCenterInLine = textTheme.keepCenterInLine } = attribute, buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize), lineHeight = this.getLineHeight(attribute, textTheme, buf);
    if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text2);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutData = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily,
      lineHeight
    }, textMeasure).GetLayoutByLines(text2, textAlign, textBaseline, lineHeight, true === ellipsis ? textTheme.ellipsis : ellipsis || void 0, false, {
      lineWidth: maxLineWidth,
      suffixPosition,
      measureMode,
      keepCenterInLine
    }), { bbox } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateWrapAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = this.getGraphicTheme(), { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, measureMode = textTheme.measureMode, suffixPosition = textTheme.suffixPosition, heightLimit = 0, lineClamp, keepCenterInLine = textTheme.keepCenterInLine } = this.attribute, buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize), lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, textOptions = {
      fontSize,
      fontWeight,
      fontFamily,
      lineHeight
    }, layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure), lines = isArray_default(text2) ? text2.map((l) => l.toString()) : [text2.toString()], linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = true;
        if (i === lineCountLimit - 1) {
          const clip2 = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, false, suffixPosition, i !== lines.length - 1), matrics2 = textMeasure.measureTextPixelADscentAndWidth(clip2.str, textOptions, measureMode);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width,
            ascent: matrics2.ascent,
            descent: matrics2.descent,
            keepCenterInLine
          });
          break;
        }
        const clip = textMeasure.clipText(str, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
        if ("" !== str && "" === clip.str || clip.wordBreaked) {
          if (ellipsis) {
            const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
        linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine
        });
        let cutLength = clip.str.length;
        if (!clip.wordBreaked || "" !== str && "" === clip.str || (needCut = true, cutLength = clip.wordBreaked), clip.str.length === str.length) ;
        else if (needCut) {
          let newStr = str.substring(cutLength);
          "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout2) => {
        maxWidth = Math.max(maxWidth, layout2.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, false, suffixPosition), matrics2 = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics2.ascent,
            descent: matrics2.descent,
            keepCenterInLine
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i], width = textMeasure.measureTextWidth(text3, textOptions), lineWidth2 = Math.max(lineWidth2, width);
        const matrics = textMeasure.measureTextPixelADscentAndWidth(text3, textOptions, measureMode);
        linesLayout.push({
          str: text3,
          width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * lineHeight;
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text2) {
    var _a, _b;
    const textTheme = this.getGraphicTheme(), textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = this.getLineHeight(attribute, textTheme, 0);
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_a = _Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = _Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach((item) => {
        const w = item.reduce((a3, b) => a3 + b.width, 0);
        width = max(w, width);
      });
      const dx2 = textDrawOffsetX(textAlign, width), height2 = this.cache.verticalList.length * lineHeight, dy2 = textLayoutOffsetY(textBaseline, height2, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + height2, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text2.map((str) => verticalLayout(str.toString()));
    verticalLists.forEach((verticalData, i) => {
      if (Number.isFinite(maxLineWidth)) if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        verticalLists[i] = data.verticalList, width = data.width;
      } else {
        const data = textMeasure.clipTextVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        verticalLists[i] = data.verticalList, width = data.width;
      }
      else width = 0, verticalData.forEach((t) => {
        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
          fontSize,
          fontWeight,
          fontFamily
        });
        width += w, t.width = w;
      });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach((item) => {
      const w = item.reduce((a3, b) => a3 + b.width, 0);
      width = max(w, width);
    });
    const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getMaxWidth(theme2) {
    var _a, _b;
    const attribute = this.attribute;
    return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme2.maxWidth;
  }
  getLineHeight(attribute, textTheme, buf) {
    var _a;
    return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
  }
  needUpdateTags(keys, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(keys, k2);
  }
  needUpdateTag(key, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(key, k2);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "text" === key && (nextAttributes.text = nextStepVal);
  }
  clone() {
    return new _Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Text.NOWORK_ANIMATE_ATTR;
  }
  getBaselineMapAlign() {
    return _Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return _Text.alignMapBaseline;
  }
};
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/wrap-text.js
var WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
var WrapText = class _WrapText extends Text {
  constructor(params2) {
    super(Object.assign(Object.assign({}, params2), {
      wrap: true
    }));
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t) => null == t || "" === t) : null != text2 && "" !== text2;
  }
  updateMultilineAABBBounds(text2) {
    var _a, _b, _c, _d;
    const textTheme = this.getGraphicTheme(), { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, heightLimit = 0, suffixPosition = textTheme.suffixPosition, lineClamp } = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure), lines = text2.map((l) => l.toString()), linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = true;
        if (i === lineCountLimit - 1) {
          const clip2 = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: false
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: false
        }), clip.str.length === str.length) ;
        else if (needCut) {
          const newStr = str.substring(clip.str.length);
          lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout2) => {
        maxWidth = Math.max(maxWidth, layout2.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: false
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i], width = layoutObj.textMeasure.measureTextWidth(text3, layoutObj.textOptions, "break-word" === wordBreak), lineWidth2 = Math.max(lineWidth2, width), linesLayout.push({
          str: text3,
          width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: false
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  needUpdateTags(keys) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
      if (-1 !== keys.indexOf(attrKey)) return true;
    }
    return super.needUpdateTags(keys);
  }
  needUpdateTag(key) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return true;
    }
    return super.needUpdateTag(key);
  }
  getNoWorkAnimateAttr() {
    return _WrapText.NOWORK_ANIMATE_ATTR;
  }
};
function createWrapText(attributes) {
  return new WrapText(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/symbol-outer-border-bounds.js
var updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
  const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = symbolTheme.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
    boundStroke(aabbBounds, distance2 + (shadowBlur + lineWidth) / 2, true, strokeBoundsBuffer);
  }
  return aabbBounds;
};

// node_modules/@visactor/vrender-core/es/graphic/symbol.js
var SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
var Symbol2 = class _Symbol extends Graphic {
  constructor(params2 = {
    symbolType: "circle"
  }) {
    super(params2), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  getParsedPath2D(x = 0, y = 0, size = 1) {
    let path = null;
    try {
      path = new Path2D();
    } catch (err) {
      return null;
    }
    const parsedPath = this.getParsedPath();
    if (!parsedPath) return null;
    parsedPath.draw(path, size, x, y);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { size } = this.attribute;
    return isArray_default(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const { symbolType = "circle" } = this.attribute;
    return super.parsePath(symbolType);
  }
  getGraphicTheme() {
    return getTheme(this).symbol;
  }
  updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, this.y1WithoutTransform = aabbBounds.y1;
    const { lineJoin = symbolTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
    const { size = symbolTheme.size } = attribute;
    if (isArray_default(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
    else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
    const { size = symbolTheme.size } = attribute;
    return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = isArray_default(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new _Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol2.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol2(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/line.js
var LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
var Line = class _Line extends Graphic {
  constructor(params2 = {}) {
    super(params2), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getGraphicTheme() {
    return getTheme(this).line;
  }
  updateAABBBounds(attribute, lineTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = lineTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const { points = lineTheme.points, connectedType } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      false === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
    }), b;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const { segments: segments2 = lineTheme.segments, connectedType } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        false === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
      });
    }), b;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, path = new CustomPath2D(), segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        points.forEach((point6) => {
          false !== point6.defined && (isFirst ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y), isFirst = false);
        });
      }
    };
    return segments2 && segments2.length ? segments2.forEach((seg) => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new _Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Line.NOWORK_ANIMATE_ATTR;
  }
};
Line.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/rect.js
var RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Rect = class _Rect extends Graphic {
  constructor(params2) {
    super(params2), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return true;
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      let { width, height } = attribute;
      const { x1, y1, x, y } = attribute;
      width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, { x, y, width, height } = normalizeRectAttributes(attribute), path = new CustomPath2D();
    return path.moveTo(x, y), path.rect(x, y, width, height), path;
  }
  clone() {
    return new _Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Rect.NOWORK_ANIMATE_ATTR;
  }
};
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/rect3d.js
var CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
var Rect3d = class _Rect3d extends Rect {
  constructor(params2) {
    super(params2), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  findFace() {
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    }, rectTheme = this.getGraphicTheme(), { x1, y1, x, y, length: length2 = min(rectTheme.width, rectTheme.height) } = this.attribute;
    let { width, height } = this.attribute;
    width = null != width ? width : x1 - x, height = null != height ? height : y1 - y;
    for (let i = 0; i < CUBE_VERTICES.length; i++) {
      const v = CUBE_VERTICES[i];
      faces.vertices.push([v[0] * width, v[1] * height, v[2] * length2]);
    }
    return faces.polygons.push({
      polygon: [0, 1, 5, 4],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [2, 3, 7, 6],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [4, 7, 3, 0],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 2, 6, 5],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  getNoWorkAnimateAttr() {
    return _Rect3d.NOWORK_ANIMATE_ATTR;
  }
};
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect3d(attributes) {
  return new Rect3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/glyph.js
var Glyph = class _Glyph extends Graphic {
  constructor(params2) {
    super(params2), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
  }
  setSubGraphic(subGraphic) {
    this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g) => {
      g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
    }), this.valid = this.isValid(), this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach((g) => {
      g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(cb) {
    this._onInit = cb;
  }
  onUpdate(cb) {
    this._onUpdate = cb;
  }
  isValid() {
    return true;
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    super.setAttributes(params2, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  translate(x, y) {
    return super.translate(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  translateTo(x, y) {
    return super.translateTo(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scale(scaleX, scaleY, scaleCenter) {
    return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scaleTo(scaleX, scaleY) {
    return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotate(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotateTo(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  getGraphicTheme() {
    return getTheme(this).glyph;
  }
  updateAABBBounds(attribute, theme2, aabbBounds) {
    return this.getSubGraphic().forEach((node) => {
      aabbBounds.union(node.AABBBounds);
    }), aabbBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++, this._AABBBounds.clear();
    const bounds = this.updateAABBBounds(this.attribute, this.getGraphicTheme(), this._AABBBounds);
    return this.clearUpdateBoundTag(), bounds;
  }
  needUpdateTags(keys) {
    return false;
  }
  needUpdateTag(key) {
    return false;
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    this.stopStateAnimates();
    const stateAttrs = {}, subAttrs = this.subGraphic.map(() => ({}));
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
      attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a2 = attrs.subAttributes) || void 0 === _a2 ? void 0 : _a2.length) && subAttrs.forEach((subAttrs2, index) => {
        Object.assign(subAttrs2, attrs.subAttributes[index]);
      }));
    }), this.subGraphic.forEach((graphic, index) => {
      graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  clearStates(hasAnimation) {
    this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], this.subGraphic.forEach((graphic) => {
      graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, true), graphic.normalAttrs = null;
    }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  clone() {
    const glyph = new _Glyph(Object.assign({}, this.attribute));
    return glyph.setSubGraphic(this.subGraphic.map((g) => g.clone())), glyph;
  }
  getNoWorkAnimateAttr() {
    return _Glyph.NOWORK_ANIMATE_ATTR;
  }
};
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGlyph(attributes) {
  return new Glyph(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/richtext/frame.js
var Frame = class {
  constructor(left2, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
    this.left = left2, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left2 + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = /* @__PURE__ */ new Map();
  }
  draw(ctx, drawIcon) {
    const { width: actualWidth, height: actualHeight } = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = false;
    if ("middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
      let lastLine = false;
      this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
    }
    else {
      const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
      "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
      for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
    }
    else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].draw(ctx, false, deltaX, y + deltaY, this.ellipsis, drawIcon);
      else {
        if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
        {
          let lastLine = false;
          this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
        }
      }
    }
    else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i = 0; i < this.lines.length; i++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
        const { top, height: height2 } = this.lines[i];
        if (0 === frameHeight) this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
        else {
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
          {
            let lastLine = false;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0, height = 0;
    for (let i = 0; i < this.lines.length; i++) {
      const line2 = this.lines[i];
      line2.actualWidth > width && (width = line2.actualWidth), height += line2.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0, heightBound = 0;
    const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
    this.width;
    let height = this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
        const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
        lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
      } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
    }
    else {
      Math.floor((frameHeight - this.actualHeight) / 2);
      for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
    }
    else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      else if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;
      else {
        if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
          const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    else for (let i = 0; i < this.lines.length; i++) {
      const { top, height: height2 } = this.lines[i];
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      else if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else {
        if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/paragraph.js
function getFixedLRTB(left2, right2, top, bottom) {
  const leftInt = Math.round(left2), topInt = Math.round(top), rightInt = Math.round(right2), bottomInt = Math.round(bottom);
  return {
    left: left2 > leftInt ? leftInt : leftInt - 0.5,
    top: top > topInt ? topInt : topInt - 0.5,
    right: rightInt > right2 ? rightInt : rightInt + 0.5,
    bottom: bottomInt > bottom ? bottomInt : bottomInt + 0.5
  };
}
var Paragraph = class {
  constructor(text2, newLine, character, ascentDescentMode) {
    var _a, _b;
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const { ascent, height, descent, width } = measureTextCanvas(text2, character, this.ascentDescentMode);
    let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text2.length, this.width = width || 0, this.text = text2 || "", this.newLine = newLine || false, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, this.space = character.space, this.dx = null !== (_a = character.dx) && void 0 !== _a ? _a : 0, this.dy = null !== (_b = character.dy) && void 0 !== _b ? _b : 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
  }
  updateWidth() {
    const { width } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
    let baseline = top + ascent, text2 = this.text, left2 = this.left + deltaLeft;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text2 = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text2 += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left2 -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;
        else {
          const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left2 -= this.ellipsisWidth - width;
        }
      }
    }
    const lrtb = getFixedLRTB(left2, left2 + (this.widthOrigin || this.width), top, top + lineHeight);
    return Object.assign(Object.assign({}, lrtb), {
      fillStyle: this.character.background,
      globalAlpha: this.character.backgroundOpacity
    });
  }
  draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    var _a;
    let baseline = top + ascent, text2 = this.text, left2 = this.left + deltaLeft + (null !== (_a = this.space) && void 0 !== _a ? _a : 0) / 2;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text2 = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text2 += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left2 -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;
        else {
          const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left2 -= this.ellipsisWidth - width;
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left2, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left2, baseline), left2 = 0, baseline = 0);
    const { lineWidth = 1 } = this.character;
    if (this.character.stroke && lineWidth && ctx.strokeText(text2, left2, baseline + this.dy), this.character.fill && ctx.fillText(text2, left2, baseline + this.dy), this.character.fill) {
      if (this.character.lineThrough || this.character.underline) {
        if (this.character.underline) {
          const top2 = 1 + baseline, lrtb = getFixedLRTB(left2, left2 + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        }
        if (this.character.lineThrough) {
          const top2 = 1 + baseline - this.ascent / 2, lrtb = getFixedLRTB(left2, left2 + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        }
      } else if ("underline" === this.character.textDecoration) {
        const top2 = 1 + baseline, lrtb = getFixedLRTB(left2, left2 + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      } else if ("line-through" === this.character.textDecoration) {
        const top2 = 1 + baseline - this.ascent / 2, lrtb = getFixedLRTB(left2, left2 + (this.widthOrigin || this.width), top2, top2 + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
    }
    "vertical" === direction && ctx.restore();
  }
  getWidthWithEllips(direction) {
    let text2 = this.text;
    const width = "vertical" === direction ? this.height : this.width;
    if ("hide" === this.ellipsis) return width;
    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text2, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
      text2 = text2.slice(0, index), text2 += this.ellipsisStr;
      const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
};
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, true, paragraph.character, paragraph.ascentDescentMode)];
}

// node_modules/@visactor/vrender-core/es/graphic/image.js
var IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
var Image = class _Image extends Graphic {
  constructor(params2) {
    super(params2), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  getImageElement() {
    const { image } = this.attribute;
    if (!image || !this.resources) return null;
    const res = this.resources.get(image);
    return "success" !== res.state ? null : res.data;
  }
  get width() {
    return this.tryUpdateAABBBounds(), this._actualWidth;
  }
  get height() {
    return this.tryUpdateAABBBounds(), this._actualHeight;
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    }), this.addUpdateBoundTag();
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.image && this.loadImage(params2.image), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).image;
  }
  updateAABBBounds(attribute, imageTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const { maxWidth = imageTheme.maxWidth, maxHeight = imageTheme.maxHeight } = attribute;
      let { width, height } = attribute;
      if (null == width || null == height) {
        const imageElement = this.getImageElement();
        if (imageElement) {
          const imageWidth = imageElement.width, imageHeight = imageElement.height;
          if (null != width) height = width * (imageHeight / imageWidth);
          else if (null != height) width = height * (imageWidth / imageHeight);
          else {
            const imageRatio = imageWidth / imageHeight;
            imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
          }
        } else width = maxWidth, height = maxHeight;
      }
      this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, false, this), aabbBounds;
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new _Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Image.NOWORK_ANIMATE_ATTR;
  }
};
Image.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/richtext/icon.js
var RichTextIcon = class extends Image {
  constructor(params2) {
    if (super(params2), this._x = 0, this._y = 0, this._hovered = false, this._marginArray = [0, 0, 0, 0], "always" === params2.backgroundShowMode && (this._hovered = true), params2.margin) {
      const marginArray = parsePadding(params2.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray_default(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
        const marginArray = parsePadding(attributes.margin);
        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute, { backgroundWidth = width, backgroundHeight = height } = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/line.js
var Line2 = class {
  constructor(left2, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
    this.left = left2, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p) => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result2 = regFirstSpace.exec(word.text);
        0 !== (null == result2 ? void 0 : result2.index) && (word.text = word.text.slice(null == result2 ? void 0 : result2.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey, maxHeight = this.height;
    let x = this.left, spacing = 0;
    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function(paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
    if (drawEllipsis && (lastLine || this.paragraphs.some((p) => p.overflow))) {
      let emptyOverflow = true, skipEllipsis = false;
      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;
        else if (emptyOverflow) {
          skipEllipsis = true;
          break;
        }
      }
      let otherParagraphWidth = 0;
      if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) {
          if ("" === paragraph.text) break;
          continue;
        }
        if (paragraph instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = true;
          break;
        }
        const ellipsis = true === drawEllipsis ? "..." : drawEllipsis || "";
        paragraph.ellipsisStr = ellipsis;
        const { width } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode), ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          lastLine && (paragraph.ellipsis = "add");
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    let fillStyle = "", globalAlpha = -1, currBgList = [];
    const bgList = [currBgList];
    this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return;
      const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
      data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
    }), bgList.forEach((bg) => {
      if (0 === bg.length) return;
      const data = bg[0], end = bg[bg.length - 1];
      ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
    }), this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
        x: x + paragraph._x,
        y: y + paragraph._y
      }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
      const b = {
        x1: this.left,
        y1: this.top,
        x2: this.left + this.actualWidth,
        y2: this.top + this.height
      };
      applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
    });
  }
  getWidthWithEllips(ellipsis) {
    let otherParagraphWidth = 0;
    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
      const paragraph = this.paragraphs[i];
      if (paragraph instanceof RichTextIcon) break;
      const { width: width2 } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode), ellipsisWidth = width2 || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.forEach((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/wrapper.js
var Wrapper = class {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0, iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line2 = new Line2(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line2), this.frame.actualHeight += line2.height, this.y += line2.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph, singleLine = false) {
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
  }
  cut(paragraph, singleLine) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), singleLine ? this.send() : this.deal(p2);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext.js
var supportIntl = false;
try {
  supportIntl = Intl && "function" == typeof Intl.Segmenter;
} catch (e) {
  supportIntl = false;
}
var RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
var RichText = class _RichText extends Graphic {
  constructor(params2) {
    super(params2), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
      for (const key2 in val) if ("hoverIconId" === key2) {
        if (val[key2] === attributes[key2]) continue;
        const icon = this._frameCache.icons.get(val[key2]);
        this.updateHoverIconState(icon);
      }
    };
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w) {
    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h) {
    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config2) {
    this.attribute.textConfig = config2, this.addUpdateShapeAndBoundsTag();
  }
  getGraphicTheme() {
    return getTheme(this).richtext;
  }
  static AllSingleCharacter(cache) {
    if (cache.lines) {
      return cache.lines.every((line2) => line2.paragraphs.every((item) => !(item.text && isString_default(item.text) && _RichText.splitText(item.text).length > 1)));
    }
    return cache.every((item) => item.isComposing || !(item.text && isString_default(item.text) && _RichText.splitText(item.text).length > 1));
  }
  static splitText(text2) {
    if (supportIntl) {
      const segmenter = new Intl.Segmenter(void 0, {
        granularity: "grapheme"
      }), segments2 = [];
      for (const { segment } of segmenter.segment(text2)) segments2.push(segment);
      return segments2;
    }
    return Array.from(text2);
  }
  static TransformTextConfig2SingleCharacter(textConfig) {
    const tc = [];
    return textConfig.forEach((item) => {
      const textList = _RichText.splitText(item.text.toString());
      if (isString_default(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
        const t = textList[i];
        tc.push(Object.assign(Object.assign({}, item), {
          text: t
        }));
      }
      else tc.push(item);
    }), tc;
  }
  updateAABBBounds(attribute, richtextTheme, aabbBounds) {
    var _a, _b, _c, _d;
    const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : "top", editOptions } = attribute;
    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);
    else {
      const frameCache = this.getFrameCache(), { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
    let deltaY = 0;
    switch (textBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    return aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  get cliped() {
    const frameCache = this.getFrameCache();
    if (frameCache.actualHeight > frameCache.height) return true;
    const { disableAutoWrapLine } = this.attribute;
    if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
      const l = frameCache.lines[i];
      for (let j = 0; j < l.paragraphs.length; j++) {
        const p = l.paragraphs[j];
        if (p.overflow && "" !== p.text) return true;
      }
    }
    return false;
  }
  combinedStyleToCharacter(config2) {
    const { fill, stroke: stroke2, fontSize, fontFamily, fontStyle, fontWeight, lineWidth, opacity, fillOpacity, lineHeight, strokeOpacity, upgradeAttrs } = this.attribute, out = Object.assign({
      fill,
      stroke: stroke2,
      fontSize,
      fontFamily,
      fontStyle,
      fontWeight,
      lineWidth,
      opacity,
      fillOpacity,
      strokeOpacity
    }, config2);
    return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
  }
  doUpdateFrameCache(tc) {
    var _a;
    const { maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine, disableAutoWrapLine, editable, ascentDescentMode, upgradeAttrs } = this.attribute, enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
    let { textConfig: _tc = [] } = this.attribute;
    editable && _tc.length > 0 && !_RichText.AllSingleCharacter(_tc) && (_tc = _RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
    const paragraphs = [], textConfig = null != tc ? tc : _tc;
    for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
      const config2 = this.combinedStyleToCharacter(textConfig[i]);
      config2.lineWidth = void 0;
      const iconCache = config2.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config2.id);
      if (iconCache) paragraphs.push(iconCache);
      else {
        const icon = new RichTextIcon(config2);
        icon.successCallback = () => {
          var _a2;
          this.addUpdateBoundTag(), null === (_a2 = this.stage) || void 0 === _a2 || _a2.renderNextFrame();
        }, icon.richtextId = config2.id, paragraphs.push(icon);
      }
    } else {
      const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
      if (isNumber_default(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
        const textParts = richTextConfig.text.split("\n");
        for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], false, richTextConfig, ascentDescentMode));
        else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], true, richTextConfig, ascentDescentMode));
        else {
          const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
          paragraphs.push(new Paragraph(textParts[j], true, nextRichTextConfig, ascentDescentMode));
        }
      } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, false, richTextConfig, ascentDescentMode));
    }
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0, maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0, richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth), richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight), frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || false, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new Wrapper(frame);
    if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
      let lineCount = 0, skip = false;
      for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        skip ? (p.overflow = true, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, true), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = true, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = true), p.newLine && (skip = false, wrapper.lineWidth = 0), wrapper.send();
      }
    } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function(l) {
        l.calcOffset(offsetSize, false);
      });
    }
    enableMultiBreakLine && frame.lines.forEach((item) => {
      const lastParagraphs = item.paragraphs;
      item.paragraphs = item.paragraphs.filter((p) => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
    }), this._frameCache = frame;
  }
  clone() {
    return new _RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach((icon) => {
      icon.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", (e) => {
      const pickedIcon = this.pickIcon(e.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
    }), this.addEventListener("pointerleave", (e) => {
      this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
    });
  }
  updateHoverIconState(pickedIcon) {
    var _a, _b, _c, _d, _e;
    pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(false), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(true), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
  }
  pickIcon(point6) {
    const frameCache = this.getFrameCache(), { e: x, f: y } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon, key) => {
      var _a, _b;
      const bounds = icon.AABBBounds.clone();
      bounds.translate(icon._marginArray[3], icon._marginArray[0]), bounds.containsPoint({
        x: point6.x - x,
        y: point6.y - y
      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon._marginArray[0]);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return _RichText.NOWORK_ANIMATE_ATTR;
  }
};
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/path.js
var PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
var Path = class _Path extends Graphic {
  constructor(params2) {
    super(params2), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { path } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = this.getGraphicTheme();
    if (!this.valid) return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil_default(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  getGraphicTheme() {
    return getTheme(this).path;
  }
  updateAABBBounds(attribute, pathTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const pathShape = this.getParsedPathShape();
      aabbBounds.union(pathShape.getBounds());
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = pathTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
  }
  doUpdateAABBBounds(full) {
    return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString_default(attribute.path, true) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new _Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Path.NOWORK_ANIMATE_ATTR;
  }
};
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/area.js
var AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
var Area = class _Area extends Graphic {
  constructor(params2) {
    super(params2), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && 0 !== points.length;
  }
  getGraphicTheme() {
    return getTheme(this).area;
  }
  updateAABBBounds(attribute, areaTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.setWidthHeightWithoutTransform(aabbBounds);
    const { lineJoin = areaTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const { points = areaTheme.points } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      var _a, _b;
      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }), b;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const { segments: segments2 = areaTheme.segments } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        var _a, _b;
        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      });
    }), b;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const path = new CustomPath2D(), attribute = this.attribute, segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        const basePoints = [];
        if (points.forEach((point6) => {
          var _a, _b;
          false !== point6.defined && (isFirst ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y), basePoints.push({
            x: null !== (_a = point6.x1) && void 0 !== _a ? _a : point6.x,
            y: null !== (_b = point6.y1) && void 0 !== _b ? _b : point6.y
          }), isFirst = false);
        }), basePoints.length) {
          for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
          path.closePath();
        }
      }
    };
    return attribute.points ? parsePoints(attribute.points) : segments2 && segments2.length && segments2.forEach((seg) => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new _Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Area.NOWORK_ANIMATE_ATTR;
  }
};
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/arc.js
var ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
var Arc = class _Arc extends Graphic {
  constructor(params2) {
    super(params2), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = this.getGraphicTheme(), { cornerRadius = arcTheme.cornerRadius, innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius), parseCR = (cornerRadius2) => Math.min(isNumber_default(cornerRadius2, true) ? cornerRadius2 : deltaRadius * parseFloat(cornerRadius2) / 100, deltaRadius / 2);
    if (isArray_default(cornerRadius)) {
      const crList = cornerRadius.map((cr) => parseCR(cr) || 0);
      return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
    }
    return parseCR(cornerRadius);
  }
  getParsedAngle() {
    const arcTheme = this.getGraphicTheme();
    let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
    const { cap = arcTheme.cap } = this.attribute, sign2 = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1, endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
      const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = this.attribute;
      outerRadius += outerPadding, innerRadius -= innerPadding;
      const capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon) return {
        startAngle: startAngle - sign2 * capAngle * startCap,
        endAngle: endAngle + sign2 * capAngle * endCap,
        sc: sign2 * capAngle * startCap,
        ec: sign2 * capAngle * endCap
      };
    }
    return {
      startAngle,
      endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = this.getGraphicTheme(), { innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding, padAngle = arcTheme.padAngle } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute, deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign2 = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)), p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign2, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign2, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle,
        outerEndAngle,
        innerStartAngle,
        innerEndAngle,
        innerDeltaAngle,
        outerDeltaAngle
      };
    }
    return {
      outerStartAngle,
      outerEndAngle,
      innerStartAngle,
      innerEndAngle,
      innerDeltaAngle,
      outerDeltaAngle
    };
  }
  getGraphicTheme() {
    return getTheme(this).arc;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.setWidthHeightWithoutTransform(aabbBounds);
    const { lineJoin = arcTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
    if (startAngle > endAngle) {
      const temp2 = startAngle;
      startAngle = endAngle, endAngle = temp2;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c, _d;
    const attribute = this.attribute, { startAngle, endAngle } = this.getParsedAngle();
    let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0), outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    const path = new CustomPath2D();
    if (outerRadius <= epsilon) path.moveTo(0, 0);
    else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));
    else {
      const xors = outerRadius * cos(startAngle), yors = outerRadius * sin(startAngle), xire = innerRadius * cos(endAngle), yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new _Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Arc.NOWORK_ANIMATE_ATTR;
  }
};
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/star.js
var STAR_UPDATE_TAG_KEY = ["width", "height", "spikes", "thickness", ...GRAPHIC_UPDATE_TAG_KEY];
var Star = class _Star extends Graphic {
  constructor(params2) {
    super(params2), this.type = "star", this._cachedPoints = [], this.numberType = STAR_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { width, height, spikes } = this.attribute;
    return (null == width || width > 0) && (null == height || height > 0) && (null == spikes || spikes >= 3 && Number.isInteger(spikes));
  }
  getGraphicTheme() {
    return getTheme(this).star;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const { width = 0, height = 0 } = attribute;
      (isFinite(width) || isFinite(height)) && aabbBounds.set(0, 0, width, height);
    }
    const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this), aabbBounds;
  }
  getCachedPoints() {
    return this.shouldUpdateShape() && (this._cachedPoints = this.getStarPoints(this.attribute, this.getGraphicTheme()), this.clearUpdateShapeTag()), this._cachedPoints;
  }
  getStarPoints(attribute, starTheme) {
    const { width = starTheme.width, height = starTheme.height, spikes = starTheme.spikes, thickness = starTheme.thickness } = attribute, validSpikes = Math.max(3, Math.floor(spikes)), validThickness = Math.max(0, Math.min(1, thickness)), points = [], outerRadius = Math.min(width, height) / 2, innerRadius = outerRadius * (1 - validThickness), centerX = width / 2, centerY = height / 2;
    for (let i = 0; i < 2 * validSpikes; i++) {
      const radius = i % 2 == 0 ? outerRadius : innerRadius, angle2 = Math.PI / validSpikes * i, scaleX = width / (2 * outerRadius), scaleY = height / (2 * outerRadius);
      points.push({
        x: centerX + Math.sin(angle2) * radius * scaleX,
        y: centerY - Math.cos(angle2) * radius * scaleY
      });
    }
    return this._cachedPoints = points, points;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "width" !== key && "height" !== key && "spikes" !== key && "thickness" !== key || (nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio);
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, STAR_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, STAR_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const starTheme = this.getGraphicTheme(), points = this.getStarPoints(this.attribute, starTheme), path = new CustomPath2D();
    return points.forEach((point6, index) => {
      0 === index ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Star(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Star.NOWORK_ANIMATE_ATTR;
  }
};
Star.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createStar(attributes) {
  return new Star(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/arc3d.js
var Arc3d = class _Arc3d extends Arc {
  constructor(params2) {
    super(params2), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute, r = outerRadius + height;
    return aabbBounds.setValue(-r, -r, r, r), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, false, this), aabbBounds;
  }
  getNoWorkAnimateAttr() {
    return _Arc3d.NOWORK_ANIMATE_ATTR;
  }
};
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc3d(attributes) {
  return new Arc3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/polygon.js
var POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Polygon = class _Polygon extends Graphic {
  constructor(params2) {
    super(params2), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { points } = this.attribute;
    return points && points.length >= 2;
  }
  getGraphicTheme() {
    return getTheme(this).polygon;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const { lineJoin = polygonTheme.lineJoin } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
    const { points = polygonTheme.points } = attribute;
    return points.forEach((p) => {
      aabbBounds.add(p.x, p.y);
    }), aabbBounds;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const points = this.attribute.points, path = new CustomPath2D();
    return points.forEach((point6, index) => {
      0 === index ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Polygon.NOWORK_ANIMATE_ATTR;
  }
};
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/pyramid3d.js
var Pyramid3d = class _Pyramid3d extends Polygon {
  constructor(params2) {
    super(params2), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    return this.findFace().vertices.forEach((v) => {
      const x = v[0], y = v[1];
      aabbBounds.add(x, y);
    }), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, this), aabbBounds;
  }
  findFace() {
    const { points } = this.attribute, kList = points.map((p, i) => {
      const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;
      return 0 === dx ? 0 : (p.y - p1.y) / dx;
    }), pointsMap = points.map((p) => ({
      p,
      d: 0
    }));
    let find = false, maxD = 0;
    for (let i = 0; i < kList.length - 1; i++) {
      for (let j = i + 1; j < kList.length; j++) {
        if (kList[i] === kList[j]) {
          find = true;
          const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
          pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
          const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
          pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
        }
        if (find) break;
      }
      if (find) break;
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      pointsMap.unshift({
        p,
        d: 0
      });
    }
    for (let i = 0; i < points.length; i++) {
      const delta = (maxD - pointsMap[i + points.length].d) / 2;
      pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
    }
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    };
    return pointsMap.forEach((p) => {
      faces.vertices.push([p.p.x, p.p.y, p.d]);
    }), faces.polygons.push({
      polygon: [0, 4, 5, 1],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [7, 6, 2, 3],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [0, 4, 7, 3],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 5, 6, 2],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return _Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
};
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPyramid3d(attributes) {
  return new Pyramid3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/shadow-root.js
var ShadowRoot = class extends Group {
  constructor(graphic) {
    super({
      x: 0,
      y: 0
    }), this.type = "shadowroot", this.shadowHost = graphic;
  }
  clearUpdateBoundTag() {
    super.clearUpdateBoundTag(), this.shadowHost && this.shadowHost.clearUpdateBoundTag();
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      const m4 = this.transMatrix;
      this._globalTransMatrix ? this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f) : this._globalTransMatrix = m4.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const parentMatrix = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
  }
};
function createShadowRoot(graphic) {
  return new ShadowRoot(graphic);
}

// node_modules/@visactor/vrender-core/es/graphic/graphic-creator.js
var GraphicCreator2 = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params2) {
    const cb = this.store.get(name);
    return cb ? cb(params2) : null;
  }
};
var graphicCreator = new GraphicCreator2();

// node_modules/@visactor/vrender-core/es/graphic/bounds.js
var text;
var richText;
function getTextBounds(params2) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params2), text.AABBBounds;
}
function getRichTextBounds(params2) {
  return richText || (richText = graphicCreator.CreateGraphic("richtext", {})), richText.setAttributes(params2), richText.AABBBounds;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-contribution-render.js
var __decorate8 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata6 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultBaseBackgroundRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    const { background, backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity, opacity = graphicAttribute.opacity, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY, backgroundClip = graphicAttribute.backgroundClip } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
      }
      backgroundClip && context.clip();
      const b = graphic.AABBBounds;
      context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio,
        backgroundScale,
        backgroundOffsetX,
        backgroundOffsetY
      }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b, params2) {
    const { backgroundMode, backgroundFit, backgroundKeepAspectRatio, backgroundScale = 1, backgroundOffsetX = 0, backgroundOffsetY = 0 } = params2, targetW = b.width(), targetH = b.height();
    let w = targetW, h = targetH;
    if ("no-repeat" === backgroundMode) if (backgroundFit) if (backgroundKeepAspectRatio) {
      const maxScale = Math.max(targetW / data.width, targetH / data.height);
      context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
    } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
    else {
      const resW = data.width * backgroundScale, resH = data.height * backgroundScale;
      context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
    }
    else {
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width, resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w = resW * (targetH / resH), h = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h = resH * (targetW / resW), w = targetW;
        }
        const dpr2 = context.dpr, canvas = canvasAllocate.allocate({
          width: w,
          height: h,
          dpr: dpr2
        }), ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr, pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
    }
  }
};
var defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
var DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach((c3) => {
      c3.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate8([injectable(), __param4(0, inject(ContributionProvider)), __param4(0, named(InteractiveSubRenderContribution)), __metadata6("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
var DefaultBaseClipRenderBeforeContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    const { clipConfig } = graphic.attribute;
    if (!clipConfig) return;
    const clipPath = graphic.getClipPath();
    if (!clipPath) return;
    const draw = !(fillCb || strokeCb), b = graphic.AABBBounds, width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(), height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
    draw && context.save(), context.beginPath(), false === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, true), draw && context.clip();
  }
};
var defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
var DefaultBaseClipRenderAfterContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const { clipConfig } = graphic.attribute;
    if (!clipConfig) return;
    graphic.getClipPath() && (fillCb || strokeCb || context.restore());
  }
};
var defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-texture-contribution-render.js
function formatRatio(ratio) {
  return ratio <= 0.5 ? 4 * ratio - 1 : -4 * ratio + 3;
}
function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
  const { fill = "orange", percent = 0.6, frequency = 4, opacity, phi = 0 } = textureOptions;
  let { amplitude = 10 } = textureOptions;
  amplitude *= formatRatio(ratio);
  const height = boundsHeight * (1 - percent), width = boundsWidth, step = Math.max(Math.round(width / 70), 2);
  ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
  const delta = width / frequency * ratio, c3 = width / Math.PI / (2 * frequency);
  for (let i = 0; i < width; i += step) {
    const y = amplitude * Math.sin((i + delta + phi) / c3 + phi);
    ctx.lineTo(i + offsetX, height + y + offsetY);
  }
  ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
}
var DefaultBaseTextureRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 10, this._tempSymbolGraphic = null;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r = (size - 2 * padding) / 2, dpr = targetContext.dpr, canvas = canvasAllocate.allocate({
      width: size,
      height: size,
      dpr
    }), ctx = canvas.getContext("2d");
    if (!ctx) return null;
    ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, size, size), cb(r, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = size / 2, y = x;
      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding;
      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const y = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2, dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2, dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = /* @__PURE__ */ new Map();
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
    var _a;
    const { textureRatio = graphicAttribute.textureRatio, textureOptions = null } = graphic.attribute;
    let pattern = this.textureMap.get(texture);
    if (!pattern) switch (texture) {
      case "circle":
        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "diamond":
        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "rect":
        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "vertical-line":
        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "horizontal-line":
        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-lr":
        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-rl":
        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "grid":
        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
    }
    if (textureOptions && textureOptions.dynamicTexture) {
      const { gridConfig = {}, useNewCanvas } = textureOptions, b = graphic.AABBBounds;
      x = b.x1, y = b.y1;
      const originalContext = context;
      let newCanvas;
      if (useNewCanvas) {
        newCanvas = canvasAllocate.allocate({
          width: b.width(),
          height: b.height(),
          dpr: context.dpr
        });
        const ctx = newCanvas.getContext("2d");
        ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
      }
      if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
        originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, true);
      }
      originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
      const width = b.width(), height = b.height(), padding = texturePadding, cellSize = textureSize, gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize), gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize), gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding, gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
      this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
      const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize, sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
      this._tempSymbolGraphic.setAttributes({
        size: [sizeW - gutterColumn, sizeH - gutterRow],
        symbolType: texture
      });
      const parsedPath = this._tempSymbolGraphic.getParsedPath();
      for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
        const _x = x + cellSize / 2 + j * cellSize, _y = y + cellSize / 2 + i * cellSize;
        null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), false === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
      }
      useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
    } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();
    else if ("wave" === texture) {
      context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
      const b = graphic.AABBBounds;
      drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
        fill: textureColor
      }), x + b.x1 - x, y + b.y1 - y), context.restore();
    }
  }
};
var defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/arc-contribution-render.js
var DefaultArcRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = arc.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { innerPadding = arcAttribute.innerPadding, outerPadding = arcAttribute.outerPadding, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, x: originX = arcAttribute.x, y: originY = arcAttribute.y, scaleX = arcAttribute.scaleX, scaleY = arcAttribute.scaleY, keepStrokeScale = arcAttribute.keepStrokeScale } = arc.attribute;
    let { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance: distance2 = arcAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance2 : getScaledStroke(context, distance2, context.dpr), deltaAngle = distance2 / outerRadius, sign2 = "outerBorder" === key ? 1 : -1;
      if (arc.setAttributes({
        outerRadius: outerRadius + sign2 * d,
        innerRadius: innerRadius - sign2 * d,
        startAngle: startAngle - sign2 * deltaAngle,
        endAngle: endAngle + sign2 * deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius + sign2 * d, innerRadius - sign2 * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = arcAttribute[key].opacity;
        arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
      outerRadius,
      innerRadius,
      startAngle,
      endAngle
    });
  }
};
var defaultArcRenderContribution = new DefaultArcRenderContribution();
var defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/circle-contribution-render.js
var DefaultCircleRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = circle3.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, x: originX = circleAttribute.x, y: originY = circleAttribute.y, scaleX = circleAttribute.scaleX, scaleY = circleAttribute.scaleY, keepStrokeScale = circleAttribute.keepStrokeScale } = circle3.attribute, renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance: distance2 = circleAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance2 : getScaledStroke(context, distance2, context.dpr), sign2 = "outerBorder" === key ? 1 : -1;
      if (context.beginPath(), context.arc(x, y, radius + sign2 * d, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle3, circle3.attribute, circleAttribute), strokeCb) strokeCb(context, borderStyle, circleAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = circleAttribute[key].opacity;
        circleAttribute[key].opacity = opacity, context.setStrokeStyle(circle3, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]), circleAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var defaultCircleRenderContribution = new DefaultCircleRenderContribution();
var defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/group-contribution-render.js
var DefaultGroupBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
      const b = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio,
        backgroundScale,
        backgroundOffsetX,
        backgroundOffsetY
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
};
var defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

// node_modules/@visactor/vrender-core/es/common/shape/rect.js
var halfPi2 = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius, roundCorner = true, edgeCb) {
  let cornerRadius;
  if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = true), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber_default(rectCornerRadius, true)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];
  else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])], leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]], leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]], rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]], rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]], rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]], rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]], leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]], leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
    if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
      edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
      const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];
      path.arc(centerX, centerY, _cornerRadius[1], -halfPi2, 0, false);
    }
    if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
      const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];
      edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi2, false);
    }
    if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
      const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];
      edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi2, pi, false);
    }
    if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
      const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];
      edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi2, false);
    }
  } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
  return !edgeCb && path.closePath(), path;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/rect-contribution-render.js
var __decorate9 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultRectRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = rect.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, x: originX = rectAttribute.x, y: originY = rectAttribute.y, scaleX = rectAttribute.scaleX, scaleY = rectAttribute.scaleY, x1, y1, keepStrokeScale = rectAttribute.keepStrokeScale } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
    const renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), sign2 = "outerBorder" === key ? -1 : 1, { distance: distance2 = rectAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance2 : getScaledStroke(context, distance2, context.dpr), nextX = x + sign2 * d, nextY = y + sign2 * d, dw = 2 * d;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign2 * dw, height - sign2 * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign2 * dw, height - sign2 * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = rectAttribute[key].opacity;
        rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = groupAttribute.stroke } = group.attribute;
    Array.isArray(stroke2) && stroke2.some((s2) => false === s2) && (doFillOrStroke.doStroke = false);
  }
};
SplitRectBeforeRenderContribution = __decorate9([injectable()], SplitRectBeforeRenderContribution);
var SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const { x1, y1, x: originX = groupAttribute.x, y: originY = groupAttribute.y, stroke: stroke2 = groupAttribute.stroke, cornerRadius = groupAttribute.cornerRadius, cornerType = groupAttribute.cornerType } = rect.attribute;
    let { width, height } = rect.attribute;
    if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke2) && stroke2.some((s2) => false === s2)) {
      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num))) {
        let lastStroke, lastStrokeI = 0;
        return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x12, y12, x2, y2) => {
          stroke2[i] && (lastStrokeI === i - 1 && stroke2[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
            stroke: stroke2[i]
          }), x, y, groupAttribute), context.beginPath(), context.moveTo(x12, y12), lastStroke = stroke2[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
        })), void context.stroke();
      }
      if (context.beginPath(), context.moveTo(x, y), stroke2[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke2[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke2[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke2[3]) {
        const adjustY = stroke2[0] ? y - context.lineWidth / 2 : y;
        context.lineTo(x, adjustY);
      } else context.moveTo(x, y);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate9([injectable()], SplitRectAfterRenderContribution);
var defaultRectRenderContribution = new DefaultRectRenderContribution();
var defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/image-contribution-render.js
var DefaultImageRenderContribution = class extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
};
var defaultImageRenderContribution = new DefaultImageRenderContribution();
var defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/symbol-contribution-render.js
var DefaultSymbolRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { outerBorder, innerBorder } = symbol.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, keepStrokeScale = symbolAttribute.keepStrokeScale } = symbol.attribute, renderBorder = (borderStyle, key) => {
      const doStroke2 = !(!borderStyle || !borderStyle.stroke), { distance: distance2 = symbolAttribute[key].distance } = borderStyle, d = keepStrokeScale ? distance2 : getScaledStroke(context, distance2, context.dpr), sign2 = "outerBorder" === key ? 1 : -1;
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x, y, sign2 * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);
      else if (doStroke2) {
        const lastOpacity = symbolAttribute[key].opacity;
        symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
};
var DefaultSymbolClipRangeStrokeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const { clipRange = graphicAttribute.clipRange, x: originX = graphicAttribute.x, y: originY = graphicAttribute.y, z = graphicAttribute.z, size = graphicAttribute.size, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY } = graphic.attribute, parsedPath = graphic.getParsedPath();
    if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
    context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a3) => {
      var _a, _b, _c, _d;
      if (graphic._parsedPath.svgCache) {
        const obj = Object.assign({}, a3);
        obj.fill = null !== (_a = a3.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj.opacity = null !== (_b = a3.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj.fillOpacity = graphic.attribute.fillOpacity, obj.stroke = null !== (_c = a3.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj.lineWidth = null !== (_d = a3.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a3 = obj;
      }
      a3.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a3, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
    }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
  }
};
var defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
var defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
var defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/star-contribution-render.js
var defaultStarTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultStarBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-texture-contribution-render.js
var DefaultAreaTextureRenderContribution = class extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { attribute = graphic.attribute } = options || {}, { texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"), textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"), textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"), texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding") } = attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/base-render.js
var result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
var BaseRender = class {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach((item) => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a3, b) => b.order - a3.order), this._beforeRenderContribitions = this._renderContribitions.filter((c3) => c3.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter((c3) => c3.time === BaseRenderContributionTime.afterFillStroke));
  }
  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach((c3) => {
      if (c3.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c3.supportedAppName) ? c3.supportedAppName : [c3.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c3.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach((c3) => {
      if (c3.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c3.supportedAppName) ? c3.supportedAppName : [c3.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c3.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  drawPathProxy(graphic, context, x, y, drawContext, params2, fillCb, strokeCb) {
    if (!graphic.pathProxy) return false;
    const themeAttributes = getTheme(graphic, null == params2 ? void 0 : params2.theme)[graphic.type.replace("3d", "")], { fill = themeAttributes.fill, stroke: stroke2 = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible, x: originX = themeAttributes.x, y: originY = themeAttributes.y } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!visible) return true;
    if (!doFill && !doStroke) return true;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return true;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), true;
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const { fill = defaultAttribute.fill, background, stroke: stroke2 = defaultAttribute.stroke, opacity = defaultAttribute.opacity, fillOpacity = defaultAttribute.fillOpacity, lineWidth = defaultAttribute.lineWidth, strokeOpacity = defaultAttribute.strokeOpacity, visible = defaultAttribute.visible } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    return !(!graphic.valid || !visible) && (!(!doFill && !doStroke) && (!!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible,
      sVisible,
      doFill,
      doStroke
    }));
  }
  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
    const { x = graphicAttribute.x, y = graphicAttribute.y, z = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle: angle2 = graphicAttribute.angle, postMatrix } = graphic.attribute, lastModelMatrix = context.modelMatrix, camera = context.camera;
    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)), onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle2 && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, true), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point6 = graphic.getOffsetXY(graphicAttribute);
      result.x += point6.x, result.y += point6.y, result.z = z, context.setTransformForCurrent();
    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, true);
    else if (camera && context.project) {
      const point6 = graphic.getOffsetXY(graphicAttribute);
      result.x += point6.x, result.y += point6.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle2);
    } else context.transformFromMatrix(graphic.transMatrix, true), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z), p2 = context.project(width, 0, z), p3 = context.project(width, height, z), _p1 = {
        x: 0,
        y: 0
      }, _p2 = {
        x: width,
        y: 0
      }, _p3 = {
        x: width,
        y: height
      };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, true);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle2) {
    const p = context.project(x, y, z);
    context.translate(p.x, p.y, false), context.scale(scaleX, scaleY, false), context.rotate(angle2, false), context.translate(-p.x, -p.y, false), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const { renderable } = graphic.attribute;
    if (false === renderable) return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params2) || (this.drawShape(graphic, context, x, y, drawContext, params2), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc-render.js
var __decorate10 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata7 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcRender = class extends BaseRender {
  constructor(arcRenderContribitions) {
    super(), this.arcRenderContribitions = arcRenderContribitions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(arcRenderContribitions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
      const temp2 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp2;
    }
    const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, limitedIcr, innerDeltaAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
      else {
        const a1 = endAngle - capAngle - 0.03, a22 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a22, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) context.lineTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11), a22 = endAngle - capAngle - 0.03;
        context.arc(cx, cy, innerRadius, a1, a22, clockwise);
      }
    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, x: originX = arcAttribute.x, y: originY = arcAttribute.y, fillStrokeOrder = arcAttribute.fillStrokeOrder } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean_default(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const { sc, startAngle, endAngle } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = false;
    const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke2);
    if (doFill || isFullStroke) {
      context.beginPath(), drawArcPath(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = true, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
      const _runFill = () => {
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
      }, _runStroke = () => {
        doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()));
      };
      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
    }
    if (!isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
    }
    if ((isBoolean_default(cap) && cap || cap[1]) && forceShowCap) {
      const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, { endAngle = arcAttribute.endAngle, fill: fill2 = arcAttribute.fill } = arc.attribute, startAngle = endAngle;
        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
          if (doFill) {
            const color = fill2;
            if ("conical" === color.gradient) {
              const lastColor = getConicGradientAt(0, 0, endAngle, color);
              fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
            }
          }
        }, _runStroke = () => {
          doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
        };
        _runFill(), _runStroke();
      }
    }
    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArcRender = __decorate10([injectable(), __param5(0, inject(ContributionProvider)), __param5(0, named(ArcRenderContribution)), __metadata7("design:paramtypes", [Object])], DefaultCanvasArcRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/circle-render.js
var __decorate11 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata8 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCircleRender = class extends BaseRender {
  constructor(circleRenderContribitions) {
    super(), this.circleRenderContribitions = circleRenderContribitions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(circleRenderContribitions);
  }
  drawShape(circle3, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle3, null == params2 ? void 0 : params2.theme).circle, { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, x: originX = circleAttribute.x, y: originY = circleAttribute.y, fillStrokeOrder = circleAttribute.fillStrokeOrder } = circle3.attribute, data = this.valid(circle3, circleAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle3, circle3.attribute, circleAttribute), this.beforeRenderStep(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, circle3.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle3, circle3.attribute, originX - x, originY - y, circleAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, circle3.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle3, circle3.attribute, originX - x, originY - y, circleAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle3, renderService, drawContext, params2) {
    const circleAttribute = getTheme(circle3, null == params2 ? void 0 : params2.theme).circle;
    this._draw(circle3, circleAttribute, false, drawContext, params2);
  }
};
DefaultCanvasCircleRender = __decorate11([injectable(), __param6(0, inject(ContributionProvider)), __param6(0, named(CircleRenderContribution)), __metadata8("design:paramtypes", [Object])], DefaultCanvasCircleRender);

// node_modules/@visactor/vrender-core/es/common/render-utils.js
function drawSegItem(ctx, curve, endPercent, params2) {
  if (!curve.p1) return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
  else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
  }
}

// node_modules/@visactor/vrender-core/es/common/render-curve.js
function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
  var _a;
  let p0 = curve.p0, newDefined0 = defined0;
  if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);
  else {
    const { originP1, originP2 } = curve;
    let validP;
    if (originP1 && false !== originP1.defined && !lastCurve ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
      newDefined0 = !defined0;
      const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
      path.moveTo(x + offsetX, y + offsetY, offsetZ);
    } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
  }
  return newDefined0;
}
function drawSegments(path, segPath, percent, clipRangeByDimension, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode = "none", drawConnect = false } = params2 || {};
  if (drawConnect && "none" === mode) return;
  if (!segPath) return;
  let needMoveTo = true;
  const { curves } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve2, defined02 = true;
      curves.forEach((curve, i) => {
        curve.originP1 !== curve.originP2 ? (defined02 = drawEachCurve(path, curve, lastCurve2, defined02, offsetX, offsetY, offsetZ), lastCurve2 = curve) : lastCurve2 = curve;
      });
    } else curves.forEach((curve) => {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
    });
    return;
  }
  if (percent <= 0) return;
  let direction;
  "x" === clipRangeByDimension ? direction = Direction.ROW : "y" === clipRangeByDimension ? direction = Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction);
  let drawedLengthUntilLast = 0, defined0 = true, lastCurve = null;
  for (let i = 0, n = curves.length; i < n; i++) {
    const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
    if (drawConnect) {
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = true;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params2), needMoveTo = false;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments2.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments2.points.forEach((p) => {
    false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, { points } = segments2, definedPointsList = [];
  let lastIdx = 0;
  for (let i = 0; i < points.length; i++) false === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), lastIdx = i);
  definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach((points2, i) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points2[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points2.forEach((p) => {
      false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
    for (let i2 = points2.length - 1; i2 >= 0; i2--) {
      const p = points2[i2];
      path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/line-render.js
var __decorate12 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line2, renderService, drawContext, params2) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line;
    this._draw(line2, lineAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb) {
    var _a;
    if (!cache) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY,
      offsetZ: z
    }), line2.cache && !isArray_default(line2.cache) && line2.cache.curves.every((c3) => c3.defined) && line2.attribute.curveType && line2.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    return false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), false;
  }
  drawLinearLineHighPerformance(line2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { points } = line2.attribute, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line2, line2.attribute, lineAttribute);
    const { x: originX = 0, x: originY = 0 } = line2.attribute;
    false !== fill && (fillCb ? fillCb(context, line2.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, line2.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, segments: segments2, points, closePath, curveTension = lineAttribute.curveTension, connectedType = lineAttribute.connectedType } = line2.attribute;
    if (!this.valid(line2, lineAttribute, fillCb, strokeCb)) return;
    let { curveType = lineAttribute.curveType } = line2.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line2.attribute;
    if (1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line2, context, !!fill, !!stroke2, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params2, fillCb, strokeCb);
    function parsePoint(points2, connectedType2) {
      return "none" === connectedType2 ? points2 : points2.filter((p) => false !== p.defined);
    }
    if (line2.shouldUpdateShape()) {
      const { points: points2, segments: segments3 } = line2.attribute, _points = points2;
      if (segments3 && segments3.length) {
        let startPoint, lastSeg;
        if (line2.cache = segments3.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y,
            curves: [{
              defined: false !== seg.points[0].defined
            }]
          }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint,
            curveTension
          });
          return lastSeg = data, data;
        }).filter((item) => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i = 0; i < line2.cache.length; i++) {
            const cacheItem = line2.cache[i];
            for (let i2 = 0; i2 < cacheItem.curves.length; i2++) if (cacheItem.curves[i2].defined) {
              startP = cacheItem.curves[i2].p0;
              break;
            }
            if (startP) break;
          }
          line2.cache[line2.cache.length - 1] && line2.cache[line2.cache.length - 1].lineTo(startP.x, startP.y, true);
        }
      } else {
        if (!points2 || !points2.length) return line2.cache = null, void line2.clearUpdateShapeTag();
        line2.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
          curveTension
        });
      }
      line2.clearUpdateShapeTag();
    }
    if (Array.isArray(line2.cache)) {
      const segments3 = line2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        line2.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], clipRange, clipRangeByDimension, x, y, line2, fillCb, strokeCb));
        });
      } else {
        const totalLength = line2.cache.reduce((l, c3) => l + c3.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        line2.cache.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], min(_cr, 1), clipRangeByDimension, x, y, line2, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, line2.cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, line2.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line2, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate12([injectable()], DefaultCanvasLineRender);

// node_modules/@visactor/vrender-core/es/common/render-area.js
function drawAreaSegments(path, segPath, percent, params2) {
  var _a;
  const { top, bottom } = segPath;
  if (top.curves.length !== bottom.curves.length) return;
  if (percent >= 1) {
    const topList2 = [], bottomList2 = [];
    let lastDefined2 = true;
    for (let i = 0, n = top.curves.length; i < n; i++) {
      const topCurve = top.curves[i];
      lastDefined2 !== topCurve.defined ? (lastDefined2 ? (drawAreaBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0) : (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1])), lastDefined2 = !lastDefined2) : lastDefined2 && (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1]));
    }
    return void drawAreaBlock(path, topList2, bottomList2, params2);
  }
  if (percent <= 0) return;
  let { direction } = params2 || {};
  const { curves: topCurves } = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = abs(endP.x - topCurves[0].p0.x), yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction = null != direction ? direction : xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN, Number.isFinite(xTotalLength) || (direction = Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = Direction.ROW);
  const totalDrawLength = percent * (direction === Direction.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0, lastDefined = true;
  const topList = [], bottomList = [];
  for (let i = 0, n = top.curves.length; i < n; i++) {
    const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction), percent2 = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent2 < 0) break;
    drawedLengthUntilLast += curCurveLength;
    let tc = null, bc = null;
    lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent2 < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent2)[0] : divideLinear(tc, percent2)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent2)[1] : divideLinear(bc, 1 - percent2)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
  }
  drawAreaBlock(path, topList, bottomList, params2);
}
function drawAreaBlock(path, topList, bottomList, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  let needMoveTo = true;
  topList.forEach((curve) => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }), needMoveTo = true;
  for (let i = bottomList.length - 1; i >= 0; i--) {
    const curve = bottomList[i];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }
  path.closePath();
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-contribution-render.js
var defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
var defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/area-render.js
var __decorate13 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata9 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaRender = class extends BaseRender {
  constructor(areaRenderContribitions) {
    super(), this.areaRenderContribitions = areaRenderContribitions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(areaRenderContribitions);
  }
  drawLinearAreaHighPerformance(area2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const { points } = area2.attribute;
    if (points.length < 2) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, area2.attribute, areaAttribute), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    });
    const { x: originX = 0, x: originY = 0 } = area2.attribute;
    false !== fill && (fillCb ? fillCb(context, area2.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    }), (() => {
      var _a2, _b2;
      if (stroke2) {
        const { stroke: stroke3 = areaAttribute && areaAttribute.stroke } = area2.attribute;
        if (isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1]) {
          if (context.beginPath(), stroke3[0]) {
            context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
            for (let i = 1; i < points.length; i++) {
              const p = points[i];
              context.lineTo(p.x + offsetX, p.y + offsetY, z);
            }
          } else if (stroke3[2]) {
            const endP = points[points.length - 1];
            context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
            for (let i = points.length - 2; i >= 0; i--) {
              const p = points[i];
              context.lineTo((null !== (_a2 = p.x1) && void 0 !== _a2 ? _a2 : p.x) + offsetX, (null !== (_b2 = p.y1) && void 0 !== _b2 ? _b2 : p.y) + offsetY, z);
            }
          }
        }
        strokeCb ? strokeCb(context, area2.attribute, areaAttribute) : (context.setStrokeStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
      }
    })();
  }
  drawShape(area2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area, { fill = areaAttribute.fill, stroke: stroke2 = areaAttribute.stroke, fillOpacity = areaAttribute.fillOpacity, z = areaAttribute.z, strokeOpacity = areaAttribute.strokeOpacity, curveTension = areaAttribute.curveTension, connectedType = areaAttribute.connectedType } = area2.attribute, data = this.valid(area2, areaAttribute, fillCb, strokeCb);
    if (!data) return;
    const { doFill } = data, doStroke = data.doStroke && data.sVisible, { clipRange = areaAttribute.clipRange, closePath, points, segments: segments2 } = area2.attribute;
    let { curveType = areaAttribute.curveType } = area2.attribute;
    function parsePoint(points2, connectedType2) {
      return "connect" !== connectedType2 ? points2 : points2.filter((p) => false !== p.defined);
    }
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area2, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params2, fillCb, strokeCb);
    if (area2.shouldUpdateShape()) {
      if (segments2 && segments2.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments2.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y
          }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data2 = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint,
            curveTension
          });
          return lastTopSeg = data2, data2;
        }).filter((item) => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i = segments2.length - 1; i >= 0; i--) {
          const points2 = segments2[i].points, bottomPoints = [];
          for (let i2 = points2.length - 1; i2 >= 0; i2--) bottomPoints.push({
            x: null !== (_a = points2[i2].x1) && void 0 !== _a ? _a : points2[i2].x,
            y: null !== (_b = points2[i2].y1) && void 0 !== _b ? _b : points2[i2].y
          });
          if (0 !== i) {
            const lastSegmentPoints = segments2[i - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension
          }), bottomCaches.unshift(lastBottomSeg));
        }
        area2.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length) return area2.cacheArea = null, void area2.clearUpdateShapeTag();
        {
          const topPoints = parsePoint(points, connectedType), bottomPoints = [];
          for (let i = topPoints.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_e = topPoints[i].x1) && void 0 !== _e ? _e : topPoints[i].x,
            y: null !== (_f = topPoints[i].y1) && void 0 !== _f ? _f : topPoints[i].y
          });
          const topCache = calcLineCache(topPoints, curveType, {
            curveTension
          }), bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension
          });
          area2.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area2.clearUpdateShapeTag();
    }
    if (Array.isArray(area2.cacheArea)) {
      const segments3 = area2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        area2.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], clipRange, x, y, z, area2, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area2.cacheArea.reduce((l, c3) => l + c3.top.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        area2.cacheArea.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], min(_cr, 1), x, y, z, area2, drawContext, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, area2.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area2.attribute, areaAttribute, clipRange, x, y, z, area2, drawContext, fillCb, strokeCb);
  }
  draw(area2, renderService, drawContext, params2) {
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area;
    this._draw(area2, areaAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb, strokeCb) {
    return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb, strokeCb);
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb, strokeCb) {
    if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
    context.beginPath();
    const { points, segments: segments2 } = area2.attribute;
    let endP, startP, direction = Direction.ROW;
    if (segments2) {
      const endSeg = segments2[segments2.length - 1];
      startP = segments2[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else startP = points[0], endP = points[points.length - 1];
    const xTotalLength = abs(endP.x - startP.x), yTotalLength = abs(endP.y - startP.y);
    direction = null == endP.x1 ? Direction.ROW : null == endP.y1 ? Direction.COLUMN : Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN : Direction.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
      offsetX,
      offsetY,
      offsetZ,
      direction
    }), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    return false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), (() => {
      if (false !== stroke2) if (strokeCb) strokeCb(context, attribute, defaultAttribute);
      else {
        const { stroke: stroke3 = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;
        isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke3[0] ? cache.top : cache.bottom, clipRange, direction === Direction.ROW ? "x" : "y", {
          offsetX,
          offsetY,
          offsetZ
        })), context.setStrokeStyle(area2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke();
      }
    })(), false;
  }
};
DefaultCanvasAreaRender = __decorate13([injectable(), __param7(0, inject(ContributionProvider)), __param7(0, named(AreaRenderContribution)), __metadata9("design:paramtypes", [Object])], DefaultCanvasAreaRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/path-contribution-render.js
var defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/path-render.js
var __decorate14 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata10 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathRender = class extends BaseRender {
  constructor(pathRenderContribitions) {
    super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(pathRenderContribitions);
  }
  drawShape(path, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params2 ? void 0 : params2.theme).path, { x: originX = pathAttribute.x, y: originY = pathAttribute.y, fillStrokeOrder = pathAttribute.fillStrokeOrder } = path.attribute, z = null !== (_b = this.z) && void 0 !== _b ? _b : 0, data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);
    else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
    const _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke()));
    }, _runFill = () => {
      doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params2) {
    const pathAttribute = getTheme(path, null == params2 ? void 0 : params2.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate14([injectable(), __param8(0, inject(ContributionProvider)), __param8(0, named(PathRenderContribution)), __metadata10("design:paramtypes", [Object])], DefaultCanvasPathRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect-render.js
var __decorate15 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata11 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectRender = class extends BaseRender {
  constructor(rectRenderContribitions) {
    super(), this.rectRenderContribitions = rectRenderContribitions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(rectRenderContribitions);
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, background, stroke: stroke2 = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x1, y1, x: originX = rectAttribute.x, y: originY = rectAttribute.y, fillStrokeOrder = rectAttribute.fillStrokeOrder } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    const _runFill = () => {
      doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
    }, _runStroke = () => {
      doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  draw(rect, renderService, drawContext, params2) {
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect;
    this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasRectRender = __decorate15([injectable(), __param9(0, inject(ContributionProvider)), __param9(0, named(RectRenderContribution)), __metadata11("design:paramtypes", [Object])], DefaultCanvasRectRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-render.js
var __decorate16 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata12 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(symbolRenderContribitions) {
    super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(symbolRenderContribitions);
  }
  drawShape(symbol, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol, { size = symbolAttribute.size, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, fillStrokeOrder = symbolAttribute.fillStrokeOrder, clipRange = symbolAttribute.clipRange } = symbol.attribute, data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    context.beginPath();
    let _size = size, _x = x, _y = y, _z = z;
    const camera = context.camera;
    if (keepDirIn3d && camera && context.project) {
      const p = context.project(x, y, z);
      context.camera = null, _size = isArray_default(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
    }
    false === parsedPath.draw(context, size, _x, _y, _z, (p, a3) => {
      var _a2, _b, _c, _d;
      if (symbol._parsedPath.svgCache) {
        const obj = Object.assign({}, a3);
        obj.fill = null !== (_a2 = a3.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj.opacity = null !== (_b = a3.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a3.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj.lineWidth = null !== (_d = a3.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a3 = obj;
      }
      const _runFill2 = () => {
        a3.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a3, originX - x, originY - y, symbolAttribute), context.fill()));
      }, _runStroke2 = () => {
        a3.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a3, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
      };
      fillStrokeOrder ? (_runStroke2(), _runFill2()) : (_runFill2(), _runStroke2());
    }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  draw(symbol, renderService, drawContext, params2) {
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol;
    this._draw(symbol, symbolAttribute, false, drawContext, params2);
  }
};
DefaultCanvasSymbolRender = __decorate16([injectable(), __param10(0, inject(ContributionProvider)), __param10(0, named(SymbolRenderContribution)), __metadata12("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

// node_modules/@visactor/vrender-core/es/allocator/bounds-allocate.js
var BoundsAllocate = Symbol.for("BoundsAllocate");
var DefaultBoundsAllocate = class {
  constructor() {
    this.pools = [];
    for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds());
  }
  allocate(x1, y1, x2, y2) {
    if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
    const b = this.pools.pop();
    return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
  }
  allocateByObj(b) {
    if (!this.pools.length) return new AABBBounds(b);
    const _b = this.pools.pop();
    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
  }
  free(b) {
    this.pools.push(b);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var boundsAllocate = new DefaultBoundsAllocate();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/text-contribution-render.js
var DefaultTextBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio } = graphic.attribute;
    let matrix, { background } = graphic.attribute;
    if (!background) return;
    const restore = () => {
      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, true, 1));
    };
    let b;
    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
    const shouldReCalBounds = isObject_default(background) && background.background, onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds, x2 = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0), y2 = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0), w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(), h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b = boundsAllocate.allocate(x2, y2, x2 + w, y2 + h), background = background.background, !onlyTranslate) {
        const w2 = b.width(), h2 = b.height();
        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w2, h2);
      }
    } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
      angle: 0,
      scaleX: 1,
      scaleY: 1,
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    })).clone());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return void restore();
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
        backgroundMode,
        backgroundFit,
        backgroundKeepAspectRatio
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else {
      const { backgroundCornerRadius } = graphic.attribute;
      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, true), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
    }
    shouldReCalBounds && boundsAllocate.free(b), restore();
  }
};
var defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/text-render.js
var __decorate17 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata13 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextRender = class extends BaseRender {
  constructor(textRenderContribitions) {
    super(), this.textRenderContribitions = textRenderContribitions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(textRenderContribitions);
  }
  drawShape(text2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { text: str, underline = textAttribute2.underline, lineThrough = textAttribute2.lineThrough, keepDirIn3d = textAttribute2.keepDirIn3d, direction = textAttribute2.direction, fontSize = textAttribute2.fontSize, verticalMode = textAttribute2.verticalMode, x: originX = textAttribute2.x, y: originY = textAttribute2.y } = text2.attribute, lineHeight = null !== (_a = calculateLineHeight(text2.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize, data = this.valid(text2, textAttribute2, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, transform3dMatrixToContextMatrix = !keepDirIn3d, z = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text2, text2.attribute, textAttribute2), this.beforeRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text2, textAttribute2, z, context);
    const drawText = (t, offsetX, offsetY, direction2) => {
      let _x = x + offsetX;
      const _y = y + offsetY;
      if (direction2) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, true), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), context.fillText(t, _x, _y, z))), direction2 && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute2, z), "horizontal" === direction) {
      const { multilineLayout } = text2;
      if (!multilineLayout) return void context.highPerformanceRestore();
      const { xOffset, yOffset } = multilineLayout.bbox;
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), multilineLayout.lines.forEach((line2) => {
        context.strokeText(line2.str, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y, z);
      }))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), multilineLayout.lines.forEach((line2) => {
        context.fillText(line2.str, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text2, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y, line2.descent, (line2.descent - line2.ascent) / 2, z, textAttribute2, context, {
          width: line2.width
        });
      })));
    } else {
      let { textAlign = textAttribute2.textAlign, textBaseline = textAttribute2.textBaseline } = text2.attribute;
      if (!verticalMode) {
        const t = textAlign;
        textAlign = null !== (_b = text2.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text2.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
      }
      text2.tryUpdateAABBBounds();
      const cache = text2.cache, { verticalList } = cache;
      context.textAlign = "left", context.textBaseline = "top";
      const totalHeight = lineHeight * verticalList.length;
      let totalW = 0;
      verticalList.forEach((verticalData) => {
        const _w = verticalData.reduce((a3, b) => a3 + (b.width || 0), 0);
        totalW = max(_w, totalW);
      });
      let offsetY = 0, offsetX = 0;
      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
        const currentW = verticalData.reduce((a3, b) => a3 + (b.width || 0), 0), dw = totalW - currentW;
        let currentOffsetY = offsetY;
        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach((item) => {
          const { text: text3, width, direction: direction2 } = item;
          drawText(text3, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction2), currentOffsetY += width;
        });
      });
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text2, textAttribute2, z, context), this.afterRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb);
  }
  draw(text2, renderService, drawContext, params2) {
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d;
    this._draw(text2, textAttribute2, computed3dMatrix, drawContext, params2);
  }
  drawUnderLine(underline, lineThrough, text2, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute2, context, multiOption) {
    if (lineThrough + underline <= 0) return;
    const { textAlign = textAttribute2.textAlign, fill = textAttribute2.fill, opacity = textAttribute2.opacity, underlineOffset = textAttribute2.underlineOffset, underlineDash = textAttribute2.underlineDash, fillOpacity = textAttribute2.fillOpacity } = text2.attribute, isMulti = !isNil_default(multiOption), w = isMulti ? multiOption.width : text2.clipedWidth, offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, anchorX, anchorY, textAttribute2), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = anchorY + offsetUnderLineY + underlineOffset;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, anchorX, anchorY, textAttribute2), context.beginPath();
      const dy = anchorY + offsetThroughLineY;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate17([injectable(), __param11(0, inject(ContributionProvider)), __param11(0, named(TextRenderContribution)), __metadata13("design:paramtypes", [Object])], DefaultCanvasTextRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/graphic-render.js
var __decorate18 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AbstractGraphicRender = class {
};
AbstractGraphicRender = __decorate18([injectable()], AbstractGraphicRender);

// node_modules/@visactor/vrender-core/es/common/polygon.js
function drawPolygon(path, points, x, y) {
  path.moveTo(points[0].x + x, points[0].y + y);
  for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
}
function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = true) {
  var _a;
  if (points.length < 3) return void drawPolygon(path, points, x, y);
  let startI = 0, endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
  for (let i = startI; i <= endI; i++) {
    const p1 = points[0 === i ? endI : (i - 1) % points.length], angularPoint = points[i % points.length], p2 = points[(i + 1) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle2 = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan = Math.abs(Math.tan(angle2));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan;
    const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length3 = Math.min(length1, length2);
    segment > length3 && (segment = length3, radius = length3 * tan);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L = getLength(dx, dy), circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
  }
  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point6, segment, length2, dx, dy) {
  const factor = segment / length2;
  return {
    x: point6.x - dx * factor,
    y: point6.y - dy * factor
  };
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/polygon-contribution-render.js
var defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-render.js
var __decorate19 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata14 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(polygonRenderContribitions) {
    super(), this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(polygonRenderContribitions);
  }
  drawShape(polygon, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon, { points = polygonAttribute.points, cornerRadius = polygonAttribute.cornerRadius, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y, closePath = polygonAttribute.closePath, fillStrokeOrder = polygonAttribute.fillStrokeOrder } = polygon.attribute, data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), cornerRadius <= 0 || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params2) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon;
    this._draw(polygon, polygonAttribute, false, drawContext, params2);
  }
};
DefaultCanvasPolygonRender = __decorate19([injectable(), __param12(0, inject(ContributionProvider)), __param12(0, named(PolygonRenderContribution)), __metadata14("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/group-render.js
var __decorate20 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata15 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  drawShape(group, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, { fill = groupAttribute.fill, background, stroke: stroke2 = groupAttribute.stroke, opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, clip = groupAttribute.clip, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible, fillStrokeOrder = groupAttribute.fillStrokeOrder, cornerType = groupAttribute.cornerType, x: originX = groupAttribute.x, y: originY = groupAttribute.y } = group.attribute, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!group.valid || !visible) return;
    if (!clip) {
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;
      context.disableFill = true, context.disableStroke = true, context.disableBeginPath = true, path.forEach((g) => {
        drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params2);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else 0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), this._groupRenderContribitions.forEach((c3) => {
      c3.time === BaseRenderContributionTime.beforeFillStroke && c3.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip();
    const _runFill = () => {
      doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.fill()));
    }, _runStroke = () => {
      doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this._groupRenderContribitions.forEach((c3) => {
      c3.time === BaseRenderContributionTime.afterFillStroke && c3.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const { clip, baseOpacity = 1, drawMode, x, y, width, height } = group.attribute, lastNativeContext = context.nativeContext, lastNativeCanvas = context.canvas.nativeCanvas;
    if (drawMode > 0) {
      const canvas = context.canvas, newCanvas = vglobal.createCanvas({
        width: canvas.width,
        height: canvas.height,
        dpr: 1
      }), newContext = newCanvas.getContext("2d"), transform30 = context.nativeContext.getTransform();
      newContext.setTransform(transform30.a, transform30.b, transform30.c, transform30.d, transform30.e, transform30.f), 1 === drawMode && (newContext.save(), newContext.clearRect(0, 0, canvas.width, canvas.height), newContext.beginPath(), newContext.rect(x, y, width, height), newContext.clip(), newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight), newContext.restore()), context.nativeContext = newContext, canvas.nativeCanvas = newCanvas;
    }
    clip ? context.save() : context.highPerformanceSave();
    const baseGlobalAlpha = context.baseGlobalAlpha;
    context.baseGlobalAlpha *= baseOpacity;
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, true);
    } else context.transformFromMatrix(group.transMatrix, true);
    context.beginPath(), params2.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params2, () => false, () => false) : this.drawShape(group, context, 0, 0, drawContext);
    const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = group.attribute;
    let p;
    if ((scrollX || scrollY) && context.translate(scrollX, scrollY), params2 && params2.drawingCb && (p = params2.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha = baseGlobalAlpha, drawMode > 0) {
      const newContext = context.nativeContext, newCanvas = context.canvas.nativeCanvas;
      lastNativeContext.save(), lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, true), 1 === drawMode && newContext.rect(x, y, width, height), lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
      const transform30 = newContext.getTransform();
      lastNativeContext.setTransform(transform30.a, transform30.b, transform30.c, transform30.d, transform30.e, transform30.f), context.nativeContext = lastNativeContext, context.canvas.nativeCanvas = lastNativeCanvas, lastNativeContext.restore();
    }
    p && p.then ? p.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate20([injectable(), __param13(0, inject(ContributionProvider)), __param13(0, named(GroupRenderContribution)), __metadata15("design:paramtypes", [Object])], DefaultCanvasGroupRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/image-render.js
var __decorate21 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata16 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
var DefaultCanvasImageRender = class extends BaseRender {
  constructor(imageRenderContribitions) {
    super(), this.imageRenderContribitions = imageRenderContribitions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image, { repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, x: originX = imageAttribute.x, y: originY = imageAttribute.y, cornerRadius = imageAttribute.cornerRadius, fillStrokeOrder = imageAttribute.fillStrokeOrder, cornerType = imageAttribute.cornerType, image: url } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("success" !== res.state) return;
    const width = image.width, height = image.height;
    context.beginPath();
    let needRestore = false;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = true), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
    const _runFill = () => {
      if (doFill) {
        if (fillCb) fillCb(context, image.attribute, imageAttribute);
        else if (fVisible) {
          context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
          let repeat = 0;
          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
            const pattern = context.createPattern(res.data, repeatStr[repeat]);
            context.fillStyle = pattern, context.translate(x, y, true), context.fillRect(0, 0, width, height), context.translate(-x, -y, true);
          } else context.drawImage(res.data, x, y, width, height);
        }
      }
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { image: url } = image.attribute;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("loading" === res.state && isString_default(url)) return void ResourceLoader.improveImageLoading(url);
    if ("success" !== res.state) return;
    const { context } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasImageRender = __decorate21([injectable(), __param14(0, inject(ContributionProvider)), __param14(0, named(ImageRenderContribution)), __metadata16("design:paramtypes", [Object])], DefaultCanvasImageRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol.js
var IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
var ArcRender = Symbol.for("ArcRender");
var Arc3dRender = Symbol.for("Arc3dRender");
var AreaRender = Symbol.for("AreaRender");
var CircleRender = Symbol.for("CircleRender");
var GraphicRender = Symbol.for("GraphicRender");
var GroupRender = Symbol.for("GroupRender");
var LineRender = Symbol.for("LineRender");
var PathRender = Symbol.for("PathRender");
var PolygonRender = Symbol.for("PolygonRender");
var RectRender = Symbol.for("RectRender");
var Rect3DRender = Symbol.for("Rect3DRender");
var SymbolRender = Symbol.for("SymbolRender");
var TextRender = Symbol.for("TextRender");
var RichTextRender = Symbol.for("RichTextRender");
var Pyramid3dRender = Symbol.for("Pyramid3dRender");
var GlyphRender = Symbol.for("GlyphRender");
var ImageRender = Symbol.for("ImageRender");
var RenderSelector = Symbol.for("RenderSelector");
var DrawContribution = Symbol.for("DrawContribution");
var StarRender = Symbol.for("StarRender");

// node_modules/@visactor/vrender-core/es/common/3d-interceptor.js
var draw3dItem = (context, graphic, callback, output) => {
  let result2, isPie = false, is3d = false;
  if (graphic.forEachChildren((c3) => (isPie = c3.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c3) => (is3d = !!c3.findFace, !is3d)), isPie) {
    const children = graphic.getChildren(), sortedChildren = [...children];
    sortedChildren.sort((a3, b) => {
      var _a, _b, _c, _d;
      let angle1 = (null !== (_b = null !== (_a = a3.attribute.startAngle) && void 0 !== _a ? _a : 0 + a3.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
      for (; angle1 < 0; ) angle1 += pi2;
      for (; angle2 < 0; ) angle2 += pi2;
      return angle2 - angle1;
    }), sortedChildren.forEach((c3) => {
      c3._next = null, c3._prev = null;
    }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c3) => {
      graphic.appendChild(c3);
    }), output.hack_pieFace = "outside", result2 = callback(isPie, is3d), result2 && result2.graphic || (output.hack_pieFace = "inside", result2 = callback(isPie, is3d)), result2 && result2.graphic || (output.hack_pieFace = "top", result2 = callback(isPie, is3d)), graphic.removeAllChild(), children.forEach((c3) => {
      c3._next = null, c3._prev = null;
    }), children.forEach((c3) => {
      graphic.appendChild(c3);
    });
  } else if (is3d) {
    const children = graphic.getChildren(), zChildren = children.map((g) => ({
      ave_z: g.findFace().vertices.map((v) => {
        var _a;
        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
      }).reduce((a3, b) => a3 + b, 0),
      g
    }));
    zChildren.sort((a3, b) => b.ave_z - a3.ave_z), graphic.removeAllChild(), zChildren.forEach((i) => {
      i.g._next = null, i.g._prev = null;
    }), graphic.update(), zChildren.forEach((i) => {
      graphic.add(i.g);
    }), result2 = callback(isPie, is3d), graphic.removeAllChild(), children.forEach((g) => {
      g._next = null, g._prev = null;
    }), graphic.update(), children.forEach((g) => {
      graphic.add(g);
    });
  } else result2 = callback(isPie, is3d);
  return result2;
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/draw-interceptor.js
var __decorate22 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata17 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
var tempDirtyBounds = new AABBBounds();
var tempBackupDirtyBounds = new AABBBounds();
var ShadowRootDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0 || (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0 || (graphic.attribute.shadowRootIdx < 0 || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.shadowRoot) return false;
    const { context } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, true), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds), tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
      const m4 = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m4), drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && (drawContribution.dirtyBounds.copy(tempDirtyBounds), drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds)), true;
  }
};
var DebugDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.attribute._debug_bounds) return false;
    const { context } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
    const b = graphic.AABBBounds;
    return true !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), true;
  }
};
var CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return false;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
};
CommonDrawItemInterceptorContribution = __decorate22([injectable(), __metadata17("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
var InteractiveDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, false, {
        skipUpdateCallback: true
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return true;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return false;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    const baseGraphic = graphic.baseGraphic;
    let intree = !!baseGraphic.stage, _g = baseGraphic.parent;
    for (; intree && _g && _g.stage !== _g; ) intree = !!_g.stage, _g = _g.parent;
    if (!intree) {
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(graphic);
      }
      return true;
    }
    if (baseGraphic) {
      this.processing = true;
      const { context } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, true), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = false, true;
    }
    return false;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
};
var Canvas3DDrawItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor) return false;
    drawContext.in3dInterceptor = true;
    const { context, stage } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m4 = context.currentMatrix;
    m4.a /= context.dpr, m4.b /= context.dpr, m4.c /= context.dpr, m4.d /= context.dpr, m4.e /= context.dpr, m4.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m4);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m5 = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m5, lastModelMatrix, matrix);
      }
    } else context.modelMatrix = matrix;
    return context.setTransform(1, 0, 0, 1, 0, 0, true), graphic.isContainer ? draw3dItem(context, graphic, (isPie, is3d) => drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d), drawContext) : drawContribution.renderItem(graphic, drawContext), context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = false, true;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};

// node_modules/@visactor/vrender-core/es/render/render-service.js
var __decorate23 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata18 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenderService = Symbol.for("RenderService");
var BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");
var DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach((g) => {
      this._prepare(g, updateBounds);
    });
  }
  _prepare(g, updateBounds) {
    g.forEachChildren((g2) => {
      this._prepare(g2, updateBounds);
    }), g.update({
      bounds: updateBounds,
      trans: true
    });
  }
  prepareRenderList() {
  }
  beforeDraw(params2) {
  }
  draw(params2) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params2) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  render(groups2, params2) {
    this.renderTreeRoots = groups2, this.drawParams = params2;
    const updateBounds = params2.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params2), this.draw(params2), this.afterDraw(params2), this.drawParams = null;
  }
};
DefaultRenderService = __decorate23([injectable(), __param15(0, inject(DrawContribution)), __metadata18("design:paramtypes", [Object])], DefaultRenderService);

// node_modules/@visactor/vrender-core/es/render/render-modules.js
var render_modules_default = new ContainerModule((bind) => {
  bind(RenderService).to(DefaultRenderService);
});

// node_modules/@visactor/vrender-core/es/picker/constants.js
var GraphicPicker = Symbol.for("GraphicPicker");
var PickerService = Symbol.for("PickerService");
var BoundsPicker = Symbol.for("BoundsPicker");
var GlobalPickerService = Symbol.for("GlobalPickerService");
var PickItemInterceptor = Symbol.for("PickItemInterceptor");
var PickServiceInterceptor = Symbol.for("PickServiceInterceptor");

// node_modules/@visactor/vrender-core/es/picker/pick-interceptor.js
var __decorate24 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ShadowPickServiceInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(result2, pickerService, point6, pickParams, params2) {
    if (result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; ) g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
};
ShadowPickServiceInterceptorContribution = __decorate24([injectable()], ShadowPickServiceInterceptorContribution);
var ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point6, pickParams, params2) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point6, pickParams, params2) : null;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point6, pickParams, params2) : null;
  }
  _pickItem(graphic, pickerService, point6, pickParams, params2) {
    var _a;
    if (!graphic.shadowRoot) return null;
    const { parentMatrix } = params2 || {};
    if (!parentMatrix) return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const theme2 = null === (_a = getTheme(graphic)) || void 0 === _a ? void 0 : _a[graphic.type], { shadowPickMode = null == theme2 ? void 0 : theme2.shadowPickMode } = graphic.attribute, g = graphic.shadowRoot, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(currentGroupMatrix.a * point6.x + currentGroupMatrix.c * point6.y + currentGroupMatrix.e, currentGroupMatrix.b * point6.x + currentGroupMatrix.d * point6.y + currentGroupMatrix.f), result2 = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), !result2.graphic && result2.group && "full" === shadowPickMode && (result2.graphic = result2.group), result2;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate24([injectable()], ShadowRootPickItemInterceptorContribution);
var InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point6.x, point6.y), context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result2 = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result2;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate24([injectable()], InteractivePickItemInterceptorContribution);
var Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
    const context = pickerService.pickContext, stage = graphic.stage;
    if (!context || !stage) return null;
    if (pickParams.in3dInterceptor = true, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      const result2 = draw3dItem(context, graphic, () => pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams), pickParams);
      return context.camera = null, pickParams.in3dInterceptor = false, context.restore(), result2;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate24([injectable()], Canvas3DPickItemInterceptor);

// node_modules/@visactor/vrender-core/es/picker/pick-modules.js
var pick_modules_default = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor), bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope(), bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution), bindContributionProvider(bind, PickServiceInterceptor);
});

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-module.js
var graphic_module_default = new ContainerModule((bind) => {
  bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator).toConstantValue(graphicCreator);
});

// node_modules/@visactor/vrender-core/es/plugins/constants.js
var AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
var PluginService = Symbol.for("PluginService");

// node_modules/@visactor/vrender-core/es/plugins/plugin-service.js
var __decorate25 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata19 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = false;
  }
  active(stage, params2) {
    this.stage = stage, this.actived = true;
    const { pluginList } = params2;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach((p) => {
      pluginList.includes(p.name) && this.register(p);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release(...params2) {
    this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate25([injectable(), __param16(0, inject(ContributionProvider)), __param16(0, named(AutoEnablePlugins)), __metadata19("design:paramtypes", [Object])], DefaultPluginService);

// node_modules/@visactor/vrender-core/es/plugins/plugin-modules.js
var plugin_modules_default = new ContainerModule((bind) => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

// node_modules/@visactor/vrender-core/es/core/contributions/env/modules.js
var modules_default = new ContainerModule((bind) => {
  bindContributionProvider(bind, EnvContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/modules.js
var modules_default2 = new ContainerModule((bind) => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/canvas2d-contribution.js
var __decorate26 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata20 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = false, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main) this.main = true, this.context = window2.getContext(), this.canvas = this.context.getCanvas();
    else {
      let nativeCanvas;
      this.main = false, params2.canvasId && (nativeCanvas = this.global.getElementById(params2.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window2.width,
        height: window2.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window2.getContext().getCanvas().nativeCanvas, canvas = wrapCanvas({
        nativeCanvas,
        width: window2.width,
        height: window2.height,
        dpr: window2.dpr,
        id: params2.canvasId,
        canvasControled: true,
        container: window2.getContainer(),
        x: windowCanvas.offsetLeft,
        y: windowCanvas.offsetTop
      });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {
  }
  render(group, params2, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }, params2), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach((l) => {
      const canvas = l.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate26([injectable(), __metadata20("design:paramtypes", [])], CanvasLayerHandlerContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/modules.js
var modules_default3 = new ContainerModule((bind) => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/modules.js
function load(container2) {
  container2.load(modules_default), container2.load(modules_default2), container2.load(modules_default3);
}

// node_modules/@visactor/vrender-core/es/common/sort.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parseChildMap(graphic, defaultZIndex, reverse) {
  const childMap = {}, zIdxArray = [];
  return graphic.forEachChildren((item) => {
    const { zIndex = defaultZIndex } = item.attribute;
    childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
  }, reverse), zIdxArray.sort((a3, b) => reverse ? b - a3 : a3 - b), {
    childMap,
    zIdxArray
  };
}
function foreach(graphic, defaultZIndex, cb, reverse = false, sort3d = false) {
  let needSort = false;
  if (sort3d) needSort = true;
  else {
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
      const { zIndex = defaultZIndex } = item.attribute;
      if (0 === i) lastZIndex = zIndex;
      else if (lastZIndex !== zIndex) return needSort = true, true;
      return false;
    }, reverse);
  }
  if (needSort) {
    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      sort3d && children.sort((a3, b) => {
        var _a, _b;
        return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a3.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i2 = 0; i2 < children.length; i2++) if (cb(children[i2], i2)) {
        skip = true;
        break;
      }
    }
  } else graphic.forEachChildren(cb, reverse);
}
function foreachAsync(graphic, defaultZIndex, cb, reverse = false) {
  return __awaiter4(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse);
  });
}
function findNextGraphic(graphic, id, defaultZIndex, reverse = false) {
  let needSort = false;
  graphic.forEachChildren((item, i) => {
    const { zIndex = defaultZIndex } = item.attribute;
    if (0 === i) ;
    else if (void 0 !== zIndex) return needSort = true, true;
    return false;
  }, reverse);
  let result2 = null, next = false;
  if (needSort) {
    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      for (let i2 = 0; i2 < children.length; i2++) {
        if (next) {
          skip = true, result2 = children[i2];
          break;
        }
        children[i2]._uid !== id || (next = true);
      }
    }
  } else graphic.forEachChildren((item) => next ? (result2 = item, true) : (item._uid === id && (next = true), false), reverse);
  return result2;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/draw-contribution.js
var __decorate27 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata21 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = /* @__PURE__ */ new Map(), this.defaultRenderMap = /* @__PURE__ */ new Map(), this.styleRenderMap = /* @__PURE__ */ new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, isArray_default(this.contributions) || (this.contributions = [this.contributions]), this.init();
  }
  init() {
    this.contributions.forEach((item) => {
      if (item.style) {
        const map4 = this.styleRenderMap.get(item.style) || /* @__PURE__ */ new Map();
        map4.set(item.numberType, item), this.styleRenderMap.set(item.style, map4);
      } else this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a3, b) => a3.order - b.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = true : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const { context, stage, viewBox, transMatrix } = drawContext;
    if (!context) return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
      dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
    }
    const d = context.dpr % 1;
    (d || 0.5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = true, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(true), context.translate(viewBox.x1, viewBox.y1, true), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = false, context.draw();
  }
  doRegister() {
    throw new Error("暂不支持");
  }
  _findNextGraphic(group) {
    let parent = group.parent, id = group._uid;
    for (; parent; ) {
      const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
      if (g) return g;
      id = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || false === group.attribute.visibleAll) return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = true, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, false) && "empty" !== group.attribute.boundsMode) return;
    let tempBounds3, nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds3 = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    this.renderItem(group, drawContext, {
      drawingCb: () => {
        var _a;
        skipSort ? group.forEachChildren((item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }) : foreach(group, DefaultAttribute.zIndex, (item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }, false, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
      }
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds3), boundsAllocate.free(tempBounds3), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const { layer, stage } = drawContext, { subLayers } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: false
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);
    else {
      let afterLayer = subLayers.get(nextGraphic._uid);
      afterLayer || (afterLayer = {
        layer: this.layerService.createLayer(stage),
        zIndex: subLayers.size
      }, subLayers.set(nextGraphic._uid, afterLayer));
      const afterContext = afterLayer.layer.getNativeHandler().getContext();
      this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
        drawContribution: idc,
        clear: "transparent",
        layer: afterLayer.layer,
        context: afterContext,
        startAtId: nextGraphic._uid,
        break: false
      }));
    }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params2) {
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params2)) return;
    }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer) return;
    let tempBounds3, retrans = this.scrollMatrix && (0 !== this.scrollMatrix.e || 0 !== this.scrollMatrix.f);
    if (graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      (scrollX || scrollY) && (retrans = true, this.scrollMatrix || (this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), this.scrollMatrix.translate(-scrollX, -scrollY));
    }
    if (retrans && (tempBounds3 = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix)), this.useDirtyBounds && !graphic.isContainer && "empty" !== graphic.attribute.boundsMode && !isRectIntersect(graphic.AABBBounds, null != tempBounds3 ? tempBounds3 : this.dirtyBounds, false)) {
      if (retrans && graphic.parent) {
        const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
        this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
      }
      return;
    }
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params2 && (params2.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params2) : renderer.draw(graphic, this.currentRenderService, drawContext, params2), retrans && graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
    }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
  }
  selectRenderByNumberType(type, graphic) {
    let data;
    if (graphic.attribute.renderStyle) {
      const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
      data = currentRenderMap && currentRenderMap.get(type);
    }
    return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b;
    const { clear, viewBox } = drawContext, width = viewBox.width(), height = viewBox.height();
    if (clear) {
      context.clearRect(0, 0, width, height);
      const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
      if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear);
        res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
      } else context.fillStyle = createColor(context, clear, {
        AABBBounds: {
          x1: 0,
          y1: 0,
          x2: 0 + width,
          y2: 0 + height
        }
      }, 0, 0), context.fillRect(0, 0, width, height);
    }
  }
  afterDraw(renderService, drawParams) {
  }
};
DefaultDrawContribution = __decorate27([injectable(), __param17(0, multiInject(GraphicRender)), __param17(1, inject(ContributionProvider)), __param17(1, named(DrawItemInterceptor)), __metadata21("design:paramtypes", [Array, Object])], DefaultDrawContribution);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-line-render.js
var __decorate28 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    if (line2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = line2.attribute;
      if (startAtIdx > segments2.length) return;
      const lineAttribute = getTheme(line2).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
      if (!line2.valid || !visible) return;
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
      const { context: context2 } = drawContext;
      for (let i = startAtIdx; i < startAtIdx + length2; i++) this.drawIncreaseSegment(line2, context2, segments2[i - 1], segments2[i], line2.attribute.segments[i], [lineAttribute, line2.attribute], x, y);
    } else super.drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb);
  }
  drawIncreaseSegment(line2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute), context.setStrokeStyle(line2, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate28([injectable()], DefaultIncrementalCanvasLineRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-area-render.js
var __decorate29 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area2, context, x, y, drawContext, params2, fillCb) {
    if (area2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = area2.attribute;
      if (startAtIdx > segments2.length) return;
      const areaAttribute = getTheme(area2).area, { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), doFill = runFill(fill);
      if (!area2.valid || !visible) return;
      if (!doFill) return;
      if (!fVisible && !fillCb) return;
      for (let i = startAtIdx; i < startAtIdx + length2; i++) this.drawIncreaseSegment(area2, context, segments2[i - 1], segments2[i], area2.attribute.segments[i], [areaAttribute, area2.attribute], x, y);
    } else super.drawShape(area2, context, x, y, drawContext, params2, fillCb);
  }
  drawIncreaseSegment(area2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute), context.setCommonStyle(area2, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate29([injectable()], DefaultIncrementalCanvasAreaRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-draw-contribution.js
var STATUS2;
var __decorate30 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata22 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
!function(STATUS3) {
  STATUS3[STATUS3.NORMAL = 0] = "NORMAL", STATUS3[STATUS3.STOP = 1] = "STOP";
}(STATUS2 || (STATUS2 = {}));
var DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = false, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS2.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw) return;
      this.currentRenderService = renderService;
      const { context, viewBox } = drawContext;
      context && (context.inuse = true, context.clearMatrix(), context.setTransformForCurrent(true), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, true), context.save(), renderService.renderTreeRoots.sort((a3, b) => {
        var _a, _b;
        return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach((group) => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = false, this.rendering = false;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter5(this, void 0, void 0, function* () {
      this.rendering = true, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter5(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter5(this, void 0, void 0, function* () {
            if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
              if (this.status === STATUS2.STOP) return true;
              if (item.isContainer) return false;
              if (i < this.currentIdx) return false;
              const frameTail = this.currFrameStartAt + group.incremental;
              return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
            }), resolve(false);
            else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {
                startAtIdx: graphic.incrementalAt,
                length: graphic.incremental
              }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();
              else this.renderItem(graphic, drawContext);
              resolve(false);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter5(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(false);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter5(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = false, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter5(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS2.STOP, yield new Promise((resolve) => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS2.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item) => "stopCb" !== item.name), resolve(false);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!drawContext.break && false !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = true)) : void (yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter5(this, void 0, void 0, function* () {
            yield foreachAsync(group, DefaultAttribute.zIndex, (item) => __awaiter5(this, void 0, void 0, function* () {
              drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
            })), resolve(false);
          })
        });
      }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate30([injectable(), __param18(0, multiInject(GraphicRender)), __param18(1, inject(DefaultIncrementalCanvasLineRender)), __param18(2, inject(DefaultIncrementalCanvasAreaRender)), __param18(3, inject(ContributionProvider)), __param18(3, named(DrawItemInterceptor)), __metadata22("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

// node_modules/@visactor/vrender-core/es/render/contributions/render/module.js
var module_default = new ContainerModule((bind) => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

// node_modules/@visactor/vrender-core/es/render/contributions/modules.js
function load2(container2) {
  container2.load(module_default);
}

// node_modules/@visactor/vrender-core/es/modules.js
function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = true, container.load(core_modules_default), container.load(graphic_module_default), container.load(render_modules_default), container.load(pick_modules_default), container.load(plugin_modules_default), load(container), load2(container));
}
preLoadAllModule.__loaded = false, preLoadAllModule();
var vglobal = container.get(VGlobal);
application.global = vglobal;
var graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
var transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
var graphicService = container.get(GraphicService);
application.graphicService = graphicService;
var layerService = container.get(LayerService);
application.layerService = layerService;

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/auto-render-plugin.js
var AutoRenderPlugin = class {
  constructor() {
    this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, this.handleChange), application.graphicService.hooks.onSetStage.tap(this.key, this.handleChange), application.graphicService.hooks.onRemove.tap(this.key, this.handleChange);
  }
  deactivate(context) {
    const filterByName = (taps) => taps.filter((item) => item.name !== this.key);
    application.graphicService.hooks.onAttributeUpdate.taps = filterByName(application.graphicService.hooks.onAttributeUpdate.taps), application.graphicService.hooks.onSetStage.taps = filterByName(application.graphicService.hooks.onSetStage.taps), application.graphicService.hooks.onRemove.taps = filterByName(application.graphicService.hooks.onRemove.taps);
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/auto-refresh-plugin.js
var AutoRefreshPlugin = class {
  constructor() {
    this.name = "AutoRefreshPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, this.dpr = application.global.devicePixelRatio, this.refresh();
  }
  refresh() {
    this._refreshByMediaQuery() || this._refreshByRaf();
  }
  _refreshByRaf() {
    const raf = application.global.getRequestAnimationFrame();
    this.rafId = raf(() => {
      application.global.devicePixelRatio !== this.dpr && (this.dpr = application.global.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, true)), this.refresh();
    });
  }
  _refreshByMediaQuery() {
    try {
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`, updatePixelRatio = () => {
        window.devicePixelRatio !== this.dpr && (this.dpr = window.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, true));
      }, dom = matchMedia(mqString);
      dom && dom.addEventListener("change", updatePixelRatio), this.autoRefreshCbs || (this.autoRefreshCbs = []), this.autoRefreshCbs.push(() => {
        dom && dom.removeEventListener("change", updatePixelRatio);
      });
    } catch (err) {
      return false;
    }
    return true;
  }
  deactivate(context) {
    var _a;
    const craf = application.global.getCancelAnimationFrame();
    craf && this.rafId && craf(this.rafId), null === (_a = this.autoRefreshCbs) || void 0 === _a || _a.forEach((cb) => {
      cb();
    }), this.autoRefreshCbs = void 0;
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/incremental-auto-render-plugin.js
var IncrementalAutoRenderPlugin = class {
  constructor() {
    this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
    }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
      group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = true, this.renderNextFrame(group));
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter((item) => item.name !== this.key);
  }
  renderNextFrame(group) {
    this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = true, application.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    const stage = this.pluginService.stage;
    this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group) => {
      const layer = group.layer;
      if (!layer || !group.layer.subLayers) return;
      const subLayer = group.layer.subLayers.get(group._uid);
      subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
        stage,
        layer,
        viewBox: stage.window.getViewBox(),
        transMatrix: stage.window.getViewBoxTransform(),
        clear: "transparent",
        renderService: stage.renderService,
        updateBounds: false,
        startAtId: group._uid,
        context: subLayer.layer.getNativeHandler().getContext()
      }, this.nextUserParams));
    }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/dirty-bounds-plugin.js
var globalBounds = new AABBBounds();
var DirtyBoundsPlugin = class {
  constructor() {
    this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params2.globalAABBBounds));
    }), application.graphicService.hooks.clearAABBBounds.tap(this.key, (graphic, stage, bounds) => {
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(bounds);
    }), application.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
      const stage = graphic.stage;
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.clearAABBBounds.taps = application.graphicService.hooks.clearAABBBounds.taps.filter((item) => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter((item) => item.name !== this.key);
  }
};

// node_modules/@visactor/vrender-core/es/animate/default-ticker.js
var defaultTicker = new DefaultTicker();
defaultTicker.addTimeline(defaultTimeline);
defaultTicker.setFPS(60);

// node_modules/@visactor/vrender-core/es/env-check.js
var _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv) try {
    const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
    _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
  } catch (err) {
    _isBrowserEnv = false;
  }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}

// node_modules/@visactor/vrender-core/es/factory.js
var Factory = class _Factory {
  static registerPlugin(pluginKey, pluginClass) {
    _Factory._pluginClasses[pluginKey] = pluginClass;
  }
  static getPlugin(pluginKey) {
    return _Factory._pluginClasses[pluginKey];
  }
};
Factory._pluginClasses = {};

// node_modules/@visactor/vrender-core/es/core/stage.js
var DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  X: 0,
  Y: 0,
  BACKGROUND: "white"
};
var Stage = class extends Group {
  set viewBox(b) {
    this.window.setViewBox(b);
  }
  get viewBox() {
    return this.window.getViewBox();
  }
  get x() {
    return this.window.getViewBox().x1;
  }
  set x(x) {
    const b = this.window.getViewBox();
    b.translate(x - b.x1, 0), this.window.setViewBox(b);
  }
  get y() {
    return this.window.getViewBox().y1;
  }
  set y(y) {
    const b = this.window.getViewBox();
    b.translate(0, y - b.y1), this.window.setViewBox(b);
  }
  get width() {
    return this.window.width;
  }
  set width(w) {
    this.resize(w, this.height);
  }
  get viewWidth() {
    return this.window.getViewBox().width();
  }
  set viewWidth(w) {
    this.resizeView(w, this.viewHeight);
  }
  get viewHeight() {
    return this.window.getViewBox().height();
  }
  set viewHeight(h) {
    this.resizeView(this.viewWidth, h);
  }
  get height() {
    return this.window.height;
  }
  set height(h) {
    this.resize(this.width, h);
  }
  get dpr() {
    return this.window.dpr;
  }
  set dpr(r) {
    this.setDpr(r);
  }
  get background() {
    var _a;
    return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
  }
  set background(b) {
    this._background = b;
  }
  get defaultLayer() {
    return this.at(0);
  }
  get eventSystem() {
    return this._eventSystem;
  }
  constructor(params2 = {}) {
    var _a;
    super({}), this.tickedBeforeRender = true, this._onVisibleChange = (visible) => {
      if (!(this._skipRender < 0)) if (visible) {
        if (this.dirtyBounds) {
          const b = this.window.getViewBox();
          this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
        }
        this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0;
      } else this._skipRender = 1;
    }, this.beforeRender = (stage) => {
      this._beforeRender && this._beforeRender(stage);
    }, this.afterRender = (stage) => {
      this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb) => cb(stage)), this._afterNextRenderCbs = null, this.tickedBeforeRender = false;
    }, this.afterTickCb = () => {
      var _a2;
      this.tickedBeforeRender = true, "performance" === (null === (_a2 = this.params.optimize) || void 0 === _a2 ? void 0 : _a2.tickRenderMode) || "rendering" !== this.state && this.render();
    }, this.params = params2, this.theme = new Theme(), this.hooks = {
      beforeRender: new SyncHook(["stage"]),
      afterRender: new SyncHook(["stage"])
    }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params2), this.window.create({
      width: params2.width,
      height: params2.height,
      viewBox: params2.viewBox,
      container: params2.container,
      dpr: params2.dpr || this.global.devicePixelRatio,
      canvasControled: false !== params2.canvasControled,
      title: params2.title || "",
      canvas: params2.canvas
    }), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._background = null !== (_a = params2.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
      main: true
    })), this.nextFrameRenderLayerSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.stage = this, this.renderStyle = params2.renderStyle, params2.autoRender && this.enableAutoRender(), params2.autoRefresh && this.enableAutoRefresh(), false === params2.disableDirtyBounds && this.enableDirtyBounds(), params2.enableHtmlAttribute && this.enableHtmlAttribute(params2.enableHtmlAttribute), params2.ReactDOM && this.enableReactAttribute(params2.ReactDOM), params2.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params2.beforeRender, this._afterRender = params2.afterRender, this.ticker = params2.ticker || defaultTicker, this.supportInteractiveLayer = false !== params2.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params2.optimize || (params2.optimize = {}), this.optmize(params2.optimize), params2.background && isString_default(this._background) && this._background.includes("/") && this.setAttributes({
      background: this._background
    }), this.ticker.on("afterTick", this.afterTickCb);
  }
  pauseRender(sr = -1) {
    this._skipRender = sr;
  }
  resumeRender() {
    this._skipRender = 0;
  }
  tryInitEventSystem() {
    this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
      targetElement: this.window,
      resolution: this.window.dpr || this.global.devicePixelRatio,
      rootNode: this,
      global: this.global,
      supportsPointerEvents: this.params.supportsPointerEvents,
      supportsTouchEvents: this.params.supportsTouchEvents
    }, this.params.event)));
  }
  preventRender(prevent2) {
    prevent2 ? this._skipRender = -1 / 0 : false !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
  }
  optmize(params2) {
    this.optmizeRender(params2.skipRenderWithOutRange), this.params.optimize = params2;
  }
  optmizeRender(skipRenderWithOutRange = false) {
    skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
  }
  getTimeline() {
    return this.timeline;
  }
  get3dOptions(options) {
    const { center: center2 = {
      x: this.width / 2,
      y: this.height / 2,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0
    }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
    return Object.assign(Object.assign({}, options), {
      center: center2,
      light,
      alpha,
      beta,
      camera,
      fieldRatio,
      fieldDepth
    });
  }
  set3dOptions(options) {
    var _a, _b, _d, _e, _f, _g;
    this.option3d = options;
    const options3d = this.get3dOptions(options), { light, center: center2, camera, alpha, beta, fieldRatio, fieldDepth } = options3d, { dir = [1, 1, -1], color = "white", ambient } = light, centerX = (null !== (_a = center2.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center2.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_d = center2.y) && void 0 !== _d ? _d : this.height / 2) + (null !== (_e = center2.dy) && void 0 !== _e ? _e : 0), centerVec3 = [centerX, centerY, (null !== (_f = center2.z) && void 0 !== _f ? _f : 0) + (null !== (_g = center2.dz) && void 0 !== _g ? _g : 0)];
    let cameraX = 0, cameraY = 0, cameraZ = 0;
    camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1);
    const DirectionalLight2 = Factory.getPlugin("DirectionalLight");
    DirectionalLight2 && (this.light = new DirectionalLight2(dir, color, ambient));
    const cameraParams = {
      left: 0,
      right: this.width,
      top: 0,
      bottom: this.height,
      fieldRatio,
      fieldDepth,
      viewParams: {
        pos: [cameraX, cameraY, cameraZ],
        center: centerVec3,
        up: [0, 1, 0]
      }
    };
    if (this.camera) this.camera.params = cameraParams;
    else {
      const OrthoCamera2 = Factory.getPlugin("OrthoCamera");
      OrthoCamera2 && (this.camera = new OrthoCamera2(cameraParams));
    }
    options.enableView3dTransform && this.enableView3dTransform();
  }
  setBeforeRender(cb) {
    this._beforeRender = cb;
  }
  setAfterRender(cb) {
    this._afterRender = cb;
  }
  afterNextRender(cb) {
    this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
  }
  enableView3dTransform() {
    if (this.view3dTranform) return;
    this.view3dTranform = true;
    const ViewTransform3dPlugin2 = Factory.getPlugin("ViewTransform3dPlugin");
    ViewTransform3dPlugin2 && this.pluginService.register(new ViewTransform3dPlugin2());
  }
  disableView3dTranform() {
    this.view3dTranform && (this.view3dTranform = false, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRender() {
    this.autoRender || (this.autoRender = true, this.pluginService.register(new AutoRenderPlugin()));
  }
  disableAutoRender() {
    this.autoRender && (this.autoRender = false, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRefresh() {
    this.autoRefresh || (this.autoRefresh = true, this.pluginService.register(new AutoRefreshPlugin()));
  }
  disableAutoRefresh() {
    this.autoRefresh && (this.autoRefresh = false, this.pluginService.findPluginsByName("AutoRefreshPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableIncrementalAutoRender() {
    this.increaseAutoRender || (this.increaseAutoRender = true, this.pluginService.register(new IncrementalAutoRenderPlugin()));
  }
  disableIncrementalAutoRender() {
    this.increaseAutoRender && (this.increaseAutoRender = false, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableDirtyBounds() {
    if (this.dirtyBounds) return;
    this.dirtyBounds = new Bounds();
    let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
    plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
  }
  disableDirtyBounds() {
    this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableLayout() {
    if (this._enableLayout) return;
    this._enableLayout = true;
    const FlexLayoutPlugin = Factory.getPlugin("FlexLayoutPlugin");
    FlexLayoutPlugin && this.pluginService.register(new FlexLayoutPlugin());
  }
  disableLayout() {
    this._enableLayout && (this._enableLayout = false, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableHtmlAttribute(container2) {
    if (this.htmlAttribute) return;
    const HtmlAttributePlugin2 = Factory.getPlugin("HtmlAttributePlugin");
    HtmlAttributePlugin2 && (this.htmlAttribute = container2, this.pluginService.register(new HtmlAttributePlugin2()));
  }
  disableHtmlAttribute() {
    this.htmlAttribute && (this.htmlAttribute = false, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableReactAttribute(container2) {
    if (this.reactAttribute) return;
    const ReactAttributePlugin2 = Factory.getPlugin("ReactAttributePlugin");
    ReactAttributePlugin2 && (this.reactAttribute = container2, this.pluginService.register(new ReactAttributePlugin2()));
  }
  disableReactAttribute() {
    this.reactAttribute && (this.reactAttribute = false, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  getPluginsByName(name) {
    return this.pluginService.findPluginsByName(name);
  }
  tryUpdateAABBBounds() {
    const viewBox = this.window.getViewBox();
    return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
  }
  combineLayer(ILayer1, ILayer2) {
    throw new Error("暂不支持");
  }
  createLayer(canvasId, layerMode) {
    if ("released" === this.releaseStatus) return;
    const layer = this.layerService.createLayer(this, {
      main: false,
      layerMode,
      canvasId
    });
    return this.appendChild(layer), layer;
  }
  sortLayer(cb) {
    const children = this.children;
    children.sort(cb), this.removeAllChild(), children.forEach((c3) => {
      this.appendChild(c3);
    });
  }
  removeLayer(ILayerId) {
    return this.removeChild(this.findChildByUid(ILayerId));
  }
  tryInitInteractiveLayer() {
    "released" !== this.releaseStatus && this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = false, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
  }
  clearViewBox(color) {
    this.window.clearViewBox(color);
  }
  render(layers, params2) {
    if ("released" === this.releaseStatus) return;
    this.ticker.start(), this.timeline.resume();
    const state = this.state;
    this.state = "rendering", this.tickedBeforeRender || this.ticker.trySyncTickStatus(), this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params2, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  combineLayersToWindow() {
    if ("harmony" === this.global.env) {
      const ctx = this.window.getContext().nativeContext;
      this.forEachChildren((layer, i) => {
        if (i > 0) {
          const image = layer.getNativeHandler().getContext().canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
          ctx.transferFromImageBitmap(image);
        }
      });
    }
  }
  renderNextFrame(layers, force) {
    this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer) => {
      this.nextFrameRenderLayerSet.add(layer);
    }), this.willNextFrameRender || (this.willNextFrameRender = true, this.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    if ("released" === this.releaseStatus) return;
    this.timeline.resume(), this.ticker.start();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  renderLayerList(layerList, params2) {
    const list = [];
    for (let i = 0; i < layerList.length; i++) {
      let l = layerList[i];
      "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
    }
    list.forEach((layer) => {
      layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer === this.interactiveLayer && this.dirtyBounds && this.dirtyBounds.clear(), layer.render({
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
        viewBox: this.window.getViewBox(),
        transMatrix: this.window.getViewBoxTransform()
      }, Object.assign({
        renderStyle: this.renderStyle
      }, params2)));
    }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && (this.dirtyBounds && this.dirtyBounds.clear(), this.interactiveLayer.render({
      renderService: this.renderService,
      updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
      viewBox: this.window.getViewBox(),
      transMatrix: this.window.getViewBoxTransform()
    }, Object.assign({
      renderStyle: this.renderStyle
    }, params2)));
  }
  resizeWindow(w, h, rerender = true) {
    this.window.resize(w, h), rerender && this.render();
  }
  resize(w, h, rerender = true) {
    "released" !== this.releaseStatus && (this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren((c3) => {
      c3.resize(w, h);
    }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render());
  }
  resizeView(w, h, rerender = true) {
    "released" !== this.releaseStatus && (this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren((c3) => {
      c3.resizeView(w, h);
    }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
      right: this.width,
      bottom: this.height
    })), rerender && this.render());
  }
  setViewBox(x, y, w, h, rerender) {
    let isRerender = true;
    "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), false === y && (isRerender = false)) : (this.viewBox.setValue(x, y, x + w, y + h), false === rerender && (isRerender = false)), this.forEachChildren((c3) => {
      c3.resizeView(this.viewBox.width(), this.viewBox.height());
    }), isRerender && this.render();
  }
  setDpr(dpr, rerender = true) {
    this.forEachChildren((c3) => {
      c3.setDpr(dpr);
    }), rerender && this.render();
  }
  setOrigin(x, y) {
    throw new Error("暂不支持");
  }
  export(type) {
    throw new Error("暂不支持");
  }
  pick(x, y) {
    if ("released" === this.releaseStatus) return;
    const result2 = this.getPickerService().pick(this.children, new Point(x, y), {
      bounds: this.AABBBounds
    });
    return !(!(null == result2 ? void 0 : result2.graphic) && !(null == result2 ? void 0 : result2.group)) && result2;
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  release() {
    super.release(), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach((layer) => {
      layer.release();
    }), this.interactiveLayer && (this.interactiveLayer.forEachChildren((item) => {
      item.setStage && item.setStage(null, null), this.interactiveLayer.removeChild(item);
    }), this.interactiveLayer.release()), this.window.release(), this.ticker.remTimeline(this.timeline), this.ticker.removeListener("afterTick", this.afterTickCb), this.renderService.renderTreeRoots = [];
  }
  setStage(stage) {
  }
  dirty(b, matrix) {
    "released" !== this.releaseStatus && (matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b));
  }
  getLayer(name) {
    return this.children.filter((layer) => layer.name === name)[0];
  }
  renderTo(window2) {
    "released" !== this.releaseStatus && this.forEachChildren((layer, i) => {
      layer.drawTo(window2, {
        renderService: this.renderService,
        viewBox: window2.getViewBox(),
        transMatrix: window2.getViewBoxTransform(),
        background: layer === this.defaultLayer ? this.background : void 0,
        clear: 0 === i,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      });
    });
  }
  renderToNewWindow(fullImage = true, viewBox) {
    if ("released" === this.releaseStatus) return;
    const window2 = container.get(VWindow), x1 = viewBox ? -viewBox.x1 : 0, y1 = viewBox ? -viewBox.y1 : 0, x2 = viewBox ? viewBox.x2 : this.viewWidth, y2 = viewBox ? viewBox.y2 : this.viewHeight, width = viewBox ? viewBox.width() : this.viewWidth, height = viewBox ? viewBox.height() : this.viewHeight;
    return window2.create({
      viewBox: {
        x1,
        y1,
        x2,
        y2
      },
      width,
      height,
      dpr: this.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    }), this.renderTo(window2), window2;
  }
  toCanvas(fullImage = true, viewBox) {
    if ("released" === this.releaseStatus) return;
    const c3 = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
    return c3.nativeCanvas ? c3.nativeCanvas : null;
  }
  setCursor(mode) {
    this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
  }
  getCursor() {
    return this._cursor;
  }
  eventPointTransform(e) {
    const point6 = this.global.mapToCanvasPoint(e, this.window.getContext().canvas.nativeCanvas);
    return this.stage.window.pointTransform(point6.x, point6.y);
  }
  pauseTriggerEvent() {
    this._eventSystem && this._eventSystem.pauseTriggerEvent();
  }
  resumeTriggerEvent() {
    this._eventSystem && this._eventSystem.resumeTriggerEvent();
  }
  getPickerService() {
    return this.pickerService || (this.pickerService = container.get(PickerService)), this.pickerService;
  }
};

// node_modules/@visactor/vrender-core/es/create.js
function createStage(params2) {
  return new Stage(params2);
}

// node_modules/@visactor/vrender-core/es/canvas/empty-context.js
var __decorate31 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata23 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
var globalPoint = {
  x: 0,
  y: 0
};
var EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    throw new Error("不支持getCanvas");
  }
  getContext() {
    throw new Error("不支持getContext");
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m4) {
    return matrixAllocate.allocateByObj(m4);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a3, b, c3, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a3, dpr * b, dpr * c3, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a3, b, c3, d, e, f, setTransform = true) {
    this.matrix.multiply(a3, b, c3, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.path.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  }
  lineTo(x, y) {
    this.path.lineTo(x, y);
  }
  moveTo(x, y) {
    this.path.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.path.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h) {
    this.path.rect(x, y, w, h);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    throw new Error("不支持createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("不支持createPattern");
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    throw new Error("不支持createRadialGradient");
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {
  }
  fillRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
  }
  fillText(text2, x, y) {
  }
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x, y) {
    return this.matrix.transformPoint({
      x,
      y
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x, y) {
    if (!this.lineWidth) return false;
    this.matrix.transformPoint({
      x,
      y
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text2) {
    throw new Error("不支持measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("不支持measureText");
  }
  setLineDash(segments2) {
  }
  stroke(path) {
  }
  strokeRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  strokeText(text2, x, y) {
  }
  drawImage() {
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setCommonStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setStrokeStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
  }
  setTextStyle(params2, defaultParams) {
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  setClearMatrix(a3, b, c3, d, e, f) {
    this._clearMatrix.setValue(a3, b, c3, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m4) => matrixAllocate.free(m4)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate31([injectable(), __metadata23("design:paramtypes", [Object, Number])], EmptyContext2d);

// node_modules/@visactor/vrender-core/es/canvas/contributions/base-canvas.js
var DefaultConfig2 = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1
};
var BaseCanvas = class {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(_x) {
    this._x = _x;
  }
  get y() {
    return this._y;
  }
  set y(_y) {
    this._y = _y;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  set nativeCanvas(nativeCanvas) {
    this._nativeCanvas = nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(width) {
    this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
  }
  get height() {
    return this._pixelHeight;
  }
  set height(height) {
    this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
  }
  getContext(str) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(visiable) {
    this._visiable = visiable, visiable ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(dpr) {
    this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(params2) {
    var _a;
    const { nativeCanvas, width = DefaultConfig2.WIDTH, height = DefaultConfig2.HEIGHT, dpr = DefaultConfig2.DPR, x, y, id, canvasControled = true } = params2;
    this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = false !== params2.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id, id && (nativeCanvas.id = id), this.init(params2);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {
  }
  show() {
  }
  applyPosition() {
  }
  resetStyle(params2) {
  }
  resize(width, height) {
  }
  toDataURL(mimeType, quality) {
    return "";
  }
  readPixels(x, y, w, h) {
    return this._context.getImageData(x, y, w, h);
  }
  convertToBlob(options) {
    throw new Error("暂未实现");
  }
  transferToImageBitmap() {
    throw new Error("暂未实现");
  }
  release(...params2) {
    this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
};
BaseCanvas.env = "browser";

// node_modules/@visactor/vrender-core/es/core/contributions/env/base-contribution.js
var __decorate32 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BaseEnvContribution = class {
  configure(service, ...p) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(dom) {
    return new AABBBounds();
  }
  removeDom(dom) {
    return false;
  }
  createDom(params2) {
    return null;
  }
  updateDom(dom, params2) {
    return false;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadBlob(url) {
    return fetch(url).then((data) => data.blob()).then((blob) => ({
      data: blob,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  getElementTop(dom, baseWindow) {
    return 0;
  }
  getElementLeft(dom, baseWindow) {
    return 0;
  }
  getElementTopLeft(dom, baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter6(this, void 0, void 0, function* () {
      return {
        loadState: "fail"
      };
    });
  }
  isMacOS() {
    return false;
  }
  copyToClipBoard(text2) {
    return Promise.resolve(null);
  }
};
BaseEnvContribution = __decorate32([injectable()], BaseEnvContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/window/base-contribution.js
var __decorate33 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata24 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BaseWindowHandlerContribution = class {
  constructor() {
    this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  onChange(cb) {
    this._onChangeCb = cb;
  }
  configure(window2, global) {
    global.env === this.type && window2.setWindowHandler(this);
  }
  release(...params2) {
    this.releaseWindow();
  }
  isVisible(bbox) {
    return true;
  }
  onVisibleChange(cb) {
  }
  getTopLeft(baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  setViewBox(vb) {
    this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
  }
  getViewBox() {
    return this.viewBox;
  }
  setViewBoxTransform(a3, b, c3, d, e, f) {
    this.modelMatrix.setValue(a3, b, c3, d, e, f);
  }
  getViewBoxTransform() {
    return this.modelMatrix;
  }
};
BaseWindowHandlerContribution = __decorate33([injectable(), __metadata24("design:paramtypes", [])], BaseWindowHandlerContribution);

// node_modules/@visactor/vrender-core/es/core/light.js
var DirectionalLight = class {
  constructor(dir, color, ambient = 0.8) {
    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
    const length2 = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    this.formatedDir = [dir[0] / length2, dir[1] / length2, dir[2] / length2];
  }
  computeColor(normal, color) {
    const lightDir = this.formatedDir, brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
    let colorArray;
    colorArray = isString_default(color) ? ColorStore.Get(color, ColorType.Color1) : color;
    const lightColorArray = this.colorRgb;
    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
  }
};
var registerDirectionalLight = () => {
  Factory.registerPlugin("DirectionalLight", DirectionalLight);
};

// node_modules/@visactor/vrender-core/es/core/camera.js
var OrthoCamera = class {
  set params(params2) {
    this._params = Object.assign({}, params2), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
  }
  get params() {
    return Object.assign({}, this._params);
  }
  constructor(params2) {
    this.params = params2;
  }
  getViewMatrix() {
    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
  }
  forceGetViewMatrix() {
    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
    const { pos, center: center2, up } = this.params.viewParams;
    return lookAt(this._viewMatrixCached, pos, center2, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
  }
  getProjectionMatrix() {
    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
  }
  forceGetProjectionMatrix() {
    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
    const { left: left2, top, right: right2, bottom } = this._params;
    return ortho(this._projectionMatrixCached, left2, right2, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
  }
  getField() {
    const { fieldRatio = 0.8, fieldDepth, left: left2, right: right2 } = this._params;
    return (null != fieldDepth ? fieldDepth : right2 - left2) * fieldRatio;
  }
  getProjectionScale(z) {
    const field5 = this.getField();
    return field5 / (field5 + z);
  }
  view(x, y, z) {
    const outP2 = [0, 0, 0];
    return transformMat4(outP2, [x, y, z], this._viewMatrixCached), outP2;
  }
  vp(x, y, z) {
    const outP2 = [0, 0, 0], { pos } = this._params.viewParams;
    transformMat4(outP2, [x, y, z], this._viewMatrixCached), x = outP2[0], y = outP2[1], z = outP2[2];
    const sizeProjection = this.getProjectionScale(z);
    return {
      x: x * sizeProjection + pos[0],
      y: y * sizeProjection + pos[1]
    };
  }
};
var registerOrthoCamera = () => {
  Factory.registerPlugin("OrthoCamera", OrthoCamera);
};

// node_modules/@visactor/vrender-core/es/picker/picker-service.js
var __decorate34 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata25 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPickService = class {
  constructor(pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.type = "default", this.global = application.global;
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a3, b) => a3.order - b.order), this.pickerServiceInterceptorContributions = this.pickServiceInterceptorContributions.getContributions().sort((a3, b) => a3.order - b.order);
  }
  pick(graphics, point6, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    params2.pickerService = this;
    const w = params2.bounds.width(), h = params2.bounds.height();
    if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point6)) return result2;
    this.pickContext && (this.pickContext.inuse = true), params2.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(true, 1);
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = graphics.length - 1; i >= 0 && (result2 = graphics[i].isContainer ? this.pickGroup(graphics[i], point6, parentMatrix, params2) : this.pickItem(graphics[i], point6, parentMatrix, params2), !result2.graphic); i--) group || (group = result2.group);
    if (result2.graphic || (result2.group = group), this.pickContext && (this.pickContext.inuse = false), this.pickerServiceInterceptorContributions.length) for (let i = 0; i < this.pickerServiceInterceptorContributions.length; i++) {
      const drawContribution = this.pickerServiceInterceptorContributions[i];
      drawContribution.afterPickItem && (result2 = drawContribution.afterPickItem(result2, this, point6, params2, {
        parentMatrix
      }));
    }
    return result2;
  }
  containsPoint(graphic, point6, params2) {
    var _a;
    return !!(null === (_a = this.pickItem(graphic, point6, null, null != params2 ? params2 : {
      pickContext: this.pickContext,
      pickerService: this
    })) || void 0 === _a ? void 0 : _a.graphic);
  }
  pickGroup(group, point6, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const context = params2.pickContext, lastMatrix = context.modelMatrix;
    if (context.camera) {
      const m4 = group.transMatrix, matrix = mat4Allocate.allocate();
      if (mat3Tomat4(matrix, m4), lastMatrix) {
        if (matrix) {
          const m5 = mat4Allocate.allocate();
          context.modelMatrix = multiplyMat4Mat4(m5, lastMatrix, matrix), mat4Allocate.free(matrix);
        }
      } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const result3 = drawContribution.beforePickItem(group, this, point6, params2, {
          parentMatrix
        });
        if (result3) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result3;
      }
    }
    const transMatrix = group.transMatrix, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(point6.x, point6.y);
    currentGroupMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup && !group.stage.camera) return result2;
    const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params2);
    pickedItem && pickedItem.graphic && (result2.graphic = pickedItem.graphic, result2.params = pickedItem.params);
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, (graphic) => {
      if (graphic.isContainer) {
        const newPoint2 = new Point(point6.x, point6.y), theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY, result2 = this.pickGroup(graphic, newPoint2, currentGroupMatrix, params2);
      } else {
        const newPoint2 = new Point(point6.x, point6.y);
        currentGroupMatrix.transformPoint(newPoint2, newPoint2);
        const theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY;
        const pickedItem2 = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        pickedItem2 && pickedItem2.graphic && (result2.graphic = pickedItem2.graphic, result2.params = pickedItem2.params);
      }
      return !!result2.graphic || !!result2.group;
    }, true, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result2.graphic || result2.group || !groupPicked || group.stage.camera || (result2.group = group), matrixAllocate.free(currentGroupMatrix), result2;
  }
  selectPicker(graphic) {
    const picker = this.pickerMap.get(graphic.numberType);
    return picker || null;
  }
};
DefaultPickService = __decorate34([injectable(), __param19(0, inject(ContributionProvider)), __param19(0, named(PickItemInterceptor)), __param19(1, inject(ContributionProvider)), __param19(1, named(PickServiceInterceptor)), __metadata25("design:paramtypes", [Object, Object])], DefaultPickService);

// node_modules/@visactor/vrender-core/es/picker/global-picker-service.js
var __decorate35 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata26 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultGlobalPickerService = class {
  constructor() {
    this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env);
  }
  configure(global, env) {
  }
  pick(graphics, point6, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = 0; i < graphics.length; i++) {
      if (graphics[i].isContainer) result2 = this.pickGroup(graphics[i], point6, parentMatrix, params2);
      else {
        const data = this.pickItem(graphics[i], point6, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      if (result2.graphic) break;
      group || (group = result2.group);
    }
    if (result2.graphic || (result2.group = group), result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; ) g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point6, params2) {
    return !!this.pickItem(graphic, point6, null, params2);
  }
  pickGroup(group, point6, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const transMatrix = group.transMatrix, newPoint = new Point(point6.x, point6.y);
    parentMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup) return result2;
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false !== group.attribute.childrenPickable && group.forEachChildren((graphic) => {
      if (graphic.isContainer) result2 = this.pickGroup(graphic, point6, parentMatrix, params2);
      else {
        const newPoint2 = new Point(point6.x, point6.y);
        parentMatrix.transformPoint(newPoint2, newPoint2);
        const data = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      return !!result2.graphic || !!result2.group;
    }), result2.graphic || result2.group || !groupPicked || (result2.group = group), result2;
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    return false === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point6) ? {
      graphic
    } : null;
  }
};
DefaultGlobalPickerService = __decorate35([injectable(), __metadata26("design:paramtypes", [])], DefaultGlobalPickerService);

// node_modules/@visactor/vrender-core/es/common/simplify.js
function simplifyRadialDist(points, sqTolerance) {
  let deltaX, deltaY, lastX = points[0].x, lastY = points[0].y;
  const newPoints = [points[0]];
  for (let i = 1, len = points.length; i < len; i++) deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
  return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
}
function flatten_simplify(points, tolerance, highestQuality) {
  if (points.length <= 10) return points;
  return points = highestQuality ? points : simplifyRadialDist(points, void 0 !== tolerance ? tolerance * tolerance : 1);
}

// node_modules/@visactor/vrender-core/es/allocator/graphic-allocate.js
var DefaultGraphicAllocate = class {
  constructor() {
    this.pools = [];
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultRectAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.rect(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(rect) {
    if (!this.pools.length) return application.graphicService.creator.rect(rect.attribute);
    const g = this.pools.pop();
    return g.initAttributes(rect.attribute), g;
  }
};
var defaultRectAllocate = new DefaultRectAllocate();
var DefaultArcAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.arc(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(arc) {
    if (!this.pools.length) return application.graphicService.creator.arc(arc.attribute);
    const g = this.pools.pop();
    return g.initAttributes(arc.attribute), g;
  }
};
var defaultArcAllocate = new DefaultArcAllocate();
var DefaultAreaAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.area(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area2) {
    if (!this.pools.length) return application.graphicService.creator.area(area2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area2.attribute), g;
  }
};
var defaultAreaAllocate = new DefaultAreaAllocate();
var DefaultCircleAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.circle(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area2) {
    if (!this.pools.length) return application.graphicService.creator.circle(area2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area2.attribute), g;
  }
};
var defaultCircleAllocate = new DefaultCircleAllocate();
var DefaultLineAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.line(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(line2) {
    if (!this.pools.length) return application.graphicService.creator.line(line2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(line2.attribute), g;
  }
};
var defaultLineAllocate = new DefaultLineAllocate();
var DefaultPathAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.path(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(path) {
    if (!this.pools.length) return application.graphicService.creator.path(path.attribute);
    const g = this.pools.pop();
    return g.initAttributes(path.attribute), g;
  }
};
var defaultPathAllocate = new DefaultPathAllocate();
var DefaultSymbolAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.symbol(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(symbol) {
    if (!this.pools.length) return application.graphicService.creator.symbol(symbol.attribute);
    const g = this.pools.pop();
    return g.initAttributes(symbol.attribute), g;
  }
};
var defaultSymbolAllocate = new DefaultSymbolAllocate();
var DefaultTextAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.text(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(text2) {
    if (!this.pools.length) return application.graphicService.creator.text(text2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(text2.attribute), g;
  }
};
var defaultTextAllocate = new DefaultTextAllocate();
var DefaultGraphicMemoryManager = class {
  constructor() {
    this.map = {
      text: defaultTextAllocate,
      symbol: defaultSymbolAllocate
    };
  }
  gc(g) {
    g.isContainer ? g.forEachChildren((i) => this.gc(i)) : this.gcItem(g);
  }
  gcItem(g) {
    const allocate = this.map[g.type];
    allocate && allocate.free(g);
  }
};
var defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc-module.js
var loadArcModule = false;
var arcModule = new ContainerModule((bind) => {
  loadArcModule || (loadArcModule = true, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect-module.js
var loadRectModule = false;
var rectModule = new ContainerModule((bind) => {
  loadRectModule || (loadRectModule = true, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/line-module.js
var loadLineModule = false;
var lineModule = new ContainerModule((bind) => {
  loadLineModule || (loadLineModule = true, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/area-module.js
var loadAreaModule = false;
var areaModule = new ContainerModule((bind) => {
  loadAreaModule || (loadAreaModule = true, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-module.js
var loadSymbolModule = false;
var symbolModule = new ContainerModule((bind) => {
  loadSymbolModule || (loadSymbolModule = true, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/circle-module.js
var loadCircleModule = false;
var circleModule = new ContainerModule((bind) => {
  loadCircleModule || (loadCircleModule = true, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/text-module.js
var loadTextModule = false;
var textModule = new ContainerModule((bind) => {
  loadTextModule || (loadTextModule = true, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/path-module.js
var loadPathModule = false;
var pathModule = new ContainerModule((bind) => {
  loadPathModule || (loadPathModule = true, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-module.js
var loadPolygonModule = false;
var polygonModule = new ContainerModule((bind) => {
  loadPolygonModule || (loadPolygonModule = true, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/star-render.js
var __decorate36 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata27 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasStarRender = class extends BaseRender {
  constructor(starRenderContribitions) {
    super(), this.starRenderContribitions = starRenderContribitions, this.numberType = STAR_NUMBER_TYPE, this.builtinContributions = [defaultStarBackgroundRenderContribution, defaultStarTextureRenderContribution], this.init(starRenderContribitions);
  }
  drawShape(star3, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const starAttribute = getTheme(star3, null == params2 ? void 0 : params2.theme).star, { x: originX = starAttribute.x, y: originY = starAttribute.y, fillStrokeOrder = starAttribute.fillStrokeOrder } = star3.attribute, data = this.valid(star3, starAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, points = star3.getCachedPoints();
    context.beginPath(), points && points.length && points.forEach((point6, index) => {
      0 === index ? context.moveTo(x + point6.x, y + point6.y) : context.lineTo(x + point6.x, y + point6.y);
    }), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(star3, star3.attribute, starAttribute), this.beforeRenderStep(star3, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
      doFill && (fillCb ? fillCb(context, star3.attribute, starAttribute) : fVisible && (context.setCommonStyle(star3, star3.attribute, originX - x, originY - y, starAttribute), context.fill()));
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, star3.attribute, starAttribute) : sVisible && (context.setStrokeStyle(star3, star3.attribute, originX - x, originY - y, starAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(star3, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
  }
  draw(star3, renderService, drawContext, params2) {
    const starAttribute = getTheme(star3, null == params2 ? void 0 : params2.theme).star;
    this._draw(star3, starAttribute, false, drawContext, params2);
  }
};
DefaultCanvasStarRender = __decorate36([injectable(), __param20(0, inject(ContributionProvider)), __param20(0, named(StarRenderContribution)), __metadata27("design:paramtypes", [Object])], DefaultCanvasStarRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/star-module.js
var loadStarModule = false;
var starModule = new ContainerModule((bind) => {
  loadStarModule || (loadStarModule = true, bind(StarRender).to(DefaultCanvasStarRender).inSingletonScope(), bind(GraphicRender).toService(StarRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-render.js
var __decorate37 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  drawShape(glyph, context, x, y, drawContext, params2, fillCb, strokeCb) {
    drawContext.drawContribution && glyph.getSubGraphic().forEach((item) => {
      const renderer = drawContext.drawContribution.getRenderContribution(item);
      renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params2, fillCb, strokeCb);
    });
  }
  draw(glyph, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    if (context.highPerformanceSave(), !drawContext.drawContribution) return;
    const glyphTheme = getTheme(glyph), subGraphic = glyph.getSubGraphic();
    subGraphic.length && subGraphic.forEach((g) => {
      drawContext.drawContribution.renderItem(g, drawContext, {
        theme: glyphTheme
      });
    }), context.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate37([injectable()], DefaultCanvasGlyphRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-module.js
var loadGlyphModule = false;
var glyphModule = new ContainerModule((bind) => {
  loadGlyphModule || (loadGlyphModule = true, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-render.js
var __decorate38 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata28 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x, y, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext, { strokeOpacity = richtextAttribute.strokeOpacity, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
    if (!richtext.valid || !visible) return;
    const fVisible = fillVisible(opacity, fillOpacity, true), sVisible = fillVisible(opacity, strokeOpacity, true);
    if (!fVisible) return;
    context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon, context, x, y, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon).richtextIcon, { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon.attribute, { backgroundWidth = width, backgroundHeight = height } = icon.attribute;
    if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
      const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, true)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, false, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate38([injectable(), __metadata28("design:paramtypes", [])], DefaultCanvasRichTextRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-module.js
var loadRichtextModule = false;
var richtextModule = new ContainerModule((bind) => {
  loadRichtextModule || (loadRichtextModule = true, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/image-module.js
var loadImageModule = false;
var imageModule = new ContainerModule((bind) => {
  loadImageModule || (loadImageModule = true, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/base-3d-render.js
var Base3dRender = class extends BaseRender {
  stroke(x, y, z, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((edge) => {
      const p1 = vertices[edge[0]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, p2 = vertices[edge[1]], v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x, y, z, face3d, faces, fillColor, context, light, graphic3d, graphic3dAttribute, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v) => context.view(v[0], v[1], v[2])[2]), sortFace = [];
    face3d.polygons.forEach((p, i) => {
      if (faces && !faces[i]) return;
      sortFace.push({
        faceIdx: i,
        polygon: p
      });
      const { polygon } = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p.ave_z = z1 + z2 + z3 + z4;
    }), sortFace.sort((a3, b) => b.polygon.ave_z - a3.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      }, v3 = {
        x: x + p3[0],
        y: y + p3[1],
        z: z + p3[2]
      }, v4 = {
        x: x + p4[0],
        y: y + p4[1],
        z: z + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, graphic3d && graphic3d.attribute, graphic3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-render.js
var __decorate39 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasRect3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, x1, y1, x: originX, y: originY, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return;
    const { light } = drawContext.stage || {}, face3d = rect.findFace();
    if (false !== fill) {
      context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, null, fc, context, light, null, null, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(rect, renderService, drawContext) {
    const rectAttribute = getTheme(rect).rect;
    this._draw(rect, rectAttribute, false, drawContext);
  }
};
DefaultCanvasRect3dRender = __decorate39([injectable()], DefaultCanvasRect3dRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-module.js
var loadRect3dModule = false;
var rect3dModule = new ContainerModule((bind) => {
  loadRect3dModule || (loadRect3dModule = true, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-render.js
var __decorate40 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
function drawArcPath2(arc, context, cx, cy, z, outerRadius, innerRadius) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp2 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp2;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy, z);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));
  else {
    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    outerDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < 1e-3 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = true) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
  }
  return context.closePath(), collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (radius <= epsilon) context.moveTo(cx, cy, z1);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
  else {
    const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle), xors = radius * cos(innerouterStartAngle), yors = radius * sin(innerouterStartAngle), xore = radius * cos(innerouterEndAngle), yore = radius * sin(innerouterEndAngle);
    innerouterDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
var DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, height = 10 } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const rgbArray = ColorStore.Get(fill, ColorType.Color255), { light } = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
      top: z,
      bottom: z + height
    }, n_face = {
      top: [0, 1, 0],
      bottom: [0, -1, 0],
      outside: [1, 0, -1],
      inside: [1, 0, -1]
    };
    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath2(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, true, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
      const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
      return "outside" === face ? {
        innerouterDeltaAngle: outerDeltaAngle,
        innerouterEndAngle: outerEndAngle,
        innerouterStartAngle: outerStartAngle
      } : {
        innerouterDeltaAngle: innerDeltaAngle,
        innerouterEndAngle: innerEndAngle,
        innerouterStartAngle: innerStartAngle
      };
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArc3DRender = __decorate40([injectable()], DefaultCanvasArc3DRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-module.js
var loadArc3dModule = false;
var arc3dModule = new ContainerModule((bind) => {
  loadArc3dModule || (loadArc3dModule = true, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-render.js
var __decorate41 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasPyramid3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  drawShape(pyramid3d, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const pyramidAttribute = getTheme(pyramid3d, null == params2 ? void 0 : params2.theme).polygon, { fill = pyramidAttribute.fill, stroke: stroke2 = pyramidAttribute.stroke, face = [true, true, true, true, true, true] } = pyramid3d.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
    const { light } = drawContext.stage || {}, face3d = pyramid3d.findFace();
    if (false !== fill) {
      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, pyramid3d, pyramidAttribute, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(pyramid3d, renderService, drawContext) {
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    this._draw(pyramid3d, pyramid3dAttribute, false, drawContext);
  }
};
DefaultCanvasPyramid3dRender = __decorate41([injectable()], DefaultCanvasPyramid3dRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-module.js
var loadPyramid3dModule = false;
var pyramid3dModule = new ContainerModule((bind) => {
  loadPyramid3dModule || (loadPyramid3dModule = true, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
});

// node_modules/@visactor/vrender-core/es/register/register-arc.js
function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

// node_modules/@visactor/vrender-core/es/register/register-arc3d.js
function registerArc3dGraphic() {
  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
}

// node_modules/@visactor/vrender-core/es/register/register-area.js
function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

// node_modules/@visactor/vrender-core/es/register/register-circle.js
function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

// node_modules/@visactor/vrender-core/es/register/register-glyph.js
function registerGlyphGraphic() {
  graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
}

// node_modules/@visactor/vrender-core/es/register/register-group.js
function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

// node_modules/@visactor/vrender-core/es/register/register-image.js
function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

// node_modules/@visactor/vrender-core/es/register/register-line.js
function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

// node_modules/@visactor/vrender-core/es/register/register-path.js
function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

// node_modules/@visactor/vrender-core/es/register/register-polygon.js
function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

// node_modules/@visactor/vrender-core/es/register/register-star.js
function registerStarGraphic() {
  graphicCreator.RegisterGraphicCreator("star", createStar);
}

// node_modules/@visactor/vrender-core/es/register/register-pyramid3d.js
function registerPyramid3dGraphic() {
  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
}

// node_modules/@visactor/vrender-core/es/register/register-rect.js
function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

// node_modules/@visactor/vrender-core/es/register/register-rect3d.js
function registerRect3dGraphic() {
  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
}

// node_modules/@visactor/vrender-core/es/register/register-richtext.js
function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

// node_modules/@visactor/vrender-core/es/register/register-symbol.js
function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

// node_modules/@visactor/vrender-core/es/register/register-text.js
function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

// node_modules/@visactor/vrender-core/es/register/register-shadowRoot.js
function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}

// node_modules/@visactor/vrender-core/es/register/register-wraptext.js
function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/html-attribute-plugin.js
var HtmlAttributePlugin = class {
  constructor() {
    this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {}, this.renderId = 0, this.onWheel = (ev) => {
      try {
        const newEvent = new ev.constructor(ev.type, ev);
        this.pluginService.stage.window.getContext().getCanvas().nativeCanvas.dispatchEvent(newEvent);
      } catch (err) {
        return;
      }
    };
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && this.drawHTML([...context.stage.getChildren()]);
    });
  }
  deactivate(context) {
    context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.unTap(this.key), application.graphicService.hooks.onRelease.unTap(this.key), this.release();
  }
  getWrapContainer(stage, userContainer, domParams) {
    let nativeContainer;
    return nativeContainer = userContainer ? "string" == typeof userContainer ? application.global.getElementById(userContainer) : userContainer : stage.window.getContainer(), {
      wrapContainer: application.global.createDom(Object.assign({
        tagName: "div",
        parent: nativeContainer
      }, domParams)),
      nativeContainer
    };
  }
  parseDefaultStyleFromGraphic(graphic) {
    const attrs = "text" === graphic.type && graphic.attribute ? graphic.attribute : getTheme(graphic).text;
    return textAttributesToStyle(attrs);
  }
  getTransformOfText(graphic) {
    const textTheme = getTheme(graphic).text, { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = graphic.attribute, cssAttrs = graphic.globalTransMatrix.toTransformAttrs(), { rotateDeg, scaleX, scaleY } = cssAttrs, translateMap = {
      left: "0",
      start: "0",
      end: "-100%",
      center: "-50%",
      right: "-100%",
      top: "0",
      middle: "-50%",
      bottom: "-100%",
      alphabetic: "-79%"
    }, originMap = {
      left: "0",
      start: "0",
      end: "100%",
      center: "50%",
      right: "100%",
      top: "0",
      middle: "50%",
      bottom: "100%",
      alphabetic: "79%"
    };
    return {
      textAlign,
      transform: `translate(${translateMap[textAlign]},${translateMap[textBaseline]}) rotate(${rotateDeg}deg) scaleX(${scaleX}) scaleY(${scaleY})`,
      transformOrigin: `${originMap[textAlign]} ${originMap[textBaseline]}`
    };
  }
  updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, options) {
    const { pointerEvents, penetrateEventList = [] } = options;
    let calculateStyle = this.parseDefaultStyleFromGraphic(graphic);
    calculateStyle.display = false !== graphic.attribute.visible ? "block" : "none", calculateStyle.pointerEvents = true === pointerEvents ? "all" : pointerEvents || "none", "none" !== calculateStyle.pointerEvents && (this.removeWrapContainerEventListener(wrapContainer), penetrateEventList.forEach((event) => {
      "wheel" === event && wrapContainer.addEventListener("wheel", this.onWheel);
    })), wrapContainer.style.position || (wrapContainer.style.position = "absolute", nativeContainer.style.position = "relative");
    let left2 = 0, top = 0;
    const b = graphic.globalAABBBounds;
    let anchorType = options.anchorType;
    if (isNil_default(anchorType) && (anchorType = "text" === graphic.type ? "position" : "boundsLeftTop"), "boundsLeftTop" === anchorType && (anchorType = "top-left"), "position" === anchorType || b.empty()) {
      const matrix = graphic.globalTransMatrix;
      left2 = matrix.e, top = matrix.f;
    } else {
      const anchor = calculateAnchorOfBounds(b, anchorType);
      left2 = anchor.x, top = anchor.y;
    }
    const containerTL = application.global.getElementTopLeft(nativeContainer, false), windowTL = stage.window.getTopLeft(false), viewBox = stage.viewBox, offsetX = left2 + windowTL.left - containerTL.left + viewBox.x1, offsetTop = top + windowTL.top - containerTL.top + viewBox.y1;
    if (calculateStyle.left = `${offsetX}px`, calculateStyle.top = `${offsetTop}px`, "text" === graphic.type && "position" === anchorType && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), this.getTransformOfText(graphic))), isFunction_default(options.style)) {
      const userStyle = options.style({
        top: offsetTop,
        left: offsetX,
        width: b.width(),
        height: b.height()
      }, graphic, wrapContainer);
      userStyle && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), userStyle));
    } else isObject_default(options.style) ? calculateStyle = Object.assign(Object.assign({}, calculateStyle), options.style) : isString_default(options.style) && options.style && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), styleStringToObject(options.style)));
    application.global.updateDom(wrapContainer, {
      width: options.width,
      height: options.height,
      style: calculateStyle
    });
  }
  clearCacheContainer() {
    this.htmlMap && Object.keys(this.htmlMap).forEach((key) => {
      this.htmlMap[key] && this.htmlMap[key].renderId !== this.renderId && this.removeElement(key);
    }), this.renderId += 1;
  }
  drawHTML(layers) {
    "browser" === application.global.env && (layers.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      this.renderGroupHTML(group);
    }), this.clearCacheContainer());
  }
  renderGroupHTML(group) {
    this.renderGraphicHTML(group), group.forEachChildren((g) => {
      g.isContainer ? this.renderGroupHTML(g) : this.renderGraphicHTML(g);
    });
  }
  removeElement(id) {
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const { wrapContainer } = this.htmlMap[id];
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id] = null;
  }
  removeWrapContainerEventListener(wrapContainer) {
    wrapContainer.removeEventListener("wheel", this.onWheel);
  }
  renderGraphicHTML(graphic) {
    var _a;
    const { html } = graphic.attribute;
    if (!html) return;
    const stage = graphic.stage;
    if (!stage) return;
    const { dom, container: container2 } = html;
    if (!dom) return;
    const id = isNil_default(html.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : html.id;
    if (this.htmlMap && this.htmlMap[id] && container2 && container2 !== this.htmlMap[id].container && this.removeElement(id), this.htmlMap && this.htmlMap[id]) "string" == typeof dom ? this.htmlMap[id].wrapContainer.innerHTML = dom : dom !== this.htmlMap[id].wrapContainer.firstChild && (this.htmlMap[id].wrapContainer.removeChild(this.htmlMap[id].wrapContainer.firstChild), this.htmlMap[id].wrapContainer.appendChild(dom));
    else {
      const { wrapContainer: wrapContainer2, nativeContainer: nativeContainer2 } = this.getWrapContainer(stage, container2);
      wrapContainer2 && ("string" == typeof dom ? wrapContainer2.innerHTML = dom : wrapContainer2.appendChild(dom), this.htmlMap || (this.htmlMap = {}), this.htmlMap[id] = {
        wrapContainer: wrapContainer2,
        nativeContainer: nativeContainer2,
        container: container2,
        renderId: this.renderId
      });
    }
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const { wrapContainer, nativeContainer } = this.htmlMap[id];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, html), this.htmlMap[id].renderId = this.renderId;
  }
  release() {
    "browser" === application.global.env && this.removeAllDom(this.pluginService.stage.defaultLayer);
  }
  removeAllDom(g) {
    this.htmlMap && (Object.keys(this.htmlMap).forEach((key) => {
      this.removeElement(key);
    }), this.htmlMap = null);
  }
};
var registerHtmlAttributePlugin = () => {
  Factory.registerPlugin("HtmlAttributePlugin", HtmlAttributePlugin);
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/react-attribute-plugin.js
var ReactAttributePlugin = class extends HtmlAttributePlugin {
  constructor() {
    super(...arguments), this.name = "ReactAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {};
  }
  removeElement(id) {
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const { root, wrapContainer, unmount } = this.htmlMap[id];
    if (root) {
      application.global.getRequestAnimationFrame()(() => {
        root.unmount();
      });
    } else unmount && unmount();
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id] = null;
  }
  renderGraphicHTML(graphic) {
    var _a;
    const { react } = graphic.attribute;
    if (!react) return;
    const stage = graphic.stage;
    if (!stage) return;
    const ReactDOM = stage.params.ReactDOM, { element, container: container2 } = react;
    if (!element || !ReactDOM || !ReactDOM.createRoot && !ReactDOM.render) return;
    const id = isNil_default(react.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : react.id;
    if (this.htmlMap && this.htmlMap[id] && container2 && container2 !== this.htmlMap[id].container && this.removeElement(id), this.htmlMap && this.htmlMap[id]) ReactDOM.createRoot ? this.htmlMap[id].root.render(element) : ReactDOM.render(element, this.htmlMap[id].wrapContainer);
    else {
      const { wrapContainer: wrapContainer2, nativeContainer: nativeContainer2 } = this.getWrapContainer(stage, container2);
      if (wrapContainer2) if (this.htmlMap || (this.htmlMap = {}), ReactDOM.createRoot) {
        const root = ReactDOM.createRoot(wrapContainer2);
        root.render(element), this.htmlMap[id] = {
          root,
          wrapContainer: wrapContainer2,
          nativeContainer: nativeContainer2,
          container: container2,
          renderId: this.renderId
        };
      } else ReactDOM.render(element, wrapContainer2), this.htmlMap[id] = {
        wrapContainer: wrapContainer2,
        nativeContainer: nativeContainer2,
        container: container2,
        renderId: this.renderId,
        unmount: () => {
          ReactDOM.unmountComponentAtNode(wrapContainer2);
        }
      };
    }
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const { wrapContainer, nativeContainer } = this.htmlMap[id];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, react), this.htmlMap[id].renderId = this.renderId;
  }
};
var registerReactAttributePlugin = () => {
  Factory.registerPlugin("ReactAttributePlugin", ReactAttributePlugin);
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/3dview-transform-plugin.js
var ViewTransform3dPlugin = class {
  constructor() {
    this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = (e) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = true, this.pageX = e.page.x, this.pageY = e.page.y);
    }, this.onMouseUp = (e) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = false);
    }, this.onMouseMove = (e) => {
      var _a, _b;
      const stage = this.pluginService.stage;
      if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {
        const deltaX = e.page.x - this.pageX, deltaY = e.page.y - this.pageY;
        this.pageX = e.page.x, this.pageY = e.page.y;
        const angle1 = deltaX / 100, angle2 = deltaY / 100;
        this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(this.option3d), stage.renderNextFrame();
      } else this.pageX = e.page.x, this.pageY = e.page.y;
    };
  }
  activate(context) {
    this.pluginService = context;
    const stage = context.stage;
    this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
  }
  deactivate(context) {
    const stage = context.stage;
    stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
  }
};
var registerViewTransform3dPlugin = () => {
  Factory.registerPlugin("ViewTransform3dPlugin", ViewTransform3dPlugin);
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/flex-layout-plugin.js
var _tempBounds2 = new AABBBounds();

// node_modules/@visactor/vchart/esm/util/array.js
function combineDomains(domains) {
  const result2 = [];
  for (let index = 0; index < domains.length; index++) {
    const domain = domains[index];
    0 !== index && domain[0] === result2[result2.length - 1] || result2.push(domain[0]), result2.push(domain[1]);
  }
  return result2;
}

// node_modules/@visactor/vchart/esm/util/debug.js
var warn = (msg, detail) => (isFunction_default(config.warnHandler) && config.warnHandler.call(null, msg, detail), detail ? Logger.getInstance().warn(`[VChart warn]: ${msg}`, detail) : Logger.getInstance().warn(`[VChart warn]: ${msg}`));
var error = (msg, detail, err) => {
  if (!config.silent) {
    if (!isFunction_default(config.errorHandler)) throw new Error(msg);
    config.errorHandler.call(null, msg, detail);
  }
};
var config = {
  silent: false,
  warnHandler: false,
  errorHandler: false
};

// node_modules/@visactor/vchart/esm/util/env.js
var isBrowser = isBrowserEnv();
var domDocument = isBrowser && globalThis ? globalThis.document : void 0;
function isTrueBrowser(mode) {
  return ("desktop-browser" === mode || "mobile-browser" === mode) && isBrowser;
}
function isMobileLikeMode(mode) {
  return isMiniAppLikeMode(mode) || "mobile-browser" === mode;
}
function isMiniAppLikeMode(mode) {
  return mode.includes("miniApp") || "lynx" === mode || "wx" === mode || "harmony" === mode;
}

// node_modules/@visactor/vchart/esm/util/id.js
var VChartId = 0;
function createID() {
  return VChartId >= 9999999 && (VChartId = 0), VChartId++;
}

// node_modules/@visactor/vchart/esm/util/type.js
function couldBeValidNumber(v) {
  return null != v && "" !== v && (!!isNumber_default(v) || +v == +v);
}
function toValidNumber2(v) {
  if (isValidNumber_default(v)) return v;
  const value = +v;
  return isValidNumber_default(value) ? value : 0;
}
function isDataDomainSpec(domain) {
  return !(!domain || 0 === domain.length) && (!isNil_default(domain[0]) && !isNil_default(domain[0].dataId) && isArray_default(domain[0].fields));
}

// node_modules/@visactor/vgrammar-util/es/accessor.js
var accessor = (fn, fields2, name) => (fn.fields = fields2 || [], fn.fname = name, fn);

// node_modules/@visactor/vgrammar-util/es/getter.js
var getter = (path) => (obj) => get_default(obj, path);

// node_modules/@visactor/vgrammar-util/es/accessors.js
var identity = (_) => _;
var zero = (_) => 0;

// node_modules/@visactor/vgrammar-util/es/error.js
var error2 = (message) => {
  Logger.getInstance().error(message);
};

// node_modules/@visactor/vgrammar-util/es/splitAccessPath.js
var splitAccessPath = (p) => {
  const path = [], n = p.length;
  let i, j, c3, q = null, b = 0, s2 = "";
  p += "";
  const push = () => {
    path.push(s2 + p.substring(i, j)), s2 = "", i = j + 1;
  };
  for (i = 0, j = 0; j < n; j += 1) if (c3 = p[j], "\\" === c3) s2 += p.substring(i, j), s2 += p.substring(++j, ++j), i = j;
  else if (c3 === q) push(), q = null, b = -1;
  else {
    if (q) continue;
    i === b && '"' === c3 || i === b && "'" === c3 ? (i = j + 1, q = c3) : "." !== c3 || b ? "[" === c3 ? (j > i && push(), i = j + 1, b = i) : "]" === c3 && (b || error2("Access path missing open bracket: " + p), b > 0 && push(), b = 0, i = j + 1) : j > i ? push() : i = j + 1;
  }
  return b && error2("Access path missing closing bracket: " + p), q && error2("Access path missing closing quote: " + p), j > i && (j += 1, push()), path;
};

// node_modules/@visactor/vgrammar-util/es/field.js
var fieldSingle = (fieldStr, name, opt = {}) => {
  if (isFunction_default(fieldStr)) return fieldStr;
  const path = splitAccessPath(fieldStr), parsedField = 1 === path.length ? path[0] : fieldStr;
  return accessor((opt && opt.get || getter)(path), [parsedField], name || parsedField);
};
var field = (fieldStr, name, opt = {}) => {
  if (isArray_default(fieldStr)) {
    const funcs = fieldStr.map((entry) => fieldSingle(entry, name, opt));
    return (datum) => funcs.map((func) => func(datum));
  }
  return fieldSingle(fieldStr, name, opt);
};

// node_modules/@visactor/vgrammar-util/es/extent.js
var extent = (array2, func) => {
  const valueGetter = isFunction_default(func) ? func : (val) => val;
  let min3, max3;
  if (array2 && array2.length) {
    const n = array2.length;
    for (let i = 0; i < n; i += 1) {
      let value = valueGetter(array2[i]);
      isNil_default(value) || !isNumber_default(value = +value) || Number.isNaN(value) || (isNil_default(min3) ? (min3 = value, max3 = value) : (min3 = Math.min(min3, value), max3 = Math.max(max3, value)));
    }
    return [min3, max3];
  }
  return [min3, max3];
};

// node_modules/@visactor/vgrammar-util/es/toPercent.js
var toPercent = (percent, total) => isNil_default(percent) ? total : isString_default(percent) ? total * parseFloat(percent) / 100 : percent;

// node_modules/@visactor/vgrammar-util/es/regression-linear.js
function ordinaryLeastSquares(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta;
  return [uY - slope * uX, slope];
}
function visitPoints(data, x, y, callback) {
  let u, v, i = -1;
  data.forEach((d) => {
    u = x(d), v = y(d), !isNil_default(u) && (u = +u) >= u && !isNil_default(v) && (v = +v) >= v && callback(u, v, ++i);
  });
}
function rSquared(data, x, y, uY, predict) {
  let SSE = 0, SST = 0;
  return visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse, SST += sst * sst;
  }), 1 - SSE / SST;
}
function regressionLinear(data, x = (datum) => datum.x, y = (datum) => datum.y) {
  let X = 0, Y = 0, XY = 0, X2 = 0, n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n, X += (dx - X) / n, Y += (dy - Y) / n, XY += (dx * dy - XY) / n, X2 += (dx * dx - X2) / n;
  });
  const coef = ordinaryLeastSquares(X, Y, XY, X2), predict = (x2) => coef[0] + coef[1] * x2;
  return {
    coef,
    predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// node_modules/@visactor/vgrammar-util/es/direction.js
function isHorizontal(direction) {
  return "horizontal" === direction;
}
function isVertical(direction) {
  return "vertical" === direction;
}
function isValidDirection(direction) {
  return "vertical" === direction || "horizontal" === direction;
}
function isValidPosition(position) {
  return "top" === position || "bottom" === position || "left" === position || "right" === position;
}
function isHorizontalPosition(position) {
  return "top" === position || "bottom" === position;
}

// node_modules/@visactor/vgrammar-util/es/shapes.js
var shapes = {
  triangleForward,
  triangleUpright: triangle,
  triangle,
  diamond: diamond2,
  square: square2,
  star: star2,
  cardioid,
  circle: circle2,
  pentagon
};
function diamond2() {
  return function(theta) {
    const thetaPrime = theta % (2 * Math.PI / 4);
    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
  };
}
function star2() {
  return function(theta) {
    const thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);
    return (theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0 ? 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime)) : 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));
  };
}
function square2() {
  return function(theta) {
    return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
  };
}
function triangle() {
  return function(theta) {
    const thetaPrime = (theta + 3 * Math.PI / 2) % (2 * Math.PI / 3);
    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
  };
}
function triangleForward() {
  return function(theta) {
    const thetaPrime = theta % (2 * Math.PI / 3);
    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
  };
}
function cardioid() {
  return function(theta) {
    return 1 + Math.sin(theta);
  };
}
function circle2() {
  return function() {
    return 1;
  };
}
function pentagon() {
  return function(theta) {
    const thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);
    return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));
  };
}
function getMaxRadiusAndCenter(shape, size) {
  const w = size[0], h = size[1];
  let maxRadius = 1;
  const center2 = [size[0] >> 1, size[1] >> 1];
  switch (shape) {
    case "cardioid":
      center2[1] = ~~(h / 2.7 * 0.4), maxRadius = Math.floor(Math.min(w / 2.3, h / 2.6));
      break;
    case "triangleForward":
      maxRadius = h / Math.sqrt(0.75) > w ? Math.floor(w / 2) : Math.floor(h / (2 * Math.sqrt(0.75)));
      break;
    case "triangle":
    case "triangleUpright":
      center2[1] = ~~(h / 1.5), maxRadius = Math.floor(Math.min(h / 1.5, w / 2));
      break;
    case "circle":
    case "diamond":
    case "square":
    case "star":
    case "pentagon":
      maxRadius = Math.floor(Math.min(w / 2, h / 2));
      break;
    default:
      maxRadius = Math.floor(Math.max(w / 2, h / 2));
  }
  return {
    maxRadius,
    center: center2
  };
}
var getShapeFunction = (type) => shapes[type] ? shapes[type]() : shapes.circle();

// node_modules/@visactor/vgrammar-util/es/image.js
var generateIsEmptyPixel = (backgroundColor) => {
  if (!backgroundColor || "#fff" === backgroundColor) return (imageData, y, x) => {
    const width = imageData.width;
    return 0 === imageData.data[y * width * 4 + 4 * x + 3] || 255 === imageData.data[y * width * 4 + 4 * x + 0] && 255 === imageData.data[y * width * 4 + 4 * x + 1] && 255 === imageData.data[y * width * 4 + 4 * x + 2];
  };
  const bctx = vglobal.createCanvas({
    width: 1,
    height: 1
  }).getContext("2d", {
    willReadFrequently: true
  });
  bctx.fillStyle = backgroundColor, bctx.fillRect(0, 0, 1, 1);
  const bgPixel = bctx.getImageData(0, 0, 1, 1).data;
  return (imageData, y, x) => {
    const width = imageData.width;
    return [0, 1, 2, 3].every((i) => imageData.data[4 * (y * width + x) + i] === bgPixel[i]);
  };
};
var generateMaskCanvas = (shape, width, height, cacheCanvas) => {
  const { backgroundColor = "#fff" } = shape, maskCanvas = cacheCanvas || vglobal.createCanvas({
    width,
    height,
    dpr: 1
  }), tempContext = maskCanvas.getContext("2d", {
    willReadFrequently: true
  });
  if (cacheCanvas) {
    const prevWidth = cacheCanvas.width, prevHeight = cacheCanvas.height;
    tempContext.clearRect(0, 0, prevWidth, prevHeight), cacheCanvas.style.width = `${width}px`, cacheCanvas.style.height = `${height}px`, cacheCanvas.width = width, cacheCanvas.height = height;
  }
  return tempContext.fillStyle = backgroundColor, tempContext.fillRect(0, 0, maskCanvas.width, maskCanvas.height), "text" === shape.type ? drawTextMask(shape, maskCanvas.width, maskCanvas.height, tempContext) : "geometric" === shape.type && drawGeometricMask(shape, maskCanvas.width, maskCanvas.height, tempContext), maskCanvas;
};
var drawTextMask = (shape, width, height, ctx) => {
  const { fontFamily = "sans-serif", fontWeight = "normal", fontStyle = "normal", fontVariant = "normal", fill, text: text2, hollow } = shape;
  let baseFontSize = 12;
  ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, ctx.textAlign = "center", ctx.textBaseline = "middle", ctx.fillStyle = null != fill ? fill : "black";
  const textMetrics = ctx.measureText(text2), scale4 = "normal" !== fontStyle ? 1.1 : 1, actualWidth = isValid_default(textMetrics.actualBoundingBoxRight) && isValid_default(textMetrics.actualBoundingBoxLeft) ? Math.ceil(scale4 * (Math.abs(textMetrics.actualBoundingBoxRight) + Math.abs(textMetrics.actualBoundingBoxLeft))) : 0, textWidth = Math.max(Math.ceil(textMetrics.width), actualWidth, baseFontSize);
  if (hollow && (ctx.globalCompositeOperation = "xor"), textWidth > width) {
    const scale5 = Math.min(width / textWidth, height / baseFontSize);
    ctx.fillText(text2, width / 2, height / 2), ctx.scale(scale5, scale5);
  } else baseFontSize = Math.floor(baseFontSize * width / textWidth), baseFontSize = Math.min(baseFontSize, height), ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, ctx.fillText(text2, Math.floor(width / 2), Math.floor(height / 2));
};
var generatePoints = (center2, radius, startAngle = 0, count) => {
  const angle2 = 2 * Math.PI / count;
  return new Array(count).fill(0).map((entry, index) => polarToCartesian(center2, radius, startAngle + index * angle2));
};
var generateCardioidPoints = (center2, radius, startAngle = 0, count) => {
  const angle2 = 2 * Math.PI / count, func = getShapeFunction("cardioid");
  return new Array(count).fill(0).map((entry, index) => {
    const theta = startAngle + index * angle2, r = radius * func(theta);
    return polarToCartesian(center2, r, theta);
  });
};
var drawRegularPolygon = (ctx, points) => {
  ctx.beginPath(), points.forEach((p, index) => {
    0 === index ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
  }), ctx.closePath(), ctx.fill();
};
var drawCardioid = (ctx, points) => {
  let prev;
  ctx.beginPath(), points.forEach((p, index) => {
    0 === index ? ctx.moveTo(p.x, p.y) : ctx.bezierCurveTo(p.x, p.y, prev.x, prev.y, p.x, p.y), prev = p;
  }), ctx.closePath(), ctx.fill();
};
var drawGeometricMask = (shape, width, height, ctx) => {
  const { fill, hollow } = shape, { center: center2, maxRadius } = getMaxRadiusAndCenter(shape.shape, [width, height]);
  ctx.fillStyle = null != fill ? fill : "black", hollow && (ctx.globalCompositeOperation = "xor");
  const cx = center2[0], cy = center2[1];
  if ("cardioid" === shape.shape) drawCardioid(ctx, generateCardioidPoints({
    x: cx,
    y: cy
  }, maxRadius, 0, 100));
  else if ("circle" === shape.shape) ctx.beginPath(), ctx.arc(cx, cy, maxRadius, 0, 2 * Math.PI, true), ctx.fill();
  else if ("diamond" === shape.shape) drawRegularPolygon(ctx, generatePoints({
    x: cx,
    y: cy
  }, maxRadius, -Math.PI / 2, 4));
  else if ("square" === shape.shape) drawRegularPolygon(ctx, generatePoints({
    x: cx,
    y: cy
  }, maxRadius, -Math.PI / 4, 4));
  else if ("pentagon" === shape.shape) drawRegularPolygon(ctx, generatePoints({
    x: cx,
    y: cy
  }, maxRadius, Math.PI / 2, 5));
  else if ("triangle" === shape.shape || "triangleUpright" === shape.shape) drawRegularPolygon(ctx, generatePoints({
    x: cx,
    y: cy
  }, maxRadius, -Math.PI / 2, 3));
  else if ("triangleForward" === shape.shape) drawRegularPolygon(ctx, generatePoints({
    x: cx,
    y: cy
  }, maxRadius, 0, 3));
  else if ("star" === shape.shape) {
    const outterPoints = generatePoints({
      x: cx,
      y: cy
    }, maxRadius, -Math.PI / 2, 5), innerPoints = generatePoints({
      x: cx,
      y: cy
    }, maxRadius / (2 * Math.cos(Math.PI / 5)), -Math.PI / 2 + Math.PI / 5, 5), points = [];
    for (let i = 0; i < 5; i++) points.push(outterPoints[i]), points.push(innerPoints[i]);
    drawRegularPolygon(ctx, points);
  } else ctx.fillRect(0, 0, width, height);
};

// node_modules/@visactor/vrender-components/es/core/base.js
var GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
var AbstractComponent = class extends Group {
  constructor(attributes, options) {
    super(attributes), this._skipRenderAttributes = GROUP_ATTRIBUTES, (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = true), this.setTheme({
      common: {
        strokeBoundsBuffer: 0
      }
    }), this.attribute = attributes, this.onSetStage(() => {
      this.render(), this.bindEvents();
    });
  }
  setAttribute(key, value, forceUpdateTag, context) {
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    if (params2) return this._setAttributes(params2, forceUpdateTag);
    isPlainObject_default(this.attribute[key]) && isPlainObject_default(value) && !isFunction_default(this.attribute[key]) && !isFunction_default(value) ? merge(this.attribute[key], value) : this.attribute[key] = value, this._skipRenderAttributes.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this._setAttributes(params2, forceUpdateTag);
  }
  _setAttributes(params2, forceUpdateTag) {
    const keys = Object.keys(params2);
    this._mergeAttributes(params2, keys), keys.every((key) => this._skipRenderAttributes.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  _mergeAttributes(params2, keys) {
    isNil_default(keys) && (keys = Object.keys(params2));
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      !isPlainObject_default(this.attribute[key]) || isFunction_default(this.attribute[key]) || isFunction_default(params2[key]) ? this.attribute[key] = params2[key] : merge(this.attribute[key], params2[key]);
    }
  }
  bindEvents() {
  }
  _getNodeId(id) {
    var _a;
    return `${null !== (_a = this.id) && void 0 !== _a ? _a : this._uid}-${this.name}-${id}`;
  }
  _dispatchEvent(eventName, details) {
    var _a;
    const changeEvent = new CustomEvent(eventName, details);
    changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
  }
};

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/config.js
var defaultRouthThemeSpec = {
  maxRandomnessOffset: 3,
  roughness: 1,
  bowing: 1,
  curveFitting: 0.95,
  curveTightness: void 0,
  curveStepCount: 9,
  fillStyle: "hachure",
  fillWeight: void 0,
  hachureAngle: 60,
  hachureGap: 6,
  simplification: 0,
  dashOffset: void 0,
  dashGap: void 0,
  zigzagOffset: void 0,
  seed: 1,
  fillLineDash: void 0,
  fillLineDashOffset: void 0,
  disableMultiStroke: false,
  disableMultiStrokeFill: false,
  preserveVertices: true,
  fixedDecimalPlaceDigits: void 0
};

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/base-render.js
var RoughBaseRender = class {
  drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb);
  }
};

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-arc.js
var __decorate42 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata29 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasArcRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  draw(arc, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const arcAttribute = arc.getGraphicTheme();
    let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const { dx = arcAttribute.dx, dy = arcAttribute.dy } = arc.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, true);
    const customPath = new CustomPath2D(), { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, lineWidth = arcAttribute.lineWidth, outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = arc.attribute;
    drawArcPath(arc, customPath, x, y, outerRadius, innerRadius), rc.path(customPath.toString(), {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasArcRender = __decorate42([injectable(), __param21(0, inject(DefaultCanvasArcRender)), __metadata29("design:paramtypes", [Object])], RoughCanvasArcRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-area.js
var __decorate43 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var RoughCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb) {
    if (fillCb) return super.drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawAreaSegments(customPath, cache, clipRange, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasAreaRender = __decorate43([injectable()], RoughCanvasAreaRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-circle.js
var __decorate44 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata30 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasCircleRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  draw(circle3, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), circleAttribute = circle3.getGraphicTheme();
    let { x = circleAttribute.x, y = circleAttribute.y } = circle3.attribute;
    circle3.transMatrix.onlyTranslate() ? context.onlyTranslate() || context.clearMatrix() : (x = 0, y = 0, context.transformFromMatrix(circle3.transMatrix, true));
    const { radius = circleAttribute.radius, fill = circleAttribute.fill, stroke: stroke2 = circleAttribute.stroke, lineWidth = circleAttribute.lineWidth } = circle3.attribute;
    rc.circle(x, y, radius, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      fillStyle: "zigzag",
      roughness: 0.5
    });
  }
};
RoughCanvasCircleRender = __decorate44([injectable(), __param22(0, inject(DefaultCanvasCircleRender)), __metadata30("design:paramtypes", [Object])], RoughCanvasCircleRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-line.js
var __decorate45 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var RoughCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb) {
    if (fillCb || strokeCb) return super.drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasLineRender = __decorate45([injectable()], RoughCanvasLineRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-path.js
var __decorate46 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata31 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasPathRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  draw(path, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {});
    context.highPerformanceSave();
    const pathAttribute = path.getGraphicTheme();
    context.transformFromMatrix(path.transMatrix, true);
    const { fill = pathAttribute.fill, stroke: stroke2 = pathAttribute.stroke, lineWidth = pathAttribute.lineWidth, path: p = pathAttribute.path, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = path.attribute;
    "string" == typeof p && rc.path(p, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasPathRender = __decorate46([injectable(), __param23(0, inject(DefaultCanvasPathRender)), __metadata31("design:paramtypes", [Object])], RoughCanvasPathRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-rect.js
var __decorate47 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata32 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasRectRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  draw(rect, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const rectAttribute = rect.getGraphicTheme();
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    if (rect.transMatrix.onlyTranslate()) {
      const { dx = rectAttribute.dx, dy = rectAttribute.dy } = rect.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, true);
    const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, fillColor = rectAttribute.fill, strokeColor = rectAttribute.stroke, x1, y1, lineWidth = rectAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = rect.attribute;
    let { width = rectAttribute.width, height = rectAttribute.height } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0, rc.rectangle(x, y, width, height, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasRectRender = __decorate47([injectable(), __param24(0, inject(DefaultCanvasRectRender)), __metadata32("design:paramtypes", [Object])], RoughCanvasRectRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-symbol.js
var __decorate48 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata33 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasSymbolRender = class extends BaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE, this.style = "rough";
  }
  draw(symbol, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(), data = this.transform(symbol, symbolAttribute, context), { x, y, z, lastModelMatrix } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { fill = symbolAttribute.fill, stroke: stroke2 = symbolAttribute.stroke, fillColor = symbolAttribute.fill, strokeColor = symbolAttribute.stroke, size = symbolAttribute.size, lineWidth = symbolAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = symbol.attribute;
    let svgPath = "";
    if (parsedPath.drawToSvgPath) svgPath = parsedPath.drawToSvgPath(size, x, y);
    else {
      const customPath = new CustomPath2D();
      parsedPath.draw(customPath, size, x, y) && customPath.closePath(), svgPath = customPath.toString();
    }
    rc.path(svgPath, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasSymbolRender = __decorate48([injectable(), __param25(0, inject(DefaultCanvasSymbolRender)), __metadata33("design:paramtypes", [Object])], RoughCanvasSymbolRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/module.js
var module_default2 = new ContainerModule((bind) => {
  bind(RoughCanvasCircleRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasCircleRender), bind(RoughCanvasRectRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasRectRender), bind(RoughCanvasPathRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasPathRender), bind(RoughCanvasSymbolRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasSymbolRender), bind(RoughCanvasLineRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasLineRender), bind(RoughCanvasAreaRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasAreaRender), bind(RoughCanvasArcRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasArcRender);
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/constants.js
var MathPickerContribution = Symbol.for("MathPickerContribution");
var MathArcPicker = Symbol.for("MathArcPicker");
var MathAreaPicker = Symbol.for("MathAreaPicker");
var MathCirclePicker = Symbol.for("MathCirclePicker");
var MathImagePicker = Symbol.for("MathImagePicker");
var MathLinePicker = Symbol.for("MathLinePicker");
var MathPathPicker = Symbol.for("MathPathPicker");
var MathRectPicker = Symbol.for("MathRectPicker");
var MathSymbolPicker = Symbol.for("MathSymbolPicker");
var MathTextPicker = Symbol.for("MathTextPicker");
var MathPolygonPicker = Symbol.for("MathPolygonPicker");
var MathGlyphPicker = Symbol.for("MathGlyphPicker");
var CanvasArcPicker = Symbol.for("CanvasArcPicker");
var CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
var CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
var CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
var CanvasImagePicker = Symbol.for("CanvasImagePicker");
var CanvasGifImagePicker = Symbol.for("CanvasGifImagePicker");
var CanvasLinePicker = Symbol.for("CanvasLinePicker");
var CanvasLottiePicker = Symbol.for("CanvasLottiePicker");
var CanvasPathPicker = Symbol.for("CanvasPathPicker");
var CanvasRectPicker = Symbol.for("CanvasRectPicker");
var CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
var CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
var CanvasTextPicker = Symbol.for("CanvasTextPicker");
var CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
var CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
var CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
var CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker");
var CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
var CanvasStarPicker = Symbol.for("CanvasStarPicker");
var CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

// node_modules/@visactor/vrender-kits/es/jsx/graphicType.js
var REACT_TO_CANOPUS_EVENTS = {
  onPointerDown: "pointerdown",
  onPointerUp: "pointerup",
  onPointerUpOutside: "pointerupoutside",
  onPointerTap: "pointertap",
  onPointerOver: "pointerover",
  onPointerMove: "pointermove",
  onPointerEnter: "pointerenter",
  onPointerLeave: "pointerleave",
  onPointerOut: "pointerout",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onMouseUpOutside: "mouseupoutside",
  onMouseMove: "mousemove",
  onMouseOver: "mouseover",
  onMouseOut: "mouseout",
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave",
  onPinch: "pinch",
  onPinchStart: "pinchstart",
  onPinchEnd: "pinchend",
  onPan: "pan",
  onPanStart: "panstart",
  onPanEnd: "panend",
  onDrag: "drag",
  onDragStart: "dragstart",
  onDragEnter: "dragenter",
  onDragLeave: "dragleave",
  onDragOver: "dragover",
  onDragEnd: "dragend",
  onRightDown: "rightdown",
  onRightUp: "rightup",
  onRightUpOutside: "rightupoutside",
  onTouchStart: "touchstart",
  onTouchEnd: "touchend",
  onTouchEndOutside: "touchendoutside",
  onTouchMove: "touchmove",
  onTouchCancel: "touchcancel",
  onPress: "press",
  onPressUp: "pressup",
  onPressEnd: "pressend",
  onSwipe: "swipe",
  onDrop: "drop",
  onWeel: "wheel",
  onClick: "click",
  onDblClick: "dblclick"
};
var REACT_TO_CANOPUS_EVENTS_LIST = Object.keys(REACT_TO_CANOPUS_EVENTS);
function VRichText(params2) {
  return graphicCreator.richtext(params2 ? params2.attribute : {});
}
VRichText.Text = function(params2) {
  return Object.assign({
    type: "rich/text"
  }, params2);
}, VRichText.Image = function(params2) {
  return Object.assign({
    type: "rich/image"
  }, params2);
};

// node_modules/@visactor/vrender-kits/es/event/extension/drag.js
var DragNDrop = class {
  constructor(rootNode) {
    this.onPointerDown = (event) => {
      const target = event.target, rootNode2 = this.rootNode, isRoot = target === rootNode2;
      if (target && !isRoot) {
        let handlePointerMove = function(moveEvent) {
          if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), dragstartTriggered = true), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), !isRoot) {
            target.attribute.pickable = false;
            const elemBelow = (null == rootNode2 ? void 0 : rootNode2.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
            target.attribute.pickable = true, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
          }
        };
        let currentDroppable, dragstartTriggered = false;
        null == rootNode2 || rootNode2.addEventListener("pointermove", handlePointerMove);
        const stopDragging = function() {
          dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), dragstartTriggered = false), null == rootNode2 || rootNode2.removeEventListener("pointermove", handlePointerMove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: true
        }), target.addEventListener("pointerupoutside", stopDragging, {
          once: true
        });
      }
    }, this.rootNode = rootNode, this.initEvents();
  }
  initEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
  }
  removeEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
  }
  release() {
    this.removeEvents(), this.rootNode = null;
  }
};

// node_modules/@visactor/vrender-kits/es/event/extension/gesture.js
var calcDirection = (start, end) => {
  const xDistance = end.x - start.x, yDistance = end.y - start.y;
  return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
};
var calcDistance = (point1, point22) => {
  const xDistance = Math.abs(point22.x - point1.x), yDistance = Math.abs(point22.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter2 = (points) => {
  const pointersLength = points.length;
  if (1 === pointersLength) return {
    x: Math.round(points[0].x),
    y: Math.round(points[0].y)
  };
  let x = 0, y = 0, i = 0;
  for (; i < pointersLength; ) x += points[i].x, y += points[i].y, i++;
  return {
    x: Math.round(x / pointersLength),
    y: Math.round(y / pointersLength)
  };
};
var Gesture = class extends import_eventemitter3.default {
  constructor(element, config2 = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = (ev) => {
      this.startTime = clock.now();
      const { cachedEvents, startPoints } = this;
      ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
      for (let i = 0; i < cachedEvents.length; i++) {
        const { x, y } = cachedEvents[i], point6 = {
          x,
          y
        };
        startPoints[i] = point6;
      }
      if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter2([startPoints[0], startPoints[1]]);
      else {
        const event = cachedEvents[0];
        this.pressTimeout = setTimeout(() => {
          event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", this.direction = "none", this.pressTimeout = null;
        }, this.config.press.time);
      }
    }, this.onMove = (ev) => {
      this.clearPressTimeout();
      const { startPoints, cachedEvents } = this;
      if (!startPoints.length) return;
      const moveEvent = ev.clone(), { x, y, pointerId } = moveEvent;
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
        cachedEvents[i] = moveEvent;
        break;
      }
      const point6 = {
        x,
        y
      }, points = cachedEvents.map((cachedEvent) => ({
        x: cachedEvent.x,
        y: cachedEvent.y
      })), now = clock.now();
      if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point6, 1 === startPoints.length) {
        const startPoint = startPoints[0], deltaX = x - startPoint.x, deltaY = y - startPoint.y, direction = this.direction || calcDirection(startPoint, point6);
        this.direction = direction;
        const eventType = this.getEventType(point6);
        return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
      }
      const { startDistance } = this, currentDistance = calcDistance(points[0], points[1]);
      moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
    }, this.onEnd = (ev) => {
      const endEvent = ev.clone(), { cachedEvents, startPoints } = this, points = cachedEvents.map((ev2) => ({
        x: ev2.x,
        y: ev2.y
      }));
      if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
        const now = clock.now(), lastMoveTime = this.lastMoveTime;
        if (now - lastMoveTime < 100) {
          const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
          if (intervalTime > 0) {
            const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance2 = calcDistance(prevMovePoint, lastMovePoint), velocity = distance2 / intervalTime;
            if (velocity > this.config.swipe.velocity && distance2 > this.config.swipe.threshold) return endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent), this.cachedEvents = [], this.startPoints = [], void this.reset();
          }
        }
        now - this.startTime < this.config.press.time && (now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0));
      }
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
        cachedEvents.splice(i, 1), startPoints.splice(i, 1);
        break;
      }
      this.reset(), cachedEvents.length > 0 && this.onStart();
    }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
      press: {
        time: null !== (_b = null === (_a = null == config2 ? void 0 : config2.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
        threshold: null !== (_d = null === (_c = null == config2 ? void 0 : config2.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
      },
      swipe: {
        threshold: null !== (_f = null === (_e = null == config2 ? void 0 : config2.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
        velocity: null !== (_h = null === (_g = null == config2 ? void 0 : config2.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : 0.3
      },
      tap: {
        interval: null !== (_k = null === (_j = null == config2 ? void 0 : config2.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
      }
    }, this.initEvents();
  }
  initEvents() {
    const { element } = this;
    element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerleave", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
  }
  removeEvents() {
    const { element } = this;
    element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerleave", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
  }
  release() {
    this.removeEvents(), this.element = null;
  }
  getEventType(point6) {
    const { eventType, startTime, startPoints } = this;
    if ("press" === eventType) return eventType;
    let type;
    return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point6) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
  }
  enable(eventType) {
    this.processEvent[eventType] = true;
  }
  isProcess(eventType) {
    return this.processEvent[eventType];
  }
  pushEvent(type, ev) {
    const { emitThrottles } = this, newEvent = {
      type,
      ev
    };
    for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
    emitThrottles.push(newEvent);
  }
  clearPressTimeout() {
    this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
  }
  reset() {
    this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
  }
  triggerEvent(type, ev) {
    this.pushEvent(type, ev);
    const { throttleTimer, emitThrottles } = this;
    throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
      application.global.getCancelAnimationFrame()(this.throttleTimer), this.throttleTimer = null;
      for (let i = 0, len = emitThrottles.length; i < len; i++) {
        const { type: type2, ev: ev2 } = emitThrottles[i];
        this.emitEvent(type2, ev2);
      }
      this.emitThrottles.length = 0;
    }));
  }
  triggerStartEvent(type, ev) {
    this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
  }
  triggerEndEvent(ev) {
    const processEvent = this.processEvent;
    Object.keys(processEvent).forEach((type) => {
      this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
    });
  }
  emitEvent(type, e) {
    if (!this.element) return;
    const listeners = this.element._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);
    else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
    this.emit(type, e);
  }
};

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/context.js
var __decorate49 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata34 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var outP = [0, 0, 0];
var addArcToBezierPath2 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
  if (clockwise) for (; endAngle > startAngle; ) endAngle -= pi2;
  else for (; endAngle < startAngle; ) endAngle += pi2;
  const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
  let sa = startAngle, ea = sa;
  for (; ea !== endAngle; ) {
    ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
    const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c22 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c22, x4, y4]), sa = ea;
  }
};
var BrowserContext2d = class {
  set fillStyle(d) {
    this.nativeContext.fillStyle = d;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(d) {
    this.nativeContext.font = d;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(d) {
    this.nativeContext.globalAlpha = d * this.baseGlobalAlpha;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(d) {
    this.nativeContext.lineCap = d;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(d) {
    this.nativeContext.lineDashOffset = d;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(d) {
    this.nativeContext.lineJoin = d;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(d) {
    this.nativeContext.lineWidth = d;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(d) {
    this.nativeContext.miterLimit = d;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(d) {
    this.nativeContext.shadowBlur = d;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(d) {
    this.nativeContext.shadowColor = d;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(d) {
    this.nativeContext.shadowOffsetX = d;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(d) {
    this.nativeContext.shadowOffsetY = d;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(d) {
    this.nativeContext.strokeStyle = d;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(d) {
    this.nativeContext.textAlign = d;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(d) {
    this.nativeContext.textBaseline = d;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(use) {
    use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
  }
  constructor(canvas, dpr) {
    this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1
    }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
      opacity: 1
    }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
      opacity: 1
    }), this._clearShadowStyle = false, this._clearFilterStyle = false, this._clearGlobalCompositeOperationStyle = false;
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.baseGlobalAlpha = 1;
  }
  reset() {
    this.stack.length && Logger.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m4) {
    return matrixAllocate.allocateByObj(m4);
  }
  clear() {
    this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
  }
  restore() {
    this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(true));
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix), this.nativeContext.save();
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a3, b, c3, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a3, dpr * b, dpr * c3, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a3, b, c3, d, e, f, setTransform = true) {
    this.matrix.multiply(a3, b, c3, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(path, fillRule) {
    path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
    if (z = z || 0, this.camera) {
      const arr = [];
      addArcToBezierPath2(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
      for (let i = 0; i < arr.length; ++i) {
        const bez = arr[i];
        this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
      }
    } else this.nativeContext.arc(x, y, Math.max(0, radius), startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
    if (z = z || 0, this.camera) {
      let cp1z = z, cp2z = z;
      this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
    }
    this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  lineTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.lineTo(x, y);
  }
  moveTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y, z) {
    if (z = z || 0, this.camera) {
      let cpz = z;
      this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
    }
    this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h, z) {
    z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
  }
  createImageData() {
    const a3 = arguments;
    return 2 === a3.length ? this.nativeContext.createImageData(a3[0], a3[1]) : 1 === a3.length ? this.nativeContext.createImageData(a3[0]) : null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    return isFinite(x0 + y0 + x1 + y1) || (x0 = 0, y0 = 0, x1 = 0, y1 = 0), this.nativeContext.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    if (this.nativeContext.createConicGradient && Math.abs(endAngle - startAngle - 2 * Math.PI) < 1e-3) return this.nativeContext.createConicGradient(startAngle, x, y);
    let pattern, edit = false;
    const ctx = this;
    return {
      stops: [],
      addColorStop(offset, color) {
        this.stops.push([offset, color]), edit = true;
      },
      GetPattern(minW, minH, deltaAngle) {
        return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = false), pattern;
      }
    };
  }
  fill(path, fillRule) {
    this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
  }
  fillRect(x, y, width, height) {
    this.nativeContext.fillRect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
    this.nativeContext.clearRect(x, y, w, h);
  }
  project(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    return {
      x,
      y
    };
  }
  view(x, y, z) {
    return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
  }
  fillText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.fillText(text2, x, y);
  }
  getImageData(sx, sy, sw, sh) {
    return this.nativeContext.getImageData(sx, sy, sw, sh);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(x, y) {
    return this.nativeContext.isPointInPath(x, y);
  }
  isPointInStroke(x, y) {
    return this.nativeContext.isPointInStroke(x, y);
  }
  measureText(text2, method = application.global.measureTextMethod) {
    var _a, _b;
    if (!method || "native" === method) return this.nativeContext.measureText(text2);
    this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
    const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily, fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
    return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text2, method);
  }
  putImageData(imagedata, dx, dy) {
    this.nativeContext.putImageData(imagedata, dx, dy);
  }
  setLineDash(segments2) {
    const a3 = arguments, _context = this.nativeContext;
    this.nativeContext.setLineDash ? a3[0] && _context.setLineDash(a3[0]) : "mozDash" in _context ? _context.mozDash = a3[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a3[0]);
  }
  stroke(path) {
    this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
  }
  strokeRect(x, y, width, height) {
    this.nativeContext.strokeRect(x, y, width, height);
  }
  strokeText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.strokeText(text2, x, y);
  }
  drawImage() {
    const _context = this.nativeContext, a3 = arguments;
    3 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2]) : 5 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4]) : 9 === a3.length && _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8]);
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setCommonStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    _context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha, fillOpacity > 1e-12 && opacity > 1e-12 && (_context.fillStyle = createColor(this, fill, params2, offsetX, offsetY));
  }
  setShadowBlendStyle(params2, attribute, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setShadowBlendStyle(params2, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setShadowBlendStyle(params2, attribute, dp);
    }
    return this._setShadowBlendStyle(params2, attribute, defaultParams);
  }
  _setShadowBlendStyle(params2, attribute, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { opacity = defaultParams.opacity, shadowBlur = defaultParams.shadowBlur, shadowColor = defaultParams.shadowColor, shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY = defaultParams.shadowOffsetY, blur = defaultParams.blur, filter: filter2 = defaultParams.filter, globalCompositeOperation = defaultParams.globalCompositeOperation } = attribute;
    opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = true) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = true) : filter2 ? (_context.filter = filter2, this._clearFilterStyle = true) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = false), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = true) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = false));
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setStrokeStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (_context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineDashOffset = defaultParams.lineDashOffset, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale } = attribute;
      _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams, this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
  }
  setClearMatrix(a3, b, c3, d, e, f) {
    this._clearMatrix.setValue(a3, b, c3, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m4) => matrixAllocate.free(m4)), this.stack.length = 0;
  }
};
BrowserContext2d.env = "browser", BrowserContext2d = __decorate49([injectable(), __metadata34("design:paramtypes", [Object, Number])], BrowserContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/canvas.js
var __decorate50 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata35 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BrowserCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init(params2) {
    const { container: container2 } = params2;
    if ("string" == typeof container2) {
      const _c = application.global.getElementById(container2);
      _c && (this._container = _c);
    } else this._container = container2;
    this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
  }
  initStyle() {
    if (!this.controled) return;
    const { nativeCanvas } = this;
    nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const canvas = this._nativeCanvas;
    canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
  }
  resetStyle(params2) {
    if (!this.controled) return;
    const { width = this._displayWidth, height = this._displayHeight, dpr = this._dpr, x = this._x, y = this._y } = params2, { nativeCanvas } = this;
    nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params2.id && (nativeCanvas.id = params2.id), this.visiable || this.hide();
  }
  setCanvasStyle(canvas, x, y, w, h) {
    this.controled && (canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
  }
  toDataURL(mimeType, quality) {
    return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
  }
  resize(width, height) {
    if (!this.controled) return;
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
    this._context.dpr = this._dpr;
  }
};
BrowserCanvas.env = "browser", BrowserCanvas = __decorate50([injectable(), __metadata35("design:paramtypes", [Object])], BrowserCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/create-canvas-module.js
function createModule(CanvasConstructor, ContextConstructor) {
  return new ContainerModule((bind) => {
    bind(CanvasFactory).toDynamicValue(() => (params2) => new CanvasConstructor(params2)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params2, dpr) => new ContextConstructor(params2, dpr)).whenTargetNamed(ContextConstructor.env);
  });
}

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/modules.js
var browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

// node_modules/@visactor/vrender-kits/es/picker/canvas-picker-service.js
var __decorate51 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata36 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(contributions, drawContribution, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const ret = drawContribution.beforePickItem(graphic, this, point6, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point6, params2), g = pd ? graphic : null, data = {
      graphic: g,
      params: pd
    };
    if (g) return data;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterPickItem) {
        const ret = drawContribution.afterPickItem(graphic, this, point6, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    return data;
  }
};
DefaultCanvasPickerService = __decorate51([injectable(), __param26(0, inject(ContributionProvider)), __param26(0, named(CanvasPickerContribution)), __param26(1, inject(DrawContribution)), __param26(2, inject(ContributionProvider)), __param26(2, named(PickItemInterceptor)), __param26(3, inject(ContributionProvider)), __param26(3, named(PickServiceInterceptor)), __metadata36("design:paramtypes", [Object, Object, Object, Object])], DefaultCanvasPickerService);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/group-picker.js
var __decorate52 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGroupPicker = class {
  constructor() {
    this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
  }
  contains(group, point6, params2) {
    return false;
  }
};
DefaultCanvasGroupPicker = __decorate52([injectable()], DefaultCanvasGroupPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/module.js
var m = new ContainerModule((bind, unbind, isBound, rebind) => {
  m.__vloaded || (m.__vloaded = true, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
});
m.__vloaded = false;
var module_default3 = m;

// node_modules/@visactor/vrender-kits/es/picker/canvas-module.js
var canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
});
function loadCanvasPicker(c3) {
  c3.load(module_default3), c3.load(canvasPickerModule);
}

// node_modules/@visactor/vrender-kits/es/window/contributions/browser-contribution.js
var BrowserWindowHandlerContribution_1;
var __decorate53 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata37 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
  get container() {
    return this.canvas.nativeCanvas.parentElement;
  }
  static GenerateCanvasId() {
    return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
  }
  constructor() {
    super(), this.type = "browser", this._canvasIsIntersecting = true, this.global = application.global, this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return this.canvas.nativeCanvas.getBoundingClientRect();
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2), this.postInit();
  }
  postInit() {
    if (this.global.optimizeVisible) try {
      this.observerCanvas();
    } catch (err) {
      console.error("发生错误，该环境不存在IntersectionObserver");
    }
  }
  isElementVisible(el) {
    const rect = el.getBoundingClientRect(), vWidth = window.innerWidth || document.documentElement.clientWidth, vHeight = window.innerHeight || document.documentElement.clientHeight;
    return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
  }
  observerCanvas() {
    this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
    const observer = new IntersectionObserver((entries, observer2) => {
      entries.forEach((entry) => {
        this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
      });
    });
    observer && observer.observe(this.canvas.nativeCanvas);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    });
    let container2;
    if (container2 = "string" == typeof params2.container ? this.global.getElementById(params2.container) : params2.container ? params2.container : this.global.getRootElement(), !container2) throw new Error("发生错误，containerId可能传入有误");
    params2.offscreen ? container2 = null : container2.appendChild(nativeCanvas);
    const options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      container: container2,
      id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
      canvasControled: true
    };
    this.canvas = new BrowserCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    if (!canvas) throw new Error("发生错误，传入的canvas不正确");
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    if (null == dpr) {
      dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
    }
    this.canvas = new BrowserCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this.canvas.nativeCanvas.dispatchEvent(event);
  }
  getStyle() {
    var _a;
    return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
  }
  setStyle(style) {
    this.canvas.nativeCanvas.style = style;
  }
  getBoundingClientRect() {
    const c3 = this.canvas.nativeCanvas, wh = this.getWH();
    return c3.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
  isVisible(bbox) {
    return this._canvasIsIntersecting;
  }
  onVisibleChange(cb) {
    this._onVisibleChangeCb = cb;
  }
  getTopLeft(baseWindow) {
    return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
  }
};
BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate53([injectable(), __metadata37("design:paramtypes", [])], BrowserWindowHandlerContribution);
var browserWindowModule = new ContainerModule((bind) => {
  bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/browser-contribution.js
var __decorate54 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata38 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DynamicB = class {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(dom) {
    this.dom = dom;
  }
};
function createImageElement(src, isSvg2 = false) {
  const img = document.createElement("img");
  if (application.global.isImageAnonymous && (img.crossOrigin = "anonymous"), isSvg2) {
    const data = new Blob([src], {
      type: "image/svg+xml"
    });
    src = window.URL.createObjectURL(data);
  }
  if (img.src = src, img.complete) return Promise.resolve(img);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "browser", this.supportEvent = true;
    try {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsTouchEvents = false, this.supportsPointerEvents = false, this.supportsPointerEvents = false;
    }
    this.applyStyles = true;
  }
  mapToCanvasPoint(nativeEvent, domElement) {
    var _a, _b;
    let clientX = 0, clientY = 0, offsetX = 0, offsetY = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
      clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
    } else clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
    if (domElement) {
      const x = clientX, y = clientY, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
      let scaleX, scaleY;
      return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
        x: (x - rect.left) / (isValidNumber_default(scaleX) ? scaleX : 1),
        y: (y - rect.top) / (isValidNumber_default(scaleY) ? scaleY : 1)
      };
    }
    return {
      x: offsetX,
      y: offsetY
    };
  }
  getNativeAABBBounds(_dom) {
    let dom = _dom;
    if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
      const b = dom.getBoundingClientRect();
      return new DynamicB(b);
    }
    return new AABBBounds();
  }
  removeDom(dom) {
    return dom.parentElement.removeChild(dom), true;
  }
  updateDom(dom, params2) {
    const { width, height, style } = params2;
    return style && (isString_default(style) ? dom.setAttribute("style", style) : Object.keys(style).forEach((k2) => {
      dom.style[k2] = style[k2];
    })), null != width && (dom.style.width = `${width}px`), null != height && (dom.style.height = `${height}px`), true;
  }
  createDom(params2) {
    const { tagName = "div", parent } = params2, element = document.createElement(tagName);
    if (this.updateDom(element, params2), parent) {
      const pd = isString_default(parent) ? this.getElementById(parent) : parent;
      pd && pd.appendChild && pd.appendChild(element);
    }
    return element;
  }
  loadImage(url) {
    return createImageElement(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return createImageElement(url, true).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  createCanvas(params2) {
    var _a, _b;
    const canvas = document.createElement("canvas");
    params2.id && (canvas.id = null !== (_a = params2.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
    const dpr = null !== (_b = params2.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
    return params2.width && params2.height && (canvas.style.width = `${params2.width}px`, canvas.style.height = `${params2.height}px`, canvas.width = params2.width * dpr, canvas.height = params2.height * dpr), canvas;
  }
  createOffscreenCanvas(params2) {
    var _a;
    const dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
    return new OffscreenCanvas(params2.width * dpr, params2.height * dpr);
  }
  releaseCanvas(canvas) {
    let c3;
    c3 = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c3 && c3.parentElement && c3.parentElement.removeChild(c3);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return document.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return document.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return document.dispatchEvent(event);
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release(...params2) {
  }
  getElementTop(element, baseWindow) {
    let actualTop = element.offsetTop, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, current = current.offsetParent;
    return actualTop;
  }
  getElementLeft(element, baseWindow) {
    let actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualLeft += current.offsetLeft, current = current.offsetParent;
    return actualLeft;
  }
  getElementTopLeft(element, baseWindow) {
    let actualTop = element.offsetTop, actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
    return {
      top: actualTop,
      left: actualLeft
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter7(this, void 0, void 0, function* () {
      return new FontFace(font, isString_default(source) ? `url(${source})` : source, descriptors).load().then(function(loadedFont) {
        return document.fonts.add(loadedFont), {
          loadState: "success"
        };
      }).catch(function(error3) {
        return console.error("Failed to load font:", error3), {
          loadState: "fail"
        };
      });
    });
  }
  isMacOS() {
    if (void 0 === this._isMacOS) try {
      this._isMacOS = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    } catch (err) {
      this._isMacOS = false;
    }
    return this._isMacOS;
  }
  copyToClipBoard(text2) {
    return navigator.clipboard.writeText(text2).then(() => {
    }).catch((err) => {
    });
  }
};
BrowserEnvContribution = __decorate54([injectable(), __metadata38("design:paramtypes", [])], BrowserEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/browser.js
var browserEnvModule = new ContainerModule((bind) => {
  browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = true, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
});
browserEnvModule.isBrowserBound = false;
function loadBrowserEnv(container2, loadPicker = true) {
  loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = true, container2.load(browserEnvModule), container2.load(browserCanvasModule), container2.load(browserWindowModule), loadPicker && loadCanvasPicker(container2));
}
loadBrowserEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/context.js
var __decorate55 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var FeishuContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  getImageData(sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      var _a;
      try {
        tt.canvasGetImageData({
          canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,
          x: sx,
          y: sy,
          width: sw,
          height: sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
  createPattern(image, repetition) {
    return null;
  }
};
FeishuContext2d.env = "feishu", FeishuContext2d = __decorate55([injectable()], FeishuContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/canvas.js
var __decorate56 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata39 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var FeishuCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new FeishuContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
FeishuCanvas.env = "feishu", FeishuCanvas = __decorate56([injectable(), __metadata39("design:paramtypes", [Object])], FeishuCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/modules.js
var feishuCanvasModule = createModule(FeishuCanvas, FeishuContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/feishu-contribution.js
var __decorate57 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata40 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var FeishuWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "feishu", this.eventManager = new MiniAppEventManager();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new FeishuCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new FeishuCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate57([injectable(), __param27(0, inject(VGlobal)), __metadata40("design:paramtypes", [Object])], FeishuWindowHandlerContribution);
var feishuWindowModule = new ContainerModule((bind) => {
  bind(FeishuWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(FeishuWindowHandlerContribution)).whenTargetNamed(FeishuWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/picker/math-picker-service.js
var __decorate58 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata41 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPickerService = class extends DefaultPickService {
  constructor(contributions, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("math-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickContext = new EmptyContext2d(null, 1);
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point6, params2), g = pd ? graphic : null;
    return g ? {
      graphic: g,
      params: pd
    } : null;
  }
};
DefaultMathPickerService = __decorate58([injectable(), __param28(0, inject(ContributionProvider)), __param28(0, named(MathPickerContribution)), __param28(1, inject(ContributionProvider)), __param28(1, named(PickItemInterceptor)), __param28(2, inject(ContributionProvider)), __param28(2, named(PickServiceInterceptor)), __metadata41("design:paramtypes", [Object, Object, Object])], DefaultMathPickerService);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/module.js
var m2 = new ContainerModule((bind) => {
  m2.__vloaded || (m2.__vloaded = true, bindContributionProvider(bind, MathPickerContribution));
});
m2.__vloaded = false;
var module_default4 = m2;

// node_modules/@visactor/vrender-kits/es/picker/contributions/common/base.js
var PickerBase = class {
  contains(graphic, point6, params2) {
    if (!graphic.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === graphic.attribute.pickMode) return true;
    if (!this.canvasRenderer) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    let { x = attribute.x, y = attribute.y } = graphic.attribute;
    if (graphic.transMatrix.onlyTranslate()) {
      const point7 = graphic.getOffsetXY(attribute);
      x += point7.x, y += point7.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, true);
    let picked = false, _final = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point6.x, point6.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
      if (picked || _final) return true;
      const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), _final = final || _final, picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-picker.js
var __decorate59 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata42 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultMathArcPicker = __decorate59([injectable(), __param29(0, inject(ArcRender)), __metadata42("design:paramtypes", [Object])], DefaultMathArcPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-module.js
var loadArcPick = false;
var arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = true, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-picker.js
var __decorate60 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata43 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultMathAreaPicker = __decorate60([injectable(), __param30(0, inject(AreaRender)), __metadata43("design:paramtypes", [Object])], DefaultMathAreaPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-module.js
var loadAreaPick = false;
var areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = true, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-picker.js
var __decorate61 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata44 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultMathCirclePicker = __decorate61([injectable(), __param31(0, inject(CircleRender)), __metadata44("design:paramtypes", [Object])], DefaultMathCirclePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-module.js
var loadCirclePick = false;
var circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = true, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/common/glyph-picker-base.js
var GlyphPickerBase = class {
  constructor() {
    this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point6, params2) {
    if (!glyph.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === glyph.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pickerService = null == params2 ? void 0 : params2.pickerService;
    if (pickerService) {
      let picked = false;
      return glyph.getSubGraphic().forEach((g) => {
        if (picked) return;
        const data = pickerService.pickItem(g, point6, null, params2);
        picked = !(!data || !data.graphic);
      }), picked;
    }
    return false;
  }
};

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-picker.js
var __decorate62 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata45 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathGlyphPicker = __decorate62([injectable(), __param32(0, inject(GlyphRender)), __metadata45("design:paramtypes", [Object])], DefaultMathGlyphPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-module.js
var loadGlyphPick = false;
var glyphMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick || (loadGlyphPick = true, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-picker.js
var __decorate63 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point6);
  }
};
DefaultMathImagePicker = __decorate63([injectable()], DefaultMathImagePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-module.js
var loadImagePick = false;
var imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-picker.js
var __decorate64 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata46 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathLinePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultMathLinePicker = __decorate64([injectable(), __param33(0, inject(LineRender)), __metadata46("design:paramtypes", [Object])], DefaultMathLinePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-module.js
var loadLinePick = false;
var lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = true, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-picker.js
var __decorate65 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata47 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultMathPolygonPicker = __decorate65([injectable(), __param34(0, inject(PolygonRender)), __metadata47("design:paramtypes", [Object])], DefaultMathPolygonPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-module.js
var loadPolygonPick = false;
var polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = true, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-picker.js
var __decorate66 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata48 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPathPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultMathPathPicker = __decorate66([injectable(), __param35(0, inject(PathRender)), __metadata48("design:paramtypes", [Object])], DefaultMathPathPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-module.js
var loadPathPick = false;
var pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = true, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/common/rect-picker-base.js
var _bounds = new AABBBounds();
var RectPickerBase = class {
  constructor() {
    this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point6, params2) {
    if (!rect.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === rect.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const rectAttribute = rect.getGraphicTheme(), { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point7 = rect.getOffsetXY(rectAttribute);
      x += point7.x, y += point7.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || rect.shadowRoot || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num)) picked = false, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, rectAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = rectAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    });
    else {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill) picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point6);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-picker.js
var __decorate67 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata49 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathRectPicker = __decorate67([injectable(), __param36(0, inject(RectRender)), __metadata49("design:paramtypes", [Object])], DefaultMathRectPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-module.js
var loadRectPick = false;
var rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = true, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/richtext-module.js
var loadRichTextPick = false;
var richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-picker.js
var __decorate68 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata50 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathSymbolPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
};
DefaultMathSymbolPicker = __decorate68([injectable(), __param37(0, inject(SymbolRender)), __metadata50("design:paramtypes", [Object])], DefaultMathSymbolPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-module.js
var loadSymbolPick = false;
var symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = true, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-picker.js
var __decorate69 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point6, params2) {
    return !!text2.AABBBounds.containsPoint(point6);
  }
};
DefaultMathTextPicker = __decorate69([injectable()], DefaultMathTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-module.js
var loadTextPick = false;
var textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = true, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/math-module.js
var mathPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
});
function loadMathPicker(c3) {
  c3.load(module_default4), c3.load(mathPickerModule), c3.load(arcMathPickModule), c3.load(areaMathPickModule), c3.load(circleMathPickModule), c3.load(glyphMathPickModule), c3.load(imageMathPickModule), c3.load(lineMathPickModule), c3.load(polygonMathPickModule), c3.load(pathMathPickModule), c3.load(rectMathPickModule), c3.load(richTextMathPickModule), c3.load(symbolMathPickModule), c3.load(textMathPickModule);
}

// node_modules/@visactor/vrender-kits/es/env/contributions/canvas-wrap.js
var CanvasWrapDisableWH = class {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {
  }
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {
  }
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {
  }
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {
  }
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
};
var CanvasWrapEnableWH = class {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {
    this._w = w / this.dpr, this.nativeCanvas.width = w;
  }
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {
    this._h = h / this.dpr, this.nativeCanvas.height = h;
  }
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {
    this._w = w, this.nativeCanvas.width = w * this.dpr;
  }
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {
    this._h = h, this.nativeCanvas.height = h * this.dpr;
  }
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
};

// node_modules/@visactor/vrender-kits/es/env/contributions/feishu-contribution.js
var __decorate70 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata51 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : tt.getSystemInfoSync().pixelRatio;
  canvasIdLists.forEach((id, i) => {
    const ctx = tt.createCanvasContext(id), canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
  });
}
var FeishuEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "feishu", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.pixelRatio));
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
FeishuEnvContribution = __decorate70([injectable(), __metadata51("design:paramtypes", [])], FeishuEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/feishu.js
var feishuEnvModule = new ContainerModule((bind) => {
  feishuEnvModule.isFeishuBound || (feishuEnvModule.isFeishuBound = true, bind(FeishuEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(FeishuEnvContribution));
});
feishuEnvModule.isFeishuBound = false;
function loadFeishuEnv(container2, loadPicker = true) {
  loadFeishuEnv.__loaded || (loadFeishuEnv.__loaded = true, container2.load(feishuEnvModule), container2.load(feishuCanvasModule), container2.load(feishuWindowModule), loadPicker && loadMathPicker(container2));
}
loadFeishuEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/context.js
var __decorate71 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var LynxContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments2) {
    const a3 = arguments, _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a3[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale, lineDashOffset = defaultParams.lineDashOffset } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || !lineDash || (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text2, method = application.global.measureTextMethod) {
    this.setTransform(1, 0, 0, 1, 0, 0, true, application.global.devicePixelRatio);
    return {
      width: super.measureText(text2, method).width,
      fontBoundingBoxDescent: void 0,
      fontBoundingBoxAscent: void 0,
      actualBoundingBoxAscent: void 0,
      actualBoundingBoxDescent: void 0
    };
  }
  createPattern(image, repetition) {
    return null;
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
};
LynxContext2d.env = "lynx", LynxContext2d = __decorate71([injectable()], LynxContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/canvas.js
var __decorate72 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata52 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var LynxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new LynxContext2d(this, this._dpr);
  }
  resize(width, height) {
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight, this._nativeCanvas.nativeCanvas && (this._nativeCanvas.nativeCanvas.width = this._pixelWidth, this._nativeCanvas.nativeCanvas.height = this._pixelHeight);
    this._context.dpr = this._dpr;
  }
  release(...params2) {
  }
};
LynxCanvas.env = "lynx", LynxCanvas = __decorate72([injectable(), __metadata52("design:paramtypes", [Object])], LynxCanvas);

// node_modules/@visactor/vrender-kits/es/window/contributions/lynx-contribution.js
var __decorate73 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata53 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager2 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var LynxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "lynx", this.eventManager = new MiniAppEventManager2();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new LynxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new LynxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate73([injectable(), __param38(0, inject(VGlobal)), __metadata53("design:paramtypes", [Object])], LynxWindowHandlerContribution);
var lynxWindowModule = new ContainerModule((bind) => {
  bind(LynxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(LynxWindowHandlerContribution)).whenTargetNamed(LynxWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/modules.js
var lynxCanvasModule = createModule(LynxCanvas, LynxContext2d);

// node_modules/@visactor/vrender-kits/es/env/contributions/lynx-contribution.js
var __decorate74 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata54 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var ng = false;
try {
  ng = !!lynx.createCanvasNG;
} catch (err) {
}
function makeUpCanvas2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, offscreen, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : SystemInfo.pixelRatio;
  if (canvasIdLists.forEach((id, i) => {
    let _canvas;
    offscreen ? _canvas = lynx.createOffscreenCanvas() : (_canvas = ng ? lynx.createCanvasNG(id) : lynx.createCanvas(id), ng && _canvas.attachToCanvasView(id)), _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"), canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), i > freeCanvasIdx && freeCanvasList.push(canvas);
  }), !freeCanvasList.length && lynx.createOffscreenCanvas) {
    const _canvas = lynx.createOffscreenCanvas();
    _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"), id = Math.random().toString(), canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), freeCanvasList.push(canvas);
  }
}
function createImageElement2(src, isSvg2 = false) {
  if (isSvg2) return Promise.reject();
  const img = lynx.createImage(src);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var LynxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "lynx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas2(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, !!params2.offscreen, params2.pixelRatio));
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
    return createImageElement2(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return SystemInfo.pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
LynxEnvContribution = __decorate74([injectable(), __metadata54("design:paramtypes", [])], LynxEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/lynx.js
var lynxEnvModule = new ContainerModule((bind) => {
  lynxEnvModule.isLynxBound || (lynxEnvModule.isLynxBound = true, bind(LynxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(LynxEnvContribution));
});
lynxEnvModule.isLynxBound = false;
function loadLynxEnv(container2, loadPicker = true) {
  loadLynxEnv.__loaded || (loadLynxEnv.__loaded = true, container2.load(lynxEnvModule), container2.load(lynxCanvasModule), container2.load(lynxWindowModule), loadPicker && loadMathPicker(container2));
}
loadLynxEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/context.js
var __decorate75 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata55 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var NodeContext2d = class extends BrowserContext2d {
  constructor(canvas, dpr) {
    super(canvas, dpr);
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
  }
  release(...params2) {
  }
};
NodeContext2d.env = "node", NodeContext2d = __decorate75([injectable(), __metadata55("design:paramtypes", [Object, Number])], NodeContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/canvas.js
var __decorate76 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata56 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var NodeCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
  }
  release(...params2) {
    this._nativeCanvas.release && isFunction_default(this._nativeCanvas.release) && this._nativeCanvas.release();
  }
};
NodeCanvas.env = "node", NodeCanvas = __decorate76([injectable(), __metadata56("design:paramtypes", [Object])], NodeCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/modules.js
var nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/node-contribution.js
var __decorate77 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata57 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "node";
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: true
    };
    this.canvas = new NodeCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    const canvas = params2.canvas, dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : 1;
    let width = params2.width, height = params2.height;
    null != width && null != height && params2.canvasControled || (width = canvas.width / dpr, height = canvas.height / dpr), this.canvas = new NodeCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer(type = "image/png") {
    return this.canvas.nativeCanvas.toBuffer(type);
  }
  addEventListener(type, listener, options) {
  }
  dispatchEvent(event) {
    return true;
  }
  removeEventListener(type, listener, options) {
  }
  getStyle() {
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(color) {
  }
};
NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate77([injectable(), __param39(0, inject(VGlobal)), __metadata57("design:paramtypes", [Object])], NodeWindowHandlerContribution);
var nodeWindowModule = new ContainerModule((bind) => {
  bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/node-contribution.js
var __decorate78 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = false;
  }
  configure(service, pkg) {
    service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadImage(url) {
    const { loadImage: loadImage2 } = this.pkg;
    return loadImage2 ? loadImage2(url).then((image) => ({
      loadState: image ? "success" : "fail",
      data: image
    })).catch(() => ({
      loadState: "fail",
      data: null
    })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(svgStr) {
    const Resvg = this.pkg.Resvg;
    if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
    const pngData = new Resvg(svgStr).render().asPng();
    return this.loadImage(pngData);
  }
  createCanvas(params2) {
    return this.pkg.createCanvas(params2.width, params2.height);
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
  }
  removeEventListener(type, listener, options) {
  }
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(event) {
  }
  release(...params2) {
  }
  createOffscreenCanvas(params2) {
  }
};
NodeEnvContribution = __decorate78([injectable()], NodeEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/node.js
var nodeEnvModule = new ContainerModule((bind) => {
  nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = true, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
});
nodeEnvModule.isNodeBound = false;
function loadNodeEnv(container2, loadPicker = true) {
  loadNodeEnv.__loaded || (loadNodeEnv.__loaded = true, container2.load(nodeEnvModule), container2.load(nodeCanvasModule), container2.load(nodeWindowModule));
}
loadNodeEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/context.js
var __decorate79 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TaroContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
  }
  draw() {
    this.nativeContext.draw();
  }
  strokeText(text2, x, y) {
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), _context.setFillStyle(createColor(this, fill, params2, offsetX, offsetY)));
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineDashOffset = defaultParams.lineDashOffset, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale } = attribute;
      _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth(keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr)), _context.setStrokeStyle(createColor(this, stroke2, params2, offsetX, offsetY)), _context.setLineJoin(lineJoin), lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.setLineCap(lineCap), _context.setMiterLimit(miterLimit);
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
    var _a;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams), _context.setFontSize(null !== (_a = params2.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
  }
  setTextStyle(params2, defaultParams) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont(params2, defaultParams), _context.setTextAlign(null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), _context.setTextBaseline(null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  createPattern(image, repetition) {
    return null;
  }
  getImageData(sx, sy, sw, sh) {
    const ctx = this.nativeContext, taro = ctx.taro;
    if (ctx && taro) return !ctx.getImageData && taro.canvasGetImageData ? new Promise((resolve, reject) => {
      try {
        taro.canvasGetImageData({
          canvasId: this.canvas.nativeCanvas.id,
          sx,
          sy,
          sw,
          sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    }) : void 0;
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createCircularGradient && this.nativeContext.createCircularGradient(x0, y0, r0, x1, y1, r1);
  }
};
TaroContext2d.env = "taro", TaroContext2d = __decorate79([injectable()], TaroContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/canvas.js
var __decorate80 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata58 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var TaroCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new TaroContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
TaroCanvas.env = "taro", TaroCanvas = __decorate80([injectable(), __metadata58("design:paramtypes", [Object])], TaroCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/modules.js
var taroCanvasModule = createModule(TaroCanvas, TaroContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/taro-contribution.js
var __decorate81 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata59 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager3 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var TaroWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "taro", this.eventManager = new MiniAppEventManager3();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new TaroCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TaroCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach((d, i) => {
      event.changedTouches[i] = Object.assign(Object.assign({}, event.changedTouches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), event.touches.length > 0 && event.touches.forEach((d, i) => {
      event.touches[i] = Object.assign(Object.assign({}, event.touches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate81([injectable(), __param40(0, inject(VGlobal)), __metadata59("design:paramtypes", [Object])], TaroWindowHandlerContribution);
var taroWindowModule = new ContainerModule((bind) => {
  bind(TaroWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(TaroWindowHandlerContribution)).whenTargetNamed(TaroWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/taro-contribution.js
var __decorate82 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata60 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function makeUpCanvas3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
  canvasIdLists.forEach((id, i) => {
    const ctx = taro.createCanvasContext(id), canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    return ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), canvas;
  });
}
var TaroEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "taro", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas3(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.taro, params2.pixelRatio), this.taro = params2.taro, this.pixelRatio = params2.pixelRatio);
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(svgStr) {
    const _window = window || globalThis;
    if (_window.DOMParser) {
      const svg = new _window.DOMParser().parseFromString(svgStr, "image/svg+xml").children[0], data = new XMLSerializer().serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    if (_window.Blob) {
      const data = new _window.Blob([svgStr], {
        type: "image/svg+xml"
      }), url = _window.URL.createObjectURL(data);
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return this.pixelRatio;
  }
  getRequestAnimationFrame() {
    return requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
TaroEnvContribution = __decorate82([injectable(), __metadata60("design:paramtypes", [])], TaroEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/taro.js
var taroEnvModule = new ContainerModule((bind) => {
  taroEnvModule.isTaroBound || (taroEnvModule.isTaroBound = true, bind(TaroEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TaroEnvContribution));
});
taroEnvModule.isTaroBound = false;
function loadTaroEnv(container2, loadPicker = true) {
  loadTaroEnv.__loaded || (loadTaroEnv.__loaded = true, container2.load(taroEnvModule), container2.load(taroCanvasModule), container2.load(taroWindowModule), loadPicker && loadMathPicker(container2));
}
loadTaroEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/context.js
var __decorate83 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var WxContext2d = class extends BrowserContext2d {
  draw() {
  }
  createPattern(image, repetition) {
    return null;
  }
};
WxContext2d.env = "wx", WxContext2d = __decorate83([injectable()], WxContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/canvas.js
var __decorate84 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata61 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var WxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new WxContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
WxCanvas.env = "wx", WxCanvas = __decorate84([injectable(), __metadata61("design:paramtypes", [Object])], WxCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/modules.js
var wxCanvasModule = createModule(WxCanvas, WxContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/wx-contribution.js
var __decorate85 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata62 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager4 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "wx", this.eventManager = new MiniAppEventManager4();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new WxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    var _a, _b, _c, _d;
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate85([injectable(), __param41(0, inject(VGlobal)), __metadata62("design:paramtypes", [Object])], WxWindowHandlerContribution);
var wxWindowModule = new ContainerModule((bind) => {
  bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(WxWindowHandlerContribution)).whenTargetNamed(WxWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/wx-contribution.js
var __decorate86 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata63 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas4(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component2, forceUpdate) {
  return __awaiter8(this, void 0, void 0, function* () {
    const dpr = wx.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      !forceUpdate && canvasMap.has(id) || (yield new Promise((resolve) => {
        let data = wx.createSelectorQuery();
        component2 && (data = data.in(component2)), data.select(`#${id}`).fields({
          node: true,
          size: true
        }).exec((res) => {
          if (!res[0]) return;
          const canvas = res[0].node, width = res[0].width, height = res[0].height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      }));
    }
  });
}
var WxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "wx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas4(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component, params2.forceUpdate).then(() => {
    });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return wx.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
WxEnvContribution = __decorate86([injectable(), __metadata63("design:paramtypes", [])], WxEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/wx.js
var wxEnvModule = new ContainerModule((bind) => {
  wxEnvModule._isWxBound || (wxEnvModule._isWxBound = true, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
});
wxEnvModule._isWxBound = false;
function loadWxEnv(container2, loadPicker = true) {
  loadWxEnv.__loaded || (loadWxEnv.__loaded = true, container2.load(wxEnvModule), container2.load(wxCanvasModule), container2.load(wxWindowModule), loadPicker && loadMathPicker(container2));
}
loadWxEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/env/all.js
function loadAllEnv(container2) {
  loadAllModule(container2);
}
function loadAllModule(container2) {
  loadAllModule.__loaded || (loadAllModule.__loaded = true, loadBrowserEnv(container2, false), loadFeishuEnv(container2, false), loadLynxEnv(container2, false), loadNodeEnv(container2, false), loadTaroEnv(container2, false), loadWxEnv(container2, false), loadCanvasPicker(container2), vglobal.hooks.onSetEnv.tap("loadMathPicker", (lastEnv, env) => {
    "browser" !== env && loadMathPicker(container2);
  }));
}
loadAllModule.__loaded = false;
function initAllEnv() {
  loadAllEnv(container);
}

// node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/context.js
var __decorate87 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TTContext2d = class extends FeishuContext2d {
};
TTContext2d.env = "tt", TTContext2d = __decorate87([injectable()], TTContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/canvas.js
var __decorate88 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata64 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var TTCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new TTContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
TTCanvas.env = "tt", TTCanvas = __decorate88([injectable(), __metadata64("design:paramtypes", [Object])], TTCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/tt/modules.js
var ttCanvasModule = createModule(TTCanvas, TTContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/tt-contribution.js
var __decorate89 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata65 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager5 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var TTWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "tt", this.eventManager = new MiniAppEventManager5();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new TTCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TTCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TTWindowHandlerContribution.env = "tt", TTWindowHandlerContribution = __decorate89([injectable(), __param42(0, inject(VGlobal)), __metadata65("design:paramtypes", [Object])], TTWindowHandlerContribution);
var ttWindowModule = new ContainerModule((bind) => {
  bind(TTWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(TTWindowHandlerContribution)).whenTargetNamed(TTWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/tt-contribution.js
var __decorate90 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata66 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas5(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component2) {
  return __awaiter9(this, void 0, void 0, function* () {
    const dpr = tt.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      yield new Promise((resolve) => {
        let data = tt.createSelectorQuery();
        component2 && (data = data.in(component2)), data.select(`#${id}`).node().exec((res) => {
          const canvas = res[0].node, width = canvas.width, height = canvas.height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      });
    }
  });
}
var TTEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "tt", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas5(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component).then(() => {
    });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
TTEnvContribution = __decorate90([injectable(), __metadata66("design:paramtypes", [])], TTEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/tt.js
var ttEnvModule = new ContainerModule((bind) => {
  ttEnvModule.isTTBound || (ttEnvModule.isTTBound = true, bind(TTEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TTEnvContribution));
});
ttEnvModule.isTTBound = false;
function loadTTEnv(container2, loadPicker = true) {
  loadTTEnv.__loaded || (loadTTEnv.__loaded = true, container2.load(ttEnvModule), container2.load(ttCanvasModule), container2.load(ttWindowModule), loadPicker && loadMathPicker(container2));
}
loadTTEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/context.js
var __decorate91 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var HarmonyContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments2) {
    const a3 = arguments, _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a3[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit, keepStrokeScale = defaultParams.keepStrokeScale, lineDashOffset = defaultParams.lineDashOffset } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || (lineDash && _context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text2, method = application.global.measureTextMethod) {
    this.setTransform(1, 0, 0, 1, 0, 0, true, application.global.devicePixelRatio);
    return super.measureText(text2, method);
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    let font = "";
    font = params2.font ? params2.font : getContextFont(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    let font = "";
    font = params2.font ? params2.font : getContextFont(params2, defaultParams, this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  createPattern(image, repetition) {
    return null;
  }
  drawImage() {
    const _context = this.nativeContext, a3 = arguments;
    a3[0].drawImage && (a3[0] = a3[0].transferToImageBitmap()), 3 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2]) : 5 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4]) : 9 === a3.length && _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8]);
  }
  draw() {
  }
};
HarmonyContext2d.env = "harmony", HarmonyContext2d = __decorate91([injectable()], HarmonyContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/canvas.js
var __decorate92 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata67 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var HarmonyCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new HarmonyContext2d(this, this._dpr);
  }
  resize(width, height) {
  }
  release(...params2) {
  }
};
HarmonyCanvas.env = "harmony", HarmonyCanvas = __decorate92([injectable(), __metadata67("design:paramtypes", [Object])], HarmonyCanvas);

// node_modules/@visactor/vrender-kits/es/window/contributions/harmony-contribution.js
var __decorate93 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata68 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager6 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var HarmonyWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "harmony", this.eventManager = new MiniAppEventManager6();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new HarmonyCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    this.canvas = new HarmonyCanvas({
      width,
      height,
      dpr: 1,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
HarmonyWindowHandlerContribution.env = "harmony", HarmonyWindowHandlerContribution = __decorate93([injectable(), __param43(0, inject(VGlobal)), __metadata68("design:paramtypes", [Object])], HarmonyWindowHandlerContribution);
var harmonyWindowModule = new ContainerModule((bind) => {
  bind(HarmonyWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(HarmonyWindowHandlerContribution)).whenTargetNamed(HarmonyWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/canvas/contributions/harmony/modules.js
var harmonyCanvasModule = createModule(HarmonyCanvas, HarmonyContext2d);

// node_modules/@visactor/vrender-kits/es/env/contributions/harmony-contribution.js
var __decorate94 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata69 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
function createCanvas(width, height, id) {
  const _c = new OffscreenCanvas(width, height), context = _c.getContext("2d");
  return new CanvasWrapDisableWH({
    width,
    height,
    context,
    _c,
    getBoundingClientRect: () => ({
      width,
      height
    }),
    getContext: () => context
  }, context, 1, width, height, id);
}
var HarmonyEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "harmony", this.supportEvent = true, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true, this.rafSTO = new RafBasedSTO(0);
  }
  configure(service, params2) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getDynamicCanvasCount() {
    return 9999;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    return createCanvas(params2.width, params2.height, params2.id);
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return (callback) => this.rafSTO.call(callback);
  }
  getCancelAnimationFrame() {
    return (h) => {
      this.rafSTO.clear(h);
    };
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
HarmonyEnvContribution = __decorate94([injectable(), __metadata69("design:paramtypes", [])], HarmonyEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/harmony.js
var harmonyEnvModule = new ContainerModule((bind) => {
  harmonyEnvModule.isHarmonyBound || (harmonyEnvModule.isHarmonyBound = true, bind(HarmonyEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(HarmonyEnvContribution));
});
harmonyEnvModule.isHarmonyBound = false;
function loadHarmonyEnv(container2, loadPicker = true) {
  loadHarmonyEnv.__loaded || (loadHarmonyEnv.__loaded = true, container2.load(harmonyEnvModule), container2.load(harmonyCanvasModule), container2.load(harmonyWindowModule), loadPicker && loadMathPicker(container2));
}
loadHarmonyEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-picker.js
var __decorate95 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata70 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultCanvasArcPicker = __decorate95([injectable(), __param44(0, inject(ArcRender)), __metadata70("design:paramtypes", [Object])], DefaultCanvasArcPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-module.js
var loadArcPick2 = false;
var arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick2 || (loadArcPick2 = true, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-picker.js
var __decorate96 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata71 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasRectPicker = __decorate96([injectable(), __param45(0, inject(RectRender)), __metadata71("design:paramtypes", [Object])], DefaultCanvasRectPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-module.js
var loadRectPick2 = false;
var rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick2 || (loadRectPick2 = true, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/common/base-line-picker.js
var BaseLinePicker = class extends BaseRender {
  contains(graphic, point6, params2) {
    if (!graphic.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === graphic.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    pickContext.highPerformanceSave();
    const lineAttribute = graphic.getGraphicTheme(), data = this.transform(graphic, lineAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = lineAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = lineAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = lineAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-picker.js
var __decorate97 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata72 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLinePicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultCanvasLinePicker = __decorate97([injectable(), __param46(0, inject(LineRender)), __metadata72("design:paramtypes", [Object])], DefaultCanvasLinePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-module.js
var loadLinePick2 = false;
var lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick2 || (loadLinePick2 = true, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-picker.js
var __decorate98 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata73 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultCanvasAreaPicker = __decorate98([injectable(), __param47(0, inject(AreaRender)), __metadata73("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-module.js
var loadAreaPick2 = false;
var areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick2 || (loadAreaPick2 = true, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/common/base-3d-picker.js
var Base3dPicker = class extends BaseRender {
  contains(graphic, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    const data = this.transform(graphic, attribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params2, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-picker.js
var __decorate99 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata74 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point6)) return false;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return true;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(), data = this.transform(symbol, symbolAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer, keepStrokeScale = symbolAttribute2.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate99([injectable(), __param48(0, inject(SymbolRender)), __metadata74("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-module.js
var loadSymbolPick2 = false;
var symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick2 || (loadSymbolPick2 = true, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-picker.js
var __decorate100 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata75 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultCanvasCirclePicker = __decorate100([injectable(), __param49(0, inject(CircleRender)), __metadata75("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-module.js
var loadCirclePick2 = false;
var circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick2 || (loadCirclePick2 = true, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-picker.js
var __decorate101 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata76 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const bounds = text2.AABBBounds;
    if (!pickContext.camera) return !!bounds.containsPoint(point6);
    pickContext.highPerformanceSave();
    const textAttribute2 = text2.getGraphicTheme(), { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text2, textAttribute2, pickContext, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.canvasRenderer.z = z;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = text2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    let picked = false;
    return this.canvasRenderer.drawShape(text2, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked) return true;
      const { fontSize = textAttribute2.fontSize, textBaseline = textAttribute2.textBaseline, textAlign = textAttribute2.textAlign } = text2.attribute, bounds2 = text2.AABBBounds, height = bounds2.height(), width = bounds2.width(), offsetY = textLayoutOffsetY(textBaseline, height, fontSize), offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate101([injectable(), __param50(0, inject(TextRender)), __metadata76("design:paramtypes", [Object])], DefaultCanvasTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-module.js
var loadTextPick2 = false;
var textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick2 || (loadTextPick2 = true, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-picker.js
var __decorate102 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata77 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathPicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultCanvasPathPicker = __decorate102([injectable(), __param51(0, inject(PathRender)), __metadata77("design:paramtypes", [Object])], DefaultCanvasPathPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-module.js
var loadPathPick2 = false;
var pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick2 || (loadPathPick2 = true, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-picker.js
var __decorate103 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata78 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultCanvasPolygonPicker = __decorate103([injectable(), __param52(0, inject(PolygonRender)), __metadata78("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-module.js
var loadPolygonPick2 = false;
var polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick2 || (loadPolygonPick2 = true, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-picker.js
var __decorate104 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata79 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasGlyphPicker = __decorate104([injectable(), __param53(0, inject(GlyphRender)), __metadata79("design:paramtypes", [Object])], DefaultCanvasGlyphPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-module.js
var loadGlyphPick2 = false;
var glyphCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick2 || (loadGlyphPick2 = true, bind(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGlyphPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-picker.js
var __decorate105 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata80 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point6, params2) {
    return !!richtext.AABBBounds.containsPoint(point6);
  }
};
DefaultCanvasRichTextPicker = __decorate105([injectable(), __param54(0, inject(RichTextRender)), __metadata80("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-module.js
var loadRichtextPick = false;
var richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = true, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-picker.js
var __decorate106 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata81 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param55 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasImagePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
};
DefaultCanvasImagePicker = __decorate106([injectable(), __param55(0, inject(ImageRender)), __metadata81("design:paramtypes", [Object])], DefaultCanvasImagePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-module.js
var loadImagePick2 = false;
var imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick2 || (loadImagePick2 = true, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-picker.js
var __decorate107 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata82 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param56 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRect3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE, this.themeType = "rect";
  }
};
DefaultCanvasRect3dPicker = __decorate107([injectable(), __param56(0, inject(Rect3DRender)), __metadata82("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-module.js
var loadRect3dPick = false;
var rect3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRect3dPick || (loadRect3dPick = true, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-picker.js
var __decorate108 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata83 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param57 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArc3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE, this.themeType = "arc";
  }
};
DefaultCanvasArc3dPicker = __decorate108([injectable(), __param57(0, inject(Arc3dRender)), __metadata83("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-module.js
var loadArc3dPick = false;
var arc3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArc3dPick || (loadArc3dPick = true, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-picker.js
var __decorate109 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata84 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param58 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPyramid3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE, this.themeType = "polygon";
  }
};
DefaultCanvasPyramid3dPicker = __decorate109([injectable(), __param58(0, inject(Pyramid3dRender)), __metadata84("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-module.js
var loadPyramid3dPick = false;
var pyramid3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPyramid3dPick || (loadPyramid3dPick = true, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
});

// node_modules/@visactor/vrender-kits/es/graphic/gif-image.js
var import_gifuct_js = __toESM(require_lib());

// node_modules/@visactor/vrender-kits/es/graphic/constants.js
var GIFIMAGE_NUMBER_TYPE = Generator.GenAutoIncrementId();
var LOTTIE_NUMBER_TYPE = Generator.GenAutoIncrementId();

// node_modules/@visactor/vrender-kits/es/graphic/gif-image.js
var GifImage = class extends Image {
  constructor(params2) {
    super(params2), this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE, this.loadGif();
  }
  loadGif() {
    if (isString_default(this.attribute.gifImage)) ResourceLoader.GetFile(this.attribute.gifImage, "arrayBuffer").then((res) => {
      const gif = (0, import_gifuct_js.parseGIF)(res), frames = (0, import_gifuct_js.decompressFrames)(gif, true);
      this.renderGIF(frames);
    }).catch((e) => {
      console.error("Gif load error: ", e);
    });
    else if (this.attribute.gifImage instanceof ArrayBuffer) {
      const gif = (0, import_gifuct_js.parseGIF)(this.attribute.gifImage), frames = (0, import_gifuct_js.decompressFrames)(gif, true);
      this.renderGIF(frames);
    }
  }
  renderGIF(frames) {
    this.loadedFrames = frames, this.frameIndex = 0, this.tempCanvas || (this.tempCanvas = application.global.createCanvas({}), this.tempCtx = this.tempCanvas.getContext("2d")), this.gifCanvas || (this.gifCanvas = application.global.createCanvas({}), this.gifCtx = this.gifCanvas.getContext("2d")), this.gifCanvas.width = frames[0].dims.width, this.gifCanvas.height = frames[0].dims.height, this.playing = true, this.lastTime = (/* @__PURE__ */ new Date()).getTime();
    const animation = this.animate();
    this.attribute.timeline && animation.setTimeline(this.attribute.timeline), animation.to({}, 1e3, "linear").loop(1 / 0);
  }
  renderFrame(context, x, y) {
    const frame = this.loadedFrames[this.frameIndex || 0];
    2 === frame.disposalType && this.gifCtx.clearRect(0, 0, this.gifCanvas.width, this.gifCanvas.height), this.drawPatch(frame), this.manipulate(context, x, y);
    const diff = (/* @__PURE__ */ new Date()).getTime() - this.lastTime;
    frame.delay < diff && (this.frameIndex++, this.lastTime = (/* @__PURE__ */ new Date()).getTime()), this.frameIndex >= this.loadedFrames.length && (this.frameIndex = 0);
  }
  drawPatch(frame) {
    const dims = frame.dims;
    this.frameImageData && dims.width === this.frameImageData.width && dims.height === this.frameImageData.height || (this.tempCanvas.width = dims.width, this.tempCanvas.height = dims.height, this.frameImageData = this.tempCtx.createImageData(dims.width, dims.height)), this.frameImageData.data.set(frame.patch), this.tempCtx.putImageData(this.frameImageData, 0, 0), this.gifCtx.drawImage(this.tempCanvas, dims.left, dims.top);
  }
  manipulate(context, x, y) {
    context.drawImage(this.gifCanvas, 0, 0, this.gifCanvas.width, this.gifCanvas.height, x, y, this.attribute.width, this.attribute.height);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), "gifImage" === key && this.loadGif();
  }
  setAttributes(params2, forceUpdateTag, context) {
    super.setAttributes(params2, forceUpdateTag, context), params2.gifImage && this.loadGif();
  }
};
function createGifImage(attributes) {
  return new GifImage(attributes);
}

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/gif-image-picker.js
var __decorate110 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGifImagePicker = class {
  constructor() {
    this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE;
  }
  contains(gifImage, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!gifImage.AABBBounds.containsPoint(point6);
  }
};
DefaultCanvasGifImagePicker = __decorate110([injectable()], DefaultCanvasGifImagePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/gif-image-module.js
var loadGifImagePick = false;
var gifImageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGifImagePick || (loadGifImagePick = true, bind(CanvasGifImagePicker).to(DefaultCanvasGifImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGifImagePicker));
});

// node_modules/@visactor/vrender-kits/es/render/contributions/canvas/gif-image-render.js
var __decorate111 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata85 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param59 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGifImageRender = class extends DefaultCanvasImageRender {
  constructor(imageRenderContribitions) {
    super(imageRenderContribitions), this.imageRenderContribitions = imageRenderContribitions, this.numberType = GIFIMAGE_NUMBER_TYPE, this._renderContribitions = void 0, this.builtinContributions = [defaultGifImageRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image, { x: originX = imageAttribute.x, y: originY = imageAttribute.y, fillStrokeOrder = imageAttribute.fillStrokeOrder } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, _runFill = () => {
      doFill && fillCb && fillCb(context, image.attribute, imageAttribute);
    }, _runStroke = () => {
      doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
    };
    fillStrokeOrder ? (_runStroke(), context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), context.restore()) : (context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), _runFill(), context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { context } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasGifImageRender = __decorate111([injectable(), __param59(0, inject(ContributionProvider)), __param59(0, named(ImageRenderContribution)), __metadata85("design:paramtypes", [Object])], DefaultCanvasGifImageRender);
var DefaultGifImageRenderContribution = class extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    image.renderFrame && image.playing && image.renderFrame(context, x, y);
  }
};
var defaultGifImageRenderContribution = new DefaultGifImageRenderContribution();

// node_modules/@visactor/vrender-kits/es/render/contributions/canvas/gif-image-module.js
var loadGifImageModule = false;
var gifImageModule = new ContainerModule((bind) => {
  loadGifImageModule || (loadGifImageModule = true, bind(DefaultCanvasGifImageRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasGifImageRender));
});

// node_modules/@visactor/vrender-kits/es/graphic/Lottie.js
var import_lottie_web = __toESM(require_lottie());
var Lottie = class extends Rect {
  constructor(params2) {
    super(params2), this.type = "lottie", this.renderNextFrame = () => {
      this.stage.renderNextFrame();
    }, this.numberType = LOTTIE_NUMBER_TYPE, this.initLottieWeb(this.attribute.data);
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.data && this.initLottieWeb(params2.data), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "data" === key && this.initLottieWeb(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  initLottieWeb(data) {
    if ("browser" !== vglobal.env) return;
    this.lottieInstance && this.releaseLottieInstance();
    const theme2 = this.getGraphicTheme(), { width = theme2.width, height = theme2.height } = this.attribute, canvas = vglobal.createCanvas({
      width,
      height,
      dpr: vglobal.devicePixelRatio
    }), params2 = {
      rendererSettings: {
        context: canvas.getContext("2d")
      },
      animType: "canvas",
      loop: true
    };
    "string" == typeof data ? params2.path = data : params2.animationData = data, this.lottieInstance = import_lottie_web.default.loadAnimation(params2), this.canvas = canvas, this.lottieInstance.addEventListener("drawnFrame", this.renderNextFrame);
  }
  release() {
    super.release(), this.releaseLottieInstance();
  }
  releaseLottieInstance() {
    this.lottieInstance.removeEventListener("drawnFrame", this.renderNextFrame), this.lottieInstance.destroy(), this.lottieInstance = null;
  }
};
Lottie.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/lottie-picker.js
var __decorate112 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata86 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param60 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLottiePicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasLottiePicker = __decorate112([injectable(), __param60(0, inject(RectRender)), __metadata86("design:paramtypes", [Object])], DefaultCanvasLottiePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/lottie-module.js
var loadLottiePick = false;
var lottieCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLottiePick || (loadLottiePick = true, bind(CanvasLottiePicker).to(DefaultCanvasLottiePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLottiePicker));
});

// node_modules/@visactor/vrender-kits/es/render/contributions/canvas/lottie-render.js
var __decorate113 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasLottieRender = class extends DefaultCanvasRectRender {
  constructor() {
    super(...arguments), this.numberType = LOTTIE_NUMBER_TYPE;
  }
  drawShape(lottie, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const _fillCb = fillCb || (() => this._drawShape.call(this, lottie, context, x, y, drawContext, params2));
    super.drawShape(lottie, context, x, y, drawContext, params2, _fillCb, strokeCb);
  }
  _drawShape(lottie, context, x, y, drawContext, params2) {
    var _a;
    const lottieAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(lottie, null == params2 ? void 0 : params2.theme).rect, { x: originX = lottieAttribute.x, y: originY = lottieAttribute.y } = lottie.attribute;
    context.setCommonStyle(lottie, lottie.attribute, originX - x, originY - y, lottieAttribute);
    const canvas = lottie.canvas;
    if (canvas) {
      const pattern = context.createPattern(canvas, "no-repeat"), dpr = context.dpr;
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, x, y])), context.fillStyle = pattern;
    }
    context.fill();
  }
};
DefaultCanvasLottieRender = __decorate113([injectable()], DefaultCanvasLottieRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/canvas/lottie-module.js
var loadLottieModule = false;
var lottieModule = new ContainerModule((bind) => {
  loadLottieModule || (loadLottieModule = true, bind(DefaultCanvasLottieRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasLottieRender));
});

// node_modules/@visactor/vrender-kits/es/register/env.js
var browser = isBrowserEnv();

// node_modules/@visactor/vrender-kits/es/register/register-arc.js
function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = true, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = false;
var registerArc = _registerArc;

// node_modules/@visactor/vrender-kits/es/register/register-arc3d.js
function _registerArc3d() {
  _registerArc3d.__loaded || (_registerArc3d.__loaded = true, registerArc3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
}
_registerArc3d.__loaded = false;
var registerArc3d = _registerArc3d;

// node_modules/@visactor/vrender-kits/es/register/register-area.js
function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = true, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = false;
var registerArea = _registerArea;

// node_modules/@visactor/vrender-kits/es/register/register-circle.js
function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = true, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = false;
var registerCircle = _registerCircle;

// node_modules/@visactor/vrender-kits/es/register/register-glyph.js
function _registerGlyph() {
  _registerGlyph.__loaded || (_registerGlyph.__loaded = true, registerGlyphGraphic(), container.load(glyphModule), container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
}
_registerGlyph.__loaded = false;
var registerGlyph = _registerGlyph;

// node_modules/@visactor/vrender-kits/es/register/register-group.js
function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = true, registerGroupGraphic());
}
_registerGroup.__loaded = false;
var registerGroup = _registerGroup;

// node_modules/@visactor/vrender-kits/es/register/register-image.js
function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = true, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = false;
var registerImage = _registerImage;

// node_modules/@visactor/vrender-kits/es/register/register-line.js
function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = true, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = false;
var registerLine = _registerLine;

// node_modules/@visactor/vrender-kits/es/register/register-path.js
function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = true, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = false;
var registerPath = _registerPath;

// node_modules/@visactor/vrender-kits/es/register/register-polygon.js
function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = true, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = false;
var registerPolygon = _registerPolygon;

// node_modules/@visactor/vrender-kits/es/register/register-pyramid3d.js
function _registerPyramid3d() {
  _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = true, registerPyramid3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
}
_registerPyramid3d.__loaded = false;
var registerPyramid3d = _registerPyramid3d;

// node_modules/@visactor/vrender-kits/es/register/register-rect.js
function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = true, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = false;
var registerRect = _registerRect;

// node_modules/@visactor/vrender-kits/es/register/register-rect3d.js
function _registerRect3d() {
  _registerRect3d.__loaded || (_registerRect3d.__loaded = true, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
}
_registerRect3d.__loaded = false;
var registerRect3d = _registerRect3d;

// node_modules/@visactor/vrender-kits/es/register/register-richtext.js
function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = true, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = false;
var registerRichtext = _registerRichtext;

// node_modules/@visactor/vrender-kits/es/register/register-shadowRoot.js
function _registerShadowRoot() {
  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = true, registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = false;
var registerShadowRoot = _registerShadowRoot;

// node_modules/@visactor/vrender-kits/es/register/register-symbol.js
function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = true, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = false;
var registerSymbol = _registerSymbol;

// node_modules/@visactor/vrender-kits/es/register/register-text.js
function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = true, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = false;
var registerText = _registerText;

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/star-picker.js
var __decorate114 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata87 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k2, v);
};
var __param61 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasStarPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "star", this.numberType = STAR_NUMBER_TYPE;
  }
};
DefaultCanvasStarPicker = __decorate114([injectable(), __param61(0, inject(StarRender)), __metadata87("design:paramtypes", [Object])], DefaultCanvasStarPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/star-module.js
var loadStarPick = false;
var starCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadStarPick || (loadStarPick = true, bind(CanvasStarPicker).to(DefaultCanvasStarPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasStarPicker));
});

// node_modules/@visactor/vrender-kits/es/register/register-star.js
function _registerStar() {
  _registerStar.__loaded || (_registerStar.__loaded = true, registerStarGraphic(), container.load(starModule), container.load(starCanvasPickModule));
}
_registerStar.__loaded = false;

// node_modules/@visactor/vrender-kits/es/register/register-wraptext.js
function _registerWrapText() {
  _registerWrapText.__loaded || (_registerWrapText.__loaded = true, registerWrapTextGraphic());
}
_registerWrapText.__loaded = false;
var registerWrapText = _registerWrapText;

// node_modules/@visactor/vrender-kits/es/register/register-gif.js
function registerGifGraphic() {
  graphicCreator.RegisterGraphicCreator("gif", createGifImage);
}
function _registerGifImage() {
  _registerGifImage.__loaded || (_registerGifImage.__loaded = true, registerGifGraphic(), container.load(gifImageModule), container.load(gifImageCanvasPickModule));
}
_registerGifImage.__loaded = false;

// node_modules/@visactor/vrender-kits/es/tools/dynamicTexture/effect.js
function pseudoRandom(n, seed = 0) {
  let hash = 3735928559 ^ seed;
  return hash = (2654435769 ^ hash) + (hash << 6) + (hash >> 2), hash = 3432918353 * (hash ^ n), hash = hash << 15 | hash >>> 17, hash ^= hash << 25, hash += hash << 9, hash ^= hash >> 4, hash ^= hash << 18, hash |= 1, (hash >>> 0) % 2147483647 / 2147483647;
}
function randomOpacity(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const targetRandomValue = 2 * pseudoRandom(row * columnCount + column) * Math.PI, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI + targetRandomValue) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnLeftToRight(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = column / columnCount, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnRightToLeft(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = (columnCount - 1 - column) / columnCount, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowTopToBottom(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = row / rowCount, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowBottomToTop(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = (rowCount - 1 - row) / rowCount, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function diagonalCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow((row - centerRow) / rowCount, 2) + Math.pow((column - centerCol) / columnCount, 2)), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance2 * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function diagonalTopLeftToBottomRight(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = (row / rowCount + column / columnCount) / 2, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rotationScan(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, angle2 = Math.atan2(row - centerRow, column - centerCol), delay = (angle2 < 0 ? angle2 + 2 * Math.PI : angle2) / (2 * Math.PI), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rippleEffect(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, normalizedDistance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2)) / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2)), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI * 3 - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function snakeWave(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const delay = (row + column) % (rowCount + columnCount) / (rowCount + columnCount), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 4 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function alternatingWave(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const rowPhase = row / rowCount, colPhase = column / columnCount, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * rowPhase * Math.PI) * Math.sin(2 * ratio * Math.PI - 2 * colPhase * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function spiralEffect(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2)), angle2 = Math.atan2(row - centerRow, column - centerCol), delay = (distance2 / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2)) + angle2 / (2 * Math.PI)) / 2, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 4 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerCol = columnCount / 2, distance2 = Math.abs(column - centerCol) / centerCol, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance2 * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnEdgeToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerCol = columnCount / 2, distance2 = 1 - Math.abs(column - centerCol) / centerCol, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance2 * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, distance2 = Math.abs(row - centerRow) / centerRow, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance2 * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowEdgeToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, distance2 = 1 - Math.abs(row - centerRow) / centerRow, _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance2 * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function cornerToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)), normalizedDistance = Math.min(distance2, 1), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function centerToCorner(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)), normalizedDistance = 1 - Math.min(distance2, 1), _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function pulseWave(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)), normalizedDistance = Math.min(distance2, 1), wavePhase = 2 * ratio * Math.PI * 3, decay = Math.max(0, 1 - normalizedDistance), _r = minRatio + amplitude * ((Math.sin(wavePhase - 4 * normalizedDistance * Math.PI) + 1) / 2) * (0.7 * decay + 0.3);
  return Math.min(1, Math.max(0, _r));
}
function particleEffect(ctx, row, column, rowCount, columnCount, ratio, graphic, minRatio = 0, amplitude = 1) {
  const index = row * columnCount + column, phase = 2 * pseudoRandom(index, 0) * Math.PI, speed = 0.5 * pseudoRandom(index, 1) + 0.5, direction = 2 * pseudoRandom(index, 2) * Math.PI, centerRow = rowCount / 2, centerCol = columnCount / 2, distance2 = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)), normalizedDistance = Math.min(distance2, 1), scatterRatio = (ratio - 0.4) / 0.6, movement = Math.sin(scatterRatio * speed * 8 * Math.PI + phase + direction * scatterRatio), distanceEffect = Math.cos(normalizedDistance * Math.PI + scatterRatio * Math.PI), _r = minRatio + amplitude * ((movement + 1) / 2 * Math.max(0, 1 - 1.2 * scatterRatio) * (0.3 + 0.7 * distanceEffect));
  return Math.min(1, Math.max(0, _r));
}

// node_modules/@visactor/vrender-components/es/scrollbar/register.js
function loadScrollbarComponent() {
  registerGroup(), registerRect();
}

// node_modules/@visactor/vrender-components/es/constant.js
var POLAR_START_ANGLE = -0.5 * Math.PI;
var POLAR_END_ANGLE = 1.5 * Math.PI;
var DEFAULT_TEXT_FONT_FAMILY2 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";
var DEFAULT_TEXT_FONT_SIZE = 14;
var StateValue;
!function(StateValue2) {
  StateValue2.selected = "selected", StateValue2.selectedReverse = "selected_reverse", StateValue2.hover = "hover", StateValue2.hoverReverse = "hover_reverse";
}(StateValue || (StateValue = {}));
var DEFAULT_STATES = {
  [StateValue.selectedReverse]: {},
  [StateValue.selected]: {},
  [StateValue.hover]: {},
  [StateValue.hoverReverse]: {}
};
var DEFAULT_HTML_TEXT_SPEC = {
  container: "",
  width: 30,
  height: 30,
  style: {}
};
var SCROLLBAR_START_EVENT = "scrollDown";
var SCROLLBAR_EVENT = "scrollDrag";
var SCROLLBAR_END_EVENT = "scrollUp";

// node_modules/@visactor/vrender-components/es/util/event.js
function getEndTriggersOfDrag() {
  return "browser" === vglobal.env ? ["pointerup", "pointerleave", "pointercancel"] : ["pointerup", "pointerleave", "pointerupoutside"];
}

// node_modules/@visactor/vrender-components/es/scrollbar/scrollbar.js
var delayMap = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadScrollbarComponent();
var ScrollBar = class _ScrollBar extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ScrollBar.defaultAttributes, attributes)), this.name = "scrollbar", this._handleTouchMove = (e) => {
      isValid_default(this._prePos) && e.preventDefault();
    }, this._onRailPointerDown = (e) => {
      const { viewX, viewY } = e, { direction, width, height, range: range2 } = this.attribute, sliderSize = this._sliderSize, [min3, max3] = this._getScrollRange();
      let currentScrollValue;
      if ("vertical" === direction) {
        const relativeY = viewY - this._viewPosition.y, currentYPos = clamp_default(relativeY - sliderSize / 2, min3, max3);
        currentScrollValue = relativeY / height, this._slider.setAttribute("y", currentYPos, true);
      } else {
        const relativeX = viewX - this._viewPosition.x, currentXPos = clamp_default(relativeX - sliderSize / 2, min3, max3);
        currentScrollValue = relativeX / width, this._slider.setAttribute("x", currentXPos, true);
      }
      this.setScrollRange([currentScrollValue - (range2[1] - range2[0]) / 2, currentScrollValue + (range2[1] - range2[0]) / 2], false), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
    }, this._onSliderPointerDown = (e) => {
      this._clearDragEvents();
      const { stopSliderDownPropagation = true } = this.attribute;
      stopSliderDownPropagation && e.stopPropagation();
      const { direction } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      this._prePos = "horizontal" === direction ? x : y, this._dispatchEvent(SCROLLBAR_START_EVENT, {
        pos: this._prePos,
        event: e
      });
      const triggers = getEndTriggersOfDrag(), obj = "browser" === vglobal.env ? vglobal : this.stage;
      obj.addEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj.addEventListener(trigger, this._onSliderPointerUp);
      });
    }, this._computeScrollValue = (e) => {
      const { direction } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      let currentScrollValue, currentPos, delta = 0;
      const { width, height } = this.getSliderRenderBounds();
      return "vertical" === direction ? (currentPos = y, delta = currentPos - this._prePos, currentScrollValue = delta / height) : (currentPos = x, delta = currentPos - this._prePos, currentScrollValue = delta / width), [currentPos, currentScrollValue];
    }, this._onSliderPointerMove = (e) => {
      const { stopSliderMovePropagation = true } = this.attribute;
      stopSliderMovePropagation && e.stopPropagation();
      const preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e);
      this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this._prePos = currentPos;
    }, this._onSliderPointerMoveWithDelay = 0 === this.attribute.delayTime ? this._onSliderPointerMove : delayMap[this.attribute.delayType](this._onSliderPointerMove, this.attribute.delayTime), this._onSliderPointerUp = (e) => {
      const { range: preRange, limitRange = [0, 1] } = this.attribute, preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e), range2 = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
      this._prePos = null, this._dispatchEvent(SCROLLBAR_END_EVENT, {
        pre: preRange,
        value: clampRange_default(range2, limitRange[0], limitRange[1])
      }), this._clearDragEvents();
    };
  }
  setScrollRange(range2, render = true) {
    const { direction = "horizontal", limitRange = [0, 1], range: preRange, realTime = true } = this.attribute, currScrollRange = clampRange_default(range2, limitRange[0], limitRange[1]);
    if (render) {
      const sliderPos = this._getSliderPos(currScrollRange);
      if (this._slider) {
        const sliderSize = sliderPos[1] - sliderPos[0];
        this._sliderSize = sliderSize, "horizontal" === direction ? this._slider.setAttributes({
          x: sliderPos[0],
          width: sliderSize
        }, true) : this._slider.setAttributes({
          y: sliderPos[0],
          height: sliderSize
        }, true), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
      }
    }
    this.attribute.range = currScrollRange, realTime && this._dispatchEvent(SCROLLBAR_EVENT, {
      pre: preRange,
      value: currScrollRange
    });
  }
  getScrollRange() {
    return this.attribute.range;
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { delayType = "throttle", delayTime = 0 } = this.attribute;
    this._rail && this._rail.addEventListener("pointerdown", delayMap[delayType](this._onRailPointerDown, delayTime)), this._slider && this._slider.addEventListener("pointerdown", this._onSliderPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    });
  }
  render() {
    this._reset();
    const { direction = "horizontal", width, height, range: range2, limitRange = [0, 1], railStyle, sliderStyle, padding = 2 } = this.attribute, group = this.createOrUpdateChild("scrollbar-container", {}, "group"), rail = group.createOrUpdateChild("scrollbar-rail", Object.assign({
      x: 0,
      y: 0,
      width,
      height
    }, railStyle), "rect");
    this._rail = rail;
    const sliderRenderBounds = this.getSliderRenderBounds(), sliderPos = this._getSliderPos(clampRange_default(range2, limitRange[0], limitRange[1])), sliderSize = sliderPos[1] - sliderPos[0];
    let sliderAttribute;
    this._sliderSize = sliderSize, sliderAttribute = "horizontal" === direction ? {
      x: sliderPos[0],
      y: sliderRenderBounds.y1,
      width: sliderSize,
      height: sliderRenderBounds.height
    } : {
      x: sliderRenderBounds.x1,
      y: sliderPos[0],
      width: sliderRenderBounds.width,
      height: sliderSize
    };
    const slider2 = group.createOrUpdateChild("slider", Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), {
      cornerRadius: this._getDefaultSliderCornerRadius()
    }), sliderStyle), {
      boundsPadding: normalizePadding(padding),
      pickMode: "imprecise"
    }), "rect");
    this._slider = slider2, this._container = group;
    const containerAABBBounds = this._container.AABBBounds;
    this._viewPosition = {
      x: containerAABBBounds.x1,
      y: containerAABBBounds.y1
    };
  }
  getSliderRenderBounds() {
    if (this._sliderRenderBounds) return this._sliderRenderBounds;
    const { width, height, padding = 2 } = this.attribute, [top, right2, bottom, left2] = normalizePadding(padding), renderBounds = {
      x1: left2,
      y1: top,
      x2: width - right2,
      y2: height - bottom,
      width: Math.max(0, width - (left2 + right2)),
      height: Math.max(0, height - (top + bottom))
    };
    return this._sliderRenderBounds = renderBounds, renderBounds;
  }
  _getDefaultSliderCornerRadius() {
    const { direction, round } = this.attribute;
    if (round) {
      const { width, height } = this.getSliderRenderBounds();
      return "horizontal" === direction ? height : width;
    }
    return 0;
  }
  _getSliderPos(range2) {
    const { direction } = this.attribute, { width, height, x1, y1 } = this.getSliderRenderBounds();
    return "horizontal" === direction ? [width * range2[0] + x1, width * range2[1] + x1] : [height * range2[0] + y1, height * range2[1] + y1];
  }
  _getScrollRange() {
    if (this._sliderLimitRange) return this._sliderLimitRange;
    const { limitRange = [0, 1], direction } = this.attribute, [min3, max3] = clampRange_default(limitRange, 0, 1), { width, height, x1, y1 } = this.getSliderRenderBounds(), sliderSize = this._sliderSize;
    return "horizontal" === direction ? clampRange_default([x1 + min3 * width, x1 + max3 * width], x1, width - sliderSize) : clampRange_default([y1 + min3 * height, y1 + max3 * height], y1, height - sliderSize);
  }
  _clearDragEvents() {
    const triggers = getEndTriggersOfDrag(), obj = "browser" === vglobal.env ? vglobal : this.stage;
    obj.removeEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj.removeEventListener(trigger, this._onSliderPointerUp);
    });
  }
  _reset() {
    this._sliderRenderBounds = null, this._sliderLimitRange = null;
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearDragEvents();
  }
};
ScrollBar.defaultAttributes = {
  direction: "horizontal",
  round: true,
  sliderSize: 20,
  sliderStyle: {
    fill: "rgba(0, 0, 0, .5)"
  },
  railStyle: {
    fill: "rgba(0, 0, 0, .0)"
  },
  padding: 2,
  scrollRange: [0, 1],
  delayType: "throttle",
  delayTime: 0,
  realTime: true
};

// node_modules/@visactor/vrender-components/es/scrollbar/scrollbar-plugin.js
var ScrollBarPlugin_1;
var __decorate115 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScrollBarPlugin = ScrollBarPlugin_1 = class {
  constructor() {
    this.name = "scrollbar", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.scroll = (e) => {
      var _a, _b;
      const graphic = e.target, data = this.getScrollContainer(graphic);
      if (!data && !this.scrollContainer) return;
      if (!data && this.scrollContainer) {
        if (!this.scrollContainer.g.stage || this.scrollContainer.g.stage !== graphic.stage) return;
        const newScrollContainer = this.formatScrollContainer(this.scrollContainer.g);
        if (!newScrollContainer) return void this.clearScrollbar(this.scrollContainer.g, "all");
        this.scrollContainer.showH && !newScrollContainer.showH && this.clearScrollbar(this.scrollContainer.g, "horizontal"), this.scrollContainer.showV && !newScrollContainer.showV && this.clearScrollbar(this.scrollContainer.g, "vertical"), this.scrollContainer = newScrollContainer;
      } else data && this.scrollContainer && data.g !== this.scrollContainer.g && this.clearScrollbar(this.scrollContainer.g, "all");
      if (this.scrollContainer = null != data ? data : this.scrollContainer, !data) return;
      const scrollContainer = data.g;
      if (!scrollContainer) return;
      const { width, height, scrollX = 0, scrollY = 0 } = scrollContainer.attribute;
      let newScrollX = scrollX, newScrollY = scrollY, { showH, showV } = data;
      this.scrollContainerBounds = new Bounds().set(0, 0, scrollContainer.attribute.width, scrollContainer.attribute.height), showH && showH && (abs(e.deltaX) > abs(e.deltaY) ? (showH = showH && true, showV = showV && false) : (showH = showH && false, showV = showV && true));
      const scrollWidth = this.childrenBounds.width(), scrollHeight = this.childrenBounds.height();
      showH && (newScrollX = scrollX - (null !== (_a = e.deltaX) && void 0 !== _a ? _a : 0), newScrollX > 0 ? newScrollX = 0 : newScrollX < width - scrollWidth && (newScrollX = width - scrollWidth)), showV && (newScrollY = scrollY - (null !== (_b = e.deltaY) && void 0 !== _b ? _b : 0), newScrollY > 0 ? newScrollY = 0 : newScrollY < height - scrollHeight && (newScrollY = height - scrollHeight)), scrollContainer.setAttributes({
        scrollX: newScrollX,
        scrollY: newScrollY
      }), this.addOrUpdateScroll(showH, showV, scrollContainer.parent, scrollContainer);
    }, this.handleScrollBarChange = (params2) => {
      if (!(this.scrollContainer && this.scrollContainerBounds && this.childrenBounds && params2 && params2.target && params2.detail && params2.detail.value)) return;
      const scrollbar2 = params2.target, newRange = params2.detail.value;
      if ("horizontal" === scrollbar2.attribute.direction) {
        const scrollWidth = this.childrenBounds.width();
        this.scrollContainer.g.setAttributes({
          scrollX: -newRange[0] * scrollWidth
        });
      } else {
        const scrollHeight = this.childrenBounds.height();
        this.scrollContainer.g.setAttributes({
          scrollY: -newRange[0] * scrollHeight
        });
      }
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    this.childrenBounds = new AABBBounds(), stage.addEventListener("wheel", this.scroll), this.params = ScrollBarPlugin_1.defaultParams;
  }
  initEventOfScrollbar(scrollContainer, scrollbar2, isHorozntal) {
    scrollContainer.addEventListener("pointerover", () => {
      scrollbar2.setAttribute("visibleAll", true);
    }), scrollContainer.addEventListener("pointermove", () => {
      scrollbar2.setAttribute("visibleAll", true);
    }), scrollContainer.addEventListener("pointerout", () => {
      scrollbar2.setAttribute("visibleAll", false);
    }), scrollbar2.addEventListener("pointerover", () => {
      scrollbar2.setAttribute("visibleAll", true);
    }), scrollbar2.addEventListener("pointerout", () => {
      scrollbar2.setAttribute("visibleAll", true);
    }), scrollbar2.addEventListener("scrollUp", this.handleScrollBarChange), scrollbar2.addEventListener(SCROLLBAR_EVENT, this.handleScrollBarChange);
  }
  addOrUpdateScroll(showH, showV, container2, scrollContainer) {
    if (showH) {
      const { scrollBar: hScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container2, true);
      isUpdate || this.initEventOfScrollbar(scrollContainer, hScrollbar, true);
    } else this.clearScrollbar(scrollContainer, "horizontal");
    if (showV) {
      const { scrollBar: vScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container2, false);
      isUpdate || this.initEventOfScrollbar(scrollContainer, vScrollbar, false);
    } else this.clearScrollbar(scrollContainer, "vertical");
  }
  getDirection(isHorozntal) {
    return isHorozntal ? "horizontal" : "vertical";
  }
  addOrUpdateHScroll(scrollContainer, container2, isHorozntal) {
    var _a, _b;
    const direction = this.getDirection(isHorozntal), name = `${null !== (_a = scrollContainer.name) && void 0 !== _a ? _a : scrollContainer._uid}_${this.getDirection(isHorozntal)}_${this.name}`, scrollbars = container2.children.filter((g) => g.name === name);
    let isUpdate = true, scrollBar2 = scrollbars[0];
    const { y = 0, dy = 0, x = 0, dx = 0, height, width, zIndex = 0 } = this.scrollContainer.g.attribute, attrs = {
      x: 0,
      y: 0,
      direction,
      zIndex: zIndex + 1,
      visibleAll: true,
      padding: [2, 0],
      railStyle: {
        fill: "rgba(0, 0, 0, .1)"
      },
      range: [0, 0.05]
    };
    isHorozntal ? (attrs.width = this.scrollContainerBounds.width(), attrs.height = 12) : (attrs.height = this.scrollContainerBounds.height(), attrs.width = 12), scrollBar2 ? scrollbars.length > 1 && scrollbars.forEach((child, index) => {
      var _a2;
      index && (null === (_a2 = child.parent) || void 0 === _a2 || _a2.removeChild(child));
    }) : (isUpdate = false, scrollBar2 = new ScrollBar(attrs), scrollBar2.name = name, container2.add(scrollBar2), scrollBar2.isScrollBar = true);
    const childrenBounds = this.childrenBounds, { scrollX, scrollY } = scrollContainer.attribute;
    if (isHorozntal) {
      const ratio = Math.min(this.scrollContainerBounds.width() / childrenBounds.width(), 1), start = Math.max(Math.min(scrollX / this.childrenBounds.width(), 0), ratio - 1);
      attrs.x = x + dx, attrs.y = y + dy + height - (null !== (_b = attrs.height) && void 0 !== _b ? _b : 0), attrs.range = [-start, -start + ratio];
    } else {
      const ratio = Math.min(this.scrollContainerBounds.height() / childrenBounds.height(), 1), start = Math.max(Math.min(scrollY / this.childrenBounds.height(), 0), ratio - 1);
      attrs.x = x + dx + width - this.scrollContainerBounds.width(), attrs.y = y + dy, attrs.range = [-start, -start + ratio];
    }
    return scrollBar2.setAttributes(attrs), {
      scrollBar: scrollBar2,
      isUpdate
    };
  }
  clearScrollbar(scrollContainer, type) {
    if (!scrollContainer.parent) return;
    scrollContainer.parent.children.filter((child) => child.isScrollBar && ("all" === type || child.attribute.direction === type)).forEach((child) => {
      child.parent.removeChild(child);
    });
  }
  formatScrollContainer(g) {
    if (!g || "group" !== g.type || !g.attribute) return null;
    const { overflow, width, height } = g.attribute;
    if (!overflow || "hidden" === overflow) return null;
    let showH = false, showV = false;
    "scroll" === overflow ? (showH = true, showV = true) : (showH = "scroll-x" === overflow, showV = !showH);
    const childrenBounds = this.childrenBounds;
    return childrenBounds.clear(), g.forEachChildren((g2) => {
      childrenBounds.union(g2.AABBBounds);
    }), g.AABBBounds.empty() || (showH && (showH = width < childrenBounds.width()), showV && (showV = height < childrenBounds.height())), showH || showV ? {
      g,
      showH,
      showV
    } : null;
  }
  getScrollContainer(graphic) {
    let g = graphic;
    for (; g; ) {
      const res = this.formatScrollContainer(g);
      if (res) return res;
      g = g.parent;
    }
    return null;
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("wheel", this.scroll);
  }
};
ScrollBarPlugin.defaultParams = {
  timeout: 500
}, ScrollBarPlugin = ScrollBarPlugin_1 = __decorate115([injectable()], ScrollBarPlugin);

// node_modules/@visactor/vrender-components/es/scrollbar/module.js
var scrollbarModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(ScrollBarPlugin) || (bind(ScrollBarPlugin).toSelf(), bind(AutoEnablePlugins).toService(ScrollBarPlugin));
});
function loadScrollbar() {
  container.load(scrollbarModule);
}

// node_modules/@visactor/vrender-components/es/util/common.js
function traverseGroup(group, cb) {
  group.forEachChildren((node) => {
    const stopped = cb(node);
    node.isContainer && !stopped && traverseGroup(node, cb);
  });
}
var isVisible = (obj) => !isNil_default(obj) && false !== obj.visible;
function getMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.getChildren() : [];
}
function getNoneGroupMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.findAll((node) => "group" !== node.type, true) : [];
}
function removeRepeatPoint(points) {
  const result2 = [points[0]];
  for (let i = 1; i < points.length; i++) points[i].x === points[i - 1].x && points[i].y === points[i - 1].y || result2.push(points[i]);
  return result2;
}
function isPostiveXAxis(angle2) {
  return angle2 >= 0 && angle2 < Math.PI / 2 || angle2 > 3 * Math.PI / 2 && angle2 <= 2 * Math.PI;
}
function fuzzyEqualNumber(a3, b, delta) {
  return Math.abs(a3 - b) < delta;
}
function getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) {
  return autoRotate2 ? {
    textAlign: "right",
    textBaseline: "middle"
  } : {
    textAlign: lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("top") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") ? "left" : lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("top") ? "right" : "center",
    textBaseline: lineEndAngle < Math.PI && itemPosition.includes("inside") || lineEndAngle > Math.PI && !itemPosition.includes("inside") ? "bottom" : "top"
  };
}

// node_modules/@visactor/vrender-components/es/util/label-smartInvert.js
var defaultAlternativeColors = ["#ffffff", "#000000"];
function labelSmartInvert(foregroundColorOrigin, backgroundColorOrogin, textType, contrastRatiosThreshold, alternativeColors, mode) {
  if ("string" != typeof foregroundColorOrigin || "string" != typeof backgroundColorOrogin) return foregroundColorOrigin;
  const foregroundColor = new Color(foregroundColorOrigin).toHex(), backgroundColor = new Color(backgroundColorOrogin).toHex();
  return contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) ? foregroundColor : improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode);
}
function improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode) {
  const alternativeColorPalletes = [];
  alternativeColors && (alternativeColors instanceof Array ? alternativeColorPalletes.push(...alternativeColors) : alternativeColorPalletes.push(alternativeColors)), alternativeColorPalletes.push(...defaultAlternativeColors);
  for (const alternativeColor of alternativeColorPalletes) if (foregroundColor !== alternativeColor && contrastAccessibilityChecker(alternativeColor, backgroundColor, textType, contrastRatiosThreshold, mode)) return alternativeColor;
}
function contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) {
  if ("lightness" === mode) {
    const backgroundColorLightness = Color.getColorBrightness(new Color(backgroundColor));
    return Color.getColorBrightness(new Color(foregroundColor)) < 0.5 ? backgroundColorLightness >= 0.5 : backgroundColorLightness < 0.5;
  }
  return contrastRatiosThreshold ? contrastRatios(foregroundColor, backgroundColor) > contrastRatiosThreshold : "largeText" === textType ? contrastRatios(foregroundColor, backgroundColor) > 3 : contrastRatios(foregroundColor, backgroundColor) > 4.5;
}
function contrastRatios(foregroundColor, backgroundColor) {
  const foregroundColorLuminance = getColorLuminance(foregroundColor), backgroundColorLuminance = getColorLuminance(backgroundColor);
  return ((foregroundColorLuminance > backgroundColorLuminance ? foregroundColorLuminance : backgroundColorLuminance) + 0.05) / ((foregroundColorLuminance > backgroundColorLuminance ? backgroundColorLuminance : foregroundColorLuminance) + 0.05);
}
function getColorLuminance(color) {
  const rgb8bit = hexToRgb(color), RsRGB = rgb8bit[0] / 255, GsRGB = rgb8bit[1] / 255, BsRGB = rgb8bit[2] / 255;
  let R, G, B;
  R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4), G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4), B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
function smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor) {
  let result2;
  switch (fillStrategy) {
    case "base":
      result2 = baseColor;
      break;
    case "invertBase":
      result2 = invertColor;
      break;
    case "similarBase":
      result2 = similarColor;
  }
  return result2;
}

// node_modules/@visactor/vrender-components/es/util/matrix.js
function scale3(vector, scale4) {
  return [vector[0] * scale4, vector[1] * scale4];
}
function length(vector) {
  const [x, y] = vector;
  return Math.sqrt(x * x + y * y);
}
function normalize(vector) {
  let len = length(vector);
  return len > 0 && (len = 1 / len), [vector[0] * len, vector[1] * len];
}
function angle(vector1, vector2) {
  const [x1, y1] = vector1, [x2, y2] = vector2, mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function angleTo(v1, v2, direct) {
  const ang = angle(v1, v2), angleLargeThanPI = crossProduct(v1, v2) >= 0;
  return direct ? angleLargeThanPI ? 2 * Math.PI - ang : ang : angleLargeThanPI ? ang : 2 * Math.PI - ang;
}

// node_modules/@visactor/vrender-components/es/util/text.js
var initTextMeasure = (textSpec, option, useNaiveCanvas, defaultFontParams) => new TextMeasure(Object.assign({
  defaultFontParams: Object.assign({
    fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
    fontSize: DEFAULT_TEXT_FONT_SIZE
  }, defaultFontParams),
  getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
  specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
}, null != option ? option : {}), textSpec);
function measureTextSize(text2, textSpec, defaultTextTheme = {}) {
  if (!text2) return {
    width: 0,
    height: 0
  };
  const bounds = getTextBounds({
    text: text2,
    fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY2,
    fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
    fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
    textAlign: textSpec.textAlign || "center",
    textBaseline: textSpec.textBaseline,
    ellipsis: !!textSpec.ellipsis,
    maxLineWidth: textSpec.maxLineWidth || 1 / 0,
    lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
  });
  return {
    width: bounds.width(),
    height: bounds.height()
  };
}
function isRichText(attributes, typeKey = "type") {
  return "rich" === getTextType(attributes, typeKey);
}
function getTextType(attributes, typeKey = "type") {
  var _a, _b;
  return isObject_default(attributes.text) && "type" in attributes.text ? null !== (_a = attributes.text.type) && void 0 !== _a ? _a : "text" : typeKey in attributes && null !== (_b = attributes[typeKey]) && void 0 !== _b ? _b : "text";
}
function richTextAttributeTransform(attributes) {
  var _a, _b;
  return isValid_default(attributes.maxLineWidth) && (attributes.maxWidth = attributes.maxLineWidth, delete attributes.maxLineWidth), attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0, attributes.textConfig = attributes.text.text || attributes.text, attributes;
}
function htmlAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: html } = text2;
  return attributes.html = html, attributes.text = _originText, attributes.renderable = false, attributes;
}
function reactAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: react } = text2;
  return attributes.react = react, attributes.text = _originText, attributes.renderable = false, attributes;
}
function createTextGraphicByType(textAttributes, typeKey = "type") {
  const textType = getTextType(textAttributes, typeKey);
  return "rich" === textType ? graphicCreator.richtext(richTextAttributeTransform(textAttributes)) : ("html" === textType ? textAttributes = htmlAttributeTransform(textAttributes) : "react" === textType && (textAttributes = reactAttributeTransform(textAttributes)), graphicCreator.text(textAttributes));
}
function alignTextInLine(layoutAlign, graphic, textAlign, pos, textWidth) {
  "right" === layoutAlign ? "center" === textAlign ? graphic.setAttribute("x", pos - textWidth / 2) : "right" === textAlign || "end" === textAlign ? graphic.setAttribute("x", pos) : graphic.setAttribute("x", pos - textWidth) : "center" === textAlign ? graphic.setAttribute("x", pos + textWidth / 2) : "right" === textAlign || "end" === textAlign ? graphic.setAttribute("x", pos + textWidth) : graphic.setAttribute("x", pos);
}

// node_modules/@visactor/vrender-components/es/util/polar.js
var deltaXYToAngle = (y, x) => {
  const angle2 = Math.atan2(y, x);
  return angle2 < 0 ? angle2 + 2 * Math.PI : angle2;
};

// node_modules/@visactor/vrender-components/es/util/limit-shape.js
function computeOffsetForlimit(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1, y1, x2, y2 } = shape.AABBBounds;
  let dx = 0, dy = 0;
  return x1 < regionMinX && (dx = regionMinX - x1), y1 < regionMinY && (dy = regionMinY - y1), x2 > regionMaxX && (dx = regionMaxX - x2), y2 > regionMaxY && (dy = regionMaxY - y2), {
    dx,
    dy
  };
}
function limitShapeInBounds(shape, bounds) {
  const { dx, dy } = computeOffsetForlimit(shape, bounds), { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}

// node_modules/@visactor/vrender-components/es/tag/register.js
function loadTagComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
}

// node_modules/@visactor/vrender-components/es/tag/tag.js
var __rest = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadTagComponent();
var Tag = class _Tag extends AbstractComponent {
  getBgRect() {
    return this._bgRect;
  }
  getTextShape() {
    return this._textShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tag.defaultAttributes, attributes)), this.name = "tag", this._tagStates = [], this._rectStates = [], this._symbolStates = [], this._textStates = [];
  }
  render() {
    var _a, _b, _c;
    this.cacheStates();
    const { text: text2 = "", textStyle = {}, shape = {}, panel = {}, space = 4, minWidth, maxWidth, padding = 4, visible, state, type, textAlwaysCenter, containerTextAlign } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("tag-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    let symbol, tagX = -parsedPadding[3], tagY = -parsedPadding[0], tagWidth = parsedPadding[1] + parsedPadding[3], tagHeight = parsedPadding[0] + parsedPadding[2], textX = 0, symbolPlaceWidth = 0;
    const { visible: shapeVisible } = shape, shapeStyle = __rest(shape, ["visible"]);
    if (isBoolean_default(shapeVisible)) {
      const size2 = (null == shapeStyle ? void 0 : shapeStyle.size) || 10, maxSize2 = isNumber_default(size2) ? size2 : Math.max(size2[0], size2[1]);
      symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
        symbolType: "circle",
        size: size2,
        strokeBoundsBuffer: 0
      }, shapeStyle), {
        visible: shapeVisible,
        x: maxSize2 / 2,
        y: maxSize2 / 2
      }), "symbol"), isEmpty_default(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize2 + space);
    }
    let textShape, textWidth, textHeight;
    tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth;
    if (isRichText({
      text: text2
    }) || "rich" === type) {
      const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({
        type,
        text: text2
      }, textStyle))), textStyle), {
        visible: isValid_default(text2) && false !== visible,
        x: textX,
        y: 0
      });
      isNil_default(richTextAttrs.lineHeight) && (richTextAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext"), textWidth = textShape.AABBBounds.width(), textHeight = textShape.AABBBounds.height();
    } else {
      const textAttrs = Object.assign(Object.assign({
        text: isObject_default(text2) && "type" in text2 && "text" === text2.type ? text2.text : text2,
        visible: isValid_default(text2) && false !== visible,
        lineHeight: null == textStyle ? void 0 : textStyle.fontSize
      }, textStyle), {
        x: textX,
        y: 0
      });
      isNil_default(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text");
      const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text);
      textWidth = textBounds.width, textHeight = textBounds.height;
    }
    tagWidth += textWidth;
    const size = null !== (_c = shape.size) && void 0 !== _c ? _c : 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
    tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
    const { textAlign, textBaseline } = textStyle;
    (isValid_default(minWidth) || isValid_default(maxWidth)) && (isValid_default(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid_default(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2]))), tagX = 0, tagY = 0;
    let flag = 0;
    "left" === textAlign || "start" === textAlign ? flag = 1 : "right" === textAlign || "end" === textAlign ? flag = -1 : "center" === textAlign && (flag = 0), flag ? flag < 0 ? (tagX -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : flag > 0 && group.setAttribute("x", parsedPadding[3]) : (tagX -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2));
    const shouldRight = "right" === containerTextAlign || "end" === containerTextAlign, shouldLeft = "left" === containerTextAlign || "start" === containerTextAlign, updateTextAttrs = (textX2, textAlign2) => {
      "richtext" === textShape.type ? textShape.setAttributes({
        x: textX2,
        textAlign: textAlign2,
        textConfig: array(textShape.attribute.textConfig).map((t) => Object.assign(Object.assign({}, t), {
          textAlign: textAlign2
        }))
      }) : textShape.setAttributes({
        x: textX2,
        textAlign: textAlign2
      });
    };
    if ((containerTextAlign ? "center" === containerTextAlign : textAlwaysCenter) && flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], tsWidth = textWidth + symbolPlaceWidth, textX2 = 1 === flag ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2 : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
      if (updateTextAttrs(textX2, "center"), symbol) {
        const symbolX = textX2 - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    if (shouldLeft && 1 !== flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], offset = 0 === flag ? -containerWidth / 2 + symbolPlaceWidth / 2 : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth;
      if (updateTextAttrs(offset + symbolPlaceWidth, "left"), symbol) {
        const symbolX = offset + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    if (shouldRight && -1 !== flag) {
      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], textX2 = 0 === flag ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
      if (updateTextAttrs(textX2, "right"), symbol) {
        const symbolX = textX2 - textWidth - symbolPlaceWidth + maxSize / 2;
        symbol.setAttributes({
          x: symbolX
        });
      }
    }
    "middle" === textBaseline ? (tagY -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (tagY -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2)), isEmpty_default(null == state ? void 0 : state.text) || (textShape.states = state.text);
    const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
    if (visible && isBoolean_default(bgVisible)) {
      const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
        visible: bgVisible && !!text2,
        width: tagWidth,
        height: tagHeight,
        x: tagX,
        y: tagY
      }), "rect");
      if (isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), backgroundStyle.customShape) {
        const customShape = backgroundStyle.customShape;
        bgRect.pathProxy = (attrs) => customShape(this, attrs, new CustomPath2D());
      }
      this._bgRect = bgRect;
    }
    this._textShape = textShape, this._symbol = symbol, this.resetStates();
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Tag.defaultAttributes, params2), super.initAttributes(params2), this.render();
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    super.addState(stateName, keepCurrentStates, hasAnimation), this._textShape && this._textShape.addState(stateName, keepCurrentStates, hasAnimation), this._bgRect && this._bgRect.addState(stateName, keepCurrentStates, hasAnimation), this._symbol && this._symbol.addState(stateName, keepCurrentStates, hasAnimation);
  }
  removeState(stateName, hasAnimation) {
    super.removeState(stateName, hasAnimation), this._textShape && this._textShape.removeState(stateName, hasAnimation), this._bgRect && this._bgRect.removeState(stateName, hasAnimation), this._symbol && this._symbol.removeState(stateName, hasAnimation);
  }
  cacheStates() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    this._tagStates = null !== (_b = null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.slice()) && void 0 !== _b ? _b : [], this._rectStates = null !== (_e = null === (_d = null === (_c = this._bgRect) || void 0 === _c ? void 0 : _c.currentStates) || void 0 === _d ? void 0 : _d.slice()) && void 0 !== _e ? _e : [], this._symbolStates = null !== (_h = null === (_g = null === (_f = this._symbol) || void 0 === _f ? void 0 : _f.currentStates) || void 0 === _g ? void 0 : _g.slice()) && void 0 !== _h ? _h : [], this._textStates = null !== (_l = null === (_k = null === (_j = this._textShape) || void 0 === _j ? void 0 : _j.currentStates) || void 0 === _k ? void 0 : _k.slice()) && void 0 !== _l ? _l : [], this.clearStates(), null === (_m = this._bgRect) || void 0 === _m || _m.clearStates(), null === (_o = this._symbol) || void 0 === _o || _o.clearStates(), null === (_p = this._textShape) || void 0 === _p || _p.clearStates();
  }
  resetStates() {
    var _a, _b, _c;
    this._tagStates.length && this.useStates(this._tagStates), this._rectStates.length && (null === (_a = this._bgRect) || void 0 === _a || _a.useStates(this._rectStates)), this._symbolStates.length && (null === (_b = this._symbol) || void 0 === _b || _b.useStates(this._symbolStates)), this._textStates.length && (null === (_c = this._textShape) || void 0 === _c || _c.useStates(this._textStates));
  }
};
Tag.defaultAttributes = {
  visible: true,
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  space: 4,
  padding: 4,
  shape: {
    fill: "#000"
  }
};

// node_modules/@visactor/vrender-components/es/poptip/theme.js
var DEFAULT_THEME = {
  visible: true,
  position: "auto",
  titleStyle: {
    fontSize: 16,
    fill: "#08979c"
  },
  contentStyle: {
    fontSize: 12,
    fill: "green"
  },
  panel: {
    visible: true,
    fill: "#e6fffb",
    size: 12,
    space: 0,
    stroke: "#87e8de",
    lineWidth: 1,
    cornerRadius: 4
  }
};
var theme = {
  poptip: merge({}, DEFAULT_THEME)
};

// node_modules/@visactor/vrender-components/es/poptip/register.js
function loadPoptipComponent() {
  registerGroup(), registerText(), registerSymbol(), registerRect();
}
function setPoptipTheme(defaultPoptipTheme) {
  merge(theme.poptip, DEFAULT_THEME, defaultPoptipTheme);
}

// node_modules/@visactor/vrender-components/es/poptip/poptip.js
var __rest2 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var _tBounds = new AABBBounds();
loadPoptipComponent();
var tlStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 -0.5, Z";
var blStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 0.5, Z";
var trStr = "M -0.5 -0.5, L 0.5 -0.5, L 0.5 0.5, Z";
var brStr = "M 0.5 -0.5, L 0.5 0.5, L -0.5 0.5, Z";
var conciseSymbolMap = {
  tl: tlStr,
  tr: trStr,
  bl: blStr,
  br: brStr,
  lt: tlStr,
  lb: blStr,
  rt: trStr,
  rb: brStr
};
var PopTip = class _PopTip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PopTip.defaultAttributes, attributes)), this.name = "poptip", this.positionList = ["top", "tl", "tr", "bottom", "bl", "br", "left", "lt", "lb", "right", "rt", "rb"];
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { titleStyle = {}, position, contentStyle = {}, panel, logoSymbol, poptipAnchor = "position", logoText, logoTextStyle = {}, triangleMode = "default", space = 4, minWidth = 0, maxWidth = 1 / 0, padding = 4, maxWidthPercent, visible, state, dx = 0, dy = 0, positionBounds } = this.attribute;
    let { title: title3 = "", content = "" } = this.attribute;
    title3 = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title3) : title3, content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
    const parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("poptip-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    this.group = group;
    const maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3], titleVisible = isValid_default(title3) && false !== visible, titleAttrs = Object.assign(Object.assign({
      text: isArray_default(title3) ? title3 : [title3],
      visible: titleVisible,
      wrap: true
    }, titleStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0],
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), titleShape = group.createOrUpdateChild("poptip-title", titleAttrs, "text");
    isEmpty_default(null == state ? void 0 : state.title) || (titleShape.states = state.title);
    const titleBounds = titleShape.AABBBounds, titleHeight = titleBounds.height(), titleWidth = titleBounds.width();
    let height = titleHeight + space;
    titleVisible || (height = 0);
    const contentVisible = isValid_default(content) && false !== visible, contentAttrs = Object.assign(Object.assign({
      text: isArray_default(content) ? content : [content],
      visible: contentVisible,
      wrap: true
    }, contentStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0] + height,
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), contentShape = group.createOrUpdateChild("poptip-content", contentAttrs, "text");
    isEmpty_default(null == state ? void 0 : state.content) || (contentShape.states = state.content);
    const contentBounds = contentShape.AABBBounds, contentHeight = contentBounds.height(), contentWidth = contentBounds.width();
    contentVisible && (height += contentHeight), this.titleShape = titleShape, this.contentShape = contentShape;
    let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
    popTipWidth > maxWidth ? popTipWidth = maxWidth : popTipWidth < minWidth && (popTipWidth = minWidth);
    let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
    const { visible: bgVisible, square: square4 } = panel, backgroundStyle = __rest2(panel, ["visible", "square"]);
    if (square4) {
      const maxWH = max(popTipWidth, poptipHeight);
      popTipWidth = maxWH;
      const deltaH = maxWH - poptipHeight;
      poptipHeight = maxWH, titleShape.setAttributes({
        dy: deltaH / 2
      }), contentShape.setAttributes({
        dy: deltaH / 2
      });
    }
    const symbolSize = null !== (_a = backgroundStyle.size) && void 0 !== _a ? _a : 12, spaceSize = isArray_default(symbolSize) ? [symbolSize[0] + (null !== (_b = backgroundStyle.space) && void 0 !== _b ? _b : 0), symbolSize[1] + (null !== (_c = backgroundStyle.space) && void 0 !== _c ? _c : 0)] : symbolSize + (null !== (_d = backgroundStyle.space) && void 0 !== _d ? _d : 0), lineWidth = null !== (_e = backgroundStyle.lineWidth) && void 0 !== _e ? _e : 1, range2 = this.stage ? [null !== (_f = this.stage.viewWidth) && void 0 !== _f ? _f : this.stage.width, null !== (_g = this.stage.viewHeight) && void 0 !== _g ? _g : this.stage.height] : void 0;
    if (range2) {
      const b = this.AABBBounds, leftWidth = null !== (_h = this.attribute.x) && void 0 !== _h ? _h : b.x1, rightWidth = range2[0] - b.x1;
      let maxSpace = Math.max(leftWidth, rightWidth);
      const buf = (isArray_default(symbolSize) ? symbolSize[0] : 12) + 3;
      if (maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent), maxSpace < popTipWidth) {
        popTipWidth = maxSpace;
        const buf2 = parsedPadding[1] + parsedPadding[3];
        titleShape.setAttribute("maxLineWidth", maxSpace - buf2), contentShape.setAttribute("maxLineWidth", maxSpace - buf2), poptipHeight = parsedPadding[0] + parsedPadding[2], titleVisible && (poptipHeight += titleShape.AABBBounds.height() + space), poptipHeight += contentShape.AABBBounds.height();
      }
    }
    const layout2 = "auto" === position || isArray_default(position), positionList = isArray_default(position) ? position : this.positionList;
    let maxBBoxI, maxBBoxSize = -1 / 0;
    for (let i = 0; i < positionList.length + 1; i++) {
      const p = layout2 ? positionList[i === positionList.length ? maxBBoxI : i] : position;
      let symbolType = "arrow2Left", offsetX = (isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 4, offsetY = 0;
      "top" === p || "bottom" === p || "left" === p || "right" === p ? symbolType = "arrow2Left" : "concise" === triangleMode && (symbolType = conciseSymbolMap[p], offsetX = ["tl", "bl", "rt", "rb"].includes(p) ? (isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 2 : -(isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 2, offsetY = ["tl", "tr", "lb", "rb"].includes(p) ? -(isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2 : (isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2);
      const { angle: angle2, offset } = this.getAngleAndOffset(p, popTipWidth, poptipHeight, isArray_default(spaceSize) ? spaceSize : [spaceSize, spaceSize - lineWidth], symbolType);
      let bgSymbol, anchorPoint = {
        x: 0,
        y: 0
      };
      if ("bounds" === poptipAnchor && positionBounds && (anchorPoint = this.calculateAnchorPoint(p, positionBounds)), isBoolean_default(bgVisible)) {
        let bgRect;
        bgSymbol = group.createOrUpdateChild("poptip-symbol-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: offsetX,
          y: offsetY,
          strokeBoundsBuffer: -1,
          boundsPadding: -2,
          anchor: [0, 0],
          symbolType,
          angle: angle2,
          dx: offset[0],
          dy: offset[1] - (null !== (_j = backgroundStyle.space) && void 0 !== _j ? _j : 0),
          size: symbolSize,
          zIndex: 9
        }), "symbol"), isEmpty_default(null == state ? void 0 : state.panel) || (bgSymbol.states = state.panel), bgRect = panel.panelSymbolType ? group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: 0,
          y: 0,
          symbolType: "rect",
          size: [popTipWidth, poptipHeight],
          zIndex: -8
        }), "symbol") : group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: 0,
          y: 0,
          width: popTipWidth,
          height: poptipHeight,
          zIndex: -8
        }), "rect"), isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
      if (group.setAttributes({
        x: -offset[0] + dx + anchorPoint.x,
        y: -offset[1] + dy + anchorPoint.y,
        anchor: [offsetX, offsetY]
      }), logoSymbol) {
        const { size = 12 } = logoSymbol, sizeArray = isArray_default(size) ? size : [size, size];
        "auto" === sizeArray[1] && (sizeArray[1] = poptipHeight), "auto" === sizeArray[0] && (sizeArray[0] = poptipHeight);
        const sizeW = sizeArray[0];
        group.createOrUpdateChild("poptip-logo", Object.assign(Object.assign({}, logoSymbol), {
          x: 0,
          y: poptipHeight / 2,
          visible: bgVisible && (contentVisible || titleVisible),
          zIndex: 10,
          size: sizeArray
        }), "symbol"), group.setAttributes({
          x: -offset[0] + dx + sizeW / 2,
          y: -offset[1] + dy
        }), logoText && group.createOrUpdateChild("poptip-logo-text", Object.assign(Object.assign({}, logoTextStyle), {
          x: 0,
          y: poptipHeight / 2,
          visible: bgVisible && (contentVisible || titleVisible),
          text: logoText,
          textAlign: "center",
          textBaseline: "middle",
          zIndex: 10
        }), "text");
      }
      if (!range2) break;
      {
        _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
        const b = _tBounds, stageBounds = new Bounds().setValue(0, 0, range2[0], range2[1]);
        if (layout2) {
          if (rectInsideAnotherRect(b, stageBounds, false)) break;
          {
            const bbox = getRectIntersect(b, stageBounds, false), size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
            size > maxBBoxSize && (maxBBoxSize = size, maxBBoxI = i);
          }
        }
        if (["top", "bottom", "left", "right"].includes(p)) {
          const isVerticalPosition = "top" === p || "bottom" === p, isHorizontalPosition2 = "left" === p || "right" === p;
          let mainDirectionOverlap = false;
          if (isVerticalPosition ? mainDirectionOverlap = "top" === p && b.y1 < 0 || "bottom" === p && b.y2 > stageBounds.y2 : isHorizontalPosition2 && (mainDirectionOverlap = "left" === p && b.x1 < 0 || "right" === p && b.x2 > stageBounds.x2), !mainDirectionOverlap) {
            let secondaryOffset = 0;
            const szNumber = (isArray_default(symbolSize) ? symbolSize[1] : symbolSize) / 2;
            isVerticalPosition ? (b.x1 < 0 ? secondaryOffset = -b.x1 : b.x2 > stageBounds.x2 && (secondaryOffset = stageBounds.x2 - b.x2), group.setAttribute("x", group.attribute.x + secondaryOffset), bgSymbol.setAttribute("dx", min(max(bgSymbol.attribute.dx - secondaryOffset, szNumber), b.width() - szNumber))) : isHorizontalPosition2 && (b.y1 < 0 ? secondaryOffset = -b.y1 : b.y2 > stageBounds.y2 && (secondaryOffset = stageBounds.y2 - b.y2), group.setAttribute("y", group.attribute.y + secondaryOffset), bgSymbol.setAttribute("dy", min(max(bgSymbol.attribute.dy - secondaryOffset, szNumber), b.height() - szNumber)));
            break;
          }
        }
        if (!layout2) break;
      }
    }
  }
  calculateAnchorPoint(position, positionBounds) {
    if (!positionBounds) return {
      x: 0,
      y: 0
    };
    const { x, y } = this.attribute, { x1, y1, x2, y2 } = positionBounds, width = x2 - x1, height = y2 - y1;
    switch (position) {
      case "top":
      case "tl":
      case "tr":
        return {
          x: x1 + width / 2 - x,
          y: y1 - y
        };
      case "bottom":
      case "bl":
      case "br":
        return {
          x: x1 + width / 2 - x,
          y: y2 - y
        };
      case "left":
      case "lt":
      case "lb":
        return {
          x: x1 - x,
          y: y1 + height / 2 - y
        };
      case "right":
      case "rt":
      case "rb":
        return {
          x: x2 - x,
          y: y1 + height / 2 - y
        };
      default:
        return {
          x: 0,
          y: 0
        };
    }
  }
  getAngleAndOffset(position, width, height, size, symbolType) {
    const sizeH = "arrow2Left" === symbolType ? size[1] / 2 : size[1];
    switch (position) {
      case "tl":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4, height + sizeH] : [0, height + sizeH]
        };
      case "top":
        return {
          angle: pi / 2 * 3,
          offset: [width / 2, height + sizeH]
        };
      case "tr":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4 * 3, height + sizeH] : [width, height + sizeH]
        };
      case "rt":
        return {
          angle: 0,
          offset: "arrow2Left" === symbolType ? [-sizeH, height / 5] : [-sizeH, 0]
        };
      case "right":
        return {
          angle: 0,
          offset: [-sizeH, height / 2]
        };
      case "rb":
        return {
          angle: 0,
          offset: "arrow2Left" === symbolType ? [-sizeH, height / 5 * 4] : [-sizeH, height]
        };
      case "bl":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4, -sizeH] : [0, -sizeH]
        };
      case "bottom":
        return {
          angle: pi / 2,
          offset: [width / 2, -sizeH]
        };
      case "br":
        return {
          angle: "arrow2Left" === symbolType ? pi / 2 : 0,
          offset: "arrow2Left" === symbolType ? [width / 4 * 3, -sizeH] : [width, -sizeH]
        };
      case "lt":
        return {
          angle: "arrow2Left" === symbolType ? pi : 0,
          offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5] : [width + sizeH, 0]
        };
      case "left":
        return {
          angle: pi,
          offset: [width + sizeH, height / 2]
        };
      case "lb":
        return {
          angle: "arrow2Left" === symbolType ? pi : 0,
          offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5 * 4] : [width + sizeH, height]
        };
    }
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig;
    if (this.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this.animate().to({
      scaleX: 1,
      scaleY: 1
    }, duration / 3 * 2, easing), this.titleShape && this.titleShape.animate().play(new InputText({
      text: ""
    }, {
      text: this.titleShape.attribute.text
    }, duration, easing)), this.contentShape && this.contentShape.animate().play(new InputText({
      text: ""
    }, {
      text: this.contentShape.attribute.text
    }, duration, easing)), animateConfig.wave) {
      const dur = duration / 6;
      this.group.animate().to({
        angle: animateConfig.wave
      }, dur, easing).to({
        angle: -animateConfig.wave
      }, 2 * dur, easing).to({
        angle: animateConfig.wave
      }, 2 * dur, easing).to({
        angle: 0
      }, dur, easing);
    }
  }
  disappearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig;
    this.animate().to({
      scaleX: 0,
      scaleY: 0
    }, duration, easing);
  }
};
PopTip.defaultAttributes = {
  position: "rt",
  visible: true,
  title: null,
  content: null,
  titleStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  contentStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  panel: {},
  maxWidthPercent: 0.8,
  space: 8,
  padding: 10
};

// node_modules/@visactor/vrender-components/es/poptip/contribution.js
var __decorate116 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
function wrapPoptip(target, source) {
  return merge(target, theme.poptip, source), target;
}
var PopTipRenderContribution = class {
  render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    if (1 === graphic._showPoptip) {
      const { visible, visibleCb } = graphic.attribute.poptip || {};
      if (false === visible || visibleCb && false === visibleCb(graphic)) return;
      const attribute = {};
      merge(attribute, PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {}), this.poptipComponent ? this.poptipComponent.initAttributes(attribute) : this.poptipComponent = new PopTip(attribute);
      let poptip2 = graphic.attribute.poptip || {};
      if ("text" === graphic.type && null == poptip2.title && null == poptip2.content) {
        const out = {};
        wrapPoptip(out, poptip2), poptip2 = out, poptip2.content = null !== (_a = poptip2.content) && void 0 !== _a ? _a : graphic.attribute.text;
      }
      const matrix = graphic.globalTransMatrix;
      this.poptipComponent.setAttributes(Object.assign(Object.assign({
        visibleAll: true,
        pickable: false,
        childrenPickable: false,
        poptipAnchor: "bounds"
      }, poptip2), {
        x: matrix.e,
        y: matrix.f,
        positionBounds: graphic.globalAABBBounds
      })), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      interactiveLayer && interactiveLayer.add(this.poptipComponent);
    } else 2 === graphic._showPoptip && (graphic._showPoptip = 0, this.poptipComponent && (this.poptipComponent.setAttributes({
      visibleAll: false
    }), null === (_b = this.poptipComponent.parent) || void 0 === _b || _b.removeChild(this.poptipComponent), this.poptipComponent = null));
  }
};
PopTipRenderContribution = __decorate116([injectable()], PopTipRenderContribution);

// node_modules/@visactor/vrender-components/es/poptip/poptip-plugin.js
var __decorate117 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var PopTipPluginBase = class {
  constructor() {
    this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.poptip = (e) => {
      const graphic = e.target;
      this.needHide(graphic) ? this.unpoptip(e) : graphic !== this.activeGraphic && (this.needShow(graphic) && (graphic.setAttributes({}), graphic._showPoptip = 1), this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2), this.setActiveGraphic(graphic, true));
    }, this.unpoptip = (e) => {
      this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2, this.setActiveGraphic(null, true));
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    stage.addEventListener("pointerover", this.poptip);
  }
  needHide(graphic) {
    return graphic.isContainer || !graphic.attribute;
  }
  needShow(graphic) {
    return !!graphic.attribute.poptip;
  }
  setActiveGraphic(graphic, rerender) {
    this.activeGraphic = graphic, this.pluginService.stage.renderNextFrame();
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("pointerover", this.poptip);
  }
};
var PopTipPlugin = class extends PopTipPluginBase {
  constructor() {
    super(...arguments), this.name = "poptip", this.key = this.name + this._uid;
  }
};
PopTipPlugin = __decorate117([injectable()], PopTipPlugin);
var PopTipForClipedTextPlugin = class extends PopTipPluginBase {
  constructor() {
    super(...arguments), this.name = "poptipForText", this.key = this.name + this._uid, this.pointerlave = (e) => {
      const { stage } = this.pluginService;
      e.target === stage && this.unpoptip(e);
    };
  }
  activate(context) {
    super.activate(context);
    const { stage } = this.pluginService;
    stage.addEventListener("pointerleave", this.pointerlave);
  }
  needHide(graphic) {
    return "text" !== graphic.type || !graphic.cliped || graphic.isContainer || !graphic.attribute || graphic.attribute.disableAutoClipedPoptip;
  }
  needShow(graphic) {
    return true;
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    super.deactivate(context), stage.removeEventListener("pointerleave", this.pointerlave);
  }
};
PopTipForClipedTextPlugin = __decorate117([injectable()], PopTipForClipedTextPlugin);

// node_modules/@visactor/vrender-components/es/poptip/module.js
var popTipModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(PopTipRenderContribution) || (bind(PopTipRenderContribution).toSelf().inSingletonScope(), bind(InteractiveSubRenderContribution).toService(PopTipRenderContribution)), isBound(PopTipPlugin) || (bind(PopTipPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipPlugin)), isBound(PopTipForClipedTextPlugin) || (bind(PopTipForClipedTextPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipForClipedTextPlugin));
});
function loadPoptip() {
  container.load(popTipModule);
}

// node_modules/@visactor/vrender-components/es/crosshair/base.js
var CrosshairBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "crosshair";
  }
  render() {
    this.renderCrosshair(this);
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/register.js
function loadLineCrosshairComponent() {
  registerGroup(), registerLine();
}
function loadCircleCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonCrosshairComponent() {
  registerGroup(), registerPath();
}
function loadRectCrosshairComponent() {
  registerGroup(), registerRect();
}
function loadSectorCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonSectorCrosshairComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vrender-components/es/crosshair/line.js
loadLineCrosshairComponent();
var LineCrosshair = class _LineCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-line", Object.assign({
      points: [start, end]
    }, lineStyle), "line");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
LineCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/rect.js
loadRectCrosshairComponent();
var RectCrosshair = class _RectCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _RectCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, rectStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-rect", Object.assign({
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    }, rectStyle), "rect");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
RectCrosshair.defaultAttributes = {
  rectStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/circle.js
loadCircleCrosshairComponent();
var CircleCrosshair = class _CircleCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-circle", Object.assign(Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius
    }), this.attribute), lineStyle), "arc");
  }
  setLocation(point6) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point6, center2);
    this.setAttribute("radius", radius);
  }
};
CircleCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: ["#b2bacf", false, false, false],
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/sector.js
loadSectorCrosshairComponent();
var SectorCrosshair = class _SectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, innerRadius = 0, sectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-sector", Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius,
      innerRadius,
      startAngle,
      endAngle
    }), sectorStyle), "arc");
  }
  setLocation(point6) {
    const { center: center2, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center2, point6));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
SectorCrosshair.defaultAttributes = {
  sectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/polygon.js
loadPolygonCrosshairComponent();
var PolygonCrosshair = class _PolygonCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, sides = 6, lineStyle } = this.attribute, { startAngle, endAngle } = this.attribute, isClose2 = (endAngle - startAngle) % (2 * Math.PI) == 0, eachAngle = (endAngle - startAngle) / sides;
    let path;
    for (let index = 0; index <= sides; index++) {
      const point6 = polarToCartesian(center2, radius, startAngle + eachAngle * index);
      0 === index ? path = `M${point6.x},${point6.y}` : path += `L${point6.x},${point6.y}`, index === sides && isClose2 && (path += "Z");
    }
    return container2.createOrUpdateChild("crosshair-polygon", Object.assign({
      path
    }, lineStyle), "path");
  }
  setLocation(point6) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point6, center2);
    this.setAttribute("radius", radius);
  }
};
PolygonCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/segment/register.js
function loadSegmentComponent() {
  registerGroup(), registerLine(), registerPolygon(), registerSymbol();
}
function loadArcSegmentComponent() {
  registerGroup(), registerLine(), registerArc(), registerSymbol();
}

// node_modules/@visactor/vrender-components/es/segment/segment.js
loadSegmentComponent();
var Segment = class _Segment extends AbstractComponent {
  getStartAngle() {
    return normalizeAngle(this._startAngle);
  }
  getEndAngle() {
    return normalizeAngle(this._endAngle);
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Segment.defaultAttributes, attributes)), this.name = "segment", this.key = "segment", this.lines = [];
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, multiSegment, mainSegmentIndex } = this.attribute;
    if (!visible) return;
    this._computeLineAngle();
    const points = this._getMainSegmentPoints(), startSymbolShape = this._renderSymbol(startSymbol, points, "start"), endSymbolShape = this._renderSymbol(endSymbol, points, "end");
    if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
      const points2 = [...this.attribute.points];
      if (isValidNumber_default(mainSegmentIndex)) points2[mainSegmentIndex] = this._clipPoints(points2[mainSegmentIndex]);
      else {
        const clipPoints = this._clipPoints(flattenArray(points2));
        points2[0][0] = clipPoints[0], points2[points2.length - 1][points2[points2.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
      }
      points2.forEach((point6, index) => {
        var _a, _b;
        const line2 = graphicCreator.line(Object.assign(Object.assign({
          points: point6
        }, isArray_default(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
          fill: false
        }));
        line2.name = `${this.name}-line`, line2.id = this._getNodeId("line" + index), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = isArray_default(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line2), this.lines.push(line2);
      });
    } else {
      let lineCreator = graphicCreator.line;
      array(lineStyle)[0].cornerRadius && (lineCreator = graphicCreator.polygon);
      const line2 = lineCreator(Object.assign(Object.assign({
        points: this._clipPoints(this.attribute.points)
      }, array(lineStyle)[0]), {
        fill: false,
        closePath: false
      }));
      line2.name = `${this.name}-line`, line2.id = this._getNodeId("line"), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = [].concat(state.line)[0]), this.add(line2), this.lines.push(line2);
    }
  }
  _computeStartRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _computeEndRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _renderSymbol(attribute, points, dim) {
    if (!points.length) return;
    const { autoRotate: autoRotate2 = true } = attribute;
    let symbol;
    if (attribute && attribute.visible) {
      const startAngle = this.getStartAngle(), endAngle = this.getEndAngle(), { state } = this.attribute, start = points[0], end = points[points.length - 1], { refX = 0, refY = 0, refAngle = 0, style, symbolType, size = 12 } = attribute;
      let position, rotate;
      "start" === dim ? (position = {
        x: start.x + (isValidNumber_default(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
        y: start.y + (isValidNumber_default(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
      }, rotate = this._computeStartRotate(this._startAngle)) : (position = {
        x: end.x + (isValidNumber_default(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
        y: end.y + (isValidNumber_default(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
      }, rotate = this._computeEndRotate(this._endAngle)), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
        symbolType,
        size,
        angle: autoRotate2 ? rotate + refAngle : 0,
        strokeBoundsBuffer: 0
      }), style)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty_default(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), "start" === dim ? isEmpty_default(null == state ? void 0 : state.startSymbol) || (symbol.states = state.startSymbol) : isEmpty_default(null == state ? void 0 : state.endSymbol) || (symbol.states = state.endSymbol), this.add(symbol);
    }
    return symbol;
  }
  _getMainSegmentPoints() {
    if (this._mainSegmentPoints) return this._mainSegmentPoints;
    const { points: originPoints, multiSegment, mainSegmentIndex } = this.attribute;
    let points;
    return points = multiSegment ? isValidNumber_default(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
  }
  _clipPoints(points) {
    const { startSymbol = {}, endSymbol = {} } = this.attribute;
    let pointsAfterClip = points;
    if (startSymbol.visible) {
      const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
      pointsAfterClip = [{
        x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
        y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
      }, ...pointsAfterClip.slice(1)];
    }
    if (endSymbol.visible) {
      const endSize = endSymbol.clip ? endSymbol.size || 10 : 0, pointsEnd = {
        x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
        y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
      };
      pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
    }
    return pointsAfterClip;
  }
  _computeLineAngle() {
    const points = this._getMainSegmentPoints();
    if (points.length <= 1) return;
    const start = points[0], startInside = points[1], endInside = points[points.length - 2], end = points[points.length - 1], startVector = [start.x - startInside.x, start.y - startInside.y], startAngle = Math.atan2(startVector[1], startVector[0]), endVector = [end.x - endInside.x, end.y - endInside.y], endAngle = Math.atan2(endVector[1], endVector[0]);
    this._startAngle = startAngle, this._endAngle = endAngle;
  }
  _reset() {
    this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
  }
};
Segment.defaultAttributes = {
  visible: true,
  lineStyle: {
    lineWidth: 1,
    stroke: "#000"
  },
  startSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  },
  endSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  }
};

// node_modules/@visactor/vrender-components/es/segment/arc-segment.js
loadArcSegmentComponent();
var ArcSegment = class extends Segment {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes)), this.name = "arc-segment", this.key = "arc-segment", this.isReverseArc = false;
  }
  getStartAngle() {
    const tangAng = this.isReverseArc ? this._startAngle + Math.PI / 2 : this._startAngle - Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getEndAngle() {
    const tangAng = this.isReverseArc ? this._endAngle - Math.PI / 2 : this._endAngle + Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  _computeStartRotate(angle2) {
    return this.isReverseArc ? angle2 + Math.PI : angle2;
  }
  _computeEndRotate(angle2) {
    return this.isReverseArc ? angle2 : angle2 + Math.PI;
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, radius, startAngle, endAngle, center: center2 } = this.attribute;
    if (!visible) return;
    this._startAngle = startAngle, this._endAngle = endAngle, this.isReverseArc = startAngle > endAngle;
    const startPoint = {
      x: center2.x + radius * Math.cos(this._startAngle),
      y: center2.y + radius * Math.sin(this._startAngle)
    }, endPoint = {
      x: center2.x + radius * Math.cos(this._endAngle),
      y: center2.y + radius * Math.sin(this._endAngle)
    };
    this._mainSegmentPoints = [startPoint, endPoint];
    const startSymbolShape = this._renderSymbol(startSymbol, this._mainSegmentPoints, "start"), endSymbolShape = this._renderSymbol(endSymbol, this._mainSegmentPoints, "end");
    this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape;
    const line2 = graphicCreator.arc(Object.assign({
      x: center2.x,
      y: center2.y,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    }, lineStyle));
    line2.name = `${this.name}-line`, line2.id = this._getNodeId("arc"), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = [].concat(state.line)[0]), this.add(line2), this.line = line2;
  }
};

// node_modules/@visactor/vrender-components/es/axis/constant.js
var AXIS_ELEMENT_NAME;
!function(AXIS_ELEMENT_NAME2) {
  AXIS_ELEMENT_NAME2.innerView = "inner-view", AXIS_ELEMENT_NAME2.axisContainer = "axis-container", AXIS_ELEMENT_NAME2.labelContainer = "axis-label-container", AXIS_ELEMENT_NAME2.tickContainer = "axis-tick-container", AXIS_ELEMENT_NAME2.tick = "axis-tick", AXIS_ELEMENT_NAME2.subTick = "axis-sub-tick", AXIS_ELEMENT_NAME2.label = "axis-label", AXIS_ELEMENT_NAME2.title = "axis-title", AXIS_ELEMENT_NAME2.gridContainer = "axis-grid-container", AXIS_ELEMENT_NAME2.grid = "axis-grid", AXIS_ELEMENT_NAME2.gridRegion = "axis-grid-region", AXIS_ELEMENT_NAME2.line = "axis-line", AXIS_ELEMENT_NAME2.background = "axis-background", AXIS_ELEMENT_NAME2.axisLabelBackground = "axis-label-background", AXIS_ELEMENT_NAME2.axisBreak = "axis-break", AXIS_ELEMENT_NAME2.axisBreakSymbol = "axis-break-symbol";
}(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
var AxisStateValue;
!function(AxisStateValue2) {
  AxisStateValue2.selected = "selected", AxisStateValue2.selectedReverse = "selected_reverse", AxisStateValue2.hover = "hover", AxisStateValue2.hoverReverse = "hover_reverse";
}(AxisStateValue || (AxisStateValue = {}));
var DEFAULT_STATES2 = {
  [AxisStateValue.selectedReverse]: {},
  [AxisStateValue.selected]: {},
  [AxisStateValue.hover]: {},
  [AxisStateValue.hoverReverse]: {}
};
var TopZIndex = 999;

// node_modules/@visactor/vrender-components/es/axis/config.js
var DEFAULT_AXIS_THEME = {
  title: {
    space: 4,
    padding: 0,
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    padding: 0,
    style: {
      fontSize: 12,
      fill: "#333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  }
};
var DEFAULT_AXIS_BREAK_SYMBOL_STYLE = {
  size: 8,
  stroke: "#000",
  lineWidth: 1,
  zIndex: 1
};

// node_modules/@visactor/vrender-components/es/axis/overlap/util.js
function genNormalBounds(item) {
  const bounds = item.AABBBounds;
  return {
    x1: bounds.x1,
    x2: bounds.x2,
    y1: bounds.y1,
    y2: bounds.y2,
    centerX: item.attribute.x,
    centerY: item.attribute.y,
    angle: item.attribute.angle
  };
}
function genRotateBounds(items) {
  items.forEach((item) => {
    if (item.rotatedBounds || !item.attribute.angle) return;
    const bounds = genNormalBounds(item), rotatedCenter = rotatePoint({
      x: item.attribute.x,
      y: item.attribute.y
    }, bounds.angle, {
      x: bounds.centerX,
      y: bounds.centerY
    }), deltaX = rotatedCenter.x - bounds.centerX, deltaY = rotatedCenter.y - bounds.centerY;
    bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
  });
}
function itemIntersect(item1, item2) {
  var _a, _b;
  return (null === (_a = item1.OBBBounds) || void 0 === _a ? void 0 : _a.empty()) || (null === (_b = item2.OBBBounds) || void 0 === _b ? void 0 : _b.empty()) ? isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) && (!item1.rotatedBounds || !item2.rotatedBounds || isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true)) : item1.OBBBounds.intersects(item2.OBBBounds);
}
var DELTA_ANGLE = Math.sin(Math.PI / 10);
function isAngleVertical(angle2, delta = DELTA_ANGLE) {
  const hasAngle = !isNil_default(angle2) && 0 !== angle2, cos2 = hasAngle ? Math.cos(angle2) : 1;
  return hasAngle && Math.abs(cos2) <= delta;
}
function isAngleHorizontal(angle2, delta = DELTA_ANGLE) {
  const hasAngle = !isNil_default(angle2) && 0 !== angle2, sin2 = hasAngle ? Math.sin(angle2) : 0;
  return !hasAngle || Math.abs(sin2) <= delta;
}

// node_modules/@visactor/vrender-components/es/axis/util.js
function getCircleLabelPosition(tickPosition, tickVector) {
  return {
    x: tickPosition.x + tickVector[0],
    y: tickPosition.y + tickVector[1]
  };
}
function getAxisBreakSymbolAttrs(props = {}) {
  var _a, _b;
  const { style = {}, angle: angle2 = 0.5 * Math.PI } = props, symbolStyle = merge({}, DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style), symbolSize = null !== (_a = symbolStyle.size) && void 0 !== _a ? _a : DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;
  return Object.assign(Object.assign({}, symbolStyle), {
    symbolType: null !== (_b = symbolStyle.symbolType) && void 0 !== _b ? _b : `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle2)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle2)}`,
    symbolSize
  });
}
function getElMap(g) {
  const elMap = {};
  return traverseGroup(g, (el) => {
    "group" !== el.type && el.id && (elMap[el.id] = el);
  }), elMap;
}
function getVerticalCoord(point6, vector) {
  return {
    x: point6.x + vector[0],
    y: point6.y + vector[1]
  };
}
function getCircleVerticalVector(offset, point6, center2, inside = false, axisInside = false) {
  const vector = [point6.x - center2.x, point6.y - center2.y];
  return scale3(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / length(vector));
}
function angleLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "left" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "right" : "center", baseline = angle2 >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "bottom" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "top" : "middle", {
    align,
    baseline
  };
}
function getPolarAngleLabelPosition(angle2, center2, radius, labelOffset, inside) {
  const point6 = polarToCartesian({
    x: 0,
    y: 0
  }, radius, angle2), labelPoint = getVerticalCoord(point6, getCircleVerticalVector(labelOffset, point6, center2, inside));
  return getCircleLabelPosition(labelPoint, getCircleVerticalVector(labelOffset || 1, labelPoint, center2, inside));
}
function getCirclePoints(center2, count, radius, startAngle, endAngle) {
  const points = [], range2 = endAngle - startAngle;
  for (let i = 0; i < count; i++) {
    const angle2 = startAngle + i * range2 / count;
    points.push(polarToCartesian(center2, radius, angle2));
  }
  return points;
}
function getPolygonPath(points, closed) {
  let path = "";
  return 0 === points.length || (points.forEach((point6, index) => {
    0 === index ? path = `M${point6.x},${point6.y}` : path += `L${point6.x},${point6.y}`;
  }), closed && (path += "Z")), path;
}
function textIntersect(textA, textB, sep) {
  var _a;
  const angle2 = null === (_a = textA.attribute) || void 0 === _a ? void 0 : _a.angle;
  if (isAngleHorizontal(angle2, Number.EPSILON)) return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);
  const a3 = textA.OBBBounds, b = textB.OBBBounds;
  return !a3 || !b || a3.empty() || b.empty() ? sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds) : a3.intersects(b) || sep > obbSeparation(a3, b);
}
function hasOverlap(items, pad) {
  for (let b, i = 1, n = items.length, a3 = items[0]; i < n; a3 = b, ++i) if (b = items[i], textIntersect(a3, b, pad)) return true;
  return false;
}

// node_modules/@visactor/vrender-components/es/util/interaction.js
var dispatchHoverState = (e, container2, lastHover) => {
  const target = e.target;
  return target !== lastHover && target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.hover, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.hoverReverse, true);
  }), target) : lastHover;
};
var dispatchUnHoverState = (e, container2, lastHover) => lastHover ? (traverseGroup(container2, (node) => {
  node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
}), null) : lastHover;
var dispatchClickState = (e, container2, lastSelect) => {
  const target = e.target;
  return lastSelect === target && target.hasState(StateValue.selected) ? (traverseGroup(container2, (node) => {
    node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
  }), null) : target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.selected, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.selectedReverse, true);
  }), target) : lastSelect;
};

// node_modules/@visactor/vrender-components/es/axis/base.js
var AxisBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis", this.data = [], this.tickLineItems = [], this.subTickLineItems = [], this.axisLabelLayerSize = {}, this.axisLabelsContainer = null, this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this.axisContainer, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this.axisContainer, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this.axisContainer, this._lastSelect);
    };
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  getBoundsWithoutRender(attributes) {
    const currentAttribute = cloneDeep(this.attribute);
    merge(this.attribute, attributes);
    const offscreenGroup = graphicCreator.group({
      x: this.attribute.x,
      y: this.attribute.y
    });
    return this.add(offscreenGroup), this._renderInner(offscreenGroup), this.removeChild(offscreenGroup), this.attribute = currentAttribute, offscreenGroup.AABBBounds;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView), this._renderInner(this._innerView), this._bindEvent();
  }
  _bindEvent() {
    if (this.attribute.disableTriggerEvent) return;
    const { hover, select } = this.attribute;
    hover && (this._innerView.addEventListener("pointermove", this._onHover), this._innerView.addEventListener("pointerout", this._onUnHover)), select && this._innerView.addEventListener("pointerdown", this._onClick);
  }
  _renderInner(container2) {
    const { title: title3, label, tick, line: line2, items } = this.attribute, axisContainer = graphicCreator.group({
      x: 0,
      y: 0,
      zIndex: 1,
      pickable: false
    });
    if (axisContainer.name = AXIS_ELEMENT_NAME.axisContainer, axisContainer.id = this._getNodeId("container"), axisContainer.setMode(this.mode), this.axisContainer = axisContainer, container2.add(axisContainer), line2 && line2.visible && this.renderLine(axisContainer), items && items.length && (this.data = this._transformItems(items[0]), tick && tick.visible && this.renderTicks(axisContainer), label && label.visible)) {
      const labelGroup = graphicCreator.group({
        x: 0,
        y: 0,
        pickable: false
      });
      labelGroup.name = AXIS_ELEMENT_NAME.labelContainer, labelGroup.id = this._getNodeId("label-container"), this.axisLabelsContainer = labelGroup, axisContainer.add(labelGroup), items.forEach((axisItems, layer) => {
        const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer), labels = layerLabelGroup.getChildren();
        this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
        let maxTextWidth = 0, maxTextHeight = 0, textAlign = "center", textBaseline = "middle", labelPos = 0;
        labels.forEach((label2, index) => {
          var _a;
          const labelStyle = label2.attribute, angle2 = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textBounds = label2.AABBBounds;
          let textWidth = textBounds.width(), textHeight = textBounds.height();
          angle2 && (textWidth = Math.abs(textWidth * Math.cos(angle2)), textHeight = Math.abs(textHeight * Math.sin(angle2))), maxTextWidth = Math.max(maxTextWidth, textWidth), maxTextHeight = Math.max(maxTextHeight, textHeight), textAlign = labelStyle.textAlign, textBaseline = labelStyle.textBaseline, 0 === index && (labelPos = labelStyle.x);
        }), this.axisLabelLayerSize[layer] = {
          width: maxTextWidth,
          height: maxTextHeight,
          labelPos,
          textAlign,
          textBaseline
        };
      });
    }
    title3 && title3.visible && this.renderTitle(axisContainer);
  }
  renderTicks(container2) {
    const tickLineItems = this.getTickLineItems(), tickLineGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer, tickLineGroup.id = this._getNodeId("tick-container"), container2.add(tickLineGroup), tickLineItems.forEach((item, index) => {
      var _a;
      const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("tick", item, index, tickLineItems)));
      if (line2.name = AXIS_ELEMENT_NAME.tick, line2.id = this._getNodeId(item.id), isEmpty_default(null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.state)) line2.states = DEFAULT_STATES;
      else {
        const data = this.data[index], tickLineState = merge({}, DEFAULT_STATES, this.attribute.tick.state);
        Object.keys(tickLineState).forEach((key) => {
          isFunction_default(tickLineState[key]) && (tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data));
        }), line2.states = tickLineState;
      }
      tickLineGroup.add(line2);
    }), this.tickLineItems = tickLineItems;
    const { subTick } = this.attribute;
    if (subTick && subTick.visible) {
      const subTickLineItems = this.getSubTickLineItems();
      subTickLineItems.length && subTickLineItems.forEach((item, index) => {
        const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("subTick", item, index, tickLineItems)));
        if (line2.name = AXIS_ELEMENT_NAME.subTick, line2.id = this._getNodeId(`${index}`), isEmpty_default(subTick.state)) line2.states = DEFAULT_STATES;
        else {
          const subTickLineState = merge({}, DEFAULT_STATES, subTick.state);
          Object.keys(subTickLineState).forEach((key) => {
            isFunction_default(subTickLineState[key]) && (subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems));
          }), line2.states = subTickLineState;
        }
        tickLineGroup.add(line2);
      }), this.subTickLineItems = subTickLineItems;
    }
  }
  renderLabels(container2, items, layer) {
    const { dataFilter } = this.attribute.label;
    dataFilter && isFunction_default(dataFilter) && (items = dataFilter(items, layer));
    const data = this._transformItems(items), labelGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    return labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`, labelGroup.id = this._getNodeId(`label-container-layer-${layer}`), container2.add(labelGroup), data.forEach((item, index) => {
      var _a;
      const labelStyle = this._getLabelAttribute(item, index, data, layer), text2 = createTextGraphicByType(labelStyle);
      if (text2.name = AXIS_ELEMENT_NAME.label, text2.id = this._getNodeId(`layer${layer}-label-${item.id}`), isEmpty_default(null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.state)) text2.states = DEFAULT_STATES;
      else {
        const labelState = merge({}, DEFAULT_STATES, this.attribute.label.state);
        Object.keys(labelState).forEach((key) => {
          isFunction_default(labelState[key]) && (labelState[key] = labelState[key](item, index, data, layer));
        }), text2.states = labelState;
      }
      text2.data = Object.assign(Object.assign({}, item), {
        index,
        layer
      }), labelGroup.add(text2);
    }), labelGroup;
  }
  renderTitle(container2) {
    const titleAttributes = this.getTitleAttribute(), axisTitle = new Tag(Object.assign({}, titleAttributes));
    axisTitle.name = AXIS_ELEMENT_NAME.title, axisTitle.id = this._getNodeId("title"), container2.add(axisTitle);
  }
  getVerticalCoord(point6, offset, inside) {
    return getVerticalCoord(point6, this.getVerticalVector(offset, inside, point6));
  }
  getTickLineItems() {
    const { tick } = this.attribute, data = this.data, tickLineItems = [], { alignWithLabel, inside = false, length: length2, dataFilter } = tick;
    let tickSegment = 1;
    return data.length >= 2 && (tickSegment = data[1].value - data[0].value), (dataFilter && isFunction_default(dataFilter) ? dataFilter(data) : data).forEach((item) => {
      let point6 = item.point, tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value)) return;
        point6 = this.getTickCoord(value), tickValue = value;
      }
      const endPoint = this.getVerticalCoord(point6, length2, inside);
      if ("3d" === this.mode) {
        const vec = this.getVerticalVector(length2, inside, point6);
        let alpha = 0, beta = 0;
        abs(vec[0]) > abs(vec[1]) ? alpha = pi / 2 * (endPoint.x > point6.x ? 1 : -1) : beta = pi / 2 * (endPoint.y > point6.y ? -1 : 1), tickLineItems.push({
          start: point6,
          end: endPoint,
          value: tickValue,
          id: `tick-${item.id}`,
          anchor: [point6.x, point6.y],
          alpha,
          beta
        });
      } else tickLineItems.push({
        start: point6,
        end: endPoint,
        value: tickValue,
        id: `tick-${item.id}`
      });
    }), tickLineItems;
  }
  getSubTickLineItems() {
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) for (let i = 0; i < tickLineCount - 1; i++) {
      const pre = tickLineItems[i], next = tickLineItems[i + 1];
      for (let j = 0; j < subCount; j++) {
        const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, inside);
        subTickLineItems.push({
          start: point6,
          end: endPoint,
          value,
          id: `sub-tick-${value}`
        });
      }
    }
    return subTickLineItems;
  }
  _getTickLineAttribute(type, tickItem, index, tickItems) {
    let style = get_default(this.attribute, `${type}.style`);
    const data = this.data[index];
    style = isFunction_default(style) ? merge({}, get_default(DEFAULT_AXIS_THEME, `${type}.style`), "tick" === type ? style(data.rawValue, index, data, this.data) : style(tickItem.value, index, tickItem, tickItems)) : style;
    const { start, end, anchor, alpha, beta } = tickItem;
    return Object.assign({
      points: [start, end],
      anchor,
      alpha,
      beta
    }, style);
  }
  _getLabelAttribute(tickDatum, index, tickData, layer) {
    var _a, _b;
    const { space = 4, inside = false, formatMethod, type = "text", text: text2 } = this.attribute.label;
    let offset = space, tickLength = 0;
    (null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.visible) && this.attribute.tick.inside === inside && (tickLength = this.attribute.tick.length || 4), (null === (_b = this.attribute.subTick) || void 0 === _b ? void 0 : _b.visible) && this.attribute.subTick.inside === inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2)), offset += tickLength;
    const axisVector = this.getRelativeVector(tickDatum.point);
    layer > 0 && (0 === axisVector[1] ? offset += (this.axisLabelLayerSize[layer - 1].height + get_default(this.attribute, "label.space", 4)) * layer : offset += (this.axisLabelLayerSize[layer - 1].width + get_default(this.attribute, "label.space", 4)) * layer);
    const point6 = this.getVerticalCoord(tickDatum.point, offset, inside), vector = this.getVerticalVector(offset || 1, inside, point6), textContent = formatMethod ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer) : tickDatum.label;
    let { style: textStyle } = this.attribute.label;
    textStyle = isFunction_default(textStyle) ? merge({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer)) : textStyle;
    const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
    return textStyle = merge(labelAlign, textStyle), isFunction_default(textStyle.text) && (textStyle.text = textStyle.text({
      label: tickDatum.label,
      value: tickDatum.rawValue,
      index: tickDatum.index,
      layer
    })), Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point6, vector, textContent, textStyle)), {
      text: null != text2 ? text2 : textContent,
      _originText: tickDatum.label,
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize,
      type
    }), textStyle);
  }
  getLabelPosition(point6, vector, text2, style) {
    return point6;
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-hide.js
var methods = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 ? item.setAttribute("opacity", 0) : 1);
  },
  greedy: function(items, sep) {
    let a3;
    return items.filter((b, i) => i && textIntersect(a3, b, sep) ? b.setAttribute("opacity", 0) : (a3 = b, 1));
  }
};
function hasBounds(item) {
  let bounds;
  return bounds = item.OBBBounds.empty() ? item.AABBBounds : item.OBBBounds, bounds.width() > 1 && bounds.height() > 1;
}
function reset(items) {
  return items.forEach((item) => item.setAttribute("opacity", 1)), items;
}
function forceItemVisible(sourceItem, items, check, comparator, inverse = false) {
  if (check && !sourceItem.attribute.opacity) {
    const remainLength = items.length;
    if (remainLength > 1) {
      sourceItem.setAttribute("opacity", 1);
      for (let i = 0; i < remainLength; i++) {
        const item = inverse ? items[remainLength - 1 - i] : items[i];
        if (!comparator(item)) break;
        item.setAttribute("opacity", 0);
      }
    }
  }
}
function autoHide(labels, config2) {
  if (isEmpty_default(labels)) return;
  const source = labels.filter(hasBounds);
  if (isEmpty_default(source)) return;
  let items;
  items = reset(source);
  const { method = "parity", separation: sep = 0 } = config2, reduce = isFunction_default(method) ? method : methods[method] || methods.parity;
  if (items.length >= 3 && hasOverlap(items, sep)) {
    do {
      items = reduce(items, sep);
    } while (items.length >= 3 && hasOverlap(items, sep));
    const shouldCheck = (length2, visibility, checkLength = true) => checkLength && length2 < 3 || visibility, checkFirst = shouldCheck(items.length, config2.firstVisible, false);
    let checkLast = shouldCheck(items.length, config2.lastVisible);
    const firstSourceItem = source[0], lastSourceItem = last(source);
    textIntersect(firstSourceItem, lastSourceItem, sep) && checkFirst && checkLast && (lastSourceItem.setAttribute("opacity", 0), checkLast = false), forceItemVisible(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, sep)), forceItemVisible(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, sep) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, sep), true);
  }
  source.forEach((item) => {
    item.setAttribute("visible", !!item.attribute.opacity);
  });
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-rotate.js
function autoRotate(items, rotateConfig) {
  if (isEmpty_default(items)) return;
  const { orient, labelRotateAngle = [0, 45, 90] } = rotateConfig;
  if (0 === labelRotateAngle.length || items.some((item) => !!item.attribute.angle)) return;
  let i = 0, n = 0;
  for (labelRotateAngle && labelRotateAngle.length > 0 && (n = labelRotateAngle.length); i < n; ) {
    const angle2 = labelRotateAngle[i++];
    if (items.forEach((item) => {
      item.attribute.angle = degreeToRadian(angle2);
    }), tryRotate(orient, items), !hasIntersect(items)) break;
  }
}
function hasIntersect(items) {
  for (let i = 1; i < items.length; i++) if (itemIntersect(items[i - 1], items[i])) return true;
  return false;
}
function tryRotate(orient, items) {
  "bottom" !== orient && "top" !== orient || rotateXAxis(orient, items), "left" !== orient && "right" !== orient || rotateYAxis(orient, items), genRotateBounds(items);
}
function clampAngle(angle2 = 0) {
  if (angle2 < 0) for (; angle2 < 0; ) angle2 += 2 * Math.PI;
  if (angle2 > 0) for (; angle2 >= 2 * Math.PI; ) angle2 -= 2 * Math.PI;
  return angle2;
}
function rotateYAxis(orient, items) {
  items.forEach((item, i) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function rotateXAxis(orient, items) {
  items.forEach((item) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function getXAxisLabelAlign(orient, angle2 = 0) {
  let align = ["center", "left", "left", "left", "center", "right", "right", "right", "left"], baseline = ["top", "top", "middle", "bottom", "bottom", "bottom", "middle", "top", "top"];
  "top" === orient && (align = ["center", "right", "right", "right", "center", "left", "left", "left", "right"], baseline = ["bottom", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}
function getYAxisLabelAlign(orient, angle2 = 0) {
  let align = ["right", "right", "center", "left", "left", "left", "center", "right", "right"], baseline = ["middle", "middle", "top", "top", "middle", "middle", "bottom", "bottom", "middle"];
  "right" === orient && (align = ["left", "left", "center", "right", "right", "right", "center", "left", "left"], baseline = ["middle", "middle", "bottom", "bottom", "middle", "middle", "top", "middle", "middle"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-limit.js
function normalizeOverflowLimitLength(overflowLimitLength) {
  return isValidNumber_default(overflowLimitLength) ? {
    left: overflowLimitLength,
    right: overflowLimitLength
  } : isObject_default(overflowLimitLength) ? {
    left: overflowLimitLength.left || 0,
    right: overflowLimitLength.right || 0
  } : {
    left: 0,
    right: 0
  };
}
function autoLimit(labels, config2) {
  const { limitLength, verticalLimitLength, ellipsis = "...", orient, axisLength } = config2;
  if (isEmpty_default(labels) || !isValidNumber_default(limitLength)) return;
  const overflowLimitLength = normalizeOverflowLimitLength(config2.overflowLimitLength), firstLabel = labels[0], angle2 = firstLabel.attribute.angle, hasAngle = !isNil_default(angle2), cos2 = hasAngle ? Math.cos(angle2) : 1, sin2 = hasAngle ? Math.sin(angle2) : 0, isHorizontal4 = isAngleHorizontal(angle2), isVertical3 = isAngleVertical(angle2), isX = "top" === orient || "bottom" === orient, direction = firstLabel.attribute.direction, checkBox = !isHorizontal4 && !isVertical3 && isX && (labels.length < 2 || labels.some((label) => Math.abs(label.AABBBounds.width() - firstLabel.AABBBounds.width()) >= 2)) && firstLabel.AABBBounds.width() > Math.abs(limitLength / sin2);
  labels.forEach((label) => {
    var _a;
    if (isX) {
      if (isVertical3 && Math.floor(label.AABBBounds.height()) <= limitLength) return;
      if (isHorizontal4 && Math.floor(label.AABBBounds.width()) <= verticalLimitLength) return;
    }
    if (!isX) {
      if ("vertical" === direction && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
      if ("vertical" !== direction) {
        if (isHorizontal4 && Math.floor(label.AABBBounds.width()) <= limitLength) return;
        if (isVertical3 && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
      }
    }
    let limitLabelLength = null;
    if (isHorizontal4 || isVertical3) limitLabelLength = isX ? isHorizontal4 ? verticalLimitLength : limitLength : "vertical" === direction || isVertical3 ? verticalLimitLength : limitLength;
    else if (isX) {
      const { x1, x2 } = label.AABBBounds, tan = sin2 / cos2, verticalSizeLimit = Math.abs(limitLength / sin2);
      if (checkBox && tan > 0 && x1 <= axisLength + overflowLimitLength.right && limitLength / tan + x1 > axisLength + overflowLimitLength.right) {
        const lengthLimit = (axisLength - x1 + overflowLimitLength.right) / Math.abs(cos2);
        limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
      } else if (checkBox && tan < 0 && x2 >= -overflowLimitLength.left && limitLength / tan + x2 < -overflowLimitLength.left) {
        const lengthLimit = (x2 + overflowLimitLength.left) / Math.abs(cos2);
        limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
      } else limitLabelLength = verticalSizeLimit;
    } else limitLabelLength = Math.abs(limitLength / cos2);
    isValidNumber_default(label.attribute.maxLineWidth) && (limitLabelLength = isValidNumber_default(limitLabelLength) ? Math.min(label.attribute.maxLineWidth, limitLabelLength) : label.attribute.maxLineWidth), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
    });
  });
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-wrap.js
function autoWrap(labels, config2) {
  const { limitLength, axisLength, ellipsis = "...", orient } = config2;
  if (isEmpty_default(labels) || !isValidNumber_default(limitLength)) return;
  const angle2 = labels[0].attribute.angle, isHorizontal4 = isAngleHorizontal(angle2), isVertical3 = isAngleVertical(angle2), isX = "top" === orient || "bottom" === orient;
  let verticalLimitLength = axisLength / labels.length;
  labels.forEach((label, index) => {
    var _a, _b, _c, _d, _e;
    if (isX) {
      if (isVertical3 && Math.floor(label.AABBBounds.height()) <= limitLength) return;
      if (isHorizontal4) {
        const minGap = getLabelMinGap(label.attribute.x, null === (_a = labels[index + 1]) || void 0 === _a ? void 0 : _a.attribute.x, null === (_b = labels[index - 1]) || void 0 === _b ? void 0 : _b.attribute.x);
        isValidNumber_default(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
      }
    } else {
      if (isVertical3) {
        const minGap = getLabelMinGap(label.attribute.y, null === (_c = labels[index + 1]) || void 0 === _c ? void 0 : _c.attribute.y, null === (_d = labels[index - 1]) || void 0 === _d ? void 0 : _d.attribute.y);
        isValidNumber_default(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
      }
      if (isHorizontal4 && Math.floor(label.AABBBounds.width()) <= limitLength) return;
    }
    let limitLabelLength = null, heightLimit = null;
    isX ? isVertical3 ? (limitLabelLength = limitLength, heightLimit = verticalLimitLength) : (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : isVertical3 ? (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : (limitLabelLength = limitLength, heightLimit = verticalLimitLength), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: null !== (_e = label.attribute.ellipsis) && void 0 !== _e ? _e : ellipsis,
      whiteSpace: "normal",
      heightLimit
    });
  });
}
function getLabelMinGap(current, next, prev) {
  let minGap;
  return isValidNumber_default(next) && (minGap = Math.abs(next - current)), isValidNumber_default(prev) && (minGap = isValidNumber_default(minGap) ? Math.min(Math.abs(current - prev), minGap) : Math.abs(current - prev)), minGap;
}

// node_modules/@visactor/vrender-components/es/util/align.js
function alignAxisLabels(labels, start, containerSize, orient, align) {
  "left" === orient || "right" === orient ? "left" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.x1
    });
  }) : "right" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.x2
    });
  }) : "center" === align && labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.x1 + label.AABBBounds.x2) / 2
    });
  }) : "bottom" !== orient && "top" !== orient || ("top" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.y1
    });
  }) : "bottom" === align ? labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.y2
    });
  }) : "middle" === align && labels.forEach((label) => {
    var _a;
    label.setAttributes({
      dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.y1 + label.AABBBounds.y2) / 2
    });
  }));
}

// node_modules/@visactor/vrender-components/es/axis/mixin/line.js
var LineAxisMixin = class {
  isInValidValue(value) {
    return value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { start } = this.attribute, axisVector = this.getRelativeVector();
    return {
      x: start.x + axisVector[0] * tickValue,
      y: start.y + axisVector[1] * tickValue
    };
  }
  getRelativeVector(point6) {
    const { start, end } = this.attribute;
    return [end.x - start.x, end.y - start.y];
  }
  getVerticalVector(offset, inside = false, point6) {
    const { verticalFactor = 1 } = this.attribute, axisVector = this.getRelativeVector(), normalizedAxisVector = normalize(axisVector), verticalVector = [normalizedAxisVector[1], -1 * normalizedAxisVector[0]];
    return scale3(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
  }
};

// node_modules/@visactor/vrender-components/es/axis/register.js
function loadBasicAxis() {
  registerGroup(), registerLine(), registerRichtext(), registerText();
}
function loadLineAxisComponent() {
  loadBasicAxis(), registerRect();
}
function loadCircleAxisComponent() {
  loadBasicAxis(), registerCircle();
}
function loadLineAxisGridComponent() {
  registerGroup(), registerPath();
}
function loadCircleAxisGridComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vrender-components/es/axis/line.js
var __rest3 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadLineAxisComponent();
var LineAxis = class _LineAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineAxis.defaultAttributes, attributes), options);
  }
  _renderInner(container2) {
    var _a;
    if (this._breaks = null, this.attribute.breaks && this.attribute.breaks.length) {
      const transformedBreaks = [];
      for (let index = 0; index < this.attribute.breaks.length; index++) {
        const aBreak = this.attribute.breaks[index], { range: range2, breakSymbol, rawRange } = aBreak;
        transformedBreaks.push({
          startPoint: this.getTickCoord(range2[0]),
          endPoint: this.getTickCoord(range2[1]),
          range: range2,
          breakSymbol,
          rawRange
        });
      }
      this._breaks = transformedBreaks;
    }
    super._renderInner(container2), this._breaks && this._breaks.length && this._breaks.forEach((b, index) => {
      const { startPoint, endPoint, breakSymbol, rawRange } = b;
      if (false !== (null == breakSymbol ? void 0 : breakSymbol.visible)) {
        const axisBreakGroup = graphicCreator.group({
          zIndex: TopZIndex
        });
        axisBreakGroup.name = AXIS_ELEMENT_NAME.axisBreak, axisBreakGroup.id = this._getNodeId(`${AXIS_ELEMENT_NAME.axisBreak}-${index}`), axisBreakGroup.data = rawRange;
        const symbolStyle = getAxisBreakSymbolAttrs(breakSymbol), shape1 = graphicCreator.symbol(Object.assign({
          x: startPoint.x,
          y: startPoint.y
        }, symbolStyle));
        shape1.name = AXIS_ELEMENT_NAME.axisBreakSymbol;
        const shape2 = graphicCreator.symbol(Object.assign({
          x: endPoint.x,
          y: endPoint.y
        }, symbolStyle));
        shape2.name = AXIS_ELEMENT_NAME.axisBreakSymbol, axisBreakGroup.add(shape1), axisBreakGroup.add(shape2), container2.add(axisBreakGroup);
      }
    });
    const { panel } = this.attribute;
    if (panel && panel.visible) {
      const axisContainer = this.axisContainer, axisContainerBounds = axisContainer.AABBBounds, bgRect = graphicCreator.rect(Object.assign({
        x: axisContainerBounds.x1,
        y: axisContainerBounds.y1,
        width: axisContainerBounds.width(),
        height: axisContainerBounds.height()
      }, panel.style));
      bgRect.name = AXIS_ELEMENT_NAME.background, bgRect.id = this._getNodeId("background"), bgRect.states = merge({}, DEFAULT_STATES2, null !== (_a = panel.state) && void 0 !== _a ? _a : {}), axisContainer.insertBefore(bgRect, axisContainer.firstChild);
    }
  }
  renderLine(container2) {
    const { start, end, line: line2 } = this.attribute, _a = line2, { startSymbol, endSymbol, style, state } = _a, restLineAttrs = __rest3(_a, ["startSymbol", "endSymbol", "style", "state"]), lineAttrs = Object.assign({
      startSymbol,
      endSymbol,
      lineStyle: style
    }, restLineAttrs);
    if (this._breaks && this._breaks.length) {
      const linePoints = [];
      let lastStartPoint = start;
      this._breaks.forEach((b) => {
        const { startPoint, endPoint } = b;
        linePoints.push([lastStartPoint, startPoint]), lastStartPoint = endPoint;
      }), linePoints.push([lastStartPoint, end]), lineAttrs.points = linePoints, lineAttrs.multiSegment = true;
    } else lineAttrs.points = [start, end];
    isEmpty_default(state) || (lineAttrs.state = {
      line: merge({}, DEFAULT_STATES2, state),
      symbol: merge({}, DEFAULT_STATES2, state)
    });
    const axisLineGroup = new Segment(lineAttrs);
    axisLineGroup.name = AXIS_ELEMENT_NAME.line, axisLineGroup.id = this._getNodeId("line"), container2.add(axisLineGroup);
  }
  getTextAlign(vector) {
    let align = "center";
    return isNumberClose(vector[0], 0) ? isNumberClose(vector[1], 0) ? Object.is(vector[1], -0) ? align = "start" : Object.is(vector[0], -0) && (align = "end") : align = "center" : vector[0] > 0 ? align = "start" : vector[0] < 0 && (align = "end"), align;
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const _d = this.attribute.title, { position = "middle", space = 4, textStyle = {}, autoRotate: autoRotate2 = true, shape, background, state = {}, maxWidth } = _d, restAttrs = __rest3(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state", "maxWidth"]);
    let percent = 0.5;
    "start" === position ? percent = 0 : "end" === position && (percent = 1);
    const { verticalFactor = 1 } = this.attribute, factor = -1 * verticalFactor, point6 = this.getTickCoord(percent), axisVector = this.getRelativeVector();
    let labelLength = 0;
    if ((null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside) {
      const space2 = +get_default(this.attribute, "label.space", 4);
      labelLength += space2;
      const layerCount = Object.keys(this.axisLabelLayerSize).length;
      if (0 === axisVector[1]) {
        const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
        isFinite(labelBoundsHeight) ? labelLength += labelBoundsHeight + (layerCount - 1) * space2 : labelLength = 0;
      } else if (0 === axisVector[0]) if (this.axisLabelsContainer && this.axisLabelsContainer.AABBBounds && !this.axisLabelsContainer.AABBBounds.empty()) {
        const baseX = this.axisLabelLayerSize[0].labelPos, bounds = this.axisLabelsContainer.AABBBounds;
        labelLength += (1 === factor ? bounds.x2 > baseX ? Math.min(bounds.x2 - baseX, bounds.width()) : 0 : bounds.x1 < baseX ? Math.min(baseX - bounds.x1, bounds.width()) : 0) + (layerCount - 1) * space2;
      } else labelLength = 0;
      else Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
        labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space2 : 0);
      });
    }
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = tickLength + labelLength + space, titlePoint = this.getVerticalCoord(point6, offset, false), vector = this.getVerticalVector(offset, false, {
      x: 0,
      y: 0
    });
    let textAlign, textBaseline, { angle: angle2 } = restAttrs;
    if (textAlign = "start" === position ? "start" : "end" === position ? "end" : "center", isNil_default(angle2) && autoRotate2) {
      angle2 = angleTo(axisVector, [1, 0], true);
      const { verticalFactor: verticalFactor2 = 1 } = this.attribute;
      textBaseline = 1 === -1 * verticalFactor2 ? "bottom" : "top";
    } else textAlign = this.getTextAlign(vector), textBaseline = this.getTextBaseline(vector, false);
    let maxTagWidth = maxWidth;
    if (isNil_default(maxTagWidth)) {
      const { verticalLimitSize, verticalMinSize, orient } = this.attribute, limitSize = Math.min(verticalLimitSize || 1 / 0, verticalMinSize || 1 / 0);
      if (isValidNumber_default(limitSize)) {
        if ("bottom" === orient || "top" === orient) if (angle2 !== Math.PI / 2) {
          const cosValue = Math.abs(Math.cos(null != angle2 ? angle2 : 0));
          maxTagWidth = cosValue < 1e-6 ? 1 / 0 : this.attribute.end.x / cosValue;
        } else maxTagWidth = limitSize - offset;
        else if (angle2 && 0 !== angle2) {
          const sinValue = Math.abs(Math.sin(angle2));
          maxTagWidth = sinValue < 1e-6 ? 1 / 0 : this.attribute.end.y / sinValue;
        } else maxTagWidth = limitSize - offset;
      }
    }
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      maxWidth: maxTagWidth,
      textStyle: Object.assign({
        textAlign,
        textBaseline
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    });
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getTextBaseline(vector, inside) {
    let base = "middle";
    const { verticalFactor = 1 } = this.attribute, factor = (inside ? 1 : -1) * verticalFactor;
    return isNumberClose(vector[1], 0) ? base = !isNumberClose(vector[0], 0) || Object.is(vector[0], -0) || Object.is(vector[1], -0) ? "middle" : 1 === factor ? "bottom" : "top" : vector[1] > 0 ? base = "top" : vector[1] < 0 && (base = "bottom"), base;
  }
  getLabelAlign(vector, inside, angle2) {
    const orient = this.attribute.orient;
    if (["top", "bottom", "right", "left"].includes(orient) || 0 === vector[0] && 0 === vector[1]) {
      if ("top" === orient || "bottom" === orient) return getXAxisLabelAlign(inside ? "bottom" === orient ? "top" : "bottom" : orient, angle2);
      if ("left" === orient || "right" === orient) return getYAxisLabelAlign(inside ? "left" === orient ? "right" : "left" : orient, angle2);
    }
    return {
      textAlign: this.getTextAlign(vector),
      textBaseline: this.getTextBaseline(vector, inside)
    };
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    var _a, _b, _c, _d;
    const { flush = false } = this.attribute.label || {};
    if (flush && labelShapes.length) {
      const { orient, start: axisStart, end: axisEnd } = this.attribute, isX = "bottom" === orient || "top" === orient, first = labelShapes[0], last2 = last(labelShapes), isInverse = isX ? first.attribute.x > last2.attribute.x : first.attribute.y < last2.attribute.y;
      if (isX) {
        const leftMostLabel = isInverse ? last2 : first, rightMostLabel = isInverse ? first : last2, left2 = axisStart.x, right2 = axisEnd.x, leftBound = leftMostLabel.AABBBounds.x1, rightBound = rightMostLabel.AABBBounds.x2;
        if (leftBound < left2) {
          leftMostLabel.attribute.angle ? leftMostLabel.setAttributes({
            dx: (null !== (_a = leftMostLabel.attribute.dx) && void 0 !== _a ? _a : 0) + left2 - leftBound
          }) : leftMostLabel.setAttributes({
            x: left2,
            textAlign: "left"
          });
        }
        if (rightBound > right2) {
          rightMostLabel.attribute.angle ? rightMostLabel.setAttributes({
            dx: (null !== (_b = rightMostLabel.attribute.dx) && void 0 !== _b ? _b : 0) + right2 - rightBound
          }) : rightMostLabel.setAttributes({
            x: right2,
            textAlign: "right"
          });
        }
      } else {
        const bottomMostLabel = isInverse ? last2 : first, topMostLabel = isInverse ? first : last2, bottomBound = bottomMostLabel.AABBBounds.y2, topBound = topMostLabel.AABBBounds.y1, top = axisStart.y, bottom = axisEnd.y;
        if (topBound < top) {
          topMostLabel.attribute.angle ? topMostLabel.setAttributes({
            dy: (null !== (_c = topMostLabel.attribute.dy) && void 0 !== _c ? _c : 0) + top - topBound
          }) : topMostLabel.setAttributes({
            y: top,
            textBaseline: "top"
          });
        }
        if (bottomBound > bottom) {
          bottomMostLabel.attribute.angle ? bottomMostLabel.setAttributes({
            dy: (null !== (_d = bottomMostLabel.attribute.dy) && void 0 !== _d ? _d : 0) + bottom - bottomBound
          }) : bottomMostLabel.setAttributes({
            y: bottom,
            textBaseline: "bottom"
          });
        }
      }
    }
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes)) return;
    const { verticalLimitSize, label, orient } = this.attribute, limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount), { layoutFunc, autoRotate: autoRotate2, autoRotateAngle, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, lastVisible, firstVisible, autoWrap: autoWrap2, overflowLimitLength } = label;
    if (isFunction_default(layoutFunc)) layoutFunc(labelShapes, labelData, layer, this);
    else {
      if (autoRotate2) autoRotate(labelShapes, {
        labelRotateAngle: autoRotateAngle,
        orient
      });
      else if (autoWrap2) {
        const axisLength = "left" === orient || "right" === orient ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x);
        autoWrap(labelShapes, {
          orient,
          limitLength,
          axisLength,
          ellipsis: limitEllipsis
        });
      }
      if (!autoWrap2 && autoLimit2 && isValidNumber_default(limitLength) && limitLength > 0) {
        const isVertical3 = "left" === orient || "right" === orient, axisLength = isVertical3 ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x), verticalLimitLength = isVertical3 ? axisLength / labelShapes.length : autoHide2 || autoRotate2 ? 1 / 0 : axisLength / labelShapes.length;
        autoLimit(labelShapes, {
          limitLength,
          verticalLimitLength,
          ellipsis: limitEllipsis,
          orient,
          axisLength,
          overflowLimitLength
        });
      }
      autoHide2 && autoHide(labelShapes, {
        orient,
        method: autoHideMethod,
        separation: autoHideSeparation,
        lastVisible,
        firstVisible
      });
    }
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    const { verticalLimitSize, orient } = this.attribute, isHorizontal4 = "bottom" === orient || "top" === orient, axisLabelContainerBounds = labelContainer.AABBBounds;
    let axisLabelContainerSize = isHorizontal4 ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
    const { verticalMinSize } = this.attribute;
    if (isValidNumber_default(verticalMinSize) && (!isValidNumber_default(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
      const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
      let x, y;
      axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize), "left" === orient ? (x = axisLabelContainerBounds.x2 - axisLabelContainerSize, y = axisLabelContainerBounds.y1) : "right" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1) : "top" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y2 - axisLabelContainerSize) : "bottom" === orient && (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1);
      const bgRect = graphicCreator.rect({
        x,
        y,
        width: isHorizontal4 ? axisLabelContainerBounds.width() : axisLabelContainerSize,
        height: isHorizontal4 ? axisLabelContainerSize : axisLabelContainerBounds.height(),
        pickable: false
      });
      bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground, bgRect.id = this._getNodeId("axis-label-background"), labelContainer.insertBefore(bgRect, labelContainer.firstChild);
    }
    if (isValid_default(this.attribute.label.containerAlign)) {
      let start;
      "left" === orient ? start = axisLabelContainerBounds.x2 - axisLabelContainerSize : "right" === orient ? start = axisLabelContainerBounds.x1 : "top" === orient ? start = axisLabelContainerBounds.y2 - axisLabelContainerSize : "bottom" === orient && (start = axisLabelContainerBounds.y1), alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
    }
  }
  _getAxisLabelLimitLength(limitSize, layerCount) {
    var _a, _b, _c, _d, _e;
    const { label, title: title3, line: line2, tick } = this.attribute, labelSpace = null !== (_a = label.space) && void 0 !== _a ? _a : 4;
    let limitLength = limitSize, titleHeight = 0, titleSpacing = 0;
    const axisLineWidth = line2 && line2.visible ? null !== (_b = line2.style.lineWidth) && void 0 !== _b ? _b : 1 : 0, tickLength = tick && tick.visible ? null !== (_c = tick.length) && void 0 !== _c ? _c : 4 : 0;
    if (title3 && title3.visible && "string" == typeof title3.text) {
      titleHeight = measureTextSize(title3.text, title3.textStyle, null === (_e = null === (_d = this.stage) || void 0 === _d ? void 0 : _d.getTheme()) || void 0 === _e ? void 0 : _e.text).height;
      const padding = normalizePadding(title3.padding);
      titleSpacing = title3.space + padding[0] + padding[2];
    }
    return limitLength && (limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount), limitLength;
  }
  release() {
    super.release(), this._breaks = null;
  }
};
LineAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(LineAxis, LineAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/mixin/circle.js
var CircleAxisMixin = class {
  isInValidValue(value) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
    return Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? value > 1 : value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center: center2, radius, inside = false, innerRadius = 0 } = this.attribute;
    return polarToCartesian(center2, inside && innerRadius > 0 ? innerRadius : radius, startAngle + (endAngle - startAngle) * tickValue);
  }
  getVerticalVector(offset, inside = false, point6) {
    return getCircleVerticalVector(offset, point6, this.attribute.center, inside, this.attribute.inside);
  }
  getRelativeVector(point6) {
    const { center: center2 } = this.attribute;
    return [point6.y - center2.y, -1 * (point6.x - center2.x)];
  }
};

// node_modules/@visactor/vrender-components/es/axis/overlap/circle-auto-limit.js
function findSiblingLabels(labels, selfIndex) {
  const len = labels.length;
  return {
    prevLabel: selfIndex >= 1 ? labels[selfIndex - 1] : labels[len - 1],
    nextLabel: selfIndex < len - 1 ? labels[selfIndex + 1] : labels[0]
  };
}
function adjustMaxLineWidth(label, maxLineWidth, ellipsis) {
  var _a;
  label.setAttributes({
    maxLineWidth,
    ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
  });
}
function adjustMaxHeight(labels, selfIndex, bounds) {
  const siblings = [];
  if (labels.length >= 3) {
    const { prevLabel, nextLabel } = findSiblingLabels(labels, selfIndex);
    siblings.push(prevLabel, nextLabel);
  } else 2 === labels.length && siblings.push(labels[0 === selfIndex ? 1 : 0]);
  const label = labels[selfIndex];
  let heightLimit = Math.min(Math.abs(label.attribute.y - bounds.y1), Math.abs(label.attribute.y - bounds.y2));
  siblings.forEach((sibling) => {
    heightLimit = Math.min(heightLimit, Math.abs(sibling.attribute.y - label.attribute.y));
  }), heightLimit > 0 && label.setAttributes({
    whiteSpace: "normal",
    heightLimit
  });
}
function circleAutoLimit(labels, config2) {
  const { ellipsis, inside, bounds, autoWrap: autoWrap2, center: center2 } = config2;
  inside || labels.forEach((label, index) => {
    const { x, y } = label.attribute, b = label.AABBBounds;
    if (isNumberClose(x, center2.x)) {
      if (y > bounds.y2 || y < bounds.y1) return void adjustMaxLineWidth(label, 0, ellipsis);
      const boxWidth = bounds.x2 - bounds.x1;
      if (labels.length >= 3) {
        const { prevLabel, nextLabel } = findSiblingLabels(labels, index);
        let leftX = prevLabel.attribute.x, rightX = nextLabel.attribute.x;
        leftX > rightX && (leftX = nextLabel.attribute.x, rightX = prevLabel.attribute.x);
        const maxWidth = leftX === rightX ? boxWidth : x >= leftX && x <= rightX ? rightX - leftX : Math.min(Math.abs(leftX - x), Math.abs(rightX - x));
        label.AABBBounds.width() > maxWidth && adjustMaxLineWidth(label, maxWidth, ellipsis);
      } else label.AABBBounds.width() > boxWidth && adjustMaxLineWidth(label, boxWidth, ellipsis);
    } else x > center2.x && b.x2 > bounds.x2 ? (adjustMaxLineWidth(label, bounds.x2 - x, ellipsis), autoWrap2 && adjustMaxHeight(labels, index, bounds)) : x < center2.x && b.x1 < bounds.x1 && (adjustMaxLineWidth(label, x - bounds.x1, ellipsis), autoWrap2 && adjustMaxHeight(labels, index, bounds));
  });
}

// node_modules/@visactor/vrender-components/es/axis/circle.js
var __rest4 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisComponent();
var CircleAxis = class _CircleAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleAxis.defaultAttributes, attributes));
  }
  renderLine(container2) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, radius, center: center2, innerRadius = 0, line: line2 = {}, inside = false, sides } = this.attribute;
    let lineGraphic, arcRadius = radius, arcInnerRadius = innerRadius;
    if (inside && innerRadius > 0 && (arcRadius = innerRadius, arcInnerRadius = 0), isValidNumber_default(sides) && sides >= 3) {
      const gridPoints = getCirclePoints(center2, sides, arcRadius, startAngle, endAngle);
      lineGraphic = graphicCreator.path(Object.assign(Object.assign({}, line2.style), {
        path: getPolygonPath(gridPoints, true)
      }));
    } else {
      const arcAttrs = Object.assign(Object.assign(Object.assign({}, center2), {
        startAngle,
        endAngle,
        radius: arcRadius,
        innerRadius: arcInnerRadius
      }), line2.style);
      lineGraphic = graphicCreator.circle(arcAttrs);
    }
    lineGraphic.name = AXIS_ELEMENT_NAME.line, lineGraphic.id = this._getNodeId("line"), isEmpty_default(line2.state) || (lineGraphic.states = merge({}, DEFAULT_STATES2, line2.state)), container2.add(lineGraphic);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const { center: center2, radius, innerRadius = 0 } = this.attribute, _d = this.attribute.title, { space = 4, textStyle = {}, shape, background, state = {} } = _d, restAttrs = __rest4(_d, ["space", "textStyle", "shape", "background", "state"]);
    let titlePoint = center2, labelHeight = 0;
    (null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside && (labelHeight = get_default(this.attribute.label, "style.fontSize", 12) + get_default(this.attribute.label, "space", 4));
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = radius + tickLength + labelHeight + space;
    let textBaseline = "middle", { position } = this.attribute.title;
    isNil_default(position) && (position = 0 === innerRadius ? "end" : "middle"), "start" === position ? (textBaseline = "bottom", titlePoint = {
      x: center2.x,
      y: center2.y - offset
    }) : "end" === position && (textBaseline = "top", titlePoint = {
      x: center2.x,
      y: center2.y + offset
    });
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      textStyle: Object.assign({
        textBaseline,
        textAlign: "center"
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    }), { angle: angle2 } = restAttrs;
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getSubTickLineItems() {
    var _a, _b;
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      const tickSegment = this.data[1].value - this.data[0].value, isAlignWithLable = null === (_b = null === (_a = this.attribute) || void 0 === _a ? void 0 : _a.tick) || void 0 === _b ? void 0 : _b.alignWithLabel;
      for (let i = 0; i < tickLineCount; i++) {
        const pre = tickLineItems[i], next = tickLineItems[i + 1];
        for (let j = 0; j < subCount; j++) {
          const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : isAlignWithLable ? 1 : pre.value + tickSegment), point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, inside);
          subTickLineItems.push({
            start: point6,
            end: endPoint,
            value
          });
        }
      }
    }
    return subTickLineItems;
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes)) return;
    const { inside, radius, center: center2, size, label, orient } = this.attribute, bounds = size ? {
      x1: 0,
      y1: 0,
      x2: size.width,
      y2: size.height
    } : {
      x1: center2.x - radius,
      y1: center2.y - radius,
      x2: center2.x + radius,
      y2: center2.y + radius
    }, { layoutFunc, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, autoWrap: autoWrap2 } = label;
    isFunction_default(layoutFunc) ? layoutFunc(labelShapes, labelData, layer, this) : ((autoLimit2 || autoWrap2) && circleAutoLimit(labelShapes, {
      inside,
      autoWrap: autoWrap2,
      bounds,
      ellipsis: limitEllipsis,
      center: center2
    }), autoHide2 && autoHide(labelShapes, {
      orient,
      method: autoHideMethod,
      separation: autoHideSeparation
    }));
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  getTextBaseline(vector) {
    return Math.abs(vector[1] / vector[0]) < 0.3 ? "middle" : vector[1] < 0 ? "bottom" : vector[1] > 0 ? "top" : "middle";
  }
  getLabelAlign(vector, inside, angle2) {
    return isNumberClose(vector[0], 0) ? {
      textAlign: "center",
      textBaseline: vector[1] > 0 ? "top" : "bottom"
    } : vector[0] < 0 ? {
      textAlign: "right",
      textBaseline: this.getTextBaseline(vector)
    } : vector[0] > 0 ? {
      textAlign: "left",
      textBaseline: this.getTextBaseline(vector)
    } : {
      textAlign: "center",
      textBaseline: "middle"
    };
  }
  getLabelPosition(point6, vector, text2, style) {
    return point6;
  }
};
CircleAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(CircleAxis, CircleAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/animate/group-transition.js
var GroupTransition = class extends ACustomAnimate {
  constructor() {
    super(...arguments), this.mode = AnimateMode.NORMAL;
  }
  onBind() {
    const currentInnerView = this.target.getInnerView(), prevInnerView = this.target.getPrevInnerView();
    prevInnerView && (this._newElementAttrMap = {}, traverseGroup(currentInnerView, (el) => {
      var _a, _b, _c, _d, _e, _f;
      if ("group" !== el.type && el.id) {
        const oldEl = prevInnerView[el.id];
        if (oldEl) {
          if (!isEqual(el.attribute, oldEl.attribute)) {
            const newProps = cloneDeep(el.attribute);
            this._newElementAttrMap[el.id] = {
              state: "update",
              node: el,
              attrs: Object.assign(Object.assign({}, newProps), {
                opacity: null !== (_a = newProps.opacity) && void 0 !== _a ? _a : 1,
                fillOpacity: null !== (_b = newProps.fillOpacity) && void 0 !== _b ? _b : 1,
                strokeOpacity: null !== (_c = newProps.strokeOpacity) && void 0 !== _c ? _c : 1
              })
            }, el.setAttributes(oldEl.attribute);
          }
        } else {
          const finalOpacityAttrs = {
            opacity: null !== (_d = el.attribute.opacity) && void 0 !== _d ? _d : 1,
            fillOpacity: null !== (_e = el.attribute.fillOpacity) && void 0 !== _e ? _e : 1,
            strokeOpacity: null !== (_f = el.attribute.strokeOpacity) && void 0 !== _f ? _f : 1
          };
          this._newElementAttrMap[el.id] = {
            state: "enter",
            node: el,
            attrs: finalOpacityAttrs
          }, el.setAttributes({
            opacity: 0,
            fillOpacity: 0,
            strokeOpacity: 0
          });
        }
      }
    }));
  }
  onStart() {
    let duration = this.duration, easing = this.easing;
    this._newElementAttrMap && Object.keys(this._newElementAttrMap).forEach((id) => {
      var _a;
      const { node, attrs, state } = this._newElementAttrMap[id];
      if ("enter" === state) {
        const { enter = {} } = null !== (_a = this.params) && void 0 !== _a ? _a : {};
        duration = isValidNumber_default(enter.duration) ? enter.duration : duration, easing = enter.easing ? enter.easing : easing;
      }
      "path" === node.type ? node.animate({
        interpolate: (key, ratio, from, to, nextAttributes) => "path" === key && (nextAttributes.path = interpolateString(from, to)(ratio), true)
      }).to(attrs, duration, easing) : node.animate().to(attrs, duration, easing);
    });
  }
  onUpdate(end, ratio, out) {
  }
};

// node_modules/@visactor/vrender-components/es/axis/tick-data/util.js
var convertDomainToTickData = (domain) => domain.map((t, index) => ({
  index,
  value: t
}));
var labelOverlap = (prevLabel, nextLabel, gap = 0) => {
  const prevBounds = new AABBBounds(prevLabel).expand(gap / 2), nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
  return prevBounds.intersects(nextBounds);
};
var MIN_TICK_GAP = 12;
var calculateFlushPos = (basePosition, size, rangePosition, otherEnd) => rangePosition < basePosition ? Math.max(basePosition - size / 2, rangePosition) : rangePosition > basePosition ? Math.min(basePosition - size / 2, rangePosition - size) : rangePosition < otherEnd ? rangePosition : rangePosition - size;
var getCartesianLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, axisOrientType, labelFlush, labelFormatter, startAngle = 0 } = op;
  let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
  "vertical" === labelStyle.direction && (labelAngle += degreeToRadian(90));
  const isHorizontal4 = ["bottom", "top"].includes(axisOrientType), isVertical3 = ["left", "right"].includes(axisOrientType);
  let scaleX = 1, scaleY = 0;
  isHorizontal4 || (isVertical3 ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), scaleY = -Math.sin(startAngle)));
  const textMeasure = initTextMeasure(labelStyle), range2 = scale4.range(), labelBoundsList = domain.map((v, i) => {
    var _a2, _b;
    const str = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), pos = scale4.scale(v), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
    let align, baseline, textX = baseTextX, textY = baseTextY;
    labelFlush && isHorizontal4 && 0 === i ? textX = calculateFlushPos(baseTextX, textWidth, range2[0], range2[range2.length - 1]) : labelFlush && isHorizontal4 && i === domain.length - 1 ? textX = calculateFlushPos(baseTextX, textWidth, range2[range2.length - 1], range2[0]) : align = null !== (_a2 = labelStyle.textAlign) && void 0 !== _a2 ? _a2 : "center", "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), labelFlush && isVertical3 && 0 === i ? textY = calculateFlushPos(baseTextY, textHeight, range2[0], range2[range2.length - 1]) : labelFlush && isVertical3 && i === domain.length - 1 ? textY = calculateFlushPos(baseTextY, textHeight, range2[range2.length - 1], range2[0]) : baseline = null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
    const bounds = new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight);
    return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
  });
  return labelBoundsList;
};
var isAxisHorizontal = (axisOrientType) => ["bottom", "top", "z"].includes(axisOrientType);

// node_modules/@visactor/vscale/es/type.js
var ScaleEnum;
!function(ScaleEnum2) {
  ScaleEnum2.Identity = "identity", ScaleEnum2.Linear = "linear", ScaleEnum2.Log = "log", ScaleEnum2.Pow = "pow", ScaleEnum2.Sqrt = "sqrt", ScaleEnum2.Symlog = "symlog", ScaleEnum2.Time = "time", ScaleEnum2.Quantile = "quantile", ScaleEnum2.Quantize = "quantize", ScaleEnum2.Threshold = "threshold", ScaleEnum2.Ordinal = "ordinal", ScaleEnum2.Point = "point", ScaleEnum2.Band = "band";
}(ScaleEnum || (ScaleEnum = {}));
var EnableScaleMap = {};
Object.values(ScaleEnum).forEach((v) => {
  EnableScaleMap[v] = true;
});
function isContinuous(type) {
  switch (type) {
    case ScaleEnum.Linear:
    case ScaleEnum.Log:
    case ScaleEnum.Pow:
    case ScaleEnum.Sqrt:
    case ScaleEnum.Symlog:
    case ScaleEnum.Time:
      return true;
    default:
      return false;
  }
}
function isValidScaleType(type) {
  return !!EnableScaleMap[type];
}
function isDiscrete(type) {
  switch (type) {
    case ScaleEnum.Ordinal:
    case ScaleEnum.Point:
    case ScaleEnum.Band:
      return true;
    default:
      return false;
  }
}

// node_modules/@visactor/vscale/es/utils/utils.js
function identity2(x) {
  return x;
}
var sqrt2 = (x) => x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
var square3 = (x) => x < 0 ? -x * x : x * x;
var logNegative = (x) => -Math.log(-x);
var expNegative = (x) => -Math.exp(-x);
var pow10 = (x) => isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
var powp = (base) => 10 === base ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
var logp = (base) => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), (x) => Math.log(x) / base);
var symlog = (c3) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c3));
var symexp = (c3) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c3;
function normalize2(a3, b) {
  if (a3 = Number(a3), b = Number(b), b -= a3) return (x) => (x - a3) / b;
  const result2 = Number.isNaN(b) ? NaN : 0.5;
  return () => result2;
}
function bimap(domain, range2, interpolate2) {
  const d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  let d0Fuc, r0Fuc;
  return d1 < d0 ? (d0Fuc = normalize2(d1, d0), r0Fuc = interpolate2(r1, r0)) : (d0Fuc = normalize2(d0, d1), r0Fuc = interpolate2(r0, r1)), (x) => r0Fuc(d0Fuc(x));
}
function bandSpace(count, paddingInner, paddingOuter) {
  let space;
  return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
}
function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
  1 === paddingInner && (paddingInner = 0);
  return bandSpace(count, paddingInner, paddingOuter) * (bandwidth / (1 - paddingInner));
}
function calculateBandwidthFromWholeRangeSize(count, wholeSize, paddingInner, paddingOuter, round) {
  const space = bandSpace(count, paddingInner, paddingOuter);
  let step = wholeSize / Math.max(1, space || 1);
  round && (step = Math.floor(step));
  let bandwidth = step * (1 - paddingInner);
  return round && (bandwidth = Math.round(bandwidth)), bandwidth;
}
function calculateWholeRangeFromRangeFactor(range2, rangeFactor) {
  const k2 = (range2[1] - range2[0]) / (rangeFactor[1] - rangeFactor[0]), b = range2[0] - k2 * rangeFactor[0];
  return [b, k2 + b];
}
function polymap(domain, range2, interpolate2) {
  const j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j);
  let i = -1;
  for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range2 = range2.slice().reverse()); ++i < j; ) d[i] = normalize2(domain[i], domain[i + 1]), r[i] = interpolate2(range2[i], range2[i + 1]);
  return function(x) {
    const i2 = bisect(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
var nice = (domain, options) => {
  const newDomain = domain.slice();
  let startIndex = 0, endIndex = newDomain.length - 1, x0 = newDomain[startIndex], x1 = newDomain[endIndex];
  return x1 < x0 && ([startIndex, endIndex] = [endIndex, startIndex], [x0, x1] = [x1, x0]), newDomain[startIndex] = options.floor(x0), newDomain[endIndex] = options.ceil(x1), newDomain;
};
var niceNumber = (value, round = false) => {
  const exponent = Math.floor(Math.log10(value)), fraction = value / Math.pow(10, exponent);
  let niceFraction;
  return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent);
};
var restrictNumber = (value, domain) => {
  let min3, max3;
  return domain[0] < domain[1] ? (min3 = domain[0], max3 = domain[1]) : (min3 = domain[1], max3 = domain[0]), Math.min(Math.max(value, min3), max3);
};

// node_modules/@visactor/vscale/es/base-scale.js
var BaseScale = class {
  constructor() {
    this._rangeFactorStart = null, this._rangeFactorEnd = null;
  }
  _calculateWholeRange(range2) {
    return this._wholeRange ? this._wholeRange : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range2;
  }
  rangeFactor(_, slience, clear) {
    return _ ? (2 === _.length && _.every((r) => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
  }
  rangeFactorStart(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  rangeFactorEnd(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  generateFishEyeTransform() {
    var _a;
    if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
    const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions, range2 = this.range(), first = range2[0], last2 = range2[range2.length - 1], min3 = Math.min(first, last2), max3 = Math.max(first, last2), focus = clamp_default(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min3, max3), rangeRadius = isNil_default(radius) ? (max3 - min3) * radiusRatio : radius;
    let k0 = Math.exp(distortion);
    k0 = k0 / (k0 - 1) * rangeRadius;
    const k1 = distortion / rangeRadius;
    this._fishEyeTransform = (output) => {
      const delta = Math.abs(output - focus);
      if (delta >= rangeRadius) return output;
      if (delta <= 1e-6) return focus;
      const k2 = k0 * (1 - Math.exp(-delta * k1)) / delta * 0.75 + 0.25;
      return focus + (output - focus) * k2;
    };
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
  get(key, defaultValue) {
    var _a;
    return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
  }
};

// node_modules/@visactor/vscale/es/ordinal-scale.js
var implicit = Symbol("implicit");
var OrdinalScale = class _OrdinalScale extends BaseScale {
  specified(_) {
    var _a;
    return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), this) : Object.assign({}, this._specified);
  }
  _getSpecifiedValue(input) {
    if (this._specified) return this._specified[input];
  }
  constructor() {
    super(), this.type = ScaleEnum.Ordinal, this._index = /* @__PURE__ */ new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit;
  }
  clone() {
    const s2 = new _OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
    return this._specified && s2.specified(this._specified), s2;
  }
  calculateVisibleDomain(range2) {
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return this._domain;
  }
  scale(d) {
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit) return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(d) {
    let i = 0;
    for (; i < this._ordinalRange.length && this._ordinalRange[i] !== d; ) i++;
    return this._domain[(i - 1) % this._domain.length];
  }
  domain(_) {
    if (!_) return this._domain.slice();
    this._domain = [], this._index = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = `${value}`;
      this._index.has(key) || this._index.set(key, this._domain.push(value));
    }
    return this;
  }
  range(_) {
    if (!_) return this._ordinalRange.slice();
    const nextRange = Array.from(_);
    return this._ordinalRange = nextRange, this;
  }
  index(x) {
    var _a;
    return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
  }
};

// node_modules/@visactor/vscale/es/utils/tick-sample-int.js
function generateTicks(start, stop, step, reverse) {
  const ticks4 = [];
  let ptr = start;
  for (; ptr <= stop; ) ticks4.push(ptr), ptr += step;
  return reverse && ticks4.reverse(), ticks4;
}
function ticks(start, stop, count, allowExcessive) {
  let reverse, step;
  if (stop = Math.floor(+stop), start = Math.floor(+start), !(count = Math.floor(+count))) return [];
  if (start === stop) return [start];
  if (reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  let expectedCount = clamper(1, stop - start + 1)(count);
  if (step = Math.floor((stop - start + 1) / expectedCount), !allowExcessive) for (; Math.ceil((stop - start + 1) / step) > count && expectedCount > 1; ) expectedCount -= 1, step = Math.floor((stop - start) / expectedCount);
  return generateTicks(start, stop, step, reverse);
}
function stepTicks(start, stop, step) {
  let reverse;
  if (stop = Math.floor(+stop), start = Math.floor(+start), step = clamper(1, stop - start + 1)(Math.floor(+step)), reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  return generateTicks(start, stop, step, reverse);
}

// node_modules/@visactor/vscale/es/band-scale.js
var BandScale = class _BandScale extends OrdinalScale {
  constructor(slience) {
    super(), this.type = ScaleEnum.Band, this._range = [0, 1], this._step = void 0, this._bandwidth = void 0, this._isFixed = false, this._round = false, this._paddingInner = 0, this._paddingOuter = 0, this._align = 0.5, this._unknown = void 0, delete this.unknown, this.rescale(slience);
  }
  rescale(slience, changeProperty) {
    if (slience) return this;
    this._wholeRange = null;
    const wholeRange = this._calculateWholeRange(this._range, changeProperty), n = super.domain().length, reverse = wholeRange[1] < wholeRange[0];
    let start = wholeRange[Number(reverse) - 0];
    const stop = wholeRange[1 - Number(reverse)], space = bandSpace(n, this._paddingInner, this._paddingOuter);
    return this._step = (stop - start) / Math.max(1, space || 1), this._round && (this._step = Math.floor(this._step)), start += (stop - start - this._step * (n - this._paddingInner)) * this._align, this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)), this._round && (start = Math.round(start), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth))), this._bandRangeState = {
      reverse,
      start: reverse ? start + this._step * (n - 1) : start,
      count: n
    }, this.generateFishEyeTransform(), this;
  }
  scale(d) {
    if (!this._bandRangeState) return;
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit) return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const { count, start, reverse } = this._bandRangeState, output = start + (reverse ? -1 : 1) * ((i - 1) % count) * this._step;
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  _calculateWholeRange(range2, changeProperty) {
    if (this._wholeRange) return this._wholeRange;
    if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
      let wholeSize;
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
        const wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]);
        wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
      } else wholeSize = Math.abs(range2[1] - range2[0]);
      const autoBandwidth = calculateBandwidthFromWholeRangeSize(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
      autoBandwidth < this._minBandwidth ? (this._bandwidth = this._minBandwidth, this._isFixed = true) : autoBandwidth > this._maxBandwidth ? (this._bandwidth = this._maxBandwidth, this._isFixed = true) : (this._bandwidth = autoBandwidth, this._isFixed = false);
    }
    if (this.isBandwidthFixed()) {
      const wholeLength = scaleWholeRangeSize(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) * Math.sign(range2[1] - range2[0]), rangeFactorSize = Math.min((range2[1] - range2[0]) / wholeLength, 1);
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd)) {
        const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1, canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
        if ("rangeFactorStart" === changeProperty && canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : "rangeFactorEnd" === changeProperty && canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : range2[0] <= range2[1] ? canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : (this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize) : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : (this._rangeFactorStart = 1 - rangeFactorSize, this._rangeFactorEnd = 1), wholeLength > 0) {
          const r0 = range2[0] - wholeLength * this._rangeFactorStart, r1 = r0 + wholeLength;
          this._wholeRange = [r0, r1];
        } else {
          const r1 = range2[1] + wholeLength * (1 - this._rangeFactorEnd), r0 = r1 - wholeLength;
          this._wholeRange = [r0, r1];
        }
      } else this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize, this._wholeRange = [range2[0], range2[0] + wholeLength];
      return this._wholeRange;
    }
    return super._calculateWholeRange(range2);
  }
  calculateWholeRangeSize() {
    const wholeRange = this._calculateWholeRange(this._range);
    return Math.abs(wholeRange[1] - wholeRange[0]);
  }
  calculateVisibleDomain(range2) {
    const domain = this._domain;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && domain.length) {
      const d0 = this._getInvertIndex(range2[0]), d1 = this._getInvertIndex(range2[1]);
      return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
    }
    return domain;
  }
  domain(_, slience) {
    return _ ? (super.domain(_), this.rescale(slience)) : super.domain();
  }
  range(_, slience) {
    return _ ? (this._range = [toNumber(_[0]), toNumber(_[1])], this.rescale(slience)) : this._range;
  }
  rangeRound(_, slience) {
    return this._range = [toNumber(_[0]), toNumber(_[1])], this._round = true, this.rescale(slience);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    if (-1 === count) return d;
    return ticks(0, d.length - 1, count, false).map((i) => d[i]);
  }
  tickData(count = 10) {
    return this.ticks(count).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
    }));
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticks(0, d.length - 1, count, true).filter((i) => i < d.length).map((i) => d[i]);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks(0, d.length - 1, step).map((i) => d[i]);
  }
  _getInvertIndex(d) {
    let i = 0;
    const halfStep = this.step() / 2, halfBandwidth = this.bandwidth() / 2, len = this._domain.length, range2 = this.range(), reverse = range2[0] > range2[range2.length - 1];
    for (i = 0; i < len; i++) {
      const r = this.scale(this._domain[i]) + halfBandwidth;
      if (0 === i && (!reverse && !isGreater(d, r + halfStep) || reverse && !isLess(d, r - halfStep))) break;
      if (i === len - 1) break;
      if (!isLess(d, r - halfStep) && !isGreater(d, r + halfStep)) break;
    }
    return i >= 0 && i <= len - 1 ? i : len - 1;
  }
  invert(d) {
    return this._domain[this._getInvertIndex(d)];
  }
  padding(p, slience) {
    return void 0 !== p ? (this._paddingOuter = Math.max(0, Math.min(Array.isArray(p) ? Math.min.apply(null, p) : p)), this._paddingInner = this._paddingOuter, this.rescale(slience)) : this._paddingInner;
  }
  paddingInner(_, slience) {
    return void 0 !== _ ? (this._paddingInner = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingInner;
  }
  paddingOuter(_, slience) {
    return void 0 !== _ ? (this._paddingOuter = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingOuter;
  }
  step() {
    return this._step;
  }
  round(_, slience) {
    return void 0 !== _ ? (this._round = _, this.rescale(slience)) : this._round;
  }
  align(_, slience) {
    return void 0 !== _ ? (this._align = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._align;
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this.rescale(slience)) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this.rescale(slience, "rangeFactorStart"));
  }
  rangeFactorEnd(_, slience) {
    return isNil_default(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this.rescale(slience, "rangeFactorEnd"));
  }
  bandwidth(_, slience) {
    return _ ? ("auto" === _ ? (this._bandwidth = void 0, this._isFixed = false) : (this._bandwidth = _, this._isFixed = true), this._userBandwidth = _, this.rescale(slience)) : this._bandwidth;
  }
  maxBandwidth(_, slience) {
    return _ ? (this._maxBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._maxBandwidth;
  }
  minBandwidth(_, slience) {
    return _ ? (this._minBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._minBandwidth;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  isBandwidthFixed() {
    return this._isFixed && !!this._bandwidth;
  }
  _isBandwidthFixedByUser() {
    return this._isFixed && this._userBandwidth && isNumber_default(this._userBandwidth);
  }
  clone() {
    var _a, _b, _c;
    return new _BandScale(true).domain(this._domain, true).range(this._range, true).round(this._round, true).paddingInner(this._paddingInner, true).paddingOuter(this._paddingOuter, true).align(this._align, true).bandwidth(null !== (_a = this._userBandwidth) && void 0 !== _a ? _a : "auto", true).maxBandwidth(null !== (_b = this._maxBandwidth) && void 0 !== _b ? _b : "auto", true).minBandwidth(null !== (_c = this._maxBandwidth) && void 0 !== _c ? _c : "auto");
  }
};

// node_modules/@visactor/vscale/es/utils/interpolate.js
var { interpolateRgb } = color_exports;
function interpolate(a3, b) {
  const t = typeof b;
  let c3;
  if (isNil_default(b) || "boolean" === t) return () => b;
  if ("number" === t) return interpolateNumber(a3, b);
  if ("string" === t) {
    if (c3 = color_exports.Color.parseColorString(b)) {
      const rgb = interpolateRgb(color_exports.Color.parseColorString(a3), c3);
      return (t2) => rgb(t2).formatRgb();
    }
    return interpolateNumber(Number(a3), Number(b));
  }
  return b instanceof color_exports.RGB ? interpolateRgb(a3, b) : b instanceof color_exports.Color ? interpolateRgb(a3.color, b.color) : b instanceof Date ? interpolateDate(a3, b) : interpolateNumber(Number(a3), Number(b));
}

// node_modules/@visactor/vscale/es/continuous-scale.js
var ContinuousScale = class extends BaseScale {
  constructor(transformer = identity2, untransformer = identity2) {
    super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = true, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity2, this._piecewise = bimap, this._interpolate = interpolate;
  }
  calculateVisibleDomain(range2) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._clamp(x)));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(y) {
    var _a;
    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y)));
  }
  domain(_, slience) {
    var _a;
    if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
    const nextDomain = Array.from(_, toNumber);
    return this._domain = nextDomain, this.rescale(slience);
  }
  range(_, slience) {
    if (!_) return this._range.slice();
    const nextRange = Array.from(_);
    return this._range = nextRange, this.rescale(slience);
  }
  rangeRound(_, slience) {
    const nextRange = Array.from(_);
    return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
    let n = Math.min(domainLength, rangeLength);
    if (domainLength && domainLength < rangeLength && this._forceAlign) {
      const deltaStep = rangeLength - domainLength + 1, last2 = domain[domainLength - 1], delta = domainLength >= 2 ? (last2 - domain[domainLength - 2]) / deltaStep : 0;
      for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last2 - delta * (deltaStep - i);
      n = rangeLength;
    }
    return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
  }
  clamp(_, f, slience) {
    return arguments.length ? (f ? (this._autoClamp = false, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity2), this.rescale(slience)) : this._clamp !== identity2;
  }
  interpolate(_, slience) {
    return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
  }
  ticks(count = 10) {
    return [];
  }
  tickData(count = 10) {
    const ticks4 = this.ticks(count);
    return (null != ticks4 ? ticks4 : []).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
    }));
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
  }
  rangeFactorEnd(_, slience) {
    return isNil_default(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
  }
  forceAlignDomainRange(forceAlign) {
    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
  }
};

// node_modules/@visactor/vscale/es/utils/tick-sample.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var niceNumbers = [1, 2, 5, 10];
var calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
  let step = 1, start = value;
  const middleIndex = Math.floor((tickCount - 1) / 2), absVal = Math.abs(value);
  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map((index) => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
};
var d3Ticks = memoize((start, stop, count, options) => {
  let reverse, n, ticks4, step, i = -1;
  if (count = +count, (start = +start) === (stop = +stop)) return [start];
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
  if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks4[i] = (r0 + i) * step;
  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
    step = 1;
    const r0 = Math.ceil(start), r1 = Math.floor(stop);
    if (!(r0 <= r1)) return [];
    for (ticks4 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks4[i] = r0 + i;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks4[i] = (r0 + i) / step;
  }
  return reverse && ticks4.reverse(), ticks4;
});
var calculateTicksByStep = (start, stop, step) => {
  let n, ticks4, i = -1;
  if (step > 0) {
    let r0 = Math.floor(start / step), r1 = Math.ceil(stop / step);
    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks4[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.floor(start * step), r1 = Math.ceil(stop * step);
    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; ) ticks4[i] = (r0 + i) / step;
  }
  return ticks4;
};
var appendTicksToCount = (ticks4, count, step) => {
  let n;
  const firstTick = ticks4[0], lastTick = ticks4[ticks4.length - 1], appendCount = count - ticks4.length;
  if (lastTick <= 0) {
    const headTicks2 = [];
    for (n = appendCount; n >= 1; n--) headTicks2.push(firstTick - n * step);
    return headTicks2.concat(ticks4);
  }
  if (firstTick >= 0) {
    for (n = 1; n <= appendCount; n++) ticks4.push(lastTick + n * step);
    return ticks4;
  }
  let headTicks = [];
  const tailTicks = [];
  for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
  return headTicks.concat(ticks4).concat(tailTicks);
};
var ticks2 = memoize((start, stop, count, options) => {
  let reverse, ticks4, n;
  if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  (reverse = stop < start) && (n = start, start = stop, stop = n);
  const stepRes = tickIncrement(start, stop, count);
  let step = stepRes.step;
  if (!isFinite(step)) return [];
  if (step > 0) {
    let cur = 1;
    const { power, gap } = stepRes, delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
    for (; cur <= 5 && (ticks4 = calculateTicksByStep(start, stop, step), ticks4.length > count + 1) && count > 2; ) step += delatStep, cur += 1;
    count > 2 && ticks4.length < count - 1 && (ticks4 = appendTicksToCount(ticks4, count, step));
  } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks4 = calculateTicksByStep(start, stop, step);
  return reverse && ticks4.reverse(), ticks4;
});
var getNickStep = (step) => {
  const power = Math.floor(Math.log(step) / Math.LN10), error3 = step / 10 ** power;
  let gap = niceNumbers[0];
  return error3 >= e10 ? gap = niceNumbers[3] : error3 >= e5 ? gap = niceNumbers[2] : error3 >= e2 && (gap = niceNumbers[1]), power >= 0 ? {
    step: gap * 10 ** power,
    gap,
    power
  } : {
    step: -(10 ** -power) / gap,
    gap,
    power
  };
};
function tickIncrement(start, stop, count) {
  const step = (stop - start) / Math.max(0, count);
  return getNickStep(step);
}
function forceTicks(start, stop, count) {
  let step;
  if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
  if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
  const ticks4 = new Array(count);
  for (let i = 0; i < count; i++) ticks4[i] = start + i * step;
  return ticks4;
}
function forceTickIncrement(start, stop, count) {
  return (stop - start) / Math.max(1, count - 1);
}
function stepTicks2(start, stop, step) {
  let n, reverse, i = -1;
  if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
  const count = Math.floor((stop - start) / step + 1), ticks4 = new Array(count);
  for (; ++i < count; ) ticks4[i] = start + i * step;
  return reverse && ticks4.reverse(), ticks4;
}
function niceLinear(d, count = 10) {
  let prestep, step, i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], maxIter = 10;
  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0; ) {
    if (step = tickIncrement(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
    if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;
    else {
      if (!(step < 0)) break;
      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function parseNiceOptions(originalDomain, option) {
  const hasForceMin = isNumber_default(option.forceMin), hasForceMax = isNumber_default(option.forceMax);
  let niceType = null;
  const niceMinMax = [];
  let niceDomain = null;
  const domainValidator = hasForceMin && hasForceMax ? (x) => x >= option.forceMin && x <= option.forceMax : hasForceMin ? (x) => x >= option.forceMin : hasForceMax ? (x) => x <= option.forceMax : null;
  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber_default(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber_default(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber_default(niceMinMax[0]) && isNumber_default(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber_default(niceMinMax[0]) || isNumber_default(niceMinMax[1]) ? isNumber_default(niceMinMax[0]) ? "max" : "min" : "all", {
    niceType,
    niceDomain,
    niceMinMax,
    domainValidator
  };
}
var fixPrecision = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
var d3TicksForLog = memoize((start, stop, count, base, transformer, untransformer, options) => {
  let u = start, v = stop;
  const r = v < u;
  r && ([u, v] = [v, u]);
  let k2, t, i = transformer(u), j = transformer(v), z = [];
  if (!(base % 1) && j - i < count) {
    if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
      for (; i <= j; ++i) for (k2 = 1; k2 < base; ++k2) if (t = i < 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
        if (t > v) break;
        z.push(t);
      }
    } else for (; i <= j; ++i) for (k2 = base - 1; k2 >= 1; --k2) if (t = i > 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
      if (t > v) break;
      z.push(t);
    }
    2 * z.length < count && (z = ticks2(u, v, count));
  } else z = ticks2(i, j, Math.min(j - i, count)).map(untransformer);
  return z = z.filter((t2) => 0 !== t2), (null == options ? void 0 : options.noDecimals) && (z = Array.from(new Set(z.map((t2) => Math.floor(t2))))), r ? z.reverse() : z;
});
var ticksBaseTransform = memoize((start, stop, count, base, transformer, untransformer) => {
  const ticksResult = [], ticksMap = {}, startExp = transformer(start), stopExp = transformer(stop);
  let ticksExp = [];
  if (Number.isInteger(base)) ticksExp = ticks2(startExp, stopExp, count);
  else {
    const stepExp = (stopExp - startExp) / (count - 1);
    for (let i = 0; i < count; i++) ticksExp.push(startExp + i * stepExp);
  }
  return ticksExp.forEach((tl) => {
    const power = untransformer(tl), nicePower = Number.isInteger(base) ? fixPrecision(start, stop, power) : fixPrecision(start, stop, niceNumber(power)), scopePower = fixPrecision(start, stop, restrictNumber(nicePower, [start, stop]));
    !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
  }), ticksResult;
});
var forceTicksBaseTransform = memoize((start, stop, count, transformer, untransformer) => forceTicks(transformer(start), transformer(stop), count).map((te) => niceNumber(untransformer(te))));
var forceStepTicksBaseTransform = memoize((start, stop, step, transformer, untransformer) => stepTicks2(transformer(start), transformer(stop), step).map((te) => niceNumber(untransformer(te))));

// node_modules/@visactor/vscale/es/linear-scale.js
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super(...arguments), this.type = ScaleEnum.Linear;
  }
  clone() {
    var _a;
    const scale4 = new _LinearScale();
    return scale4.domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate), this._niceType && (scale4._niceType = this._niceType, scale4._domainValidator = this._domainValidator, scale4._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), scale4;
  }
  tickFormat() {
    return () => {
    };
  }
  d3Ticks(count = 10, options) {
    const d = this.calculateVisibleDomain(this._range);
    return d3Ticks(d[0], d[d.length - 1], count, options);
  }
  ticks(count = 10, options) {
    var _a;
    if (isFunction_default(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
    let ticksResult = ticks2(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
    if (!ticksResult.length) return ticksResult;
    if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);
    else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
      const newNiceDomain = curNiceDomain.slice();
      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
        const min3 = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max3 = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
        ticksResult = ticksResult.filter((entry) => entry >= min3 && entry <= max3);
      }
    }
    return ticksResult;
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicks(d[0], d[d.length - 1], count);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks2(d[0], d[d.length - 1], step);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [];
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else this._niceType = "all";
    if (this._niceType) {
      const niceDomain = niceLinear(originalDomain.slice(), count);
      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
    }
    return this;
  }
  niceMin(count = 10) {
    this._niceType = "min";
    const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear(this.domain(), count);
    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax(count = 10) {
    this._niceType = "max";
    const minD = this._domain[0], niceDomain = niceLinear(this._domain.slice(), count);
    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vscale/es/log-nice-mixin.js
var LogNiceMixin = class {
  nice(count = 10, option) {
    var _b, _c, _d, _e;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), null !== (_c = null === (_b = this.getNiceConfig) || void 0 === _b ? void 0 : _b.call(this)) && void 0 !== _c ? _c : {
        floor: (x) => Math.floor(x),
        ceil: (x) => Math.ceil(x)
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_d = niceMinMax[1]) && void 0 !== _d ? _d : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_e = niceMinMax[0]) && void 0 !== _e ? _e : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vscale/es/log-scale.js
function reflect(f) {
  return (x) => -f(-x);
}
function limitPositiveZero(min3 = Number.EPSILON) {
  return (x) => Math.max(x, min3);
}
function limitNegativeZero(min3 = Number.EPSILON) {
  return (x) => Math.min(x, -min3);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
  }
  clone() {
    return new _LogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).base(this._base);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    super.rescale();
    const logs = logp(this._base), pows = powp(this._base);
    return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), this;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._limit(this._clamp(x))));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  base(_, slience) {
    return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
  }
  tickFormat() {
    return identity2;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
    return d3TicksForLog(u, v, count, this._base, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
  }
  getNiceConfig() {
    return {
      floor: (x) => this._pows(Math.floor(this._logs(this._limit(x)))),
      ceil: (x) => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
    };
  }
};
mixin(LogScale, LogNiceMixin);

// node_modules/@visactor/vscale/es/point-scale.js
var PointScale = class extends BandScale {
  constructor(slience) {
    super(false), this.type = ScaleEnum.Point, this._padding = 0, this.paddingInner(1, slience), this.padding = this.paddingOuter, this.paddingInner = void 0, this.paddingOuter = void 0;
  }
};

// node_modules/@visactor/vscale/es/sqrt-scale.js
var SqrtScale = class _SqrtScale extends LinearScale {
  constructor() {
    super(sqrt2, square3), this.type = ScaleEnum.Sqrt;
  }
  clone() {
    return new _SqrtScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate);
  }
};

// node_modules/@visactor/vscale/es/symlog-scale.js
var SymlogScale = class _SymlogScale extends LinearScale {
  constructor() {
    super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
  }
  clone() {
    return new _SymlogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).constant(this._const);
  }
  constant(_, slience) {
    return arguments.length ? (this._const = _, this.transformer = symlog(_), this.untransformer = symexp(_), this.rescale(slience)) : this._const;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = d[0], v = d[d.length - 1];
    return d3TicksForLog(u, v, count, this._const, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
  }
};
mixin(SymlogScale, LogNiceMixin);

// node_modules/@visactor/vscale/es/threshold-scale.js
var ThresholdScale = class _ThresholdScale {
  constructor() {
    this.type = ScaleEnum.Threshold, this._range = [0, 1], this._domain = [0.5], this.n = 1;
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
  scale(x) {
    return !isNil_default(x) && isValidNumber_default(+x) ? this._range[bisect(this._domain, x, 0, this.n)] : this._unknown;
  }
  invertExtent(y) {
    const i = this._range.indexOf(y);
    return [this._domain[i - 1], this._domain[i]];
  }
  domain(_) {
    return _ ? (this._domain = Array.from(_), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._domain.slice();
  }
  range(_) {
    return _ ? (this._range = Array.from(_), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._range.slice();
  }
  clone() {
    return new _ThresholdScale().domain(this._domain).range(this._range).unknown(this._unknown);
  }
};

// node_modules/@visactor/vscale/es/utils/time.js
var timeIntervals = [["second", 1, SECOND], ["second", 5, 5 * SECOND], ["second", 10, 10 * SECOND], ["second", 30, 30 * SECOND], ["minute", 1, MINUTE], ["minute", 5, 5 * MINUTE], ["minute", 10, 10 * MINUTE], ["minute", 30, 30 * MINUTE], ["hour", 1, HOUR], ["hour", 3, 3 * HOUR], ["hour", 6, 6 * HOUR], ["hour", 12, 12 * HOUR], ["day", 1, DAY], ["day", 2, 2 * DAY], ["day", 7, 7 * DAY], ["month", 1, MONTH], ["month", 3, 3 * MONTH], ["month", 6, 6 * MONTH], ["year", 1, 365 * DAY]];

// node_modules/@visactor/vscale/es/identity-scale.js
var implicit2 = Symbol("implicit");

// node_modules/@visactor/vscale/es/utils/tick-wilkinson-extended.js
var eps = 100 * Number.EPSILON;

// node_modules/@visactor/vrender-components/es/axis/tick-data/continuous.js
function getScaleTicks(op, scale4, count, getTicks) {
  let scaleTicks;
  const { breakData: breakData2 } = op;
  if (breakData2 && breakData2()) {
    const { breakDomains } = breakData2(), domain = scale4.domain();
    scaleTicks = [];
    for (let i = 0; i < domain.length - 1; i++) {
      getTicks(count, [domain[i], domain[i + 1]]).forEach((tick) => {
        breakDomains.some((breakDomain2) => tick >= breakDomain2[0] && tick <= breakDomain2[1]) || scaleTicks.push(tick);
      });
    }
    scale4.domain(domain);
  } else scaleTicks = getTicks(count);
  return scaleTicks;
}
function forceItemVisible2(sourceItem, items, check, comparator, inverse = false) {
  if (check && !items.includes(sourceItem)) {
    let remainLength = items.length;
    if (remainLength > 1) {
      inverse ? items.push(sourceItem) : items.unshift(sourceItem);
      for (let i = 0; i < remainLength; i++) {
        const index = inverse ? remainLength - 1 - i : i;
        if (!comparator(items[index])) break;
        items.splice(index, 1), i--, remainLength--;
      }
    }
  }
}
var continuousTicks = (scale4, op) => {
  var _a, _b;
  if (!isContinuous(scale4.type)) return convertDomainToTickData(scale4.domain());
  const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]);
  if (rangeSize < 2) return convertDomainToTickData([scale4.domain()[0]]);
  const { tickCount, forceTickCount, tickStep: tickStep2, noDecimals = false, labelStyle, breakData: breakData2 } = op;
  let scaleTicks;
  if (isValid_default(tickStep2)) ticks4 = scale4.stepTicks(tickStep2), breakDomains = breakData2 && breakData2() ? breakData2().breakDomains : null, scaleTicks = breakDomains && breakDomains.length ? ticks4.filter((tick) => breakDomains.every((breakDomain2) => tick < breakDomain2[0] || tick > breakDomain2[1])) : ticks4;
  else if (isValid_default(forceTickCount)) scaleTicks = getScaleTicks(op, scale4, forceTickCount, (count, subDomain) => subDomain && subDomain.length ? scale4.domain(subDomain, true).forceTicks(count) : scale4.forceTicks(count));
  else if ("d3" === op.tickMode) {
    const count = null !== (_a = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount) && void 0 !== _a ? _a : 5;
    scaleTicks = getScaleTicks(op, scale4, count, (count2, subDomain) => subDomain && subDomain.length ? scale4.domain(subDomain, true).d3Ticks(count2, {
      noDecimals
    }) : scale4.d3Ticks(count2, {
      noDecimals
    }));
  } else {
    const count = null !== (_b = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount) && void 0 !== _b ? _b : 5, customTicks = isFunction_default(op.tickMode) ? op.tickMode : void 0;
    scaleTicks = getScaleTicks(op, scale4, count, (count2, subDomain) => subDomain && subDomain.length ? scale4.domain(subDomain, true).ticks(count2, {
      noDecimals,
      customTicks
    }) : scale4.ticks(count2, {
      noDecimals,
      customTicks
    }));
  }
  var ticks4, breakDomains;
  const domain = scale4.domain();
  if (op.labelFirstVisible && domain[0] !== scaleTicks[0] && !scaleTicks.includes(domain[0]) && scaleTicks.unshift(domain[0]), op.labelLastVisible && domain[domain.length - 1] !== scaleTicks[scaleTicks.length - 1] && !scaleTicks.includes(domain[domain.length - 1]) && scaleTicks.push(domain[domain.length - 1]), op.sampling && scaleTicks.length > 1 && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
    const { labelGap = 4, labelFlush } = op, MIN_FONT_SIZE = 6;
    let items;
    if (scaleTicks.length * MIN_FONT_SIZE > rangeSize) {
      const samplingScaleTicks = [], step = Math.floor(scaleTicks.length * MIN_FONT_SIZE / rangeSize);
      scaleTicks.forEach((tick, index) => {
        index % step != 0 && index !== scaleTicks.length - 1 || samplingScaleTicks.push(tick);
      }), items = getCartesianLabelBounds(scale4, samplingScaleTicks, op).map((bounds, i) => ({
        AABBBounds: bounds,
        value: samplingScaleTicks[i]
      }));
    } else items = getCartesianLabelBounds(scale4, scaleTicks, op).map((bounds, i) => ({
      AABBBounds: bounds,
      value: scaleTicks[i]
    }));
    const firstSourceItem = items[0], lastSourceItem = last(items), samplingMethod = breakData2 && breakData2() ? methods2.greedy : methods2.parity;
    for (; items.length >= 3 && hasOverlap(items, labelGap); ) items = samplingMethod(items, labelGap);
    const checkFirst = op.labelFirstVisible;
    let checkLast = op.labelLastVisible;
    textIntersect(firstSourceItem, lastSourceItem, labelGap) && items.includes(lastSourceItem) && items.length > 1 && checkFirst && checkLast && (items.splice(items.indexOf(lastSourceItem), 1), checkLast = false), forceItemVisible2(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, labelGap)), forceItemVisible2(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, labelGap) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, labelGap), true);
    const ticks5 = items.map((item) => item.value);
    ticks5.length < 3 && labelFlush && (ticks5.length > 1 && ticks5.pop(), last(ticks5) !== last(scaleTicks) && ticks5.push(last(scaleTicks))), scaleTicks = ticks5;
  }
  return convertDomainToTickData(scaleTicks);
};
var methods2 = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 == 0);
  },
  greedy: function(items, sep) {
    let a3;
    return items.filter((b, i) => (!i || !textIntersect(a3, b, sep)) && (a3 = b, true));
  }
};

// node_modules/@visactor/vrender-components/es/axis/tick-data/discrete/linear.js
var getOneDimensionalLabelBounds = (scale4, domain, op, isHorizontal4) => getCartesianLabelBounds(scale4, domain, op).map((bounds) => isHorizontal4 ? [bounds.x1, bounds.x2, bounds.width()] : [bounds.y1, bounds.y2, bounds.height()]);
var boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
var boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;
var linearDiscreteTicks = (scale4, op) => {
  var _a;
  const domain = scale4.domain();
  if (!domain.length) return [];
  const { tickCount, forceTickCount, tickStep: tickStep2, labelGap = 4, axisOrientType, labelStyle } = op, isHorizontal4 = isAxisHorizontal(axisOrientType), range2 = scale4.range(), rangeSize = scale4.calculateWholeRangeSize();
  if (rangeSize < 2) return op.labelLastVisible ? convertDomainToTickData([domain[domain.length - 1]]) : convertDomainToTickData([domain[0]]);
  let scaleTicks;
  if (isValid_default(tickStep2)) scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount)) scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = minInArray(range2), rangeEnd = maxInArray(range2);
    if (domain.length <= rangeSize / fontSize) {
      const incrementUnit = (rangeEnd - rangeStart) / domain.length, labelBoundsList = getOneDimensionalLabelBounds(scale4, domain, op, isHorizontal4), minBoundsLength = Math.min(...labelBoundsList.map((bounds) => bounds[2])), stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), false);
      scaleTicks = scale4.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), scaleTicks.push(domain[domain.length - 1]));
    } else {
      const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]], tempList = getOneDimensionalLabelBounds(scale4, tempDomain, op, isHorizontal4);
      let maxBounds = null;
      tempList.forEach((current) => {
        maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
      });
      const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
      scaleTicks = scale4.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale4.scale(scaleTicks[scaleTicks.length - 1]) - scale4.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), scaleTicks.push(domain[domain.length - 1]));
    }
  } else scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
  let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
  const validateStep = (step2) => {
    let success = true, ptr = 0;
    do {
      ptr + step2 < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step2], labelGap) && (success = false), ptr += step2;
    } while (success && ptr < domain.length);
    return success;
  }, minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, (step2) => validateStep(step2) ? 1 : -1);
  let step = minValidStep;
  do {
    if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++;
    else {
      if (!labelLastVisible) {
        resultStep = step;
        break;
      }
      {
        const lastIndex = domain.length - 1;
        let ptr, delCount = 0;
        ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
        do {
          if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
          delCount++;
        } while (ptr > 0);
        if (ptr === lastIndex) {
          resultStep = step, resultDelCount = delCount;
          break;
        }
        {
          const tickCount = Math.floor(domain.length / step) - delCount + 1;
          if (tickCount < resultTickCount) break;
          {
            resultTickCount = tickCount;
            const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
            if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), distance1 <= distance2) break;
          }
        }
      }
      step++;
    }
  } while (step <= domain.length);
  return {
    step: resultStep,
    delCount: resultDelCount
  };
};

// node_modules/@visactor/vrender-components/es/axis/tick-data/discrete/polar-angle.js
var getPolarAngleLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, getRadius, labelOffset, labelFormatter, inside } = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure = initTextMeasure(labelStyle);
  return domain.map((v) => {
    const str = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, MIN_TICK_GAP), textHeight = Math.max(height, MIN_TICK_GAP), angle2 = scale4.scale(v), center2 = {
      x: 0,
      y: 0
    };
    let textX = 0, textY = 0;
    const orient = {
      align: labelStyle.textAlign,
      baseline: labelStyle.textBaseline
    }, { x, y } = getPolarAngleLabelPosition(angle2, center2, radius, labelOffset, inside);
    orient.align || (isNumberClose(x, center2.x) ? orient.baseline || (orient.baseline = y > center2.y ? "top" : "bottom") : x > center2.x ? orient.align = "left" : x < center2.x && (orient.align = "right")), textX = x + ("right" === orient.align ? -textWidth : "left" === orient.align ? 0 : -textWidth / 2), textY = y + ("bottom" === orient.baseline ? -textHeight : "top" === orient.baseline ? 0 : -textHeight / 2);
    return new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
  });
};
var polarAngleAxisDiscreteTicks = (scale4, op) => {
  const { tickCount, forceTickCount, tickStep: tickStep2, getRadius, labelOffset, labelGap = 0, labelStyle } = op, radius = null == getRadius ? void 0 : getRadius();
  if (!radius) return convertDomainToTickData(scale4.domain());
  let scaleTicks;
  if (isValid_default(tickStep2)) scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount)) scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]), count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const domain = scale4.domain(), range2 = scale4.range(), labelBoundsList = getPolarAngleLabelBounds(scale4, domain, op), rangeStart = minInArray(range2), rangeEnd = maxInArray(range2), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, { step, delCount } = getStep2(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min3, curBounds) => Math.min(min3, curBounds.width(), curBounds.height()), Number.MAX_VALUE) / incrementUnit));
    scaleTicks = scale4.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
  } else scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep2 = (domain, labelBoundsList, labelGap, defaultStep) => {
  let step = defaultStep;
  do {
    let success = true;
    step++;
    let ptr = 0;
    do {
      ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = false), ptr += step;
    } while (success && ptr < domain.length);
    if (success) break;
  } while (step <= domain.length);
  let delCount = 0;
  if (domain.length > 2) {
    let ptr = domain.length - domain.length % step;
    for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]); ) delCount++, ptr -= step;
  }
  return {
    step,
    delCount
  };
};

// node_modules/@visactor/vrender-components/es/crosshair/polygon-sector.js
loadPolygonSectorCrosshairComponent();
var PolygonSectorCrosshair = class _PolygonSectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonSectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, innerRadius = 0, polygonSectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute, points = [];
    points.push(polarToCartesian(center2, innerRadius, startAngle)), points.push(polarToCartesian(center2, radius * Math.cos((endAngle - startAngle) / 2), startAngle)), points.push(polarToCartesian(center2, radius, (startAngle + endAngle) / 2)), points.push(polarToCartesian(center2, radius * Math.cos((endAngle - startAngle) / 2), endAngle)), points.push(polarToCartesian(center2, innerRadius, endAngle));
    return container2.createOrUpdateChild("crosshair-polygon-sector", Object.assign({
      path: getPolygonPath(points, true)
    }, polygonSectorStyle), "path");
  }
  setLocation(point6) {
    const { center: center2, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center2, point6));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
PolygonSectorCrosshair.defaultAttributes = {
  polygonSectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vrender-components/es/label/overlap/bitmap.js
var RIGHT0 = new Uint32Array(33);
var RIGHT1 = new Uint32Array(33);
RIGHT1[0] = 0, RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= 32; ++i) RIGHT1[i] = RIGHT1[i - 1] << 1 | 1, RIGHT0[i] = ~RIGHT1[i];
function bitmap(w, h) {
  const array2 = new Uint32Array(~~((w * h + 32) / 32));
  function _set(index, mask) {
    array2[index] |= mask;
  }
  function _clear(index, mask) {
    array2[index] &= mask;
  }
  return {
    array: array2,
    get: (x, y) => {
      const index = y * w + x;
      return array2[index >>> 5] & 1 << (31 & index);
    },
    set: (x, y) => {
      const index = y * w + x;
      _set(index >>> 5, 1 << (31 & index));
    },
    clear: (x, y) => {
      const index = y * w + x;
      _clear(index >>> 5, ~(1 << (31 & index)));
    },
    getRange: ({ x1, y1, x2, y2 }) => {
      if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) return true;
      let start, end, indexStart, indexEnd, r = y2;
      for (; r >= y1; --r) if (start = r * w + x1, end = r * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) {
        if (array2[indexStart] & RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]) return true;
      } else {
        if (array2[indexStart] & RIGHT0[31 & start]) return true;
        if (array2[indexEnd] & RIGHT1[1 + (31 & end)]) return true;
        for (let i = indexStart + 1; i < indexEnd; ++i) if (array2[i]) return true;
      }
      return false;
    },
    setRange: ({ x1, y1, x2, y2 }) => {
      if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) return;
      let start, end, indexStart, indexEnd, i;
      for (; y1 <= y2; ++y1) if (start = y1 * w + x1, end = y1 * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _set(indexStart, RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]);
      else for (_set(indexStart, RIGHT0[31 & start]), _set(indexEnd, RIGHT1[1 + (31 & end)]), i = indexStart + 1; i < indexEnd; ++i) _set(i, 4294967295);
    },
    clearRange: ({ x1, y1, x2, y2 }) => {
      let start, end, indexStart, indexEnd, i;
      for (; y1 <= y2; ++y1) if (start = y1 * w + x1, end = y1 * w + x2, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _clear(indexStart, RIGHT1[31 & start] | RIGHT0[1 + (31 & end)]);
      else for (_clear(indexStart, RIGHT1[31 & start]), _clear(indexEnd, RIGHT0[1 + (31 & end)]), i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
    },
    outOfBounds: ({ x1, y1, x2, y2 }) => x1 < 0 || y1 < 0 || y2 >= h || x2 >= w,
    toImageData: (ctx) => {
      const imageData = ctx.createImageData(w, h), data = imageData.data;
      for (let y = 0; y < h; ++y) for (let x = 0; x < w; ++x) {
        const index = y * w + x, offset = 4 * index, occupied = array2[index >>> 5] & 1 << (31 & index);
        data[offset + 0] = 255 * occupied, data[offset + 1] = 255 * occupied, data[offset + 2] = 255 * occupied, data[offset + 3] = 31;
      }
      return imageData;
    }
  };
}

// node_modules/@visactor/vrender-components/es/label/overlap/scaler.js
function bitmapTool(width, height, padding = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}) {
  const { top = 0, left: left2 = 0, right: right2 = 0, bottom = 0 } = padding, ratio = Math.max(1, Math.sqrt(width * height / 1e6)), w = ~~((width + left2 + right2 + ratio) / ratio), h = ~~((height + top + bottom + ratio) / ratio), scale4 = (_) => ~~(_ / ratio);
  return scale4.bitmap = () => bitmap(w, h), scale4.x = (_) => ~~((_ + left2) / ratio), scale4.y = (_) => ~~((_ + top) / ratio), scale4.ratio = ratio, scale4.padding = padding, scale4.width = width, scale4.height = height, scale4;
}
function clampRangeByBitmap($, range2) {
  const { x1, x2, y1, y2 } = range2, { top = 0, left: left2 = 0, right: right2 = 0, bottom = 0 } = $.padding, _x1 = clamp_default(x1, -left2, $.width + right2), _x2 = clamp_default(x2, -left2, $.width + right2), _y1 = clamp_default(y1, -top, $.height + bottom), _y2 = clamp_default(y2, -top, $.height + bottom);
  return {
    x1: $.x(_x1),
    x2: $.x(_x2),
    y1: $.y(_y1),
    y2: $.y(_y2)
  };
}
function boundToRange($, bound2, clamp = false) {
  return clamp ? clampRangeByBitmap($, bound2) : {
    x1: $.x(bound2.x1),
    x2: $.x(bound2.x2),
    y1: $.y(bound2.y1),
    y2: $.y(bound2.y2)
  };
}

// node_modules/@visactor/vrender-components/es/label/overlap/place.js
function canPlace($, bitmap2, bound2, checkBound = true, pad = 0) {
  let range2 = bound2;
  pad > 0 && (range2 = {
    x1: bound2.x1 - pad,
    x2: bound2.x2 + pad,
    y1: bound2.y1 - pad,
    y2: bound2.y2 + pad
  }), range2 = boundToRange($, range2);
  const outOfBounds2 = bitmap2.outOfBounds(range2);
  return (!checkBound || !outOfBounds2) && (outOfBounds2 && (range2 = clampRangeByBitmap($, range2)), !bitmap2.getRange(range2));
}
function placeToCandidates($, bitmap2, text2, candidates = [], clampForce = true, pad = 0, changePosition = false) {
  const validCandidates = candidates.filter((candidate) => isValid_default(candidate));
  for (let i = 0; i < validCandidates.length; i++) {
    let measureText2;
    if (measureText2 = changePosition ? text2 : text2.clone(), measureText2.setAttributes(validCandidates[i]), canPlace($, bitmap2, measureText2.AABBBounds, clampForce, pad)) return bitmap2.setRange(boundToRange($, measureText2.AABBBounds, true)), validCandidates[i];
  }
  return false;
}
function place($, bitmap2, s2, attrs, text2, bounds, labeling) {
  var _a, _b;
  const clampForce = null === (_a = attrs.overlap) || void 0 === _a ? void 0 : _a.clampForce, overlapPadding = null === (_b = attrs.overlap) || void 0 === _b ? void 0 : _b.overlapPadding;
  if ("bound" === s2.type || "position" === s2.type) {
    if (isFunction_default(labeling)) {
      const candidates = ((isFunction_default(s2.position) ? s2.position(text2.attribute) : s2.position) || defaultLabelPosition(attrs.type)).map((p) => labeling(text2.AABBBounds, bounds, p, attrs.offset)), shouldClone = false === s2.restorePosition;
      return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding, shouldClone);
    }
    return false;
  }
  if ("moveY" === s2.type) {
    const candidates = (s2.offset ? isFunction_default(s2.offset) ? s2.offset(text2.attribute) : s2.offset : []).map((dy) => ({
      x: text2.attribute.x,
      y: text2.attribute.y + dy
    }));
    return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  if ("moveX" === s2.type) {
    const candidates = (s2.offset ? isFunction_default(s2.offset) ? s2.offset(text2.attribute) : s2.offset : []).map((dx) => ({
      x: text2.attribute.x + dx,
      y: text2.attribute.y
    }));
    return placeToCandidates($, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  return false;
}
var DefaultPositions = ["top", "bottom", "right", "left", "top-right", "bottom-right", "top-left", "bottom-left"];
var DefaultRectPositions = ["top", "inside-top", "inside"];
function defaultLabelPosition(type) {
  return "rect" === type ? DefaultRectPositions : DefaultPositions;
}
function clampText(text2, width, height, padding = {}) {
  const { x1, x2, y1, y2 } = text2.AABBBounds, { top = 0, left: left2 = 0, right: right2 = 0, bottom = 0 } = padding, minX = Math.min(x1, x2), maxX = Math.max(x1, x2), minY = Math.min(y1, y2), maxY2 = Math.max(y1, y2), maxXWithPadding = width + right2, maxYWithPadding = height + bottom;
  let dx = 0, dy = 0;
  return minX < 0 - left2 ? dx = -minX : maxX > maxXWithPadding && (dx = maxXWithPadding - maxX), minY < 0 - top ? dy = -minY : maxY2 > maxYWithPadding && (dy = maxYWithPadding - maxY2), {
    dx,
    dy
  };
}

// node_modules/@visactor/vrender-components/es/label/animate/animate.js
var fadeIn = (textAttribute2 = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_a = textAttribute2.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute2.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute2.strokeOpacity) && void 0 !== _c ? _c : 1
    }
  };
};
var fadeOut = (textAttribute2 = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = textAttribute2.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute2.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute2.strokeOpacity) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};
var animationEffects = {
  fadeIn,
  fadeOut
};
function getAnimationAttributes(textAttribute2, type) {
  var _a, _b;
  return null !== (_b = null === (_a = animationEffects[type]) || void 0 === _a ? void 0 : _a.call(animationEffects, textAttribute2)) && void 0 !== _b ? _b : {
    from: {},
    to: {}
  };
}
function updateAnimation(prev, next, animationConfig2) {
  const changeAttributes = (prev2, next2) => {
    const changed = {};
    for (const key in next2.attribute) prev2.attribute[key] !== next2.attribute[key] && (changed[key] = next2.attribute[key]);
    return changed;
  };
  if (!isArray_default(animationConfig2)) {
    const { duration, easing, increaseEffect = true } = animationConfig2;
    return prev.animate().to(changeAttributes(prev, next), duration, easing), void (increaseEffect && "text" === prev.type && "text" === next.type && playIncreaseCount(prev, next, duration, easing));
  }
  animationConfig2.forEach((cfg) => {
    const { duration, easing, increaseEffect = true, channel } = cfg, { to } = update(prev, next, channel, cfg.options);
    isEmpty_default(to) || prev.animate().to(changeAttributes(prev, next), duration, easing), increaseEffect && "text" === prev.type && "text" === next.type && playIncreaseCount(prev, next, duration, easing);
  });
}
var update = (prev, next, channel, options) => {
  const from = Object.assign({}, prev.attribute), to = Object.assign({}, next.attribute);
  return array(null == options ? void 0 : options.excludeChannels).forEach((key) => {
    delete to[key];
  }), Object.keys(to).forEach((key) => {
    channel && !channel.includes(key) && delete to[key];
  }), {
    from,
    to
  };
};
function playIncreaseCount(prev, next, duration, easing) {
  prev.attribute.text !== next.attribute.text && isValidNumber_default(Number(prev.attribute.text) * Number(next.attribute.text)) && prev.animate().play(new IncreaseCount({
    text: prev.attribute.text
  }, {
    text: next.attribute.text
  }, duration, easing));
}
var DefaultLabelAnimation = {
  mode: "same-time",
  duration: 300,
  easing: "linear"
};

// node_modules/@visactor/vrender-components/es/label/util.js
function isQuadrantLeft(quadrant) {
  return 3 === quadrant || 4 === quadrant;
}
function isQuadrantRight(quadrant) {
  return 1 === quadrant || 2 === quadrant;
}
function lineCirclePoints(a3, b, c3, x0, y0, r) {
  if (0 === a3 && 0 === b || r <= 0) return [];
  if (0 === a3) {
    const y12 = -c3 / b, fd2 = r ** 2 - (y12 - y0) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x0,
      y: y12
    }];
    return [{
      x: Math.sqrt(fd2) + x0,
      y: y12
    }, {
      x: -Math.sqrt(fd2) + x0,
      y: y12
    }];
  }
  if (0 === b) {
    const x12 = -c3 / a3, fd2 = r ** 2 - (x12 - x0) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x12,
      y: y0
    }];
    return [{
      x: x12,
      y: Math.sqrt(fd2) + y0
    }, {
      x: x12,
      y: -Math.sqrt(fd2) + y0
    }];
  }
  const fa = (b / a3) ** 2 + 1, fb = 2 * ((c3 / a3 + x0) * (b / a3) - y0), fd = fb ** 2 - 4 * fa * ((c3 / a3 + x0) ** 2 + y0 ** 2 - r ** 2);
  if (fd < 0) return [];
  const y1 = (-fb + Math.sqrt(fd)) / (2 * fa), y2 = (-fb - Math.sqrt(fd)) / (2 * fa), x1 = -(b * y1 + c3) / a3;
  return 0 === fd ? [{
    x: x1,
    y: y1
  }] : [{
    x: x1,
    y: y1
  }, {
    x: -(b * y2 + c3) / a3,
    y: y2
  }];
}
function connectLineRadian(radius, length2) {
  return length2 > 2 * radius ? NaN : 2 * Math.asin(length2 / 2 / radius);
}
function checkBoundsOverlap(boundsA, boundsB) {
  const { x1: ax1, y1: ay1, x2: ax2, y2: ay2 } = boundsA, { x1: bx1, y1: by1, x2: bx2, y2: by2 } = boundsB;
  return !(ax1 <= bx1 && ax2 <= bx1 || ax1 >= bx2 && ax2 >= bx2 || ay1 <= by1 && ay2 <= by1 || ay1 >= by2 && ay2 >= by2);
}
var labelingPoint = (textBounds, graphicBounds, position = "top", offset = 0) => {
  if (!textBounds) return;
  const { x1, y1, x2, y2 } = textBounds, width = Math.abs(x2 - x1), height = Math.abs(y2 - y1), anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2, anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2;
  let sx = 0, sy = 0, offsetX = 0, offsetY = 0;
  graphicBounds && (offsetX = Math.abs(graphicBounds.x1 - graphicBounds.x2) / 2, offsetY = Math.abs(graphicBounds.y1 - graphicBounds.y2) / 2);
  const angle2 = {
    "top-right": -235,
    "top-left": 235,
    "bottom-right": 45,
    "bottom-left": -45
  };
  switch (position) {
    case "top":
      sy = -1;
      break;
    case "bottom":
      sy = 1;
      break;
    case "left":
      sx = -1;
      break;
    case "right":
      sx = 1;
      break;
    case "bottom-left":
    case "bottom-right":
    case "top-left":
    case "top-right":
      sx = Math.sin(angle2[position] * (Math.PI / 180)), sy = Math.cos(angle2[position] * (Math.PI / 180));
      break;
    case "center":
      sx = 0, sy = 0;
  }
  return {
    x: anchorX + sx * (offset + offsetX) + Math.sign(sx) * (width / 2),
    y: anchorY + sy * (offset + offsetY) + Math.sign(sy) * (height / 2)
  };
};
var getPointsOfLineArea = (graphic) => {
  if (!graphic || !graphic.attribute) return [];
  const { points, segments: segments2 } = graphic.attribute;
  if (segments2 && segments2.length) {
    const res = [];
    return segments2.forEach((seg) => {
      seg.points.forEach((point6) => {
        res.push(point6);
      });
    }), res;
  }
  return points;
};
function labelingLineOrArea(textBounds, graphicBounds, position = "end", offset = 0) {
  if (!textBounds || !graphicBounds) return {
    x: 1 / 0,
    y: 1 / 0
  };
  const { x1, x2 } = textBounds, width = Math.abs(x2 - x1), anchorX = graphicBounds.x1;
  let x = anchorX;
  return "end" === position ? x = anchorX + width / 2 + offset : "start" === position && (x = anchorX - width / 2 - offset), {
    x,
    y: graphicBounds.y1
  };
}
function connectLineBetweenBounds(boundA, boundB) {
  if (!boundA || !boundB) return;
  if (isRectIntersect(boundA, boundB, true)) return;
  const x1 = Math.min(boundA.x1, boundA.x2), y1 = Math.min(boundA.y1, boundA.y2), x2 = Math.min(boundB.x1, boundB.x2), y2 = Math.min(boundB.y1, boundB.y2), w1 = Math.abs(boundA.x2 - x1) / 2, h1 = Math.abs(boundA.y2 - y1) / 2, w2 = Math.abs(boundB.x2 - x2) / 2, h2 = Math.abs(boundB.y2 - y2) / 2, cx1 = x1 + w1, cy1 = y1 + h1, cx2 = x2 + w2, cy2 = y2 + h2, dx = cx2 - cx1, dy = cy2 - cy1;
  return [getIntersection(dx, dy, cx1, cy1, w1, h1), getIntersection(-dx, -dy, cx2, cy2, w2, h2)];
}
function getIntersection(dx, dy, cx, cy, w, h) {
  return Math.abs(dy / dx) < h / w ? {
    x: cx + (dx > 0 ? w : -w),
    y: cy + dy * w / Math.abs(dx)
  } : {
    x: cx + dx * h / Math.abs(dy),
    y: cy + (dy > 0 ? h : -h)
  };
}
function getAlignOffset(align) {
  return "left" === align ? 0 : "right" === align ? 1 : 0.5;
}

// node_modules/@visactor/vrender-components/es/label/register.js
function loadLabelComponent() {
  registerGroup(), registerText(), registerRichtext(), registerLine();
}

// node_modules/@visactor/vrender-components/es/label/overlap/shiftY.js
var isIntersect = (top, bottom) => Math.ceil(top) > Math.floor(bottom);
var isXIntersect = ([a3, b], [c3, d]) => d > a3 && b > c3;
function getIntersectionLength(range1, range2) {
  const [start1, end1] = range1, [start2, end2] = range2, start = Math.max(start1, start2), end = Math.min(end1, end2);
  return Math.max(0, end - start);
}
function shiftY(texts, option) {
  const { maxY: maxY2 = Number.MAX_VALUE, labelling, globalShiftY = {
    enable: true,
    maxIterations: 10,
    maxError: 0.1,
    padding: 1
  } } = option, n = texts.length;
  if (n <= 1) return texts;
  const xMap = /* @__PURE__ */ new Map(), textInformation = /* @__PURE__ */ new Map(), getY1Initial = (text2) => textInformation.get(text2).y1Initial, getHeight = (text2) => textInformation.get(text2).height, getY1 = (text2) => textInformation.get(text2).y1, getX = (text2) => textInformation.get(text2).x, getX1 = (text2) => textInformation.get(text2).x1, getX2 = (text2) => textInformation.get(text2).x2, getAdjustAttempts = (text2) => textInformation.get(text2).attempts, setY1 = (text2, y) => {
    textInformation.get(text2).y1 = y;
  }, setAdjustAttempts = (text2, attempts) => {
    textInformation.get(text2).attempts = attempts;
  };
  function adjustPositionInOneGroup(texts2) {
    for (let i = texts2.length - 1; i >= 0; i--) {
      const curText = texts2[i], upperText = texts2[i - 1], lowerText = texts2[i + 1];
      if (upperText && isIntersect(getY1(upperText) + getHeight(upperText), getY1(curText)) || 0 === getY1(curText) && curText._isClamped) {
        const { y } = labelling(curText);
        lowerText && isIntersect(y + getHeight(curText) / 2, getY1(lowerText)) || y + getHeight(curText) / 2 <= maxY2 && setY1(curText, getY1(curText) + y - (text2 = curText, textInformation.get(text2).y));
      }
    }
    var text2;
  }
  texts.sort((a3, b) => a3.attribute.x - b.attribute.x);
  for (const text2 of texts) {
    const { y1, y2, x1, x2 } = text2.AABBBounds, { x, y } = text2.attribute;
    textInformation.set(text2, {
      y1Initial: y1,
      y1,
      y2,
      y,
      height: y2 - y1,
      x1,
      x2,
      x,
      attempts: 0
    });
    let hasRange = false;
    for (const [range2, xGroupTexts] of xMap) {
      const { start: start2, end: end2 } = range2;
      if (x1 >= start2 && x2 <= end2) xGroupTexts.push(text2), hasRange = true;
      else if (isNumberClose(x, getX(xGroupTexts[0]), void 0, 5)) {
        const newRange = {
          start: Math.min(start2, x1),
          end: Math.max(end2, x2)
        };
        xGroupTexts.push(text2), xMap.set(newRange, xGroupTexts), xMap.delete(range2), hasRange = true;
      } else if (getIntersectionLength([start2, end2], [x1, x2]) / (end2 - start2) > 0.5) {
        const newRange = {
          start: Math.min(start2, x1),
          end: Math.max(end2, x2)
        };
        xGroupTexts.push(text2), xMap.set(newRange, xGroupTexts), xMap.delete(range2), hasRange = true;
      }
      if (hasRange) break;
    }
    hasRange || xMap.set({
      start: x1,
      end: x2
    }, [text2]);
  }
  for (const xTexts of xMap.values()) xTexts.sort((a3, b) => getY1Initial(a3) - getY1Initial(b)), adjustPositionInOneGroup(xTexts);
  if (false !== globalShiftY.enable) {
    const { maxIterations = 10, maxError = 0.1, padding = 1, maxAttempts = 1e3, deltaYTolerance = Number.MAX_VALUE } = globalShiftY;
    for (let iter = 0; iter < maxIterations; iter++) {
      texts.sort((a3, b) => getY1Initial(a3) - getY1Initial(b));
      let error3 = 0;
      for (let i = 0; i < n - 1; i++) {
        const curText = texts[i];
        if (getAdjustAttempts(curText) >= maxAttempts) continue;
        let nextText, j = i + 1;
        for (; (nextText = texts[j]) && !isXIntersect([getX1(curText), getX2(curText)], [getX1(nextText), getX2(nextText)]); ) j += 1;
        if (nextText) {
          const y1 = getY1(curText), h0 = getHeight(curText), nextY1 = getY1(nextText), delta = nextY1 - (y1 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            if (error3 = Math.max(error3, newDelta), y1 + newDelta + getHeight(nextText) > maxY2) {
              const newY1 = y1 - (padding - delta), curTextDelta = getY1Initial(curText) - newY1;
              Math.abs(curTextDelta) <= deltaYTolerance && (setY1(curText, newY1), setAdjustAttempts(curText, getAdjustAttempts(curText) + 1));
            } else if (y1 - newDelta < 0) {
              const newY1 = nextY1 + (padding - delta), nextTextDelta = getY1Initial(nextText) - newY1;
              Math.abs(nextTextDelta) <= deltaYTolerance && (setY1(nextText, newY1), setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1));
            } else {
              const newCurY1 = y1 - newDelta, curTextDelta = getY1Initial(curText) - newCurY1, newNextY1 = nextY1 + newDelta, nextTextDelta = getY1Initial(nextText) - newNextY1;
              Math.abs(curTextDelta) <= deltaYTolerance && Math.abs(nextTextDelta) <= deltaYTolerance && (setY1(curText, newCurY1), setY1(nextText, newNextY1), setAdjustAttempts(curText, getAdjustAttempts(curText) + 1), setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1));
            }
          }
        }
      }
      if (error3 < maxError) break;
    }
  }
  for (const text2 of texts) {
    const finalY = text2.attribute.y + getY1(text2) - getY1Initial(text2);
    text2.setAttribute("y", finalY);
  }
  const result2 = [];
  texts.sort((a3, b) => a3.attribute.x - b.attribute.x);
  let start = 0, end = texts.length - 1;
  for (; start <= end; ) start === end ? result2.push(texts[start]) : (result2.push(texts[start]), result2.push(texts[end])), start++, end--;
  return result2;
}

// node_modules/@visactor/vrender-components/es/label/base.js
var __rest5 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadLabelComponent();
var LabelBase = class _LabelBase extends AbstractComponent {
  setBitmap(bitmap2) {
    this._bitmap = bitmap2;
  }
  setBitmapTool(bmpTool) {
    this._bmpTool = bmpTool;
  }
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest5(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _LabelBase.defaultAttributes, restAttributes))), this.name = "label", this._onHover = (e) => {
      const target = e.target;
      target === this._lastHover || isEmpty_default(target.states) || (target.addState(StateValue.hover, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.hoverReverse, true);
      }), this._lastHover = target);
    }, this._onUnHover = (e) => {
      this._lastHover && (traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
      }), this._lastHover = null);
    }, this._onClick = (e) => {
      const target = e.target;
      if (this._lastSelect === target && target.hasState("selected")) return this._lastSelect = null, void traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
      });
      isEmpty_default(target.states) || (target.addState(StateValue.selected, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.selectedReverse, true);
      }), this._lastSelect = target);
    }, this._handleRelatedGraphicSetState = (e) => {
      var _a, _b, _c, _d, _e;
      if ((null === (_a = e.detail) || void 0 === _a ? void 0 : _a.type) === AttributeUpdateType.STATE || (null === (_b = e.detail) || void 0 === _b ? void 0 : _b.type) === AttributeUpdateType.ANIMATE_UPDATE && (null === (_c = e.detail.animationState) || void 0 === _c ? void 0 : _c.isFirstFrameOfStep)) {
        const currentStates = null !== (_e = null === (_d = e.target) || void 0 === _d ? void 0 : _d.currentStates) && void 0 !== _e ? _e : [], labels = this._isCollectionBase ? [...this._graphicToText.values()] : [this._graphicToText.get(e.target)];
        this.updateStatesOfLabels(labels, currentStates);
      }
    };
  }
  labeling(textBounds, graphicBounds, position, offset) {
  }
  _getLabelLinePoints(text2, baseMark) {
    return connectLineBetweenBounds(text2.AABBBounds, null == baseMark ? void 0 : baseMark.AABBBounds);
  }
  _createLabelLine(text2, baseMark) {
    const points = this._getLabelLinePoints(text2, baseMark);
    if (points) {
      const lineGraphic = graphicCreator.line({
        points
      }), { line: line2 = {} } = text2.attribute;
      if (line2.customShape) {
        const customShape = line2.customShape;
        lineGraphic.pathProxy = (attrs) => customShape({
          text: text2,
          baseMark
        }, attrs, new CustomPath2D());
      }
      return baseMark && baseMark.attribute.fill && lineGraphic.setAttribute("stroke", baseMark.attribute.fill), this.attribute.line && !isEmpty_default(this.attribute.line.style) && lineGraphic.setAttributes(this.attribute.line.style), this._setStatesOfLabelLine(lineGraphic), lineGraphic;
    }
  }
  render() {
    if (this._prepare(), isNil_default(this._idToGraphic) || this._isCollectionBase && isNil_default(this._idToPoint)) return;
    const { overlap: overlap2, smartInvert, dataFilter, customLayoutFunc, customOverlapFunc } = this.attribute;
    let data = this.attribute.data;
    if (isFunction_default(dataFilter) && (data = dataFilter(data)), data && data.length) {
      const seenIds = /* @__PURE__ */ new Set();
      data = data.filter((d) => !seenIds.has(d.id) && seenIds.add(d.id));
    }
    let labels = this._initText(data);
    labels = isFunction_default(customLayoutFunc) ? customLayoutFunc(data, labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this) : this._layout(labels), isFunction_default(customOverlapFunc) ? labels = customOverlapFunc(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this) : false !== overlap2 && (labels = this._overlapping(labels)), isFunction_default(this.attribute.onAfterOverlapping) && this.attribute.onAfterOverlapping(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this), labels && labels.length && labels.forEach((label) => {
      this._bindEvent(label), this._setStatesOfText(label);
    }), false !== smartInvert && this._smartInvert(labels), this._renderLabels(labels);
  }
  _bindEvent(target) {
    if (this.attribute.disableTriggerEvent) return;
    if (!target) return;
    const { hover, select } = this.attribute;
    hover && (target.addEventListener("pointermove", this._onHover), target.addEventListener("pointerout", this._onUnHover)), select && target.addEventListener("pointerdown", this._onClick);
  }
  _setStatesOfText(target) {
    if (!target) return;
    const state = this.attribute.state;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _setStatesOfLabelLine(target) {
    if (!target) return;
    const state = this.attribute.labelLineState;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _createLabelText(attributes) {
    var _a, _b;
    const textAttrs = Object.assign(Object.assign({}, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text), attributes);
    return createTextGraphicByType(textAttrs, "textType");
  }
  _prepare() {
    var _a, _b;
    const currentBaseMarks = [];
    let baseMarks;
    if (baseMarks = isFunction_default(this.attribute.getBaseMarks) ? this.attribute.getBaseMarks() : getMarksByName(this.getRootNode(), this.attribute.baseMarkGroupName), baseMarks.forEach((mark) => {
      "willRelease" !== mark.releaseStatus && currentBaseMarks.push(mark);
    }), null === (_a = this._idToGraphic) || void 0 === _a || _a.clear(), null === (_b = this._idToPoint) || void 0 === _b || _b.clear(), this._baseMarks = currentBaseMarks, this._isCollectionBase = "line-data" === this.attribute.type, !currentBaseMarks || 0 === currentBaseMarks.length) return;
    const { data } = this.attribute;
    if (data && 0 !== data.length) {
      if (this._idToGraphic || (this._idToGraphic = /* @__PURE__ */ new Map()), this._isCollectionBase) {
        this._idToPoint || (this._idToPoint = /* @__PURE__ */ new Map());
        let cur = 0;
        for (let i = 0; i < currentBaseMarks.length; i++) {
          const baseMark = currentBaseMarks[i], points = getPointsOfLineArea(baseMark);
          if (points && points.length) for (let j = 0; j < points.length; j++) {
            const textData = data[cur];
            textData && points[j] && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${cur}`), this._idToPoint.set(textData.id, points[j]), this._idToGraphic.set(textData.id, baseMark)), cur++;
          }
        }
      } else for (let i = 0; i < currentBaseMarks.length; i++) {
        const textData = data[i], baseMark = currentBaseMarks[i];
        textData && baseMark && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${i}`), this._idToGraphic.set(textData.id, baseMark));
      }
      if (false !== this.attribute.animation) {
        const { animation, animationEnter, animationExit, animationUpdate } = this.attribute, animationCfg = isObject_default(animation) ? animation : {};
        this._animationConfig = {
          enter: false !== animationEnter && merge({}, DefaultLabelAnimation, animationCfg, null != animationEnter ? animationEnter : {}),
          exit: false !== animationExit && merge({}, DefaultLabelAnimation, animationCfg, null != animationExit ? animationExit : {}),
          update: false !== animationUpdate && (isArray_default(animationUpdate) ? animationUpdate : merge({}, DefaultLabelAnimation, animationCfg, null != animationUpdate ? animationUpdate : {}))
        };
      } else this._animationConfig = {
        enter: false,
        exit: false,
        update: false
      };
    }
  }
  getRelatedGraphic(item) {
    return this._idToGraphic.get(item.id);
  }
  _initText(data = []) {
    const { textStyle = {} } = this.attribute, labels = [];
    for (let i = 0; i < data.length; i++) {
      const textData = data[i], baseMark = this.getRelatedGraphic(textData);
      if (!baseMark) continue;
      const labelAttribute = Object.assign(Object.assign({
        fill: this._isCollectionBase ? isArray_default(baseMark.attribute.stroke) ? baseMark.attribute.stroke.find((entry) => !!entry && true !== entry) : baseMark.attribute.stroke : baseMark.attribute.fill
      }, textStyle), textData), text2 = this._createLabelText(labelAttribute);
      labels.push(text2);
    }
    return labels;
  }
  _layout(texts) {
    const { position, offset } = this.attribute;
    for (let i = 0; i < texts.length; i++) {
      const text2 = texts[i];
      if (!text2) return;
      const textData = text2.attribute, baseMark = this.getRelatedGraphic(textData);
      if (!baseMark) continue;
      text2.attachedThemeGraphic = this;
      const textBounds = this.getGraphicBounds(text2);
      text2.attachedThemeGraphic = null;
      const actualPosition = isFunction_default(position) ? position(textData) : position, graphicBounds = this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(textData.id), actualPosition) : this.getGraphicBounds(baseMark, {
        x: textData.x,
        y: textData.y
      }, actualPosition), textLocation = this.labeling(textBounds, graphicBounds, actualPosition, offset);
      textLocation && text2.setAttributes(textLocation);
    }
    return texts;
  }
  _overlapping(labels) {
    var _a, _b, _c;
    if (0 === labels.length) return [];
    const option = isObject_default(this.attribute.overlap) ? this.attribute.overlap : {}, baseMarkGroup = this.getBaseMarkGroup(), size = null !== (_a = option.size) && void 0 !== _a ? _a : {
      width: null !== (_b = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.width()) && void 0 !== _b ? _b : 0,
      height: null !== (_c = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.height()) && void 0 !== _c ? _c : 0
    };
    if (0 === size.width || 0 === size.height) return labels;
    const { strategy, priority } = option, bmpTool = this._bmpTool || bitmapTool(size.width, size.height), bitmap2 = this._bitmap || bmpTool.bitmap();
    return priority && (labels = labels.sort((a3, b) => priority(b.attribute.data) - priority(a3.attribute.data))), "shiftY" === (null == strategy ? void 0 : strategy.type) ? this._overlapGlobal(labels, option, bmpTool, bitmap2) : this._overlapByStrategy(labels, option, bmpTool, bitmap2);
  }
  _overlapGlobal(labels, option, bmpTool, bitmap2) {
    let result2 = labels.filter((label) => label.attribute.visible && 0 !== label.attribute.opacity && this.isMarkInsideRect(this.getRelatedGraphic(label.attribute), bmpTool));
    const { clampForce = true, hideOnHit = true, overlapPadding, strategy } = option;
    if (clampForce) for (let i = 0; i < result2.length; i++) {
      const text2 = labels[i], { dx = 0, dy = 0 } = clampText(text2, bmpTool.width, bmpTool.height, bmpTool.padding);
      0 === dx && 0 === dy || (text2.setAttributes({
        x: text2.attribute.x + dx,
        y: text2.attribute.y + dy
      }), text2._isClamped = true);
    }
    result2 = shiftY(result2, Object.assign(Object.assign({
      maxY: bmpTool.height
    }, strategy), {
      labelling: (text2) => {
        const baseMark = this.getRelatedGraphic(text2.attribute), graphicBound = this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(text2.attribute.id)) : this.getGraphicBounds(baseMark, text2);
        return this.labeling(text2.AABBBounds, graphicBound, "bottom", this.attribute.offset);
      }
    }));
    for (let i = 0; i < result2.length; i++) {
      const text2 = result2[i], bounds = text2.AABBBounds, range2 = boundToRange(bmpTool, bounds, true);
      if (canPlace(bmpTool, bitmap2, bounds, clampForce, overlapPadding)) bitmap2.setRange(range2);
      else {
        if (clampForce) {
          if (this._processClampForce(text2, bmpTool, bitmap2, overlapPadding)) continue;
        }
        hideOnHit ? text2.setAttributes({
          visible: false
        }) : bitmap2.setRange(range2);
      }
    }
    return result2;
  }
  _processClampForce(text2, bmpTool, bitmap2, overlapPadding = 0) {
    const { dy = 0, dx = 0 } = clampText(text2, bmpTool.width, bmpTool.height, bmpTool.padding);
    if (0 === dx && 0 === dy) {
      if (canPlace(bmpTool, bitmap2, text2.AABBBounds, false, overlapPadding)) return bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), true;
    } else if (canPlace(bmpTool, bitmap2, {
      x1: text2.AABBBounds.x1 + dx,
      x2: text2.AABBBounds.x2 + dx,
      y1: text2.AABBBounds.y1 + dy,
      y2: text2.AABBBounds.y2 + dy
    })) return text2.setAttributes({
      x: text2.attribute.x + dx,
      y: text2.attribute.y + dy
    }), bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), true;
    return false;
  }
  _overlapByStrategy(labels, option, bmpTool, bitmap2) {
    var _a;
    const { avoidBaseMark, strategy = [], hideOnHit = true, clampForce = true, avoidMarks = [], overlapPadding } = option, result2 = [], checkBounds = strategy.some((s2) => "bound" === s2.type);
    avoidBaseMark && (null === (_a = this._baseMarks) || void 0 === _a || _a.forEach((mark) => {
      mark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, mark.AABBBounds, true));
    })), avoidMarks.length > 0 && avoidMarks.forEach((avoid) => {
      isString_default(avoid) ? getNoneGroupMarksByName(this.getRootNode(), avoid).forEach((avoidMark) => {
        avoidMark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoidMark.AABBBounds, true));
      }) : avoid.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoid.AABBBounds, true));
    });
    for (let i = 0; i < labels.length; i++) {
      if (false === labels[i].attribute.visible) continue;
      const text2 = labels[i], baseMark = this.getRelatedGraphic(text2.attribute);
      if (text2.update(), !this.isMarkInsideRect(baseMark, bmpTool)) continue;
      if (canPlace(bmpTool, bitmap2, text2.AABBBounds, clampForce, overlapPadding)) {
        if (!checkBounds) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
        if (checkBounds && baseMark && baseMark.AABBBounds && this._canPlaceInside(text2.AABBBounds, baseMark.AABBBounds)) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
      }
      let hasPlace = false;
      for (let j = 0; j < strategy.length; j++) if (hasPlace = place(bmpTool, bitmap2, strategy[j], this.attribute, text2, this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(labels[i].attribute.id)) : this.getGraphicBounds(baseMark, labels[i].attribute), this.labeling), false !== hasPlace) {
        text2.setAttributes({
          x: hasPlace.x,
          y: hasPlace.y
        }), result2.push(text2);
        break;
      }
      if (!hasPlace && clampForce) {
        if (this._processClampForce(text2, bmpTool, bitmap2, overlapPadding)) {
          result2.push(text2);
          continue;
        }
      }
      !hasPlace && !hideOnHit && result2.push(text2);
    }
    return result2;
  }
  isMarkInsideRect(baseMark, bmpTool) {
    const { left: left2, right: right2, top, bottom } = bmpTool.padding, rect = {
      x1: -left2,
      x2: bmpTool.width + right2,
      y1: -top,
      y2: bmpTool.height + bottom
    }, bounds = baseMark.AABBBounds;
    if (0 !== bounds.width() && 0 !== bounds.height()) return isRectIntersect(baseMark.AABBBounds, rect, true);
    const { attribute } = baseMark;
    if ("rect" === baseMark.type) {
      const { x, x1, y, y1 } = attribute;
      return pointInRect({
        x: null != x ? x : x1,
        y: null != y ? y : y1
      }, rect, true);
    }
    return "x" in attribute && "y" in attribute && pointInRect({
      x: attribute.x,
      y: attribute.y
    }, rect, true);
  }
  getBaseMarkGroup() {
    const { baseMarkGroupName } = this.attribute;
    if (baseMarkGroupName) return this.getRootNode().find((node) => node.name === baseMarkGroupName, true);
  }
  getGraphicBounds(graphic, point6 = {}, position) {
    if (graphic) {
      if (false !== graphic.attribute.visible) return graphic.AABBBounds;
      const { x: x2, y: y2 } = graphic.attribute;
      return {
        x1: x2,
        x2,
        y1: y2,
        y2
      };
    }
    if (point6 && position && "inside-middle" === position) {
      const { x: x2, y: y2, x1 = x2, y1 = y2 } = point6;
      return {
        x1: (x2 + x1) / 2,
        x2: (x2 + x1) / 2,
        y1: (y2 + y1) / 2,
        y2: (y2 + y1) / 2
      };
    }
    const { x, y } = point6;
    return {
      x1: x,
      x2: x,
      y1: y,
      y2: y
    };
  }
  _renderLabels(labels) {
    var _a;
    const { syncState } = this.attribute, currentTextMap = /* @__PURE__ */ new Map(), prevTextMap = this._graphicToText || /* @__PURE__ */ new Map(), texts = [], labelLines = [], { visible: showLabelLine } = null !== (_a = this.attribute.line) && void 0 !== _a ? _a : {};
    labels && labels.forEach((text2, index) => {
      var _a2;
      const relatedGraphic = this.getRelatedGraphic(text2.attribute), textKey = this._isCollectionBase ? text2.attribute.id : relatedGraphic, state = (null == prevTextMap ? void 0 : prevTextMap.get(textKey)) ? "update" : "enter";
      let labelLine;
      if (showLabelLine && (labelLine = this._createLabelLine(text2, relatedGraphic)), syncState && this.updateStatesOfLabels([labelLine ? {
        text: text2,
        labelLine
      } : {
        text: text2
      }], null !== (_a2 = relatedGraphic.currentStates) && void 0 !== _a2 ? _a2 : []), "enter" === state) texts.push(text2), currentTextMap.set(textKey, labelLine ? {
        text: text2,
        labelLine
      } : {
        text: text2
      }), this._addLabel({
        text: text2,
        labelLine
      }, texts, labelLines, index);
      else if ("update" === state) {
        const prevLabel = prevTextMap.get(textKey);
        prevTextMap.delete(textKey), currentTextMap.set(textKey, prevLabel), this._updateLabel(prevLabel, {
          text: text2,
          labelLine
        });
      }
    }), this._removeLabel(prevTextMap), this._graphicToText = currentTextMap;
  }
  _addLabel(label, texts, labelLines, index) {
    const { text: text2, labelLine } = label, relatedGraphic = this.getRelatedGraphic(text2.attribute);
    if (this._syncStateWithRelatedGraphic(relatedGraphic), false !== this._enableAnimation && false !== this._animationConfig.enter) {
      if (relatedGraphic) {
        const { from, to } = getAnimationAttributes(text2.attribute, "fadeIn");
        text2 && this.add(text2), labelLine && (labelLines.push(labelLine), this.add(labelLine)), this._animationConfig.enter.duration > 0 && relatedGraphic.once("animate-bind", (a3) => {
          text2.setAttributes(from), labelLine && labelLine.setAttributes(from);
          const listener = this._afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, this._animationConfig.enter);
          relatedGraphic.on("afterAttributeUpdate", listener);
        });
      }
    } else text2 && this.add(text2), labelLine && this.add(labelLine);
  }
  _updateLabel(prevLabel, currentLabel) {
    const { text: prevText, labelLine: prevLabelLine } = prevLabel, { text: curText, labelLine: curLabelLine } = currentLabel;
    if (false !== this._enableAnimation && false !== this._animationConfig.update) {
      const { duration, easing } = this._animationConfig.update;
      updateAnimation(prevText, curText, this._animationConfig.update), prevLabelLine && curLabelLine && prevLabel.labelLine.animate().to(curLabelLine.attribute, duration, easing);
    } else prevLabel.text.setAttributes(curText.attribute), prevLabelLine && curLabelLine && prevLabel.labelLine.setAttributes(curLabelLine.attribute);
  }
  _removeLabel(textMap) {
    const removeLabelAndLine = (label) => {
      this.removeChild(label.text), label.labelLine && this.removeChild(label.labelLine);
    };
    if (false !== this._enableAnimation && false !== this._animationConfig.exit) {
      const { duration, easing } = this._animationConfig.exit;
      textMap.forEach((label) => {
        var _a;
        null === (_a = label.text) || void 0 === _a || _a.animate().to(getAnimationAttributes(label.text.attribute, "fadeOut").to, duration, easing).onEnd(() => {
          removeLabelAndLine(label);
        });
      });
    } else textMap.forEach((label) => {
      removeLabelAndLine(label);
    });
  }
  updateStatesOfLabels(labels, currentStates) {
    labels.forEach((label) => {
      label && (label.text && label.text.useStates(currentStates), label.labelLine && label.labelLine.useStates(currentStates));
    });
  }
  _syncStateWithRelatedGraphic(relatedGraphic) {
    this.attribute.syncState && relatedGraphic && relatedGraphic.on("afterAttributeUpdate", this._handleRelatedGraphicSetState);
  }
  _afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, { mode, duration, easing, delay }) {
    const listener = (event) => {
      var _a, _b, _c;
      const { detail } = event;
      if (!detail) return {};
      const step = null === (_a = detail.animationState) || void 0 === _a ? void 0 : _a.step;
      if (!(detail.type === AttributeUpdateType.ANIMATE_UPDATE && step && !("wait" === step.type && null == (null === (_b = step.prev) || void 0 === _b ? void 0 : _b.type)))) return {};
      if (detail.type === AttributeUpdateType.ANIMATE_END) return text2.setAttributes(to), void (labelLine && labelLine.setAttributes(to));
      const onStart = () => {
        relatedGraphic && (relatedGraphic.onAnimateBind = void 0, relatedGraphic.removeEventListener("afterAttributeUpdate", listener));
      };
      switch (mode) {
        case "after":
          detail.animationState.end && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          break;
        case "after-all":
          index === texts.length - 1 && detail.animationState.end && (texts.forEach((t) => {
            t.animate({
              onStart
            }).wait(delay).to(to, duration, easing);
          }), labelLines.forEach((t) => {
            t.animate().wait(delay).to(to, duration, easing);
          }));
          break;
        default:
          if (this._isCollectionBase) {
            const point6 = this._idToPoint.get(text2.attribute.id);
            !point6 || text2.animates && text2.animates.has("label-animate") || !relatedGraphic.containsPoint(point6.x, point6.y, IContainPointMode.LOCAL, null === (_c = this.stage) || void 0 === _c ? void 0 : _c.getPickerService()) || (text2.animate({
              onStart
            }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          } else detail.animationState.isFirstFrameOfStep && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
      }
    };
    return listener;
  }
  _smartInvert(labels) {
    var _a, _b, _c, _d, _e, _f, _g;
    const option = isObject_default(this.attribute.smartInvert) ? this.attribute.smartInvert : {}, { textType, contrastRatiosThreshold, alternativeColors, mode, interactInvertType } = option, fillStrategy = null !== (_a = option.fillStrategy) && void 0 !== _a ? _a : "invertBase", strokeStrategy = null !== (_b = option.strokeStrategy) && void 0 !== _b ? _b : "base", brightColor = null !== (_c = option.brightColor) && void 0 !== _c ? _c : "#ffffff", darkColor = null !== (_d = option.darkColor) && void 0 !== _d ? _d : "#000000", outsideEnable = null !== (_e = option.outsideEnable) && void 0 !== _e && _e;
    if ("null" !== fillStrategy || "null" !== strokeStrategy) for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      if (!label) continue;
      const baseMark = this.getRelatedGraphic(label.attribute);
      let backgroundColor = baseMark.attribute.fill, foregroundColor = label.attribute.fill;
      if (isObject_default(backgroundColor) && backgroundColor.gradient) {
        const firstStopColor = null === (_g = null === (_f = backgroundColor.stops) || void 0 === _f ? void 0 : _f[0]) || void 0 === _g ? void 0 : _g.color;
        firstStopColor && (backgroundColor = firstStopColor, foregroundColor = firstStopColor);
      }
      const invertColor = labelSmartInvert(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode), similarColor = contrastAccessibilityChecker(invertColor, brightColor) ? brightColor : darkColor, isInside = this._canPlaceInside(label.AABBBounds, baseMark.AABBBounds), isIntersect2 = !isInside && label.AABBBounds && baseMark.AABBBounds && baseMark.AABBBounds.intersects(label.AABBBounds);
      if (isInside || outsideEnable || isIntersect2 && "inside" === interactInvertType) {
        const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
        if (fill && label.setAttributes({
          fill
        }), 0 === label.attribute.lineWidth || 0 === label.attribute.strokeOpacity) continue;
        const stroke2 = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
        stroke2 && label.setAttributes({
          stroke: stroke2
        });
      } else if (isIntersect2 && "none" !== interactInvertType) {
        if (0 === label.attribute.lineWidth || 0 === label.attribute.strokeOpacity) continue;
        if (label.attribute.stroke) {
          label.setAttributes({
            fill: labelSmartInvert(label.attribute.fill, label.attribute.stroke, textType, contrastRatiosThreshold, alternativeColors, mode)
          });
          continue;
        }
        const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
        fill && label.setAttributes({
          fill
        });
        const stroke2 = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
        stroke2 && label.setAttributes({
          stroke: stroke2
        });
      }
    }
  }
  _canPlaceInside(textBound, shapeBound) {
    return !(!textBound || !shapeBound) && shapeBound.encloses(textBound);
  }
  setLocation(point6) {
    this.translateTo(point6.x, point6.y);
  }
  disableAnimation() {
    this._enableAnimation = false;
  }
  enableAnimation() {
    this._enableAnimation = true;
  }
};
LabelBase.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-2, -1, -2, -1]
  },
  offset: 0,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/data-label-register.js
var labelComponentMap = {};
var registerLabelComponent = (type, LabelClass) => {
  labelComponentMap[type] = LabelClass;
};
var getLabelComponent = (type) => labelComponentMap[type];

// node_modules/@visactor/vrender-components/es/label/symbol.js
var __rest6 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var SymbolLabel = class _SymbolLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest6(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _SymbolLabel.defaultAttributes, restAttributes))), this.name = "symbol-label";
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    return labelingPoint(textBounds, graphicBounds, position, offset);
  }
};
SymbolLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "top",
  offset: 5
};
var registerSymbolDataLabel = () => {
  registerLabelComponent("symbol", SymbolLabel), registerLabelComponent("line-data", SymbolLabel);
};

// node_modules/@visactor/vrender-components/es/label/rect.js
var __rest7 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var RectLabel = class _RectLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest7(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _RectLabel.defaultAttributes, restAttributes)));
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    if (!textBounds || !graphicBounds) return;
    const { x1, y1, x2, y2 } = textBounds, width = Math.abs(x2 - x1), height = Math.abs(y2 - y1), { x: anchorX, y: anchorY } = calculateAnchorOfBounds(graphicBounds, position);
    let vx = 0, vy = 0;
    const isInside = position.includes("inside");
    switch (position.includes("top") ? vy = isInside ? 1 : -1 : position.includes("bottom") ? vy = isInside ? -1 : 1 : position.includes("left") ? vx = isInside ? 1 : -1 : position.includes("right") && (vx = isInside ? -1 : 1), position) {
      case "top-right":
      case "bottom-right":
        vx = -1;
        break;
      case "top-left":
      case "bottom-left":
        vx = 1;
    }
    return {
      x: anchorX + vx * offset + vx * width / 2,
      y: anchorY + vy * offset + vy * height / 2
    };
  }
};
RectLabel.tag = "rect-label", RectLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "top",
  offset: 5
};
var registerRectDataLabel = () => {
  registerLabelComponent("rect", RectLabel);
};

// node_modules/@visactor/vrender-components/es/label/line.js
var __rest8 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var LineLabel = class _LineLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest8(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _LineLabel.defaultAttributes, restAttributes))), this.name = "line-label";
  }
  getGraphicBounds(graphic, point6 = {}, position = "end") {
    if (!graphic || "line" !== graphic.type && "area" !== graphic.type) return super.getGraphicBounds(graphic, point6);
    let points = graphic.attribute.points;
    const segments2 = graphic.attribute.segments;
    !points && segments2 && segments2.length && (points = segments2.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, [])), points && 0 !== points.length || (points = [point6]);
    const index = "start" === position ? 0 : points.length - 1;
    return points[index] ? {
      x1: points[index].x,
      x2: points[index].x,
      y1: points[index].y,
      y2: points[index].y
    } : void 0;
  }
  labeling(textBounds, graphicBounds, position = "end", offset = 0) {
    return labelingLineOrArea(textBounds, graphicBounds, position, offset);
  }
};
LineLabel.defaultAttributes = {
  textStyle: {
    fill: "#000"
  },
  position: "end",
  offset: 6
};
var registerLineDataLabel = () => {
  registerLabelComponent("line", LineLabel), registerLabelComponent("area", LineLabel);
};

// node_modules/@visactor/vrender-components/es/label/arc.js
var __rest9 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var ArcInfo = class {
  constructor(refDatum, center2, outerCenter, quadrant, radian, middleAngle, innerRadius, outerRadius, circleCenter) {
    this.refDatum = refDatum, this.center = center2, this.outerCenter = outerCenter, this.quadrant = quadrant, this.radian = radian, this.middleAngle = middleAngle, this.innerRadius = innerRadius, this.outerRadius = outerRadius, this.circleCenter = circleCenter, this.labelVisible = true;
  }
  getLabelBounds() {
    return this.labelPosition && this.labelSize ? {
      x1: this.labelPosition.x - this.labelSize.width / 2,
      y1: this.labelPosition.y - this.labelSize.height / 2,
      x2: this.labelPosition.x + this.labelSize.width / 2,
      y2: this.labelPosition.y + this.labelSize.height / 2
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
};
var ArcLabel = class _ArcLabel extends LabelBase {
  constructor(attributes, options) {
    const { data } = attributes, restAttributes = __rest9(attributes, ["data"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      data
    }, merge({}, _ArcLabel.defaultAttributes, restAttributes))), this.name = "arc-label", this._ellipsisWidth = 0, this._arcLeft = /* @__PURE__ */ new Map(), this._arcRight = /* @__PURE__ */ new Map(), this._line2MinLength = 0, this._alignOffset = 0;
  }
  _overlapping(labels) {
    return ["inside", "inside-center"].includes(this.attribute.position) ? super._overlapping(labels) : labels;
  }
  labeling(textBounds, graphicBounds, position = "outside", offset = 0) {
    if (textBounds && graphicBounds) return {
      x: 0,
      y: 0
    };
  }
  _layout(texts) {
    var _a, _b, _c;
    if (!texts || !texts.length) return;
    const labels = super._layout(texts), textBoundsArray = labels.map((label) => this.getGraphicBounds(label)), ellipsisLabelAttribute = Object.assign(Object.assign({}, this.attribute.textStyle), {
      text: "…"
    });
    let ellipsisWidth = 1 / 0;
    if (false !== ellipsisLabelAttribute.ellipsis) {
      const ellipsisText = this._createLabelText(ellipsisLabelAttribute), ellipsisTextBounds = this.getGraphicBounds(ellipsisText);
      ellipsisWidth = ellipsisTextBounds.x2 - ellipsisTextBounds.x1;
    }
    const data = labels.map((label) => label.attribute), currentMarks = Array.from(this._idToGraphic.values());
    this._line2MinLength = isFunction_default(this.attribute.line.line2MinLength) ? this.attribute.line.line2MinLength(texts, currentMarks, this.attribute) : this.attribute.line.line2MinLength, this._alignOffset = null !== (_a = isFunction_default(this.attribute.layout.alignOffset) ? this.attribute.layout.alignOffset(texts, currentMarks, this.attribute) : this.attribute.layout.alignOffset) && void 0 !== _a ? _a : 0;
    const arcs = this.layoutArcLabels(this.attribute.position, this.attribute, currentMarks, data, textBoundsArray, ellipsisWidth);
    for (let i = 0; i < data.length; i++) {
      const textData = data[i], basedArc = arcs.find((arc) => {
        var _a2;
        return (null === (_a2 = arc.refDatum) || void 0 === _a2 ? void 0 : _a2.id) === textData.id;
      });
      if (basedArc) {
        const labelAttribute = {
          visible: basedArc.labelVisible,
          x: basedArc.labelPosition.x,
          y: basedArc.labelPosition.y,
          angle: basedArc.angle,
          points: basedArc.pointA && basedArc.pointB && basedArc.pointC ? [basedArc.pointA, basedArc.pointB, basedArc.pointC] : void 0,
          line: basedArc.labelLine
        };
        "richtext" === labels[i].type ? labelAttribute.width = null !== (_b = basedArc.labelLimit) && void 0 !== _b ? _b : labels[i].attribute.width : labelAttribute.maxLineWidth = null !== (_c = basedArc.labelLimit) && void 0 !== _c ? _c : labels[i].attribute.maxLineWidth, basedArc.refArc && "arc3d" === basedArc.refArc.type && (labelAttribute.anchor3d = [basedArc.circleCenter.x - labelAttribute.x, basedArc.circleCenter.y - labelAttribute.y], labelAttribute.beta = basedArc.refArc.attribute.beta), labels[i].setAttributes(labelAttribute);
      }
    }
    return labels;
  }
  layoutArcLabels(position, attribute, currentMarks, data, textBoundsArray, ellipsisWidth) {
    this._arcLeft.clear(), this._arcRight.clear(), this._ellipsisWidth = ellipsisWidth;
    let maxRadius = 0;
    currentMarks.forEach((currentMarks2) => {
      currentMarks2.attribute.outerRadius > maxRadius && (maxRadius = currentMarks2.attribute.outerRadius);
    }), data.forEach((d, index) => {
      var _a, _b;
      const currentMark = this._idToGraphic.get(d.id), graphicAttribute = currentMark.attribute, center2 = {
        x: null !== (_a = null == graphicAttribute ? void 0 : graphicAttribute.x) && void 0 !== _a ? _a : 0,
        y: null !== (_b = null == graphicAttribute ? void 0 : graphicAttribute.y) && void 0 !== _b ? _b : 0
      };
      if (!isNil_default(data[index]) && !isNil_default(textBoundsArray[index])) {
        const item = data[index] ? data[index] : null, textBounds = textBoundsArray[index] ? textBoundsArray[index] : {
          x1: 0,
          x2: 0,
          y1: 0,
          y2: 0
        }, arcMiddleAngle = (graphicAttribute.startAngle + graphicAttribute.endAngle) / 2, intervalAngle = graphicAttribute.endAngle - graphicAttribute.startAngle, arcQuadrant = computeQuadrant(graphicAttribute.endAngle - intervalAngle / 2), arcMiddle = polarToCartesian(center2, graphicAttribute.outerRadius, arcMiddleAngle), outerArcMiddle = polarToCartesian(center2, maxRadius + attribute.line.line1MinLength, arcMiddleAngle), arc = new ArcInfo(item, arcMiddle, outerArcMiddle, arcQuadrant, intervalAngle, arcMiddleAngle, graphicAttribute.innerRadius, graphicAttribute.outerRadius, center2);
        arc.refArc = currentMark, arc.pointA = polarToCartesian(center2, this.computeDatumRadius(2 * center2.x, 2 * center2.y, graphicAttribute.outerRadius), arc.middleAngle), arc.labelSize = {
          width: textBounds.x2 - textBounds.x1,
          height: textBounds.y2 - textBounds.y1
        }, isQuadrantRight(arc.quadrant) ? this._arcRight.set(arc.refDatum, arc) : isQuadrantLeft(arc.quadrant) && this._arcLeft.set(arc.refDatum, arc);
      }
    });
    const leftArcs = Array.from(this._arcLeft.values()), rightArcs = Array.from(this._arcRight.values()), arcs = [];
    switch (position) {
      case "inside":
      case "inside-inner":
      case "inside-outer":
      case "inside-center":
        arcs.push(...this._layoutInsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutInsideLabels(leftArcs, attribute, currentMarks));
        break;
      default:
        arcs.push(...this._layoutOutsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutOutsideLabels(leftArcs, attribute, currentMarks));
    }
    return arcs;
  }
  _layoutInsideLabels(arcs, attribute, currentMarks) {
    var _a, _b;
    const labelConfig = attribute, spaceWidth = labelConfig.spaceWidth, position = null !== (_a = labelConfig.position) && void 0 !== _a ? _a : "inside", offsetRadius = null !== (_b = labelConfig.offsetRadius) && void 0 !== _b ? _b : -spaceWidth;
    return arcs.forEach((arc) => {
      var _a2, _b2, _c;
      const { labelSize, radian } = arc, innerRadius = arc.innerRadius, outerRadius = arc.outerRadius;
      let limit;
      if (radian < connectLineRadian(outerRadius, labelSize.height)) limit = 0;
      else {
        let minRadius;
        minRadius = radian >= Math.PI ? innerRadius : Math.max(innerRadius, labelSize.height / 2 / Math.tan(radian / 2)), limit = outerRadius - minRadius - spaceWidth;
      }
      true !== labelConfig.rotate && (limit = outerRadius - spaceWidth);
      const text2 = this._getFormatLabelText(arc.refDatum, limit);
      arc.labelText = text2;
      const labelWidth = Math.min(limit, arc.labelSize.width), align = this._computeAlign(arc, attribute);
      let labelRadius, alignOffset = 0;
      if ("inside" === position && (alignOffset = "left" === align ? labelWidth : "right" === align ? 0 : labelWidth / 2), labelRadius = "inside-inner" === position ? innerRadius - offsetRadius + alignOffset : "inside-center" === position ? innerRadius + (outerRadius - innerRadius) / 2 : outerRadius + offsetRadius - alignOffset, arc.labelPosition = polarToCartesian(arc.circleCenter, labelRadius, arc.middleAngle), arc.labelLimit = labelWidth, isGreater(labelWidth, 0) || (arc.labelVisible = false), false !== labelConfig.rotate) {
        arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : arc.middleAngle;
        let offsetAngle = null !== (_c = labelConfig.offsetAngle) && void 0 !== _c ? _c : 0;
        ["inside-inner", "inside-outer"].includes(position) && (offsetAngle += Math.PI / 2), arc.angle += offsetAngle;
      }
    }), arcs;
  }
  _layoutOutsideLabels(arcs, attribute, currentMarks) {
    var _a, _b, _c;
    const center_x = null !== (_a = currentMarks[0].attribute.x) && void 0 !== _a ? _a : 0, height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), labelLayout = attribute.layout, spaceWidth = attribute.spaceWidth;
    if (arcs.forEach((arc) => {
      const direction = isQuadrantLeft(arc.quadrant) ? -1 : 1;
      arc.labelPosition = {
        x: arc.outerCenter.x + direction * (arc.labelSize.width / 2 + this._line2MinLength + spaceWidth),
        y: arc.outerCenter.y
      };
    }), arcs.sort((a3, b) => a3.labelPosition.y - b.labelPosition.y), false !== attribute.coverEnable || "none" === labelLayout.strategy) {
      for (const arc of arcs) {
        const { labelPosition, labelSize } = arc;
        arc.labelLimit = labelSize.width, arc.pointB = isQuadrantLeft(arc.quadrant) ? {
          x: labelPosition.x + labelSize.width / 2 + this._line2MinLength + spaceWidth,
          y: labelPosition.y
        } : {
          x: labelPosition.x - labelSize.width / 2 - this._line2MinLength - spaceWidth,
          y: labelPosition.y
        }, this._computeX(arc, attribute, currentMarks);
      }
      false === attribute.coverEnable && "none" === labelLayout.strategy && this._coverLabels(arcs);
    } else {
      const maxLabels = height / ((null === (_c = attribute.textStyle) || void 0 === _c ? void 0 : _c.fontSize) || 16);
      this._adjustY(arcs, maxLabels, attribute, currentMarks);
      const { minY, maxY: maxY2 } = arcs.reduce((yInfo, arc) => {
        const { y1, y2 } = arc.getLabelBounds();
        return yInfo.minY = Math.max(0, Math.min(y1, yInfo.minY)), yInfo.maxY = Math.min(height, Math.max(y2, yInfo.maxY)), yInfo;
      }, {
        minY: 1 / 0,
        maxY: -1 / 0
      }), halfY = Math.max(Math.abs(height / 2 - minY), Math.abs(maxY2 - height / 2)), r = this._computeLayoutRadius(halfY, attribute, currentMarks);
      for (const arc of arcs) this._computePointB(arc, r, attribute, currentMarks), this._computeX(arc, attribute, currentMarks);
    }
    const width = 2 * center_x;
    return arcs.forEach((arc) => {
      var _a2, _b2;
      arc.labelVisible && (isLess(arc.pointB.x, this._line2MinLength + spaceWidth) || isGreater(arc.pointB.x, width - this._line2MinLength - spaceWidth)) && (arc.labelVisible = false), arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : 0, attribute.offsetAngle && (arc.angle += attribute.offsetAngle), arc.labelLine = Object.assign(Object.assign({}, attribute.line), {
        visible: arc.labelVisible
      });
    }), arcs;
  }
  _computeX(arc, attribute, currentMarks) {
    var _a;
    const center2 = arc.circleCenter, plotLayout_x1 = 0, plotLayout_x2 = this.attribute.width;
    this.attribute.height;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, labelLayoutAlign = null === (_a = attribute.layout) || void 0 === _a ? void 0 : _a.align, spaceWidth = attribute.spaceWidth, { labelPosition, quadrant, pointB } = arc;
    isValidNumber_default(pointB.x * pointB.y) || (arc.pointC = {
      x: NaN,
      y: NaN
    }, labelPosition.x = NaN, arc.labelLimit = 0);
    const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), flag = isQuadrantLeft(quadrant) ? -1 : 1;
    let cx = 0, limit = (flag > 0 ? plotLayout_x2 - pointB.x : pointB.x - plotLayout_x1) + this._alignOffset - this._line2MinLength - spaceWidth;
    "labelLine" === labelLayoutAlign && (cx = (radius + line1MinLength + this._line2MinLength) * flag + center2.x, limit = (flag > 0 ? plotLayout_x2 - cx : cx - plotLayout_x1) - spaceWidth);
    const text2 = this._getFormatLabelText(arc.refDatum, limit);
    arc.labelText = text2;
    let labelWidth = Math.min(limit, arc.labelSize.width);
    switch (labelLayoutAlign) {
      case "labelLine":
        break;
      case "edge":
        cx = flag > 0 ? plotLayout_x2 - labelWidth - spaceWidth : plotLayout_x1 + labelWidth + spaceWidth;
        break;
      default:
        cx = pointB.x + flag * this._line2MinLength;
    }
    labelWidth = Math.max(this._ellipsisWidth, labelWidth);
    const needAdjustLimit = labelWidth < arc.labelSize.width - 1;
    arc.labelLimit = needAdjustLimit ? labelWidth : null, arc.pointC = {
      x: cx,
      y: labelPosition.y
    };
    const align = this._computeAlign(arc, attribute), targetCenterOffset = getAlignOffset(align) * (needAdjustLimit ? labelWidth : arc.labelSize.width);
    "edge" === labelLayoutAlign ? (labelPosition.x = (flag > 0 ? plotLayout_x2 : plotLayout_x1) - flag * targetCenterOffset + flag * this._alignOffset, arc.pointC.x += flag * this._alignOffset) : labelPosition.x = cx + flag * (this._alignOffset + spaceWidth + targetCenterOffset);
  }
  _computeAlign(arc, attribute) {
    var _a, _b, _c, _d, _e, _f;
    const labelConfig = attribute, textAlign = null !== (_b = null === (_a = labelConfig.textStyle) || void 0 === _a ? void 0 : _a.textAlign) && void 0 !== _b ? _b : null === (_c = labelConfig.textStyle) || void 0 === _c ? void 0 : _c.align, layoutAlign = null !== (_e = null === (_d = labelConfig.layout) || void 0 === _d ? void 0 : _d.textAlign) && void 0 !== _e ? _e : null === (_f = labelConfig.layout) || void 0 === _f ? void 0 : _f.align;
    return "inside" !== labelConfig.position ? isNil_default(textAlign) || "auto" === textAlign ? "edge" === layoutAlign ? isQuadrantLeft(arc.quadrant) ? "left" : "right" : isQuadrantLeft(arc.quadrant) ? "right" : "left" : textAlign : isNil_default(textAlign) || "auto" === textAlign ? "center" : textAlign;
  }
  _getFormatLabelText(value, limit) {
    var _a;
    return null !== (_a = null == value ? void 0 : value.text) && void 0 !== _a ? _a : "";
  }
  _adjustY(arcs, maxLabels, attribute, currentMarks) {
    var _a, _b;
    _a = currentMarks[0].attribute.x;
    const plotRect_height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), labelLayout = attribute.layout;
    if ("vertical" === labelLayout.strategy) {
      let delta, lastY = 0;
      const len = arcs.length;
      if (len <= 0) return;
      for (let i = 0; i < len; i++) {
        const { y1 } = arcs[i].getLabelBounds();
        if (delta = y1 - lastY, isLess(delta, 0)) {
          const index = this._shiftY(arcs, i, len - 1, -delta);
          this._shiftY(arcs, index, 0, delta / 2);
        }
        const { y2 } = arcs[i].getLabelBounds();
        lastY = y2;
      }
      const { y1: firstY1 } = arcs[0].getLabelBounds();
      delta = firstY1 - 0, isLess(delta, 0) && this._shiftY(arcs, 0, len - 1, -delta);
      for (let i = arcs.length - 1; i >= 0 && arcs[i].getLabelBounds().y2 > plotRect_height; i--) arcs[i].labelVisible = false;
    } else if ("none" !== labelLayout.strategy) {
      const priorityArcs = arcs.map((arc, i) => ({
        arc,
        originIndex: i,
        priorityIndex: 0
      }));
      priorityArcs.sort((a3, b) => b.arc.radian - a3.arc.radian), priorityArcs.forEach((priorityArc, i) => {
        priorityArc.priorityIndex = i, priorityArc.arc.labelVisible = false;
      });
      let topLabelIndex = 1 / 0, bottomLabelIndex = -1 / 0;
      for (let i = 0; i < maxLabels && i < arcs.length; i++) {
        this._storeY(arcs);
        const arc = priorityArcs[i].arc;
        this._computeYRange(arc, attribute, currentMarks), arc.labelVisible = true;
        const curY = arc.labelPosition.y, { lastIndex, nextIndex } = this._findNeighborIndex(arcs, priorityArcs[i]), lastArc = arcs[lastIndex], nextArc = arcs[nextIndex];
        if (-1 === lastIndex && -1 !== nextIndex) {
          const nextY = nextArc.labelPosition.y;
          curY > nextY ? arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2 : this._twoWayShift(arcs, arc, nextArc, nextIndex);
        } else if (-1 !== lastIndex && -1 === nextIndex) {
          const lastY = lastArc.labelPosition.y;
          curY < lastY ? arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2 : this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex);
        } else if (-1 !== lastIndex && -1 !== nextIndex) {
          const lastY = lastArc.labelPosition.y, nextY = nextArc.labelPosition.y;
          curY > nextY ? (arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2, this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex)) : curY < lastY ? (arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2, this._twoWayShift(arcs, arc, nextArc, nextIndex)) : (this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex), this._twoWayShift(arcs, arc, nextArc, nextIndex));
        }
        const nextTopIndex = Math.min(topLabelIndex, priorityArcs[i].originIndex), nextBottomIndex = Math.max(bottomLabelIndex, priorityArcs[i].originIndex);
        let delta;
        if (delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0) && this._shiftY(arcs, nextBottomIndex, 0, -delta), delta = arcs[nextTopIndex].getLabelBounds().y1 - 0, isLess(delta, 0) && this._shiftY(arcs, nextTopIndex, arcs.length - 1, -delta), delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0)) {
          arc.labelVisible = false, this._restoreY(arcs);
          break;
        }
        labelLayout.tangentConstraint && !this._checkYRange(arcs) ? (arc.labelVisible = false, this._restoreY(arcs)) : (topLabelIndex = nextTopIndex, bottomLabelIndex = nextBottomIndex);
      }
    }
  }
  _shiftY(arcs, start, end, delta) {
    const direction = start < end ? 1 : -1;
    let index = start;
    for (; -1 !== index; ) {
      arcs[index].labelPosition.y += delta;
      const nextIndex = this._findNextVisibleIndex(arcs, index, end, direction);
      if (nextIndex >= 0 && nextIndex < arcs.length) {
        const { y1: curY1, y2: curY2 } = arcs[index].getLabelBounds(), { y1: nextY1, y2: nextY2 } = arcs[nextIndex].getLabelBounds();
        if (direction > 0 && curY2 < nextY1 || direction < 0 && curY1 > nextY2) return index;
      }
      index = nextIndex;
    }
    return end;
  }
  _findNextVisibleIndex(arcs, start, end, direction) {
    const diff = (end - start) * direction;
    for (let i = 1; i <= diff; i++) {
      const index = start + i * direction;
      if (arcs[index].labelVisible) return index;
    }
    return -1;
  }
  _computePointB(arc, r, attribute, currentMarks) {
    const labelConfig = attribute;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = labelConfig.line.line1MinLength;
    if ("none" === labelConfig.layout.strategy) arc.pointB = {
      x: arc.outerCenter.x,
      y: arc.outerCenter.y
    };
    else {
      const center2 = arc.circleCenter, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), { labelPosition, quadrant } = arc, rd = r - Math.max(radius + line1MinLength, arc.outerRadius), x = Math.sqrt(r ** 2 - Math.abs(center2.y - labelPosition.y) ** 2) - rd;
      isValidNumber_default(x) ? arc.pointB = {
        x: center2.x + x * (isQuadrantLeft(quadrant) ? -1 : 1),
        y: labelPosition.y
      } : arc.pointB = {
        x: NaN,
        y: NaN
      };
    }
  }
  _storeY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.lastLabelY = arc.labelPosition.y);
  }
  _computeYRange(arc, attribute, currentMarks) {
    const center2 = arc.circleCenter, plotRect = {
      width: 2 * center2.x,
      height: 2 * center2.y
    };
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, { width, height } = plotRect, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), r = this._computeLayoutRadius(height / 2, attribute, currentMarks), cx = Math.abs(arc.center.x - width / 2), cy = arc.center.y - height / 2;
    let a3, b, c3;
    if (isNumberClose(width / 2, cx)) a3 = 0, b = 1, c3 = -cy;
    else if (isNumberClose(height / 2, cy)) a3 = 1, b = 0, c3 = -cx;
    else {
      const k2 = -1 / (cy / cx);
      a3 = k2, b = -1, c3 = cy - k2 * cx;
    }
    const points = lineCirclePoints(a3, b, c3, line1MinLength + radius - r, 0, r);
    if (points.length < 2) return;
    let min3, max3;
    points[0].x > points[1].x && points.reverse(), points[0].x < 0 ? isNumberClose(points[0].y, points[1].y) ? isGreater(arc.middleAngle, -Math.PI) && isLess(arc.middleAngle, 0) || isGreater(arc.middleAngle, Math.PI) && isLess(arc.middleAngle, 2 * Math.PI) ? (min3 = 0, max3 = points[1].y + height / 2) : (min3 = points[1].y + height / 2, max3 = height) : points[0].y < points[1].y ? (min3 = 0, max3 = points[1].y + height / 2) : (min3 = points[1].y + height / 2, max3 = plotRect.height) : (min3 = Math.min(points[0].y, points[1].y) + height / 2, max3 = Math.max(points[0].y, points[1].y) + height / 2), arc.labelYRange = [min3, max3];
  }
  _computeLayoutRadius(halfYLength, attribute, currentMarks) {
    const labelConfig = attribute, layoutArcGap = labelConfig.layoutArcGap, line1MinLength = labelConfig.line.line1MinLength;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), outerR = this.computeRadius(radiusRatio, attribute.width, attribute.height) + line1MinLength, a3 = outerR - layoutArcGap;
    return Math.max((a3 ** 2 + halfYLength ** 2) / (2 * a3), outerR);
  }
  _findNeighborIndex(arcs, priorityArc) {
    const index = priorityArc.originIndex;
    let lastIndex = -1, nextIndex = -1;
    for (let i = index - 1; i >= 0; i--) if (arcs[i].labelVisible) {
      lastIndex = i;
      break;
    }
    for (let i = index + 1; i < arcs.length; i++) if (arcs[i].labelVisible) {
      nextIndex = i;
      break;
    }
    return {
      lastIndex,
      nextIndex
    };
  }
  _twoWayShift(arcs, lastArc, nextArc, nextIndex) {
    const delta = nextArc.getLabelBounds().y1 - lastArc.getLabelBounds().y2;
    if (isLess(delta, 0)) {
      const i = this._shiftY(arcs, nextIndex, arcs.length - 1, -delta);
      this._shiftY(arcs, i, 0, delta / 2);
    }
  }
  _restoreY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.labelPosition.y = arc.lastLabelY);
  }
  _checkYRange(arcs) {
    for (const arc of arcs) {
      const { labelYRange, labelPosition } = arc;
      if (arc.labelVisible && labelYRange && (isLess(labelPosition.y, labelYRange[0]) || isGreater(labelPosition.y, labelYRange[1]))) return false;
    }
    return true;
  }
  _coverLabels(arcs) {
    if (arcs.length <= 1) return;
    let lastBounds = arcs[0].getLabelBounds();
    for (let i = 1; i < arcs.length; i++) {
      const bounds = arcs[i].getLabelBounds();
      checkBoundsOverlap(lastBounds, bounds) ? arcs[i].labelVisible = false : lastBounds = bounds;
    }
  }
  _getLabelLinePoints(text2, baseMark) {
    return text2.attribute.points;
  }
  _createLabelLine(text2, baseMark) {
    var _a, _b, _c, _d, _e;
    const { line: line2 = {}, visible } = text2.attribute, lineGraphic = super._createLabelLine(text2, baseMark);
    if (lineGraphic && (lineGraphic.setAttributes({
      visible: null === (_c = null !== (_a = line2.visible && visible) && void 0 !== _a ? _a : null === (_b = text2.attribute) || void 0 === _b ? void 0 : _b.visible) || void 0 === _c || _c,
      lineWidth: null !== (_e = null === (_d = line2.style) || void 0 === _d ? void 0 : _d.lineWidth) && void 0 !== _e ? _e : 1
    }), line2.smooth && lineGraphic.setAttributes({
      curveType: "basis"
    }), "arc3d" === baseMark.type && baseMark)) {
      const { beta, x, y } = baseMark.attribute;
      lineGraphic.setAttributes({
        beta,
        anchor3d: [x, y]
      });
    }
    return lineGraphic;
  }
  computeRadius(r, width, height, k2) {
    return this.computeLayoutRadius(width || 0, height || 0) * r * (isNil_default(k2) ? 1 : k2);
  }
  computeLayoutRadius(width, height) {
    return Math.min(width / 2, height / 2);
  }
  _canPlaceInside(textBound, shapeBound) {
    return "inside" === this.attribute.position || "inside-center" === this.attribute.position;
  }
  computeLayoutOuterRadius(r, width, height) {
    return r / (Math.min(width, height) / 2);
  }
  computeDatumRadius(width, height, outerRadius) {
    const outerRadiusRatio = this.computeLayoutOuterRadius(outerRadius, width, height);
    return this.computeLayoutRadius(width || 0, height || 0) * outerRadiusRatio;
  }
};
ArcLabel.defaultAttributes = {
  coverEnable: false,
  spaceWidth: 5,
  layoutArcGap: 6,
  textStyle: {
    visible: true,
    fontSize: 14,
    fontWeight: "normal",
    fillOpacity: 1,
    boundsPadding: [-1, 0, -1, 0],
    ellipsis: true
  },
  position: "outside",
  line: {
    visible: true,
    line1MinLength: 20,
    line2MinLength: 10
  },
  layout: {
    align: "arc",
    strategy: "priority",
    tangentConstraint: true
  }
};
var registerArcDataLabel = () => {
  registerLabelComponent("arc", ArcLabel);
};

// node_modules/@visactor/vrender-components/es/label/dataLabel.js
var __rest10 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var DataLabel = class _DataLabel extends AbstractComponent {
  constructor(attributes, options) {
    const { dataLabels } = attributes, restAttributes = __rest10(attributes, ["dataLabels"]);
    super((null == options ? void 0 : options.skipDefault) ? attributes : Object.assign({
      dataLabels
    }, merge({}, _DataLabel.defaultAttributes, restAttributes))), this.name = "data-label";
  }
  render() {
    var _a;
    const { dataLabels, size } = this.attribute;
    if (!dataLabels || 0 === dataLabels.length) return;
    const { width = 0, height = 0, padding } = size || {};
    if (!width || !height || !isValidNumber_default(height * width)) return;
    this._componentMap || (this._componentMap = /* @__PURE__ */ new Map());
    const tool = bitmapTool(width, height, padding), bitmap2 = tool.bitmap(), currentComponentMap = /* @__PURE__ */ new Map(), prevComponentMap = this._componentMap;
    for (let i = 0; i < dataLabels.length; i++) {
      const dataLabel2 = dataLabels[i], labelComponent = getLabelComponent(dataLabel2.type) || LabelBase;
      if (labelComponent) {
        const { baseMarkGroupName, type } = dataLabel2, id = null !== (_a = dataLabel2.id) && void 0 !== _a ? _a : `${baseMarkGroupName}-${type}-${i}`;
        "arc" === dataLabel2.type && (dataLabel2.width = size.width, dataLabel2.height = size.height);
        let component2 = this._componentMap.get(id);
        component2 ? (component2.setBitmapTool(tool), component2.setBitmap(bitmap2), component2.setAttributes(dataLabel2), currentComponentMap.set(id, component2)) : (component2 = new labelComponent(dataLabel2), component2.setBitmap(bitmap2), component2.setBitmapTool(tool), this.add(component2), currentComponentMap.set(id, component2));
      }
    }
    prevComponentMap.forEach((cp, key) => {
      currentComponentMap.get(key) || this.removeChild(cp);
    }), this._componentMap = currentComponentMap;
  }
  setLocation(point6) {
    this.translateTo(point6.x, point6.y);
  }
  disableAnimation() {
    this._componentMap.forEach((component2) => {
      component2.disableAnimation();
    });
  }
  enableAnimation() {
    this._componentMap.forEach((component2) => {
      component2.enableAnimation();
    });
  }
};
DataLabel.defaultAttributes = {
  pickable: false
};

// node_modules/@visactor/vrender-components/es/axis/grid/base.js
function getArcPath(center2, points, reverse, closed) {
  let path = "";
  if (!center2 || 0 === points.length) return path;
  const firstPoint = points[0], radius = PointService.distancePP(center2, firstPoint), sweepFlag = reverse ? 0 : 1;
  return closed ? path += `M${center2.x},${center2.y - radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y + radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y - radius}Z` : points.forEach((point6, index) => {
    0 === index ? path = `M${point6.x},${point6.y}` : path += `A${radius},${radius},0,0,${sweepFlag},${point6.x},${point6.y}`;
  }), path;
}
function getRegionPath(from, to, attribute) {
  const { type, closed } = attribute, reversePoints = to.slice(0).reverse();
  let regionPath = "", nextPath = "";
  if ("line" === type && attribute.smoothLink && attribute.center) {
    const fromStart = from[0], toEnd = reversePoints[0], center2 = attribute.center;
    regionPath = getPolygonPath(from, !!closed), nextPath = getPolygonPath(reversePoints, !!closed);
    const toEndRadius = PointService.distancePP(toEnd, center2), fromStartRadius = PointService.distancePP(fromStart, center2);
    regionPath += `A${toEndRadius},${toEndRadius},0,0,1,${toEnd.x},${toEnd.y}L${toEnd.x},${toEnd.y}`, nextPath += `A${fromStartRadius},${fromStartRadius},0,0,0,${fromStart.x},${fromStart.y}`;
  } else if ("circle" === type) {
    const { center: center2 } = attribute;
    regionPath = getArcPath(center2, from, false, !!closed), nextPath = getArcPath(center2, reversePoints, true, !!closed);
  } else "line" !== type && "polygon" !== type || (regionPath = getPolygonPath(from, !!closed), nextPath = getPolygonPath(reversePoints, !!closed));
  return closed ? regionPath += nextPath : (nextPath = "L" + nextPath.substring(1), regionPath += nextPath, regionPath += "Z"), regionPath;
}
var BaseGrid = class _BaseGrid extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis-grid", this.data = [];
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView);
    const { items, visible } = this.attribute;
    items && items.length && false !== visible && (this.data = this._transformItems(items), this._renderGrid(this._innerView));
  }
  getVerticalCoord(point6, offset, inside) {
    return getVerticalCoord(point6, this.getVerticalVector(offset, inside, point6));
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  _renderGrid(container2) {
    const { visible } = this.attribute.subGrid || {};
    visible && this._renderGridByType(true, container2), this._renderGridByType(false, container2);
  }
  _renderGridByType(isSubGrid, container2) {
    const gridAttrs = merge({}, this.attribute, this.getGridAttribute(isSubGrid)), { type, items, style, closed, alternateColor, depth = 0 } = gridAttrs, name = isSubGrid ? `${AXIS_ELEMENT_NAME.grid}-sub` : `${AXIS_ELEMENT_NAME.grid}`;
    if (items.forEach((item, index) => {
      const { id, points } = item;
      let path = "";
      if ("line" === type || "polygon" === type) path = getPolygonPath(points, !!closed);
      else if ("circle" === type) {
        const { center: center2 } = this.attribute;
        path = getArcPath(center2, points, false, !!closed);
      }
      const shape = graphicCreator.path(Object.assign({
        path,
        z: depth
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id}`), container2.add(shape);
    }), depth && "line" === type && items.forEach((item, index) => {
      const { id, points } = item, nextPoints = [];
      nextPoints.push(points[0]);
      const dir_x = points[1].x - points[0].x, dir_y = points[1].y - points[0].y, dirLen = Math.sqrt(dir_x * dir_x + dir_y * dir_y), ratio = depth / dirLen;
      nextPoints.push({
        x: points[0].x + dir_x * ratio,
        y: points[0].y + dir_y * ratio
      });
      const path = getPolygonPath(nextPoints, !!closed), deltaX = abs(nextPoints[0].x - nextPoints[1].x), deltaY = abs(nextPoints[0].y - nextPoints[1].y), shape = graphicCreator.path(Object.assign({
        path,
        z: 0,
        alpha: deltaX > deltaY ? (points[1].x - points[0].x > 0 ? -1 : 1) * pi / 2 : 0,
        beta: deltaX < deltaY ? -pi / 2 : 0,
        anchor3d: deltaX > deltaY ? [nextPoints[0].x, 0] : [0, nextPoints[0].y]
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id}`), container2.add(shape);
    }), items.length > 1 && alternateColor) {
      const colors = isArray_default(alternateColor) ? alternateColor : [alternateColor, "transparent"], getColor = (index) => colors[index % colors.length], originalItems = this.attribute.items, firstItem = originalItems[0], lastItem = originalItems[originalItems.length - 1], noZero = !isNumberClose(firstItem.value, 0) && !isNumberClose(lastItem.value, 0), noOne = !isNumberClose(firstItem.value, 1) && !isNumberClose(lastItem.value, 1), allPoints = [], isDesc = firstItem.value > lastItem.value;
      (isDesc && noOne || !isDesc && noZero) && allPoints.push(this.getGridPointsByValue(isDesc ? 1 : 0)), items.forEach((item) => {
        allPoints.push(item.points);
      }), (isDesc && noZero || !isDesc && noOne) && allPoints.push(this.getGridPointsByValue(isDesc ? 0 : 1));
      for (let index = 0; index < allPoints.length - 1; index++) {
        const path = getRegionPath(allPoints[index], allPoints[index + 1], gridAttrs), shape = graphicCreator.path({
          path,
          fill: getColor(index)
        });
        shape.name = `${name}-region`, shape.id = this._getNodeId(`${name}-region-${index}`), container2.add(shape);
      }
    }
  }
  _getNodeId(id) {
    return `${this.id}-${id}`;
  }
  _parseTickSegment() {
    let tickSegment = 1;
    return this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value), tickSegment;
  }
  _getPointsOfSubGrid(tickSegment, alignWithLabel) {
    const tickLineCount = this.data.length, points = [];
    return tickLineCount >= 2 && this.data.forEach((item) => {
      let tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value)) return;
        tickValue = value;
      }
      points.push({
        value: tickValue
      });
    }), points;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};
BaseGrid.defaultAttributes = {
  style: {
    lineWidth: 1,
    stroke: "#999",
    strokeOpacity: 1,
    lineDash: [4, 4]
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  }
};

// node_modules/@visactor/vrender-components/es/axis/grid/line.js
loadLineAxisGridComponent();
var LineAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  _getGridPoint(gridType, point6) {
    let gridPoints;
    if ("line" === gridType) {
      const { length: length2 } = this.attribute;
      gridPoints = [point6, this.getVerticalCoord(point6, length2, true)];
    } else if ("circle" === gridType || "polygon" === gridType) {
      const { center: center2, sides = 6, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, distance2 = PointService.distancePP(center2, point6);
      gridPoints = getCirclePoints(center2, sides, distance2, startAngle, endAngle);
    }
    return gridPoints;
  }
  getGridPointsByValue(value) {
    const basePoint = this.getTickCoord(value);
    return this._getGridPoint(this.attribute.type, basePoint);
  }
  getGridAttribute(isSubGrid) {
    const { type: gridType, alignWithLabel = true } = this.attribute, tickSegment = this._parseTickSegment();
    let gridAttribute, items = [];
    if (isSubGrid) {
      gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
      const subGridItems = [], { count: subCount = 4 } = gridAttribute;
      if (this.data.length >= 2) {
        const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
        for (let i = 0; i < points.length - 1; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: this.getGridPointsByValue(pre.value),
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value;
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: this.getGridPointsByValue(value),
              datum: {}
            });
          }
          i === points.length - 2 && subGridItems.push({
            id: `sub-${i}-${subCount + 1}`,
            points: this.getGridPointsByValue(next.value),
            datum: {}
          });
        }
        items = subGridItems;
      }
    } else {
      gridAttribute = this.attribute;
      const gridItems = [];
      this.data.forEach((item) => {
        let { point: point6 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point6 = this.getTickCoord(value);
        }
        gridItems.push({
          id: item.label,
          datum: item,
          points: this._getGridPoint(gridType, point6)
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items
    });
  }
};
mixin(LineAxisGrid, LineAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/grid/circle.js
var __rest11 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisGridComponent();
var CircleAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  getGridPointsByValue(value) {
    const basePoint = this.getTickCoord(value), { radius, innerRadius = 0 } = this.attribute;
    return [basePoint, this.getVerticalCoord(basePoint, radius - innerRadius, true)];
  }
  getGridAttribute(isSubGrid) {
    let gridAttribute, items = [];
    const _a = this.attribute, { radius, innerRadius = 0, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center: center2, subGrid } = _a, grid2 = __rest11(_a, ["radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid"]), { alignWithLabel = true } = grid2 || {}, length2 = radius - innerRadius, tickSegment = this._parseTickSegment();
    if (isSubGrid) {
      gridAttribute = merge({}, grid2, subGrid);
      const subGridItems = [], { count: subCount = 4 } = subGrid || {}, tickLineCount = this.data.length;
      if (tickLineCount >= 2) {
        const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
        for (let i = 0; i < tickLineCount; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length2, true)],
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment), point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, true);
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: [point6, endPoint],
              datum: {}
            });
          }
        }
        Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 && subGridItems.push(subGridItems[0]), items = subGridItems;
      }
    } else {
      gridAttribute = grid2;
      const gridItems = [];
      let data;
      data = Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? [...this.data].concat(this.data[0]) : this.data, data.forEach((item) => {
        let { point: point6 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point6 = this.getTickCoord(value);
        }
        const endPoint = this.getVerticalCoord(point6, length2, true);
        gridItems.push({
          id: item.id,
          points: [point6, endPoint],
          datum: item
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items,
      center: center2,
      type: "line"
    });
  }
};
mixin(CircleAxisGrid, CircleAxisMixin);

// node_modules/@visactor/vrender-components/es/data-zoom/config.js
var DEFAULT_HANDLER_PATH = "M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z";
var DEFAULT_DATA_ZOOM_ATTRIBUTES = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  zoomLock: false,
  minSpan: 0,
  maxSpan: 1,
  delayType: "throttle",
  delayTime: 0,
  realTime: true,
  backgroundStyle: {
    fill: "white",
    stroke: "#D1DBEE",
    lineWidth: 1,
    cornerRadius: 2
  },
  dragMaskStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2
  },
  backgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1,
      fill: "#F6F8FC"
    },
    line: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1
    }
  },
  selectedBackgroundStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.5
  },
  selectedBackgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#B0C8F9",
      lineWidth: 1,
      fill: "#fbb934"
    },
    line: {
      visible: true,
      stroke: "#fbb934",
      lineWidth: 1
    }
  },
  middleHandlerStyle: {
    visible: true,
    background: {
      size: 8,
      style: {
        fill: "white",
        stroke: "#B0C8F9",
        cornerRadius: 2
      }
    },
    icon: {
      size: 6,
      fill: "white",
      stroke: "#B0C8F9",
      symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
      lineWidth: 0.5
    }
  },
  startHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  endHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  startTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  },
  endTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  }
};
var DEFAULT_HANDLER_ATTR_MAP = {
  horizontal: {
    angle: 0,
    strokeBoundsBuffer: 0,
    boundsPadding: 2,
    pickMode: "imprecise",
    cursor: "ew-resize"
  },
  vertical: {
    angle: Math.PI / 180 * 90,
    cursor: "ns-resize",
    boundsPadding: 2,
    pickMode: "imprecise",
    strokeBoundsBuffer: 0
  }
};

// node_modules/@visactor/vrender-components/es/data-zoom/type.js
var DataZoomActiveTag;
!function(DataZoomActiveTag2) {
  DataZoomActiveTag2.startHandler = "startHandler", DataZoomActiveTag2.endHandler = "endHandler", DataZoomActiveTag2.middleHandler = "middleHandler", DataZoomActiveTag2.background = "background";
}(DataZoomActiveTag || (DataZoomActiveTag = {}));

// node_modules/@visactor/vrender-components/es/data-zoom/register.js
function loadDataZoomComponent() {
  loadTagComponent(), registerRect(), registerSymbol(), registerArea(), registerLine();
}

// node_modules/@visactor/vrender-components/es/data-zoom/data-zoom.js
var __rest12 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var delayMap2 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadDataZoomComponent();
var DataZoom = class _DataZoom extends AbstractComponent {
  setPropsFromAttrs() {
    const { start, end, orient, previewData, previewPointsX, previewPointsY, previewPointsX1, previewPointsY1 } = this.attribute;
    start && (this.state.start = start), end && (this.state.end = end);
    const { width, height } = this.getLayoutAttrFromConfig();
    this._spanCache = this.state.end - this.state.start, this._isHorizontal = "top" === orient || "bottom" === orient, this._layoutCache.max = this._isHorizontal ? width : height, this._layoutCache.attPos = this._isHorizontal ? "x" : "y", this._layoutCache.attSize = this._isHorizontal ? "width" : "height", previewData && (this._previewData = previewData), isFunction_default(previewPointsX) && (this._previewPointsX = previewPointsX), isFunction_default(previewPointsY) && (this._previewPointsY = previewPointsY), isFunction_default(previewPointsX1) && (this._previewPointsX1 = previewPointsX1), isFunction_default(previewPointsY1) && (this._previewPointsY1 = previewPointsY1);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DataZoom.defaultAttributes, attributes)), this.name = "dataZoom", this._previewData = [], this._activeState = false, this._activeCache = {
      startPos: {
        x: 0,
        y: 0
      },
      lastPos: {
        x: 0,
        y: 0
      }
    }, this._layoutCache = {
      attPos: "x",
      attSize: "width",
      max: 0
    }, this.state = {
      start: 0,
      end: 1
    }, this._statePointToData = (state) => state, this._handleTouchMove = (e) => {
      this._activeState && e.preventDefault();
    }, this._onHandlerPointerDown = (e, tag) => {
      this._clearDragEvents(), "start" === tag ? (this._activeTag = DataZoomActiveTag.startHandler, this._activeItem = this._startHandlerMask) : "end" === tag ? (this._activeTag = DataZoomActiveTag.endHandler, this._activeItem = this._endHandlerMask) : "middleRect" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerRect) : "middleSymbol" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerSymbol) : "background" === tag && (this._activeTag = DataZoomActiveTag.background, this._activeItem = this._background), this._activeState = true, this._activeCache.startPos = this.eventPosToStagePos(e), this._activeCache.lastPos = this.eventPosToStagePos(e);
      const evtTarget = "browser" === vglobal.env ? vglobal : this.stage, triggers = getEndTriggersOfDrag();
      evtTarget.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        evtTarget.addEventListener(trigger, this._onHandlerPointerUp);
      });
    }, this._pointerMove = (e) => {
      const { start: startAttr, end: endAttr, brushSelect, realTime = true } = this.attribute, pos = this.eventPosToStagePos(e), { attPos, max: max3 } = this._layoutCache, dis = (pos[attPos] - this._activeCache.lastPos[attPos]) / max3;
      let { start, end } = this.state;
      this._activeState && (this._activeTag === DataZoomActiveTag.middleHandler ? this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + dis) : this._activeTag === DataZoomActiveTag.startHandler ? start + dis > end ? (start = end, end = start + dis, this._activeTag = DataZoomActiveTag.endHandler) : start += dis : this._activeTag === DataZoomActiveTag.endHandler && (end + dis < start ? (end = start, start = end + dis, this._activeTag = DataZoomActiveTag.startHandler) : end += dis), this._activeCache.lastPos = pos, brushSelect && this.renderDragMask()), start = Math.min(Math.max(start, 0), 1), end = Math.min(Math.max(end, 0), 1), startAttr === start && endAttr === end || (this.setStateAttr(start, end, true), realTime && this._dispatchEvent("change", {
        start,
        end,
        tag: this._activeTag
      }));
    }, this._onHandlerPointerMove = 0 === this.attribute.delayTime ? this._pointerMove : delayMap2[this.attribute.delayType](this._pointerMove, this.attribute.delayTime), this._onHandlerPointerUp = (e) => {
      const { start, end, brushSelect, realTime = true } = this.attribute;
      if (this._activeState && this._activeTag === DataZoomActiveTag.background) {
        const pos = this.eventPosToStagePos(e);
        this.backgroundDragZoom(this._activeCache.startPos, pos);
      }
      this._activeState = false, brushSelect && this.renderDragMask(), this._dispatchEvent("change", {
        start: this.state.start,
        end: this.state.end,
        tag: this._activeTag
      }), this._clearDragEvents();
    };
    const { position, showDetail } = attributes;
    this._activeCache.startPos = position, this._activeCache.lastPos = position, this._showText = "auto" !== showDetail && showDetail, this.setPropsFromAttrs();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this.setPropsFromAttrs();
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return void this.setAttribute("childrenPickable", false);
    const { showDetail, brushSelect } = this.attribute;
    this._startHandlerMask && this._startHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "start")), this._endHandlerMask && this._endHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "end")), this._middleHandlerSymbol && this._middleHandlerSymbol.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleSymbol")), this._middleHandlerRect && this._middleHandlerRect.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleRect"));
    const selectedTag = brushSelect ? "background" : "middleRect";
    this._selectedBackground && this._selectedBackground.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), brushSelect && this._background && this._background.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), brushSelect && this._previewGroup && this._previewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), this._selectedPreviewGroup && this._selectedPreviewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), "auto" === showDetail && (this.addEventListener("pointerenter", this._onHandlerPointerEnter), this.addEventListener("pointerleave", this._onHandlerPointerLeave)), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    });
  }
  dragMaskSize() {
    const { position } = this.attribute, { attPos, max: max3 } = this._layoutCache;
    return this._activeCache.lastPos[attPos] - position[attPos] > max3 ? max3 + position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - position[attPos] < 0 ? position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - this._activeCache.startPos[attPos];
  }
  setStateAttr(start, end, shouldRender) {
    const { zoomLock = false, minSpan = 0, maxSpan = 1 } = this.attribute, span = end - start;
    span !== this._spanCache && (zoomLock || span < minSpan || span > maxSpan) || (this._spanCache = span, this.state.start = start, this.state.end = end, shouldRender && this.setAttributes({
      start,
      end
    }));
  }
  eventPosToStagePos(e) {
    var _a, _b;
    return null !== (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventPointTransform(e)) && void 0 !== _b ? _b : {
      x: 0,
      y: 0
    };
  }
  _clearDragEvents() {
    const evtTarget = "browser" === vglobal.env ? vglobal : this.stage, triggers = getEndTriggersOfDrag();
    evtTarget.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      evtTarget.removeEventListener(trigger, this._onHandlerPointerUp);
    }), this.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    });
  }
  _onHandlerPointerEnter(e) {
    this._showText = true, this.renderText();
  }
  _onHandlerPointerLeave(e) {
    this._showText = false, this.renderText();
  }
  backgroundDragZoom(startPos, endPos) {
    const { attPos, max: max3 } = this._layoutCache, { position } = this.attribute, startPosInComponent = startPos[attPos] - position[attPos], endPosInComponent = endPos[attPos] - position[attPos], start = Math.min(Math.max(Math.min(startPosInComponent, endPosInComponent) / max3, 0), 1), end = Math.min(Math.max(Math.max(startPosInComponent, endPosInComponent) / max3, 0), 1);
    Math.abs(start - end) < 0.01 ? this.moveZoomWithMiddle(start) : this.setStateAttr(start, end, false);
  }
  moveZoomWithMiddle(middle) {
    let offset = middle - (this.state.start + this.state.end) / 2;
    0 !== offset && (offset > 0 ? this.state.end + offset > 1 && (offset = 1 - this.state.end) : offset < 0 && this.state.start + offset < 0 && (offset = -this.state.start), this.setStateAttr(this.state.start + offset, this.state.end + offset, false));
  }
  renderDragMask() {
    const { dragMaskStyle } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    this._isHorizontal ? this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x, position.x, position.x + width),
      y: position.y,
      width: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0,
      height
    }, dragMaskStyle), "rect") : this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: position.x,
      y: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y, position.y, position.y + height),
      width,
      height: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0
    }, dragMaskStyle), "rect");
  }
  isTextOverflow(componentBoundsLike, textBounds, layout2) {
    if (!textBounds) return false;
    if (this._isHorizontal) {
      if ("start" === layout2) {
        if (textBounds.x1 < componentBoundsLike.x1) return true;
      } else if (textBounds.x2 > componentBoundsLike.x2) return true;
    } else if ("start" === layout2) {
      if (textBounds.y1 < componentBoundsLike.y1) return true;
    } else if (textBounds.y2 > componentBoundsLike.y2) return true;
    return false;
  }
  setTextAttr(startTextBounds, endTextBounds) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { startTextStyle, endTextStyle } = this.attribute, { formatMethod: startTextFormat } = startTextStyle, restStartTextStyle = __rest12(startTextStyle, ["formatMethod"]), { formatMethod: endTextFormat } = endTextStyle, restEndTextStyle = __rest12(endTextStyle, ["formatMethod"]), { start, end } = this.state;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end);
    const { position, width, height } = this.getLayoutAttrFromConfig(), startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue, endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue, componentBoundsLike = {
      x1: position.x,
      y1: position.y,
      x2: position.x + width,
      y2: position.y + height
    };
    let startTextPosition, endTextPosition, startTextAlignStyle, endTextAlignStyle;
    this._isHorizontal ? (startTextPosition = {
      x: position.x + start * width,
      y: position.y + height / 2
    }, endTextPosition = {
      x: position.x + end * width,
      y: position.y + height / 2
    }, startTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "left" : "right",
      textBaseline: null !== (_b = null === (_a = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _a ? void 0 : _a.textBaseline) && void 0 !== _b ? _b : "middle"
    }, endTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "right" : "left",
      textBaseline: null !== (_d = null === (_c = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _c ? void 0 : _c.textBaseline) && void 0 !== _d ? _d : "middle"
    }) : (startTextPosition = {
      x: position.x + width / 2,
      y: position.y + start * height
    }, endTextPosition = {
      x: position.x + width / 2,
      y: position.y + end * height
    }, startTextAlignStyle = {
      textAlign: null !== (_f = null === (_e = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _e ? void 0 : _e.textAlign) && void 0 !== _f ? _f : "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "top" : "bottom"
    }, endTextAlignStyle = {
      textAlign: null !== (_h = null === (_g = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _g ? void 0 : _g.textAlign) && void 0 !== _h ? _h : "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "bottom" : "top"
    }), this._startText = this.maybeAddLabel(this._container, merge({}, restStartTextStyle, {
      text: startTextValue,
      x: startTextPosition.x,
      y: startTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: startTextAlignStyle
    }), `data-zoom-start-text-${position}`), this._endText = this.maybeAddLabel(this._container, merge({}, restEndTextStyle, {
      text: endTextValue,
      x: endTextPosition.x,
      y: endTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: endTextAlignStyle
    }), `data-zoom-end-text-${position}`);
  }
  renderText() {
    let startTextBounds = null, endTextBounds = null;
    this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds, this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds;
    const { x1, x2, y1, y2 } = startTextBounds, { dx: startTextDx = 0, dy: startTextDy = 0 } = this.attribute.startTextStyle;
    if (new Bounds().set(x1, y1, x2, y2).intersects(endTextBounds)) {
      const direction = "bottom" === this.attribute.orient || "right" === this.attribute.orient ? -1 : 1;
      this._isHorizontal ? this._startText.setAttribute("dy", startTextDy + direction * Math.abs(endTextBounds.y1 - endTextBounds.y2)) : this._startText.setAttribute("dx", startTextDx + direction * Math.abs(endTextBounds.x1 - endTextBounds.x2));
    } else this._isHorizontal ? this._startText.setAttribute("dy", startTextDy) : this._startText.setAttribute("dx", startTextDx);
  }
  getLayoutAttrFromConfig() {
    var _a, _b, _c, _d, _e, _f;
    if (this._layoutAttrFromConfig) return this._layoutAttrFromConfig;
    const { position: positionConfig, size, orient, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, backgroundStyle = {} } = this.attribute, { width: widthConfig, height: heightConfig } = size, middleHandlerSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10;
    let width, height, position;
    middleHandlerStyle.visible ? this._isHorizontal ? (width = widthConfig, height = heightConfig - middleHandlerSize, position = {
      x: positionConfig.x,
      y: positionConfig.y + middleHandlerSize
    }) : (width = widthConfig - middleHandlerSize, height = heightConfig, position = {
      x: positionConfig.x + ("left" === orient ? middleHandlerSize : 0),
      y: positionConfig.y
    }) : (width = widthConfig, height = heightConfig, position = positionConfig);
    const startHandlerSize = null !== (_c = startHandlerStyle.size) && void 0 !== _c ? _c : this._isHorizontal ? height : width, endHandlerSize = null !== (_d = endHandlerStyle.size) && void 0 !== _d ? _d : this._isHorizontal ? height : width;
    return startHandlerStyle.visible && (this._isHorizontal ? (width -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x + startHandlerSize / 2,
      y: position.y
    }) : (height -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x,
      y: position.y + startHandlerSize / 2
    })), height += null !== (_e = backgroundStyle.lineWidth / 2) && void 0 !== _e ? _e : 1, width += null !== (_f = backgroundStyle.lineWidth / 2) && void 0 !== _f ? _f : 1, this._layoutAttrFromConfig = {
      position,
      width,
      height
    }, this._layoutAttrFromConfig;
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
    this._layoutAttrFromConfig = null;
    const { orient, backgroundStyle, backgroundChartStyle = {}, selectedBackgroundStyle = {}, selectedBackgroundChartStyle = {}, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, brushSelect, zoomLock } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig(), startHandlerMinSize = null !== (_a = startHandlerStyle.triggerMinSize) && void 0 !== _a ? _a : 40, endHandlerMinSize = null !== (_b = endHandlerStyle.triggerMinSize) && void 0 !== _b ? _b : 40, group = this.createOrUpdateChild("dataZoom-container", {}, "group");
    if (this._container = group, this._background = group.createOrUpdateChild("background", Object.assign(Object.assign({
      x: position.x,
      y: position.y,
      width,
      height,
      cursor: brushSelect ? "crosshair" : "auto"
    }, backgroundStyle), {
      pickable: !zoomLock && (null === (_c = backgroundStyle.pickable) || void 0 === _c || _c)
    }), "rect"), (null === (_d = backgroundChartStyle.line) || void 0 === _d ? void 0 : _d.visible) && this.setPreviewAttributes("line", group), (null === (_e = backgroundChartStyle.area) || void 0 === _e ? void 0 : _e.visible) && this.setPreviewAttributes("area", group), brushSelect && this.renderDragMask(), this._isHorizontal ? this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x + start * width,
      y: position.y,
      width: (end - start) * width,
      height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_f = selectedBackgroundChartStyle.pickable) || void 0 === _f || _f)
    }), "rect") : this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x,
      y: position.y + start * height,
      width,
      height: (end - start) * height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_g = selectedBackgroundStyle.pickable) || void 0 === _g || _g)
    }), "rect"), (null === (_h = selectedBackgroundChartStyle.line) || void 0 === _h ? void 0 : _h.visible) && this.setSelectedPreviewAttributes("line", group), (null === (_j = selectedBackgroundChartStyle.area) || void 0 === _j ? void 0 : _j.visible) && this.setSelectedPreviewAttributes("area", group), this._isHorizontal) {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_k = middleHandlerStyle.background) || void 0 === _k ? void 0 : _k.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: position.x + start * width,
          y: position.y - middleHandlerBackgroundSize,
          width: (end - start) * width,
          height: middleHandlerBackgroundSize
        }, null === (_l = middleHandlerStyle.background) || void 0 === _l ? void 0 : _l.style), {
          pickable: !zoomLock && (null === (_p = null === (_o = null === (_m = middleHandlerStyle.background) || void 0 === _m ? void 0 : _m.style) || void 0 === _o ? void 0 : _o.pickable) || void 0 === _p || _p)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: position.x + (start + end) / 2 * width,
          y: position.y - middleHandlerBackgroundSize / 2,
          strokeBoundsBuffer: 0,
          angle: 0,
          symbolType: null !== (_r = null === (_q = middleHandlerStyle.icon) || void 0 === _q ? void 0 : _q.symbolType) && void 0 !== _r ? _r : "square"
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_s = middleHandlerStyle.icon.pickable) || void 0 === _s || _s)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + start * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_t = startHandlerStyle.symbolType) && void 0 !== _t ? _t : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), {
        pickable: !zoomLock && (null === (_u = startHandlerStyle.pickable) || void 0 === _u || _u)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + end * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_v = endHandlerStyle.symbolType) && void 0 !== _v ? _v : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), {
        pickable: !zoomLock && (null === (_w = endHandlerStyle.pickable) || void 0 === _w || _w)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + start * width - startHandlerWidth / 2,
        y: position.y + height / 2 - startHandlerHeight / 2,
        width: startHandlerWidth,
        height: startHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + end * width - endHandlerWidth / 2,
        y: position.y + height / 2 - endHandlerHeight / 2,
        width: endHandlerWidth,
        height: endHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect");
    } else {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_x = middleHandlerStyle.background) || void 0 === _x ? void 0 : _x.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize : position.x + width,
          y: position.y + start * height,
          width: middleHandlerBackgroundSize,
          height: (end - start) * height
        }, null === (_y = middleHandlerStyle.background) || void 0 === _y ? void 0 : _y.style), {
          pickable: !zoomLock && (null === (_1 = null === (_0 = null === (_z = middleHandlerStyle.background) || void 0 === _z ? void 0 : _z.style) || void 0 === _0 ? void 0 : _0.pickable) || void 0 === _1 || _1)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize / 2 : position.x + width + middleHandlerBackgroundSize / 2,
          y: position.y + (start + end) / 2 * height,
          angle: Math.PI / 180 * 90,
          symbolType: null !== (_3 = null === (_2 = middleHandlerStyle.icon) || void 0 === _2 ? void 0 : _2.symbolType) && void 0 !== _3 ? _3 : "square",
          strokeBoundsBuffer: 0
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_5 = null === (_4 = middleHandlerStyle.icon) || void 0 === _4 ? void 0 : _4.pickable) || void 0 === _5 || _5)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + start * height,
        size: width,
        symbolType: null !== (_6 = startHandlerStyle.symbolType) && void 0 !== _6 ? _6 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), {
        pickable: !zoomLock && (null === (_7 = startHandlerStyle.pickable) || void 0 === _7 || _7)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + end * height,
        size: width,
        symbolType: null !== (_8 = endHandlerStyle.symbolType) && void 0 !== _8 ? _8 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), {
        pickable: !zoomLock && (null === (_9 = endHandlerStyle.pickable) || void 0 === _9 || _9)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + startHandlerWidth / 2,
        y: position.y + start * height - startHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + endHandlerWidth / 2,
        y: position.y + end * height - endHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect");
    }
    this._showText && this.renderText();
  }
  computeBasePoints() {
    const { orient } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    let basePointStart, basePointEnd;
    return this._isHorizontal ? (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : "left" === orient ? (basePointStart = [{
      x: position.x + width,
      y: position.y
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x,
      y: position.y
    }]), {
      basePointStart,
      basePointEnd
    };
  }
  simplifyPoints(points) {
    var _a;
    if (points.length > 1e4) {
      const tolerance = null !== (_a = this.attribute.tolerance) && void 0 !== _a ? _a : this._previewData.length / 1e4;
      return flatten_simplify(points, tolerance, false);
    }
    return points;
  }
  getPreviewLinePoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d)
    }));
    if (0 === previewPoints.length) return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  getPreviewAreaPoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d),
      x1: this._previewPointsX1 && this._previewPointsX1(d),
      y1: this._previewPointsY1 && this._previewPointsY1(d)
    }));
    if (0 === previewPoints.length) return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  setPreviewAttributes(type, group) {
    this._previewGroup || (this._previewGroup = group.createOrUpdateChild("previewGroup", {
      pickable: false
    }, "group")), "line" === type ? this._previewLine = this._previewGroup.createOrUpdateChild("previewLine", {}, "line") : this._previewArea = this._previewGroup.createOrUpdateChild("previewArea", {
      curveType: "basis"
    }, "area");
    const { backgroundChartStyle = {} } = this.attribute;
    "line" === type && this._previewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.line)), "area" === type && this._previewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.area));
  }
  setSelectedPreviewAttributes(type, group) {
    this._selectedPreviewGroupClip || (this._selectedPreviewGroupClip = group.createOrUpdateChild("selectedPreviewGroupClip", {
      pickable: false
    }, "group"), this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild("selectedPreviewGroup", {}, "group")), "line" === type ? this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewLine", {}, "line") : this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewArea", {
      curveType: "basis"
    }, "area");
    const { selectedBackgroundChartStyle = {} } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig();
    this._selectedPreviewGroupClip.setAttributes({
      x: this._isHorizontal ? position.x + start * width : position.x,
      y: this._isHorizontal ? position.y : position.y + start * height,
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      clip: true,
      pickable: false
    }), this._selectedPreviewGroup.setAttributes({
      x: -(this._isHorizontal ? position.x + start * width : position.x),
      y: -(this._isHorizontal ? position.y : position.y + start * height),
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      pickable: false
    }), "line" === type && this._selectedPreviewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.line)), "area" === type && this._selectedPreviewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.area));
  }
  maybeAddLabel(container2, attributes, name) {
    let labelShape = this.find((node) => node.name === name, true);
    return labelShape ? labelShape.setAttributes(attributes) : (labelShape = new Tag(attributes), labelShape.name = name), container2.add(labelShape), labelShape;
  }
  setStartAndEnd(start, end) {
    const { start: startAttr, end: endAttr } = this.attribute;
    isValid_default(start) && isValid_default(end) && (start !== this.state.start || end !== this.state.end) && (this.state.start = start, this.state.end = end, startAttr === this.state.start && endAttr === this.state.end || (this.setStateAttr(start, end, true), this._dispatchEvent("change", {
      start,
      end,
      tag: this._activeTag
    })));
  }
  setPreviewData(data) {
    this._previewData = data;
  }
  setText(text2, tag) {
    "start" === tag ? this._startText.setAttribute("text", text2) : this._endText.setAttribute("text", text2);
  }
  getStartValue() {
    return this._startValue;
  }
  getEndTextValue() {
    return this._endValue;
  }
  getMiddleHandlerSize() {
    var _a, _b, _c, _d;
    const { middleHandlerStyle = {} } = this.attribute, middleHandlerRectSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10, middleHandlerSymbolSize = null !== (_d = null === (_c = middleHandlerStyle.icon) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
    return Math.max(middleHandlerRectSize, ...array(middleHandlerSymbolSize));
  }
  setPreviewPointsX(callback) {
    isFunction_default(callback) && (this._previewPointsX = callback);
  }
  setPreviewPointsY(callback) {
    isFunction_default(callback) && (this._previewPointsY = callback);
  }
  setPreviewPointsX1(callback) {
    isFunction_default(callback) && (this._previewPointsX1 = callback);
  }
  setPreviewPointsY1(callback) {
    isFunction_default(callback) && (this._previewPointsY1 = callback);
  }
  setStatePointToData(callback) {
    isFunction_default(callback) && (this._statePointToData = callback);
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearDragEvents();
  }
};
DataZoom.defaultAttributes = DEFAULT_DATA_ZOOM_ATTRIBUTES;

// node_modules/@visactor/vrender-components/es/marker/type.js
var IMarkLineLabelPosition;
!function(IMarkLineLabelPosition2) {
  IMarkLineLabelPosition2.start = "start", IMarkLineLabelPosition2.startTop = "startTop", IMarkLineLabelPosition2.startBottom = "startBottom", IMarkLineLabelPosition2.insideStart = "insideStart", IMarkLineLabelPosition2.insideStartTop = "insideStartTop", IMarkLineLabelPosition2.insideStartBottom = "insideStartBottom", IMarkLineLabelPosition2.middle = "middle", IMarkLineLabelPosition2.insideMiddleTop = "insideMiddleTop", IMarkLineLabelPosition2.insideMiddleBottom = "insideMiddleBottom", IMarkLineLabelPosition2.end = "end", IMarkLineLabelPosition2.endTop = "endTop", IMarkLineLabelPosition2.endBottom = "endBottom", IMarkLineLabelPosition2.insideEnd = "insideEnd", IMarkLineLabelPosition2.insideEndTop = "insideEndTop", IMarkLineLabelPosition2.insideEndBottom = "insideEndBottom";
}(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
var IMarkAreaLabelPosition;
!function(IMarkAreaLabelPosition2) {
  IMarkAreaLabelPosition2.left = "left", IMarkAreaLabelPosition2.right = "right", IMarkAreaLabelPosition2.top = "top", IMarkAreaLabelPosition2.bottom = "bottom", IMarkAreaLabelPosition2.topLeft = "topLeft", IMarkAreaLabelPosition2.topRight = "topRight", IMarkAreaLabelPosition2.bottomLeft = "bottomLeft", IMarkAreaLabelPosition2.bottomRight = "bottomRight", IMarkAreaLabelPosition2.middle = "middle", IMarkAreaLabelPosition2.insideLeft = "insideLeft", IMarkAreaLabelPosition2.insideRight = "insideRight", IMarkAreaLabelPosition2.insideTop = "insideTop", IMarkAreaLabelPosition2.insideBottom = "insideBottom", IMarkAreaLabelPosition2.insideTopLeft = "insideTopLeft", IMarkAreaLabelPosition2.insideTopRight = "insideTopRight", IMarkAreaLabelPosition2.insideBottomLeft = "insideBottomLeft", IMarkAreaLabelPosition2.insideBottomRight = "insideBottomRight";
}(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
var IMarkCommonArcLabelPosition;
!function(IMarkCommonArcLabelPosition2) {
  IMarkCommonArcLabelPosition2.arcInnerStart = "arcInnerStart", IMarkCommonArcLabelPosition2.arcInnerEnd = "arcInnerEnd", IMarkCommonArcLabelPosition2.arcInnerMiddle = "arcInnerMiddle", IMarkCommonArcLabelPosition2.arcOuterStart = "arcOuterStart", IMarkCommonArcLabelPosition2.arcOuterEnd = "arcOuterEnd", IMarkCommonArcLabelPosition2.arcOuterMiddle = "arcOuterMiddle", IMarkCommonArcLabelPosition2.center = "center";
}(IMarkCommonArcLabelPosition || (IMarkCommonArcLabelPosition = {}));
var IMarkPointItemPosition;
!function(IMarkPointItemPosition2) {
  IMarkPointItemPosition2.top = "top", IMarkPointItemPosition2.bottom = "bottom", IMarkPointItemPosition2.middle = "middle", IMarkPointItemPosition2.insideTop = "insideTop", IMarkPointItemPosition2.insideBottom = "insideBottom", IMarkPointItemPosition2.insideMiddle = "insideMiddle";
}(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

// node_modules/@visactor/vrender-components/es/marker/register.js
function loadBaseMarker() {
  registerGroup(), loadTagComponent();
}
function loadMarkLineComponent() {
  loadBaseMarker(), loadSegmentComponent();
}
function loadMarkArcLineComponent() {
  loadBaseMarker(), loadArcSegmentComponent();
}
function loadMarkAreaComponent() {
  loadBaseMarker(), registerPolygon();
}
function loadMarkArcAreaComponent() {
  loadBaseMarker(), registerArc();
}
function loadMarkPointComponent() {
  loadBaseMarker(), loadSegmentComponent(), loadArcSegmentComponent(), registerSymbol(), registerImage(), registerLine();
}

// node_modules/@visactor/vrender-components/es/marker/base.js
var Marker = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "marker", this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this._container, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this._container, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this._container, this._lastSelect);
    };
  }
  transAnimationConfig() {
    var _a, _b, _c;
    if (false !== this.attribute.animation) {
      const animation = isObject_default(this.attribute.animation) ? this.attribute.animation : {};
      this._animationConfig = {
        enter: merge({}, this.defaultUpdateAnimation, animation, null !== (_a = this.attribute.animationEnter) && void 0 !== _a ? _a : {}),
        exit: merge({}, this.defaultExitAnimation, animation, null !== (_b = this.attribute.animationExit) && void 0 !== _b ? _b : {}),
        update: merge({}, this.defaultUpdateAnimation, animation, null !== (_c = this.attribute.animationUpdate) && void 0 !== _c ? _c : {})
      };
    }
  }
  setAttribute(key, value, forceUpdateTag) {
    super.setAttribute(key, value, forceUpdateTag), "visible" === key && this.render();
  }
  _bindEvent() {
    var _a, _b, _c;
    if (!this.attribute.interactive) return;
    const { hover, select } = this.attribute;
    hover && (null === (_a = this._container) || void 0 === _a || _a.addEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.addEventListener("pointerout", this._onUnHover)), select && (null === (_c = this._container) || void 0 === _c || _c.addEventListener("pointerdown", this._onClick));
  }
  _releaseEvent() {
    var _a, _b, _c;
    null === (_a = this._container) || void 0 === _a || _a.removeEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.removeEventListener("pointerout", this._onUnHover), null === (_c = this._container) || void 0 === _c || _c.removeEventListener("pointerdown", this._onClick);
  }
  _initContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    let group;
    if (clipInRange) {
      const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), {
        clip: true,
        pickable: false
      }));
      group = graphicCreator.group({
        x: -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0),
        y: -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0),
        pickable: false
      }), groupClip.add(group), this._containerClip = groupClip, this.add(groupClip);
    } else group = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(group);
    group.name = "marker-container", this._container = group;
  }
  _updateContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    this._containerClip && this._containerClip.setAttributes(Object.assign({}, limitRect)), this._container.setAttributes({
      x: clipInRange ? -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0) : 0,
      y: clipInRange ? -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0) : 0
    });
  }
  render() {
    var _a;
    this.transAnimationConfig(), this.setAttribute("pickable", false);
    const markerVisible = null === (_a = this.attribute.visible) || void 0 === _a || _a;
    false === this.attribute.interactive && this.setAttribute("childrenPickable", false), markerVisible && this.isValidPoints() ? this._container ? (this._updateContainer(), this.updateMarker(), this.markerAnimate("update")) : (this._initContainer(), this.initMarker(this._container), this.markerAnimate("enter")) : (this.markerAnimate("exit"), this._container = null, this.removeAllChild(true)), this._releaseEvent(), this._bindEvent();
  }
  release() {
    this.markerAnimate("exit"), super.release(), this._releaseEvent(), this._container = null;
  }
};

// node_modules/@visactor/vrender-components/es/marker/animate/common.js
function graphicFadeIn(graphic, delay, duration, easing) {
  var _a, _b, _c, _d, _e;
  if (!graphic) return;
  null === (_a = null == graphic ? void 0 : graphic.animates) || void 0 === _a || _a.forEach((a3) => a3.stop("end"));
  const fillOpacityConfig = null !== (_c = null === (_b = graphic.attribute) || void 0 === _b ? void 0 : _b.fillOpacity) && void 0 !== _c ? _c : 1, strokeOpacityConfig = null !== (_e = null === (_d = graphic.attribute) || void 0 === _d ? void 0 : _d.strokeOpacity) && void 0 !== _e ? _e : 1;
  graphic.setAttributes({
    fillOpacity: 0,
    strokeOpacity: 0
  }), graphic.animate().wait(delay).to({
    fillOpacity: fillOpacityConfig,
    strokeOpacity: strokeOpacityConfig
  }, duration, easing);
}
function segmentFadeIn(segment, delay, duration, easing) {
  segment && (graphicFadeIn(segment.startSymbol, delay, duration, easing), segment.lines.forEach((line2) => graphicFadeIn(line2, delay, duration, easing)), graphicFadeIn(segment.line, delay, duration, easing), graphicFadeIn(segment.endSymbol, delay, duration, easing));
}
function tagFadeIn(tag, delay, duration, easing) {
  tag && (graphicFadeIn(tag.getTextShape(), delay, duration, easing), graphicFadeIn(tag.getBgRect(), delay, duration, easing));
}
function graphicFadeOut(graphic, delay, duration, easing) {
  var _a, _b, _c, _d;
  graphic && (graphic.setAttributes({
    fillOpacity: null !== (_b = null === (_a = graphic.attribute) || void 0 === _a ? void 0 : _a.fillOpacity) && void 0 !== _b ? _b : 1,
    strokeOpacity: null !== (_d = null === (_c = graphic.attribute) || void 0 === _c ? void 0 : _c.strokeOpacity) && void 0 !== _d ? _d : 1
  }), graphic.animate().wait(delay).to({
    fillOpacity: 0,
    strokeOpacity: 0
  }, duration, easing));
}
function segmentFadeOut(segment, delay, duration, easing) {
  segment && (graphicFadeOut(segment.startSymbol, delay, duration, easing), segment.lines.forEach((line2) => graphicFadeOut(line2, delay, duration, easing)), graphicFadeOut(segment.line, delay, duration, easing), graphicFadeOut(segment.endSymbol, delay, duration, easing));
}
function tagFadeOut(tag, delay, duration, easing) {
  tag && (graphicFadeOut(tag.getTextShape(), delay, duration, easing), graphicFadeOut(tag.getBgRect(), delay, duration, easing));
}

// node_modules/@visactor/vrender-components/es/marker/animate/clip-in.js
function commonLineClipIn(line2, label, duration, delay, easing) {
  const startSymbolDuration = 0.1 * duration, lineDuration = 0.7 * duration, endSymbolDuration = 0.1 * duration, labelDuration = 0.1 * duration;
  graphicFadeIn(line2.startSymbol, delay, startSymbolDuration, easing), line2.lines.forEach((line3) => line3.setAttribute("clipRange", 0)), line2.lines.forEach((l, index) => {
    const stepDuration = lineDuration / line2.lines.length;
    l.animate().wait(delay + startSymbolDuration + index * stepDuration).to({
      clipRange: 1
    }, stepDuration, easing);
  }), graphicFadeIn(line2.endSymbol, delay + startSymbolDuration + lineDuration, endSymbolDuration, easing), array(label).forEach((labelNode) => {
    const delayTime = delay + startSymbolDuration + lineDuration + endSymbolDuration;
    graphicFadeIn(labelNode.getTextShape(), delayTime, labelDuration, easing), graphicFadeIn(labelNode.getBgRect(), delayTime, labelDuration, easing);
  });
}

// node_modules/@visactor/vrender-components/es/marker/animate/fade-in.js
function commonLineFadeIn(line2, label, duration, delay, easing) {
  segmentFadeIn(line2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeIn(labelNode, delay, duration, easing);
  });
}
function areaFadeIn(area2, label, duration, delay, easing) {
  graphicFadeIn(area2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeIn(labelNode, delay, duration, easing);
  });
}
function arcAreaFadeIn(area2, label, duration, delay, easing) {
  graphicFadeIn(area2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeIn(labelNode, delay, duration, easing);
  });
}
function pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  segmentFadeIn(itemLine, delay, duration, easing), graphicFadeIn(decorativeLine, delay, duration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? tagFadeIn(item, delay, duration, easing) : graphicFadeIn(item, delay, duration, easing);
}

// node_modules/@visactor/vrender-components/es/marker/animate/fade-out.js
function commonLineFadeOut(line2, label, duration, delay, easing) {
  segmentFadeOut(line2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeOut(labelNode, delay, duration, easing);
  });
}
function areaFadeOut(area2, label, duration, delay, easing) {
  graphicFadeOut(area2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeOut(labelNode, delay, duration, easing);
  });
}
function arcAreaFadeOut(area2, label, duration, delay, easing) {
  graphicFadeOut(area2, delay, duration, easing), array(label).forEach((labelNode) => {
    tagFadeOut(labelNode, delay, duration, easing);
  });
}
function pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  segmentFadeOut(itemLine, delay, duration, easing), graphicFadeOut(decorativeLine, delay, duration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? tagFadeOut(item, delay, duration, easing) : graphicFadeOut(item, delay, duration, easing);
}

// node_modules/@visactor/vrender-components/es/marker/animate/call-in.js
function pointCallIn(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  const startSymbolDuration = 0.1 * duration, lineDuration = 0.65 * duration, decorativeDuration = 0.05 * duration, endSymbolDuration = 0.1 * duration, labelDuration = 0.1 * duration;
  graphicFadeIn(itemLine.startSymbol, delay, startSymbolDuration, easing), itemLine.lines.forEach((line2) => line2.setAttribute("clipRange", 0)), itemLine.lines.forEach((l, index) => {
    const stepDuration = lineDuration / itemLine.lines.length;
    l.animate().wait(delay + startSymbolDuration + index * stepDuration).to({
      clipRange: 1
    }, stepDuration, easing);
  }), graphicFadeIn(decorativeLine, delay + startSymbolDuration + lineDuration, decorativeDuration, easing), graphicFadeIn(itemLine.endSymbol, delay + startSymbolDuration + lineDuration + decorativeDuration, endSymbolDuration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? (graphicFadeIn(item.getTextShape(), delay + startSymbolDuration + lineDuration + decorativeDuration + endSymbolDuration, labelDuration, easing), graphicFadeIn(item.getBgRect(), delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing)) : graphicFadeIn(item, delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing);
}

// node_modules/@visactor/vrender-components/es/marker/animate/animate.js
function markCommonLineAnimate(line2, label, animationconfig, state) {
  const { enter, update: update3, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "clipIn" === type ? commonLineClipIn(line2, label, duration, delay, easing) : "fadeIn" === type && commonLineFadeIn(line2, label, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update3;
    "clipIn" === type ? commonLineClipIn(line2, label, duration, delay, easing) : "fadeIn" === type && commonLineFadeIn(line2, label, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    commonLineFadeOut(line2, label, duration, delay, easing);
  }
}
function markAreaAnimate(area2, label, animationconfig, state) {
  const { enter, update: update3, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "fadeIn" === type && areaFadeIn(area2, label, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update3;
    "fadeIn" === type && areaFadeIn(area2, label, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    areaFadeOut(area2, label, duration, delay, easing);
  }
}
function markArcAreaAnimate(area2, label, animationconfig, state) {
  const { enter, update: update3, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "fadeIn" === type && arcAreaFadeIn(area2, label, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update3;
    "fadeIn" === type && arcAreaFadeIn(area2, label, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    arcAreaFadeOut(area2, label, duration, delay, easing);
  }
}
function markPointAnimate(lines, item, animationconfig, state) {
  const [itemLine, decorativeLine] = lines, { enter, update: update3, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "fadeIn" === type ? pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) : "callIn" === type && pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update3;
    "fadeIn" === type ? pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) : "callIn" === type && pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing);
  }
}
var DefaultUpdateMarkLineAnimation = {
  type: "clipIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkAreaAnimation = {
  type: "fadeIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkPointAnimation = {
  type: "callIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultExitMarkerAnimation = {
  type: "fadeOut",
  duration: 500,
  easing: "linear",
  delay: 0
};

// node_modules/@visactor/vrender-components/es/marker/mixin/label.js
var MarkLabelMixin = class {
  getLabel() {
    return this._label;
  }
  _addMarkLabels(container2, labelName, defaultLabelAttrs) {
    const { label, state } = this.attribute, labelStates = array(null == state ? void 0 : state.label), labelBackgroundStates = array(null == state ? void 0 : state.labelBackground), labelShapes = array(label).map((labelAttrs, index) => {
      var _a, _b;
      const finalLabelAttrs = merge({}, defaultLabelAttrs, labelAttrs), markLabel = new Tag(Object.assign(Object.assign({}, finalLabelAttrs), {
        state: {
          panel: merge({}, DEFAULT_STATES, null !== (_a = labelBackgroundStates[index]) && void 0 !== _a ? _a : last(labelBackgroundStates)),
          text: merge({}, DEFAULT_STATES, null !== (_b = labelStates[index]) && void 0 !== _b ? _b : last(labelStates))
        }
      }));
      return markLabel.name = labelName, container2.add(markLabel), this.setLabelPos(markLabel, finalLabelAttrs), markLabel;
    });
    this._label = 1 === array(labelShapes).length ? labelShapes[0] : labelShapes;
  }
  _updateMarkLabels(defaultLabelAttrs) {
    const { label, state } = this.attribute, labelShapes = array(this._label), labelStates = array(null == state ? void 0 : state.label), labelBackgroundStates = array(null == state ? void 0 : state.labelBackground);
    if (labelShapes.length) {
      const labels = array(label);
      labelShapes.forEach((labelItem, index) => {
        var _a, _b;
        const finalLabelAttrs = merge({}, defaultLabelAttrs, labels[index]);
        labelItem.setAttributes(Object.assign(Object.assign({
          dx: 0,
          dy: 0
        }, finalLabelAttrs), {
          state: {
            panel: merge({}, DEFAULT_STATES, null !== (_a = labelBackgroundStates[index]) && void 0 !== _a ? _a : last(labelBackgroundStates)),
            text: merge({}, DEFAULT_STATES, null !== (_b = labelStates[index]) && void 0 !== _b ? _b : last(labelStates))
          }
        })), this.setLabelPos(labelItem, finalLabelAttrs);
      });
    }
  }
};

// node_modules/@visactor/vrender-components/es/marker/common-line.js
var MarkCommonLine = class extends Marker {
  constructor() {
    super(...arguments), this.name = "markCommonLine", this.defaultUpdateAnimation = DefaultUpdateMarkLineAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getLine() {
    return this._line;
  }
  setLabelPos(labelNode, labelAttrs) {
    const { limitRect } = this.attribute, { position, confine, autoRotate: autoRotate2 } = labelAttrs, labelPoint = this.getPointAttrByPosition(position, labelAttrs), labelAngle = position.toString().toLocaleLowerCase().includes("start") ? this._line.getStartAngle() || 0 : this._line.getEndAngle() || 0;
    if (labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint.position), {
      angle: autoRotate2 ? this.getRotateByAngle(labelPoint.angle, labelAttrs) : 0,
      textStyle: Object.assign(Object.assign({}, this.getTextStyle(position, labelAngle, autoRotate2)), labelAttrs.textStyle)
    })), limitRect && confine) {
      const { x, y, width, height } = limitRect;
      limitShapeInBounds(labelNode, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
    }
  }
  initMarker(container2) {
    const line2 = this.createSegment();
    line2.name = "mark-common-line-line", this._line = line2, container2.add(line2), this.addMarkLineLabels(container2);
  }
  updateMarker() {
    this.setLineAttributes(), this.updateMarkLineLabels();
  }
};
mixin(MarkCommonLine, MarkLabelMixin);

// node_modules/@visactor/vrender-components/es/marker/config.js
var FUZZY_EQUAL_DELTA = 1e-3;
var DEFAULT_MARK_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    position: IMarkLineLabelPosition.end,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP = {
  postiveXAxis: {
    start: {
      textAlign: "left",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "left",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "right",
      textBaseline: "top"
    }
  },
  negativeXAxis: {
    start: {
      textAlign: "right",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "right",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "left",
      textBaseline: "top"
    }
  }
};
var DEFAULT_MARK_ARC_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    autoRotate: true,
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_MARK_AREA_THEME = {
  interactive: true,
  label: {
    position: IMarkAreaLabelPosition.right,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_MARK_ARC_AREA_THEME = {
  interactive: true,
  label: {
    autoRotate: true,
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP = {
  arcInnerStart: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerEnd: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerMiddle: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcOuterStart: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterEnd: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterMiddle: {
    textAlign: "center",
    textBaseline: "top"
  },
  center: {
    textAlign: "center",
    textBaseline: "middle"
  }
};
var DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP = {
  left: {
    textAlign: "right",
    textBaseline: "middle"
  },
  insideLeft: {
    textAlign: "left",
    textBaseline: "middle"
  },
  right: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideRight: {
    textAlign: "right",
    textBaseline: "middle"
  },
  top: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  insideTop: {
    textAlign: "center",
    textBaseline: "top"
  },
  bottom: {
    textAlign: "center",
    textBaseline: "top"
  },
  insideBottom: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  middle: {
    textAlign: "center",
    textBaseline: "middle"
  },
  topLeft: {
    textAlign: "right",
    textBaseline: "top"
  },
  insideTopLeft: {
    textAlign: "left",
    textBaseline: "top"
  },
  topRight: {
    textAlign: "left",
    textBaseline: "top"
  },
  insideTopRight: {
    textAlign: "right",
    textBaseline: "top"
  },
  bottomLeft: {
    textAlign: "right",
    textBaseline: "bottom"
  },
  insideBottomLeft: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  bottomRight: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  insideBottomRight: {
    textAlign: "right",
    textBaseline: "bottom"
  }
};
var DEFAULT_MARK_POINT_THEME = {
  interactive: true,
  targetSymbol: {
    visible: false,
    offset: 0,
    style: {
      symbolType: "circle",
      size: 20,
      fill: false,
      stroke: "rgba(46, 47, 50)"
    }
  },
  itemLine: {
    visible: true,
    decorativeLine: {
      visible: false,
      length: 30
    },
    startSymbol: {
      visible: true,
      clip: true,
      symbolType: "circle",
      size: 20,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    endSymbol: {
      visible: false,
      clip: true,
      symbolType: "triangle",
      size: 12,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    lineStyle: {
      stroke: "#000",
      lineWidth: 1
    }
  },
  itemContent: {
    type: "text",
    position: "middle",
    refX: 10,
    symbolStyle: {
      symbolType: "star",
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8,
      size: 20
    },
    textStyle: {
      dx: 0,
      dy: 0
    },
    imageStyle: {
      width: 80,
      height: 80
    },
    richTextStyle: {
      width: 100,
      height: 100
    }
  }
};
var DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
  postiveXAxis: {
    top: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "right",
      textBaseline: "middle"
    }
  },
  negativeXAxis: {
    top: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "left",
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vrender-components/es/marker/line.js
loadMarkLineComponent();
function registerMarkLineAnimate() {
  MarkLine._animate = markCommonLineAnimate;
}
var MarkLine = class _MarkLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkLine._animate && this._animationConfig && _MarkLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkLine.defaultAttributes, attributes)), this.name = "markLine";
  }
  getPointAttrByPosition(position, labelAttrs) {
    var _a;
    const { refX = 0, refY = 0 } = labelAttrs, points = this._line.getMainSegmentPoints(), lineEndAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelAngle = (isPostiveXAxis(lineEndAngle), lineEndAngle), labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
    return position.includes("start") || position.includes("Start") ? {
      position: {
        x: points[0].x + labelOffsetX,
        y: points[0].y + labelOffsetY
      },
      angle: labelAngle
    } : position.includes("middle") || position.includes("Middle") ? {
      position: {
        x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
        y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
      },
      angle: labelAngle
    } : {
      position: {
        x: points[points.length - 1].x + labelOffsetX,
        y: points[points.length - 1].y + labelOffsetY
      },
      angle: labelAngle
    };
  }
  getRotateByAngle(angle2, labelAttrs) {
    var _a;
    return (isPostiveXAxis(angle2) ? angle2 : angle2 - Math.PI) + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
  }
  getTextStyle(position, labelAngle, autoRotate2) {
    return fuzzyEqualNumber(Math.abs(labelAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(labelAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, labelAngle, position) : isPostiveXAxis(labelAngle) ? DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position] : DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
  }
  createSegment() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    return new Segment({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      pickable: false,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    this._line && this._line.setAttributes({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 2) return false;
    let validFlag = true;
    return points.forEach((point6) => {
      if (point6.length) point6.forEach((p) => {
        isValidNumber_default(p.x) && isValidNumber_default(p.y) || (validFlag = false);
      });
      else if (!isValidNumber_default(point6.x) || !isValidNumber_default(point6.y)) return void (validFlag = false);
    }), validFlag;
  }
  addMarkLineLabels(container2) {
    this._addMarkLabels(container2, "mark-common-line-label", _MarkLine.defaultAttributes.label);
  }
  updateMarkLineLabels() {
    this._updateMarkLabels(_MarkLine.defaultAttributes.label);
  }
};
MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;

// node_modules/@visactor/vrender-components/es/marker/area.js
loadMarkAreaComponent();
function registerMarkAreaAnimate() {
  MarkArea._animate = markAreaAnimate;
}
var MarkArea = class _MarkArea extends Marker {
  markerAnimate(state) {
    _MarkArea._animate && this._animationConfig && _MarkArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArea.defaultAttributes, attributes)), this.name = "markArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position) {
    const { x1, x2, y1, y2 } = this._area.AABBBounds, result2 = {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    };
    return (position.includes("left") || position.includes("Left")) && (result2.x = x1), (position.includes("right") || position.includes("Right")) && (result2.x = x2), (position.includes("top") || position.includes("Top")) && (result2.y = y1), (position.includes("bottom") || position.includes("Bottom")) && (result2.y = y2), result2;
  }
  setLabelPos(labelNode, labelAttrs) {
    var _a;
    if (this._area) {
      const labelPosition = null !== (_a = labelAttrs.position) && void 0 !== _a ? _a : "middle", labelPoint = this.getPointAttrByPosition(labelPosition);
      if (labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint), {
        textStyle: Object.assign(Object.assign({}, DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle)
      })), this.attribute.limitRect && labelAttrs.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(labelNode, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { points, areaStyle, state } = this.attribute, area2 = graphicCreator.polygon(Object.assign({
      points
    }, areaStyle));
    area2.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area2.name = "mark-area-polygon", this._area = area2, container2.add(area2), this._addMarkLabels(container2, "mark-area-label", _MarkArea.defaultAttributes.label);
  }
  updateMarker() {
    const { points, areaStyle, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      points
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._updateMarkLabels(_MarkArea.defaultAttributes.label);
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 3) return false;
    let validFlag = true;
    return points.forEach((point6) => {
      isValidNumber_default(point6.x) && isValidNumber_default(point6.y) || (validFlag = false);
    }), validFlag;
  }
};
MarkArea.defaultAttributes = DEFAULT_MARK_AREA_THEME, mixin(MarkArea, MarkLabelMixin);

// node_modules/@visactor/vrender-components/es/marker/arc-line.js
loadMarkArcLineComponent();
function registerMarkArcLineAnimate() {
  MarkArcLine._animate = markCommonLineAnimate;
}
var MarkArcLine = class _MarkArcLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkArcLine._animate && this._animationConfig && _MarkArcLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcLine.defaultAttributes, attributes)), this.name = "markArcLine";
  }
  getPointAttrByPosition(direction, labelAttrs) {
    const { center: center2, radius, startAngle, endAngle } = this.attribute, { refX = 0, refY = 0 } = labelAttrs;
    let angle2;
    switch (direction) {
      case IMarkCommonArcLabelPosition.arcInnerStart:
        angle2 = startAngle;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        angle2 = endAngle;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.center:
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
      default:
        angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center2.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center2.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  getTextStyle(position) {
    return DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[position];
  }
  getRotateByAngle(angle2, labelAttrs) {
    var _a;
    return angle2 - Math.PI / 2 + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
  }
  createSegment() {
    const { center: center2, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    return new ArcSegment({
      center: center2,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { center: center2, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    this._line && this._line.setAttributes({
      center: center2,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    return true;
  }
  addMarkLineLabels(container2) {
    this._addMarkLabels(container2, "mark-common-line-label", _MarkArcLine.defaultAttributes.label);
  }
  updateMarkLineLabels() {
    this._updateMarkLabels(_MarkArcLine.defaultAttributes.label);
  }
};
MarkArcLine.defaultAttributes = DEFAULT_MARK_ARC_LINE_THEME;

// node_modules/@visactor/vrender-components/es/marker/arc-area.js
loadMarkArcAreaComponent();
function registerMarkArcAreaAnimate() {
  MarkArcArea._animate = markArcAreaAnimate;
}
var MarkArcArea = class _MarkArcArea extends Marker {
  markerAnimate(state) {
    _MarkArcArea._animate && this._animationConfig && _MarkArcArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcArea.defaultAttributes, attributes)), this.name = "markArcArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position, labelAttrs) {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle } = this.attribute, { refX = 0, refY = 0 } = labelAttrs;
    let radius, angle2;
    switch (position) {
      case IMarkCommonArcLabelPosition.center:
        radius = (innerRadius + outerRadius) / 2, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcInnerStart:
        radius = innerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        radius = outerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        radius = innerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        radius = outerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
        radius = outerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      default:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center2.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center2.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  setLabelPos(labelNode, labelAttrs) {
    var _a;
    if (this._area) {
      const { position: labelPosition = "arcInnerMiddle", autoRotate: autoRotate2 } = labelAttrs, labelAttr = this.getPointAttrByPosition(labelPosition, labelAttrs);
      if (labelNode.setAttributes(Object.assign(Object.assign({}, labelAttr.position), {
        angle: autoRotate2 ? labelAttr.angle - Math.PI / 2 + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0) : 0,
        textStyle: Object.assign(Object.assign({}, DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle)
      })), this.attribute.limitRect && labelAttrs.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(labelNode, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle, areaStyle, state } = this.attribute, area2 = graphicCreator.arc(Object.assign({
      x: center2.x,
      y: center2.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle));
    area2.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area2.name = "polar-mark-area-area", this._area = area2, container2.add(area2), this._addMarkLabels(container2, "mark-area-label", _MarkArcArea.defaultAttributes.label);
  }
  updateMarker() {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle, areaStyle, label, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      x: center2.x,
      y: center2.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._updateMarkLabels(_MarkArcArea.defaultAttributes.label);
  }
  isValidPoints() {
    return true;
  }
};
MarkArcArea.defaultAttributes = DEFAULT_MARK_ARC_AREA_THEME, mixin(MarkArcArea, MarkLabelMixin);

// node_modules/@visactor/vrender-components/es/marker/point.js
loadMarkPointComponent();
function registerMarkPointAnimate() {
  MarkPoint._animate = markPointAnimate;
}
var MarkPoint = class _MarkPoint extends Marker {
  markerAnimate(state) {
    _MarkPoint._animate && this._animationConfig && _MarkPoint._animate([this._line, this._decorativeLine], this._item, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkPoint.defaultAttributes, attributes)), this.name = "markPoint", this.defaultUpdateAnimation = DefaultUpdateMarkPointAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation, this._isArcLine = false, this._isStraightLine = false;
  }
  setLabelPos() {
  }
  getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, itemPosition) {
    return fuzzyEqualNumber(Math.abs(lineEndAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(lineEndAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) : isPostiveXAxis(lineEndAngle) ? DEFAULT_MARK_POINT_TEXT_STYLE_MAP.postiveXAxis[itemPosition] : DEFAULT_MARK_POINT_TEXT_STYLE_MAP.negativeXAxis[itemPosition];
  }
  setItemAttributes(item, itemContent, newPosition, newItemPosition, itemType) {
    var _a, _b;
    if (!item) return;
    const { autoRotate: autoRotate2 = true, refX = 0, refY = 0, refAngle = 0, textStyle = {}, richTextStyle = {}, imageStyle = {}, position: positionType2 = IMarkPointItemPosition.middle } = itemContent, { state } = this.attribute, lineEndAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0, itemRefOffsetX = refX * Math.cos(lineEndAngle) + refY * Math.cos(lineEndAngle - Math.PI / 2), itemRefOffsetY = refX * Math.sin(lineEndAngle) + refY * Math.sin(lineEndAngle - Math.PI / 2);
    if ("text" === itemType) {
      const offsetX = newItemPosition.x - newPosition.x, offsetY = newItemPosition.y - newPosition.y;
      item.setAttributes(Object.assign(Object.assign({}, textStyle), {
        textStyle: Object.assign(Object.assign({}, this.getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, null !== (_b = itemContent.position) && void 0 !== _b ? _b : "end")), textStyle.textStyle),
        state: {
          panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
          text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
        }
      }));
    } else "richText" === itemType ? (item.setAttributes({
      dx: this.getItemDx(item, positionType2, richTextStyle) + (richTextStyle.dx || 0),
      dy: this.getItemDy(item, positionType2, richTextStyle) + (richTextStyle.dy || 0)
    }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === itemType && (item.setAttributes({
      dx: this.getItemDx(item, positionType2, imageStyle) + (imageStyle.dx || 0),
      dy: this.getItemDy(item, positionType2, imageStyle) + (imageStyle.dy || 0)
    }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image));
    const itemAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle - Math.PI;
    item.setAttributes({
      x: newItemPosition.x + (itemRefOffsetX || 0),
      y: newItemPosition.y + (itemRefOffsetY || 0),
      angle: autoRotate2 && itemAngle + refAngle
    });
  }
  getItemDx(item, position, style) {
    var _a, _b;
    const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style ? void 0 : style.width) || 0;
    return position.includes("inside") ? -width : 0;
  }
  getItemDy(item, position, style) {
    var _a, _b;
    const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style ? void 0 : style.height) || 0;
    return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
  }
  initItem(itemContent, newPosition, newItemPosition) {
    const { state } = this.attribute, { type = "text", symbolStyle, richTextStyle, imageStyle, renderCustomCallback } = itemContent;
    let item;
    return "symbol" === type ? (item = graphicCreator.symbol(Object.assign(Object.assign({}, newItemPosition), symbolStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.symbol)) : "text" === type ? item = new Tag(Object.assign(Object.assign({}, newItemPosition), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
      }
    })) : "richText" === type ? (item = graphicCreator.richtext(Object.assign(Object.assign({}, newItemPosition), richTextStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === type ? (item = graphicCreator.image(Object.assign(Object.assign({}, newItemPosition), imageStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback(), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.customMark)), item.name = `mark-point-${type}`, this.setItemAttributes(item, itemContent, newPosition, newItemPosition, type), item;
  }
  getItemLineAttr(itemLine, newPosition, newItemPosition) {
    let points = [], center2 = {
      x: 0,
      y: 0
    }, radius = 0, startAngle = 0, endAngle = 0;
    const { type = "type-s", arcRatio = 0.8 } = itemLine, itemOffsetX = newItemPosition.x - newPosition.x, itemOffsetY = newItemPosition.y - newPosition.y;
    if (this._isStraightLine = fuzzyEqualNumber(itemOffsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(itemOffsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine) {
      const { x: x1, y: y1 } = this.attribute.position, { x: x2, y: y2 } = newItemPosition, x0 = (x1 + x2) / 2, y0 = (y1 + y2) / 2, k2 = y1 === y2 ? 0 : -(x1 - x2) / (y1 - y2), centerX = x0 + arcRatio * (y2 > y1 ? -1 : 1) * x0, centerY = ((x) => k2 * (x - x0) + y0)(centerX);
      startAngle = deltaXYToAngle(y1 - centerY, x1 - centerX), endAngle = deltaXYToAngle(y2 - centerY, x2 - centerX), center2 = {
        x: centerX,
        y: centerY
      };
      const R = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1)), r = this.attribute.targetSymbol.style.size / 2;
      startAngle += 2 * Math.acos(Math.sqrt(1 - r * r / (4 * R * R))), arcRatio > 0 ? endAngle < startAngle && (endAngle += 2 * Math.PI) : startAngle < endAngle && (startAngle += 2 * Math.PI), radius = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1));
    } else points = "type-do" !== type || this._isStraightLine ? "type-po" !== type || this._isStraightLine ? "type-op" !== type || this._isStraightLine ? [newPosition, newItemPosition] : [newPosition, {
      x: newPosition.x,
      y: newItemPosition.y
    }, newItemPosition] : [newPosition, {
      x: newItemPosition.x,
      y: newPosition.y
    }, newItemPosition] : [newPosition, {
      x: (newPosition.x + newItemPosition.x) / 2,
      y: newItemPosition.y
    }, newItemPosition];
    return points = removeRepeatPoint(points), {
      points,
      center: center2,
      radius,
      startAngle,
      endAngle
    };
  }
  reDrawLine(itemLine, pointsAttr) {
    this._line.release();
    const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, lineConstructor = this._isArcLine ? ArcSegment : Segment;
    this._container.removeChild(this._line), this._line = new lineConstructor(Object.assign(Object.assign({}, pointsAttr), {
      pickable: false,
      startSymbol,
      endSymbol,
      lineStyle,
      visible: itemLine.visible,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    })), this._container.add(this._line);
  }
  setItemLineAttr(itemLine, newPosition, newItemPosition) {
    if (this._line) {
      const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, pointsAttr = this.getItemLineAttr(itemLine, newPosition, newItemPosition);
      this._isArcLine && "arc-segment" === this._line.key || !this._isArcLine && "segment" === this._line.key ? this._line.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
        startSymbol,
        endSymbol,
        lineStyle,
        visible: itemLine.visible,
        state: {
          line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
          startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
          endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
        }
      })) : this.reDrawLine(itemLine, pointsAttr);
    }
  }
  getDecorativeLineAttr(itemLine) {
    var _a;
    const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10, itemAngle = this._line.getEndAngle() || 0;
    return {
      startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
      endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
    };
  }
  setDecorativeLineAttr(itemLine, newItemPosition, visible) {
    var _a;
    if (this._decorativeLine) {
      const { lineStyle } = itemLine, { startPointOffsetX, startPointOffsetY, endPointOffsetX, endPointOffsetY } = this.getDecorativeLineAttr(itemLine);
      this._decorativeLine.setAttributes(Object.assign(Object.assign({
        points: [{
          x: newItemPosition.x + startPointOffsetX,
          y: newItemPosition.y + startPointOffsetY
        }, {
          x: newItemPosition.x + endPointOffsetX,
          y: newItemPosition.y + endPointOffsetY
        }]
      }, lineStyle), {
        visible
      })), this._decorativeLine.states = merge({}, DEFAULT_STATES, null === (_a = this.attribute.state) || void 0 === _a ? void 0 : _a.line);
    }
  }
  setTargetItemAttributes(targetItem, position) {
    var _a, _b;
    this._targetItem && (this._targetItem.setAttributes(Object.assign({
      x: position.x,
      y: position.y,
      visible: null !== (_a = targetItem.visible) && void 0 !== _a && _a,
      size: targetItem.size
    }, targetItem.style)), this._targetItem.states = merge({}, DEFAULT_STATES, null === (_b = this.attribute.state) || void 0 === _b ? void 0 : _b.targetItem));
  }
  setAllOfItemsAttr(newPosition, newItemPosition) {
    var _a;
    const { position, itemLine = {}, itemContent = {}, limitRect, targetSymbol } = this.attribute, { type = "text", confine } = itemContent;
    if (limitRect && confine) {
      const { x, y, width, height } = limitRect, { dx, dy } = computeOffsetForlimit(this._item, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
      newItemPosition.x = newItemPosition.x + dx, newItemPosition.y = newItemPosition.y + dy;
    }
    this.setTargetItemAttributes(targetSymbol, position), this.setItemLineAttr(itemLine, newPosition, newItemPosition), this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setDecorativeLineAttr(itemLine, newItemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
  }
  computeNewPositionAfterTargetItem(position) {
    var _a, _b;
    const { itemContent = {}, targetSymbol, itemLine } = this.attribute, { offsetX: itemContentOffsetX = 0, offsetY: itemContentOffsetY = 0 } = itemContent, { offset: targetSymbolOffset = 0, style: targetSymbolStyle, visible: targetItemvisible = false, size: targetSymbolSize } = targetSymbol, targetSize = targetItemvisible ? null !== (_b = null !== (_a = targetSymbolStyle.size) && void 0 !== _a ? _a : targetSymbolSize) && void 0 !== _b ? _b : 20 : 0;
    let targetOffsetAngle;
    targetOffsetAngle = "type-do" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, itemContentOffsetX / 2) : "type-po" === itemLine.type ? deltaXYToAngle(0, itemContentOffsetX) : "type-op" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, 0) : deltaXYToAngle(itemContentOffsetY, itemContentOffsetX);
    return {
      newPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle),
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle)
      },
      newItemPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle) + itemContentOffsetX,
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle) + itemContentOffsetY
      }
    };
  }
  initMarker(container2) {
    const { position, itemContent = {}, itemLine } = this.attribute, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine;
    const { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position), line2 = new (this._isArcLine ? ArcSegment : Segment)({
      points: [],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    });
    line2.name = "mark-point-line", this._line = line2, container2.add(line2);
    const decorativeLine = graphicCreator.line({
      points: []
    });
    decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, container2.add(decorativeLine);
    const targetItem = graphicCreator.symbol({});
    targetItem.name = "mark-point-targetItem", this._targetItem = targetItem, container2.add(this._targetItem);
    const item = this.initItem(itemContent, newPosition, newItemPosition);
    this._item = item, container2.add(item), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  updateMarker() {
    const { position, itemContent = {}, itemLine } = this.attribute, { type = "text" } = itemContent, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
    const isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine, { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position);
    isArcLine !== this._isArcLine ? (this._isArcLine = isArcLine, this.reDrawLine(itemLine, {
      points: [{
        x: 0,
        y: 0
      }],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    })) : this._isArcLine = isArcLine, this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  isValidPoints() {
    const { position } = this.attribute;
    return !(!isValidNumber_default(position.x) || !isValidNumber_default(position.y));
  }
};
MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

// node_modules/@visactor/vrender-components/es/pager/register.js
function loadPagerComponent() {
  registerGroup(), registerSymbol(), registerText();
}

// node_modules/@visactor/vrender-components/es/pager/pager.js
var DEFAULT_HANDLER_STYLE = {
  space: 8,
  style: {
    fill: "rgb(47, 69, 84)",
    cursor: "pointer",
    size: 15
  },
  state: {
    disable: {
      fill: "rgb(170, 170, 170)",
      cursor: "not-allowed"
    },
    hover: {}
  }
};
loadPagerComponent();
var Pager = class _Pager extends AbstractComponent {
  getCurrent() {
    return this._current;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Pager.defaultAttributes, attributes)), this.name = "pager", this._current = 1, this._onHover = (e) => {
      const target = e.target;
      target.hasState("disable") || target.addState("hover");
    }, this._onUnHover = (e) => {
      e.target.removeState("hover");
    }, this._onClick = (e) => {
      const target = e.target;
      if ("preHandler" === target.name) {
        if (1 === this._current) return;
        this._current -= 1, 1 === this._current ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toPrev", {
          current: this._current,
          total: this._total,
          direction: "pre",
          event: e
        });
      }
      if ("nextHandler" === target.name) {
        if (this._current === this._total) return;
        this._current += 1, this._current === this._total ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toNext", {
          current: this._current,
          total: this._total,
          direction: "next",
          event: e
        });
      }
      this._current > 1 && this.preHandler.removeState("disable"), this._current < this._total && this.nextHandler.removeState("disable"), this.text.setAttribute("text", this._getPageText(this._current));
    };
  }
  render() {
    var _a, _b, _c;
    this._reset();
    const { layout: layout2 = "horizontal", handler = DEFAULT_HANDLER_STYLE, total, defaultCurrent = 1, textStyle, padding = 0 } = this.attribute;
    this._current = defaultCurrent;
    const parsedPadding = normalizePadding(padding), isHorizontal4 = "horizontal" === layout2, container2 = graphicCreator.group({
      x: 0,
      y: 0
    }), handlerStyle = handler.style || {}, handlerSize = handlerStyle.size || 15, handlerSpace = null !== (_a = handler.space) && void 0 !== _a ? _a : 8, handlerState = handler.state || {};
    let { preShape, nextShape } = handler;
    preShape || (preShape = isHorizontal4 ? "triangleLeft" : "triangleUp"), nextShape || (nextShape = isHorizontal4 ? "triangleRight" : "triangleDown");
    const preHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: 0,
      y: 0,
      symbolType: preShape,
      size: handlerSize
    }));
    preHandler.states = handlerState, preHandler.name = "preHandler", this.preHandler = preHandler, container2.add(preHandler);
    const { width: maxTextWidth, height: maxTextHeight } = measureTextSize(this._getPageText(total), Object.assign({
      textAlign: "center",
      textBaseline: "middle"
    }, textStyle), null === (_c = null === (_b = this.stage) || void 0 === _b ? void 0 : _b.getTheme()) || void 0 === _c ? void 0 : _c.text), handlerSizeX = isNumber_default(handlerSize) ? handlerSize : handlerSize[0], handlerSizeY = isNumber_default(handlerSize) ? handlerSize : handlerSize[1], text2 = graphicCreator.text(Object.assign({
      x: isHorizontal4 ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0,
      y: isHorizontal4 ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2,
      text: this._getPageText(defaultCurrent),
      textAlign: "center",
      textBaseline: "middle",
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize
    }, textStyle));
    this.text = text2, container2.add(text2);
    const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: isHorizontal4 ? handlerSizeX + 2 * handlerSpace + maxTextWidth : 0,
      y: isHorizontal4 ? 0 : handlerSizeY + 2 * handlerSpace + maxTextHeight,
      symbolType: nextShape,
      size: handlerSize
    }));
    nextHandler.name = "nextHandler", nextHandler.states = handlerState, this.nextHandler = nextHandler, container2.add(nextHandler), 1 === this._total ? (preHandler.addState("disable"), nextHandler.addState("disable")) : 1 === this._current ? preHandler.addState("disable") : this._current === total && nextHandler.addState("disable");
    const containerBounds = container2.AABBBounds, width = containerBounds.width(), height = containerBounds.height();
    container2.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]), this.add(container2), this.attribute.width = width + parsedPadding[1] + parsedPadding[3], this.attribute.height = height + parsedPadding[0] + parsedPadding[2], this._bindEvents();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || (this.preHandler && (this.preHandler.addEventListener("pointerenter", this._onHover), this.preHandler.addEventListener("pointerleave", this._onUnHover), this.preHandler.addEventListener("pointerdown", this._onClick)), this.nextHandler && (this.nextHandler.addEventListener("pointerenter", this._onHover), this.nextHandler.addEventListener("pointerleave", this._onUnHover), this.nextHandler.addEventListener("pointerdown", this._onClick)));
  }
  _reset() {
    this.removeAllChild(true), this._current = 1, this._total = this.attribute.total, this.preHandler = this.nextHandler = this.text = null;
  }
  _getPageText(current) {
    const { pageFormatter } = this.attribute;
    return pageFormatter ? isFunction_default(pageFormatter) ? pageFormatter(current, this._total) : `${pageFormatter}`.replace("{current}", `${current}`).replace("{total}", `${this._total}`) : `${current}/${this._total}`;
  }
  setTotal(total) {
    total !== this.attribute.total && (this._total = total, 1 !== this._current && this._current <= total ? this.setAttributes({
      total,
      defaultCurrent: this._current
    }) : this.setAttribute("total", total));
  }
};
Pager.defaultAttributes = {
  handler: DEFAULT_HANDLER_STYLE,
  textStyle: {
    fill: "rgb(51, 51, 51)",
    fontSize: 12
  }
};

// node_modules/@visactor/vrender-components/es/legend/constant.js
var DEFAULT_SHAPE_SIZE = 10;
var DEFAULT_SHAPE_SPACE = 8;
var DEFAULT_LABEL_SPACE = 8;
var DEFAULT_VALUE_SPACE = 8;
var DEFAULT_ITEM_SPACE_COL = 16;
var DEFAULT_ITEM_SPACE_ROW = 8;
var DEFAULT_TITLE_SPACE = 12;
var DEFAULT_PAGER_SPACE = 12;
var LegendStateValue;
!function(LegendStateValue2) {
  LegendStateValue2.selected = "selected", LegendStateValue2.unSelected = "unSelected", LegendStateValue2.selectedHover = "selectedHover", LegendStateValue2.unSelectedHover = "unSelectedHover", LegendStateValue2.focus = "focus";
}(LegendStateValue || (LegendStateValue = {}));
var LegendEvent;
!function(LegendEvent2) {
  LegendEvent2.legendItemHover = "legendItemHover", LegendEvent2.legendItemUnHover = "legendItemUnHover", LegendEvent2.legendItemClick = "legendItemClick", LegendEvent2.legendItemAttributeUpdate = "legendItemAttributeUpdate";
}(LegendEvent || (LegendEvent = {}));
var LEGEND_ELEMENT_NAME;
!function(LEGEND_ELEMENT_NAME2) {
  LEGEND_ELEMENT_NAME2.innerView = "innerView", LEGEND_ELEMENT_NAME2.title = "legendTitle", LEGEND_ELEMENT_NAME2.item = "legendItem", LEGEND_ELEMENT_NAME2.itemShape = "legendItemShape", LEGEND_ELEMENT_NAME2.itemLabel = "legendItemLabel", LEGEND_ELEMENT_NAME2.itemValue = "legendItemValue", LEGEND_ELEMENT_NAME2.focus = "legendItemFocus";
}(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

// node_modules/@visactor/vrender-components/es/legend/base.js
var LegendBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "legend", this._title = null;
  }
  render() {
    this.removeAllChild(true);
    const { interactive = true, title: title3, padding = 0 } = this.attribute;
    this._parsedPadding = normalizePadding(padding);
    const innerView = graphicCreator.group({
      x: this._parsedPadding[3],
      y: this._parsedPadding[0],
      pickable: interactive,
      childrenPickable: interactive
    });
    innerView.name = LEGEND_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView, (null == title3 ? void 0 : title3.visible) && this._renderTitle(title3), this._renderContent(), this._adjustLayout(), interactive && this._bindEvents();
    const viewBounds = this._innerView.AABBBounds;
    this.attribute.width = viewBounds.width() + this._parsedPadding[1] + this._parsedPadding[3], this.attribute.height = viewBounds.height() + this._parsedPadding[0] + this._parsedPadding[2];
  }
  _renderTitle(title3) {
    const { text: text2 = "", textStyle, padding = 0, background, minWidth, maxWidth, shape } = title3, tagAttrs = {
      x: 0,
      y: 0,
      text: text2,
      textStyle,
      padding: normalizePadding(padding),
      minWidth,
      maxWidth
    };
    shape && shape.visible && (tagAttrs.shape = Object.assign({
      visible: true
    }, shape.style), isValid_default(shape.space) && (tagAttrs.space = shape.space)), background && background.visible && (tagAttrs.panel = Object.assign({
      visible: true
    }, background.style));
    const titleTag = new Tag(tagAttrs);
    titleTag.name = LEGEND_ELEMENT_NAME.title, this._title = titleTag, this._innerView.add(titleTag);
  }
  _adjustLayout() {
    var _a;
    if (this._title) {
      const innerViewWidth = this._innerView.AABBBounds.width(), titleWidth = this._title.AABBBounds.width(), align = null === (_a = this.attribute.title) || void 0 === _a ? void 0 : _a.align;
      "center" === align ? this._title.setAttribute("x", (innerViewWidth - titleWidth) / 2) : "end" === align && this._title.setAttribute("x", innerViewWidth - titleWidth);
    }
  }
};

// node_modules/@visactor/vrender-components/es/slider/register.js
function loadSliderComponent() {
  registerGroup(), registerText(), registerRect(), registerSymbol();
}

// node_modules/@visactor/vrender-components/es/legend/register.js
function loadBaseLegend() {
  registerGroup(), loadTagComponent();
}
function loadDiscreteLegendComponent() {
  loadBaseLegend(), loadPagerComponent(), loadScrollbarComponent();
}
function loadColorContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent();
}
function loadSizeContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent(), registerPath();
}

// node_modules/@visactor/vrender-components/es/legend/discrete/discrete.js
var __rest13 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var DEFAULT_STATES3 = {
  [LegendStateValue.focus]: {},
  [LegendStateValue.selected]: {},
  [LegendStateValue.selectedHover]: {},
  [LegendStateValue.unSelected]: {},
  [LegendStateValue.unSelectedHover]: {}
};
loadDiscreteLegendComponent();
var DiscreteLegend = class _DiscreteLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DiscreteLegend.defaultAttributes, attributes)), this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, this._itemHeight = 0, this._itemMaxWidth = 0, this._contentMaxHeight = 0, this._onHover = (e) => {
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate;
        if (this._lastActiveItem) {
          if (this._lastActiveItem.id === legendItem.id) return;
          this._unHover(this._lastActiveItem, e);
        }
        this._hover(legendItem, e);
      } else this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onUnHover = (e) => {
      this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onClick = (e) => {
      var _a, _b, _c, _d;
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate, { selectMode = "multiple" } = this.attribute;
        if (target.name === LEGEND_ELEMENT_NAME.focus || "focus" === selectMode) {
          const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
          legendItem.toggleState(LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
            this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.selected, e);
          }) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
          }));
        } else {
          null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach((item) => {
            item.removeState(LegendStateValue.focus);
          });
          const { allowAllCanceled = true } = this.attribute, isSelected = legendItem.hasState(LegendStateValue.selected), currentSelectedItems = this._getSelectedLegends();
          if ("multiple" === selectMode) {
            if (false === allowAllCanceled && isSelected && 1 === currentSelectedItems.length) return void this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
            isSelected ? (this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(legendItem, LegendStateValue.unSelected, e)) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e));
          } else this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
          });
        }
        this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
      }
    };
  }
  render() {
    super.render(), this._lastActiveItem = null;
  }
  setSelected(selectedData) {
    var _a;
    (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach((item) => {
      const itemData = item.data;
      selectedData.includes(itemData.label) ? (this._setLegendItemState(item, LegendStateValue.selected), this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover])) : (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]), this._setLegendItemState(item, LegendStateValue.unSelected));
    });
  }
  _renderItems() {
    const { item: itemAttrs = {}, maxCol = 1, maxRow = 2, maxWidth, defaultSelected, lazyload, autoPage } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW, verticalAlign = "middle" } = itemAttrs, itemsContainer = this._itemsContainer, { items: legendItems, isHorizontal: isHorizontal4, startIndex, isScrollbar } = this._itemContext, maxPages = isScrollbar ? 1 : isHorizontal4 ? maxRow : maxCol, maxHeight = this._contentMaxHeight;
    let item, { doWrap, maxWidthInCol, startX, startY, pages } = this._itemContext, lastItemWidth = 0, lastLineHeight = 0;
    const lastLineItemGroup = [];
    for (let index = startIndex, len = legendItems.length; index < len && !(lazyload && pages > this._itemContext.currentPage * maxPages); index++) {
      lazyload && (this._itemContext.startIndex = index + 1), item = legendItems[index], item.id || (item.id = item.label), item.index = index;
      let isSelected = true;
      isArray_default(defaultSelected) && (isSelected = defaultSelected.includes(item.label));
      const itemGroup = this._renderEachItem(item, isSelected, index, legendItems), itemWidth = itemGroup.attribute.width, itemHeight = itemGroup.attribute.height;
      this._itemHeight = Math.max(this._itemHeight, itemHeight), maxWidthInCol = Math.max(itemWidth, maxWidthInCol), this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth), isHorizontal4 ? (isValid_default(maxWidth) && (isScrollbar && autoPage ? (pages = Math.ceil((startX + itemWidth) / maxWidth), doWrap = pages > 1) : startX + itemWidth > maxWidth && (doWrap = true, startX > 0 && ("middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach((i) => {
        i.setAttributes({
          y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
        });
      }), pages += 1, startX = 0, startY += lastLineHeight + spaceRow, lastLineHeight = 0, lastLineItemGroup.length = 0))), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startX += spaceCol + itemWidth, lastLineHeight = Math.max(lastLineHeight, itemHeight), lastLineItemGroup.push(itemGroup)) : (isValid_default(maxHeight) && (isScrollbar && autoPage ? (pages = Math.ceil((startY + itemHeight) / maxHeight), doWrap = pages > 1) : maxHeight <= itemHeight ? (pages += 1, doWrap = true, startY = 0, index > 0 && (startX += lastItemWidth + spaceCol)) : maxHeight < startY + itemHeight && (pages += 1, doWrap = true, startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0)), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startY += spaceRow + itemHeight), itemsContainer.add(itemGroup), lastItemWidth = itemWidth;
    }
    return !isHorizontal4 || "middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach((i) => {
      i.setAttributes({
        y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
      });
    }), this._itemContext.doWrap = doWrap, this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.maxWidthInCol = maxWidthInCol, this._itemContext.pages = pages, this._itemContext.maxPages = maxPages, isScrollbar && (this._itemContext.totalPage = pages), lazyload || (this._itemContext.startIndex = legendItems.length), this._itemContext;
  }
  _renderContent() {
    const { item = {}, items, reversed, maxWidth, maxHeight } = this.attribute;
    if (false === item.visible || isEmpty_default(items)) return;
    let legendItems = items;
    reversed && (legendItems = null == items ? void 0 : items.reverse()), this._contentMaxHeight = Math.max(0, maxHeight - this._parsedPadding[0] - this._parsedPadding[2]);
    const itemsContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._itemsContainer = itemsContainer;
    const { layout: layout2, autoPage } = this.attribute, isHorizontal4 = "horizontal" === layout2, { maxWidth: maxItemWidth, width: itemWidth, height: itemHeight } = item, widthsOptions = [];
    isValid_default(maxItemWidth) && widthsOptions.push(maxItemWidth), isValid_default(itemWidth) && widthsOptions.push(itemWidth), widthsOptions.length && (isValid_default(maxWidth) && widthsOptions.push(maxWidth), this._itemWidthByUser = minInArray(widthsOptions)), isValid_default(itemHeight) && (this._itemHeightByUser = itemHeight);
    const pager = this.attribute.pager;
    this._itemContext = {
      currentPage: pager && pager.defaultCurrent || 1,
      doWrap: false,
      maxWidthInCol: 0,
      maxPages: 1,
      pages: 1,
      startX: 0,
      startY: 0,
      startIndex: 0,
      items: legendItems,
      isHorizontal: isHorizontal4,
      totalPage: 1 / 0,
      isScrollbar: pager && "scrollbar" === pager.type,
      clipContainer: void 0
    }, this._itemContext = this._renderItems();
    let pagerRendered = false;
    this._itemContext.doWrap && autoPage && this._itemContext.pages > this._itemContext.maxPages && (pagerRendered = this._renderPagerComponent()), pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    if (!this._itemsContainer) return;
    const { hover = true, select = true } = this.attribute;
    if (hover) {
      let trigger = "pointermove", triggerOff = "pointerleave";
      isObject_default(hover) && (hover.trigger && (trigger = hover.trigger), hover.triggerOff && (triggerOff = hover.triggerOff)), this._itemsContainer.addEventListener(trigger, this._onHover), this._itemsContainer.addEventListener(triggerOff, this._onUnHover);
    }
    if (select) {
      let trigger = "pointerdown";
      isObject_default(select) && select.trigger && (trigger = select.trigger), this._itemsContainer.addEventListener(trigger, this._onClick);
    }
  }
  _autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape) {
    var _a, _b;
    const { label: labelAttr, value: valueAttr } = this.attribute.item, valueBounds = valueShape.AABBBounds, labelBounds = labelShape.AABBBounds, valueWidth = valueBounds.width(), labelWidth = labelBounds.width();
    let useWidthRatio = false;
    "labelFirst" === autoEllipsisStrategy ? labelWidth > layoutWidth ? useWidthRatio = true : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth) : "valueFirst" === autoEllipsisStrategy ? valueWidth > layoutWidth ? useWidthRatio = true : labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : valueWidth + labelWidth > layoutWidth && (useWidthRatio = true), useWidthRatio && (valueShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_a = labelAttr.widthRatio) && void 0 !== _a ? _a : 0.5), layoutWidth - labelWidth)), labelShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_b = valueAttr.widthRatio) && void 0 !== _b ? _b : 0.5), layoutWidth - valueWidth)));
  }
  _renderEachItem(item, isSelected, index, items) {
    var _a, _b;
    const { id, label, value, shape } = item, { padding = 0, focus, focusIconStyle, align, autoEllipsisStrategy } = this.attribute.item, { shape: shapeAttr, label: labelAttr, value: valueAttr, background } = this.attribute.item, shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items), labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items), valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items), backgroundStyle = this._handleStyle(background, item, isSelected, index, items), parsedPadding = normalizePadding(padding);
    let itemGroup;
    false === background.visible ? (itemGroup = graphicCreator.group({
      x: 0,
      y: 0,
      cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
    }), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = graphicCreator.group(Object.assign({
      x: 0,
      y: 0
    }, backgroundStyle.style)), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), itemGroup.id = `${null != id ? id : label}-${index}`, itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
    const innerGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    itemGroup.add(innerGroup);
    let focusShape, focusStartX = 0, shapeSize = 0, shapeSpace = 0;
    if (shapeAttr && false !== shapeAttr.visible) {
      const s2 = get_default(shapeStyle, "style.size", DEFAULT_SHAPE_SIZE);
      shapeSize = isArray_default(s2) ? s2[0] || 0 : s2, shapeSpace = get_default(shapeAttr, "space", DEFAULT_SHAPE_SPACE);
      const itemShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: 0,
        symbolType: "circle",
        strokeBoundsBuffer: 0
      }, shape), shapeStyle.style));
      Object.keys(shapeStyle.state || {}).forEach((key) => {
        const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
        shape.fill && isNil_default(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), shape.stroke && isNil_default(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
      }), this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(itemShape);
    }
    let focusSpace = 0;
    if (focus) {
      const focusSize = get_default(focusIconStyle, "size", DEFAULT_SHAPE_SIZE);
      focusShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: -focusSize / 2 - 1,
        strokeBoundsBuffer: 0,
        boundsPadding: parsedPadding
      }, focusIconStyle), {
        visible: true,
        pickMode: "imprecise"
      })), this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup), focusSpace = focusSize;
    }
    const text2 = labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label, labelAttributes = Object.assign(Object.assign({
      x: shapeSize / 2 + shapeSpace,
      y: 0,
      textAlign: "start",
      textBaseline: "middle",
      lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
    }, labelStyle.style), {
      text: text2,
      _originText: labelAttr.formatMethod ? label : void 0
    }), labelShape = createTextGraphicByType(labelAttributes);
    this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(labelShape);
    const labelSpace = get_default(labelAttr, "space", DEFAULT_LABEL_SPACE);
    if (isValid_default(value)) {
      const valueSpace = get_default(valueAttr, "space", focus ? DEFAULT_VALUE_SPACE : 0), valueText = valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value, valueAttributes = Object.assign(Object.assign({
        x: 0,
        y: 0,
        textAlign: "start",
        textBaseline: "middle",
        lineHeight: valueStyle.style.fontSize
      }, valueStyle.style), {
        text: valueText,
        _originText: valueAttr.formatMethod ? value : void 0
      }), valueShape = createTextGraphicByType(valueAttributes);
      if (this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), this._itemWidthByUser) {
        const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace;
        this._autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape), valueAttr.alignRight ? valueShape.setAttributes({
          textAlign: "right",
          x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
        }) : valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      } else valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      focusStartX = valueSpace + (valueShape.AABBBounds.empty() ? 0 : valueShape.AABBBounds.x2), innerGroup.add(valueShape);
    } else this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2)) : focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
    focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
    const innerGroupBounds = innerGroup.AABBBounds, innerGroupWidth = innerGroupBounds.width();
    if ("right" === align) {
      const x2 = innerGroupBounds.x2, x1 = innerGroupBounds.x1;
      innerGroup.forEachChildren((child, index2) => {
        "symbol" !== child.type && "right" !== child.attribute.textAlign || child === focusShape ? child.setAttribute("x", x1 + x2 - child.attribute.x - child.AABBBounds.width()) : "symbol" !== child.type ? child.setAttributes({
          x: x1 + x2 - child.attribute.x,
          textAlign: "left"
        }) : child.setAttribute("x", x1 + x2 - child.attribute.x);
      });
    }
    const innerGroupHeight = innerGroupBounds.height(), itemGroupWidth = isValid_default(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3], itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
    return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, focusShape && focusShape.setAttribute("visible", false), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), itemGroup;
  }
  _createPager(compStyle) {
    var _a, _b;
    const { disableTriggerEvent, maxRow } = this.attribute, estimateTotal = (num) => num <= 99 ? 99 : num <= 999 ? 999 : 9999;
    return this._itemContext.isHorizontal ? new Pager(Object.assign(Object.assign({
      layout: 1 === maxRow ? "horizontal" : "vertical",
      total: estimateTotal(this._itemContext.pages)
    }, merge({
      handler: {
        preShape: "triangleUp",
        nextShape: "triangleDown"
      }
    }, compStyle)), {
      defaultCurrent: null === (_a = this.attribute.pager) || void 0 === _a ? void 0 : _a.defaultCurrent,
      disableTriggerEvent
    })) : new Pager(Object.assign({
      layout: "horizontal",
      total: estimateTotal(this._itemContext.pages),
      disableTriggerEvent,
      defaultCurrent: null === (_b = this.attribute.pager) || void 0 === _b ? void 0 : _b.defaultCurrent
    }, compStyle));
  }
  _createScrollbar(compStyle, compSize) {
    const { disableTriggerEvent } = this.attribute;
    return this._itemContext.isHorizontal ? new ScrollBar(Object.assign(Object.assign({
      direction: "horizontal",
      disableTriggerEvent,
      range: [0, 0.5],
      height: false === compStyle.visible ? 0 : 12
    }, compStyle), {
      width: compSize
    })) : new ScrollBar(Object.assign(Object.assign({
      direction: "vertical",
      width: false === compStyle.visible ? 0 : 12,
      range: [0, 0.5]
    }, compStyle), {
      height: compSize,
      disableTriggerEvent
    }));
  }
  _updatePositionOfPager(renderStartY, compWidth, compHeight) {
    const { pager } = this.attribute, { totalPage, isHorizontal: isHorizontal4 } = this._itemContext, position = pager && pager.position || "middle";
    if (this._pagerComponent.setTotal(totalPage), isHorizontal4) {
      let y;
      y = "start" === position ? renderStartY : "end" === position ? renderStartY + compHeight - this._pagerComponent.AABBBounds.height() / 2 : renderStartY + compHeight / 2 - this._pagerComponent.AABBBounds.height() / 2, this._pagerComponent.setAttributes({
        x: compWidth - this._pagerComponent.AABBBounds.width(),
        y
      });
    } else {
      let x;
      x = "start" === position ? 0 : "end" === position ? compWidth - this._pagerComponent.AABBBounds.width() : (compWidth - this._pagerComponent.AABBBounds.width()) / 2, this._pagerComponent.setAttributes({
        x,
        y: compHeight - this._pagerComponent.AABBBounds.height()
      });
    }
  }
  _computeScrollbarDelta() {
    const { isHorizontal: isHorizontal4, clipContainer } = this._itemContext, itemContainerBounds = this._itemsContainer.AABBBounds, clipContainerBounds = clipContainer.AABBBounds;
    let delta, innerViewSize;
    return isHorizontal4 ? (innerViewSize = clipContainerBounds.width(), delta = innerViewSize / itemContainerBounds.width()) : (innerViewSize = clipContainerBounds.height(), delta = innerViewSize / itemContainerBounds.height()), delta;
  }
  _updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY) {
    const { isHorizontal: isHorizontal4, currentPage, totalPage } = this._itemContext, start = (currentPage - 1) / totalPage;
    this._pagerComponent.setScrollRange([start, start + this._computeScrollbarDelta()]), isHorizontal4 ? this._pagerComponent.setAttributes({
      x: 0,
      y: renderStartY + contentHeight
    }) : this._pagerComponent.setAttributes({
      x: contentWidth,
      y: renderStartY
    });
  }
  _bindEventsOfPager(pageSize, channel) {
    const pager = this.attribute.pager || {}, { animation = true, animationDuration = 450, animationEasing = "quadIn" } = pager, pageParser = this._itemContext.isScrollbar ? (e) => {
      const { value } = e.detail;
      let newPage;
      return newPage = 0 === value[0] ? 1 : 1 === value[1] ? this._itemContext.totalPage : value[0] * this._itemContext.totalPage + 1, newPage;
    } : (e) => e.detail.current, onScroll = (e) => {
      const scrollComponent = this._pagerComponent, preScrollRange = scrollComponent.getScrollRange(), { direction } = scrollComponent.attribute, { width, height } = scrollComponent.getSliderRenderBounds(), currentScrollValue = "vertical" === direction ? e.deltaY / height : e.deltaX / width;
      scrollComponent.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this.updateScrollMask();
    }, onPaging = (e) => {
      const newPage = pageParser(e);
      if (newPage !== this._itemContext.currentPage) {
        if (this._itemContext.currentPage = newPage, this._itemContext && this._itemContext.startIndex < this._itemContext.items.length) {
          this._renderItems();
          const newTotalPage = Math.ceil(this._itemContext.pages / this._itemContext.maxPages);
          if (this._itemContext.totalPage = newTotalPage, this._itemContext.isScrollbar && this._pagerComponent) {
            const newDelta = this._computeScrollbarDelta(), [start] = this._pagerComponent.getScrollRange();
            this._pagerComponent.setScrollRange([start, start + newDelta]);
          }
        }
        if (this._itemContext.isScrollbar) {
          const [start] = this._pagerComponent.getScrollRange();
          let containerSize;
          containerSize = this._itemContext.isHorizontal ? this._itemsContainer.AABBBounds.width() : this._itemsContainer.AABBBounds.height();
          const startOffset = containerSize * start;
          this.updateScrollMask(), animation ? this._itemsContainer.animate().to({
            [channel]: -startOffset
          }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -startOffset);
        } else animation ? this._itemsContainer.animate().to({
          [channel]: -(newPage - 1) * pageSize
        }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -(newPage - 1) * pageSize);
      }
    };
    if (this._itemContext.isScrollbar) {
      if (this._pagerComponent.addEventListener("scrollDrag", onPaging), this._pagerComponent.addEventListener("scrollUp", onPaging), this.attribute.pager.roamScroll) {
        const THROTTLE_TIME = 50;
        this.addEventListener("wheel", (e) => e.nativeEvent.preventDefault()), this.addEventListener("wheel", throttle_default(onScroll, THROTTLE_TIME));
      }
    } else this._pagerComponent.addEventListener("toPrev", onPaging), this._pagerComponent.addEventListener("toNext", onPaging);
  }
  _renderPager() {
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, maxCol = 1, maxRow = 2, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest13(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal4 } = this._itemContext, maxHeight = this._contentMaxHeight;
    let comp, compWidth = 0, compHeight = 0, contentWidth = 0, contentHeight = 0, startX = 0, startY = 0, pages = 1;
    if (isHorizontal4) {
      if (compHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, compWidth = maxWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentWidth = maxWidth - comp.AABBBounds.width() - pagerSpace, contentWidth <= 0) return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { width, height } = item2.attribute;
        contentWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startX += spaceCol + width;
      }), this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.pages = pages;
      const total = Math.ceil(pages / maxRow);
      this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
    } else {
      if (compWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, compHeight = maxHeight, contentWidth = compWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentHeight = maxHeight - comp.AABBBounds.height() - pagerSpace - renderStartY, contentHeight <= 0) return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { height } = item2.attribute;
        contentHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startY += spaceRow + height;
      });
      const total = Math.ceil(pages / maxCol);
      this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
    }
    defaultCurrent > 1 && (isHorizontal4 ? itemsContainer.setAttribute("y", -(defaultCurrent - 1) * (compHeight + spaceRow)) : itemsContainer.setAttribute("x", -(defaultCurrent - 1) * (compWidth + spaceCol)));
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: isHorizontal4 ? contentWidth : compWidth,
      height: isHorizontal4 ? compHeight : contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._bindEventsOfPager(isHorizontal4 ? compHeight + spaceRow : compWidth + spaceCol, isHorizontal4 ? "y" : "x"), true;
  }
  _renderScrollbar() {
    var _a;
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest13(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal4 } = this._itemContext, maxHeight = this._contentMaxHeight;
    let comp, contentWidth = 0, contentHeight = 0, startY = 0, pages = 1;
    if (isHorizontal4) contentWidth = maxWidth, contentHeight = this._itemHeight, comp = this._createScrollbar(compStyle, contentWidth), this._pagerComponent = comp, this._innerView.add(comp);
    else {
      if (contentHeight = maxHeight - renderStartY, contentWidth = this._itemMaxWidth, comp = this._createScrollbar(compStyle, contentHeight), this._pagerComponent = comp, this._innerView.add(comp), contentHeight <= 0) return this._innerView.removeChild(comp), false;
      const items = itemsContainer.getChildren(), itemsHeightArr = items.map((item2) => item2.attribute.height);
      if (1 === itemsHeightArr.length || itemsHeightArr.every((entry) => entry === itemsHeightArr[0])) {
        const itemHeight = itemsHeightArr[0], maxContentHeight = contentHeight, pageItemsCount = Math.floor(maxContentHeight / (spaceRow + itemHeight));
        contentHeight = pageItemsCount * (spaceRow + itemHeight), pages = Math.ceil(items.length / pageItemsCount);
      } else items.forEach((item2, index) => {
        const { height } = item2.attribute, prePages = pages, preStartY = startY;
        pages = Math.floor((startY + height) / contentHeight) + 1, startY += spaceRow + height, prePages !== pages && index === itemsContainer.getChildren().length - 1 && startY - contentHeight >= 1 / 3 * height && (contentHeight = preStartY + height, pages -= 1);
      });
      this._itemContext.totalPage = pages, this._itemContext.pages = pages;
    }
    if (defaultCurrent > 1) if (isHorizontal4) {
      const maxOffset = this._itemsContainer.AABBBounds.width() - contentWidth;
      itemsContainer.setAttribute("x", -Math.min((defaultCurrent - 1) * (contentWidth + spaceCol), maxOffset));
    } else {
      const maxOffset = this._itemsContainer.AABBBounds.height() - contentHeight;
      itemsContainer.setAttribute("y", -Math.min((defaultCurrent - 1) * (contentHeight + spaceRow), maxOffset));
    }
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: contentWidth,
      height: contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY), (null === (_a = pager.scrollMask) || void 0 === _a ? void 0 : _a.visible) && this.renderScrollMask(clipGroup), this._bindEventsOfPager(isHorizontal4 ? contentWidth : contentHeight, isHorizontal4 ? "x" : "y"), true;
  }
  renderScrollMask(clipGroup) {
    const { scrollMask = {} } = this.attribute.pager, { visible = true, gradientLength = 16, gradientStops } = scrollMask;
    if (!visible || !gradientStops) return;
    const width = clipGroup.AABBBounds.width(), height = clipGroup.AABBBounds.height(), totalLength = this._itemContext.isHorizontal ? width : height, startStops = gradientStops.map((stop) => ({
      offset: gradientLength * stop.offset / totalLength,
      color: stop.color
    })), endStops = gradientStops.map((stop) => ({
      offset: (totalLength - gradientLength * stop.offset) / totalLength,
      color: stop.color
    })), mask = graphicCreator.rect({
      x: 0,
      y: 0,
      width,
      height
    });
    this._scrollMask = mask, this._scrollMaskContext = {
      startStops,
      endStops
    }, this.updateScrollMask(), clipGroup.add(mask);
  }
  updateScrollMask() {
    if (!this._scrollMask || !this._pagerComponent) return;
    if (!this._itemContext.isScrollbar) return;
    const [start, end] = this._pagerComponent.getScrollRange(), stops = [];
    isNumberClose(clamp_default(end, 0, 1), 1) || stops.push(...this._scrollMaskContext.endStops), isNumberClose(clamp_default(start, 0, 1), 0) || stops.push(...this._scrollMaskContext.startStops), stops.length && (this._itemContext.isHorizontal ? this._scrollMask.setAttributes({
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 0,
        stops
      }
    }) : this._scrollMask.setAttributes({
      fill: {
        gradient: "linear",
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 1,
        stops
      }
    }));
  }
  _renderPagerComponent() {
    return this._itemContext.isScrollbar ? this._renderScrollbar() : this._renderPager(), true;
  }
  _hover(legendItem, e) {
    this._lastActiveItem = legendItem;
    legendItem.hasState(LegendStateValue.selected) ? this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e) : this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e);
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", true), this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e);
  }
  _unHover(legendItem, e) {
    let attributeUpdate = false;
    (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) && (attributeUpdate = true), legendItem.removeState(LegendStateValue.unSelectedHover), legendItem.removeState(LegendStateValue.selectedHover), legendItem.getChildren()[0].getChildren().forEach((child) => {
      attributeUpdate || !child.hasState(LegendStateValue.unSelectedHover) && !child.hasState(LegendStateValue.selectedHover) || (attributeUpdate = true), child.removeState(LegendStateValue.unSelectedHover), child.removeState(LegendStateValue.selectedHover);
    });
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", false), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e), this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e);
  }
  _setLegendItemState(legendItem, stateName, e) {
    let attributeUpdate = false;
    legendItem.hasState(stateName) || (attributeUpdate = true), legendItem.addState(stateName, true), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = true), child.addState(stateName, true));
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _removeLegendItemState(legendItem, stateNames, e) {
    let attributeUpdate = false;
    stateNames.forEach((name) => {
      !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = true), legendItem.removeState(name);
    }), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && stateNames.forEach((name) => {
        !attributeUpdate && child.hasState(name) && (attributeUpdate = true), child.removeState(name);
      });
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _getSelectedLegends() {
    var _a;
    const selectedData = [];
    return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
      item.hasState(LegendStateValue.selected) && selectedData.push(item.data);
    }), selectedData;
  }
  _appendDataToShape(shape, name, data, delegateShape, states = {}) {
    shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = merge({}, DEFAULT_STATES3, states);
  }
  _dispatchLegendEvent(eventName, legendItem, event) {
    const currentSelectedItems = this._getSelectedLegends();
    currentSelectedItems.sort((pre, next) => pre.index - next.index);
    const currentSelected = currentSelectedItems.map((obj) => obj.label);
    this._dispatchEvent(eventName, {
      item: legendItem,
      data: legendItem.data,
      selected: legendItem.hasState(LegendStateValue.selected),
      currentSelectedItems,
      currentSelected,
      event
    });
  }
  _handleStyle(config2, item, isSelected, index, items) {
    const newConfig = {};
    return config2.style && (isFunction_default(config2.style) ? newConfig.style = config2.style(item, isSelected, index, items) : newConfig.style = config2.style), config2.state && (newConfig.state = {}, Object.keys(config2.state).forEach((key) => {
      config2.state[key] && (isFunction_default(config2.state[key]) ? newConfig.state[key] = config2.state[key](item, isSelected, index, items) : newConfig.state[key] = config2.state[key]);
    })), newConfig;
  }
  release() {
    super.release(), this.removeAllEventListeners();
  }
};
DiscreteLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: DEFAULT_ITEM_SPACE_COL,
    spaceRow: DEFAULT_ITEM_SPACE_ROW,
    shape: {
      space: DEFAULT_SHAPE_SPACE,
      style: {
        size: DEFAULT_SHAPE_SIZE,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          opacity: 0.5
        }
      }
    },
    label: {
      space: DEFAULT_LABEL_SPACE,
      style: {
        fontSize: 12,
        fill: "#2C3542",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      }
    },
    focus: false,
    focusIconStyle: {
      size: DEFAULT_SHAPE_SIZE,
      symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
      fill: "#333",
      cursor: "pointer"
    }
  },
  autoPage: true,
  pager: {
    space: DEFAULT_PAGER_SPACE,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: true
};

// node_modules/@visactor/vrender-components/es/slider/constant.js
var SLIDER_ELEMENT_NAME;
!function(SLIDER_ELEMENT_NAME2) {
  SLIDER_ELEMENT_NAME2.innerView = "innerView", SLIDER_ELEMENT_NAME2.railContainer = "sliderRailContainer", SLIDER_ELEMENT_NAME2.rail = "sliderRail", SLIDER_ELEMENT_NAME2.startText = "sliderStartText", SLIDER_ELEMENT_NAME2.endText = "sliderEndText", SLIDER_ELEMENT_NAME2.startHandler = "sliderStartHandler", SLIDER_ELEMENT_NAME2.startHandlerText = "startHandlerText", SLIDER_ELEMENT_NAME2.endHandler = "sliderEndHandler", SLIDER_ELEMENT_NAME2.endHandlerText = "sliderEndHandlerText", SLIDER_ELEMENT_NAME2.track = "sliderTrack", SLIDER_ELEMENT_NAME2.trackContainer = "sliderTrackContainer";
}(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

// node_modules/@visactor/vrender-components/es/slider/slider.js
function convertValueToRange(value) {
  return isArray_default(value) ? value : [value, value];
}
function getDefaultCursor(isHorizontal4) {
  return isHorizontal4 ? "ew-resize" : "ns-resize";
}
loadSliderComponent();
var Slider = class _Slider extends AbstractComponent {
  get track() {
    return this._track;
  }
  get currentValue() {
    return this._currentValue;
  }
  get startHandler() {
    return this._startHandler;
  }
  get endHandler() {
    return this._endHandler;
  }
  get tooltipShape() {
    return this._tooltipShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Slider.defaultAttributes, attributes)), this.name = "slider", this._isHorizontal = true, this._startHandler = null, this._endHandler = null, this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, this._currentValue = {}, this._onTooltipShow = (e) => {
      this._isChanging || this._tooltipState && this._tooltipState.isActive || (this._tooltipState ? this._tooltipState.isActive = true : this._tooltipState = {
        isActive: true
      }, this._onTooltipUpdate(e), this._dispatchTooltipEvent("sliderTooltipShow"));
    }, this._onTooltipUpdate = (e) => {
      if (this._isChanging || !this._tooltipState || !this._tooltipState.isActive) return;
      const railLen = this._isHorizontal ? this._rail.globalAABBBounds.width() : this._rail.globalAABBBounds.height(), pos = clamp_default(this._isHorizontal ? (e.viewX - this._rail.globalAABBBounds.x1) / railLen : (e.viewY - this._rail.globalAABBBounds.y1) / railLen, 0, 1);
      pos !== this._tooltipState.pos && (this._tooltipState.pos = pos, this._tooltipState.value = this.calculateValueByPos(pos * railLen), this._updateTooltip(), this._dispatchTooltipEvent("sliderTooltipUpdate"));
    }, this._onTooltipHide = () => {
      const { tooltip: tooltip3 } = this.attribute;
      tooltip3 && tooltip3.alwaysShow || (this._tooltipState = null, this._tooltipShape && this._tooltipShape.setAttribute("visible", false), this._tooltipText && this._tooltipText.setAttribute("visible", false), this._dispatchTooltipEvent("sliderTooltipHide"));
    }, this._onHandlerPointerdown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._currentHandler = e.target, this._prePos = this._isHorizontal ? x : y;
      const triggers = getEndTriggersOfDrag(), obj = "browser" === vglobal.env ? vglobal : this.stage;
      obj.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj.addEventListener(trigger, this._onHandlerPointerUp);
      });
    }, this._onHandlerPointerMove = (e) => {
      var _a, _b;
      this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3 } = this.attribute;
      if (max3 === min3) return;
      const { x, y } = this.stage.eventPointTransform(e);
      let currentPos, originPos, railLen, delta = 0;
      this._isHorizontal ? (currentPos = x, delta = currentPos - this._prePos, originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, railLen = railWidth) : (currentPos = y, delta = currentPos - this._prePos, originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, railLen = railHeight);
      const newPos = clamp_default(originPos + delta, 0, railLen), currentValue = this.calculateValueByPos(newPos);
      "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onHandlerPointerUp = (e) => {
      this._isChanging = false, this._currentHandler = null, this._clearAllDragEvents();
    }, this._handleTouchMove = (e) => {
      this._isChanging && e.preventDefault();
    }, this._onTrackPointerdown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._prePos = this._isHorizontal ? x : y;
      const triggers = getEndTriggersOfDrag(), obj = "browser" === vglobal.env ? vglobal : this.stage;
      obj.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), triggers.forEach((trigger) => {
        obj.addEventListener(trigger, this._onTrackPointerUp);
      });
    }, this._onTrackPointerMove = (e) => {
      this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute;
      if (max3 === min3) return;
      const { startHandler, endHandler } = this._getHandlers();
      let currentPos, trackLen, railLen;
      const { x, y } = this.stage.eventPointTransform(e);
      this._isHorizontal ? (currentPos = x, trackLen = this._track.attribute.width, railLen = railWidth) : (currentPos = y, trackLen = this._track.attribute.height, railLen = railHeight);
      const delta = currentPos - this._prePos;
      if (startHandler) {
        const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, trackLen, railLen) : clamp_default(originPos + delta, 0, railLen - trackLen), currentValue = this.calculateValueByPos(newPos);
        this._updateHandler(startHandler, newPos, currentValue);
      }
      if (endHandler) {
        const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, 0, railLen - trackLen) : clamp_default(originPos + delta, trackLen, railLen), currentValue = this.calculateValueByPos(newPos), startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
        this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
          x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
          width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
        } : {
          y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
          height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
        });
      }
      this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onTrackPointerUp = (e) => {
      this._isChanging = false, this._clearAllDragEvents();
    }, this._onRailPointerDown = (e) => {
      this._clearAllDragEvents(), this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3 } = this.attribute;
      if (max3 === min3) return;
      const startHandler = this._startHandler, endHandler = this._endHandler;
      let currentPos, startHandlerPos, endHandlerPos, railLen;
      this._isHorizontal ? (currentPos = e.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railLen = railWidth) : (currentPos = e.viewY - this._rail.globalAABBBounds.y1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, railLen = railHeight);
      const currentValue = this.calculateValueByPos(currentPos);
      if (isValid_default(endHandlerPos)) {
        const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
        this._updateHandler(updateHandler, currentPos, currentValue);
      } else this._updateHandler(startHandler, currentPos, currentValue);
      this._updateTrack(), this._dispatchChangeEvent();
    };
  }
  calculatePosByValue(value, pos) {
    const { layout: layout2, railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute;
    let ratio = 0;
    ratio = min3 === max3 ? "start" === pos ? 0 : "end" === pos ? 1 : 0 : (value - min3) / (max3 - min3);
    return (inverse ? 1 - ratio : ratio) * ("vertical" === layout2 ? railHeight : railWidth);
  }
  calculateValueByPos(pos) {
    const { layout: layout2, railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute, railLen = "vertical" === layout2 ? railHeight : railWidth;
    return min3 + (max3 - min3) * (inverse ? 1 - pos / railLen : pos / railLen);
  }
  setValue(value) {
    const { min: min3, max: max3 } = this.attribute;
    if (max3 === min3) return;
    const [startValue, endValue] = array(value), { startHandler, endHandler } = this._getHandlers();
    startHandler && this._updateHandler(startHandler, this.calculatePosByValue(startValue), startValue), endHandler && this._updateHandler(endHandler, this.calculatePosByValue(endValue), endValue), this._updateTrack();
  }
  render() {
    var _a, _b;
    this.removeAllChild(true);
    const { layout: layout2 = "horizontal", railWidth, railHeight, startText, endText, min: min3, max: max3, showHandler = true, showTooltip: showTooltip2 } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min3, max3]), this._currentValue = {
      startValue: convertValueToRange(value)[0],
      endValue: convertValueToRange(value)[1]
    };
    const isHorizontal4 = "horizontal" === layout2;
    this._isHorizontal = isHorizontal4;
    const innerView = graphicCreator.group({
      x: 0,
      y: 0
    });
    innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
    let startTextShape, startLen = 0;
    if (startText && startText.visible) {
      startTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal4 ? 0 : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : 0,
        textAlign: isHorizontal4 ? "start" : "center",
        textBaseline: isHorizontal4 ? "middle" : "top",
        text: startText.text,
        lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
      }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
      const space = isValid_default(startText.space) ? startText.space : 0;
      startLen += (isHorizontal4 ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
    }
    const mainContainer = graphicCreator.group({
      x: isHorizontal4 ? startLen : 0,
      y: isHorizontal4 ? 0 : startLen
    });
    innerView.add(mainContainer);
    const railContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    let endTextShape;
    if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, mainContainer.add(railContainer), this._mainContainer = mainContainer, this._renderRail(railContainer), startLen += isHorizontal4 ? railWidth : railHeight, endText && endText.visible) {
      const space = isValid_default(endText.space) ? endText.space : 0;
      endTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal4 ? startLen + space : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : startLen + space,
        textAlign: isHorizontal4 ? "start" : "center",
        textBaseline: isHorizontal4 ? "middle" : "top",
        text: endText.text,
        lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
      }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
    }
    this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), this._bindEvents()), showTooltip2 && (this._renderTooltip(), this._bindTooltipEvents());
  }
  _renderRail(container2) {
    const { railWidth, railHeight, railStyle, slidable } = this.attribute;
    let cursor = "default";
    false !== slidable && (cursor = "pointer");
    const railShape = graphicCreator.rect(Object.assign({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cursor
    }, railStyle));
    return railShape.name = SLIDER_ELEMENT_NAME.rail, container2.add(railShape), this._rail = railShape, railShape;
  }
  _renderHandlers(container2) {
    const { range: range2, min: min3, max: max3, handlerSize = 14, handlerStyle, handlerText, railHeight, railWidth, slidable } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min3, max3]);
    const handlerTextVisible = handlerText && handlerText.visible, isHorizontal4 = this._isHorizontal, [startValue, endValue] = convertValueToRange(value), startPos = this.calculatePosByValue(startValue, range2 ? "start" : "end"), startHandler = this._renderHandler(Object.assign({
      x: isHorizontal4 ? startPos : railWidth / 2,
      y: isHorizontal4 ? railHeight / 2 : startPos,
      size: handlerSize,
      strokeBoundsBuffer: 0,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
    }, handlerStyle));
    if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, container2.add(startHandler), this._currentValue.startPos = startPos, handlerTextVisible) {
      const startHandlerText = this._renderHandlerText(startValue, range2 ? "start" : "end");
      startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container2.add(startHandlerText), this._startHandlerText = startHandlerText;
    }
    if (range2) {
      const endPos = this.calculatePosByValue(endValue, "end"), endHandler = this._renderHandler(Object.assign({
        x: isHorizontal4 ? endPos : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : endPos,
        size: handlerSize,
        strokeBoundsBuffer: 0,
        cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
      }, handlerStyle));
      if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, container2.add(endHandler), this._currentValue.endPos = endPos, handlerTextVisible) {
        const endHandlerText = this._renderHandlerText(endValue, "end");
        endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container2.add(endHandlerText), this._endHandlerText = endHandlerText;
      }
    }
  }
  _renderTrack(container2) {
    const { range: range2, min: min3, max: max3, railHeight, railWidth, trackStyle, railStyle, slidable, value } = this.attribute;
    let startValue, endValue;
    if (isNil_default(value)) range2 ? (startValue = min3, endValue = max3) : startValue = endValue = min3;
    else if (range2) {
      const clampValue = clampRange_default(value, min3, max3);
      startValue = clampValue[0], endValue = clampValue[1];
    } else startValue = min3, endValue = clamp_default(value, min3, max3);
    const isHorizontal4 = this._isHorizontal;
    range2 || (startValue = min3);
    const trackContainer = graphicCreator.group({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
      clip: true,
      pickable: false
    });
    trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
    const draggableTrack = isObject_default(range2) && true === range2.draggableTrack;
    let cursor;
    cursor = false === slidable ? "default" : false === range2 || false === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal4);
    const startPos = this.calculatePosByValue(startValue, "start"), endPos = this.calculatePosByValue(endValue, range2 ? "end" : "start"), track = graphicCreator.rect(Object.assign({
      x: isHorizontal4 ? Math.min(startPos, endPos) : 0,
      y: isHorizontal4 ? 0 : Math.min(startPos, endPos),
      width: isHorizontal4 ? Math.abs(endPos - startPos) : railWidth,
      height: isHorizontal4 ? railHeight : Math.abs(endPos - startPos),
      cursor
    }, trackStyle));
    track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), container2.add(trackContainer);
  }
  _renderHandler(style) {
    return graphicCreator.symbol(style);
  }
  _renderHandlerText(value, position) {
    var _a, _b, _c;
    const { align, handlerSize = 14, handlerText = {}, railHeight, railWidth, slidable } = this.attribute, isHorizontal4 = this._isHorizontal, pos = this.calculatePosByValue(value, position), textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4, textStyle = {
      text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
      lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
    };
    isHorizontal4 ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, textStyle.y = pos) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = pos);
    return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
  }
  _renderTooltip() {
    var _a;
    const { tooltip: tooltip3, railHeight, railWidth, align } = this.attribute;
    tooltip3 && tooltip3.alwaysShow ? this._tooltipState = {
      value: this._currentValue.startValue,
      pos: this._currentValue.startPos
    } : this._tooltipState = null;
    const cx = this._isHorizontal ? 0 : railWidth / 2, cy = this._isHorizontal ? railHeight / 2 : 0;
    if (tooltip3 && tooltip3.shape) {
      const shape = graphicCreator.symbol(Object.assign({
        pickable: false,
        visible: !!this._tooltipState,
        x: cx,
        y: cy,
        symbolType: "circle"
      }, tooltip3.shapeStyle));
      this._tooltipShape = shape, this._mainContainer.add(shape);
    }
    const textConfig = tooltip3 && tooltip3.text || {}, space = null !== (_a = textConfig.space) && void 0 !== _a ? _a : 6, textStyle = {
      pickable: false,
      visible: !!this._tooltipState,
      text: ""
    };
    this._isHorizontal ? (textStyle.x = cx, textStyle.y = "top" === align ? cy - railHeight / 2 - space : cy + railHeight / 2 + space, textStyle.textAlign = "center", textStyle.textBaseline = "top" === align ? "bottom" : "top") : (textStyle.y = cy, textStyle.x = "left" === align ? cx - railWidth / 2 - space : cy + railWidth / 2 + space, textStyle.textAlign = "left" === align ? "end" : "start", textStyle.textBaseline = "middle");
    const text2 = graphicCreator.text(Object.assign(Object.assign({}, textStyle), textConfig.style));
    this._mainContainer.add(text2), this._tooltipText = text2, this._tooltipState && this._updateTooltip();
  }
  _updateTooltip() {
    var _a, _b;
    if (!this._tooltipShape && !this._tooltipText || !this._tooltipState) return;
    const { railWidth, railHeight } = this.attribute, railLen = this._isHorizontal ? railWidth : railHeight, coord = this._tooltipState.pos * railLen, coordKey = this._isHorizontal ? "x" : "y";
    this._tooltipShape && this._tooltipShape.setAttributes({
      visible: true,
      [coordKey]: coord
    });
    const { align } = this.attribute;
    if (this._tooltipText) {
      const textConfig = this.attribute.tooltip && this.attribute.tooltip.text || {};
      this._tooltipText.setAttributes({
        visible: true,
        [coordKey]: coord,
        text: textConfig.formatter ? textConfig.formatter(this._tooltipState.value) : this._isHorizontal || "left" !== align ? `≈ ${this._tooltipState.value.toFixed(null !== (_b = textConfig.precision) && void 0 !== _b ? _b : 0)}` : `${this._tooltipState.value.toFixed(null !== (_a = textConfig.precision) && void 0 !== _a ? _a : 0)} ≈`
      });
    }
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { slidable, range: range2 } = this.attribute;
    slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), isObject_default(range2) && range2.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), this._railContainer.addEventListener("pointerdown", this._onRailPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }));
  }
  _bindTooltipEvents() {
    this.attribute.disableTriggerEvent || (this._mainContainer.addEventListener("pointerenter", this._onTooltipShow), this._mainContainer.addEventListener("pointermove", this._onTooltipUpdate), this._mainContainer.addEventListener("pointerleave", this._onTooltipHide));
  }
  _clearAllDragEvents() {
    const triggers = getEndTriggersOfDrag(), obj = "browser" === vglobal.env ? vglobal : this.stage;
    obj.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj.removeEventListener(trigger, this._onHandlerPointerUp);
    }), obj.removeEventListener("pointermove", this._onTrackPointerMove, {
      capture: true
    }), triggers.forEach((trigger) => {
      obj.removeEventListener(trigger, this._onTrackPointerUp);
    });
  }
  _updateTrack() {
    const { inverse, railWidth, railHeight } = this.attribute, startHandler = this._startHandler, endHandler = this._endHandler;
    if (this._isHorizontal) {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
        this._track.setAttributes({
          x: Math.min(startHandlerPos, endHandlerPos),
          width: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else inverse ? this._track.setAttributes({
        x: startHandlerPos,
        width: railWidth - startHandlerPos
      }) : this._track.setAttributes({
        width: startHandlerPos
      });
    } else {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
        this._track.setAttributes({
          y: Math.min(startHandlerPos, endHandlerPos),
          height: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else inverse ? this._track.setAttributes({
        y: startHandlerPos,
        height: railHeight - startHandlerPos
      }) : this._track.setAttributes({
        height: startHandlerPos
      });
    }
  }
  _updateHandler(handler, position, value) {
    var _a;
    const isHorizontal4 = this._isHorizontal;
    handler.setAttribute(isHorizontal4 ? "x" : "y", position);
    const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
    if (updateHandlerText) {
      const { handlerText = {} } = this.attribute;
      updateHandlerText.setAttributes({
        text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
        [isHorizontal4 ? "x" : "y"]: position
      });
    }
    handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _updateHandlerText(handlerText, position, value) {
    var _a;
    const isHorizontal4 = this._isHorizontal, { handlerText: handlerTextAttr = {} } = this.attribute;
    handlerText.setAttributes({
      [isHorizontal4 ? "x" : "y"]: position,
      text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
    });
    const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
    updateHandler && updateHandler.setAttributes({
      [isHorizontal4 ? "x" : "y"]: position
    }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _dispatchChangeEvent() {
    const isRange = !!this.attribute.range, currentValue = this._currentValue;
    this._dispatchEvent("change", {
      value: isRange ? [Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue)] : currentValue.startValue,
      position: isRange ? [Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos)] : currentValue.startPos
    });
  }
  _dispatchTooltipEvent(type) {
    this._dispatchEvent("sliderTooltip", {
      type,
      position: this._tooltipState && this._tooltipState.pos,
      value: this._tooltipState && this._tooltipState.value
    });
  }
  _getHandlers() {
    const { inverse } = this.attribute;
    let startHandler = this._startHandler, endHandler = this._endHandler;
    return endHandler ? (this._isHorizontal ? (!inverse && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) || inverse && endHandler.attribute.x > (null == startHandler ? void 0 : startHandler.attribute.x)) && ([startHandler, endHandler] = [endHandler, startHandler]) : (!inverse && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) || inverse && endHandler.attribute.y > (null == startHandler ? void 0 : startHandler.attribute.y)) && ([startHandler, endHandler] = [endHandler, startHandler]), {
      startHandler,
      endHandler
    }) : {
      startHandler,
      endHandler
    };
  }
  release(all) {
    super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
      passive: false
    }), this._clearAllDragEvents();
  }
};
Slider.defaultAttributes = {
  slidable: true,
  layout: "horizontal",
  align: "bottom",
  height: 8,
  showHandler: true,
  handlerSize: 14,
  handlerStyle: {
    symbolType: "circle",
    fill: "#fff",
    stroke: "#91caff",
    lineWidth: 2
  },
  tooltip: {
    shapeStyle: {
      symbolType: "circle",
      fill: "#fff",
      stroke: "#91caff",
      lineWidth: 2
    },
    text: {
      style: {
        fill: "#2C3542",
        fontSize: 12
      }
    }
  },
  railStyle: {
    fill: "rgba(0,0,0,.04)"
  },
  trackStyle: {
    fill: "#91caff"
  },
  showValue: true,
  valueStyle: {
    fill: "#2C3542",
    fontSize: 12
  },
  startText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  endText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  handlerText: {
    visible: true,
    space: 4,
    precision: 0,
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  }
};

// node_modules/@visactor/vrender-components/es/legend/color/color.js
loadColorContinuousLegendComponent();
var ColorContinuousLegend = class _ColorContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ColorContinuousLegend.defaultAttributes, attributes)), this.name = "colorLegend", this._onSliderToolipChange = (e) => {
      const tooltipShape = this._slider.tooltipShape;
      if (tooltipShape && e.detail && !isNil_default(e.detail.value)) {
        const color = this._colorScale.scale(e.detail.value);
        tooltipShape.setAttribute("fill", color);
      }
      this.dispatchEvent(e);
    }, this._onSliderChange = (e) => {
      this._updateColor(), this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && (this._slider.setValue(value), this._updateColor());
  }
  _renderContent() {
    const { colors, slidable, layout: layout2, align, min: min3, max: max3, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, inverse, disableTriggerEvent } = this.attribute, domain = [], step = (max3 - min3) / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) domain.push(min3 + step * i);
    this._colorScale = new LinearScale().domain(domain, true).range(colors), this._color = this._getTrackColor();
    const slider2 = new Slider({
      x: 0,
      y: 0,
      range: {
        draggableTrack: true
      },
      slidable,
      layout: layout2,
      align,
      min: min3,
      max: max3,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle,
      railStyle,
      trackStyle: Object.assign({
        fill: this._color
      }, trackStyle),
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent,
      inverse
    });
    this._innerView.add(slider2), this._slider = slider2, slider2.translateTo(0 - slider2.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0) - slider2.AABBBounds.y1), this._updateColor();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
  _getTrackColor() {
    const { colors, layout: layout2, inverse } = this.attribute;
    if (isEmpty_default(colors)) return;
    const count = colors.length;
    if (1 === count) return colors[0];
    const stops = [];
    for (let i = 0; i < count; i++) {
      const percent = i / (count - 1);
      stops.push({
        offset: percent,
        color: colors[i]
      });
    }
    const isHorizontal4 = "horizontal" === layout2, res = {
      gradient: "linear",
      stops,
      x0: 0,
      y0: 0,
      x1: isHorizontal4 ? 1 : 0,
      y1: isHorizontal4 ? 0 : 1
    };
    return inverse && (isHorizontal4 ? (res.x0 = 1, res.x1 = 0) : (res.y0 = 1, res.y1 = 0)), res;
  }
  _updateColor() {
    var _a;
    const { layout: layout2 = "horizontal", colors, railWidth, railHeight } = this.attribute, { startHandler, endHandler, track, attribute } = this._slider, { startValue, endValue, startPos, endPos } = this._slider.currentValue, handlerColor = null === (_a = attribute.handlerStyle) || void 0 === _a ? void 0 : _a.fill;
    if (startHandler && !handlerColor) {
      const startHandlerColor = this._colorScale.scale(startValue);
      startHandler.setAttribute("fill", startHandlerColor);
    }
    if (endHandler && !handlerColor) {
      const endHandlerColor = this._colorScale.scale(endValue);
      endHandler.setAttribute("fill", endHandlerColor);
    }
    const railLen = "horizontal" === layout2 ? railWidth : railHeight;
    if (Math.abs(startPos - endPos) !== railLen && colors && colors.length > 1) {
      const stops = this._color.stops, start = Math.min(startPos, endPos), end = Math.max(startPos, endPos), startRatio = start / railLen, endRatio = end / railLen, range2 = endRatio - startRatio, betweenStops = stops.filter((stop) => stop.offset > startRatio && stop.offset < endRatio), minValue = Math.min(startValue, endValue), maxValue = Math.max(startValue, endValue), startColor = this._colorScale.scale(minValue), endColor = this._colorScale.scale(maxValue), newStops = [{
        offset: 0,
        color: startColor
      }];
      betweenStops.forEach((stop) => {
        newStops.push({
          offset: (stop.offset - startRatio) / range2,
          color: stop.color
        });
      }), newStops.push({
        offset: 1,
        color: endColor
      }), track.setAttribute("fill", Object.assign(Object.assign({}, this._color), {
        stops: newStops
      }));
    }
  }
};
ColorContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    fill: null,
    lineWidth: 4,
    stroke: "#fff",
    outerBorder: {
      distance: 2,
      lineWidth: 1,
      stroke: "#ccc"
    }
  },
  tooltip: {
    shapeStyle: {
      lineWidth: 4,
      stroke: "#fff"
    }
  }
};

// node_modules/@visactor/vrender-components/es/legend/util.js
function getSizeHandlerPath(align = "bottom") {
  let centerX = 0;
  return "top" === align ? `
    M${centerX},-6L${centerX - 3.5},-2.5
    v5
    h7
    v-5
    Z
` : "left" === align ? (centerX = 1, `
    M${centerX - 6},0L${centerX - 6 + 2.5},-3.5
    h5
    v7
    h-5
    Z
`) : "right" === align ? (centerX = -1, `
    M${centerX + 6},0L${centerX + 6 - 2.5},-3.5
    h-5
    v7
    h5
    Z
  `) : `
    M${centerX},6L${centerX - 3.5},2.5
    v-5
    h7
    v5
    Z
`;
}

// node_modules/@visactor/vrender-components/es/legend/size/size.js
loadSizeContinuousLegendComponent();
var SizeContinuousLegend = class _SizeContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SizeContinuousLegend.defaultAttributes, attributes)), this.name = "sizeLegend", this._onSliderChange = (e) => {
      this.dispatchEvent(e);
    }, this._onSliderToolipChange = (e) => {
      this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && this._slider.setValue(value);
  }
  _renderContent() {
    const { slidable, layout: layout2, align, min: min3, max: max3, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, sizeBackground, disableTriggerEvent, inverse } = this.attribute, mainContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._innerView.add(mainContainer);
    const slider2 = new Slider({
      x: 0,
      y: 0,
      zIndex: 1,
      range: {
        draggableTrack: true
      },
      slidable,
      layout: layout2,
      align,
      min: min3,
      max: max3,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle: Object.assign({
        symbolType: getSizeHandlerPath(align)
      }, handlerStyle),
      railStyle,
      trackStyle,
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent,
      inverse
    });
    mainContainer.add(slider2);
    let path, start = 0;
    "horizontal" === layout2 ? "top" === align ? (path = `M0,0L${railWidth},0L${inverse ? 0 : railWidth},12Z`, start = railHeight) : (path = `M0,12L${railWidth},12L${inverse ? 0 : railWidth},0Z`, slider2.setAttribute("y", 12)) : "left" === align ? path = `M${railWidth},0L${railWidth + 12},${inverse ? 0 : railHeight}L${railWidth},${railHeight}Z` : (path = `M0,${inverse ? 0 : railHeight}L12,${railHeight}L12,0Z`, slider2.setAttribute("x", 12));
    const background = graphicCreator.path(Object.assign(Object.assign({
      x: 0,
      y: start,
      path
    }, sizeBackground), {
      zIndex: 0
    }));
    mainContainer.add(background);
    const titleSpace = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0;
    mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1), this._slider = slider2;
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
};
SizeContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    lineWidth: 1,
    stroke: "#ccc",
    fill: "#fff"
  },
  sizeBackground: {
    fill: "rgba(20,20,20,0.1)"
  }
};

// node_modules/@visactor/vrender-components/es/title/register.js
function loadTitleComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/title/title.js
loadTitleComponent();
var Title = class _Title extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Title.defaultAttributes, attributes)), this.name = "title";
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const { textType, text: text2, subtextType, textStyle = {}, subtext, subtextStyle = {}, width, height, minWidth, maxWidth, minHeight, maxHeight, align, verticalAlign, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("title-container", {
      x: parsedPadding[3],
      y: parsedPadding[0],
      zIndex: 1
    }, "group"), fixedMainTitleHeight = null !== (_a = textStyle.height) && void 0 !== _a ? _a : height;
    if (false !== this.attribute.visible && false !== textStyle.visible) {
      const { width: mainTitleWidth, maxHeight: mainTitleMaxHeight, maxWidth: mainTitleMaxWidth, x = 0, y = 0, ellipsis = true, wordBreak = "break-word", maxWidth: maxWidth2, lineClamp } = textStyle;
      if ("rich" === textType || isValid_default(textStyle.character)) {
        const attr = Object.assign({
          x,
          y,
          width: null !== (_b = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _b ? _b : 0,
          height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
          ellipsis: null == ellipsis || ellipsis,
          wordBreak: null != wordBreak ? wordBreak : "break-word",
          maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
          maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth2,
          textConfig: null !== (_c = textStyle.character) && void 0 !== _c ? _c : text2
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else if ("html" === textType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: text2
          }, DEFAULT_HTML_TEXT_SPEC), textStyle),
          x,
          y,
          width: null !== (_d = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _d ? _d : 0,
          height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
          maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth2,
          textConfig: []
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else isValid_default(text2) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
        text: isArray_default(text2) ? text2 : [text2],
        whiteSpace: "normal"
      }, textStyle), {
        maxLineWidth: null !== (_f = null !== (_e = textStyle.maxLineWidth) && void 0 !== _e ? _e : mainTitleWidth) && void 0 !== _f ? _f : width,
        heightLimit: null !== (_g = textStyle.height) && void 0 !== _g ? _g : maxHeight,
        lineClamp,
        ellipsis,
        x,
        y
      }), "text"));
    }
    const mainTextBoundsHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0, mainTextBoundsWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
    if (false !== this.attribute.visible && false !== subtextStyle.visible) {
      const { width: subTitleWidth, height: subTitleHeight, maxWidth: subTitleMaxWidth, maxHeight: subTitleMaxHeight, x = 0, y = 0, ellipsis = true, wordBreak = "break-word", lineClamp } = subtextStyle, maxSubTextHeight = Math.max(Number.MIN_VALUE, maxHeight - mainTextBoundsHeight);
      if ("rich" === subtextType || isValid_default(subtextStyle.character)) {
        const attr = Object.assign({
          x,
          y,
          width: null !== (_h = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _h ? _h : 0,
          height: null !== (_j = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _j ? _j : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
          maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
          textConfig: null !== (_k = subtextStyle.character) && void 0 !== _k ? _k : subtext
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else if ("html" === subtextType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: subtext
          }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
          x,
          y,
          width: null !== (_l = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _l ? _l : 0,
          height: null !== (_m = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _m ? _m : 0,
          ellipsis,
          wordBreak,
          maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
          maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
          textConfig: []
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else isValid_default(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
        text: isArray_default(subtext) ? subtext : [subtext],
        whiteSpace: "normal"
      }, subtextStyle), {
        maxLineWidth: null !== (_o = subtextStyle.maxLineWidth) && void 0 !== _o ? _o : width,
        heightLimit: null !== (_p = subtextStyle.heightLimit) && void 0 !== _p ? _p : maxSubTextHeight,
        lineClamp,
        ellipsis,
        x: 0,
        y: mainTextBoundsHeight
      }), "text"));
    }
    const subTextBoundsHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0, subTextBoundsWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
    let totalWidth = Math.max(mainTextBoundsWidth, subTextBoundsWidth), totalHeight = mainTextBoundsHeight + (null !== (_q = subtextStyle.height) && void 0 !== _q ? _q : subTextBoundsHeight);
    if (isValid_default(width) && (totalWidth = width), isValid_default(height) && (totalHeight = height), isValid_default(minWidth) && totalWidth < minWidth && (totalWidth = minWidth), isValid_default(maxWidth) && totalWidth > maxWidth && (totalWidth = maxWidth), isValid_default(minHeight) && totalHeight < minHeight && (totalHeight = minHeight), isValid_default(maxHeight) && totalHeight > maxHeight && (totalHeight = maxHeight), group.attribute.width = totalWidth, group.attribute.height = totalHeight, group.attribute.boundsPadding = parsedPadding, this._mainTitle) {
      if (isValid_default(align) || isValid_default(textStyle.align)) {
        const mainTitleAlign = textStyle.align ? textStyle.align : align, mainTitleWidth = null !== (_r = textStyle.width) && void 0 !== _r ? _r : totalWidth;
        "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth), this._mainTitle.setAttribute("textAlign", "right")) : (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left"));
      }
      const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign, mainTitleHeight = null != fixedMainTitleHeight ? fixedMainTitleHeight : this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height();
      "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight), this._mainTitle.setAttribute("textBaseline", "bottom")) : (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top"));
    }
    if (this._subTitle) {
      if (isValid_default(align) || isValid_default(subtextStyle.align)) {
        const subTitleAlign = subtextStyle.align ? subtextStyle.align : align, subTitleWidth = null !== (_t = null !== (_s = subtextStyle.width) && void 0 !== _s ? _s : textStyle.width) && void 0 !== _t ? _t : totalWidth;
        "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth), this._subTitle.setAttribute("textAlign", "right")) : (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left"));
      }
      const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign, subTitleYStart = this._mainTitle ? isValid_default(fixedMainTitleHeight) ? this._mainTitle.AABBBounds.y1 + Math.max(this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height(), fixedMainTitleHeight) : this._mainTitle.AABBBounds.y2 : 0, subTitleHeight = null !== (_v = null !== (_u = subtextStyle.height) && void 0 !== _u ? _u : height) && void 0 !== _v ? _v : this._subTitle.AABBBounds.empty() ? 0 : this._subTitle.AABBBounds.height();
      "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), this._subTitle.setAttribute("textBaseline", "bottom")) : (this._subTitle.setAttribute("y", subTitleYStart), this._subTitle.setAttribute("textBaseline", "top"));
    }
  }
};
Title.defaultAttributes = {
  textStyle: {
    ellipsis: "...",
    fill: "#333",
    fontSize: 20,
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "top"
  },
  subtextStyle: {
    ellipsis: "...",
    fill: "#6F6F6F",
    fontSize: 16,
    fontWeight: "normal",
    textAlign: "left",
    textBaseline: "top"
  }
};

// node_modules/@visactor/vrender-components/es/indicator/config.js
var DEFAULT_INDICATOR_THEME = {
  title: {
    style: {
      text: "",
      fontSize: 20,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  },
  content: {
    style: {
      text: "",
      fontSize: 16,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  }
};

// node_modules/@visactor/vrender-components/es/indicator/register.js
function loadIndicatorComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/indicator/indicator.js
loadIndicatorComponent();
var Indicator = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "indicator";
  }
  _renderText(group, title3, limit, limitRatio, themePath, graphicName) {
    if (false !== title3.visible) {
      const titleStyle = merge({}, get_default(DEFAULT_INDICATOR_THEME, themePath), title3.style, {
        visible: title3.visible
      });
      titleStyle.lineHeight = isValid_default(titleStyle.lineHeight) ? titleStyle.lineHeight : titleStyle.fontSize, title3.formatMethod && (titleStyle._originText = titleStyle.text, titleStyle.text = title3.formatMethod(titleStyle.text, titleStyle));
      const textGraphic = createTextGraphicByType(titleStyle);
      return textGraphic.name = graphicName, group.appendChild(textGraphic), title3.autoFit && isValidNumber_default(limit) && this._setLocalAutoFit(limit, textGraphic, title3), title3.autoLimit && isValidNumber_default(limitRatio) && textGraphic.setAttribute("maxLineWidth", limit), textGraphic;
    }
  }
  render() {
    var _a, _b;
    if (this.removeAllChild(true), true !== this.attribute.visible) return;
    const { title: title3 = {}, content, size, limitRatio = 1 / 0 } = this.attribute, limit = Math.min(size.width, size.height) * limitRatio, group = this.createOrUpdateChild("indicator-container", {
      x: 0,
      y: 0,
      zIndex: 1,
      pickable: null === (_a = this.attribute.pickable) || void 0 === _a || _a
    }, "group");
    if (isValid_default(title3) && (this._title = this._renderText(group, title3, limit, limitRatio, "title.style", "indicator-title")), isValid_default(content)) {
      const contents = array(content), contentComponents = [];
      contents.forEach((contentItem, i) => {
        false !== contentItem.visible && contentComponents.push(this._renderText(group, contentItem, limit, limitRatio, "content.style", "indicator-content-" + i));
      }), this._content = contentComponents;
    }
    this._setGlobalAutoFit(limit), this._setYPosition();
    const totalHeight = null !== (_b = null == group ? void 0 : group.AABBBounds.height()) && void 0 !== _b ? _b : 0;
    group.setAttribute("y", size.height / 2 - totalHeight / 2), group.setAttribute("x", size.width / 2);
  }
  _setLocalAutoFit(limit, indicatorItem, indicatorItemSpec) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if ("default" !== (null !== (_a = indicatorItemSpec.fitStrategy) && void 0 !== _a ? _a : "default")) return;
    const originWidth = measureTextSize(null !== (_c = null === (_b = indicatorItemSpec.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "", null !== (_d = indicatorItemSpec.style) && void 0 !== _d ? _d : {}, null === (_f = null === (_e = this.stage) || void 0 === _e ? void 0 : _e.getTheme()) || void 0 === _f ? void 0 : _f.text).width;
    if (originWidth > 0) {
      const ratio = limit * (null !== (_g = indicatorItemSpec.fitPercent) && void 0 !== _g ? _g : 0.5) / originWidth, fontSize = Math.floor((null !== (_j = null === (_h = indicatorItemSpec.style) || void 0 === _h ? void 0 : _h.fontSize) && void 0 !== _j ? _j : 20) * ratio);
      indicatorItem.setAttribute("fontSize", fontSize), indicatorItem.setAttribute("lineHeight", isValid_default(indicatorItemSpec.style.lineHeight) ? indicatorItemSpec.style.lineHeight : fontSize);
    }
  }
  _setGlobalAutoFit(limit) {
    var _a, _b, _c, _d, _e, _f, _g;
    const r = limit / 2, autoFitTexts = [];
    let otherHeight = 0;
    const titleSpec = null !== (_a = this.attribute.title) && void 0 !== _a ? _a : {};
    titleSpec.autoFit && "inscribed" === titleSpec.fitStrategy ? (this._title.setAttribute("fontSize", 12), autoFitTexts.push({
      text: this._title,
      spec: null !== (_b = this.attribute.title) && void 0 !== _b ? _b : {}
    })) : otherHeight += null !== (_f = null === (_e = null === (_d = null === (_c = this._title) || void 0 === _c ? void 0 : _c.AABBBounds) || void 0 === _d ? void 0 : _d.height) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : 0;
    const titleSpace = null !== (_g = titleSpec.space) && void 0 !== _g ? _g : 0;
    if (otherHeight += titleSpace, array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2, _b2, _c2, _d2;
      const contentText = this._content[index];
      contentSpec.autoFit && "inscribed" === contentSpec.fitStrategy ? (contentText.setAttribute("fontSize", 12), autoFitTexts.push({
        text: contentText,
        spec: contentSpec
      })) : otherHeight += null !== (_c2 = null === (_b2 = null === (_a2 = null == contentText ? void 0 : contentText.AABBBounds) || void 0 === _a2 ? void 0 : _a2.height) || void 0 === _b2 ? void 0 : _b2.call(_a2)) && void 0 !== _c2 ? _c2 : 0;
      const contentSpace = null !== (_d2 = contentSpec.space) && void 0 !== _d2 ? _d2 : 0;
      otherHeight += contentSpace;
    }), autoFitTexts.length <= 0) return;
    const ra = 12 / autoFitTexts.reduce((width, textItem) => Math.max(width, textItem.text.AABBBounds.width()), 0) * autoFitTexts.length, h = otherHeight / 2, a3 = ra ** 2 + 1, b = 2 * h * ra, c3 = h ** 2 - r ** 2, y = 2 * (ra * ((-b + Math.sqrt(b ** 2 - 4 * a3 * c3)) / (2 * a3)) + h), lineHeight = (y - otherHeight) / autoFitTexts.length;
    isValidNumber_default(y) && autoFitTexts.forEach((textItem) => {
      var _a2;
      const specLineHeight = null === (_a2 = textItem.spec.style) || void 0 === _a2 ? void 0 : _a2.lineHeight;
      textItem.text.setAttribute("fontSize", lineHeight), textItem.text.setAttribute("lineHeight", isValid_default(specLineHeight) ? specLineHeight : lineHeight);
    });
  }
  _setYPosition() {
    var _a, _b, _c, _d, _e, _f;
    let lastContentHeight = 0;
    const titleHeight = null !== (_d = null === (_c = null === (_b = null === (_a = this._title) || void 0 === _a ? void 0 : _a.AABBBounds) || void 0 === _b ? void 0 : _b.height) || void 0 === _c ? void 0 : _c.call(_b)) && void 0 !== _d ? _d : 0, titleSpace = null !== (_f = null === (_e = this.attribute.title) || void 0 === _e ? void 0 : _e.space) && void 0 !== _f ? _f : 0;
    array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2;
      const contentText = this._content[index];
      contentText.setAttribute("y", titleHeight + titleSpace + lastContentHeight);
      const contentSpace = null !== (_a2 = contentSpec.space) && void 0 !== _a2 ? _a2 : 0;
      lastContentHeight += contentText.AABBBounds.height() + contentSpace;
    });
  }
};

// node_modules/@visactor/vrender-components/es/link-path/register.js
function loadLinkPathComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vrender-components/es/link-path/link-path.js
var getHorizontalPath = (options, ratio) => {
  let x0 = options.x0, x1 = options.x1;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let y00 = options.y0 - options.thickness / 2, y10 = options.y1 - options.thickness / 2;
  "center" === options.align ? (y00 = options.y0 - thickness / 2, y10 = options.y1 - thickness / 2) : "end" === options.align && (y00 = options.y0 + options.thickness / 2 - thickness, y10 = options.y1 + options.thickness / 2 - thickness);
  let midX = (x0 + x1) / 2, y01 = y00 + thickness, y11 = y10 + thickness;
  options.round && (x0 = Math.round(x0), x1 = Math.round(x1), y00 = Math.round(y00), y10 = Math.round(y10), y01 = Math.round(y01), y11 = Math.round(y11), midX = Math.round(midX));
  const hasLength = Math.abs(x1 - x0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x1},${y10 - thickness / 2}L${x1 + thickness},${(y10 + y11) / 2}L${x1},${y11 + thickness / 2}` : "", startArrowPath = options.startArrow && hasLength ? `L${x0},${y01 + thickness / 2}L${x0 - thickness},${(y00 + y01) / 2}L${x0},${y00 - thickness / 2}` : "";
  return false === options.isSmooth ? `M${x0},${y00}L${x1},${y10}${endArrowPath}L${x1},${y11}L${x0},${y01}${startArrowPath}Z` : `M${x0},${y00}
  C${midX},${y00},${midX},${y10},${x1},${y10}
  ${endArrowPath}
  L${x1},${y11}
  C${midX},${y11},${midX},${y01},${x0},${y01}
  ${startArrowPath}
  Z`;
};
var getVerticalPath = (options, ratio) => {
  let y0 = options.y0, y1 = options.y1, x00 = options.x0 - options.thickness / 2, x10 = options.x1 - options.thickness / 2;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  "center" === options.align ? (x00 = options.x0 - thickness / 2, x10 = options.x1 - thickness / 2) : "end" === options.align && (x00 = options.x0 + options.thickness / 2 - thickness, x10 = options.x1 + options.thickness / 2 - thickness);
  let midY = (y0 + y1) / 2, x01 = x00 + thickness, x11 = x10 + thickness;
  options.round && (y0 = Math.round(y0), y1 = Math.round(y1), x00 = Math.round(x00), x10 = Math.round(x10), x01 = Math.round(x01), x11 = Math.round(x11), midY = Math.round(midY));
  const hasLength = Math.abs(y1 - y0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x10 - thickness / 2},${y1}L${(x10 + x11) / 2},${y1 + thickness}L${x11 + thickness / 2},${y1}` : "", startArrowPath = options.startArrow && hasLength ? `L${x01 + thickness / 2},${y0}L${(x01 + x00) / 2},${y0 - thickness}L${x00 - thickness / 2},${y0}` : "";
  return false === options.isSmooth ? `M${x00},${y0}L${x10},${y1}${endArrowPath}L${x11},${y1}L${x01},${y0}${startArrowPath}Z` : `M${x00},${y0}
  C${x00},${midY},${x10},${midY},${x10},${y1}
  ${endArrowPath}
  L${x11},${y1}
  C${x11},${midY},${x01},${midY},${x01},${y0}
  ${startArrowPath}
  Z`;
};
loadLinkPathComponent();
var LinkPath = class _LinkPath extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LinkPath.defaultAttributes, attributes));
  }
  render() {
    const { direction = "horizontal" } = this.attribute, parsePath = "vertical" === direction ? getVerticalPath : getHorizontalPath, isRatioShow = "number" == typeof this.attribute.ratio && this.attribute.ratio >= 0 && this.attribute.ratio <= 1, groupAttrKeys = ["direction", "x0", "x1", "y0", "y1", "thickness", "round", "ratio", "align", "isSmooth", "backgroudStyle"], commonStyle = {};
    if (Object.keys(this.attribute).forEach((key) => {
      groupAttrKeys.includes(key) || (commonStyle[key] = this.attribute[key]);
    }), isRatioShow) {
      const background = this.createOrUpdateChild("sankey-link-background", Object.assign({}, commonStyle, this.attribute.backgroudStyle, {
        path: parsePath(this.attribute, 1),
        visible: true,
        pickable: false,
        zIndex: -1
      }), "path");
      this._backPath = background;
    } else this._backPath && this._backPath.setAttribute("visible", false);
    const front = this.createOrUpdateChild("sankey-link-front", Object.assign({}, commonStyle, {
      path: parsePath(this.attribute, isRatioShow ? this.attribute.ratio : 1),
      pickable: false
    }), "path");
    this._frontPath = front;
  }
};
LinkPath.defaultAttributes = {
  direction: "horizontal",
  align: "start"
};

// node_modules/@visactor/vrender-components/es/player/controller/assets/index.js
var iconPlay = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z";
var iconPause = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z";
var iconLeft = "M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z";
var iconDown = "M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z";
var iconUp = "m 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z";
var iconRight = "M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z";

// node_modules/@visactor/vrender-components/es/player/controller/icon/icon.js
var PlayerIcon = class extends Symbol2 {
  constructor(params2) {
    super(params2);
  }
};

// node_modules/@visactor/vrender-components/es/player/controller/constant.js
var ControllerEventEnum;
!function(ControllerEventEnum2) {
  ControllerEventEnum2.OnPlay = "onPlay", ControllerEventEnum2.OnPause = "onPause", ControllerEventEnum2.OnForward = "onForward", ControllerEventEnum2.OnBackward = "onBackward";
}(ControllerEventEnum || (ControllerEventEnum = {}));
var ControllerTypeEnum;
!function(ControllerTypeEnum2) {
  ControllerTypeEnum2.Start = "start", ControllerTypeEnum2.Pause = "pause", ControllerTypeEnum2.Forward = "forward", ControllerTypeEnum2.Backward = "backward";
}(ControllerTypeEnum || (ControllerTypeEnum = {}));

// node_modules/@visactor/vrender-components/es/player/controller/controller.js
var Controller = class _Controller extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Controller.defaultAttributes, attributes)), this._isPaused = true, this.updateAttributes = () => {
      this._startAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPlay
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.start.visible
        }), this.attribute.start.style)
      }, this._pauseAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPause
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.pause.visible
        }), this.attribute.pause.style)
      }, this._forwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.forward.visible
        }), this.attribute.forward.style)
      }, this._backwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.backward.visible
        }), this.attribute.backward.style)
      }, this.updateLayout();
    }, this.updateLayout = () => {
      var _a, _b, _c, _d;
      this._layout = this.attribute.layout, "horizontal" === this._layout ? (this._backwardAttr.style.symbolType = null !== (_a = this._backwardAttr.style.symbolType) && void 0 !== _a ? _a : iconLeft, this._forwardAttr.style.symbolType = null !== (_b = this._forwardAttr.style.symbolType) && void 0 !== _b ? _b : iconRight) : "vertical" === this._layout && (this._backwardAttr.style.symbolType = null !== (_c = this._backwardAttr.style.symbolType) && void 0 !== _c ? _c : iconUp, this._forwardAttr.style.symbolType = null !== (_d = this._forwardAttr.style.symbolType) && void 0 !== _d ? _d : iconDown);
    }, this._initPlay = () => {
      isNil_default(this._playController) && (this._playController = new PlayerIcon(Object.assign({}, this._startAttr.style)), this.add(this._playController));
    }, this._initBackward = () => {
      isNil_default(this._backwardController) && (this._backwardController = new PlayerIcon(Object.assign({}, this._backwardAttr.style)), this.add(this._backwardController));
    }, this._initForward = () => {
      isNil_default(this._forwardController) && (this._forwardController = new PlayerIcon(Object.assign({}, this._forwardAttr.style)), this.add(this._forwardController));
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._playController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), true === this._isPaused ? this.play() : this.pause();
      }), this._backwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.backward();
      }), this._forwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.forward();
      }));
    }, this.renderPlay = () => {
      this._isPaused ? this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._startAttr.style)) : this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._pauseAttr.style));
    }, this.renderBackward = () => {
      this._backwardController.setAttributes(this._backwardAttr.style);
    }, this.renderForward = () => {
      this._forwardController.setAttributes(this._forwardAttr.style);
    }, this.play = () => {
      this._dispatchEvent(ControllerEventEnum.OnPlay);
    }, this.pause = () => {
      this._dispatchEvent(ControllerEventEnum.OnPause);
    }, this.forward = () => {
      this._dispatchEvent(ControllerEventEnum.OnForward);
    }, this.backward = () => {
      this._dispatchEvent(ControllerEventEnum.OnBackward);
    }, this.togglePlay = () => {
      this._playController.setAttributes(this._startAttr.style), this._isPaused = true;
    }, this.togglePause = () => {
      this._playController.setAttributes(this._pauseAttr.style), this._isPaused = false;
    }, this.updateAttributes(), this._initPlay(), this._initBackward(), this._initForward(), this._initEvents();
  }
  render() {
    this.updateAttributes(), this.renderPlay(), this.renderBackward(), this.renderForward();
  }
};
Controller.defaultControllerAttr = {
  visible: true,
  x: 0,
  y: 0,
  size: 20,
  fill: "#91caff",
  pickMode: "imprecise",
  cursor: "pointer"
}, Controller.defaultAttributes = {
  [ControllerTypeEnum.Start]: {},
  [ControllerTypeEnum.Pause]: {},
  [ControllerTypeEnum.Backward]: {},
  [ControllerTypeEnum.Forward]: {}
};

// node_modules/@visactor/vrender-components/es/player/constant.js
var defaultControllerAttributes = {
  visible: true,
  style: {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    size: 20
  },
  order: 0,
  space: 10
};
var RailDefaultSize = [200, 10];

// node_modules/@visactor/vrender-components/es/player/type/direction.js
var DirectionEnum;
!function(DirectionEnum2) {
  DirectionEnum2.Default = "default", DirectionEnum2.Reverse = "reverse";
}(DirectionEnum || (DirectionEnum = {}));

// node_modules/@visactor/vrender-components/es/player/type/event.js
var PlayerEventEnum;
!function(PlayerEventEnum2) {
  PlayerEventEnum2.change = "change", PlayerEventEnum2.play = "play", PlayerEventEnum2.pause = "pause", PlayerEventEnum2.backward = "backward", PlayerEventEnum2.forward = "forward", PlayerEventEnum2.end = "end", PlayerEventEnum2.OnChange = "change", PlayerEventEnum2.OnPlay = "play", PlayerEventEnum2.OnPause = "pause", PlayerEventEnum2.OnBackward = "backward", PlayerEventEnum2.OnForward = "forward", PlayerEventEnum2.OnEnd = "end";
}(PlayerEventEnum || (PlayerEventEnum = {}));

// node_modules/@visactor/vrender-components/es/player/utils.js
var isReachEndByDefault = ({ direction, maxIndex, dataIndex }) => direction === DirectionEnum.Default && dataIndex === maxIndex;
var isReachEndByReverse = ({ direction, minIndex, dataIndex }) => direction === DirectionEnum.Reverse && dataIndex === minIndex;
var isReachEnd = ({ direction, maxIndex, minIndex, dataIndex }) => isReachEndByDefault({
  direction,
  maxIndex,
  dataIndex
}) || isReachEndByReverse({
  direction,
  minIndex,
  dataIndex
});
var isReachStartByDefault = ({ direction, minIndex, dataIndex }) => direction === DirectionEnum.Default && dataIndex === minIndex;
var isReachStartByReverse = ({ direction, maxIndex, dataIndex }) => direction === DirectionEnum.Reverse && dataIndex === maxIndex;
var isReachStart = ({ direction, maxIndex, minIndex, dataIndex }) => isReachStartByDefault({
  direction,
  minIndex,
  dataIndex
}) || isReachStartByReverse({
  direction,
  maxIndex,
  dataIndex
});
var isHorizontal2 = (orient) => "top" === orient || "bottom" === orient;
var forwardStep = (direction, currentIndex, min3, max3) => "default" === direction ? Math.min(currentIndex + 1, max3) : Math.max(currentIndex - 1, min3);

// node_modules/@visactor/vrender-components/es/player/base-player.js
var BasePlayer = class _BasePlayer extends AbstractComponent {
  getMinIndex() {
    return this._minIndex;
  }
  getMaxIndex() {
    return this._maxIndex;
  }
  getDataIndex() {
    return this._dataIndex;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _BasePlayer.defaultAttributes, attributes)), this._data = [], this._dataIndex = 0, this._layoutInfo = {}, this._updateSliderAttrs = () => {
      var _a, _b;
      let handlerSize;
      isValidNumber_default(this._handlerStyle.size) ? handlerSize = this._handlerStyle.size : this._handlerStyle.size && this._handlerStyle.size.length && (handlerSize = max(this._handlerStyle.size[0], this._handlerStyle.size[1]));
      const attrs = {
        visible: this._sliderVisible,
        min: this._minIndex,
        max: this._maxIndex,
        value: this._dataIndex,
        railWidth: this._railStyle.width,
        railHeight: this._railStyle.height,
        railStyle: this._railStyle,
        trackStyle: this._trackStyle,
        handlerSize: isValidNumber_default(handlerSize) ? handlerSize : void 0,
        handlerStyle: this._handlerStyle,
        dy: this.attribute.slider.dy,
        dx: this.attribute.slider.dx,
        slidable: true,
        range: false,
        handlerText: {
          visible: false
        },
        startText: {
          visible: false
        },
        endText: {
          visible: false
        },
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      if (isHorizontal2(this._orient)) {
        const railWidth = Math.max(0, this._layoutInfo.slider.size), railHeight = null !== (_a = this._railStyle.height) && void 0 !== _a ? _a : RailDefaultSize[1];
        attrs.layout = "horizontal", attrs.railHeight = railHeight, attrs.railWidth = railWidth, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      } else {
        const railHeight = Math.max(0, this._layoutInfo.slider.size), railWidth = null !== (_b = this._railStyle.width) && void 0 !== _b ? _b : RailDefaultSize[1];
        attrs.layout = "vertical", attrs.railWidth = railWidth, attrs.railHeight = railHeight, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      }
      return attrs;
    }, this._initSlider = () => {
      const attrs = this._updateSliderAttrs();
      this._slider = new Slider(attrs), this._sliderVisible && this.add(this._slider);
    }, this._updateControllerAttrs = () => {
      const attrs = {
        start: this._start,
        pause: this._pause,
        forward: this._forward,
        backward: this._backward,
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      return attrs.layout = isHorizontal2(this._orient) ? "horizontal" : "vertical", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      }), attrs;
    }, this._initController = () => {
      const attrs = this._updateControllerAttrs();
      this._controller = new Controller(attrs), this._controllerVisible && this.add(this._controller);
    }, this._initAttributes(), this._initDataIndex(), this._initLayoutInfo(), this._initController(), this._initSlider();
  }
  _initAttributes() {
    this._size = this.attribute.size, this._orient = this.attribute.orient, this._data = this.attribute.data, this._minIndex = 0, this._maxIndex = this._data.length - 1;
    const { slider: slider2 = {}, controller = {} } = this.attribute;
    this._sliderVisible = slider2.visible, this._railStyle = Object.assign({}, slider2.railStyle), this._trackStyle = Object.assign({}, slider2.trackStyle), this._handlerStyle = Object.assign({}, slider2.handlerStyle), this._controllerVisible = controller.visible, this._start = Object.assign({}, controller.start), this._pause = Object.assign({}, controller.pause), this._forward = Object.assign({}, controller.forward), this._backward = Object.assign({}, controller.backward);
  }
  _initDataIndex() {
    var _a;
    this._dataIndex = null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0;
  }
  _initLayoutInfo() {
    var _a, _b, _c;
    const controllers = [this._start, this._backward, this._forward].sort((a3, b) => a3.order - b.order), startControllers = controllers.filter((d) => "end" !== d.position), endControllers = controllers.filter((d) => "end" === d.position), railSectionLength = null !== (_a = isHorizontal2(this._orient) ? this._railStyle.height : this._railStyle.width) && void 0 !== _a ? _a : RailDefaultSize[1], controllerPx = controllers.reduce((len, controller) => {
      const size = controller.style.size, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return len + controller.space + maxSize;
    }, 0), sliderPx = this._sliderVisible ? (isHorizontal2(this._orient) ? null === (_b = this._size) || void 0 === _b ? void 0 : _b.width : null === (_c = this._size) || void 0 === _c ? void 0 : _c.height) - controllerPx : 0, railPx = sliderPx - this.attribute.slider.space, startPx = startControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal2(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal2(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, 0);
    this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), {
      size: railPx,
      x: isHorizontal2(this._orient) ? startPx + this.attribute.slider.space : (this._size.width - railSectionLength) / 2,
      y: isHorizontal2(this._orient) ? (this._size.height - railSectionLength) / 2 : startPx + this.attribute.slider.space
    }), endControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal2(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal2(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, startPx + sliderPx);
  }
  render() {
    this._initLayoutInfo(), this.renderSlider(), this.renderController();
  }
  renderSlider() {
    const attrs = this._updateSliderAttrs();
    this._slider.setAttributes(attrs);
  }
  renderController() {
    const attrs = this._updateControllerAttrs();
    this._controller.setAttributes(attrs);
  }
  dispatchCustomEvent(eventType, dataIndex) {
    this._dispatchEvent(eventType, {
      eventType,
      index: dataIndex,
      value: this._data[dataIndex]
    });
  }
};
BasePlayer.defaultAttributes = {
  visible: true,
  data: [],
  interval: 1e3,
  orient: "bottom",
  align: "center",
  size: {
    height: 20,
    width: 300
  },
  slider: {
    visible: true,
    space: 10,
    dx: 0,
    dy: 0,
    railStyle: {
      cornerRadius: 5
    },
    trackStyle: {},
    handlerStyle: {}
  },
  controller: {
    visible: true,
    start: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "start",
      position: "start",
      space: 0
    }),
    pause: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "pause",
      position: "start"
    }),
    forward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "forward",
      position: "end"
    }),
    backward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "backward",
      position: "start"
    })
  }
};

// node_modules/@visactor/vrender-components/es/player/register.js
function loadBasePlayer() {
  loadSliderComponent(), registerGroup(), registerSymbol();
}
function loadDiscretePlayerComponent() {
  loadBasePlayer();
}
function loadContinuousPlayerComponent() {
  loadBasePlayer();
}

// node_modules/@visactor/vrender-components/es/player/discrete-player.js
loadDiscretePlayerComponent();
var DiscretePlayer = class extends BasePlayer {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, attributes)), this._activeIndex = -1, this._isReachEnd = false, this._initAttributes = () => {
      var _a, _b, _c;
      super._initAttributes(), this._alternate = null !== (_a = this.attribute.alternate) && void 0 !== _a && _a, this._interval = null !== (_b = this.attribute.interval) && void 0 !== _b ? _b : 1e3, this._direction = null !== (_c = this.attribute.direction) && void 0 !== _c ? _c : DirectionEnum.Default;
    }, this._initDataIndex = () => {
      var _a;
      this._dataIndex = isNil_default(this.attribute.dataIndex) ? "default" === this._direction ? this._minIndex : this._maxIndex : null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0, this._slider.setAttribute("value", this._dataIndex);
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
        e.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
        e.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
        e.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
        e.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e) => {
        const middle = Math.floor(e.detail.value) + 0.5;
        this._dataIndex = e.detail.value >= middle ? Math.ceil(e.detail.value) : Math.floor(e.detail.value), this._slider.setValue(this._dataIndex), this.dispatchCustomEvent(PlayerEventEnum.change);
      }));
    }, this.play = () => {
      this._isPlaying || 1 !== this._data.length && (this._controller.togglePause(), this._isPlaying = true, (isReachEnd({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      }) || isReachStart({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      })) && (this._direction === DirectionEnum.Default ? this._updateDataIndex(this._minIndex) : this._updateDataIndex(this._maxIndex)), this.dispatchCustomEvent(PlayerEventEnum.play), this._isReachEnd = false, this._tickTime = Date.now(), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, true)));
    }, this._play = (isFirstPlay) => {
      const now = Date.now();
      if (this._isReachEnd && now - this._tickTime >= this._interval) return this._isReachEnd = false, void this._playEnd();
      isFirstPlay && this._activeIndex !== this._dataIndex ? (this.dispatchCustomEvent(PlayerEventEnum.change), this._activeIndex = this._dataIndex) : now - this._tickTime >= this._interval && (this._tickTime = now, this._updateDataIndex(forwardStep(this._direction, this._dataIndex, this._minIndex, this._maxIndex)), this._activeIndex = this._dataIndex, this.dispatchCustomEvent(PlayerEventEnum.change)), ("default" === this._direction && this._dataIndex >= this._maxIndex || "reverse" === this._direction && this._dataIndex <= this._minIndex) && (this._isReachEnd = true), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, false));
    }, this._updateDataIndex = (dataIndex) => {
      this._dataIndex = dataIndex, this._slider.setValue(this._dataIndex);
    }, this._playEnd = () => {
      this._isPlaying = false, this._controller.togglePlay(), vglobal.getCancelAnimationFrame()(this._rafId), this._activeIndex = -1, this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const { loop = false } = this.attribute;
      let index;
      index = loop ? this._dataIndex - 1 < this._minIndex ? this._maxIndex : this._dataIndex - 1 : Math.max(this._dataIndex - 1, this._minIndex), this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const { loop = false } = this.attribute;
      let index;
      index = loop ? this._dataIndex + 1 > this._maxIndex ? this._minIndex : this._dataIndex + 1 : Math.min(this._dataIndex + 1, this._maxIndex), this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initDataIndex(), this._initEvents();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this._initAttributes();
  }
  dispatchCustomEvent(event) {
    super.dispatchCustomEvent(event, this._dataIndex);
  }
};

// node_modules/@visactor/vrender-components/es/player/continuous-player.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
loadContinuousPlayerComponent();
var ContinuousPlayer = class extends BasePlayer {
  constructor(attributes) {
    super(attributes), this._isPlaying = false, this._startTime = Date.now(), this._initAttributes = () => {
      var _a;
      super._initAttributes(), this._maxIndex = this._data.length, this._slider.setAttribute("max", this._maxIndex), this._isPlaying = false, this._elapsed = 0, this._interval = null !== (_a = this.attribute.interval) && void 0 !== _a ? _a : 1e3;
      const frames = this._data.length;
      this.attribute.totalDuration && this._data.length ? (this._totalDuration = this.attribute.totalDuration, this._interval = this._totalDuration / (null != frames ? frames : 1)) : (this._totalDuration = this._interval * frames, this._interval = this.attribute.interval);
    }, this._initDataIndex = () => {
      var _a;
      this._dataIndex = null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : this._minIndex;
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
        e.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
        e.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
        e.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
        e.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e) => {
        var _a;
        e.stopPropagation();
        const value = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.value, progress = value / this._maxIndex;
        this._elapsed = progress * this._totalDuration, this._startTime = Date.now() - this._elapsed, this._dispatchChange(value);
      }));
    }, this._getSliderValue = () => {
      const progress = this._elapsed / this._totalDuration;
      return Math.min(progress * this._maxIndex, this._maxIndex);
    }, this._updateSlider = () => {
      const value = this._getSliderValue();
      this._dataIndex = Math.floor(value), this._slider.setValue(Math.min(value, this._maxIndex)), this._dispatchChange(Math.floor(value));
    }, this._dispatchChange = (value) => {
      const index = Math.floor(value);
      index !== this._activeIndex && (this._dataIndex = index, this._activeIndex = index, index !== this._maxIndex && this.dispatchCustomEvent(PlayerEventEnum.change));
    }, this.play = () => __awaiter10(this, void 0, void 0, function* () {
      this._isPlaying || (this._controller.togglePause(), this._isPlaying = true, this._elapsed >= this._totalDuration && (this._elapsed = 0), this._startTime = Date.now() - this._elapsed, this.dispatchCustomEvent(PlayerEventEnum.play), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this)));
    }), this._play = () => {
      this._elapsed = Date.now() - this._startTime;
      const value = this._getSliderValue();
      this._updateSlider(), value >= this._maxIndex ? this._playEnd() : this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this));
    }, this._playEnd = () => {
      this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, this._elapsed = Date.now() - this._startTime, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed - interval;
      elapsed <= 0 ? (this._elapsed = 0, this._startTime = now) : (this._elapsed = elapsed, this._startTime = this._startTime + this._interval), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed + interval;
      elapsed >= this._totalDuration ? (this._startTime = now - this._totalDuration, this._elapsed = this._totalDuration) : (this._startTime = this._startTime - interval, this._elapsed = elapsed), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initDataIndex(), this._initEvents();
  }
  dispatchCustomEvent(eventType) {
    super.dispatchCustomEvent(eventType, this._dataIndex);
  }
  render() {
    super.render();
  }
};

// node_modules/@visactor/vrender-components/es/brush/type.js
var IOperateType;
!function(IOperateType2) {
  IOperateType2.drawStart = "drawStart", IOperateType2.drawEnd = "drawEnd", IOperateType2.drawing = "drawing", IOperateType2.moving = "moving", IOperateType2.moveStart = "moveStart", IOperateType2.moveEnd = "moveEnd", IOperateType2.brushActive = "brushActive", IOperateType2.brushClear = "brushClear";
}(IOperateType || (IOperateType = {}));

// node_modules/@visactor/vrender-components/es/brush/config.js
var DEFAULT_BRUSH_ATTRIBUTES = {
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: ["pointerup", "pointerleave"],
  resetTrigger: "pointerupoutside",
  hasMask: true,
  brushMode: "single",
  brushType: "rect",
  brushStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    strokeWidth: 2
  },
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 10,
  interactiveRange: {
    minY: -1 / 0,
    maxY: 1 / 0,
    minX: -1 / 0,
    maxX: 1 / 0
  }
};
var DEFAULT_SIZE_THRESHOLD = 5;

// node_modules/@visactor/vrender-components/es/brush/register.js
function loadBrushComponent() {
  registerGroup(), registerPolygon();
}

// node_modules/@visactor/vrender-components/es/brush/brush.js
var delayMap3 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadBrushComponent();
var Brush = class _Brush extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Brush.defaultAttributes, attributes)), this.name = "brush", this._activeDrawState = false, this._cacheDrawPoints = [], this._activeMoveState = false, this._operatingMaskMoveDx = 0, this._operatingMaskMoveDy = 0, this._operatingMaskMoveRangeX = [-1 / 0, 1 / 0], this._operatingMaskMoveRangeY = [-1 / 0, 1 / 0], this._brushMaskAABBBoundsDict = {}, this._firstUpdate = true, this._onBrushStart = (e) => {
      if (this._outOfInteractiveRange(e)) return void (this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)));
      const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, brushMoved = true } = this.attribute;
      array(updateTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushingWithDelay)), array(endTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushEnd)), e.stopPropagation(), this._firstUpdate = true, this._activeMoveState = brushMoved && this._isPosInBrushMask(e), this._activeDrawState = !this._activeMoveState, this._startPos = this.eventPosToStagePos(e), this._cacheDrawPoints = [this._startPos];
    }, this._onBrushing = (e) => {
      this._outOfInteractiveRange(e) || (e.stopPropagation(), this._firstUpdate ? (this._activeDrawState && this._initDraw(e), this._activeMoveState && this._initMove(e), this._firstUpdate = false) : (this._activeDrawState && this._drawing(e), this._activeMoveState && this._moving(e)));
    }, this._onBrushingWithDelay = 0 === this.attribute.delayTime ? this._onBrushing : delayMap3[this.attribute.delayType](this._onBrushing, this.attribute.delayTime), this._onBrushEnd = (e) => {
      this._releaseBrushUpdateEvents(), e.preventDefault(), this._activeDrawState && this._drawEnd(e), this._activeMoveState && this._moveEnd(e), this._activeDrawState = false, this._activeMoveState = false;
    }, this._onBrushClear = (e) => {
      e.preventDefault(), this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)), this._activeDrawState = false, this._activeMoveState = false;
    };
  }
  _bindBrushEvents() {
    if (this.releaseBrushEvents(), this.attribute.disableTriggerEvent) return;
    const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    array(trigger).forEach((t) => this.stage.addEventListener(t, this._onBrushStart)), array(resetTrigger).forEach((t) => this.stage.addEventListener(t, this._onBrushClear));
  }
  _initDraw(e) {
    const { brushMode } = this.attribute, pos = this.eventPosToStagePos(e);
    this._cacheDrawPoints.push(pos), "single" === brushMode && this._clearMask(), this._addBrushMask(), this._dispatchBrushEvent(IOperateType.drawStart, e), 1 === Object.keys(this._brushMaskAABBBoundsDict).length && this._dispatchBrushEvent(IOperateType.brushActive, e);
  }
  _initMove(e) {
    var _a, _b;
    this._cacheMovePoint = this.eventPosToStagePos(e), this._operatingMaskMoveDx = null !== (_a = this._operatingMask.attribute.dx) && void 0 !== _a ? _a : 0, this._operatingMaskMoveDy = null !== (_b = this._operatingMask.attribute.dy) && void 0 !== _b ? _b : 0;
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY: maxY2 = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, { x1, x2, y1, y2 } = this._operatingMask.globalAABBBounds, minMoveStepX = minX - x1, maxMoveStepX = maxX - x2, minMoveStepY = minY - y1, maxMoveStepY = maxY2 - y2;
    this._operatingMaskMoveRangeX = [minMoveStepX, maxMoveStepX], this._operatingMaskMoveRangeY = [minMoveStepY, maxMoveStepY], this._operatingMask.setAttribute("pickable", true), this._dispatchBrushEvent(IOperateType.moveStart, e);
  }
  _drawing(e) {
    var _a;
    const pos = this.eventPosToStagePos(e), { brushType } = this.attribute, cacheLength = this._cacheDrawPoints.length;
    if (cacheLength > 0) {
      const lastPos = null !== (_a = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) && void 0 !== _a ? _a : {};
      if (pos.x === lastPos.x && pos.y === lastPos.y) return;
    }
    "polygon" === brushType || cacheLength <= 1 ? this._cacheDrawPoints.push(pos) : this._cacheDrawPoints[cacheLength - 1] = pos;
    const maskPoints = this._computeMaskPoints();
    this._operatingMask.setAttribute("points", maskPoints), this._dispatchBrushEvent(IOperateType.drawing, e);
  }
  _moving(e) {
    const startPos = this._cacheMovePoint, pos = this.eventPosToStagePos(e);
    if (pos.x === (null == startPos ? void 0 : startPos.x) && pos.y === (null == startPos ? void 0 : startPos.y)) return;
    const moveStepX = pos.x - startPos.x, moveStepY = pos.y - startPos.y, moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) + this._operatingMaskMoveDx, moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) + this._operatingMaskMoveDy;
    this._operatingMask.setAttributes({
      dx: moveX,
      dy: moveY
    }), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchBrushEvent(IOperateType.moving, e);
  }
  _drawEnd(e) {
    const { removeOnClick = true, sizeThreshold = DEFAULT_SIZE_THRESHOLD } = this.attribute;
    if (this._outOfInteractiveRange(e)) this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e));
    else {
      const { x: x1, y: y1 } = this._startPos, { x: x2, y: y2 } = this.eventPosToStagePos(e);
      Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1 && removeOnClick ? this._isEmptyMask() || (this._clearMask(), this._dispatchBrushEvent(IOperateType.brushClear, e)) : Math.abs(x2 - x1) < sizeThreshold && Math.abs(y1 - y2) < sizeThreshold ? (delete this._brushMaskAABBBoundsDict[this._operatingMask.name], this._container.setAttributes({}), this._container.removeChild(this._operatingMask), this._isEmptyMask() && this._dispatchBrushEvent(IOperateType.brushClear, e)) : (this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchBrushEvent(IOperateType.drawEnd, e));
    }
  }
  _moveEnd(e) {
    this._operatingMask && this._operatingMask.setAttribute("pickable", false), this._dispatchBrushEvent(IOperateType.moveEnd, e);
  }
  render() {
    this._bindBrushEvents();
    const group = this.createOrUpdateChild("brush-container", {}, "group");
    this._container = group;
  }
  releaseBrushEvents() {
    const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    array(trigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushStart)), array(resetTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushClear)), this._releaseBrushUpdateEvents();
  }
  _releaseBrushUpdateEvents() {
    const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger } = this.attribute;
    array(updateTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushingWithDelay)), array(endTrigger).forEach((t) => this.stage.removeEventListener(t, this._onBrushEnd));
  }
  _computeMaskPoints() {
    const { brushType, xRange = [0, 0], yRange = [0, 0] } = this.attribute;
    let maskPoints = [];
    const startPoint = this._cacheDrawPoints[0], endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
    return maskPoints = "rect" === brushType ? [startPoint, {
      x: endPoint.x,
      y: startPoint.y
    }, endPoint, {
      x: startPoint.x,
      y: endPoint.y
    }] : "x" === brushType ? [{
      x: startPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[1]
    }, {
      x: startPoint.x,
      y: yRange[1]
    }] : "y" === brushType ? [{
      x: xRange[0],
      y: startPoint.y
    }, {
      x: xRange[0],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: startPoint.y
    }] : cloneDeep(this._cacheDrawPoints), maskPoints;
  }
  _addBrushMask() {
    var _a;
    const { brushStyle, hasMask } = this.attribute, brushMask = graphicCreator.polygon(Object.assign(Object.assign({
      points: cloneDeep(this._cacheDrawPoints),
      cursor: "move",
      pickable: false
    }, brushStyle), {
      opacity: hasMask ? null !== (_a = brushStyle.opacity) && void 0 !== _a ? _a : 1 : 0
    }));
    brushMask.name = `brush-${Date.now()}`, this._operatingMask = brushMask, this._container.add(brushMask), this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
  }
  _isPosInBrushMask(e) {
    const pos = this.eventPosToStagePos(e), brushMasks = this._container.getChildren();
    for (let i = 0; i < brushMasks.length; i++) {
      const { points = [], dx = 0, dy = 0 } = brushMasks[i].attribute, pointsConsiderOffset = points.map((point6) => ({
        x: point6.x + dx,
        y: point6.y + dy
      }));
      if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y)) return this._operatingMask = brushMasks[i], true;
    }
    return false;
  }
  _outOfInteractiveRange(e) {
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY: maxY2 = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, pos = this.eventPosToStagePos(e);
    return pos.x > maxX || pos.x < minX || pos.y > maxY2 || pos.y < minY;
  }
  eventPosToStagePos(e) {
    return this.stage.eventPointTransform(e);
  }
  _dispatchBrushEvent(operateType, e) {
    this._dispatchEvent(operateType, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    });
  }
  _clearMask() {
    this._brushMaskAABBBoundsDict = {}, this._container.incrementalClearChild(), this._operatingMask = null;
  }
  _isEmptyMask() {
    return isEmpty_default(this._brushMaskAABBBoundsDict) || Object.keys(this._brushMaskAABBBoundsDict).every((key) => this._brushMaskAABBBoundsDict[key].empty());
  }
};
Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;

// node_modules/@visactor/vrender-components/es/tooltip/util.js
var mergeRowAttrs = (target, ...sources) => {
  const shapeList = [target.shape, ...sources.map((s2) => null == s2 ? void 0 : s2.shape)], keyList = [target.key, ...sources.map((s2) => null == s2 ? void 0 : s2.key)], valueList = [target.value, ...sources.map((s2) => null == s2 ? void 0 : s2.value)];
  return merge(target, ...sources, {
    shape: shapeList.every(isNil_default) ? void 0 : merge({}, ...shapeList),
    key: keyList.every(isNil_default) ? void 0 : merge({}, ...keyList),
    value: valueList.every(isNil_default) ? void 0 : merge({}, ...valueList)
  });
};
var getRichTextAttribute = (attr) => {
  const { width, height, wordBreak = "break-word", textAlign, textBaseline, text: text2 } = attr;
  return Array.isArray(text2) ? {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: array(text2).map((text3) => Object.assign(Object.assign({}, attr), {
      text: text3
    }))
  } : {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: null == text2 ? void 0 : text2.text
  };
};

// node_modules/@visactor/vrender-components/es/tooltip/config.js
var defaultAttributes = {
  panel: {
    visible: true,
    cornerRadius: [3, 3, 3, 3],
    fill: "white",
    shadow: true,
    shadowBlur: 12,
    shadowColor: "rgba(0, 0, 0, 0.1)",
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowSpread: 0,
    stroke: "white"
  },
  titleStyle: {
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 14,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle"
    },
    spaceRow: 6
  },
  contentStyle: {
    shape: {
      fill: "black",
      size: 8,
      symbolType: "circle",
      spacing: 6
    },
    key: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle",
      spacing: 26
    },
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY2,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "right",
      textBaseline: "middle",
      spacing: 0
    },
    spaceRow: 6
  },
  padding: 10,
  positionX: "right",
  positionY: "bottom",
  offsetX: 10,
  offsetY: 10,
  parentBounds: new AABBBounds().setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
  autoCalculatePosition: true,
  autoMeasure: true,
  pickable: false,
  childrenPickable: false,
  zIndex: 500
};
var TOOLTIP_POSITION_ATTRIBUTES = ["pointerX", "pointerY", "offsetX", "offsetY", "positionX", "positionY", "parentBounds"];

// node_modules/@visactor/vrender-components/es/tooltip/register.js
function loadTooltipComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/tooltip/tooltip.js
loadTooltipComponent();
var Tooltip = class _Tooltip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tooltip.defaultAttributes, attributes), options), this.name = "tooltip";
  }
  render() {
    var _a;
    const { visible, content, panel, keyWidth, valueWidth, hasContentShape, autoCalculatePosition, autoMeasure, align } = this.attribute;
    if (!visible) return void this.hideAll();
    autoMeasure && _Tooltip.measureTooltip(this.attribute), autoCalculatePosition && _Tooltip.calculateTooltipPosition(this.attribute);
    const padding = normalizePadding(this.attribute.padding);
    this._tooltipPanel = this.createOrUpdateChild("tooltip-background", Object.assign({
      visible: true
    }, panel), "rect"), this._tooltipTitleContainer = this.createOrUpdateChild("tooltip-title", {
      visible: true,
      x: padding[3],
      y: padding[0]
    }, "group");
    const titleAttr = _Tooltip.getTitleAttr(this.attribute);
    this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-shape", merge({
      symbolType: "circle"
    }, titleAttr.shape, {
      visible: isVisible(titleAttr) && isVisible(titleAttr.shape)
    }), "symbol"), "object" != typeof titleAttr.value.text || null === titleAttr.value.text || "rich" !== titleAttr.value.text.type && "html" !== titleAttr.value.text.type ? titleAttr.value.multiLine ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      text: null !== (_a = titleAttr.value.text) && void 0 !== _a ? _a : "",
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, titleAttr.value), "text") : "rich" === titleAttr.value.text.type ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : "html" === titleAttr.value.text.type && (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      html: Object.assign(Object.assign({
        dom: titleAttr.value.text.text
      }, DEFAULT_HTML_TEXT_SPEC), titleAttr.value),
      visible: isVisible(titleAttr) && isVisible(titleAttr.value),
      width: titleAttr.value.width,
      height: titleAttr.value.height,
      wordBreak: titleAttr.value.wordBreak,
      textAlign: titleAttr.value.textAlign,
      textBaseline: titleAttr.value.textBaseline,
      singleLine: false,
      textConfig: []
    }, titleAttr.value), "richtext"));
    const titlePaddingLeft = isVisible(titleAttr.shape) ? titleAttr.shape.size + titleAttr.shape.spacing : 0, { textAlign, textBaseline } = titleAttr.value, contentWidth = panel.width - padding[3] - padding[0] - titlePaddingLeft;
    "center" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth / 2) : "right" === textAlign || "end" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth) : this._tooltipTitle.setAttribute("x", titlePaddingLeft), "bottom" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height) : "middle" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height / 2) : this._tooltipTitle.setAttribute("y", 0);
    const titleHeight = isVisible(titleAttr) ? titleAttr.height + titleAttr.spaceRow : 0;
    if (this._tooltipContent = this.createOrUpdateChild("tooltip-content", {
      visible: true
    }, "group"), this._tooltipContent.removeAllChild(true), content && content.length) {
      this._tooltipContent.setAttribute("x", padding[3]), this._tooltipContent.setAttribute("y", padding[0] + titleHeight);
      let lastYPos = 0;
      content.forEach((item, i) => {
        const itemAttr = _Tooltip.getContentAttr(this.attribute, i);
        if (!isVisible(itemAttr)) return;
        const itemGroupName = `tooltip-content-${i}`, itemGroup = this._tooltipContent.createOrUpdateChild(itemGroupName, {
          visible: true,
          x: 0,
          y: lastYPos
        }, "group"), shapeOffsetWidth = itemAttr.shape.size + itemAttr.shape.spacing;
        let x = "right" === align ? (hasContentShape ? shapeOffsetWidth : 0) + (isVisible(itemAttr.key) ? keyWidth + itemAttr.key.spacing : 0) + (isVisible(itemAttr.value) ? valueWidth : 0) : 0;
        this._createShape("right" === align ? x - itemAttr.shape.size / 2 : x + itemAttr.shape.size / 2, itemAttr, itemGroup, itemGroupName), hasContentShape && ("right" === align ? x -= shapeOffsetWidth : x += shapeOffsetWidth);
        const keyGraphic = this._createKey(itemAttr, itemGroup, itemGroupName);
        keyGraphic && (alignTextInLine(align, keyGraphic, itemAttr.key.textAlign, x, keyWidth), keyGraphic.setAttribute("y", 0), "right" === align ? x -= keyWidth + itemAttr.key.spacing : x += keyWidth + itemAttr.key.spacing);
        const valueGraphic = this._createValue(itemAttr, itemGroup, itemGroupName);
        if (valueGraphic) {
          let textAlign2 = "right";
          isValid_default(itemAttr.value.textAlign) ? textAlign2 = itemAttr.value.textAlign : isVisible(itemAttr.key) || "right" === align || (textAlign2 = "left"), valueGraphic.setAttribute("textAlign", textAlign2), alignTextInLine(align, valueGraphic, textAlign2, x, valueWidth), valueGraphic.setAttribute("y", 0);
        }
        lastYPos += itemAttr.height + itemAttr.spaceRow;
      });
    }
  }
  _createShape(x, itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.shape)) return itemGroup.createOrUpdateChild(`${itemGroupName}-shape`, Object.assign({
      visible: true,
      x,
      y: itemAttr.shape.size / 2 + ((null !== (_a = calculateLineHeight(itemAttr.key.lineHeight, itemAttr.key.fontSize)) && void 0 !== _a ? _a : itemAttr.key.fontSize) - itemAttr.shape.size) / 2
    }, itemAttr.shape), "symbol");
  }
  _createKey(itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.key)) {
      let element;
      return element = itemAttr.key.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.key)), {
        textBaseline: "top"
      }), "richtext") : "object" != typeof itemAttr.key.text || null === itemAttr.key.text || "rich" !== itemAttr.key.text.type && "html" !== itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
        visible: true,
        text: null !== (_a = itemAttr.key.text) && void 0 !== _a ? _a : ""
      }, itemAttr.key), {
        textBaseline: "top"
      }), "text") : "rich" === itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.key)), {
        textBaseline: "top"
      }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
        html: Object.assign(Object.assign({
          dom: itemAttr.key.text.text
        }, DEFAULT_HTML_TEXT_SPEC), itemAttr.key)
      }, "richtext"), element;
    }
  }
  _createValue(itemAttr, itemGroup, itemGroupName) {
    var _a;
    if (isVisible(itemAttr.value)) {
      let element;
      return element = itemAttr.value.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.value)), {
        textBaseline: "top"
      }), "richtext") : "object" != typeof itemAttr.value.text || null === itemAttr.value.text || "rich" !== itemAttr.value.text.type && "html" !== itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true,
        text: null !== (_a = itemAttr.value.text) && void 0 !== _a ? _a : ""
      }, itemAttr.value), {
        textBaseline: "top"
      }), "text") : "rich" === itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
        visible: true
      }, getRichTextAttribute(itemAttr.value)), {
        textBaseline: "top"
      }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
        html: Object.assign({
          dom: itemAttr.value.text.text,
          container: "",
          width: 30,
          height: 30,
          style: {}
        }, itemAttr.value)
      }, "richtext"), element;
    }
  }
  setAttributes(params2, forceUpdateTag) {
    const keys = Object.keys(params2);
    this.attribute.autoCalculatePosition && keys.every((key) => TOOLTIP_POSITION_ATTRIBUTES.includes(key)) ? (this._mergeAttributes(params2, keys), isNil_default(this.attribute.panel.width) && this.attribute.autoMeasure && _Tooltip.measureTooltip(this.attribute), _Tooltip.calculateTooltipPosition(this.attribute), super.setAttributes({
      x: this.attribute.x,
      y: this.attribute.y
    }, forceUpdateTag)) : super.setAttributes(params2, forceUpdateTag);
  }
  static calculateTooltipPosition(attribute) {
    const { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = attribute.panel, { offsetX, offsetY, pointerX, pointerY, positionX, positionY, parentBounds } = attribute;
    let x = pointerX, y = pointerY;
    return "left" === positionX ? x -= tooltipBoxWidth + offsetX : "center" === positionX ? x -= tooltipBoxWidth / 2 : x += offsetX, "top" === positionY ? y -= tooltipBoxHeight + offsetY : "middle" === positionY ? y -= tooltipBoxHeight / 2 : y += offsetY, x + tooltipBoxWidth > parentBounds.x2 && (x -= tooltipBoxWidth + offsetX), y + tooltipBoxHeight > parentBounds.y2 && (y -= tooltipBoxHeight + offsetY), x < parentBounds.x1 && (x = parentBounds.x1), y < parentBounds.y1 && (y = parentBounds.y1), attribute.x = x, attribute.y = y, attribute;
  }
  static measureTooltip(attribute) {
    const { content, contentStyle } = attribute, padding = normalizePadding(attribute.padding), titleAttr = _Tooltip.getTitleAttr(attribute);
    let maxWidth = 0, containerHeight = padding[0] + padding[2], titleMaxHeight = 0;
    const { value: titleValue, shape: titleShape } = titleAttr, { visible: titleHasShape = false, symbolType: titleShapeType = "" } = null != titleShape ? titleShape : {};
    if (isValid_default(titleValue) && "object" != typeof titleAttr.value.text) {
      const { width, height } = initTextMeasure(titleValue).quickMeasure(titleValue.text);
      maxWidth = width, titleMaxHeight = height;
    }
    if (titleHasShape && builtinSymbolsMap[titleShapeType] && (maxWidth += titleShape.size + titleShape.spacing, titleMaxHeight = Math.max(titleShape.size, titleMaxHeight)), attribute.title && (attribute.title.width = maxWidth, attribute.title.height = titleMaxHeight), isVisible(titleAttr) && (containerHeight += titleMaxHeight + titleAttr.spaceRow), content && content.length) {
      const filteredContent = [];
      if (content.forEach((item, i) => {
        const itemAttr = _Tooltip.getContentAttr(attribute, i);
        (item.key || item.value) && isVisible(itemAttr) && filteredContent.push([item, itemAttr]);
      }), filteredContent.length) {
        let hasContentShape = false;
        const shapeWidths = [], keyWidths = [], valueWidths = [];
        filteredContent.forEach(([item, itemAttr], i) => {
          var _a;
          const { key, value, shape, spaceRow } = itemAttr, itemHasShape = isVisible(shape), itemShapeType = null !== (_a = null == shape ? void 0 : shape.symbolType) && void 0 !== _a ? _a : "", keyTextMeasure = initTextMeasure(key), valueTextMeasure = initTextMeasure(value);
          let itemHeight = 0;
          if (isVisible(key)) {
            const { width, height } = keyTextMeasure.quickMeasure(key.text);
            keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          if (isVisible(value)) {
            const { width, height } = valueTextMeasure.quickMeasure(value.text);
            valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          itemHasShape && builtinSymbolsMap[itemShapeType] && (hasContentShape = true, shapeWidths.push(shape.size), itemHeight = Math.max(shape.size, itemHeight)), item.height = itemHeight, containerHeight += itemHeight, i < filteredContent.length - 1 && (containerHeight += null != spaceRow ? spaceRow : contentStyle.spaceRow);
        });
        const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : 0, maxKeyWidth = keyWidths.length ? Math.max(...keyWidths) : 0, maxValueWidth = valueWidths.length ? Math.max(...valueWidths) : 0;
        maxWidth = Math.max(maxKeyWidth + maxValueWidth + contentStyle.key.spacing + contentStyle.value.spacing + (hasContentShape ? maxShapeWidth + contentStyle.shape.spacing : 0), maxWidth), content.forEach((item) => {
          item.width = maxWidth;
        }), attribute.hasContentShape = hasContentShape, attribute.keyWidth = maxKeyWidth, attribute.valueWidth = maxValueWidth;
      }
    }
    return attribute.panel.width = maxWidth + padding[1] + padding[3], attribute.panel.height = containerHeight, attribute;
  }
  static getTitleAttr(attribute) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.titleStyle, _Tooltip.defaultAttributes.title, attribute.titleStyle, attribute.title);
  }
  static getContentAttr(attribute, index) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.contentStyle, attribute.contentStyle, attribute.content[index]);
  }
};
Tooltip.defaultAttributes = defaultAttributes;

// node_modules/@visactor/vrender-components/es/timeline/register.js
function loadTimelineComponent() {
  registerGroup(), registerText(), registerSymbol(), registerLine();
}

// node_modules/@visactor/vrender-components/es/timeline/timeline.js
loadTimelineComponent();
var Timeline = class _Timeline extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Timeline.defaultAttributes, attributes)), this.name = "timeline";
  }
  render() {
    const { width, lineStyle, activeLineStyle, symbolStyle, activeSymbolStyle, labelStyle, activeLabelStyle, times, pointLayoutMode, labelSpace, clipRange, animation } = this.attribute;
    if (!times || !times.length) return;
    const symbolHeight = (isArray_default(symbolStyle.size) ? symbolStyle.size[1] : symbolStyle.size) || 0, activeSymbolHeight = (isArray_default(activeSymbolStyle.size) ? activeSymbolStyle.size[1] : activeSymbolStyle.size) || 0, lineSymbolHeight = Math.max(lineStyle.lineWidth || 0, activeLineStyle.lineWidth || 0, symbolHeight, activeSymbolHeight), lineY = lineSymbolHeight / 2, lineAttr = {
      y: lineY,
      points: [{
        x: 0,
        y: 0
      }, {
        x: width,
        y: 0
      }]
    };
    this._line = this.createOrUpdateChild("line-axes", Object.assign(Object.assign({}, lineStyle), lineAttr), "line"), this._activeLine = this.createOrUpdateChild("active-line-axes", Object.assign(Object.assign(Object.assign({}, activeLineStyle), lineAttr), {
      clipRange
    }), "line");
    const activeWidth = width * clipRange, symbolGroup = this.createOrUpdateChild("symbol-group", {
      y: lineY
    }, "group"), symbolSpace = 1 === times.length ? width : "space-between" === pointLayoutMode ? width / (times.length - 1) : width / times.length, symbolStartX = "space-between" === pointLayoutMode ? 0 : symbolSpace / 2;
    this._timesPercent = times.map((_, i) => (symbolStartX + symbolSpace * i) / width), times.forEach((item, i) => {
      const x = this._timesPercent[i] * width;
      symbolGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, symbolStyle), {
        x
      }), "symbol");
    }), this._symbolGroup = symbolGroup;
    const labelY = lineSymbolHeight + labelSpace, labelGroup = this.createOrUpdateChild("label-group", {
      y: labelY
    }, "group");
    times.forEach((item, i) => {
      const x = this._timesPercent[i] * width;
      labelGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, labelStyle), {
        x,
        text: item.label
      }), "text");
    }), this._labelGroup = labelGroup;
    const setActive = (group, activeStyle) => {
      group.forEachChildren((label) => {
        if (label.currentStates) {
          const currentStates = label.currentStates;
          label.clearStates(), label.useStates(currentStates, false);
        }
        label.states = {
          active: activeStyle
        }, label.attribute.x <= activeWidth && label.useStates(["active"], animation);
      });
    };
    setActive(labelGroup, activeLabelStyle), setActive(symbolGroup, activeSymbolStyle);
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut" } = animateConfig, { activeLabelStyle, activeSymbolStyle } = this.attribute, percent = duration / 1e3, lineDuration = 500 * percent, activeLineDuration = 200 * percent, perSymbolDuration = 100 * percent, perSymbolNormalDuration = 90 * percent, symbolDelay = 100 * percent, symbolNormalDelay = 600 * percent;
    if (this._line && (this._line.setAttributes({
      clipRange: 0
    }), this._line.animate().to({
      clipRange: 1
    }, lineDuration, easing)), this._activeLine && (this._activeLine.setAttributes({
      opacity: 0
    }), this._activeLine.animate().wait(500).to({
      opacity: 1
    }, activeLineDuration, easing)), this._symbolGroup) {
      const size = this._symbolGroup.count - 1, delay = percent * (1 === size ? 0 : 400 / (size - 1)), delayNormal = percent * (1 === size ? 0 : 240 / (size - 1));
      this._symbolGroup.forEachChildren((symbol, i) => {
        const originAttrs = {};
        Object.keys(activeSymbolStyle).forEach((k2) => {
          originAttrs[k2] = symbol.attribute[k2];
        }), symbol.setAttributes({
          opacity: 0
        }), symbol.animate().wait(symbolDelay + delay * i).to({
          opacity: 1
        }, perSymbolDuration, easing), symbol.animate().wait(symbolNormalDelay + delayNormal * i).to(Object.assign({}, activeSymbolStyle), perSymbolNormalDuration, easing).to(Object.assign({}, originAttrs), perSymbolNormalDuration, easing);
      });
    }
    if (this._labelGroup) {
      const size = this._labelGroup.count - 1, delay = percent * (1 === size ? 0 : 400 / (size - 1)), delayNormal = percent * (1 === size ? 0 : 240 / (size - 1));
      this._labelGroup.forEachChildren((label, i) => {
        const originAttrs = {};
        Object.keys(activeLabelStyle).forEach((k2) => {
          originAttrs[k2] = label.attribute[k2];
        }), label.setAttributes({
          opacity: 0
        }), label.animate().wait(symbolDelay + delay * i).to({
          opacity: 1
        }, perSymbolDuration, easing), label.animate().wait(symbolNormalDelay + delayNormal * i).to(Object.assign({
          dy: 10
        }, activeLabelStyle), perSymbolNormalDuration, easing).to(Object.assign({
          dy: 0
        }, originAttrs), perSymbolNormalDuration, easing);
      });
    }
  }
  goto(flag, animateConfig) {
    let { clipRange } = this.attribute;
    const { animation } = this.attribute;
    if (flag > 0) {
      if (clipRange >= 1) return;
      clipRange < 0 && (clipRange = 0);
    } else {
      if (clipRange <= 0) return;
      clipRange > 1 && (clipRange = 1);
    }
    clipRange !== this.attribute.clipRange && this.setAttributes({
      clipRange
    });
    let i = 0;
    for (; i < this._timesPercent.length && !(clipRange < this._timesPercent[i]); i++) ;
    const nextClipRange = flag > 0 ? this._timesPercent[i] || 1 : this._timesPercent[i - 1] || 0;
    if (animation) {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this.animate().to({
        clipRange: nextClipRange
      }, duration, easing);
    } else this.setAttributes({
      clipRange: nextClipRange
    });
  }
  forward(animateConfig) {
    this.goto(1, animateConfig);
  }
  backward(animateConfig) {
    this.goto(-1, animateConfig);
  }
};
Timeline.defaultAttributes = {
  labelSpace: 10,
  pointLayoutMode: "space-around",
  animation: true,
  symbolStyle: {
    fill: "black",
    size: 12,
    symbolType: "circle"
  },
  activeSymbolStyle: {
    fill: "orange",
    size: 16
  },
  lineStyle: {
    lineDash: [2, 2],
    lineCap: "butt",
    stroke: "black",
    lineWidth: 2
  },
  activeLineStyle: {
    stroke: "orange",
    lineWidth: 4
  },
  labelStyle: {
    fontSize: 12,
    fill: "black",
    textAlign: "center",
    textBaseline: "top"
  },
  activeLabelStyle: {
    fontSize: 14,
    fill: "orange"
  },
  clipRange: 0
};

// node_modules/@visactor/vrender-components/es/checkbox/register.js
function loadCheckBoxComponent() {
  registerGroup(), registerRect(), registerText(), registerImage();
}

// node_modules/@visactor/vrender-components/es/checkbox/checkbox.js
var checkSvg = '<svg width="200" height="200" viewBox="0 0 1024 1024" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z"></path></svg>';
var indeterminateSvg = '<svg width="200" height="200" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none"><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="5" d="M5 12h14"/></svg>';
loadCheckBoxComponent();
var CheckBox = class _CheckBox extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CheckBox.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || (this.attribute.checked ? (this.setAttribute("checked", false), this.setAttribute("indeterminate", false)) : (this.setAttribute("checked", true), this.setAttribute("indeterminate", false)), this._dispatchEvent("checkbox_state_change", {
        eventType: "checkbox_state_change",
        checked: this.attribute.checked
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderBox(), this.renderIcon(), this.renderText(), this.layout();
  }
  renderBox() {
    this._box = new Rect(merge({}, this.attribute.box));
    const isCheckedOrIndeterminate = this.attribute.checked || this.attribute.indeterminate;
    isCheckedOrIndeterminate && this.attribute.disabled ? this._box.setAttributes({
      fill: this.attribute.box.disableCheckedFill,
      stroke: this.attribute.box.disableCheckedStroke
    }) : isCheckedOrIndeterminate ? this._box.setAttributes({
      fill: this.attribute.box.checkedFill,
      stroke: this.attribute.box.checkedStroke
    }) : this.attribute.disabled && this._box.setAttributes({
      fill: this.attribute.box.disableFill
    }), this.appendChild(this._box);
  }
  renderIcon() {
    this._checkIcon = new Image(merge({
      image: this.attribute.icon.checkIconImage
    }, this.attribute.icon)), this.appendChild(this._checkIcon), this._indeterminateIcon = new Image(merge({
      image: this.attribute.icon.indeterminateIconImage
    }, this.attribute.icon)), this.appendChild(this._indeterminateIcon), this.attribute.checked ? (this._checkIcon.setAttribute("visible", true), this._indeterminateIcon.setAttribute("visible", false)) : this.attribute.indeterminate ? (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", true)) : (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", false));
  }
  renderText() {
    this._text = new Text(merge({
      wrap: true
    }, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    const boxHeight = this.attribute.box.height, iconHeight = this.attribute.icon.height, textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(boxHeight, iconHeight, textHeight), boxY = maxHeight / 2 - boxHeight / 2, iconY = maxHeight / 2 - iconHeight / 2, textY = maxHeight / 2 - textHeight / 2, boxWidth = this.attribute.box.width, iconWidth = this.attribute.icon.width, maxWidth = Math.max(boxWidth, iconWidth), boxX = maxWidth / 2 - boxWidth / 2, iconX = maxWidth / 2 - iconWidth / 2, textX = maxWidth + this.attribute.spaceBetweenTextAndIcon;
    this._box.setAttributes({
      x: boxX,
      y: boxY
    }), this._checkIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._indeterminateIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._text.setAttributes({
      x: textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _CheckBox.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
CheckBox.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  indeterminate: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  spaceBetweenTextAndIcon: 8,
  text: {
    text: "text",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    textBaseline: "top",
    pickable: false
  },
  icon: {
    checkIconImage: checkSvg,
    indeterminateIconImage: indeterminateSvg,
    width: 10,
    height: 10,
    pickable: false
  },
  box: {
    width: 14,
    height: 14,
    cornerRadius: 2,
    fill: "#fff",
    stroke: "rgb(229,230,235)",
    disableFill: "rgb(242,243,245)",
    checkedFill: "rgb(22, 93, 255)",
    checkedStroke: "rgb(22, 93, 255)",
    disableCheckedFill: "rgb(148, 191, 255)",
    disableCheckedStroke: "rgb(148, 191, 255)",
    pickable: false
  }
};

// node_modules/@visactor/vrender-components/es/radio/register.js
function loadRadioComponent() {
  registerGroup(), registerRect(), registerWrapText(), registerImage();
}

// node_modules/@visactor/vrender-components/es/radio/radio.js
loadRadioComponent();
var Radio = class _Radio extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Radio.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || this.attribute.checked || (this.setAttribute("checked", true), this._dispatchEvent("radio_checked", {
        eventType: "radio_checked",
        target: this
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderCircle(), this.renderText(), this.layout();
  }
  renderCircle() {
    this._circle = new Arc(merge({}, this.attribute.circle));
    const isChecked = this.attribute.checked;
    isChecked && this.attribute.disabled ? this._circle.setAttributes({
      fill: this.attribute.circle.disableCheckedFill,
      stroke: this.attribute.circle.disableCheckedStroke
    }) : isChecked ? this._circle.setAttributes({
      fill: this.attribute.circle.checkedFill,
      stroke: this.attribute.circle.checkedStroke
    }) : this.attribute.disabled && this._circle.setAttributes({
      fill: this.attribute.circle.disableFill
    }), this.appendChild(this._circle);
  }
  renderText() {
    this._text = new Text(merge({}, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    const circleHeight = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth), textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(circleHeight, textHeight), circleY = maxHeight / 2 - circleHeight / 2 + this.attribute.circle.outerRadius + this.attribute.circle.lineWidth, textY = maxHeight / 2 - textHeight / 2, circleWidth = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth), circleX = this.attribute.circle.outerRadius + this.attribute.circle.lineWidth, textX = circleWidth + this.attribute.spaceBetweenTextAndIcon;
    this._circle.setAttributes({
      x: circleX,
      y: circleY
    }), this._text.setAttributes({
      x: textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Radio.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
Radio.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  spaceBetweenTextAndIcon: 8,
  text: {
    text: "text",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    textBaseline: "top",
    pickable: false
  },
  circle: {
    outerRadius: 7,
    innerRadius: 3,
    startAngle: 0,
    endAngle: 2 * Math.PI,
    lineWidth: 1,
    fill: "#fff",
    stroke: "rgb(229,230,235)",
    disableFill: "rgb(242,243,245)",
    checkedFill: "rgb(22, 93, 255)",
    checkedStroke: "rgb(22, 93, 255)",
    disableCheckedFill: "rgb(148, 191, 255)",
    disableCheckedStroke: "rgb(148, 191, 255)",
    pickable: false
  }
};

// node_modules/@visactor/vrender-components/es/empty-tip/register.js
function loadEmptyTipComponent() {
  registerGroup(), registerText(), registerImage();
}

// node_modules/@visactor/vrender-components/es/empty-tip/empty-tip.js
var emptyTipSvg = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
loadEmptyTipComponent();
var EmptyTip = class _EmptyTip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _EmptyTip.defaultAttributes, attributes));
  }
  render() {
    this.removeAllChild(true), this.renderIcon(), this.renderText(), this.layout();
  }
  renderIcon() {
    this._emptyTipIcon = new Image(merge({
      image: this.attribute.icon.image
    }, this.attribute.icon)), this.appendChild(this._emptyTipIcon);
  }
  renderText() {
    this._text = new Text(merge({
      wrap: true
    }, this.attribute.text)), this.appendChild(this._text);
  }
  layout() {
    const iconHeight = this.attribute.icon.height, textHeight = this._text.AABBBounds.height(), iconWidth = this.attribute.icon.width, { width, height, spaceBetweenTextAndIcon } = this.attribute;
    this._emptyTipIcon.setAttribute("x", width / 2 - iconWidth / 2), this._emptyTipIcon.setAttribute("y", height / 2 - iconHeight / 2 - textHeight / 2 - spaceBetweenTextAndIcon / 2), this._text.setAttribute("x", width / 2), this._text.setAttribute("textAlign", "center"), this._text.setAttribute("y", height / 2 + iconHeight / 2 + spaceBetweenTextAndIcon / 2), this._text.setAttribute("textBaseline", "middle");
  }
};
EmptyTip.defaultAttributes = {
  spaceBetweenTextAndIcon: 20,
  text: {
    text: "no data",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    pickable: false
  },
  icon: {
    image: emptyTipSvg,
    width: 100,
    height: 100,
    pickable: false
  }
};

// node_modules/@visactor/vrender-components/es/weather/weather-box.js
function random() {
  return Math.random();
}
function createUniformRandom(count) {
  const result2 = [], step = 1 / count;
  for (let i = 0; i < count; i++) result2.push((random() - 0.5) * step / 2 + step * i);
  result2.sort(() => Math.random() - 0.5);
  let idx2 = 0;
  return function(i) {
    return idx2 > count - 1 && (idx2 = 0), void 0 === i && (i = idx2, idx2++), result2[i];
  };
}
var WeatherBox = class _WeatherBox extends AbstractComponent {
  constructor(attributes, options) {
    var _a;
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _WeatherBox.defaultAttributes, attributes)), this.name = "weatherBox", this.timeline = null !== (_a = null == options ? void 0 : options.timeline) && void 0 !== _a ? _a : new DefaultTimeline();
  }
  render() {
    const { rainRatio, rainIconPath, snowRatio, snowIconPath, rainCountThreshold, snowCountThreshold, windRatio, rainSizeRange, snowSizeRange, rainSpeed, snowSpeed, width, height, windIconPath, windSize, windSpeed } = this.attribute;
    this.attribute.clip = true;
    const windAngle = -windRatio * Math.PI / 4, rainGroup = this.createOrUpdateChild("rain-container", {
      zIndex: 1,
      width,
      height
    }, "group");
    rainRatio > 0 && this.generateRainOrSnow("rain", rainRatio, rainCountThreshold, windRatio, rainGroup, rainIconPath, windAngle, rainSizeRange, rainSpeed);
    const snowGroup = this.createOrUpdateChild("snow-container", {
      zIndex: 1,
      width,
      height
    }, "group");
    snowRatio > 0 && this.generateRainOrSnow("snow", snowRatio, snowCountThreshold, windRatio, snowGroup, snowIconPath, windAngle, snowSizeRange, snowSpeed);
    const windGroup = this.createOrUpdateChild("wind-container", {
      zIndex: 0,
      width,
      height
    }, "group");
    windRatio > 0 && this.generateWind(windRatio, windIconPath, windGroup, windSize, windSpeed);
  }
  generateWind(windRatio, windIconPath, group, size, speed) {
    const { width, height } = group.attribute, { windAnimateEffect, windStyle = {} } = this.attribute;
    let fromAttribute = {
      opacity: 0,
      clipRange: 1
    }, toAttribute = {
      opacity: 1,
      clipRange: 1
    };
    "clipRange" === windAnimateEffect && (fromAttribute = {
      clipRange: 0,
      opacity: 1
    }, toAttribute = {
      clipRange: 1,
      opacity: 1
    });
    const wind = group.createOrUpdateChild("wind", Object.assign(Object.assign({
      x: (width - size) / 2,
      y: (height - size) / 2,
      symbolType: windIconPath,
      size,
      stroke: "white",
      lineWidth: 2,
      dx: -size / 2,
      dy: -size / 2
    }, windStyle), fromAttribute), "symbol"), duration = speed / 4 * 1e3;
    new Animate(void 0, this.timeline).bind(wind).to(fromAttribute, duration, "linear").to(toAttribute, duration, "linear").wait(duration / 2).loop(1 / 0);
  }
  generateRainOrSnow(type, ratio, threshold, windRatio, group, path, windAngle, sizeRange, speed) {
    let { width } = group.attribute;
    const { height } = group.attribute, { snowRainBottomPadding, rainStyle = {}, snowStyle = {} } = this.attribute;
    let maxCount = Math.round(ratio * threshold);
    windRatio > 0 && (maxCount *= Math.round(1 + windRatio)), width *= Math.round(1 + windRatio);
    const uniformRandomX = createUniformRandom(maxCount), uniformRandomY = createUniformRandom(maxCount);
    for (let i = 0; i < maxCount; i++) {
      const x = uniformRandomX(), y = uniformRandomY(), size = sizeRange[0] + random() * (sizeRange[1] - sizeRange[0]), startX = x * width - (windAngle ? height * Math.tan(Math.abs(windAngle)) : 0), startY = -y * height, particle = group.createOrUpdateChild(`${type}-${i}`, Object.assign({
        x: startX,
        y: startY,
        symbolType: path,
        size,
        fill: "white",
        angle: windAngle
      }, "rain" === type ? rainStyle : snowStyle), "symbol"), duration = 1 / speed / 2 * (1 + y) * 1e3;
      let endX = x * width;
      "rain" === type && windAngle && (endX = startX + (1 + y) * height * Math.tan(Math.abs(windAngle))), new Animate(void 0, this.timeline).bind(particle).to({
        x: endX,
        y: height - snowRainBottomPadding
      }, duration, "linear").loop(1 / 0), new Animate(void 0, this.timeline).bind(particle).to({
        opacity: 0
      }, duration, "quintIn").loop(1 / 0);
    }
  }
};
WeatherBox.defaultAttributes = {
  snowIconPath: "M512 64c24.7 0 44.8 20.1 44.8 44.8v43.1l29.3-15.5c21.9-11.6 49-3.2 60.5 18.7s3.2 49-18.7 60.5l-71.2 37.6v85.2c32 8.2 60.6 25.1 83.1 48l73.8-42.6-3-80.4c-0.9-24.7 18.4-45.5 43.1-46.4 24.7-0.9 45.5 18.4 46.4 43.1l1.2 33.1 37.3-21.5c21.4-12.4 48.8-5 61.2 16.4 12.4 21.4 5 48.8-16.4 61.2l-37.3 21.5 28.1 17.6c21 13.2 27.3 40.8 14.1 61.8-13.2 20.9-40.8 27.3-61.8 14.1l-68.2-42.8-73.6 42.5c4.2 15.3 6.5 31.4 6.5 48s-2.3 32.7-6.5 48l73.8 42.6 68.2-42.8c20.9-13.2 48.6-6.8 61.8 14.1 13.2 21 6.8 48.6-14.1 61.8l-28.1 17.6 37.3 21.5c21.4 12.4 28.8 39.8 16.4 61.2-12.4 21.4-39.8 28.8-61.2 16.4l-37.3-21.5-1.2 33.1c-0.9 24.7-21.7 44-46.4 43.1-24.7-0.9-44-21.7-43.1-46.4l3-80.4-73.8-42.6c-22.5 22.9-51 39.8-83.1 48v85.2l71.2 37.6c21.9 11.6 30.2 38.7 18.7 60.5-11.6 21.9-38.7 30.2-60.5 18.7L557 872.2v43.1c0 24.7-20.1 44.8-44.8 44.8-24.7 0-44.8-20.1-44.8-44.8v-43.1l-29.3 15.5c-21.9 11.6-49 3.2-60.5-18.7-11.6-21.9-3.2-49 18.7-60.5l71.2-37.6v-85.2c-32-8.2-60.6-25.1-83.1-48l-73.8 42.6 3 80.4c0.9 24.7-18.4 45.5-43.1 46.4-24.7 0.9-45.5-18.4-46.4-43.1l-1.2-33.1-37.3 21.5c-21.4 12.4-48.8 5-61.2-16.4s-5-48.8 16.4-61.2l37.3-21.5-28.1-17.6c-21-13.2-27.3-40.8-14.1-61.8 13.2-20.9 40.8-27.3 61.8-14.1l68.2 42.8 73.8-42.6c-4.2-15.3-6.5-31.4-6.5-48s2.3-32.7 6.5-48l-73.8-42.6-68.2 42.8c-21 13.2-48.6 6.8-61.8-14.1-13.2-21-6.8-48.6 14.1-61.8l28.1-17.6-37.3-21.5C119 336.8 111.7 309.4 124 288c12.4-21.4 39.8-28.8 61.2-16.4l37.3 21.5 1.2-33.1c0.9-24.7 21.7-44 46.4-43.1 24.7 0.9 44 21.7 43.1 46.4l-3 80.4 73.8 42.6c22.5-22.9 51-39.8 83.1-48v-85.2L396 215.6c-21.9-11.6-30.2-38.7-18.7-60.5 11.6-21.9 38.7-30.2 60.5-18.7l29.3 15.5v-43.1C467.2 84.1 487.3 64 512 64z m0 537.6c49.5 0 89.6-40.1 89.6-89.6s-40.1-89.6-89.6-89.6-89.6 40.1-89.6 89.6 40.1 89.6 89.6 89.6z",
  rainIconPath: "M802.94208 583.04c19.328 38.016 29.056 78.336 29.056 120.96a313.216 313.216 0 0 1-44.032 161.536 324.48 324.48 0 0 1-114.56 114.944c-23.552 13.696-49.024 24.32-76.416 32-27.264 7.68-55.68 11.52-84.992 11.52-29.44 0-57.6-3.84-84.992-11.52a331.136 331.136 0 0 1-76.544-32 337.536 337.536 0 0 1-65.024-49.92 337.536 337.536 0 0 1-49.92-65.024 331.136 331.136 0 0 1-32-76.544A313.216 313.216 0 0 1 191.99808 704c0-42.24 9.344-82.56 28.032-120.448L509.43808 0l293.504 583.04z",
  windIconPath: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\n      <path d="M 4.0003 14.0002 L 12.0003 14.0008 M 12.0003 14.0008 C 13.1049 14.0009 14.0003 14.8964 14.0002 16.001 C 14.0001 17.1055 13.1046 18.0009 12 18.0008 L 10.5 18.0007" stroke-linecap="round" stroke-linejoin="round"/>\n      <path d="M 7 10.0002 L 14.5 10.0008 C 15.6046 10.0009 16.5001 9.1055 16.5002 8.001 C 16.5003 6.8964 15.6049 6.0009 14.5003 6.0008 L 13.0003 6.0007" stroke-linecap="round" stroke-linejoin="round"/>\n    </svg>',
  windRatio: 0,
  rainRatio: 0,
  snowRatio: 0,
  rainCountThreshold: 10,
  snowCountThreshold: 10,
  rainSizeRange: [5, 10],
  snowSizeRange: [5, 13],
  windSize: 30,
  rainSpeed: 1,
  snowSpeed: 0.5,
  windSpeed: 1,
  windAnimateEffect: "fade",
  rainStyle: {},
  snowStyle: {},
  windStyle: {
    opacity: 0.8
  },
  snowRainBottomPadding: 0
};

// node_modules/@visactor/vrender-components/es/switch/register.js
function loadSwitchComponent() {
  registerGroup(), registerRect(), registerText(), registerCircle();
}

// node_modules/@visactor/vrender-components/es/switch/switch.js
loadSwitchComponent();
var Switch = class _Switch extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Switch.defaultAttributes, attributes)), this._handlePointerUp = () => {
      this.attribute.disabled || (this.attribute.checked ? this.setAttribute("checked", false) : this.setAttribute("checked", true), this._dispatchEvent("switch_state_change", {
        eventType: "switch_state_change",
        checked: this.attribute.checked
      }), this.stage.renderNextFrame());
    }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("pointerup", this._handlePointerUp);
  }
  render() {
    this.removeAllChild(true), this.renderBox(), this.renderCircle(), this.renderText(), this.layout();
  }
  renderBox() {
    this._box = new Rect(merge({}, this.attribute.box)), this.attribute.disabled && this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.disableCheckedFill
    }) : this.attribute.disabled && !this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.disableUncheckedFill
    }) : this.attribute.checked ? this._box.setAttributes({
      fill: this.attribute.box.checkedFill
    }) : this._box.setAttributes({
      fill: this.attribute.box.uncheckedFill
    }), this.appendChild(this._box);
  }
  renderCircle() {
    this._circle = new Circle(merge({}, this.attribute.circle)), this.appendChild(this._circle);
  }
  renderText() {
    var _a, _b, _c;
    this._text = new Text(merge({}, null !== (_a = this.attribute.text) && void 0 !== _a ? _a : {})), this.attribute.checked && (null === (_b = this.attribute.text) || void 0 === _b ? void 0 : _b.checkedText) ? this._text.setAttributes({
      text: this.attribute.text.checkedText
    }) : (null === (_c = this.attribute.text) || void 0 === _c ? void 0 : _c.uncheckedText) && this._text.setAttributes({
      text: this.attribute.text.uncheckedText
    }), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const space = this.attribute.spaceBetweenTextAndCircle, radius = this.attribute.circle.radius, boxHeight = this.attribute.box.height, circleHeight = 2 * radius, textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(boxHeight, circleHeight, textHeight), circleY = maxHeight / 2 - circleHeight / 2 + radius, textY = maxHeight / 2 - textHeight / 2, boxWidth = this.attribute.box.width, circleWidth = 2 * radius, textWidth = measureTextSize((null !== (_c = null === (_b = null === (_a = this.attribute.text) || void 0 === _a ? void 0 : _a.checkedText) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) > (null !== (_f = null === (_e = null === (_d = this.attribute.text) || void 0 === _d ? void 0 : _d.uncheckedText) || void 0 === _e ? void 0 : _e.length) && void 0 !== _f ? _f : 0) ? null !== (_h = null === (_g = this.attribute.text) || void 0 === _g ? void 0 : _g.checkedText) && void 0 !== _h ? _h : "" : null !== (_k = null === (_j = this.attribute.text) || void 0 === _j ? void 0 : _j.uncheckedText) && void 0 !== _k ? _k : "", this._text.attribute).width, maxWidth = Math.max(boxWidth, circleWidth + textWidth + 3 * space), circleX = boxHeight / 2 - circleWidth / 2 + radius, textX = circleX + radius + space;
    this._box.setAttributes({
      width: maxWidth,
      height: maxHeight
    }), this._circle.setAttributes({
      y: circleY,
      x: this.attribute.checked ? maxWidth - circleX : circleX
    }), this._text.setAttributes({
      x: this.attribute.checked ? maxWidth - textX - textWidth : textX,
      y: textY
    });
  }
  initAttributes(params2, options) {
    params2 = (null == options ? void 0 : options.skipDefault) ? params2 : merge({}, _Switch.defaultAttributes, params2), super.initAttributes(params2), this.renderGroup(), this.render();
  }
};
Switch.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  circle: {
    radius: 8,
    fill: "#FFF",
    pickable: false
  },
  box: {
    width: 40,
    height: 24,
    cornerRadius: 12,
    uncheckedFill: "rgb(201,205,212)",
    checkedFill: "#165DFF",
    disableUncheckedFill: "rgb(242,243,245)",
    disableCheckedFill: "rgb(148,191,255)",
    pickable: false
  },
  text: {
    textAlign: "left",
    textBaseline: "top",
    pickable: false
  },
  spaceBetweenTextAndCircle: 6
};

// node_modules/@visactor/vrender-components/es/label-item/label-item.js
var StoryLabelItem = class _StoryLabelItem extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _StoryLabelItem.defaultAttributes, attributes));
  }
  render() {
    const { contentOffsetX, contentOffsetY, lineStyle, symbolStartStyle, symbolEndStyle, symbolStartOuterStyle, titleTop: titleTopText, titleBottom: titleBottomText, titleTopStyle, titleBottomStyle, titleSpace, titleTopPanelStyle, titleBottomPanelStyle, theme: theme2 } = this.attribute, group = this.createOrUpdateChild("label-item-container", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group"), symbolStart = group.createOrUpdateChild("label-item-symbol-start", Object.assign({
      x: 0,
      y: 0
    }, symbolStartStyle), "symbol"), symbolEnd = group.createOrUpdateChild("label-item-symbol-end", Object.assign({
      x: contentOffsetX,
      y: contentOffsetY
    }, symbolEndStyle), "symbol"), symbolStartOut = group.createOrUpdateChild("label-item-symbol-start-out", Object.assign({
      x: 0,
      y: 0
    }, symbolStartOuterStyle), "symbol"), spaceW = titleSpace[0], spaceH = titleSpace[1], titleTopGroup = group.createOrUpdateChild("label-item-title-top-group", {
      x: contentOffsetX,
      y: contentOffsetY,
      clip: true
    }, "group"), titleTop = titleTopGroup.createOrUpdateChild("label-item-title-top", Object.assign(Object.assign({
      x: spaceW,
      y: -spaceH,
      text: titleTopText
    }, titleTopStyle), {
      textBaseline: "bottom",
      textAlign: "left",
      zIndex: 10
    }), "text"), titleTopBounds = titleTop.AABBBounds;
    contentOffsetX > 0 && titleTopGroup.setAttributes({
      x: contentOffsetX - titleTopBounds.width() - 2 * spaceW
    }), titleTopGroup.setAttributes({
      width: titleTopBounds.width() + 2 * spaceW,
      height: -titleTopBounds.height() - 2 * spaceH
    });
    const titleTopPanel = titleTopGroup.createOrUpdateChild("label-item-title-top-panel", Object.assign(Object.assign({}, titleTopPanelStyle), {
      x: titleTopPanelStyle.padding.left,
      y: (titleTopGroup.attribute.height > 0 ? 0 : titleTopGroup.attribute.height) + titleTopPanelStyle.padding.top,
      width: titleTopGroup.attribute.width - titleTopPanelStyle.padding.left - titleTopPanelStyle.padding.right,
      height: (titleTopGroup.attribute.height > 0 ? 1 : -1) * titleTopGroup.attribute.height - titleTopPanelStyle.padding.bottom - titleTopPanelStyle.padding.top,
      scaleCenter: [titleTopGroup.attribute.width / 2, titleTopGroup.attribute.height / 2]
    }), "rect");
    this._titleTopPanel = titleTopPanel;
    const titleBottomGroup = group.createOrUpdateChild("label-item-title-bottom-group", {
      x: contentOffsetX,
      y: contentOffsetY,
      clip: true
    }, "group"), titleBottom = titleBottomGroup.createOrUpdateChild("label-item-title-bottom", Object.assign(Object.assign({
      x: spaceW,
      y: spaceH,
      text: titleBottomText
    }, titleBottomStyle), {
      textBaseline: "top",
      textAlign: "left",
      zIndex: 10
    }), "text"), titleBottomBounds = titleBottom.AABBBounds;
    contentOffsetX > 0 && titleBottomGroup.setAttributes({
      x: contentOffsetX - titleBottomBounds.width() - 2 * spaceW
    }), titleBottomGroup.setAttributes({
      width: titleBottomBounds.width() + 2 * spaceW,
      height: titleTopBounds.height() + 2 * spaceH
    });
    const titleBottomPanel = titleBottomGroup.createOrUpdateChild("label-item-title-bottom-panel", Object.assign(Object.assign({}, titleBottomPanelStyle), {
      x: titleBottomPanelStyle.padding.left,
      y: (titleBottomGroup.attribute.height > 0 ? 0 : titleBottomGroup.attribute.height) + titleBottomPanelStyle.padding.top,
      width: titleBottomGroup.attribute.width - titleBottomPanelStyle.padding.left - titleBottomPanelStyle.padding.right,
      height: (titleBottomGroup.attribute.height > 0 ? 1 : -1) * titleBottomGroup.attribute.height - titleBottomPanelStyle.padding.bottom - titleBottomPanelStyle.padding.top,
      scaleCenter: [titleBottomGroup.attribute.width / 2, titleBottomGroup.attribute.height / 2]
    }), "rect");
    this._titleBottomPanel = titleBottomPanel;
    const maxTextWidth = Math.max(titleTop.AABBBounds.width(), titleBottom.AABBBounds.width()) + 2 * spaceW, points = [{
      x: 0,
      y: 0
    }, contentOffsetX > 0 ? {
      x: contentOffsetX - maxTextWidth,
      y: contentOffsetY
    } : {
      x: contentOffsetX + maxTextWidth,
      y: contentOffsetY
    }, {
      x: contentOffsetX,
      y: contentOffsetY
    }];
    if ("simple" === theme2) {
      points.pop();
      const p = points[1];
      symbolEnd.setAttributes(p);
    }
    const line2 = group.createOrUpdateChild("label-item-line", Object.assign(Object.assign({
      x: 0,
      y: 0
    }, lineStyle), {
      points
    }), "line");
    this._symbolEnd = symbolEnd, this._symbolStart = symbolStart, this._symbolStartOuter = symbolStartOut, this._titleTop = titleTop, this._titleBottom = titleBottom, this._line = line2;
  }
  appearAnimate(animateConfig) {
    const { duration = 1e3, easing = "quadOut", symbolStartOuterType = "scale", titleType = "typewriter", titlePanelType = "scale" } = animateConfig, symbolTime = duration / 10;
    let symbolStartOuterFrom, symbolStartOuterTo;
    if (this._symbolStart.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this._symbolStart.animate().to({
      scaleX: 1,
      scaleY: 1
    }, 5 * symbolTime, easing), "scale" === symbolStartOuterType ? (symbolStartOuterFrom = {
      scaleX: 0,
      scaleY: 0
    }, symbolStartOuterTo = {
      scaleX: 1,
      scaleY: 1
    }) : (symbolStartOuterFrom = {
      clipRange: 0
    }, symbolStartOuterTo = {
      clipRange: 1
    }), this._symbolStartOuter.setAttributes(symbolStartOuterFrom), this._symbolStartOuter.animate().to(symbolStartOuterTo, 5 * symbolTime, easing), this._symbolEnd.setAttributes({
      scaleX: 0,
      scaleY: 0
    }), this._symbolEnd.animate().wait(8 * symbolTime).to({
      scaleX: 1,
      scaleY: 1
    }, 2 * symbolTime, easing), this._line.setAttributes({
      clipRange: 0
    }), this._line.animate().to({
      clipRange: 1
    }, 9 * symbolTime, easing), "typewriter" === titleType) {
      const titleTopText = this._titleTop.attribute.text;
      this._titleTop.setAttributes({
        text: ""
      }), this._titleTop.animate().wait(5 * symbolTime).play(new InputText({
        text: ""
      }, {
        text: titleTopText
      }, 4 * symbolTime, "linear"));
      const titleBottomText = this._titleBottom.attribute.text;
      this._titleBottom.setAttributes({
        text: ""
      }), this._titleBottom.animate().wait(5 * symbolTime).play(new InputText({
        text: ""
      }, {
        text: titleBottomText
      }, 4 * symbolTime, "linear"));
    } else this._titleTop.setAttributes({
      dy: this._titleTop.AABBBounds.height() + 10
    }), this._titleTop.animate().wait(5 * symbolTime).to({
      dy: 0
    }, 4 * symbolTime, "linear"), this._titleBottom.setAttributes({
      dy: -(10 + this._titleBottom.AABBBounds.height())
    }), this._titleBottom.animate().wait(5 * symbolTime).to({
      dy: 0
    }, 4 * symbolTime, "linear");
    "scale" === titlePanelType ? [this._titleTopPanel, this._titleBottomPanel].forEach((panel) => {
      const scaleX = panel.attribute.scaleX;
      panel.setAttributes({
        scaleX: 0
      }), panel.animate().to({
        scaleX
      }, duration, "circInOut");
    }) : "stroke" === titlePanelType && [this._titleTopPanel, this._titleBottomPanel].forEach((panel) => {
      const b = panel.AABBBounds, totalLen = 2 * (b.width() + b.height());
      panel.setAttributes({
        lineDash: [0, 10 * totalLen]
      }), panel.animate().to({
        lineDash: [totalLen, 10 * totalLen]
      }, duration, "quadOut");
    });
  }
  disappearAnimate(animateConfig) {
    if ("scale" === animateConfig.mode) {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this.animate().to({
        scaleX: 0,
        scaleY: 0
      }, duration, easing);
    } else {
      const { duration = 1e3, easing = "quadOut" } = animateConfig;
      this._line.animate().to({
        clipRange: 0
      }, duration, easing), this._symbolStart.animate().wait(duration / 2).to({
        scaleX: 0,
        scaleY: 0
      }, duration / 2, easing), this._symbolEnd.animate().to({
        scaleX: 0,
        scaleY: 0
      }, duration, easing), this._titleTop.animate().to({
        dy: this._titleTop.AABBBounds.height() + 10
      }, duration / 2, easing), this._titleBottom.animate().to({
        dy: -(10 + this._titleBottom.AABBBounds.height())
      }, duration / 2, easing), this._symbolStartOuter.animate().wait(duration / 2).to({
        clipRange: 0
      }, duration / 2, easing), this._titleTopPanel.animate().to({
        scaleX: 0
      }, duration, "circInOut"), this._titleBottomPanel.animate().to({
        scaleX: 0
      }, duration, "circInOut");
    }
  }
};
StoryLabelItem.defaultAttributes = {
  contentOffsetX: 100,
  contentOffsetY: -60,
  titleTopStyle: {
    fontSize: 12,
    fill: "white"
  },
  titleBottomStyle: {
    fontSize: 12,
    fill: "white"
  },
  lineStyle: {
    stroke: "white",
    lineWidth: 1
  },
  symbolStartStyle: {
    symbolType: "circle",
    size: 3,
    fill: "white"
  },
  symbolEndStyle: {
    symbolType: "circle",
    size: 3,
    fill: "white"
  },
  symbolStartOuterStyle: {
    symbolType: "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0",
    size: 8,
    stroke: "white"
  },
  titleSpace: [2, 2],
  titleTopPanelStyle: {
    visible: false,
    padding: {
      left: 0,
      right: 0,
      bottom: 2,
      top: 2
    },
    cornerRadius: 3
  },
  titleBottomPanelStyle: {
    visible: false,
    padding: {
      left: 0,
      right: 0,
      bottom: 2,
      top: 2
    },
    cornerRadius: 3
  },
  theme: "default"
};

// node_modules/@visactor/vchart/esm/util/math.js
var isClose = isNumberClose;
function normalizeStartEndAngle(start, end) {
  let startAngle = 0, endAngle = 2 * Math.PI;
  const isStartValid = isValid_default(start), isEndValid = isValid_default(end);
  for (isStartValid || isEndValid ? isEndValid ? isStartValid ? (startAngle = start, endAngle = end) : (startAngle = end - 2 * Math.PI, endAngle = end) : (startAngle = start, endAngle = start + 2 * Math.PI) : (startAngle = 0, endAngle = 2 * Math.PI); endAngle <= startAngle; ) endAngle += 2 * Math.PI;
  for (; startAngle > 2 * Math.PI; ) startAngle -= 2 * Math.PI, endAngle -= 2 * Math.PI;
  for (; endAngle < 0; ) startAngle += 2 * Math.PI, endAngle += 2 * Math.PI;
  return {
    startAngle,
    endAngle
  };
}
function outOfBounds(bounds, x, y) {
  return bounds.x1 > x || bounds.x2 < x || bounds.y1 > y || bounds.y2 < y;
}
function min2(data, field5) {
  const dataArray = [];
  return data.forEach((d) => {
    const value = +d[field5];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : minInArray(dataArray);
}
function max2(data, field5) {
  const dataArray = [];
  return data.forEach((d) => {
    const value = +d[field5];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : maxInArray(dataArray);
}
function sum(data, field5) {
  return data.reduce((pre, _cur) => {
    const cur = field5 ? +_cur[field5] : +_cur;
    return isValidNumber_default(cur) && (pre += cur), pre;
  }, 0);
}
function average(data, field5) {
  let sum3 = 0, count = 0;
  data.forEach((x) => {
    const v = field5 ? +x[field5] : +x;
    isValidNumber_default(v) && (sum3 += v, count++);
  });
  return sum3 / count;
}
function variance(data, field5) {
  const averageNumber = average(data, field5);
  if (data.length <= 1) return 0;
  const total = data.reduce((sum3, cur) => sum3 + (field5 ? +cur[field5] : +cur - averageNumber) ** 2, 0);
  return total / (data.length - 1);
}
function standardDeviation(data, field5) {
  return Math.sqrt(variance(data, field5));
}
function median2(data, field5) {
  return median(data.map((datum) => datum[field5]));
}
function regression(data, fieldX, fieldY) {
  const { predict } = regressionLinear(data, (datum) => datum[fieldX], (datum) => datum[fieldY]), x1 = min2(data, fieldX), x2 = max2(data, fieldX), predict1 = predict(x1), predict2 = predict(x2);
  return [{
    [fieldX]: x1,
    [fieldY]: predict1
  }, {
    [fieldX]: x2,
    [fieldY]: predict2
  }];
}
function radiusLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "right" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "left" : "center", baseline = angle2 >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "bottom" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "top" : "middle", {
    align,
    baseline
  };
}
function vectorAngle(v1, v2) {
  const v1Length = distance(v1), v2Length = distance(v2), rho = Math.asin((v1.x * v2.y - v2.x * v1.y) / v1Length / v2Length), theta = Math.acos((v1.x * v2.x + v1.y * v2.y) / v1Length / v2Length);
  return rho < 0 ? -theta : theta;
}
function distance(p1, p2 = {
  x: 0,
  y: 0
}) {
  return PointService.distancePP(p1, p2);
}
function getPercentValue(valueList, precision = 2) {
  const sum3 = valueList.reduce((a3, c3) => a3 + (isNaN(c3) ? 0 : c3), 0);
  if (0 === sum3) return 0;
  const digits = Math.pow(10, precision), votesPerQuota = valueList.map((val) => (isNaN(val) ? 0 : val) / sum3 * digits * 100), targetSeats = 100 * digits, seats = votesPerQuota.map((votes) => Math.floor(votes));
  let currentSum = seats.reduce((a3, c3) => a3 + c3, 0);
  const remainder = votesPerQuota.map((votes, idx2) => votes - seats[idx2]);
  for (; currentSum < targetSeats; ) {
    let max3 = Number.NEGATIVE_INFINITY, maxId2 = null;
    for (let i = 0; i < remainder.length; i++) remainder[i] > max3 && (max3 = remainder[i], maxId2 = i);
    ++seats[maxId2], remainder[maxId2] = 0, ++currentSum;
  }
  return seats.map((entry) => entry / digits);
}
function isValidPoint(p) {
  return isValidNumber_default(p.x) && isValidNumber_default(p.y);
}

// node_modules/@visactor/vchart/esm/util/model.js
function eachSeries(regions, callback, filter2) {
  let flag = false;
  if (callback && isFunction_default(callback)) {
    for (const r of regions) for (const s2 of r.getSeries(filter2)) if (flag = !!callback.call(null, s2), flag) return flag;
  }
  return flag;
}
function getSeries(regions, filter2) {
  const result2 = [];
  for (const r of regions) for (const s2 of r.getSeries(filter2)) result2.push(s2);
  return result2;
}
var getFirstSeries = (regions, coordinateType) => {
  for (let i = 0; i < regions.length; i++) {
    const series2 = regions[i].getSeries();
    for (let j = 0; j < series2.length; j++) {
      const s2 = series2[j];
      if (coordinateType && s2 && s2.coordinate === coordinateType) return s2;
      if (!coordinateType && s2) return s2;
    }
  }
  return null;
};

// node_modules/@visactor/vchart/esm/util/object.js
function field2(f) {
  return function(datum) {
    let value;
    return value = isArray_default(f) ? f.reduce((cur, g) => null == cur ? void 0 : cur[g], datum) : null == datum ? void 0 : datum[f], value;
  };
}

// node_modules/@visactor/vchart/esm/series/interface/theme.js
var SeriesTypeForThemeEnum;
!function(SeriesTypeForThemeEnum2) {
  SeriesTypeForThemeEnum2.area_horizontal = "area_horizontal", SeriesTypeForThemeEnum2.area_vertical = "area_vertical", SeriesTypeForThemeEnum2.area_stack = "area_stack", SeriesTypeForThemeEnum2.line_horizontal = "line_horizontal", SeriesTypeForThemeEnum2.line_vertical = "line_vertical", SeriesTypeForThemeEnum2.line_stack = "line_stack", SeriesTypeForThemeEnum2.bar_horizontal = "bar_horizontal", SeriesTypeForThemeEnum2.bar_vertical = "bar_vertical", SeriesTypeForThemeEnum2.bar_stack = "bar_stack", SeriesTypeForThemeEnum2.bar3d_horizontal = "bar3d_horizontal", SeriesTypeForThemeEnum2.bar3d_vertical = "bar3d_vertical", SeriesTypeForThemeEnum2.bar3d_stack = "bar3d_stack", SeriesTypeForThemeEnum2.rangeColumn_horizontal = "rangeColumn_horizontal", SeriesTypeForThemeEnum2.rangeColumn_vertical = "rangeColumn_vertical", SeriesTypeForThemeEnum2.rangeColumn3d_horizontal = "rangeColumn3d_horizontal", SeriesTypeForThemeEnum2.rangeColumn3d_vertical = "rangeColumn3d_vertical", SeriesTypeForThemeEnum2.rangeArea_horizontal = "rangeArea_horizontal", SeriesTypeForThemeEnum2.rangeArea_vertical = "rangeArea_vertical", SeriesTypeForThemeEnum2.linearProgress_horizontal = "linearProgress_horizontal", SeriesTypeForThemeEnum2.linearProgress_vertical = "linearProgress_vertical", SeriesTypeForThemeEnum2.linearProgress_stack = "linearProgress_stack", SeriesTypeForThemeEnum2.boxPlot_horizontal = "boxPlot_horizontal", SeriesTypeForThemeEnum2.boxPlot_vertical = "boxPlot_vertical", SeriesTypeForThemeEnum2.sankey_horizontal = "sankey_horizontal", SeriesTypeForThemeEnum2.sankey_vertical = "sankey_vertical", SeriesTypeForThemeEnum2.waterfall_horizontal = "waterfall_horizontal", SeriesTypeForThemeEnum2.waterfall_vertical = "waterfall_vertical", SeriesTypeForThemeEnum2.circularProgress_stack = "circularProgress_stack", SeriesTypeForThemeEnum2.radar_stack = "radar_stack", SeriesTypeForThemeEnum2.rose_stack = "rose_stack";
}(SeriesTypeForThemeEnum || (SeriesTypeForThemeEnum = {}));

// node_modules/@visactor/vchart/esm/series/interface/type.js
var SeriesTypeEnum;
!function(SeriesTypeEnum2) {
  SeriesTypeEnum2.area = "area", SeriesTypeEnum2.line = "line", SeriesTypeEnum2.bar = "bar", SeriesTypeEnum2.bar3d = "bar3d", SeriesTypeEnum2.rangeColumn = "rangeColumn", SeriesTypeEnum2.rangeColumn3d = "rangeColumn3d", SeriesTypeEnum2.rangeArea = "rangeArea", SeriesTypeEnum2.dot = "dot", SeriesTypeEnum2.geo = "geo", SeriesTypeEnum2.link = "link", SeriesTypeEnum2.map = "map", SeriesTypeEnum2.pie = "pie", SeriesTypeEnum2.pie3d = "pie3d", SeriesTypeEnum2.radar = "radar", SeriesTypeEnum2.rose = "rose", SeriesTypeEnum2.scatter = "scatter", SeriesTypeEnum2.circularProgress = "circularProgress", SeriesTypeEnum2.wordCloud = "wordCloud", SeriesTypeEnum2.wordCloud3d = "wordCloud3d", SeriesTypeEnum2.funnel = "funnel", SeriesTypeEnum2.funnel3d = "funnel3d", SeriesTypeEnum2.linearProgress = "linearProgress", SeriesTypeEnum2.boxPlot = "boxPlot", SeriesTypeEnum2.sankey = "sankey", SeriesTypeEnum2.gaugePointer = "gaugePointer", SeriesTypeEnum2.gauge = "gauge", SeriesTypeEnum2.treemap = "treemap", SeriesTypeEnum2.sunburst = "sunburst", SeriesTypeEnum2.circlePacking = "circlePacking", SeriesTypeEnum2.waterfall = "waterfall", SeriesTypeEnum2.heatmap = "heatmap", SeriesTypeEnum2.correlation = "correlation", SeriesTypeEnum2.liquid = "liquid", SeriesTypeEnum2.venn = "venn", SeriesTypeEnum2.mosaic = "mosaic", SeriesTypeEnum2.pictogram = "pictogram";
}(SeriesTypeEnum || (SeriesTypeEnum = {}));
var SeriesMarkNameEnum;
!function(SeriesMarkNameEnum2) {
  SeriesMarkNameEnum2.label = "label", SeriesMarkNameEnum2.point = "point", SeriesMarkNameEnum2.line = "line", SeriesMarkNameEnum2.area = "area", SeriesMarkNameEnum2.bar = "bar", SeriesMarkNameEnum2.bar3d = "bar3d", SeriesMarkNameEnum2.boxPlot = "boxPlot", SeriesMarkNameEnum2.outlier = "outlier", SeriesMarkNameEnum2.circlePacking = "circlePacking", SeriesMarkNameEnum2.group = "group", SeriesMarkNameEnum2.gridBackground = "gridBackground", SeriesMarkNameEnum2.grid = "grid", SeriesMarkNameEnum2.dot = "dot", SeriesMarkNameEnum2.title = "title", SeriesMarkNameEnum2.subTitle = "subTitle", SeriesMarkNameEnum2.symbol = "symbol", SeriesMarkNameEnum2.funnel = "funnel", SeriesMarkNameEnum2.funnel3d = "funnel3d", SeriesMarkNameEnum2.transform = "transform", SeriesMarkNameEnum2.transform3d = "transform3d", SeriesMarkNameEnum2.transformLabel = "transformLabel", SeriesMarkNameEnum2.outerLabel = "outerLabel", SeriesMarkNameEnum2.outerLabelLine = "outerLabelLine", SeriesMarkNameEnum2.pin = "pin", SeriesMarkNameEnum2.pinBackground = "pinBackground", SeriesMarkNameEnum2.pointer = "pointer", SeriesMarkNameEnum2.segment = "segment", SeriesMarkNameEnum2.track = "track", SeriesMarkNameEnum2.cell = "cell", SeriesMarkNameEnum2.cellBackground = "cellBackground", SeriesMarkNameEnum2.link = "link", SeriesMarkNameEnum2.arrow = "arrow", SeriesMarkNameEnum2.pie = "pie", SeriesMarkNameEnum2.pie3d = "pie3d", SeriesMarkNameEnum2.labelLine = "labelLine", SeriesMarkNameEnum2.progress = "progress", SeriesMarkNameEnum2.minLabel = "minLabel", SeriesMarkNameEnum2.maxLabel = "maxLabel", SeriesMarkNameEnum2.rose = "rose", SeriesMarkNameEnum2.node = "node", SeriesMarkNameEnum2.sunburst = "sunburst", SeriesMarkNameEnum2.nonLeaf = "nonLeaf", SeriesMarkNameEnum2.leaf = "leaf", SeriesMarkNameEnum2.nonLeafLabel = "nonLeafLabel", SeriesMarkNameEnum2.leaderLine = "leaderLine", SeriesMarkNameEnum2.stackLabel = "stackLabel", SeriesMarkNameEnum2.word = "word", SeriesMarkNameEnum2.fillingWord = "fillingWord", SeriesMarkNameEnum2.wordMask = "wordMask", SeriesMarkNameEnum2.nodePoint = "nodePoint", SeriesMarkNameEnum2.ripplePoint = "ripplePoint", SeriesMarkNameEnum2.centerPoint = "centerPoint", SeriesMarkNameEnum2.centerLabel = "centerLabel", SeriesMarkNameEnum2.barBackground = "barBackground", SeriesMarkNameEnum2.lineLabel = "lineLabel", SeriesMarkNameEnum2.areaLabel = "areaLabel", SeriesMarkNameEnum2.liquidGroup = "liquidGroup", SeriesMarkNameEnum2.liquid = "liquid", SeriesMarkNameEnum2.liquidBackground = "liquidBackground", SeriesMarkNameEnum2.liquidOutline = "liquidOutline", SeriesMarkNameEnum2.circle = "circle", SeriesMarkNameEnum2.overlap = "overlap", SeriesMarkNameEnum2.overlapLabel = "overlapLabel", SeriesMarkNameEnum2.pictogram = "pictogram";
}(SeriesMarkNameEnum || (SeriesMarkNameEnum = {}));

// node_modules/@visactor/vchart/esm/series/util/spec.js
function getDirectionFromSeriesSpec(spec) {
  var _a, _b;
  const { type } = spec;
  return type === SeriesTypeEnum.sankey ? null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal" : null !== (_b = spec.direction) && void 0 !== _b ? _b : "vertical";
}

// node_modules/@visactor/vchart/esm/theme/color-scheme/legacy.js
var newTokenToLegacyToken = {
  primaryFontColor: "titleFontColor",
  tertiaryFontColor: "labelFontColor",
  axisLabelFontColor: "axisFontColor",
  axisMarkerFontColor: "labelReverseFontColor",
  dataZoomHandleStrokeColor: "dataZoomHandlerStrokeColor",
  sliderHandleColor: "dataZoomHandlerFillColor",
  sliderRailColor: "dataZoomBackgroundColor",
  sliderTrackColor: "dataZoomSelectedColor",
  playerControllerColor: "dataZoomSelectedColor",
  popupBackgroundColor: "tooltipBackgroundColor",
  hoverBackgroundColor: "axisGridColor"
};
var legacyTokenToNewToken = {
  titleFontColor: "primaryFontColor",
  labelFontColor: "tertiaryFontColor",
  axisFontColor: "axisLabelFontColor",
  labelReverseFontColor: "axisMarkerFontColor",
  dataZoomHandlerStrokeColor: "dataZoomHandleStrokeColor",
  dataZoomHandlerFillColor: "sliderHandleColor",
  dataZoomBackgroundColor: "sliderRailColor",
  dataZoomSelectedColor: "sliderTrackColor",
  tooltipBackgroundColor: "popupBackgroundColor"
};
function getUpgradedTokenValue(palette, key) {
  const legacyKey = newTokenToLegacyToken[key];
  if (legacyKey && palette[legacyKey]) return palette[legacyKey];
  if (palette[key]) return palette[key];
  const newKey = legacyTokenToNewToken[key];
  return newKey ? palette[newKey] : void 0;
}

// node_modules/@visactor/vchart/esm/theme/color-scheme/util.js
function getDataScheme(colorScheme3, seriesSpec) {
  var _a;
  if (!colorScheme3) return [];
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme || isArray_default(scheme)) return null !== (_a = scheme) && void 0 !== _a ? _a : [];
  if (isObject_default(scheme)) {
    const { dataScheme: dataScheme2 } = scheme;
    return dataScheme2 ? isProgressiveDataColorScheme(dataScheme2) ? dataScheme2.map((item) => Object.assign(Object.assign({}, item), {
      scheme: item.scheme.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default)
    })) : dataScheme2.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default) : [];
  }
  return [];
}
function computeActualDataScheme(dataScheme2, colorDomain) {
  var _a, _b;
  return isProgressiveDataColorScheme(dataScheme2) ? null !== (_b = null === (_a = dataScheme2.find((item) => isValid_default(item.isAvailable) ? isFunction_default(item.isAvailable) ? item.isAvailable(colorDomain) : !!item.isAvailable : !isValid_default(item.maxDomainLength) || (null == colorDomain ? void 0 : colorDomain.length) <= item.maxDomainLength)) || void 0 === _a ? void 0 : _a.scheme) && void 0 !== _b ? _b : dataScheme2[dataScheme2.length - 1].scheme : dataScheme2;
}
function queryColorFromColorScheme(colorScheme3, colorKey, seriesSpec) {
  var _a;
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme) return;
  let color;
  const { palette } = scheme;
  if (isObject_default(palette) && (color = null !== (_a = getUpgradedTokenValue(palette, colorKey.key)) && void 0 !== _a ? _a : colorKey.default), !color) return;
  if (isNil_default(colorKey.a) && isNil_default(colorKey.l) || !isString_default(color)) return color;
  let c3 = new Color(color);
  if (isValid_default(colorKey.l)) {
    const { r, g, b } = c3.color, { h, s: s2 } = rgbToHsl(r, g, b), rgb = hslToRgb(h, s2, colorKey.l), newColor = new Color(`rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`);
    newColor.setOpacity(c3.color.opacity), c3 = newColor;
  }
  return isValid_default(colorKey.a) && c3.setOpacity(colorKey.a), c3.toRGBA();
}
var getActualColor = (value, colorScheme3, seriesSpec) => {
  if (colorScheme3 && isColorKey(value)) {
    const color = queryColorFromColorScheme(colorScheme3, value, seriesSpec);
    if (color) return color;
  }
  return value;
};
function isColorKey(obj) {
  return obj && "palette" === obj.type && !!obj.key;
}
function isProgressiveDataColorScheme(obj) {
  return !(!isArray_default(obj) || 0 === obj.length) && obj.every((item) => isValid_default(item.scheme));
}
function transformColorSchemeToStandardStruct(colorScheme3) {
  return isArray_default(colorScheme3) ? {
    dataScheme: colorScheme3
  } : colorScheme3;
}
function getColorSchemeBySeries(colorScheme3, seriesSpec) {
  var _a, _b;
  const { type: seriesType } = null != seriesSpec ? seriesSpec : {};
  let scheme;
  if (!seriesSpec || isNil_default(seriesType)) scheme = null == colorScheme3 ? void 0 : colorScheme3.default;
  else {
    const direction = getDirectionFromSeriesSpec(seriesSpec);
    scheme = null !== (_b = null !== (_a = null == colorScheme3 ? void 0 : colorScheme3[`${seriesType}_${direction}`]) && void 0 !== _a ? _a : null == colorScheme3 ? void 0 : colorScheme3[seriesType]) && void 0 !== _b ? _b : null == colorScheme3 ? void 0 : colorScheme3.default;
  }
  return scheme;
}

// node_modules/@visactor/vchart/esm/scale/color-ordinal-scale.js
var ColorOrdinalScale = class extends OrdinalScale {
  range(value) {
    return value ? (this._range = value, this._resetRange(), this) : super.range();
  }
  domain(value) {
    return value ? (super.domain(value), this._resetRange(), this) : super.domain();
  }
  _resetRange() {
    if (!isProgressiveDataColorScheme(this._range)) return void super.range(this._range);
    const range2 = computeActualDataScheme(this._range, this._domain);
    super.range(range2);
  }
};

// node_modules/@visactor/vchart/esm/util/scale.js
var defaultScaleMap = {
  linear: LinearScale,
  band: BandScale,
  point: PointScale,
  ordinal: OrdinalScale,
  threshold: ThresholdScale,
  colorOrdinal: ColorOrdinalScale
};
function createScale(type) {
  const scaleConstructor = defaultScaleMap[type];
  return scaleConstructor ? new scaleConstructor() : null;
}
function createScaleWithSpec(spec, context) {
  if ("scale" in spec && spec.scale) return isString_default(spec.scale) && (null == context ? void 0 : context.globalScale) ? context.globalScale.registerMarkAttributeScale(spec, context.seriesId) : spec.scale;
  const scale4 = createScale(spec.type);
  return scale4 && initScaleWithSpec(scale4, spec), scale4;
}
function initScaleWithSpec(scale4, spec) {
  scale4 && spec && (spec.domain && scale4.domain(spec.domain), spec.range && scale4.range(spec.range), spec.specified && scale4.specified && scale4.specified(spec.specified), spec.clamp && scale4.clamp && scale4.clamp(spec.clamp));
}
function valueInScaleRange(v, s2, useWholeRange) {
  if (!s2) return v;
  const scaleRange = s2.range(), range2 = useWholeRange && s2._calculateWholeRange ? s2._calculateWholeRange(scaleRange) : s2.range(), min3 = Math.min(range2[0], range2[range2.length - 1]), max3 = Math.max(range2[0], range2[range2.length - 1]);
  return Math.min(Math.max(min3, v), max3);
}
function isValueInScaleDomain(v, s2, useWholeRange) {
  if (!s2) return true;
  const scaleRange = s2.range(), domain = (useWholeRange && s2._calculateWholeRange ? s2._calculateWholeRange(scaleRange) : s2.range()).map((v2) => s2.invert(v2)), min3 = Math.min(domain[0], domain[domain.length - 1]), max3 = Math.max(domain[0], domain[domain.length - 1]);
  return Array.isArray(v) ? v.every((v2) => v2 >= min3 && v2 <= max3) : v >= min3 && v <= max3;
}
function isSpecValueWithScale(specValue) {
  return isValid_default(null == specValue ? void 0 : specValue.field) && isValid_default(null == specValue ? void 0 : specValue.scale);
}

// node_modules/@visactor/vchart/esm/util/space.js
function isValidOrient(orient) {
  switch (orient) {
    case "left":
    case "right":
    case "top":
    case "bottom":
      return true;
    default:
      return false;
  }
}
function isPercent(v) {
  return !!isString_default(v) && (!!v.endsWith("%") && couldBeValidNumber(v.substring(0, v.length - 1)));
}
function isPercentOffset(v) {
  return !!isObject_default(v) && ("percent" in v || "offset" in v);
}
function calcLayoutNumber(v, size, callOp, defaultValue = 0) {
  var _a, _b;
  return isNumber_default(v) ? v : isPercent(v) ? Number(v.substring(0, v.length - 1)) * size / 100 : isFunction_default(v) ? v(callOp) : isObject_default(v) ? size * (null !== (_a = v.percent) && void 0 !== _a ? _a : 0) + (null !== (_b = v.offset) && void 0 !== _b ? _b : 0) : defaultValue;
}
function calcPadding(paddingSpec, rect, callOp) {
  var _a, _b, _c, _d;
  const result2 = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  if (Object.values(paddingSpec).every((value) => isNumber_default(value))) return result2.top = null !== (_a = paddingSpec.top) && void 0 !== _a ? _a : 0, result2.right = null !== (_b = paddingSpec.right) && void 0 !== _b ? _b : 0, result2.bottom = null !== (_c = paddingSpec.bottom) && void 0 !== _c ? _c : 0, result2.left = null !== (_d = paddingSpec.left) && void 0 !== _d ? _d : 0, result2;
  return [{
    orients: ["left", "right"],
    size: rect.width
  }, {
    orients: ["top", "bottom"],
    size: rect.height
  }].forEach((p) => {
    p.orients.forEach((o) => {
      result2[o] = calcLayoutNumber(paddingSpec[o], p.size, callOp);
    });
  }), result2;
}
function boundsInRect(bounds, rect) {
  return bounds ? {
    width: Math.ceil(Math.min(bounds.x2 - bounds.x1, rect.width)),
    height: Math.ceil(Math.min(bounds.y2 - bounds.y1, rect.height))
  } : {
    width: 0,
    height: 0
  };
}
function normalizeLayoutPaddingSpec(spec) {
  let result2 = {};
  return isArray_default(spec) ? (isNil_default(spec[0]) || (result2.top = result2.left = result2.bottom = result2.right = spec[0]), isNil_default(spec[1]) || (result2.left = result2.right = spec[1]), isNil_default(spec[2]) || (result2.bottom = spec[2]), isNil_default(spec[3]) || (result2.left = spec[3]), result2) : isNumber_default(spec) || isPercent(spec) || isFunction_default(spec) || isPercentOffset(spec) ? (result2.top = result2.left = result2.bottom = result2.right = spec, result2) : isObject_default(spec) ? (result2 = Object.assign({}, spec), result2) : result2;
}
function convertPoint(point6, relativePoint, convert) {
  return convert ? {
    x: point6.x + relativePoint.x,
    y: point6.y + relativePoint.y
  } : point6;
}
var getActualNumValue = (originValue, total) => {
  const originNumValue = Number(originValue), originStrValue = originValue.toString();
  return isNaN(originNumValue) && "%" === originStrValue[originStrValue.length - 1] ? total * (Number(originStrValue.slice(0, originStrValue.length - 1)) / 100) : originNumValue;
};

// node_modules/@visactor/vchart/esm/theme/color-scheme/builtin/default.js
var dataScheme = [{
  maxDomainLength: 10,
  scheme: ["#1664FF", "#1AC6FF", "#FF8A00", "#3CC780", "#7442D4", "#FFC400", "#304D77", "#B48DEB", "#009488", "#FF7DDA"]
}, {
  scheme: ["#1664FF", "#B2CFFF", "#1AC6FF", "#94EFFF", "#FF8A00", "#FFCE7A", "#3CC780", "#B9EDCD", "#7442D4", "#DDC5FA", "#FFC400", "#FAE878", "#304D77", "#8B959E", "#B48DEB", "#EFE3FF", "#009488", "#59BAA8", "#FF7DDA", "#FFCFEE"]
}];

// node_modules/@visactor/vchart/esm/theme/builtin/light/color-scheme.js
var colorScheme = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#ffffff",
      borderColor: "#e3e5e8",
      shadowColor: "rgba(33,37,44,0.1)",
      hoverBackgroundColor: "#f1f2f5",
      sliderRailColor: "#f1f3f4",
      sliderHandleColor: "#ffffff",
      sliderTrackColor: "#0040ff",
      popupBackgroundColor: "#ffffff",
      primaryFontColor: "#21252c",
      secondaryFontColor: "#606773",
      tertiaryFontColor: "#89909d",
      axisLabelFontColor: "#89909d",
      disableFontColor: "#bcc1cb",
      axisMarkerFontColor: "#ffffff",
      axisGridColor: "#f1f2f5",
      axisDomainColor: "#d9dde4",
      dataZoomHandleStrokeColor: "#aeb5be",
      dataZoomChartColor: "#c9ced8",
      playerControllerColor: "#0040ff",
      scrollBarSliderColor: "rgba(0,0,0,0.3)",
      axisMarkerBackgroundColor: "#21252c",
      markLabelBackgroundColor: "#f1f2f5",
      markLineStrokeColor: "#606773",
      dangerColor: "#e33232",
      warningColor: "#ffc528",
      successColor: "#07a35a",
      infoColor: "#3073f2",
      discreteLegendPagerTextColor: "rgb(51, 51, 51)",
      discreteLegendPagerHandlerColor: "rgb(47, 69, 84)",
      discreteLegendPagerHandlerDisableColor: "rgb(170, 170, 170)",
      emptyCircleColor: "#e3e5e8",
      linearProgressTrackColor: "#E7EBED"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/area.js
var area = {
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  },
  seriesMark: "area"
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/bar.js
var bar = {
  label: {
    visible: false,
    position: "outside",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/bar3d.js
var bar3d = {
  bar3d: {
    style: {
      length: 3
    }
  },
  label: {
    visible: false,
    style: {
      offset: 12,
      position: "outside"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/circular-progress.js
var circularProgress = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fillOpacity: 0.2
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/dot.js
var dot = {
  dot: {
    style: {
      size: 10,
      fillOpacity: 1
    }
  },
  symbol: {
    style: {
      size: 10
    }
  },
  title: {
    style: {
      textAlign: "left",
      textBaseline: "middle",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  },
  subTitle: {
    style: {
      textAlign: "left",
      textBaseline: "top",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/funnel.js
var getFunnelTheme = (is3d) => {
  const res = {
    label: {
      style: {
        fill: "white",
        textBaseline: "middle",
        lineWidth: 2
      }
    },
    outerLabel: {
      style: {
        fontSize: {
          type: "token",
          key: "l4FontSize"
        },
        fill: {
          type: "palette",
          key: "secondaryFontColor"
        }
      },
      line: {
        style: {
          stroke: {
            type: "palette",
            key: "axisDomainColor"
          }
        }
      }
    },
    transformLabel: {
      style: {
        fontSize: {
          type: "token",
          key: "l4FontSize"
        },
        fill: {
          type: "palette",
          key: "secondaryFontColor"
        },
        textBaseline: "middle"
      }
    }
  };
  return res[is3d ? "transform3d" : "transform"] = {
    style: {
      fill: {
        type: "palette",
        key: "axisGridColor"
      }
    }
  }, res;
};
var funnel = getFunnelTheme();
var funnel3d = getFunnelTheme(true);

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/gauge.js
var gauge = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  padAngle: 1.146,
  segment: {
    style: {
      fillOpacity: 1
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/gauge-pointer.js
var pointerPath = "M-0.020059 -0.978425 C-0.018029 -0.9888053 -0.013378 -1 0 -1 C0.01342 -1 0.01812 -0.989146 0.0201 -0.978425 C0.02161 -0.9702819 0.0692 -0.459505 0.09486 -0.184807 C0.10298 -0.097849 0.1089 -0.034548 0.11047 -0.018339 C0.11698 0.04908 0.07373 0.11111 0.00002 0.11111 C-0.07369 0.11111 -0.117184 0.04991 -0.110423 -0.018339 C-0.103662 -0.086591 -0.022089 -0.9680447 -0.020059 -0.978425Z";
var circlePath = "M1 0 C1 0.55228 0.55228 1 0 1 C-0.552285 1 -1 0.55228 -1 0 C-1 -0.552285 -0.552285 -1 0 -1 C0.55228 -1 1 -0.552285 1 0Z";
var gaugePointer = {
  pointer: {
    type: "path",
    width: 0.4,
    height: 0.4,
    style: {
      path: pointerPath
    }
  },
  pin: {
    width: 0.025,
    height: 0.025,
    style: {
      path: circlePath,
      fill: "#888"
    }
  },
  pinBackground: {
    width: 0.06,
    height: 0.06,
    style: {
      path: circlePath,
      fill: "#ddd"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/line.js
var line = {
  label: {
    visible: false,
    position: "top",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/linear-progress.js
var linearProgress = {
  bandWidth: 30,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fill: {
        type: "palette",
        key: "linearProgressTrackColor"
      },
      fillOpacity: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/link.js
var link = {
  arrow: {
    style: {
      size: 10
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/map.js
var map2 = {
  defaultFillColor: "#f3f3f3",
  area: {
    style: {
      lineWidth: 0.5,
      strokeOpacity: 1,
      stroke: "black",
      fillOpacity: 1
    }
  },
  label: {
    interactive: false,
    style: {
      fontSize: {
        type: "token",
        key: "l6FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l6LineHeight"
      },
      textBaseline: "middle",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      },
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/pie.js
var pie = {
  outerRadius: 0.6,
  pie: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    interactive: true,
    position: "outside",
    style: {
      fontWeight: "normal",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1
    }
  },
  innerLabel: {
    style: {
      lineWidth: 2
    }
  },
  emptyCircle: {
    style: {
      fill: {
        type: "palette",
        key: "emptyCircleColor"
      },
      fillOpacity: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/pie3d.js
var pie3d = {
  outerRadius: 0.6,
  pie3d: {
    style: {
      height: 10,
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    interactive: true,
    position: "outside"
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/radar.js
var radar = {
  label: {
    visible: false,
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/scatter.js
var scatter = {
  point: {
    style: {
      size: 8,
      symbolType: "circle",
      lineWidth: 0,
      fillOpacity: 0.8
    }
  },
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/waterfall.js
var waterfall = {
  seriesFieldName: {
    total: "total",
    increase: "increase",
    decrease: "decrease"
  },
  leaderLine: {
    style: {
      stroke: "black",
      lineWidth: 1,
      lineDash: [4, 4]
    }
  },
  stackLabel: {
    visible: true,
    offset: 12,
    position: "withChange",
    style: {
      fill: "black",
      fontSize: {
        type: "token",
        key: "l4FontSize"
      }
    }
  },
  label: {
    visible: false,
    offset: 12,
    position: "inside",
    style: {
      lineWidth: 2
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/word-cloud.js
var wordCloud = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};
var wordCloud3d = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/treemap.js
var treemap = {
  gapWidth: 1,
  nodePadding: [5],
  nonLeaf: {
    visible: false,
    style: {
      fillOpacity: 0.5
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  },
  nonLeafLabel: {
    padding: 24,
    style: {
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      textBaseline: "middle",
      textAlign: "center"
    }
  }
};

// node_modules/@visactor/vchart/esm/constant/base.js
var PREFIX = "__VCHART";
var DEFAULT_CHART_WIDTH = 500;
var DEFAULT_CHART_HEIGHT = 500;

// node_modules/@visactor/vchart/esm/constant/polar.js
var ARC_TRANSFORM_VALUE = `${PREFIX}_ARC_TRANSFORM_VALUE`;
var ARC_RATIO = `${PREFIX}_ARC_RATIO`;
var ARC_START_ANGLE = `${PREFIX}_ARC_START_ANGLE`;
var ARC_END_ANGLE = `${PREFIX}_ARC_END_ANGLE`;
var ARC_K = `${PREFIX}_ARC_K`;
var ARC_MIDDLE_ANGLE = `${PREFIX}_ARC_MIDDLE_ANGLE`;
var ARC_QUADRANT = `${PREFIX}_ARC_QUADRANT`;
var ARC_RADIAN = `${PREFIX}_ARC_RADIAN`;
var POLAR_START_RADIAN = -Math.PI / 2;
var POLAR_END_RADIAN = 3 * Math.PI / 2;
var POLAR_START_ANGLE2 = -90;
var POLAR_END_ANGLE2 = 270;
var POLAR_DEFAULT_RADIUS = 0.6;

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/sunburst.js
var sunburst = {
  innerRadius: 0,
  outerRadius: 1,
  startAngle: POLAR_START_ANGLE2,
  endAngle: POLAR_END_ANGLE2,
  gap: 0,
  labelLayout: {
    align: "center",
    offset: 0,
    rotate: "radial"
  },
  sunburst: {
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1,
      cursor: "pointer"
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/rangeColumn.js
var rangeColumn = {
  label: {
    visible: false,
    offset: 5,
    position: "inside",
    style: {
      lineWidth: 2,
      fill: {
        type: "palette",
        key: "axisMarkerFontColor"
      }
    },
    minLabel: {
      position: "end"
    },
    maxLabel: {
      position: "start"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/circle-packing.js
var circlePacking = {
  layoutPadding: 5,
  circlePacking: {
    visible: true,
    style: {
      cursor: "pointer",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/heatmap.js
var heatmap = {
  cell: {
    style: {
      shape: "square",
      fillOpacity: 1
    }
  },
  cellBackground: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/sankey.js
var sankey = {
  link: {
    style: {
      fillOpacity: 0.15,
      round: true
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/rose.js
var rose = {
  rose: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      textAlign: "center",
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/box-plot.js
var boxPlot = {
  boxPlot: {
    style: {
      lineWidth: 1
    }
  },
  label: {
    style: {
      lineWidth: 2
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/correlation.js
var correlation = {
  centerLabel: {
    visible: true,
    position: "center",
    style: {
      fill: "#fff",
      text: ""
    }
  },
  label: {
    visible: true,
    position: "bottom",
    style: {
      fill: "#000"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/liquid.js
var liquid = {
  outlinePadding: 10,
  liquidBackground: {
    style: {
      lineWidth: 0,
      fillOpacity: 0.2
    }
  },
  liquidOutline: {
    style: {
      lineWidth: 2
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/venn.js
var venn = {
  circle: {
    style: {
      opacity: 0.8
    },
    state: {
      hover: {
        opacity: 1
      }
    }
  },
  overlap: {
    style: {
      opacity: 0.8
    },
    state: {
      hover: {
        opacity: 1,
        stroke: "white",
        lineWidth: 2
      }
    }
  },
  label: {
    visible: true,
    style: {
      fill: "white",
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l4LineHeight"
      }
    }
  },
  overlapLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/mosaic.js
var mosaic = {
  label: {
    visible: false,
    position: "center",
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  bar: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/index.js
var series = {
  scatter,
  line,
  area,
  bar,
  bar3d,
  pie,
  pie3d,
  map: map2,
  radar,
  dot,
  link,
  wordCloud,
  wordCloud3d,
  funnel,
  funnel3d,
  linearProgress,
  circularProgress,
  waterfall,
  gauge,
  gaugePointer,
  treemap,
  sunburst,
  rangeColumn,
  circlePacking,
  heatmap,
  sankey,
  rose,
  boxPlot,
  correlation,
  liquid,
  venn,
  mosaic
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/mark.js
var markByType = {
  text: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var markByName = {
  label: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      lineJoin: "bevel"
    }
  },
  area: {
    style: {
      fillOpacity: 0.2
    }
  },
  line: {
    style: {
      lineWidth: 2,
      lineCap: "round",
      lineJoin: "round"
    }
  },
  point: {
    style: {
      size: 8,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 1,
      fillOpacity: 1
    }
  },
  word: {
    style: {
      fontWeight: null,
      fontSize: null
    }
  },
  fillingWord: {
    style: {
      fontWeight: null,
      fontSize: null
    }
  },
  sunburst: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  circlePacking: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  funnel3d: {
    style: {
      stroke: false
    }
  },
  barBackground: {
    visible: false,
    style: {
      fill: {
        type: "palette",
        key: "primaryFontColor",
        a: 0.06
      },
      stroke: "transparent"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/band-axis.js
var axisBand = {
  domainLine: {
    visible: true
  },
  grid: {
    visible: false
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: true
  },
  subTick: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/cartesian-axis.js
var axisX = {
  label: {
    space: 8
  },
  title: {
    space: 8
  },
  maxHeight: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisY = {
  label: {
    space: 12,
    autoLimit: true
  },
  title: {
    space: 12,
    autoRotate: true
  },
  maxWidth: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisZ = Object.assign(Object.assign({}, axisX), {
  label: {
    space: 0
  }
});

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/common-axis.js
var commonAxis = {
  domainLine: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  grid: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: []
    }
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  },
  tick: {
    visible: true,
    inside: false,
    tickSize: 4,
    alignWithLabel: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    tickSize: 2,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 10,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  title: {
    space: 10,
    padding: 0,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/linear-axis.js
var axisLinear = {
  domainLine: {
    visible: false
  },
  grid: {
    visible: true
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: false
  },
  subTick: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/polar-axis.js
var axisRadius = {
  grid: {
    smooth: true,
    visible: true
  },
  subGrid: {
    smooth: true,
    visible: false
  }
};
var axisAngle = {
  grid: {
    visible: true,
    style: {
      lineDash: [6, 6]
    }
  },
  label: {
    space: 5
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/brush.js
var brush = {
  style: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    lineWidth: 2
  },
  brushMode: "single",
  brushType: "rect",
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 0
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/crosshair.js
var crosshair = {
  trigger: "hover",
  bandField: {
    visible: false,
    line: {
      type: "rect",
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "axisGridColor"
        },
        opacity: 0.7,
        lineWidth: 0,
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        lineDash: [2, 3]
      }
    },
    label: {
      visible: false,
      style: {
        fontWeight: "normal",
        fill: {
          type: "palette",
          key: "axisMarkerFontColor"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        }
      },
      labelBackground: {
        padding: {
          bottom: 0,
          top: 0,
          left: 2,
          right: 2
        },
        style: {
          fill: {
            type: "palette",
            key: "axisMarkerBackgroundColor"
          },
          cornerRadius: 1
        }
      }
    }
  },
  linearField: {
    visible: false,
    line: {
      type: "line",
      visible: true,
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        fill: "transparent",
        opacity: 0.7,
        lineDash: [2, 3]
      }
    },
    label: {
      visible: false,
      style: {
        fontWeight: "normal",
        fill: {
          type: "palette",
          key: "axisMarkerFontColor"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        }
      },
      labelBackground: {
        padding: {
          bottom: 0,
          top: 0,
          left: 2,
          right: 2
        },
        style: {
          fill: {
            type: "palette",
            key: "axisMarkerBackgroundColor"
          },
          cornerRadius: 1
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/data-zoom.js
var DataZoomHandlerSymbolType = "M-0.5-2.4h0.9c0.4,0,0.7,0.3,0.7,0.7v3.3c0,0.4-0.3,0.7-0.7,0.7h-0.9c-0.4,0-0.7-0.3-0.7-0.7v-3.3\nC-1.2-2-0.9-2.4-0.5-2.4z M-0.4-1.4L-0.4-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC-0.4-1.4-0.4-1.4-0.4-1.4z M0.3-1.4L0.3-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC0.3-1.4,0.3-1.4,0.3-1.4z;";
var getHandlerTheme = () => ({
  style: {
    symbolType: DataZoomHandlerSymbolType,
    fill: {
      type: "palette",
      key: "sliderHandleColor"
    },
    scaleX: 1.2,
    scaleY: 1.2,
    stroke: {
      type: "palette",
      key: "dataZoomHandleStrokeColor"
    },
    lineWidth: 1
  }
});
var getBackgroundChartTheme = (visible) => ({
  area: {
    style: {
      visible,
      stroke: false,
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    }
  },
  line: {
    style: {
      visible,
      stroke: {
        type: "palette",
        key: "dataZoomChartColor"
      },
      lineWidth: 1
    }
  }
});
var dataZoom = {
  padding: [12, 0],
  showDetail: "auto",
  brushSelect: false,
  middleHandler: {
    visible: false,
    background: {
      size: 6,
      style: {
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        cornerRadius: 2
      }
    },
    icon: {
      style: {
        size: 4,
        fill: {
          type: "palette",
          key: "sliderHandleColor"
        },
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
        lineWidth: 0.5
      }
    }
  },
  background: {
    size: 20,
    style: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      },
      lineWidth: 0
    }
  },
  selectedBackground: {
    style: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.1,
      outerBorder: {
        stroke: {
          type: "palette",
          key: "sliderTrackColor"
        },
        strokeOpacity: 0.2,
        distance: -0.5,
        lineWidth: 1
      }
    }
  },
  selectedBackgroundChart: getBackgroundChartTheme(false),
  startHandler: getHandlerTheme(),
  endHandler: getHandlerTheme(),
  startText: {
    padding: 8,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  endText: {
    padding: 8,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  backgroundChart: getBackgroundChartTheme(true)
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/indicator.js
var getTextStyle = (fontSizeKey, fillKey) => ({
  fontSize: {
    type: "token",
    key: fontSizeKey
  },
  fill: {
    type: "palette",
    key: fillKey
  },
  fontWeight: "normal",
  fillOpacity: 1,
  textBaseline: "top",
  textAlign: "center"
});
var indicator = {
  title: {
    visible: true,
    autoLimit: false,
    autoFit: false,
    style: getTextStyle("l1FontSize", "primaryFontColor")
  },
  content: {
    visible: true,
    style: getTextStyle("l2FontSize", "tertiaryFontColor")
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/continuous.js
var DEFAULT_CONTINUOUS_LEGEND_THEME = {
  orient: "right",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    space: 12
  },
  handler: {
    visible: true
  },
  startText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  endText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  handlerText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/color-legend.js
var getColorLegendTheme = (horizontal) => {
  const rail = {
    width: 200,
    height: 8,
    style: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      }
    }
  };
  return horizontal ? (rail.width = 200, rail.height = 8) : (rail.width = 8, rail.height = 200), Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    rail,
    handler: {
      style: {
        symbolType: "circle",
        lineWidth: 0,
        outerBorder: {
          lineWidth: 2,
          distance: 0.8,
          stroke: "#ffffff"
        },
        shadowBlur: 12,
        shadowOffsetX: 0,
        shadowOffsetY: 4,
        shadowColor: {
          type: "palette",
          key: "shadowColor"
        }
      }
    }
  });
};
var colorLegend = {
  horizontal: getColorLegendTheme(true),
  vertical: getColorLegendTheme(false)
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/discrete-legend.js
var discreteLegend = {
  orient: "bottom",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontWeight: "normal"
    },
    space: 12
  },
  pager: {
    textStyle: {
      fill: {
        type: "palette",
        key: "discreteLegendPagerTextColor"
      }
    },
    handler: {
      style: {
        fill: {
          type: "palette",
          key: "discreteLegendPagerHandlerColor"
        }
      },
      state: {
        disable: {
          fill: {
            type: "palette",
            key: "discreteLegendPagerHandlerDisableColor"
          }
        }
      }
    }
  },
  item: {
    visible: true,
    spaceCol: 10,
    spaceRow: 6,
    padding: 2,
    background: {
      state: {
        selectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        },
        unSelectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        }
      }
    },
    shape: {
      space: 6,
      style: {
        lineWidth: 0,
        fillOpacity: 1,
        opacity: 1
      },
      state: {
        unSelected: {
          fillOpacity: 0.2,
          opacity: 1
        }
      }
    },
    label: {
      space: 6,
      style: {
        fill: {
          type: "palette",
          key: "secondaryFontColor",
          default: "#89909d"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        },
        lineHeight: {
          type: "token",
          key: "l5LineHeight"
        },
        opacity: 1
      },
      state: {
        unSelected: {
          fill: {
            type: "palette",
            key: "disableFontColor"
          },
          opacity: 1
        }
      }
    }
  },
  allowAllCanceled: false
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/size-legend.js
var getSizeLegendTheme = (horizontal) => {
  const rail = {
    style: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      }
    }
  };
  return horizontal ? (rail.width = 200, rail.height = 4) : (rail.height = 200, rail.width = 4), Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    sizeBackground: {
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    },
    track: {
      style: {
        fill: {
          type: "palette",
          key: "sliderTrackColor",
          a: 0.8
        }
      }
    },
    rail,
    handler: {
      style: {
        symbolType: "circle",
        lineWidth: 0,
        outerBorder: {
          lineWidth: 2,
          distance: 0.8,
          stroke: {
            type: "palette",
            key: "sliderTrackColor"
          }
        },
        fill: {
          type: "palette",
          key: "sliderHandleColor"
        }
      }
    }
  });
};
var sizeLegend = {
  horizontal: getSizeLegendTheme(true),
  vertical: getSizeLegendTheme(false)
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/map-label.js
var mapLabel = {
  visible: true,
  offset: 12,
  position: "top",
  space: 10,
  nameLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: {
        type: "token",
        key: "l6FontSize"
      }
    }
  },
  valueLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: {
        type: "token",
        key: "l6FontSize"
      }
    }
  },
  background: {
    visible: true,
    padding: {
      top: 4,
      bottom: 4,
      left: 6,
      right: 6
    },
    style: {
      cornerRadius: 2,
      lineWidth: 1,
      fill: "white",
      stroke: "grey"
    }
  },
  leader: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "red"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark.js
var getCommonLabelTheme = () => ({
  style: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    fontWeight: "normal",
    fontStyle: "normal",
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  labelBackground: {
    padding: {
      top: 2,
      bottom: 2,
      right: 4,
      left: 4
    },
    style: {
      cornerRadius: 3,
      fill: {
        type: "palette",
        key: "markLabelBackgroundColor"
      }
    }
  }
});

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-area.js
var markArea = {
  area: {
    style: {
      fill: {
        type: "palette",
        key: "axisDomainColor",
        a: 0.25
      }
    }
  },
  label: getCommonLabelTheme()
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-line.js
var getSymbolTheme = (visible) => ({
  visible,
  symbolType: "triangle",
  size: 10,
  style: {
    fill: {
      type: "palette",
      key: "markLineStrokeColor"
    },
    stroke: null,
    lineWidth: 0
  }
});
var labelTheme = getCommonLabelTheme();
labelTheme.refY = 5;
var markLine = {
  line: {
    style: {
      lineDash: [3, 3],
      stroke: {
        type: "palette",
        key: "markLineStrokeColor"
      }
    }
  },
  startSymbol: getSymbolTheme(false),
  endSymbol: getSymbolTheme(true),
  label: labelTheme
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-point.js
var markPoint = {
  itemLine: {
    decorativeLine: {
      visible: false
    },
    startSymbol: {
      size: 5,
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    endSymbol: {
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        }
      }
    }
  },
  itemContent: {
    offsetY: -50
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/player.js
var player = {
  visible: true,
  position: "start",
  padding: {
    top: 20,
    bottom: 20
  },
  slider: {
    space: 10,
    trackStyle: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.8
    },
    railStyle: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      }
    },
    handlerStyle: {
      size: 15,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fill: {
        type: "palette",
        key: "playerControllerColor"
      }
    }
  },
  controller: {
    start: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    pause: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    backward: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    forward: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/title.js
var title = {
  padding: {
    top: 4,
    bottom: 20
  },
  textStyle: {
    fontSize: {
      type: "token",
      key: "l3FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l3LineHeight"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  subtextStyle: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fill: {
      type: "palette",
      key: "tertiaryFontColor"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/tooltip.js
var tooltip = {
  offset: {
    x: 10,
    y: 10
  },
  panel: {
    padding: {
      top: 10,
      left: 10,
      right: 10,
      bottom: 10
    },
    backgroundColor: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    border: {
      color: {
        type: "palette",
        key: "popupBackgroundColor"
      },
      width: 0,
      radius: 3
    },
    shadow: {
      x: 0,
      y: 4,
      blur: 12,
      spread: 0,
      color: {
        type: "palette",
        key: "shadowColor"
      }
    }
  },
  spaceRow: 6,
  titleLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textBaseline: "middle",
    spacing: 0
  },
  shape: {
    size: 8,
    spacing: 6
  },
  keyLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "secondaryFontColor"
    },
    textBaseline: "middle",
    spacing: 26
  },
  valueLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textBaseline: "middle",
    spacing: 0
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/poptip.js
var poptip = {
  visible: true,
  position: "auto",
  padding: 8,
  titleStyle: {
    fontSize: {
      type: "token",
      key: "l5FontSize"
    },
    fontWeight: "bold",
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  contentStyle: {
    fontSize: {
      type: "token",
      key: "l5FontSize"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  panel: {
    visible: true,
    fill: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    cornerRadius: 3,
    lineWidth: 0,
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: {
      type: "palette",
      key: "shadowColor"
    },
    size: 0,
    space: 12
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/total-label.js
var totalLabel = {
  visible: false,
  offset: 5,
  overlap: {
    clampForce: true,
    strategy: []
  },
  smartInvert: false,
  animation: false,
  style: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/scroll-bar.js
var scrollBar = {
  horizontal: {
    height: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  },
  vertical: {
    width: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/index.js
var component = {
  discreteLegend,
  colorLegend,
  sizeLegend,
  axis: commonAxis,
  axisBand,
  axisLinear,
  axisX,
  axisY,
  axisZ,
  axisAngle,
  axisRadius,
  markLine,
  markArea,
  markPoint,
  polarMarkLine: markLine,
  polarMarkArea: markArea,
  polarMarkPoint: markPoint,
  geoMarkPoint: markPoint,
  tooltip,
  dataZoom,
  crosshair,
  player,
  brush,
  indicator,
  title,
  mapLabel,
  poptip,
  totalLabel,
  scrollBar
};

// node_modules/@visactor/vchart/esm/theme/token/util.js
function queryToken(tokenMap, tokenKey) {
  return tokenMap && tokenKey.key in tokenMap ? tokenMap[tokenKey.key] : tokenKey.default;
}
function isTokenKey(obj) {
  return obj && "token" === obj.type && !!obj.key;
}

// node_modules/@visactor/vchart/esm/theme/token/builtin/default.js
var token = {
  fontFamily: "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol",
  fontSize: 14,
  l1FontSize: 32,
  l1LineHeight: "150%",
  l2FontSize: 20,
  l2LineHeight: "140%",
  l3FontSize: 16,
  l3LineHeight: "150%",
  l4FontSize: 14,
  l4LineHeight: "150%",
  l5FontSize: 12,
  l5LineHeight: "130%",
  l6FontSize: 10,
  l6LineHeight: "120%"
};

// node_modules/@visactor/vchart/esm/theme/builtin/light/index.js
var lightTheme = {
  name: "light",
  background: {
    type: "palette",
    key: "backgroundColor"
  },
  padding: 20,
  fontFamily: {
    type: "token",
    key: "fontFamily"
  },
  colorScheme,
  token,
  mark: markByType,
  markByName,
  series,
  component,
  animationThreshold: 2e3
};

// node_modules/@visactor/vchart/esm/theme/builtin/dark/color-scheme.js
var colorScheme2 = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#202226",
      borderColor: "#404349",
      shadowColor: "rgba(0,0,0,0.1)",
      hoverBackgroundColor: "#404349",
      sliderRailColor: "#404349",
      sliderHandleColor: "#202226",
      sliderTrackColor: "#4284FF",
      popupBackgroundColor: "#404349",
      primaryFontColor: "#fdfdfd",
      secondaryFontColor: "#bbbdc3",
      tertiaryFontColor: "#888c93",
      axisLabelFontColor: "#888c93",
      disableFontColor: "#55595f",
      axisMarkerFontColor: "#202226",
      axisGridColor: "#404349",
      axisDomainColor: "#4b4f54",
      dataZoomHandleStrokeColor: "#bbbdc3",
      dataZoomChartColor: "#55595F",
      playerControllerColor: "#4284FF",
      scrollBarSliderColor: "rgba(255,255,255,0.3)",
      axisMarkerBackgroundColor: "#fdfdfd",
      markLabelBackgroundColor: "#404349",
      markLineStrokeColor: "#bbbdc3",
      dangerColor: "#eb4b4b",
      warningColor: "#f0bd30",
      successColor: "#14b267",
      infoColor: "#4284ff",
      discreteLegendPagerTextColor: "#BBBDC3",
      discreteLegendPagerHandlerColor: "#BBBDC3",
      discreteLegendPagerHandlerDisableColor: "#55595F",
      emptyCircleColor: "#bbbdc3",
      linearProgressTrackColor: "#404349"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/dark/index.js
var darkTheme = {
  name: "dark",
  colorScheme: colorScheme2,
  component: {
    dataZoom: {
      selectedBackground: {
        style: {
          fillOpacity: 0.4,
          outerBorder: {
            strokeOpacity: 0.4
          }
        }
      }
    }
  }
};

// node_modules/@visactor/vutils-extension/es/utils/object.js
var includeSpec = (spec, searchSpec) => spec === searchSpec || !isFunction_default(spec) && !isFunction_default(searchSpec) && (isArray_default(spec) && isArray_default(searchSpec) ? searchSpec.every((searchItem) => spec.some((item) => includeSpec(item, searchItem))) : !(!isObject_default(spec) || !isObject_default(searchSpec)) && Object.keys(searchSpec).every((key) => includeSpec(spec[key], searchSpec[key])));
var setProperty = (target, path, value) => {
  if (isNil_default(path)) return target;
  const key = path[0];
  return isNil_default(key) ? target : 1 === path.length ? (target[key] = value, target) : (isNil_default(target[key]) && ("number" == typeof path[1] ? target[key] = [] : target[key] = {}), setProperty(target[key], path.slice(1), value));
};
var getProperty = (target, path, defaultValue) => {
  if (!isNil_default(path)) return get_default(target, path, defaultValue);
};

// node_modules/@visactor/vutils-extension/es/spec/clone-deep.js
var ignoreWhen = (value) => isDataView(value) || isHTMLElement(value);
function cloneDeepSpec(spec, excludeKeys = ["data"]) {
  return cloneDeep(spec, ignoreWhen, excludeKeys);
}

// node_modules/@visactor/vutils-extension/es/spec/merge-spec.js
function mergeSpec(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    const source = sources[sourceIndex];
    baseMerge(target, source, true, true);
  }
  return target;
}
function mergeSpecWithFilter(target, filter2, spec, forceMerge) {
  Object.keys(target).forEach((k2) => {
    if (isObject_default(filter2)) filter2.type === k2 && (isArray_default(target[k2]) ? target[k2].length >= filter2.index && (target[k2][filter2.index] = forceMerge ? mergeSpec({}, target[k2][filter2.index], spec) : spec) : target[k2] = forceMerge ? mergeSpec({}, target[k2], spec) : spec);
    else if (isArray_default(target[k2])) {
      const index = target[k2].findIndex((_s) => _s.id === filter2);
      index >= 0 && (target[k2][index] = forceMerge ? mergeSpec({}, target[k2][index], spec) : spec);
    } else target.id === filter2 && (target[k2] = forceMerge ? mergeSpec({}, target[k2], spec) : spec);
  });
}

// node_modules/@visactor/vchart/esm/core/factory.js
var Factory2 = class _Factory {
  static registerChart(key, chart) {
    _Factory._charts[key] = chart;
  }
  static registerSeries(key, series2) {
    _Factory._series[key] = series2;
  }
  static registerComponent(key, cmp, alwaysCheck) {
    _Factory._components[key] = {
      cmp,
      alwaysCheck
    };
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static registerRegion(key, region) {
    _Factory._regions[key] = region;
  }
  static registerTransform(key, transform30) {
    _Factory.transforms[key] = transform30;
  }
  static registerLayout(key, layout2) {
    _Factory._layout[key] = layout2;
  }
  static registerAnimation(key, animation) {
    _Factory._animations[key] = animation;
  }
  static registerImplement(key, implement) {
    _Factory._implements[key] = implement;
  }
  static registerChartPlugin(key, plugin) {
    _Factory._chartPlugin[key] = plugin;
  }
  static registerComponentPlugin(key, plugin) {
    _Factory._componentPlugin[key] = plugin;
  }
  static createChart(chartType, spec, options) {
    if (!_Factory._charts[chartType]) return null;
    return new (0, _Factory._charts[chartType])(spec, options);
  }
  static createChartSpecTransformer(chartType, option) {
    if (!_Factory._charts[chartType]) return null;
    const ChartConstructor = _Factory._charts[chartType];
    return new (0, ChartConstructor.transformerConstructor)(Object.assign({
      seriesType: ChartConstructor.seriesType
    }, option));
  }
  static createRegion(regionType, spec, options) {
    if (!_Factory._regions[regionType]) return null;
    return new (0, _Factory._regions[regionType])(spec, options);
  }
  static createRegionSpecTransformer(regionType, options) {
    if (!_Factory._regions[regionType]) return null;
    return new (0, _Factory._regions[regionType].transformerConstructor)(options);
  }
  static createSeries(seriesType, spec, options) {
    if (!_Factory._series[seriesType]) return null;
    return new (0, _Factory._series[seriesType])(spec, options);
  }
  static createSeriesSpecTransformer(seriesType, options) {
    if (!_Factory._series[seriesType]) return null;
    return new (0, _Factory._series[seriesType].transformerConstructor)(options);
  }
  static createMark(markType, name, options) {
    if (!_Factory._marks[markType]) return null;
    const markInstance = new (0, _Factory._marks[markType])(name, options);
    return "group" === markInstance.type && markInstance.setMarkConfig({
      interactive: false
    }), markInstance;
  }
  static getComponents() {
    return Object.values(_Factory._components);
  }
  static getComponentInKey(name) {
    return _Factory._components[name].cmp;
  }
  static getLayout() {
    return Object.values(_Factory._layout);
  }
  static getLayoutInKey(name) {
    return _Factory._layout[name];
  }
  static getSeries() {
    return Object.values(_Factory._series);
  }
  static getSeriesInType(type) {
    return _Factory._series[type];
  }
  static getRegionInType(type) {
    return _Factory._regions[type];
  }
  static getAnimationInKey(key) {
    return _Factory._animations[key];
  }
  static getImplementInKey(key) {
    return _Factory._implements[key];
  }
  static getSeriesMarkMap(seriesType) {
    return _Factory._series[seriesType] ? _Factory._series[seriesType].mark : {};
  }
  static getChartPlugins() {
    return Object.values(_Factory._chartPlugin);
  }
  static getComponentPlugins() {
    return Object.values(_Factory._componentPlugin);
  }
  static getComponentPluginInType(type) {
    return _Factory._componentPlugin[type];
  }
  static registerFormatter(func) {
    this._formatter = func;
  }
  static getFormatter() {
    return this._formatter;
  }
};
Factory2._charts = {}, Factory2._series = {}, Factory2._components = {}, Factory2._marks = {}, Factory2._regions = {}, Factory2._animations = {}, Factory2._implements = {}, Factory2._chartPlugin = {}, Factory2._componentPlugin = {}, Factory2.transforms = {
  fields,
  filter,
  fold
}, Factory2.dataParser = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser
}, Factory2._layout = {};

// node_modules/@visactor/vchart/esm/util/theme/merge-theme.js
function mergeTheme(target, ...sources) {
  return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}
function transformThemeToMerge(theme2) {
  var _a;
  if (!theme2) return theme2;
  const colorScheme3 = transformColorSchemeToMerge(theme2.colorScheme);
  return Object.assign({}, theme2, {
    colorScheme: colorScheme3,
    token: null !== (_a = theme2.token) && void 0 !== _a ? _a : {},
    series: Object.assign({}, theme2.series)
  });
}
function transformColorSchemeToMerge(colorScheme3) {
  return colorScheme3 && (colorScheme3 = Object.keys(colorScheme3).reduce((scheme, key) => {
    const value = colorScheme3[key];
    return scheme[key] = transformColorSchemeToStandardStruct(value), scheme;
  }, {})), colorScheme3;
}
function transformSeriesThemeToMerge(seriesTheme, seriesType, markByType2, markByName2) {
  const seriesMarkInfoMap = Factory2.getSeriesMarkMap(seriesType);
  if (!seriesMarkInfoMap) return seriesTheme;
  const newTheme = {};
  return Object.values(seriesMarkInfoMap).forEach(({ type, name }) => {
    newTheme[name] = mergeSpec({}, null == markByType2 ? void 0 : markByType2[array(type)[0]], null == markByName2 ? void 0 : markByName2[name], null == seriesTheme ? void 0 : seriesTheme[name]);
  }), Object.assign(Object.assign({}, seriesTheme), newTheme);
}

// node_modules/@visactor/vchart/esm/util/theme/preprocess.js
var IGNORE_KEYS = ["animationThreshold", "colorScheme", "name", "padding"];
function preprocessTheme(obj, colorScheme3, tokenMap, seriesSpec) {
  if (!obj) return obj;
  colorScheme3 || (colorScheme3 = obj.colorScheme), tokenMap || (tokenMap = obj.token);
  const newObj = {};
  return Object.keys(obj).forEach((key) => {
    const value = obj[key];
    IGNORE_KEYS.includes(key) ? newObj[key] = value : isPlainObject_default(value) ? isColorKey(value) ? newObj[key] = getActualColor(value, colorScheme3, seriesSpec) : isTokenKey(value) ? newObj[key] = queryToken(tokenMap, value) : newObj[key] = preprocessTheme(value, colorScheme3, tokenMap, seriesSpec) : newObj[key] = value;
  }), newObj;
}

// node_modules/@visactor/vchart/esm/theme/builtin/index.js
var builtinThemes = {
  [lightTheme.name]: lightTheme
};
var defaultThemeName = lightTheme.name;
var themes = new Map(Object.keys(builtinThemes).map((key) => [key, builtinThemes[key]]));
var transformedThemes = new Map(Object.keys(builtinThemes).map((key) => [key, preprocessTheme(builtinThemes[key])]));
var hasThemeMerged = new Map(Object.keys(builtinThemes).map((key) => [key, key === defaultThemeName]));
var registerTheme = (name, theme2) => {
  if (!name) return;
  const mergedTheme = getMergedTheme(theme2);
  themes.set(name, mergedTheme), transformedThemes.set(name, preprocessTheme(mergedTheme)), hasThemeMerged.set(name, true);
};
var getTheme2 = (name = defaultThemeName, transformed = false) => (hasThemeMerged.has(name) && !hasThemeMerged.get(name) && registerTheme(name, themes.get(name)), transformed ? transformedThemes.get(name) : themes.get(name));
var removeTheme = (name) => themes.delete(name) && transformedThemes.delete(name) && hasThemeMerged.delete(name);
var themeExist = (name) => !!isString_default(name) && themes.has(name);
var getMergedTheme = (theme2) => {
  var _a;
  const baseThemeName = null !== (_a = theme2.type) && void 0 !== _a ? _a : defaultThemeName, baseTheme = getTheme2(baseThemeName);
  return mergeTheme({}, baseTheme, theme2);
};

// node_modules/@visactor/vchart/esm/core/instance-manager.js
var InstanceManager = class _InstanceManager {
  static registerInstance(instance) {
    _InstanceManager.instances.set(instance.id, instance);
  }
  static unregisterInstance(instance) {
    _InstanceManager.instances.delete(instance.id);
  }
  static getInstance(id) {
    return _InstanceManager.instances.get(id);
  }
  static instanceExist(id) {
    return _InstanceManager.instances.has(id);
  }
  static forEach(callbackfn, excludeId = [], thisArg) {
    const excludeIdList = array(excludeId);
    return _InstanceManager.instances.forEach((instance, id, map4) => {
      excludeIdList.includes(id) || callbackfn(instance, id, map4);
    }, thisArg);
  }
};
InstanceManager.instances = /* @__PURE__ */ new Map();

// node_modules/@visactor/vchart/esm/theme/theme-manager.js
var ThemeManager = class _ThemeManager {
  static registerTheme(name, theme2) {
    registerTheme(name, theme2);
  }
  static getTheme(name, transformed = false) {
    return getTheme2(name, transformed);
  }
  static removeTheme(name) {
    return removeTheme(name);
  }
  static themeExist(name) {
    return themeExist(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.themes.get(defaultThemeName);
  }
  static setCurrentTheme(name) {
    _ThemeManager.themeExist(name) && (_ThemeManager._currentThemeName = name, InstanceManager.forEach((instance) => null == instance ? void 0 : instance.setCurrentTheme(name)));
  }
  static getCurrentTheme(transformed = false) {
    return _ThemeManager.getTheme(_ThemeManager._currentThemeName, transformed);
  }
  static getCurrentThemeName() {
    return _ThemeManager._currentThemeName;
  }
};
ThemeManager.themes = themes, ThemeManager._currentThemeName = defaultThemeName;

// node_modules/@visactor/vchart/esm/util/theme/common.js
function getThemeObject(theme2, transformed) {
  return isString_default(theme2) ? ThemeManager.themeExist(theme2) ? ThemeManager.getTheme(theme2, transformed) : {} : isObject_default(theme2) ? theme2 : {};
}

// node_modules/@visactor/vchart/esm/util/spec/transform.js
function specTransform(spec, special = {
  data: (v) => v
}) {
  if (!spec) return spec;
  if (spec.constructor === Object) {
    const result2 = {};
    for (const key in spec) if (Object.prototype.hasOwnProperty.call(spec, key)) {
      if (special[key]) {
        result2[key] = special[key](spec[key]);
        continue;
      }
      result2[key] = specTransform(spec[key], special);
    }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s2) => specTransform(s2, special)) : spec;
}
function functionTransform(spec, VChart2) {
  if (!spec) return spec;
  if (isPlainObject_default(spec)) {
    const result2 = {};
    for (const key in spec) if (Object.prototype.hasOwnProperty.call(spec, key)) {
      if (isString_default(spec[key]) && VChart2.getFunction(spec[key])) {
        result2[key] = VChart2.getFunction(spec[key]);
        continue;
      }
      result2[key] = functionTransform(spec[key], VChart2);
    }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s2) => functionTransform(s2, VChart2)) : spec;
}

// node_modules/@visactor/vchart/esm/util/text.js
var initTextMeasure2 = (textSpec, option, useNaiveCanvas) => initTextMeasure(textSpec, option, useNaiveCanvas, {
  fontFamily: token.fontFamily,
  fontSize: token.fontSize
});
var measureText = (text2, textSpec, option, useNaiveCanvas) => initTextMeasure2(textSpec, option, useNaiveCanvas).measure(text2);

// node_modules/@visactor/vchart/esm/constant/data.js
var DEFAULT_MEASURE_CANVAS_ID = `${PREFIX}_MEASURE_CANVAS_ID`;
var DEFAULT_DATA_INDEX = `${PREFIX}_DEFAULT_DATA_INDEX`;
var DEFAULT_DATA_KEY = `${PREFIX}_DEFAULT_DATA_KEY`;
var DEFAULT_DATA_SERIES_FIELD = `${PREFIX}_DEFAULT_DATA_SERIES_FIELD`;
var DEFAULT_SERIES_STYLE_NAME = `${PREFIX}_DEFAULT_SERIES_STYLE_NAME`;
var STACK_FIELD_KEY = `${PREFIX}_STACK_KEY`;
var STACK_FIELD_START = `${PREFIX}_STACK_START`;
var STACK_FIELD_END = `${PREFIX}_STACK_END`;
var STACK_FIELD_START_PERCENT = `${PREFIX}_STACK_START_PERCENT`;
var STACK_FIELD_END_PERCENT = `${PREFIX}_STACK_END_PERCENT`;
var STACK_FIELD_START_OffsetSilhouette = `${PREFIX}_STACK_START_OffsetSilhouette`;
var STACK_FIELD_END_OffsetSilhouette = `${PREFIX}_STACK_END_OffsetSilhouette`;
var STACK_FIELD_TOTAL = `${PREFIX}_STACK_TOTAL`;
var STACK_FIELD_TOTAL_PERCENT = `${PREFIX}_STACK_TOTAL_PERCENT`;
var STACK_FIELD_TOTAL_TOP = `${PREFIX}_STACK_TOTAL_TOP`;
var STACK_FIELD_TOTAL_BOTTOM = `${PREFIX}_STACK_TOTAL_BOTTOM`;
var MOSAIC_VALUE_START_PERCENT = `${PREFIX}_MOSAIC_VALUE_START_PERCENT`;
var MOSAIC_VALUE_END_PERCENT = `${PREFIX}_MOSAIC_VALUE_END_PERCENT`;
var MOSAIC_CAT_START_PERCENT = `${PREFIX}_MOSAIC_CAT_START_PERCENT`;
var MOSAIC_CAT_END_PERCENT = `${PREFIX}_MOSAIC_CAT_END_PERCENT`;
var SEGMENT_FIELD_START = `${PREFIX}_SEGMENT_START`;
var SEGMENT_FIELD_END = `${PREFIX}_SEGMENT_END`;

// node_modules/@visactor/vchart/esm/util/data.js
function mergeFields(targetFields, mergeFields2) {
  for (let i = 0; i < mergeFields2.length; i++) {
    const element = mergeFields2[i], _target = findFields(targetFields, element.key);
    _target ? _target.operations = [...new Set(_target.operations.concat(element.operations))] : targetFields.push(element);
  }
  return targetFields;
}
function findFields(list, fieldKey) {
  return list.find((i) => i.key === fieldKey);
}
function getFieldAlias(dataView, field5) {
  var _a;
  if (!dataView) return null != field5 ? field5 : null;
  const fields2 = dataView.getFields();
  return fields2 && fields2[field5] ? null !== (_a = fields2[field5].alias) && void 0 !== _a ? _a : field5 : null != field5 ? field5 : null;
}
function getRegionStackGroup(region, setInitialValue, filter2) {
  const stackSort = region.getStackSort(), stackValueGroup = {};
  let stackSortCache = null;
  return stackSort && (stackSortCache = {}, region.getSeries().forEach((s2) => {
    const seriesField = s2.getSeriesField();
    if (seriesField) {
      const fieldInfo = s2.getRawDataStatisticsByField(seriesField);
      fieldInfo.values && (stackSortCache[seriesField] || (stackSortCache[seriesField] = {
        lastIndex: 0,
        sort: {}
      }), fieldInfo.values.forEach((v, i) => {
        v in stackSortCache[seriesField].sort || (stackSortCache[seriesField].sort[v] = stackSortCache[seriesField].lastIndex, stackSortCache[seriesField].lastIndex++);
      }));
    }
  })), region.getSeries().forEach((s2) => {
    var _a;
    const stackData = s2.getStackData(), stackValue = s2.getStackValue(), stackValueField = s2.getStackValueField(), filterEnable = !filter2 || filter2(s2);
    stackData && stackValueField && filterEnable && (stackValueGroup[stackValue] = null !== (_a = stackValueGroup[stackValue]) && void 0 !== _a ? _a : {
      groupField: stackData.groupField,
      nodes: {}
    }, stackGroup(s2, stackData, stackValueGroup[stackValue], stackValueField, setInitialValue, stackSortCache));
  }), stackSort ? sortStackValueGroup(stackValueGroup, stackSortCache) : stackValueGroup;
}
function sortStackValueGroup(stackValueGroup, stackSortCache) {
  var _a;
  for (const key in stackValueGroup) (null === (_a = stackValueGroup[key].sortDatums) || void 0 === _a ? void 0 : _a.length) ? (stackValueGroup[key].sortDatums.sort((a3, b) => a3.index - b.index), stackValueGroup[key].values = stackValueGroup[key].sortDatums.map((sd) => sd.datum)) : sortStackValueGroup(stackValueGroup[key].nodes, stackSortCache);
  return stackValueGroup;
}
function stackTotal(stackData, valueField) {
  if ("values" in stackData && stackData.values.length) {
    const total = sum(stackData.values, valueField), percent = max2(stackData.values, STACK_FIELD_END_PERCENT);
    stackData.values.forEach((v) => {
      v[STACK_FIELD_TOTAL] = total, v[STACK_FIELD_TOTAL_PERCENT] = percent;
    });
  } else for (const key in stackData.nodes) stackTotal(stackData.nodes[key], valueField);
}
function stackMosaicTotal(stackData, valueField) {
  var _a, _b;
  if ("values" in stackData && stackData.values.length) isValid_default(null === (_a = stackData.values[0]) || void 0 === _a ? void 0 : _a[STACK_FIELD_TOTAL]) ? stackData.total = null === (_b = stackData.values[0]) || void 0 === _b ? void 0 : _b[STACK_FIELD_TOTAL] : stackData.total = sum(stackData.values, valueField);
  else {
    for (const key in stackData.nodes) stackMosaicTotal(stackData.nodes[key], valueField);
    stackData.nodes && (stackData.total = sum(Object.keys(stackData.nodes).map((key) => stackData.nodes[key]), "total"));
  }
}
function stackMosaic(s2, stackCache, mosaicData) {
  var _a;
  if (stackCache.groupField && stackCache.nodes) {
    const groupValues = (null === (_a = s2.getRawDataStatisticsByField(stackCache.groupField, false)) || void 0 === _a ? void 0 : _a.values) || [], mosaicStackData = {
      key: `${stackCache.groupField}`,
      values: groupValues.map((group) => {
        const groupValues2 = stackCache.nodes[group];
        return {
          groupValue: group,
          value: groupValues2.total,
          end: groupValues2.total
        };
      })
    };
    stack(mosaicStackData, false, true, false, {
      key: "groupField",
      start: "start",
      end: "end",
      startPercent: "startPercent",
      endPercent: "endPercent"
    }), mosaicStackData.values.forEach((stackValue) => {
      stackCache.nodes[stackValue.groupValue].mosaicData = stackValue;
    });
  } else if ("values" in stackCache && stackCache.values.length && mosaicData && mosaicData.length) {
    const len = mosaicData.length;
    let catStartPercent = 0, catEndPercent = 1, valueStartPercent = 0, valueEndPercent = 1;
    for (let i = 0; i < len; i++) if (i % 2 == 0) {
      const catDelta = catEndPercent - catStartPercent;
      catEndPercent = catStartPercent + mosaicData[i].endPercent * catDelta, catStartPercent += mosaicData[i].startPercent * catDelta;
    } else {
      const valueDelta = valueEndPercent - valueStartPercent;
      valueEndPercent = valueStartPercent + mosaicData[i].endPercent * valueDelta, valueStartPercent += mosaicData[i].startPercent * valueDelta;
    }
    len % 2 == 0 ? stackCache.values.forEach((v) => {
      const delta = catEndPercent - catStartPercent;
      v[MOSAIC_CAT_END_PERCENT] = catStartPercent + delta * v[STACK_FIELD_END_PERCENT], v[MOSAIC_CAT_START_PERCENT] = catStartPercent + delta * v[STACK_FIELD_START_PERCENT], v[MOSAIC_VALUE_END_PERCENT] = valueEndPercent, v[MOSAIC_VALUE_START_PERCENT] = valueStartPercent;
    }) : stackCache.values.forEach((v) => {
      const delta = valueEndPercent - valueStartPercent;
      v[MOSAIC_VALUE_END_PERCENT] = valueStartPercent + delta * v[STACK_FIELD_END_PERCENT], v[MOSAIC_VALUE_START_PERCENT] = valueStartPercent + delta * v[STACK_FIELD_START_PERCENT], v[MOSAIC_CAT_END_PERCENT] = catEndPercent, v[MOSAIC_CAT_START_PERCENT] = catStartPercent;
    });
  }
  for (const key in stackCache.nodes) stackMosaic(s2, stackCache.nodes[key], stackCache.nodes[key].mosaicData ? mosaicData ? [...mosaicData, stackCache.nodes[key].mosaicData] : [stackCache.nodes[key].mosaicData] : null);
}
function stackOffsetSilhouette(stackCache) {
  if (!stackCache.values.length) return;
  const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;
  for (let j = 0; j < stackCache.values.length; j++) stackCache.values[j][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_START] - centerValue, stackCache.values[j][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_END] - centerValue;
}
function stack(stackCache, stackInverse, hasPercent, hasMinMax, fields2 = {
  key: STACK_FIELD_KEY,
  start: STACK_FIELD_START,
  end: STACK_FIELD_END,
  startPercent: STACK_FIELD_START_PERCENT,
  endPercent: STACK_FIELD_END_PERCENT,
  max: STACK_FIELD_TOTAL_TOP,
  min: STACK_FIELD_TOTAL_BOTTOM
}) {
  const hasMinField = hasMinMax && isValid_default(fields2.min), hasMaxField = hasMinMax && isValid_default(fields2.max);
  if (stackCache.values.length > 0) {
    let positiveStart = 0, negativeStart = 0, sign2 = 1, value = 0, minNode = null, maxNode = null;
    const maxLength = stackCache.values.length;
    for (let index = 0; index < maxLength; index++) {
      const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
      value = v[fields2.end], value >= 0 ? (v[fields2.start] = positiveStart, positiveStart += v[fields2.end], v[fields2.end] = positiveStart) : (v[fields2.start] = negativeStart, negativeStart += v[fields2.end], v[fields2.end] = negativeStart), v[fields2.key] = stackCache.key, hasMaxField && (delete v[fields2.max], (!maxNode || v[fields2.end] > maxNode[fields2.end]) && (maxNode = v)), hasMinField && (delete v[fields2.min], (!minNode || v[fields2.start] < minNode[fields2.start]) && (minNode = v));
    }
    if (hasMaxField && maxNode && (maxNode[fields2.max] = true), hasMinField && minNode && (minNode[fields2.min] = true), hasPercent) for (let index = 0; index < maxLength; index++) {
      const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
      value = v[fields2.end];
      const denominator = value >= 0 ? positiveStart : negativeStart;
      sign2 = value >= 0 ? 1 : -1, v[fields2.startPercent] = 0 === denominator ? 0 : Math.min(1, v[fields2.start] / denominator) * sign2, v[fields2.endPercent] = 0 === denominator ? 0 : Math.min(1, v[fields2.end] / denominator) * sign2;
    }
  }
  for (const key in stackCache.nodes) stack(stackCache.nodes[key], stackInverse, hasPercent, hasMinMax, fields2);
}
function stackGroup(s2, stackData, stackCache, valueField, setInitialValue, stackSortCache, stackKey) {
  var _a;
  if ("values" in stackData) if (setInitialValue && stackData.values.forEach((v) => v[STACK_FIELD_END] = toValidNumber2(v[valueField])), stackCache.series.push({
    s: s2,
    values: stackData.values
  }), stackSortCache) {
    const seriesField = s2.getSeriesField();
    stackData.values.forEach((d) => {
      stackCache.sortDatums.push({
        series: s2,
        datum: d,
        index: seriesField ? stackSortCache[seriesField].sort[d[seriesField]] : 0
      });
    });
  } else stackCache.values.push(...stackData.values);
  else for (const key in stackData.nodes) {
    const newStackKey = stackKey ? `${stackKey}_${key}` : key;
    stackCache.nodes[key] || (stackCache.nodes[key] = {
      values: [],
      series: [],
      nodes: {},
      sortDatums: [],
      key: newStackKey
    }, isValid_default(null === (_a = stackData.nodes[key]) || void 0 === _a ? void 0 : _a.groupField) && (stackCache.nodes[key].groupField = stackData.nodes[key].groupField)), stackGroup(s2, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue, stackSortCache, newStackKey);
  }
}

// node_modules/@visactor/vchart/esm/util/hierarchy.js
var findHierarchyNode = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i = 0; i < hierarchyData.length; i++) {
    const node = hierarchyData[i];
    if (node[keyField] === key) return node;
    if (node[childrenField]) {
      const result2 = findHierarchyNode(node[childrenField], key, keyField, childrenField);
      if (result2) return result2;
    }
  }
  return null;
};
var findHierarchyNodeParent = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i = 0; i < hierarchyData.length; i++) {
    const node = hierarchyData[i];
    if (node[childrenField]) for (let j = 0; j < node[childrenField].length; j++) {
      const childNode = node[childrenField][j];
      if (childNode[keyField] === key) return node;
      const result2 = findHierarchyNodeParent([childNode], key, keyField, childrenField);
      if (result2) return result2;
    }
  }
  return null;
};
var findHierarchyPath = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  const result2 = [], dfs = (data, path) => {
    for (const item of data) {
      if (item[keyField] === key) return result2.push(...path, item[keyField].toString()), true;
      if (item[childrenField]) {
        const res = dfs(item[childrenField], [...path, item[keyField]]);
        if (true === res) return res;
      }
    }
    return false;
  };
  return dfs(hierarchyData, []), result2;
};
function isHierarchyItem(item, valueField = "value", childrenField = "children") {
  return !!isObject_default(item) && (!!item.hasOwnProperty(childrenField) && Array.isArray(item[childrenField]));
}
function filterHierarchyDataByRange(data, minValue, maxValue, valueField = "value", childrenField = "children") {
  return Array.isArray(data) ? data.map((item) => {
    const newItem = Object.assign({}, item);
    return Array.isArray(newItem[childrenField]) && (newItem[childrenField] = filterHierarchyDataByRange(newItem[childrenField], minValue, maxValue, valueField, childrenField)), newItem;
  }).filter((item) => +item[valueField] >= minValue && +item[valueField] <= maxValue || item[childrenField] && item[childrenField].length > 0) : data;
}

// node_modules/@visactor/vchart/esm/util/style.js
function transformComponentStyle(cfg = {}) {
  const newConfig = Object.assign({}, cfg);
  if (isFunction_default(cfg.style) ? newConfig.style = (item, isSelected, index, allItems) => transformToGraphic(cfg.style(item, isSelected, index, allItems)) : isEmpty_default(cfg.style) || (newConfig.style = transformToGraphic(cfg.style)), !isEmpty_default(cfg.state)) {
    const newStateStyle = {};
    Object.keys(cfg.state).forEach((key) => {
      isFunction_default(cfg.state[key]) ? newStateStyle[key] = (item, isSelected, index, allItems) => transformToGraphic(cfg.state[key](item, isSelected, index, allItems)) : isEmpty_default(cfg.state[key]) || (newStateStyle[key] = transformToGraphic(cfg.state[key]));
    }), newConfig.state = newStateStyle;
  }
  return newConfig;
}
function transformStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle)) return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (value, index, datum, data) => transformToGraphic(stateStyle[key](value, index, datum, data)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformAxisLabelStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle)) return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (datum, index, data, layer) => transformToGraphic(stateStyle[key](datum.rawValue, index, datum, data, layer)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformIndicatorStyle(style, datum) {
  if (isEmpty_default(style)) return null;
  const newStateStyle = {};
  return Object.keys(style).forEach((key) => {
    isFunction_default(style[key]) ? newStateStyle[key] = style[key](datum) : newStateStyle[key] = style[key];
  }), transformToGraphic(newStateStyle);
}
function transformToGraphic(style) {
  return (null == style ? void 0 : style.angle) && (style.angle = degreeToRadian(style.angle)), style;
}

// node_modules/@visactor/vgrammar-core/es/graph/enums.js
var BuiltInEncodeNames;
!function(BuiltInEncodeNames2) {
  BuiltInEncodeNames2.enter = "enter", BuiltInEncodeNames2.update = "update", BuiltInEncodeNames2.exit = "exit", BuiltInEncodeNames2.group = "group", BuiltInEncodeNames2.connectNulls = "connectNulls";
}(BuiltInEncodeNames || (BuiltInEncodeNames = {}));
var DiffState;
!function(DiffState2) {
  DiffState2.enter = "enter", DiffState2.update = "update", DiffState2.exit = "exit", DiffState2.unChange = "unChange";
}(DiffState || (DiffState = {}));
var GrammarMarkType;
!function(GrammarMarkType2) {
  GrammarMarkType2.arc = "arc", GrammarMarkType2.arc3d = "arc3d", GrammarMarkType2.area = "area", GrammarMarkType2.image = "image", GrammarMarkType2.line = "line", GrammarMarkType2.path = "path", GrammarMarkType2.rect = "rect", GrammarMarkType2.rect3d = "rect3d", GrammarMarkType2.rule = "rule", GrammarMarkType2.shape = "shape", GrammarMarkType2.symbol = "symbol", GrammarMarkType2.text = "text", GrammarMarkType2.richtext = "richtext", GrammarMarkType2.polygon = "polygon", GrammarMarkType2.pyramid3d = "pyramid3d", GrammarMarkType2.circle = "circle", GrammarMarkType2.cell = "cell", GrammarMarkType2.interval = "interval", GrammarMarkType2.group = "group", GrammarMarkType2.glyph = "glyph", GrammarMarkType2.component = "component", GrammarMarkType2.largeRects = "largeRects", GrammarMarkType2.largeSymbols = "largeSymbols";
}(GrammarMarkType || (GrammarMarkType = {}));
var ComponentEnum;
!function(ComponentEnum2) {
  ComponentEnum2.axis = "axis", ComponentEnum2.grid = "grid", ComponentEnum2.legend = "legend", ComponentEnum2.slider = "slider", ComponentEnum2.label = "label", ComponentEnum2.datazoom = "datazoom", ComponentEnum2.player = "player", ComponentEnum2.title = "title", ComponentEnum2.scrollbar = "scrollbar";
}(ComponentEnum || (ComponentEnum = {}));
var DataFilterRank;
!function(DataFilterRank2) {
  DataFilterRank2[DataFilterRank2.player = 1] = "player", DataFilterRank2[DataFilterRank2.rollUp = 2] = "rollUp", DataFilterRank2[DataFilterRank2.drillDown = 3] = "drillDown", DataFilterRank2[DataFilterRank2.slider = 4] = "slider", DataFilterRank2[DataFilterRank2.datazoom = 5] = "datazoom", DataFilterRank2[DataFilterRank2.legend = 6] = "legend", DataFilterRank2[DataFilterRank2.scrollbar = 7] = "scrollbar", DataFilterRank2[DataFilterRank2.brush = 8] = "brush", DataFilterRank2[DataFilterRank2.normal = 9] = "normal";
}(DataFilterRank || (DataFilterRank = {}));
var AxisEnum;
!function(AxisEnum2) {
  AxisEnum2.lineAxis = "lineAxis", AxisEnum2.circleAxis = "circleAxis";
}(AxisEnum || (AxisEnum = {}));
var GridEnum;
!function(GridEnum2) {
  GridEnum2.lineAxisGrid = "lineAxisGrid", GridEnum2.circleAxisGrid = "circleAxisGrid";
}(GridEnum || (GridEnum = {}));
var LegendEnum;
!function(LegendEnum2) {
  LegendEnum2.discreteLegend = "discreteLegend", LegendEnum2.colorLegend = "colorLegend", LegendEnum2.sizeLegend = "sizeLegend";
}(LegendEnum || (LegendEnum = {}));
var CrosshairEnum;
!function(CrosshairEnum2) {
  CrosshairEnum2.lineCrosshair = "lineCrosshair", CrosshairEnum2.rectCrosshair = "rectCrosshair", CrosshairEnum2.sectorCrosshair = "sectorCrosshair", CrosshairEnum2.circleCrosshair = "circleCrosshair", CrosshairEnum2.polygonCrosshair = "polygonCrosshair", CrosshairEnum2.ringCrosshair = "ringCrosshair";
}(CrosshairEnum || (CrosshairEnum = {}));
var LabelEnum;
!function(LabelEnum2) {
  LabelEnum2.symbolLabel = "symbolLabel", LabelEnum2.rectLabel = "rectLabel", LabelEnum2.lineLabel = "lineLabel", LabelEnum2.dataLabel = "dataLabel";
}(LabelEnum || (LabelEnum = {}));
var PlayerEnum;
!function(PlayerEnum2) {
  PlayerEnum2.continuousPlayer = "continuousPlayer", PlayerEnum2.discretePlayer = "discretePlayer";
}(PlayerEnum || (PlayerEnum = {}));
var LayoutState;
!function(LayoutState2) {
  LayoutState2.before = "before", LayoutState2.layouting = "layouting", LayoutState2.reevaluate = "reevaluate", LayoutState2.after = "after";
}(LayoutState || (LayoutState = {}));
var HOOK_EVENT;
!function(HOOK_EVENT2) {
  HOOK_EVENT2.BEFORE_EVALUATE_DATA = "beforeEvaluateData", HOOK_EVENT2.AFTER_EVALUATE_DATA = "afterEvaluateData", HOOK_EVENT2.BEFORE_EVALUATE_SCALE = "beforeEvaluateScale", HOOK_EVENT2.AFTER_EVALUATE_SCALE = "afterEvaluateScale", HOOK_EVENT2.BEFORE_PARSE_VIEW = "beforeParseView", HOOK_EVENT2.AFTER_PARSE_VIEW = "afterParseView", HOOK_EVENT2.BEFORE_TRANSFORM = "beforeTransform", HOOK_EVENT2.AFTER_TRANSFORM = "afterTransform", HOOK_EVENT2.BEFORE_CREATE_VRENDER_STAGE = "beforeCreateVRenderStage", HOOK_EVENT2.AFTER_CREATE_VRENDER_STAGE = "afterCreateVRenderStage", HOOK_EVENT2.BEFORE_CREATE_VRENDER_LAYER = "beforeCreateVRenderLayer", HOOK_EVENT2.AFTER_CREATE_VRENDER_LAYER = "afterCreateVRenderLayer", HOOK_EVENT2.BEFORE_STAGE_RESIZE = "beforeStageResize", HOOK_EVENT2.AFTER_STAGE_RESIZE = "afterStageResize", HOOK_EVENT2.BEFORE_VRENDER_DRAW = "beforeVRenderDraw", HOOK_EVENT2.AFTER_VRENDER_DRAW = "afterVRenderDraw", HOOK_EVENT2.BEFORE_MARK_JOIN = "beforeMarkJoin", HOOK_EVENT2.AFTER_MARK_JOIN = "afterMarkJoin", HOOK_EVENT2.BEFORE_MARK_UPDATE = "beforeMarkUpdate", HOOK_EVENT2.AFTER_MARK_UPDATE = "afterMarkUpdate", HOOK_EVENT2.BEFORE_MARK_STATE = "beforeMarkState", HOOK_EVENT2.AFTER_MARK_STATE = "afterMarkState", HOOK_EVENT2.BEFORE_MARK_ENCODE = "beforeMarkEncode", HOOK_EVENT2.AFTER_MARK_ENCODE = "afterMarkEncode", HOOK_EVENT2.BEFORE_DO_LAYOUT = "beforeDoLayout", HOOK_EVENT2.AFTER_DO_LAYOUT = "afterDoLayout", HOOK_EVENT2.BEFORE_MARK_LAYOUT_END = "beforeMarkLayoutEnd", HOOK_EVENT2.AFTER_MARK_LAYOUT_END = "afterMarkLayoutEnd", HOOK_EVENT2.BEFORE_DO_RENDER = "beforeDoRender", HOOK_EVENT2.AFTER_DO_RENDER = "afterDoRender", HOOK_EVENT2.BEFORE_MARK_RENDER_END = "beforeMarkRenderEnd", HOOK_EVENT2.AFTER_MARK_RENDER_END = "afterMarkRenderEnd", HOOK_EVENT2.BEFORE_CREATE_VRENDER_MARK = "beforeCreateVRenderMark", HOOK_EVENT2.AFTER_CREATE_VRENDER_MARK = "afterCreateVRenderMark", HOOK_EVENT2.BEFORE_ADD_VRENDER_MARK = "beforeAddVRenderMark", HOOK_EVENT2.AFTER_ADD_VRENDER_MARK = "afterAddVRenderMark", HOOK_EVENT2.AFTER_VRENDER_NEXT_RENDER = "afterVRenderNextRender", HOOK_EVENT2.BEFORE_ELEMENT_UPDATE_DATA = "beforeElementUpdateData", HOOK_EVENT2.AFTER_ELEMENT_UPDATE_DATA = "afterElementUpdateData", HOOK_EVENT2.BEFORE_ELEMENT_STATE = "beforeElementState", HOOK_EVENT2.AFTER_ELEMENT_STATE = "afterElementState", HOOK_EVENT2.BEFORE_ELEMENT_ENCODE = "beforeElementEncode", HOOK_EVENT2.AFTER_ELEMENT_ENCODE = "afterElementEncode", HOOK_EVENT2.ANIMATION_START = "animationStart", HOOK_EVENT2.ANIMATION_END = "animationEnd", HOOK_EVENT2.ELEMENT_ANIMATION_START = "elementAnimationStart", HOOK_EVENT2.ELEMENT_ANIMATION_END = "elementAnimationEnd", HOOK_EVENT2.ALL_ANIMATION_START = "allAnimationStart", HOOK_EVENT2.ALL_ANIMATION_END = "allAnimationEnd";
}(HOOK_EVENT || (HOOK_EVENT = {}));
var GrammarTypeEnum;
!function(GrammarTypeEnum2) {
  GrammarTypeEnum2.signal = "signal", GrammarTypeEnum2.data = "data", GrammarTypeEnum2.scale = "scale", GrammarTypeEnum2.coordinate = "coordinate", GrammarTypeEnum2.mark = "mark";
}(GrammarTypeEnum || (GrammarTypeEnum = {}));
var InteractionStateEnum;
!function(InteractionStateEnum2) {
  InteractionStateEnum2.active = "active", InteractionStateEnum2.selected = "selected", InteractionStateEnum2.highlight = "highlight", InteractionStateEnum2.blur = "blur";
}(InteractionStateEnum || (InteractionStateEnum = {}));

// node_modules/@visactor/vgrammar-core/es/graph/constants.js
var BridgeElementKey = "__vgrammar_scene_item__";
var CollectionMarkType = [GrammarMarkType.line, GrammarMarkType.area];
var Mark3DType = [GrammarMarkType.arc3d, GrammarMarkType.rect3d, GrammarMarkType.pyramid3d];
var DefaultKey = "key";
var DefaultMarkData = [{}];
var DefaultGroupKeys = ["key"];
var DefaultReuse = true;
var DefaultMorph = true;
var DefaultMorphAll = false;
var DefaultSplitPath = null;
var DefaultEnableExitAnimation = true;
var ImmediateAnimationState = "VGRAMMAR_IMMEDIATE_ANIMATION";
var DefaultAnimationStartTime = 0;
var DefaultAnimationDuration = 1e3;
var DefaultAnimationDelay = 0;
var DefaultAnimationDelayAfter = 0;
var DefaultAnimationLoop = false;
var DefaultAnimationOneByOne = false;
var DefaultAnimationEasing = "quintInOut";
var DefaultAnimationControlOptions = {
  stopWhenStateChange: false,
  immediatelyApply: true
};
var DefaultAnimationParameters = "VGRAMMAR_ANIMATION_PARAMETERS";
var MARK_OVERLAP_HIDE_KEY = "_mo_hide_";

// node_modules/@visactor/vgrammar-core/es/parse/util.js
function parseReference(dependency, view) {
  return array(dependency).reduce((refs, dep) => {
    const ref = isString_default(dep) ? view.getGrammarById(dep) : dep;
    return ref && refs.push(ref), refs;
  }, []);
}
function isSignalReferenceType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.signal);
}
function isSignalFunctionType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.callback);
}
function parseFunctionType(spec, view) {
  if (isNil_default(spec)) return [];
  if (isSignalReferenceType(spec)) {
    const signal = spec.signal;
    if (isString_default(signal)) return array(view.getGrammarById(signal));
    if ("signal" === (null == signal ? void 0 : signal.grammarType)) return [signal];
  } else if (isSignalFunctionType(spec)) return parseReference(spec.dependency, view);
  return [];
}
function isFunctionType(spec) {
  return isFunction_default(spec) || (null == spec ? void 0 : spec.signal) || !!(null == spec ? void 0 : spec.callback);
}
function invokeFunctionType(spec, parameters, datumOrGrammarInstance, element) {
  if (isNil_default(spec)) return spec;
  if (isFunction_default(spec)) return element ? spec.call(null, datumOrGrammarInstance, element, parameters) : spec.call(null, datumOrGrammarInstance, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? element ? spec.callback.call(null, datumOrGrammarInstance, element, parameters) : spec.callback.call(null, datumOrGrammarInstance, parameters) : spec;
}
function invokeParameterFunctionType(spec, parameters) {
  if (isNil_default(spec)) return spec;
  if (isFunction_default(spec)) return spec.call(null, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? spec.callback.call(null, parameters) : spec;
}
function getGrammarOutput(grammar, parameters) {
  return isGrammar(grammar) ? grammar.output() : parameters[grammar];
}
function isSignal(obj) {
  return obj && (obj.signal || obj.callback);
}
var isGrammar = (el) => el && !isNil_default(el.grammarType);
var parseField = (field5) => isFunction_default(field5) ? field5 : (datum) => datum[field5];
var parseColor = (color) => isString_default(color) && Color.parseColorString(color) ? color : null;

// node_modules/@visactor/vgrammar-core/es/parse/mark.js
function isScaleEncode(encode) {
  return !!(null == encode ? void 0 : encode.scale);
}
function isFieldEncode(encode) {
  return !!(null == encode ? void 0 : encode.field);
}
function parseEncodeType(encoder2, view) {
  if (!encoder2) return [];
  let dependencies = [];
  return encoder2.scale && (dependencies = isGrammar(encoder2.scale) ? [encoder2.scale] : array(view.getScaleById(encoder2.scale))), dependencies.concat(parseFunctionType(encoder2, view));
}

// node_modules/@visactor/vgrammar-core/es/graph/attributes/helpers.js
function isValidPointsChannel(channels, markType) {
  switch (markType) {
    case "line":
      return channels.some((channel) => ["x", "y", "defined"].includes(channel));
    case "area":
      return channels.some((channel) => ["x", "y", "x1", "y1", "defined"].includes(channel));
    case "largeRects":
      return channels.some((channel) => ["x", "y", "width", "y1"].includes(channel));
    case "largeSymbols":
      return channels.some((channel) => ["x", "y"].includes(channel));
  }
  return false;
}
function getRulePoints(nextAttrs) {
  const { x, y, x1, y1 } = nextAttrs;
  return isValidNumber_default(x) && isValidNumber_default(y) && isValidNumber_default(x1) && isValidNumber_default(y1) ? [{
    x,
    y
  }, {
    x: x1,
    y: y1
  }] : [];
}
function getLinePoints(items, includeOnePoint, lastPoints, isArea) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
  return items.some((item) => isValidPointsChannel(Object.keys(item.nextAttrs), "line")) ? items.map((item, index) => {
    var _a;
    const attrs = item.nextAttrs, { x, y, x1, y1, defined } = null !== (_a = null == lastPoints ? void 0 : lastPoints[index]) && void 0 !== _a ? _a : {};
    return isNil_default(attrs.x) && (attrs.x = x), isNil_default(attrs.y) && (attrs.y = y), isNil_default(attrs.defined) && false === defined && (attrs.defined = false), attrs.context = item.key, isArea && (isNil_default(attrs.x1) && (attrs.x1 = x1), isNil_default(attrs.y1) && (attrs.y1 = y1)), attrs;
  }) : null != lastPoints ? lastPoints : [];
}
function getLargeRectsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
  const arr = new Float32Array(4 * items.length);
  return items.forEach((item, index) => {
    var _a, _b, _c, _d;
    const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[4 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[4 * index + 1], width = null !== (_c = attrs.width) && void 0 !== _c ? _c : lastPoints[4 * index + 2], y1 = null !== (_d = attrs.y1) && void 0 !== _d ? _d : lastPoints[4 * index + 3];
    arr[4 * index] = x, arr[4 * index + 1] = y, arr[4 * index + 2] = width, arr[4 * index + 3] = y1 - y;
  }), arr;
}
function getLargeSymbolsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
  const arr = new Float32Array(2 * items.length);
  return items.forEach((item, index) => {
    var _a, _b;
    const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[2 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[2 * index + 1];
    arr[2 * index] = x, arr[2 * index + 1] = y;
  }), arr;
}
function isPositionOrSizeChannel(type, channel) {
  if (["x", "y", "dx", "dy"].includes(channel)) return true;
  switch (type) {
    case GrammarMarkType.arc:
      return ["innerRadius", "outerRadius", "startAngle", "endAngle"].includes(channel);
    case GrammarMarkType.group:
    case GrammarMarkType.rect:
    case GrammarMarkType.image:
      return ["width", "height", "y1"].includes(channel);
    case GrammarMarkType.path:
    case GrammarMarkType.shape:
      return ["path", "customPath"].includes(channel);
    case GrammarMarkType.line:
      return "defined" === channel;
    case GrammarMarkType.area:
      return ["x1", "y1", "defined"].includes(channel);
    case GrammarMarkType.rule:
      return ["x1", "y1"].includes(channel);
    case GrammarMarkType.symbol:
      return "size" === channel;
    case GrammarMarkType.polygon:
      return "points" === channel;
    case GrammarMarkType.text:
      return "text" === channel;
  }
  return false;
}
function isPointsMarkType(markType) {
  return [GrammarMarkType.line, GrammarMarkType.area, GrammarMarkType.largeRects, GrammarMarkType.largeSymbols].includes(markType);
}

// node_modules/@visactor/vgrammar-core/es/graph/mark/encode.js
function invokeEncoderToItems(element, items, encoder2, parameters, onlyFullEncodeFirst) {
  encoder2 && (isFunctionType(encoder2) ? items.forEach((item) => {
    const attributes = invokeFunctionType(encoder2, parameters, item.datum, element);
    Object.assign(item.nextAttrs, attributes);
  }) : Object.keys(encoder2).forEach((channel) => {
    var _a, _b;
    const encode = encoder2[channel], encodeItems = onlyFullEncodeFirst && !isPositionOrSizeChannel(element.mark.markType, channel) ? [items[0]] : items;
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null;
      let to = hasField ? null : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, encode.value);
      encodeItems.forEach((item) => {
        var _a2;
        hasField && (to = null === (_a2 = scale4.scale) || void 0 === _a2 ? void 0 : _a2.call(scale4, fieldAccessor(item.datum))), item.nextAttrs[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
      });
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      encodeItems.forEach((item) => {
        item.nextAttrs[channel] = fieldAccessor(item.datum);
      });
    } else encodeItems.forEach((item) => {
      item.nextAttrs[channel] = invokeFunctionType(encode, parameters, item.datum, element);
    });
  }));
}
function invokeEncoder(encoder2, datum, element, parameters) {
  if (!encoder2) return null;
  if (isFunctionType(encoder2)) return invokeFunctionType(encoder2, parameters, datum, element);
  const attributes = {};
  return Object.keys(encoder2).forEach((channel) => {
    var _a, _b, _c;
    const encode = encoder2[channel];
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null, to = hasField ? null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, fieldAccessor(datum)) : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_c = scale4.scale) || void 0 === _c ? void 0 : _c.call(scale4, encode.value);
      attributes[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      attributes[channel] = fieldAccessor(datum);
    } else attributes[channel] = invokeFunctionType(encode, parameters, datum, element);
  }), attributes;
}

// node_modules/@visactor/vgrammar-core/es/view/glyph-meta.js
var GlyphMeta = class {
  constructor(marks, encoders, defaultEncoder, progressiveChannels) {
    this.channelEncoder = {}, this.marks = marks, encoders && this.registerChannelEncoder(encoders), defaultEncoder && this.registerDefaultEncoder(defaultEncoder), this.progressiveChannels && this.registerProgressiveChannels(progressiveChannels);
  }
  getMarks() {
    return this.marks;
  }
  registerChannelEncoder(channel, encoder2) {
    return isString_default(channel) ? this.channelEncoder[channel] = encoder2 : Object.assign(this.channelEncoder, channel), this;
  }
  registerFunctionEncoder(encoder2) {
    return this.functionEncoder = encoder2, this;
  }
  registerDefaultEncoder(encoder2) {
    return this.defaultEncoder = encoder2, this;
  }
  registerProgressiveChannels(channels) {
    return this.progressiveChannels = array(channels), this;
  }
  getChannelEncoder() {
    return this.channelEncoder;
  }
  getFunctionEncoder() {
    return this.functionEncoder;
  }
  getDefaultEncoder() {
    return this.defaultEncoder;
  }
  getProgressiveChannels() {
    return this.progressiveChannels;
  }
};

// node_modules/@visactor/vgrammar-core/es/core/factory.js
var Factory3 = class _Factory {
  static registerPlotMarks(key, mark) {
    _Factory._plotMarks[key] = mark;
  }
  static createPlotMark(type, id) {
    if (!_Factory._plotMarks[type]) return null;
    return new (0, _Factory._plotMarks[type])(id);
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static createMark(type, view, group) {
    if (!_Factory._marks[type]) return null;
    return new (0, _Factory._marks[type])(view, type, group);
  }
  static hasMark(type) {
    return !!_Factory._marks[type];
  }
  static getMark(type) {
    return _Factory._marks[type];
  }
  static registerComponent(key, component2) {
    _Factory._components[key] = component2;
  }
  static createComponent(componentType, view, group, mode) {
    const Ctor = _Factory._components[componentType];
    return Ctor ? new Ctor(view, group, mode) : null;
  }
  static hasComponent(componentType) {
    return !!_Factory._components[componentType];
  }
  static registerGraphicComponent(key, creator) {
    _Factory._graphicComponents[key] = creator;
  }
  static createGraphicComponent(componentType, attrs, options) {
    const compCreator = _Factory._graphicComponents[componentType];
    return compCreator ? compCreator(attrs, options) : null;
  }
  static registerTransform(type, transform30, isBuiltIn) {
    _Factory._transforms[type] = Object.assign(transform30, {
      type,
      isBuiltIn: !!isBuiltIn
    });
  }
  static getTransform(type) {
    return _Factory._transforms[type];
  }
  static unregisterRuntimeTransforms() {
    Object.keys(_Factory._transforms).forEach((type) => {
      _Factory._transforms[type] && !_Factory._transforms[type].isBuiltIn && (_Factory._transforms[type] = null);
    });
  }
  static registerGrammar(type, grammarClass, specKey) {
    _Factory._grammars[type] = {
      grammarClass,
      specKey: null != specKey ? specKey : type
    };
  }
  static createGrammar(type, view, grammarType) {
    var _a;
    const Ctor = null === (_a = _Factory._grammars[type]) || void 0 === _a ? void 0 : _a.grammarClass;
    return Ctor ? new Ctor(view, grammarType) : null;
  }
  static getGrammars() {
    return this._grammars;
  }
  static getGlyph(glyphType) {
    return _Factory._glyphs[glyphType];
  }
  static createInteraction(interactionType, view, options) {
    const Ctor = _Factory._interactions[interactionType];
    return Ctor ? new Ctor(view, options) : null;
  }
  static hasInteraction(interactionType) {
    return !!_Factory._interactions[interactionType];
  }
};
Factory3._plotMarks = {}, Factory3._marks = {}, Factory3._components = {}, Factory3._graphicComponents = {}, Factory3._transforms = {}, Factory3._grammars = {}, Factory3._glyphs = {}, Factory3._animations = {}, Factory3._interactions = {}, Factory3._graphics = {}, Factory3._stageEventPlugins = {}, Factory3.registerGlyph = (glyphType, marks, encoders, defaultEncoder, progressiveChannels) => (Factory3._glyphs[glyphType] = new GlyphMeta(marks, encoders, defaultEncoder, progressiveChannels), Factory3._glyphs[glyphType]), Factory3.registerAnimationType = (animationType, animation) => {
  Factory3._animations[animationType] = animation;
}, Factory3.getAnimationType = (animationType) => Factory3._animations[animationType], Factory3.registerInteraction = (interactionType, interaction) => {
  Factory3._interactions[interactionType] = interaction;
}, Factory3.registerGraphic = (graphicType, creator) => {
  Factory3._graphics[graphicType] = creator;
}, Factory3.getGraphicType = (graphicType) => Factory3._graphics[graphicType], Factory3.createGraphic = (graphicType, attributes) => {
  const creator = Factory3._graphics[graphicType];
  return creator ? creator(attributes) : null;
}, Factory3.registerDefaultLayout = (layout2) => {
  Factory3.defaultLayout = layout2;
}, Factory3.getDefaultLayout = () => Factory3.defaultLayout, Factory3.registerStageEventPlugin = (type, Plugin) => {
  Factory3._stageEventPlugins[type] = Plugin;
}, Factory3.getStageEventPlugin = (type) => Factory3._stageEventPlugins[type];

// node_modules/@visactor/vgrammar-core/es/graph/util/graphic.js
var isMarkType = (type) => !!GrammarMarkType[type];
function createGraphicItem(mark, markType, attrs = {}) {
  var _a;
  const graphicItem = Factory3.getGraphicType(markType) ? Factory3.createGraphic(markType, attrs) : Factory3.createGraphicComponent(markType, attrs, {
    skipDefault: null === (_a = null == mark ? void 0 : mark.spec) || void 0 === _a ? void 0 : _a.skipTheme
  });
  if (!graphicItem) {
    Logger.getInstance().error(`create ${markType} graphic failed!`);
  }
  return graphicItem;
}
function createGlyphGraphicItem(mark, glyphMeta, attrs = {}) {
  if (!Factory3.getGraphicType(GrammarMarkType.glyph)) return;
  const graphicItem = Factory3.createGraphic(GrammarMarkType.glyph, attrs), glyphMarks = glyphMeta.getMarks(), subGraphics = Object.keys(glyphMarks).map((name) => {
    if (Factory3.getGraphicType(glyphMarks[name])) {
      const graphic = Factory3.createGraphic(glyphMarks[name]);
      if (graphic) return graphic.name = name, graphic;
    }
  });
  return graphicItem.setSubGraphic(subGraphics), graphicItem;
}
var removeGraphicItem = (graphicItem) => {
  graphicItem && (graphicItem[BridgeElementKey] = null, graphicItem.release(), graphicItem.parent && graphicItem.parent.removeChild(graphicItem));
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/common.js
var commonAttributes = ["fillOpacity"];
var transformCommonAttribute = (graphicAttributes, changedKey, nextAttrs) => {
  var _a;
  return "fillOpacity" === changedKey ? (graphicAttributes.fillOpacity = null !== (_a = nextAttrs.fillOpacity) && void 0 !== _a ? _a : 1, ["fillOpacity"]) : [];
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/transform.js
function storeOriginAttributes(name, channels, graphicAttributes, nextAttrs, element, markName) {
  const prevStoredAttrs = element.getGraphicAttribute(name, false, markName);
  if (prevStoredAttrs) return channels.forEach((channel) => {
    channel in nextAttrs && (prevStoredAttrs[channel] = nextAttrs[channel]);
  }), prevStoredAttrs;
  const storedAttrs = {};
  return channels.forEach((channel) => {
    storedAttrs[channel] = nextAttrs[channel];
  }), graphicAttributes[name] = storedAttrs, storedAttrs;
}
var transformsByType = {
  rect3d: [{
    channels: ["x", "y", "z", "x1", "y1", "width", "height", "length"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      isValidNumber_default(nextAttrs.width) || !isValidNumber_default(nextAttrs.x1) && isValidNumber_default(storedAttrs.width) ? (graphicAttributes.x = Math.min(null !== (_a = storedAttrs.x) && void 0 !== _a ? _a : 0, null !== (_b = storedAttrs.x1) && void 0 !== _b ? _b : 1 / 0), graphicAttributes.width = storedAttrs.width) : isValidNumber_default(nextAttrs.x1) || !isValidNumber_default(nextAttrs.width) && isValidNumber_default(storedAttrs.x1) ? (graphicAttributes.x = Math.min(storedAttrs.x, storedAttrs.x1), graphicAttributes.width = Math.abs(storedAttrs.x1 - storedAttrs.x)) : (graphicAttributes.x = Math.min(null !== (_c = storedAttrs.x) && void 0 !== _c ? _c : 0, null !== (_d = storedAttrs.x1) && void 0 !== _d ? _d : 1 / 0), graphicAttributes.width = storedAttrs.width), isValidNumber_default(nextAttrs.height) || !isValidNumber_default(nextAttrs.y1) && isValidNumber_default(storedAttrs.height) ? (graphicAttributes.y = Math.min(null !== (_e = storedAttrs.y) && void 0 !== _e ? _e : 0, null !== (_f = storedAttrs.y1) && void 0 !== _f ? _f : 1 / 0), graphicAttributes.height = storedAttrs.height) : isValidNumber_default(nextAttrs.y1) || !isValidNumber_default(nextAttrs.height) && isValidNumber_default(storedAttrs.y1) ? (graphicAttributes.y = Math.min(storedAttrs.y, storedAttrs.y1), graphicAttributes.height = Math.abs(storedAttrs.y1 - storedAttrs.y)) : (graphicAttributes.y = Math.min(null !== (_g = storedAttrs.y) && void 0 !== _g ? _g : 0, null !== (_h = storedAttrs.y1) && void 0 !== _h ? _h : 1 / 0), graphicAttributes.height = storedAttrs.height), isValidNumber_default(nextAttrs.length) || !isValidNumber_default(nextAttrs.z1) && isValidNumber_default(storedAttrs.length) ? (graphicAttributes.z = Math.min(null !== (_j = storedAttrs.z) && void 0 !== _j ? _j : 0, null !== (_k = storedAttrs.z1) && void 0 !== _k ? _k : 1 / 0), graphicAttributes.length = storedAttrs.length) : isValidNumber_default(nextAttrs.z1) || !isValidNumber_default(nextAttrs.length) && isValidNumber_default(storedAttrs.z1) ? (graphicAttributes.z = Math.min(storedAttrs.z, storedAttrs.z1), graphicAttributes.length = Math.abs(storedAttrs.z1 - storedAttrs.z)) : (graphicAttributes.z = Math.min(null !== (_l = storedAttrs.z) && void 0 !== _l ? _l : 0, null !== (_m = storedAttrs.z1) && void 0 !== _m ? _m : 1 / 0), graphicAttributes.length = storedAttrs.length);
    },
    storedAttrs: "sizeAttrs"
  }],
  [GrammarMarkType.text]: [{
    channels: ["text", "limit", "autoLimit", "maxLineWidth", "textType", "_originText"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d;
      const limit = null !== (_a = storedAttrs.limit) && void 0 !== _a ? _a : 1 / 0, autoLimit2 = null !== (_b = storedAttrs.autoLimit) && void 0 !== _b ? _b : 1 / 0, maxWidth = Math.min(limit, autoLimit2), isTextConfig = isPlainObject_default(storedAttrs.text) && !isNil_default(storedAttrs.text.text), text2 = isTextConfig ? storedAttrs.text.text : storedAttrs.text;
      Array.isArray(text2), graphicAttributes.maxLineWidth = maxWidth === 1 / 0 ? storedAttrs.maxLineWidth : maxWidth, isTextConfig || storedAttrs.textType ? "rich" === storedAttrs.text.type || "rich" === storedAttrs.textType ? graphicAttributes.textConfig = text2 : "html" === storedAttrs.text.type ? (graphicAttributes.html = text2, graphicAttributes.text = null !== (_c = storedAttrs._originText) && void 0 !== _c ? _c : "", graphicAttributes.renderable = false) : "react" === storedAttrs.text.type ? (graphicAttributes.react = text2, graphicAttributes.text = null !== (_d = storedAttrs._originText) && void 0 !== _d ? _d : "", graphicAttributes.renderable = false) : graphicAttributes.text = text2 : graphicAttributes.text = text2;
    },
    storedAttrs: "limitAttrs"
  }],
  [GrammarMarkType.rule]: [{
    channels: ["x", "y", "x1", "y1"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      const points = getRulePoints(storedAttrs);
      graphicAttributes.points = points, graphicAttributes.x = 0, graphicAttributes.y = 0;
    },
    storedAttrs: "pointAttrs"
  }],
  [GrammarMarkType.symbol]: [{
    channels: ["shape", "symbolType"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a;
      graphicAttributes.symbolType = null !== (_a = nextAttrs.shape) && void 0 !== _a ? _a : nextAttrs.symbolType;
    }
  }, {
    channels: ["image", "fill", "background"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      nextAttrs.image ? (graphicAttributes.background = nextAttrs.image, graphicAttributes.fill = false) : storedAttrs.image ? (graphicAttributes.background = storedAttrs.image, graphicAttributes.fill = false) : (graphicAttributes.fill = storedAttrs.fill, graphicAttributes.background = storedAttrs.background);
    },
    storedAttrs: "imageAttrs"
  }]
};
function cloneTransformAttributes(markType, attributes) {
  var _a;
  return (null !== (_a = transformsByType[markType]) && void 0 !== _a ? _a : []).reduce((clonedAttributes, transform30) => (transform30.channels.forEach((channel) => {
    has_default(attributes, channel) && (clonedAttributes[channel] = attributes[channel]);
  }), clonedAttributes), {});
}
var transformAttributes = (markType, nextAttrs, element, markName) => {
  const graphicAttributes = {}, changedKeys = nextAttrs ? Object.keys(nextAttrs) : [], transforms = isString_default(markType) ? transformsByType[markType] : markType;
  if (transforms && transforms.length) {
    const tags = [];
    changedKeys.forEach((key) => {
      let isTransformed = false;
      transforms.forEach((transform30, index) => {
        if (transform30.channels.includes(key)) {
          if (!tags[index]) if (transform30.storedAttrs) {
            const storedAttrs = storeOriginAttributes(transform30.storedAttrs, transform30.channels, graphicAttributes, nextAttrs, element, markName);
            transform30.transform(graphicAttributes, nextAttrs, storedAttrs);
          } else transform30.transform(graphicAttributes, nextAttrs, null);
          tags[index] = true, isTransformed = true;
        }
      }), isTransformed || (commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key]);
    });
  } else changedKeys.forEach((key) => {
    commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key];
  });
  return graphicAttributes;
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/line.js
var isStopsEqual = (prev, next) => {
  var _a, _b;
  if (prev === next) return true;
  const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
  return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset);
};
var isColorAttrEqual = (prev, next) => {
  if (prev === next) return true;
  if (typeof prev != typeof next) return false;
  if (isString_default(prev)) return false;
  if (prev.gradient !== next.gradient) return false;
  const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
  return prevKeys.length === nextKeys.length && prevKeys.every((key) => "stops" === key ? isStopsEqual(prev[key], next[key]) : prev[key] === next[key]);
};
var isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-");
var isSegmentAttrEqual = (prev, next, key) => !(!isNil_default(prev) || !isNil_default(next)) || !isNil_default(prev) && (!isNil_default(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next));
var fillAttrs = ["fill", "fillOpacity", "background", "texture", "texturePadding", "textureSize", "textureColor"];
var strokeAttrs = ["stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit"];
var areaAttrs = fillAttrs.concat(strokeAttrs);
function getLineSegmentConfigs(items, points, element) {
  var _a;
  if (!items || items.length <= 1) return null;
  const checkAttributes = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? areaAttrs : strokeAttrs, segments2 = [];
  let prevSegmentAttrs = null;
  return items.forEach((item, index) => {
    prevSegmentAttrs && checkAttributes.every((key) => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key)) || (segments2.length && (segments2[segments2.length - 1].endIndex = index), prevSegmentAttrs = item, segments2.push({
      attrs: prevSegmentAttrs,
      startIndex: index
    }));
  }), segments2.length >= 2 ? segments2.map((entry) => {
    const res = parseCollectionMarkAttributes(entry.attrs);
    return res.points = points.slice(entry.startIndex, isNil_default(entry.endIndex) ? points.length : entry.endIndex), res;
  }) : null;
}
function getConnectLineSegmentConfigs(items, points, element) {
  if (!items || items.length <= 1) return null;
  const enableSegments = !!element && element.mark.getSpec().enableSegments;
  let isPrevDefined, curSegment, segments2 = [], point6 = null;
  if (items.forEach((item, index) => {
    point6 = points[index], point6 && false !== point6.defined ? (isPrevDefined || (curSegment = {
      items: [],
      points: []
    }, segments2.push(curSegment)), curSegment.points.push(point6), curSegment.items.push(item), false === isPrevDefined && (curSegment.isConnect = true, curSegment = {
      items: [],
      points: []
    }, segments2.push(curSegment)), isPrevDefined = true) : isPrevDefined = false;
  }), segments2 = segments2.filter((seg) => seg.points.length > 0), segments2.length >= 2) {
    const res = [];
    return segments2.forEach((entry) => {
      if (entry.isConnect) return void res.push({
        points: entry.points,
        isConnect: true
      });
      if (enableSegments) {
        const subSegments = getLineSegmentConfigs(entry.items, entry.points, element);
        if (subSegments) return void subSegments.forEach((subSeg) => {
          res.push(subSeg);
        });
      }
      const seg = parseCollectionMarkAttributes(entry.items[0]);
      seg.points = entry.points, res.push(seg);
    }), res;
  }
  return enableSegments ? getLineSegmentConfigs(items, points, element) : null;
}
function getLinePointsFromSegments(segments2) {
  return segments2 ? segments2.reduce((points, segment) => points.concat(segment.points), []) : null;
}
function parseCollectionMarkAttributes(itemNextAttrs) {
  const result2 = {};
  if (!itemNextAttrs) return result2;
  const skipKeys = ["x", "y", "x1", "y1", "defined", "size", "width", "height", "context"];
  return Object.keys(itemNextAttrs).forEach((key) => {
    skipKeys.includes(key) || (result2[key] = itemNextAttrs[key]);
  }), result2;
}
function removeSegmentAttrs(itemNextAttrs, element) {
  var _a;
  if (!itemNextAttrs || !itemNextAttrs.segments || !itemNextAttrs.segments.length) return itemNextAttrs;
  const segmentKeys = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? ["fillOpacity", "strokeOpacity"] : ["strokeOpacity"], result2 = {};
  return Object.keys(itemNextAttrs).forEach((key) => {
    segmentKeys.includes(key) || (result2[key] = itemNextAttrs[key]);
  }), result2;
}

// node_modules/@visactor/vgrammar-core/es/graph/element.js
var Element = class {
  constructor(mark) {
    this.data = null, this.states = [], this.diffState = DiffState.enter, this.isReserved = false, this.runtimeStatesEncoder = null, this.items = [], this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c, _d;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder2 = isRuntimeState ? Object.assign(Object.assign({}, null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName]), this.runtimeStatesEncoder[stateName]) : null === (_c = this.mark.getSpec().encode) || void 0 === _c ? void 0 : _c[stateName];
      if (!encoder2) return {};
      if (isFunction_default(encoder2)) return encoder2(this.getDatum(), this, stateName, nextStates);
      if (!isRuntimeState && (null === (_d = this.graphicItem.states) || void 0 === _d ? void 0 : _d[stateName])) return this.graphicItem.states[stateName];
      const stateItems = this.items.map((item) => Object.assign({}, item, {
        nextAttrs: {}
      }));
      invokeEncoderToItems(this, stateItems, encoder2, this.mark.parameters());
      const graphicAttributes = this.transformElementItems(stateItems, this.mark.markType);
      return this.graphicItem.states ? this.graphicItem.states[stateName] || (this.graphicItem.states[stateName] = graphicAttributes) : this.graphicItem.states = {
        [stateName]: graphicAttributes
      }, graphicAttributes;
    }, this.mark = mark;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem) return;
    const attrTransforms = this.mark.getAttributeTransforms();
    if (this.graphicItem = this.mark.addGraphicItem(attrTransforms ? transformAttributes(attrTransforms, attributes, this) : attributes, this.groupKey), !this.graphicItem) return;
    const { graphicName } = this.mark.getSpec();
    isString_default(graphicName) ? this.graphicItem.name = graphicName : isFunction_default(graphicName) && (this.graphicItem.name = graphicName(this)), this.graphicItem[BridgeElementKey] = this, attrTransforms && (this.graphicItem.onBeforeAttributeUpdate = (attributes2) => {
      if (!this.mark) return attributes2;
      return transformAttributes(attrTransforms, attributes2, this);
    }), this.clearGraphicAttributes(), this.mark.needAnimate() && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(Object.assign({}, attributes)), this.setFinalGraphicAttributes(Object.assign({}, attributes)));
  }
  updateGraphicItem() {
    var _a;
    if (!this.graphicItem) return;
    this.diffState === DiffState.exit ? this.graphicItem.releaseStatus = "willRelease" : this.graphicItem.releaseStatus = void 0;
    const stateAnimation = null === (_a = this.mark.animate) || void 0 === _a ? void 0 : _a.getAnimationConfigs("state");
    stateAnimation && 0 !== stateAnimation.length && (this.graphicItem.stateAnimateConfig = stateAnimation[0].originConfig);
  }
  getGraphicItem() {
    return this.graphicItem;
  }
  removeGraphicItem() {
    var _a, _b;
    this.graphicItem && (null === (_b = null === (_a = this.graphicItem.animates) || void 0 === _a ? void 0 : _a.forEach) || void 0 === _b || _b.call(_a, (animate) => animate.stop())), this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem[BridgeElementKey] = null, this.graphicItem = null);
  }
  resetGraphicItem() {
    this.graphicItem && (this.graphicItem = null);
  }
  getBounds() {
    var _a;
    return null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getStates() {
    return this.states;
  }
  updateData(groupKey, data, key) {
    var _a;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.data = data;
    const keyGetter = parseField(key);
    return this.items = data.map((datum) => ({
      datum,
      key: keyGetter(datum),
      view: this.mark.view,
      nextAttrs: {}
    })), this.groupKey = groupKey, this.key = this.mark.isCollectionMark() ? groupKey : null === (_a = this.items) || void 0 === _a ? void 0 : _a[0].key, this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.items;
  }
  state(markState, parameters) {
    var _a;
    const isCollectionMark = this.mark.isCollectionMark(), prevStateValues = this.states, newStateValues = array(invokeFunctionType(markState, parameters, this.getDatum(), this)), stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && newStateValues.length && newStateValues.sort(stateSort);
    const isStateChanged = newStateValues.length !== prevStateValues.length || newStateValues.some((newState, index) => newState !== prevStateValues[index]);
    this.states = newStateValues, !isCollectionMark && isStateChanged && this.diffState === DiffState.unChange && (this.diffState = DiffState.update);
  }
  encodeGraphic(attrs) {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
    attrs && Object.assign(graphicAttributes, attrs), this.graphicItem ? (this.graphicItem.clearStates(), this.graphicItem.states = {}, this.graphicItem.stateProxy = null, MARK_OVERLAP_HIDE_KEY in this.graphicItem.attribute && "visible" in graphicAttributes && delete this.graphicItem.attribute[MARK_OVERLAP_HIDE_KEY], this.applyGraphicAttributes(graphicAttributes)) : this.initGraphicItem(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || this.useStates(this.states), this.mark.markType === GrammarMarkType.shape && (this.graphicItem.datum = this.items[0].datum), this.items.forEach((item) => {
      item.nextAttrs = {};
    }), this._setCustomizedShape();
  }
  _setCustomizedShape() {
    var _a;
    if (!this.graphicItem) return;
    const setCustomizedShape = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.setCustomizedShape;
    setCustomizedShape && (this.graphicItem.pathProxy = (attrs) => setCustomizedShape(this.data, attrs, new CustomPath2D()));
  }
  encodeItems(items, encoders, isReentered = false, parameters) {
    const isCollectionMark = this.mark.isCollectionMark(), updateEncoder = encoders[BuiltInEncodeNames.update], enterEncoder = encoders[BuiltInEncodeNames.enter], exitEncoder = encoders[BuiltInEncodeNames.exit], onlyFullEncodeFirst = this.mark.isLargeMode() || isCollectionMark && !this.mark.getSpec().enableSegments;
    this.diffState === DiffState.enter ? (enterEncoder && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.update ? ((isCollectionMark && enterEncoder || isReentered) && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.exit && exitEncoder && (isReentered && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), invokeEncoderToItems(this, items, exitEncoder, parameters, onlyFullEncodeFirst));
  }
  coordinateTransformEncode(items) {
    if (!this.mark.coord || "arc" === this.mark.markType || true === this.mark.disableCoordinateTransform) return;
    const coord = this.mark.coord.output();
    items.forEach((item) => {
      const nextAttrs = item.nextAttrs, convertedPoint = coord.convert(nextAttrs);
      Object.assign(nextAttrs, convertedPoint);
    });
  }
  hasStateAnimation() {
    var _a;
    const stateAnimation = null === (_a = this.mark.animate) || void 0 === _a ? void 0 : _a.getAnimationConfigs("state");
    return stateAnimation && stateAnimation.length > 0;
  }
  clearStates(hasAnimation) {
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : this.hasStateAnimation();
    this.states = [], this.graphicItem && this.graphicItem.clearStates(stateAnimationEnable), this.runtimeStatesEncoder && (this.runtimeStatesEncoder = {});
  }
  _updateRuntimeStates(state, attrs) {
    this.runtimeStatesEncoder || (this.runtimeStatesEncoder = {}), this.runtimeStatesEncoder[state] = attrs;
  }
  hasState(state) {
    return this.states && state && this.states.includes(state);
  }
  updateStates(states) {
    if (!this.graphicItem) return false;
    let nextStates = this.states.slice();
    const encode = this.mark.getSpec().encode;
    let forceClearState = false, hasUpdate = false;
    return Object.keys(states).forEach((stateKey) => {
      var _a;
      if (!stateKey) return;
      const stateValue = states[stateKey];
      if (isObject_default(stateValue) && !isEqual(stateValue, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateKey])) nextStates.includes(stateKey) ? forceClearState = true : nextStates.push(stateKey), this._updateRuntimeStates(stateKey, stateValue), hasUpdate = true;
      else if (stateValue) !nextStates.includes(stateKey) && (null == encode ? void 0 : encode[stateKey]) && (nextStates.push(stateKey), hasUpdate = true);
      else if (nextStates.length) {
        const newNextStates = nextStates.filter((state) => state !== stateKey);
        newNextStates.length !== nextStates.length && (hasUpdate = true, nextStates = newNextStates), this.runtimeStatesEncoder && this.runtimeStatesEncoder[stateKey] && (this.runtimeStatesEncoder[stateKey] = null);
      }
    }), forceClearState && this.graphicItem.clearStates(), !!hasUpdate && (this.useStates(nextStates), true);
  }
  addState(state, attrs) {
    var _a;
    if (!this.graphicItem) return false;
    if (attrs && isString_default(state) && !isEqual(attrs, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[state])) {
      const nextStates2 = this.states.slice();
      return nextStates2.includes(state) ? this.graphicItem.clearStates() : nextStates2.push(state), this._updateRuntimeStates(state, attrs), this.useStates(nextStates2), true;
    }
    const encode = this.mark.getSpec().encode, nextStates = array(state).reduce((nextStates2, stateName) => (stateName && !nextStates2.includes(stateName) && (null == encode ? void 0 : encode[stateName]) && nextStates2.push(stateName), nextStates2), this.states.slice());
    return nextStates.length !== this.states.length && (this.useStates(nextStates), true);
  }
  removeState(state) {
    if (!this.graphicItem) return false;
    const states = array(state);
    if (!states.length) return false;
    const nextStates = this.states.filter((state2) => !states.includes(state2));
    return nextStates.length !== this.states.length && (this.runtimeStatesEncoder && states.forEach((state2) => {
      this.runtimeStatesEncoder[state2] = null;
    }), this.useStates(nextStates), true);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!this.graphicItem) return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this);
    const stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && states.sort(stateSort), this.states = states;
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : this.hasStateAnimation();
    return this.graphicItem.stateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  diffAttributes(graphicAttributes) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes();
    for (const key in graphicAttributes) has_default(finalGraphicAttributes, key) && isEqual(finalGraphicAttributes[key], graphicAttributes[key]) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  transformElementItems(items, markType, computePoints) {
    var _a, _b, _c, _d, _e;
    const item = items[0];
    if (!item.nextAttrs || 0 === Object.keys(item.nextAttrs).length) return {};
    let nextAttrs = item.nextAttrs;
    if (isPointsMarkType(markType) && items && items.length && isNil_default(null === (_a = item.nextAttrs) || void 0 === _a ? void 0 : _a.points) && (true === computePoints || isValidPointsChannel(Object.keys(item.nextAttrs), this.mark.markType))) {
      const markSpec = this.mark.getSpec(), lastPoints = this.getGraphicAttribute("points", false), lastSegments = this.getGraphicAttribute("segments", false), enableSegments = markSpec.enableSegments, connectNullsEncoder = null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[BuiltInEncodeNames.connectNulls], itemNextAttrs = items.map((item2) => item2.nextAttrs), isProgressive = this.mark.isProgressive();
      if (nextAttrs = parseCollectionMarkAttributes(nextAttrs), markType === GrammarMarkType.line || markType === GrammarMarkType.area) {
        const linePoints = getLinePoints(items, true, lastPoints, markType === GrammarMarkType.area);
        if (isProgressive) nextAttrs.segments = (null !== (_e = null === (_d = null === (_c = this.graphicItem) || void 0 === _c ? void 0 : _c.attribute) || void 0 === _d ? void 0 : _d.segments) && void 0 !== _e ? _e : []).concat([{
          points: linePoints
        }]);
        else if (connectNullsEncoder) {
          if (nextAttrs.segments = getConnectLineSegmentConfigs(itemNextAttrs, linePoints, this), nextAttrs.segments && nextAttrs.segments.some((seg) => seg.isConnect)) {
            const connectStyle = invokeEncoder(connectNullsEncoder, this.getDatum(), this, this.mark.parameters());
            connectStyle && nextAttrs.segments.forEach((seg) => {
              seg.isConnect && Object.assign(seg, connectStyle);
            });
          }
          nextAttrs.points = linePoints;
        } else if (enableSegments) {
          const points = linePoints && 0 !== linePoints.length ? linePoints : getLinePointsFromSegments(lastSegments), segments2 = getLineSegmentConfigs(itemNextAttrs, points, this);
          segments2 ? (nextAttrs.segments = segments2, nextAttrs.points = null) : (nextAttrs.segments = null, nextAttrs.points = points), nextAttrs = removeSegmentAttrs(nextAttrs, this);
        } else nextAttrs.points = linePoints, nextAttrs.segments = null;
      } else markType === GrammarMarkType.largeRects ? nextAttrs.points = getLargeRectsPoints(items, true, lastPoints) : markType === GrammarMarkType.largeSymbols && (nextAttrs.points = getLargeSymbolsPoints(items, true, lastPoints));
    }
    return nextAttrs;
  }
  applyGraphicAttributes(graphicAttributes) {
    var _a, _b, _c;
    if (!isEmpty_default(graphicAttributes)) if (this.mark.needAnimate()) {
      const nextGraphicAttributes = this.diffAttributes(graphicAttributes), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes()) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes()) && void 0 !== _b ? _b : {};
      Object.keys(nextGraphicAttributes).forEach((channel) => {
        prevGraphicAttributes[channel] = this.getGraphicAttribute(channel), finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
      }), this.setNextGraphicAttributes(nextGraphicAttributes), this.setPrevGraphicAttributes(prevGraphicAttributes), this.setFinalGraphicAttributes(finalGraphicAttributes);
      const currentAnimators = null === (_c = this.mark.animate) || void 0 === _c ? void 0 : _c.getElementAnimators(this).filter((animator) => {
        var _a2;
        return !(null === (_a2 = animator.animationOptions.timeline.controlOptions) || void 0 === _a2 ? void 0 : _a2.ignoreLoopFinalAttributes) || !animator.animationOptions.timeline.loop;
      }), animateGraphicAttributes = (currentAnimators || []).reduce((attributes, animator) => Object.assign(attributes, animator.getEndAttributes()), {}), currentGraphicAttributes = Object.assign({}, animateGraphicAttributes, finalGraphicAttributes);
      this.graphicItem.setAttributes(currentGraphicAttributes);
    } else this.graphicItem.setAttributes(graphicAttributes);
  }
  getGraphicAttribute(channel, prev = false) {
    var _a;
    if (!this.graphicItem) return;
    if (prev) {
      let value;
      const prevGraphicAttributes = this.getPrevGraphicAttributes();
      if (!isNil_default(value = get_default(prevGraphicAttributes, channel))) return value;
    }
    const trans = this.mark.getAttributeTransforms();
    let getKey = [channel];
    if (trans && trans.length) {
      const channelTransform = trans.find((entry) => entry.storedAttrs && entry.channels.includes(channel));
      channelTransform && (getKey = [channelTransform.storedAttrs, channel]);
    }
    return get_default(null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, getKey);
  }
  setGraphicAttribute(channel, value, final = true) {
    if (!this.graphicItem) return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    final && finalGraphicAttributes && (finalGraphicAttributes[channel] = value), prevGraphicAttributes && !has_default(prevGraphicAttributes, channel) && (prevGraphicAttributes[channel] = this.graphicItem.attribute[channel]), this.graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true) {
    if (!this.graphicItem) return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    Object.keys(attributes).forEach((key) => {
      finalGraphicAttributes && final && (finalGraphicAttributes[key] = attributes[key]), prevGraphicAttributes && !has_default(prevGraphicAttributes, key) && (prevGraphicAttributes[key] = this.graphicItem.attribute[key]);
    }), this.graphicItem.setAttributes(attributes);
  }
  getFinalGraphicAttributes() {
    return this.graphicItem.finalAttrs;
  }
  setFinalGraphicAttributes(attributes) {
    this.graphicItem.finalAttrs = attributes;
  }
  getPrevGraphicAttributes() {
    return this.graphicItem.prevAttrs;
  }
  setPrevGraphicAttributes(attributes) {
    this.graphicItem.prevAttrs = attributes;
  }
  getNextGraphicAttributes() {
    return this.graphicItem.nextAttrs;
  }
  getFinalAnimationAttribute(channel) {
    var _a, _b;
    return null !== (_b = null === (_a = this.getFinalGraphicAttributes()) || void 0 === _a ? void 0 : _a[channel]) && void 0 !== _b ? _b : this.getGraphicAttribute(channel);
  }
  getFinalAnimationAttributes() {
    var _a;
    return null !== (_a = this.getFinalGraphicAttributes()) && void 0 !== _a ? _a : this.graphicItem.attribute;
  }
  setNextGraphicAttributes(attributes) {
    this.graphicItem.nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.graphicItem && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null));
  }
  clearGraphicAttributes() {
    this.graphicItem && (this.graphicItem.prevAttrs && this.setPrevGraphicAttributes(null), this.graphicItem.nextAttrs && this.setNextGraphicAttributes(null), this.graphicItem.finalAttrs && this.setFinalGraphicAttributes(null));
  }
  remove() {
    this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem = null);
  }
  release() {
    this.removeGraphicItem(), this.mark = null, this.data = null, this.items = null;
  }
  getItemAttribute(channel) {
    var _a, _b;
    if (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) return this.mark.isCollectionMark() ? isNil_default(channel) ? this.items.map((item) => item.nextAttrs) : this.items.map((item) => {
      var _a2;
      return null === (_a2 = item.nextAttrs) || void 0 === _a2 ? void 0 : _a2[channel];
    }) : isNil_default(channel) ? this.items[0].nextAttrs : null === (_b = this.items[0].nextAttrs) || void 0 === _b ? void 0 : _b[channel];
  }
  setItemAttributes(attributes) {
    var _a;
    (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) && (this.mark.isCollectionMark() ? isArray_default(attributes) && this.items.forEach((item, index) => {
      Object.assign(item.nextAttrs, attributes[index]);
    }) : Object.assign(this.items[0].nextAttrs, attributes));
  }
  getItem() {
    var _a, _b;
    return this.mark && this.mark.isCollectionMark() ? null !== (_a = this.items) && void 0 !== _a ? _a : [] : null === (_b = this.items) || void 0 === _b ? void 0 : _b[0];
  }
  getDatum() {
    var _a, _b;
    return this.mark && this.mark.isCollectionMark() ? null !== (_a = this.data) && void 0 !== _a ? _a : [] : null === (_b = this.data) || void 0 === _b ? void 0 : _b[0];
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/base.js
var BaseInteraction = class {
  constructor(view, options) {
    this.references = /* @__PURE__ */ new Map(), this.view = view, this.depend(null == options ? void 0 : options.dependency);
  }
  getStartState() {
    return null;
  }
  depend(grammar) {
    this.references.clear(), array(grammar).map((grammar2) => isString_default(grammar2) ? this.view.getGrammarById(grammar2) : grammar2).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + 1);
    });
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  bind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && "none" !== evtType && this.view.addEventListener(evtType, evt.handler);
      }) : "none" !== evt.type && this.view.addEventListener(evt.type, evt.handler));
    });
  }
  unbind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && "none" !== evtType && this.view.removeEventListener(evtType, evt.handler);
      }) : "none" !== evt.type && this.view.removeEventListener(evt.type, evt.handler));
    });
  }
  start(element) {
  }
  reset(element) {
  }
  dispatchEvent(type, params2) {
    this.view.emit(`${this.type}:${type}`, params2), "start" === type && this.options.onStart ? this.options.onStart(params2) : "reset" === type && this.options.onReset ? this.options.onReset(params2) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params2) : "end" === type && this.options.onEnd && this.options.onEnd(params2);
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-active.js
var ElementActive = class _ElementActive extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActive.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      this.reset(e.element);
    }, this.options = Object.assign({}, _ElementActive.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  getStartState() {
    return this.options.state;
  }
  start(element) {
    element && this._marks && this._marks.includes(element.mark) && (element.addState(this.options.state), this._prevActiveElement = element);
  }
  reset(element) {
    const el = null != element ? element : this._prevActiveElement;
    el && this._marks && this._marks.includes(el.mark) && el.removeState(this.options.state);
  }
};
ElementActive.type = "element-active", ElementActive.defaultOptions = {
  state: InteractionStateEnum.active,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/utils.js
var generateFilterValue = (options) => options.filterField ? (el) => {
  var _a;
  return null === (_a = el.getDatum()) || void 0 === _a ? void 0 : _a[options.filterField];
} : (el) => el[options.filterType];
var groupMarksByState = (marks, states) => {
  if (!states || !marks) return null;
  const res = {};
  return marks.forEach((mark) => {
    const markSpec = mark && mark.getSpec(), encode = markSpec && markSpec.encode;
    encode && states.forEach((state) => {
      state && encode[state] && (res[state] || (res[state] = []), res[state].push(mark));
    });
  }), res;
};
var parseTriggerOffOfSelect = (triggerOff) => {
  const triggerOffArray = array(triggerOff), resetType = [], eventNames = [];
  return triggerOffArray.forEach((off) => {
    "empty" === off ? resetType.push("view") : isString_default(off) && "none" !== off ? off.includes("view:") ? (eventNames.push(off.replace("view:", "")), resetType.push("view")) : (eventNames.push(off), resetType.push("self")) : isNumber_default(off) && resetType.push("timeout");
  }), {
    eventNames,
    resetType
  };
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-select.js
var ElementSelect = class _ElementSelect extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementSelect.type, this._resetType = [], this.resetAll = () => {
      const { state, reverseState } = this.options;
      this._statedElements && this._statedElements.length && (this.clearAllStates(state, reverseState), this.dispatchEvent("reset", {
        elements: this._statedElements,
        options: this.options
      }), this._statedElements = []);
    }, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      if (!this._statedElements || !this._statedElements.length) return;
      const element = e.element, hasActiveElement = element && this._marks && this._marks.includes(element.mark);
      (this._resetType.includes("view") && !hasActiveElement || this._resetType.includes("self") && hasActiveElement) && this.resetAll();
    }, this.options = Object.assign({}, _ElementSelect.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.state, this.options.reverseState]);
  }
  getStartState() {
    return this.options.state;
  }
  getEvents() {
    const triggerOff = this.options.triggerOff, trigger = this.options.trigger, events = [{
      type: trigger,
      handler: this.handleStart
    }], { eventNames, resetType } = parseTriggerOffOfSelect(triggerOff);
    return eventNames.forEach((evt) => {
      evt && (isArray_default(trigger) ? !trigger.includes(evt) : evt !== trigger) && events.push({
        type: evt,
        handler: this.handleReset
      });
    }), this._resetType = resetType, events;
  }
  start(element) {
    const { state, reverseState, isMultiple } = this.options;
    if (element && this._marks && this._marks.includes(element.mark)) if (element.hasState(state)) {
      if (this._resetType.includes("self")) {
        const newStatedElements = this._statedElements && this._statedElements.filter((el) => el !== element);
        newStatedElements && newStatedElements.length ? this._statedElements = this.updateStates(newStatedElements, this._statedElements, state, reverseState) : this.resetAll();
      }
    } else this._timer && clearTimeout(this._timer), element.addState(state), this._statedElements = this.updateStates(isMultiple && this._statedElements ? [...this._statedElements, element] : [element], this._statedElements, state, reverseState), this.dispatchEvent("start", {
      elements: this._statedElements,
      options: this.options
    }), this._resetType.includes("timeout") && (this._timer = setTimeout(() => {
      this.resetAll();
    }, this.options.triggerOff));
    else this._resetType.includes("view") && this._statedElements && this._statedElements.length && this.resetAll();
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.state, this.options.reverseState]) : this.resetAll();
  }
};
ElementSelect.type = "element-select", ElementSelect.defaultOptions = {
  state: InteractionStateEnum.selected,
  trigger: "click"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight.js
var ElementHighlight = class _ElementHighlight extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlight.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      if (!this._statedElements || !this._statedElements.length) return;
      const element = e.element;
      if (element) {
        const hasActiveElement = this._marks && this._marks.includes(element.mark);
        "view" !== this._resetType || hasActiveElement ? "self" === this._resetType && hasActiveElement && this.resetAll() : this.resetAll();
      }
    }, this.options = Object.assign({}, _ElementHighlight.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.highlightState, this.options.blurState]);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    const triggerOff = this.options.triggerOff, events = [{
      type: this.options.trigger,
      handler: this.handleStart
    }];
    let eventName = triggerOff;
    return isString_default(triggerOff) && triggerOff.includes("view:") ? (eventName = triggerOff.replace("view:", ""), this._resetType = "view") : this._resetType = "self", events.push({
      type: eventName,
      handler: this.handleReset
    }), events;
  }
  resetAll() {
    const { highlightState, blurState } = this.options;
    this._lastElement && (this.clearAllStates(highlightState, blurState), this.dispatchEvent("reset", {
      elements: [this._lastElement],
      options: this.options
    }), this._lastElement = null, this._statedElements = null);
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const { highlightState, blurState } = this.options;
      if (this._lastElement === element) return;
      this._statedElements = this.updateStates([element], this._statedElements, highlightState, blurState), this._lastElement = element, this.dispatchEvent("start", {
        elements: [element],
        options: this.options
      });
    } else this._lastElement && "view" === this._resetType && this.resetAll();
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.highlightState, this.options.blurState]) : this.resetAll();
  }
};
ElementHighlight.type = "element-highlight", ElementHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-key.js
var ElementHighlightByKey = class _ElementHighlightByKey extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByKey.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      e.element && this._marks && this._marks.includes(e.element.mark) && this.resetAll();
    }, this.options = Object.assign({}, _ElementHighlightByKey.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  resetAll() {
    const states = [this.options.highlightState, this.options.blurState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const highlightKey = element.key;
      if (isNil_default(highlightKey)) return;
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.key === highlightKey ? el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          }) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
    }
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.highlightState, this.options.blurState]) : this.resetAll();
  }
};
ElementHighlightByKey.type = "element-highlight-by-key", ElementHighlightByKey.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-group.js
var ElementHighlightByGroup = class _ElementHighlightByGroup extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByGroup.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      const element = e.element;
      element && this._marks && this._marks.includes(element.mark) && this.resetAll();
    }, this.options = Object.assign({}, _ElementHighlightByGroup.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  resetAll() {
    const states = [this.options.highlightState, this.options.blurState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const highlightKey = element.groupKey;
      if (isNil_default(highlightKey)) return;
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.groupKey === highlightKey ? el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          }) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
    }
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.highlightState, this.options.blurState]) : this.resetAll();
  }
};
ElementHighlightByGroup.type = "element-highlight-by-group", ElementHighlightByGroup.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-active-by-legend.js
var ElementActiveByLegend = class _ElementActiveByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActiveByLegend.type, this.handleStart = (e) => {
      var _a, _b;
      this.start(null === (_b = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id);
    }, this.handleReset = (e) => {
      this.resetAll();
    }, this.options = Object.assign({}, _ElementActiveByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
  getStartState() {
    return this.options.state;
  }
  start(element) {
    const itemKey = element;
    if (isNil_default(itemKey)) return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.addState(this.options.state) : el.removeState(this.options.state);
      });
    });
  }
  resetAll() {
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(this.options.state);
      });
    });
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState(this.options.state) : this.resetAll();
  }
};
ElementActiveByLegend.type = "element-active-by-legend", ElementActiveByLegend.defaultOptions = {
  state: InteractionStateEnum.active,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-legend.js
var ElementHighlightByLegend = class _ElementHighlightByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByLegend.type, this.handleStart = (e, element) => {
      var _a, _b;
      this.start(null === (_b = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id);
    }, this.handleReset = (e) => {
      this.resetAll();
    }, this.options = Object.assign({}, _ElementHighlightByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
  start(itemKey) {
    if (isNil_default(itemKey)) return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.updateStates({
          [this.options.blurState]: false,
          [this.options.highlightState]: true
        }) : el.updateStates({
          [this.options.blurState]: true,
          [this.options.highlightState]: false
        });
      });
    });
  }
  resetAll() {
    const states = [this.options.highlightState, this.options.blurState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.highlightState, this.options.blurState]) : this.resetAll();
  }
};
ElementHighlightByLegend.type = "element-highlight-by-legend", ElementHighlightByLegend.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-name.js
var ElementHighlightByName = class _ElementHighlightByName extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByName.type, this.handleStart = (e, element) => {
      if (this.options.shouldStart ? this.options.shouldStart(e) : this._filterByName(e)) {
        const itemKey = this._parseTargetKey(e, element);
        this.start(itemKey);
      }
    }, this.handleReset = (e) => {
      (this.options.shouldReset ? this.options.shouldReset(e) : this._filterByName(e)) && this.resetAll();
    }, this.options = Object.assign({}, _ElementHighlightByName.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  _filterByName(e) {
    var _a;
    const names = array(this.options.graphicName);
    return (null === (_a = null == e ? void 0 : e.target) || void 0 === _a ? void 0 : _a.name) && names.includes(e.target.name);
  }
  _parseTargetKey(e, element) {
    return this.options.parseData ? this.options.parseData(e) : "text" === e.target.type ? e.target.attribute.text : null;
  }
  start(itemKey) {
    if (isNil_default(itemKey)) return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.updateStates({
          [this.options.blurState]: false,
          [this.options.highlightState]: true
        }) : el.updateStates({
          [this.options.blurState]: true,
          [this.options.highlightState]: false
        });
      });
    });
  }
  resetAll() {
    const states = [this.options.blurState, this.options.highlightState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  reset(element) {
    element ? this._marks && this._marks.includes(element.mark) && element.removeState([this.options.highlightState, this.options.blurState]) : this.resetAll();
  }
};
ElementHighlightByName.type = "element-highlight-by-name", ElementHighlightByName.defaultOptions = {
  trigger: "pointerover",
  triggerOff: "pointerout",
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-graphic-name.js
var ElementHighlightByGraphicName = class _ElementHighlightByGraphicName extends ElementHighlight {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByGraphicName.type, this.handleStart = (e) => {
      if (e && e.element && this._marks.includes(e.element.mark)) {
        if (this.options.shouldStart ? this.options.shouldStart(e) : this._filterByName(e)) {
          const itemKey = this._parseTargetKey(e, e.element);
          this.start(itemKey);
        }
      }
    }, this.handleReset = (e) => {
      e && e.element && this._marks.includes(e.element.mark) && this.reset();
    }, this.options = Object.assign({}, _ElementHighlightByGraphicName.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  _filterByName(e) {
    var _a;
    return !!(null === (_a = null == e ? void 0 : e.target) || void 0 === _a ? void 0 : _a.name);
  }
  _parseTargetKey(e, element) {
    return e.target.name;
  }
  start(itemKey) {
    isNil_default(itemKey) || this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        var _a;
        (null === (_a = el.getGraphicItem()) || void 0 === _a ? void 0 : _a.name) === itemKey ? el.updateStates({
          [this.options.blurState]: false,
          [this.options.highlightState]: true
        }) : el.updateStates({
          [this.options.blurState]: true,
          [this.options.highlightState]: false
        });
      });
    });
  }
  reset() {
    const states = [this.options.blurState, this.options.highlightState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
};
ElementHighlightByGraphicName.type = "element-highlight-by-graphic-name";

// node_modules/@visactor/vgrammar-core/es/interactions/element-select-by-graphic-name.js
var ElementSelectByGraphicName = class _ElementSelectByGraphicName extends ElementSelect {
  constructor() {
    super(...arguments), this.type = _ElementSelectByGraphicName.type;
  }
  start(element) {
    var _a;
    const name = null === (_a = element.getGraphicItem()) || void 0 === _a ? void 0 : _a.name;
    name && this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        var _a2;
        (null === (_a2 = el.getGraphicItem()) || void 0 === _a2 ? void 0 : _a2.name) === name && super.start(el);
      });
    });
  }
};
ElementSelectByGraphicName.type = "element-select-by-graphic-name";

// node_modules/@visactor/vgrammar-core/es/interactions/brush-base.js
var BrushBase = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.handleAfterDraw = () => {
      var _a, _b, _c, _d;
      const stage = this.view.renderer.stage();
      if (this._brushComp || !stage) return;
      const viewBox = this.view.getViewBox();
      this._brushComp = new Brush({
        interactiveRange: null !== (_a = this.options.interactiveRange) && void 0 !== _a ? _a : {
          minX: viewBox.x1,
          maxX: viewBox.x2,
          minY: viewBox.y1,
          maxY: viewBox.y2
        },
        xRange: null !== (_b = this.options.xRange) && void 0 !== _b ? _b : [viewBox.x1, viewBox.x2],
        yRange: null !== (_c = this.options.yRange) && void 0 !== _c ? _c : [viewBox.y1, viewBox.y2],
        brushMode: null !== (_d = this.options.brushMode) && void 0 !== _d ? _d : "single",
        brushType: this.options.brushType,
        brushStyle: this.options.brushStyle,
        brushMoved: this.options.brushMoved,
        removeOnClick: this.options.removeOnClick,
        sizeThreshold: this.options.sizeThreshold,
        delayType: this.options.delayType,
        delayTime: this.options.delayTime
      }), this._brushComp.addEventListener(IOperateType.brushClear, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moveEnd, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawEnd, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawStart, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moveStart, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawing, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moving, this.handleBrushUpdate), stage.defaultLayer.appendChild(this._brushComp);
    }, this.options = options, this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: HOOK_EVENT.BEFORE_DO_RENDER,
      handler: this.handleAfterDraw
    }];
  }
  isPolygonBrushContainGraphicItem(brushMask, graphicItem, offset) {
    const points = brushMask.attribute.points, { a: a3, b, c: c3, d, e, f } = brushMask.globalTransMatrix, { x: dx = 0, y: dy = 0 } = null != offset ? offset : {}, pointsCoord = points.map((p) => ({
      x: a3 * p.x + c3 * p.y + e + dx,
      y: b * p.x + d * p.y + f + dy
    })), globalAABBBoundsOffset = brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy), x = graphicItem.globalTransMatrix.e, y = graphicItem.globalTransMatrix.f;
    if ("symbol" === graphicItem.type || "circle" === graphicItem.type) return globalAABBBoundsOffset.contains(x, y) && polygonContainPoint(pointsCoord, x, y);
    if ("rect" === graphicItem.type) {
      const { width = 0, height = 0 } = null == graphicItem ? void 0 : graphicItem.attribute;
      return polygonIntersectPolygon(pointsCoord, [{
        x,
        y
      }, {
        x: x + width,
        y
      }, {
        x: x + width,
        y: y + height
      }, {
        x,
        y: y + height
      }]);
    }
    return brushMask.globalAABBBounds.intersects(graphicItem.globalAABBBounds);
  }
  isRectBrushContainGraphicItem(brushMask, graphicItem, offset) {
    const { x: dx = 0, y: dy = 0 } = null != offset ? offset : {}, globalAABBBoundsOffset = brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy), x = graphicItem.globalTransMatrix.e, y = graphicItem.globalTransMatrix.f;
    if ("symbol" === graphicItem.type || "circle" === graphicItem.type) return globalAABBBoundsOffset.contains(x, y);
    if ("rect" === graphicItem.type) {
      const { width = 0, height = 0 } = graphicItem.attribute;
      return isRectIntersect(globalAABBBoundsOffset, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      }, false);
    }
    return brushMask.globalAABBBounds.intersects(graphicItem.globalAABBBounds);
  }
  isBrushContainGraphicItem(brushMask, graphicItem, offset) {
    var _a;
    return !(!((null == brushMask ? void 0 : brushMask.globalTransMatrix) && brushMask.globalAABBBounds && !brushMask.globalAABBBounds.empty() && graphicItem && (null === (_a = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _a ? void 0 : _a.points)) || brushMask.attribute.points.length <= 1) && ("polygon" === this.options.brushType ? this.isPolygonBrushContainGraphicItem(brushMask, graphicItem, offset) : this.isRectBrushContainGraphicItem(brushMask, graphicItem, offset));
  }
  unbind() {
    super.unbind();
    const stage = this.view.renderer.stage();
    this._brushComp && stage && (stage.defaultLayer.removeChild(this._brushComp), this._brushComp.releaseBrushEvents(), this._brushComp.release(), this._brushComp = null);
  }
  _dispatchEvent(event, activeElements) {
    const params2 = {
      operateType: event.type,
      operateMask: event.detail.operateMask,
      activeElements
    };
    event.type === IOperateType.drawStart || event.type === IOperateType.moveStart ? this.dispatchEvent("start", params2) : event.type === IOperateType.drawing || event.type === IOperateType.moving ? this.dispatchEvent("update", params2) : event.type === IOperateType.drawEnd || event.type === IOperateType.moveEnd ? this.dispatchEvent("end", params2) : this.dispatchEvent("reset", params2);
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-highlight.js
var BrushHighlight = class _BrushHighlight extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushHighlight.defaultOptions, option)), this.type = _BrushHighlight.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      if (event.type === IOperateType.brushClear) {
        const states = [this.options.blurState, this.options.highlightState];
        this._marks.forEach((mark) => {
          mark.elements.forEach((el) => {
            el.removeState(states);
          });
        });
      } else this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) ? (elements.push(el), el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          })) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
      this._dispatchEvent(event, elements);
    };
  }
  getStartState() {
    return this.options.highlightState;
  }
};
BrushHighlight.type = "brush-highlight", BrushHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-active.js
var BrushActive = class _BrushActive extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushActive.defaultOptions, option)), this.type = _BrushActive.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) ? (elements.push(el), el.addState(this.options.state)) : el.removeState(this.options.state);
        });
      }), this._dispatchEvent(event, elements);
    };
  }
  getStartState() {
    return this.options.state;
  }
};
BrushActive.type = "brush-active", BrushActive.defaultOptions = {
  state: InteractionStateEnum.active
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-filter.js
var BrushFilter = class _BrushFilter extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushFilter.defaultOptions, option)), this.type = _BrushFilter.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      let filterValue = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) && (elements.push(el), filterValue = filterValue.concat(array(el.getDatum())));
        });
      }), this._data && (filterValue = Array.from(new Set(filterValue)), this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter())), this._dispatchEvent(event, elements);
    }, this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._data) return [];
    const transform30 = this.options.target.transform;
    return this._filterData(this._data, null, DataFilterRank.brush, null, void 0, (data, filterValue) => {
      const nextData = filterValue || data;
      return transform30 ? transform30(data, filterValue) : nextData;
    }), super.getEvents();
  }
};
BrushFilter.type = "brush-filter", BrushFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/interactions/drill-down.js
var DrillDown = class _DrillDown extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _DrillDown.defaultOptions, option)), this.type = _DrillDown.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      let filterValue = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) && (elements.push(el), filterValue = filterValue.concat(array(el.getDatum())));
        });
      }), this._data && (filterValue = Array.from(new Set(filterValue)), this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter())), this._dispatchEvent(event, elements);
    }, this.handleTrigger = (event) => {
      const element = event.element;
      if (element && this._marks && this._marks.includes(element.mark)) {
        const filterValue = array(element.getDatum());
        this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter());
      }
    }, this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._data) return [];
    const transform30 = this.options.target.transform;
    return this._filterData(this._data, null, DataFilterRank.drillDown, null, void 0, (data, filterValue) => {
      const nextData = filterValue || data;
      return transform30 ? transform30(data, filterValue) : nextData;
    }), this.options.brush ? super.getEvents() : [{
      type: this.options.trigger,
      handler: this.handleTrigger
    }];
  }
};
DrillDown.type = "drill-down", DrillDown.defaultOptions = {
  brush: false,
  trigger: "click"
};

// node_modules/@visactor/vgrammar-core/es/interactions/filter.js
var Filter = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), options.target && (this._data = isString_default(options.target.data) ? view.getDataById(options.target.data) : options.target.data);
  }
};
Filter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/interactions/roll-up.js
var RollUp = class _RollUp extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _RollUp.type, this._isToggle = false, this.handleStart = (event) => {
      var _a, _b;
      const element = event.element;
      if (element && this._marks && this._marks.includes(element.mark)) {
        const filterValue = null === (_b = null === (_a = event.element) || void 0 === _a ? void 0 : _a.getDatum) || void 0 === _b ? void 0 : _b.call(_a);
        filterValue === this._filterData || isArray_default(filterValue) && isArray_default(this._filterValue) && filterValue.length === this._filterValue.length && filterValue.every((datum) => !this._filterValue.includes(datum)) ? this._isToggle && (this._filterValue = null, this.handleFilter(event)) : this.handleFilter(event);
      }
    }, this.handleReset = (event) => {
      this._filterValue && (this._filterValue = null, this.handleFilter(event));
    }, this.options = Object.assign({}, _RollUp.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    if (!this._data) return [];
    const transform30 = this.options.target.transform;
    this._filterData(this._data, null, DataFilterRank.rollUp, (event) => {
      var _a, _b;
      return null === (_b = null === (_a = null == event ? void 0 : event.element) || void 0 === _a ? void 0 : _a.getDatum) || void 0 === _b ? void 0 : _b.call(_a);
    }, void 0, (data, filterValue) => transform30(data, filterValue));
    const events = [{
      type: this.options.trigger,
      handler: this.handleStart
    }], eventName = "empty" === this.options.triggerOff ? this.options.trigger : this.options.triggerOff.includes("view:") ? this.options.triggerOff.replace("view:", "") : this.options.triggerOff;
    return eventName !== this.options.trigger ? (events.push({
      type: eventName,
      handler: this.handleReset
    }), this._isToggle = false) : this._isToggle = true, events;
  }
};
RollUp.type = "roll-up", RollUp.defaultOptions = {
  trigger: "click",
  triggerOff: "empty"
};

// node_modules/@visactor/vgrammar-core/es/interactions/base-tooltip.js
var generateTooltipAttributes = (point6, title3, content, bounds, theme2, addition) => {
  var _a;
  const tooltipTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.tooltip;
  return merge({}, tooltipTheme, {
    visible: true,
    pointerX: point6.x,
    pointerY: point6.y,
    title: title3,
    content,
    parentBounds: bounds
  }, null != addition ? addition : {});
};
var BaseTooltip = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this._marks = view.getMarksBySelector(options.selector);
  }
  bind() {
    super.bind();
    const stage = this.view.renderer.stage();
    !this._tooltipComponent && stage && (this._tooltipComponent = new Tooltip({}), stage.defaultLayer.appendChild(this._tooltipComponent));
  }
  unbind() {
    super.unbind();
    const stage = this.view.renderer.stage();
    this._tooltipComponent && stage && (stage.defaultLayer.removeChild(this._tooltipComponent), this._tooltipComponent.release(), this._tooltipComponent = null);
  }
  _computeTooltipRow(row, datum) {
    let key, value, symbol, visible = invokeFunctionType(row.visible, this.parameters(), datum);
    if (visible = !!isNil_default(visible) || !!visible, isFieldEncode(row.key)) {
      key = field(row.key.field)(datum);
    } else key = invokeFunctionType(row.key, this.parameters(), datum);
    if (key = isNil_default(key) ? void 0 : isObjectLike_default(key) ? key : {
      text: key
    }, isFieldEncode(row.value)) {
      value = field(row.value.field)(datum);
    } else value = invokeFunctionType(row.value, this.parameters(), datum);
    if (value = isNil_default(value) ? void 0 : isObjectLike_default(value) ? value : {
      text: value
    }, isFieldEncode(row.symbol)) {
      symbol = field(row.symbol.field)(datum);
    } else symbol = invokeFunctionType(row.symbol, this.parameters(), datum);
    return symbol = isNil_default(symbol) ? void 0 : isObjectLike_default(symbol) ? symbol : {
      symbolType: symbol
    }, {
      visible,
      key,
      value,
      shape: symbol
    };
  }
  _computeTitleContent(datum) {
    const title3 = isValid_default(this.options.title) ? isFunction_default(this.options.title) ? this.options.title.call(null, datum, null, {}) : this._computeTooltipRow(isString_default(this.options.title) ? {
      value: this.options.title
    } : this.options.title, datum) : void 0, content = isValid_default(this.options.content) ? isFunction_default(this.options.content) ? array(this.options.content.call(null, datum, null, {})) : array(datum).reduce((content2, datumRow) => content2.concat(array(this.options.content).map((row) => this._computeTooltipRow(row, datumRow))), []) : void 0;
    return {
      title: isArray_default(title3) ? title3[0] : title3,
      content
    };
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/tooltip.js
var Tooltip2 = class _Tooltip extends BaseTooltip {
  constructor(view, options) {
    super(view, options), this.type = _Tooltip.type, this.handleTooltipShow = throttle_default((event) => {
      if (!this._tooltipComponent) return;
      const element = event.element;
      if (!this._marks.includes(null == element ? void 0 : element.mark)) return void this._tooltipComponent.hideAll();
      this._tooltipComponent.showAll();
      const groupGraphicItem = this.view.rootMark.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      };
      if (groupGraphicItem.globalTransMatrix.transformPoint(event.canvas, point6), element === this._lastElement) return void this._tooltipComponent.setAttributes({
        pointerX: point6.x,
        pointerY: point6.y
      });
      const boundsStart = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: 0,
        y: 0
      }, boundsStart);
      const boundsEnd = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: this.view.getSignalById("width").getValue(),
        y: this.view.getSignalById("height").getValue()
      }, boundsEnd);
      const bounds = new AABBBounds().set(boundsStart.x, boundsStart.y, boundsEnd.x, boundsEnd.y), { title: title3, content } = this._computeTitleContent(element.getDatum()), theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), element.getDatum()), attributes = generateTooltipAttributes(point6, title3, content, bounds, theme2, addition);
      this._tooltipComponent.setAttributes(attributes);
    }, 10), this.handleTooltipHide = (event) => {
      this._tooltipComponent && this._tooltipComponent.hideAll();
    }, this.options = Object.assign({}, _Tooltip.defaultOptions, options);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleTooltipShow
    }, {
      type: this.options.triggerOff,
      handler: this.handleTooltipHide
    }];
  }
};
Tooltip2.type = "tooltip", Tooltip2.defaultOptions = {
  trigger: "pointermove",
  triggerOff: "pointerleave"
};

// node_modules/@visactor/vgrammar-core/es/interactions/dimension-tooltip.js
var isEqualTooltipDatum = (current, previous) => {
  const currentDatum = array(current), previousDatum = array(previous);
  return currentDatum.length === previousDatum.length && (currentDatum.every((datum) => previousDatum.includes(datum)) && previousDatum.every((datum) => currentDatum.includes(datum)));
};
var computeTooltipFilterValue = (point6, scale4, type, groupSize, tooltipCenter) => {
  if ("x" === type) return scale4.invert(point6.x);
  if ("y" === type) return scale4.invert(point6.y);
  if ("radius" === type) {
    const center2 = null != tooltipCenter ? tooltipCenter : {
      x: groupSize.width / 2,
      y: groupSize.height / 2
    }, radius = Math.sqrt((center2.x - point6.x) ** 2 + (center2.y - point6.y) ** 2);
    return scale4.invert(radius);
  }
  if ("angle" === type) {
    const center2 = null != tooltipCenter ? tooltipCenter : {
      x: groupSize.width / 2,
      y: groupSize.height / 2
    }, angle2 = getAngleByPoint(center2, point6);
    return scale4.invert(angle2 < 0 ? angle2 + 2 * Math.PI : angle2);
  }
  return scale4.invert(point6.x);
};
var DimensionTooltip = class _DimensionTooltip extends BaseTooltip {
  constructor(view, options) {
    var _a, _b, _c;
    super(view, options), this.type = _DimensionTooltip.type, this._avoidMarks = [], this._tooltipDataFilter = null, this.handleTooltipShow = throttle_default((event) => {
      var _a2, _b2, _c2;
      if (!this._tooltipComponent) return;
      const scale4 = (isString_default(this.options.scale) ? this.view.getScaleById(this.options.scale) : this.options.scale).getScale(), groupGraphicItem = this._container.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint(event.canvas, point6);
      const groupSize = {
        width: groupGraphicItem.attribute.width,
        height: groupGraphicItem.attribute.height
      };
      if (point6.x < 0 || point6.x > groupGraphicItem.attribute.width || point6.y < 0 || point6.y > groupGraphicItem.attribute.height) return void this._tooltipComponent.hideAll();
      const eventTargetMark = null === (_b2 = null === (_a2 = event.target) || void 0 === _a2 ? void 0 : _a2[BridgeElementKey]) || void 0 === _b2 ? void 0 : _b2.mark;
      if (this._avoidMarks.includes(eventTargetMark)) return void this._tooltipComponent.hideAll();
      const target = null === (_c2 = this.options.target) || void 0 === _c2 ? void 0 : _c2.data, lastDataGrammar = target ? isString_default(target) ? this.view.getDataById(target) : target : null, data = lastDataGrammar ? lastDataGrammar.getValue() : [], filterValue = computeTooltipFilterValue(point6, scale4, this.options.tooltipType, groupSize, this.options.center), tooltipDatum = this._tooltipDataFilter ? data.filter((datum) => this._tooltipDataFilter(datum, filterValue)) : [];
      if (this._tooltipComponent.showAll(), isEqualTooltipDatum(tooltipDatum, this._lastDatum)) return void this._tooltipComponent.setAttributes({
        pointerX: point6.x,
        pointerY: point6.y
      });
      this._lastDatum = tooltipDatum;
      const boundsStart = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: 0,
        y: 0
      }, boundsStart);
      const boundsEnd = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: this.view.getSignalById("width").getValue(),
        y: this.view.getSignalById("height").getValue()
      }, boundsEnd);
      const bounds = new AABBBounds().set(boundsStart.x, boundsStart.y, boundsEnd.x, boundsEnd.y), { title: title3, content } = this._computeTitleContent(tooltipDatum), theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), {}), attributes = generateTooltipAttributes(point6, title3, content, bounds, theme2, addition);
      this._tooltipComponent.setAttributes(attributes);
    }, 10), this.handleTooltipHide = (event) => {
      this._tooltipComponent && this._tooltipComponent.hideAll();
    }, this.options = Object.assign({}, _DimensionTooltip.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._avoidMarks = null !== (_a = view.getMarksBySelector(this.options.avoidMark)) && void 0 !== _a ? _a : [], this._container = null !== (_c = null === (_b = view.getMarksBySelector(this.options.container)) || void 0 === _b ? void 0 : _b[0]) && void 0 !== _c ? _c : view.rootMark;
  }
  getEvents() {
    const filter2 = this.options.target.filter;
    return this._tooltipDataFilter = isString_default(filter2) ? (datum, filterValue) => filterValue === datum[filter2] : filter2, [{
      type: this.options.trigger,
      handler: this.handleTooltipShow
    }, {
      type: this.options.triggerOff,
      handler: this.handleTooltipHide
    }];
  }
};
DimensionTooltip.type = "dimension-tooltip", DimensionTooltip.defaultOptions = {
  trigger: "pointermove",
  triggerOff: "pointerleave"
};

// node_modules/@visactor/vgrammar-core/es/interactions/crosshair.js
var computeCrosshairStartEnd = (point6, scale4, type, groupSize, config2, offset = 0) => {
  var _a, _b;
  const start = {
    x: 0,
    y: 0
  }, end = {
    x: 0,
    y: 0
  }, radius = "angle" === type ? null !== (_a = null == config2 ? void 0 : config2.radius) && void 0 !== _a ? _a : Math.min(groupSize.width, groupSize.height) / 2 : null, center2 = "angle" === type ? null !== (_b = null == config2 ? void 0 : config2.center) && void 0 !== _b ? _b : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  } : null;
  let current = 0;
  if (isDiscrete(scale4.type)) {
    if ("x" === type) current = scale4.scale(scale4.invert(point6.x));
    else if ("y" === type) current = scale4.scale(scale4.invert(point6.y));
    else if ("angle" === type) {
      const angle2 = clampRadian(getAngleByPoint(center2, point6) + 2 * Math.PI);
      current = scale4.scale(scale4.invert(angle2));
    }
  } else isContinuous(scale4.type) && ("x" === type ? current = point6.x : "y" === type ? current = point6.y : "angle" === type && (current = getAngleByPoint(center2, point6)));
  switch (current += offset, type) {
    case "x":
      start.x = current, start.y = 0, end.x = current, end.y = groupSize.height;
      break;
    case "y":
      start.x = 0, start.y = current, end.x = groupSize.width, end.y = current;
      break;
    case "angle":
      start.x = center2.x, start.y = center2.y, end.x = center2.x + radius * Math.cos(current), end.y = center2.y + radius * Math.sin(current);
  }
  return {
    start,
    end
  };
};
var computeRadiusOfTangential = (point6, scale4, type, groupSize, config2, addition) => {
  var _a, _b, _c;
  const center2 = null !== (_b = null !== (_a = null == addition ? void 0 : addition.center) && void 0 !== _a ? _a : null == config2 ? void 0 : config2.center) && void 0 !== _b ? _b : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  };
  let currentRadius = 0;
  if (isDiscrete(scale4.type)) {
    const offset = "band" === scale4.type ? scale4.bandwidth() / 2 : 0, radius = Math.sqrt((point6.x - center2.x) ** 2 + (point6.y - center2.y) ** 2);
    currentRadius = scale4.scale(scale4.invert(radius)) + offset;
  } else if (isContinuous(scale4.type)) {
    const maxRadius = null !== (_c = null == config2 ? void 0 : config2.radius) && void 0 !== _c ? _c : Math.min(groupSize.width, groupSize.height) / 2;
    currentRadius = Math.min(maxRadius, Math.sqrt((point6.x - center2.x) ** 2 + (point6.y - center2.y) ** 2));
  }
  return {
    radius: currentRadius,
    center: center2
  };
};
var generateLineCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.lineCrosshair, offset = "band" === scale4.type ? scale4.bandwidth() / 2 : 0, points = computeCrosshairStartEnd(point6, scale4, type, groupSize, {
    radius: null !== (_b = null == addition ? void 0 : addition.radius) && void 0 !== _b ? _b : null == config2 ? void 0 : config2.radius,
    center: null !== (_c = null == addition ? void 0 : addition.center) && void 0 !== _c ? _c : null == config2 ? void 0 : config2.center
  }, offset);
  return merge({}, crosshairTheme, points, null != addition ? addition : {});
};
var generateRectCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.rectCrosshair, defaultSize = "band" === scale4.type || "point" === scale4.type ? scale4.step() : void 0, customRectStyle = null == addition ? void 0 : addition.rectStyle, size = null != defaultSize ? defaultSize : "y" === type ? null !== (_b = null == customRectStyle ? void 0 : customRectStyle.width) && void 0 !== _b ? _b : crosshairTheme.rectStyle.width : null !== (_c = null == customRectStyle ? void 0 : customRectStyle.height) && void 0 !== _c ? _c : crosshairTheme.rectStyle.height, points = computeCrosshairStartEnd(point6, scale4, type, groupSize, config2, "band" === scale4.type ? 0 : -size / 2), rectStyle = {};
  "x" === type ? rectStyle.width = size : rectStyle.height = size;
  const attribute = merge({}, crosshairTheme, {
    start: points.start,
    end: points.end,
    rectStyle
  }, null != addition ? addition : {});
  return "x" === type ? attribute.rectStyle.height = attribute.end.y - attribute.start.y : attribute.rectStyle.width = attribute.end.x - attribute.start.x, attribute;
};
var generateRingCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle, deltaRadius = "band" === scale4.type || "point" === scale4.type ? scale4.step() : 0;
  return merge({}, crosshairTheme, {
    center: center2,
    innerRadius: radius - deltaRadius / 2,
    radius: radius + deltaRadius / 2,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var generateSectorCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c, _d, _e;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.sectorCrosshair, radius = null !== (_c = null !== (_b = null == addition ? void 0 : addition.radius) && void 0 !== _b ? _b : null == config2 ? void 0 : config2.radius) && void 0 !== _c ? _c : Math.min(groupSize.width, groupSize.height) / 2, center2 = null !== (_e = null !== (_d = null == addition ? void 0 : addition.center) && void 0 !== _d ? _d : null == config2 ? void 0 : config2.center) && void 0 !== _e ? _e : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  }, defaultAngle = crosshairTheme.endAngle - crosshairTheme.startAngle, angle2 = "band" === scale4.type || "point" === scale4.type ? scale4.step() : defaultAngle;
  let currentAngle = 0;
  if (isDiscrete(scale4.type)) {
    const angle3 = clampRadian(getAngleByPoint(center2, point6) + 2 * Math.PI);
    currentAngle = scale4.scale(scale4.invert(angle3)) + ("band" === scale4.type ? scale4.bandwidth() / 2 : 0);
  } else isContinuous(scale4.type) && (currentAngle = getAngleByPoint(center2, point6));
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle: currentAngle - angle2 / 2,
    endAngle: currentAngle + angle2 / 2
  }, null != addition ? addition : {});
};
var generateCircleCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle;
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var generatePolygonCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle;
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var Crosshair = class _Crosshair extends BaseInteraction {
  constructor(view, options) {
    var _a, _b;
    super(view, options), this.type = _Crosshair.type, this.handleCrosshairShow = (event) => {
      var _a2;
      if (!this._crosshairComponent) return;
      const groupGraphicItem = this._container.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      }, globalTransMatrix = groupGraphicItem.globalTransMatrix, containerPoint = {
        x: globalTransMatrix.e,
        y: globalTransMatrix.f
      };
      if (globalTransMatrix.transformPoint(event.canvas, point6), point6.x < 0 || point6.x > groupGraphicItem.attribute.width || point6.y < 0 || point6.y > groupGraphicItem.attribute.height) return void this._crosshairComponent.hideAll();
      const crosshairType = null !== (_a2 = this.options.crosshairType) && void 0 !== _a2 ? _a2 : "x", groupSize = {
        width: groupGraphicItem.attribute.width,
        height: groupGraphicItem.attribute.height
      }, scale4 = (isString_default(this.options.scale) ? this.view.getScaleById(this.options.scale) : this.options.scale).getScale(), config2 = {
        center: this.options.center,
        radius: this.options.radius
      }, theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), {}, {});
      let attributes = {};
      switch (this.getCrosshairComponentType()) {
        case CrosshairEnum.lineCrosshair:
          attributes = generateLineCrosshairAttributes(point6, scale4, crosshairType, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.rectCrosshair:
          attributes = generateRectCrosshairAttributes(point6, scale4, crosshairType, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.sectorCrosshair:
          attributes = generateSectorCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.circleCrosshair:
          attributes = generateCircleCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.polygonCrosshair:
          attributes = generatePolygonCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.ringCrosshair:
          attributes = generateRingCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
      }
      this.getCrosshairComponentType() !== CrosshairEnum.circleCrosshair && (attributes.x = containerPoint.x, attributes.y = containerPoint.y), this._crosshairComponent.showAll(), this._crosshairComponent.setAttributes(attributes);
    }, this.handleCrosshairHide = () => {
      this._crosshairComponent && this._crosshairComponent.hideAll();
    }, this.options = Object.assign({}, _Crosshair.defaultOptions, options), this._container = null !== (_b = null === (_a = view.getMarksBySelector(this.options.container)) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : view.rootMark;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleCrosshairShow
    }, {
      type: this.options.triggerOff,
      handler: this.handleCrosshairHide
    }];
  }
  getCrosshairComponentType() {
    var _a, _b;
    if (this._crosshairComponentType) return this._crosshairComponentType;
    const shape = null !== (_a = this.options.crosshairShape) && void 0 !== _a ? _a : "line", type = null !== (_b = this.options.crosshairType) && void 0 !== _b ? _b : "x";
    return this._crosshairComponentType = "rect" === shape ? "angle" === type ? CrosshairEnum.sectorCrosshair : "radius" === type ? CrosshairEnum.ringCrosshair : "radius-polygon" === type ? CrosshairEnum.polygonCrosshair : CrosshairEnum.rectCrosshair : "radius" === type ? CrosshairEnum.circleCrosshair : "radius-polygon" === type ? CrosshairEnum.polygonCrosshair : CrosshairEnum.lineCrosshair, this._crosshairComponentType;
  }
  getDefaultCrosshairAttribute() {
    var _a;
    const type = null !== (_a = this.options.crosshairType) && void 0 !== _a ? _a : "x";
    return "radius" === type || "radius-polygon" === type ? {
      center: {
        x: 0,
        y: 0
      },
      zIndex: -1
    } : {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      },
      zIndex: -1
    };
  }
  bind() {
    super.bind();
    const stage = this.view.renderer.stage();
    if (!this._crosshairComponent && stage) {
      switch (this.getCrosshairComponentType()) {
        case CrosshairEnum.lineCrosshair:
          this._crosshairComponent = new LineCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.rectCrosshair:
          this._crosshairComponent = new RectCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.sectorCrosshair:
          this._crosshairComponent = new SectorCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.circleCrosshair:
          this._crosshairComponent = new CircleCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.polygonCrosshair:
          this._crosshairComponent = new PolygonCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.ringCrosshair:
          this._crosshairComponent = new SectorCrosshair(this.getDefaultCrosshairAttribute());
      }
      stage.defaultLayer.appendChild(this._crosshairComponent);
    }
  }
  unbind() {
    super.unbind();
    const stage = this.view.renderer.stage();
    this._crosshairComponent && stage && (stage.defaultLayer.removeChild(this._crosshairComponent), this._crosshairComponent.release(), this._crosshairComponent = null);
  }
};
Crosshair.type = "crosshair", Crosshair.defaultOptions = {
  trigger: "pointermove",
  triggerOff: "pointerleave",
  crosshairType: "x",
  crosshairShape: "line"
};

// node_modules/@visactor/vgrammar-core/es/util/scale.js
function getBandWidthOfScale(scale4) {
  if (scale4) return scale4.type === ScaleEnum.Band ? scale4.bandwidth() : scale4.type === ScaleEnum.Point ? scale4.step() : void 0;
}
function getScaleRangeRatio(scale4, input) {
  const range2 = scale4.range();
  return (scale4.scale(input) - range2[0]) / (range2[range2.length - 1] - range2[0]);
}

// node_modules/@visactor/vgrammar-core/es/interactions/view-navigation-base.js
var ViewNavigationBase = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.options = options;
  }
  _parseLinkedComponent(option) {
    if (!option) return null;
    const comp = isString_default(option) ? this.view.getMarkById(option) : option;
    return !comp || comp.markType !== GrammarMarkType.component || comp.componentType !== ComponentEnum.datazoom && comp.componentType !== ComponentEnum.scrollbar ? null : comp;
  }
  _initStateByDim(dim, linkedComponent, scale4, dataTarget, rangeOptions) {
    const comp = this._parseLinkedComponent(linkedComponent);
    if (comp) return void (this._state[dim] = {
      linkedComponent: comp
    });
    const scaleGrammar = isNil_default(scale4) ? null : isString_default(scale4) ? this.view.getScaleById(scale4) : scale4, dataGrammar = isNil_default(null == dataTarget ? void 0 : dataTarget.data) ? null : isString_default(dataTarget.data) ? this.view.getDataById(dataTarget.data) : dataTarget.data;
    if (!scaleGrammar || !dataGrammar) return this._state[dim] = {
      data: dataGrammar,
      scale: scaleGrammar
    }, void (isArray_default(rangeOptions) ? (this._state[dim].rangeFactor = rangeOptions, this._state[dim].initRangeFactor = rangeOptions) : isFunction_default(rangeOptions) ? this._state[dim].getCurrentRange = rangeOptions : scaleGrammar && scaleGrammar.getRangeFactor() && (this._state[dim].rangeFactor = scaleGrammar.getRangeFactor(), this._state[dim].initRangeFactor = scaleGrammar.getRangeFactor()));
    dataGrammar.attach(scaleGrammar);
    const filterByScale = isString_default(dataTarget.filter) ? (datum, filterValue) => {
      const scale5 = scaleGrammar.getScale(), ratio = getScaleRangeRatio(scale5, datum[dataTarget.filter]);
      return ratio >= filterValue[0] && ratio <= filterValue[1];
    } : dataTarget.filter, dataFilter = {
      source: `${scaleGrammar.uid}`,
      rank: DataFilterRank.normal,
      filter: (data) => {
        var _a, _b, _c, _d;
        const filterValue = "x" === dim ? null === (_b = null === (_a = this._state) || void 0 === _a ? void 0 : _a.x) || void 0 === _b ? void 0 : _b.filterValue : null === (_d = null === (_c = this._state) || void 0 === _c ? void 0 : _c.y) || void 0 === _d ? void 0 : _d.filterValue;
        if (!filterValue) return data;
        const filteredData = data.filter((datum) => filterByScale(datum, filterValue));
        return dataTarget.transform ? dataTarget.transform(filteredData, filterValue) : filteredData;
      }
    };
    "x" === dim ? this._dataFilterX = dataFilter : this._dataFilterY = dataFilter, dataGrammar.addDataFilter(dataFilter), this._state[dim] = {
      data: dataGrammar,
      scale: scaleGrammar
    };
  }
  _initGrammars() {
    const { enableX, enableY, scaleX, scaleY, dataTargetX, dataTargetY, linkedComponentX, linkedComponentY, rangeX, rangeY } = this.options;
    this._state = {}, false !== enableX && this._initStateByDim("x", linkedComponentX, scaleX, dataTargetX, rangeX), false !== enableY && this._initStateByDim("y", linkedComponentY, scaleY, dataTargetY, rangeY), this._inited = true;
  }
  _updateLinkedComponent(comp, newRange) {
    comp.componentType === ComponentEnum.datazoom ? comp.setStartEndValue(newRange[0], newRange[1]) : comp.setScrollStart(newRange[0]);
  }
  updateView(type, newRange, eventType, e) {
    var _a, _b, _c, _d;
    newRange && newRange.x && (null === (_b = null === (_a = this._state) || void 0 === _a ? void 0 : _a.x) || void 0 === _b ? void 0 : _b.linkedComponent) && this._updateLinkedComponent(this._state.x.linkedComponent, newRange.x), newRange && newRange.y && (null === (_d = null === (_c = this._state) || void 0 === _c ? void 0 : _c.y) || void 0 === _d ? void 0 : _d.linkedComponent) && this._updateLinkedComponent(this._state.y.linkedComponent, newRange.y), newRange && newRange.needUpdate && this.view.run(), this.dispatchEvent(type, {
      viewRange: newRange,
      event: e,
      eventType
    });
  }
  unbind() {
    super.unbind(), this._state && Object.keys(this._state).forEach((dim) => {
      const { data, scale: scale4 } = this._state[dim];
      data && scale4 ? (data.detach(scale4), data.removeDataFilter("x" === dim ? this._dataFilterX : this._dataFilterY)) : scale4 && (scale4.setRangeFactor(null), scale4.commit());
    }), this._state = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-zoom.js
var ViewZoom = class _ViewZoom extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewZoom.defaultOptions, option)), this.type = _ViewZoom.type, this.handleStartInner = (e) => {
      this.formatZoomEvent(e), !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._inited || this._initGrammars(), this._isStarted = true, this.updateView("start", this.handleZoomStart(e, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      }), "zoom", e));
    }, this.handleEnd = (e) => {
      this._isStarted && (this.formatZoomEvent(e), !e || this.options.shouldEnd && !this.options.shouldEnd(e) || this.updateView("end", this.handleZoomEnd(e, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      }), "zoom", e));
    }, this.handleReset = (e) => {
      this._isStarted && (!e || this.options.shouldReset && !this.options.shouldReset(e) || (this.updateView("reset", this.handleZoomReset(e, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      }), "zoom", e), this._isStarted = false));
    }, this.handleStart = throttle_default(this.handleStartInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
};
ViewZoom.type = "view-zoom", ViewZoom.defaultOptions = {
  realtime: true,
  focus: true,
  trigger: "wheel",
  endTrigger: "pointerup",
  triggerOff: "dblclick",
  rate: 1,
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-scroll.js
var ViewScroll = class _ViewScroll extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewScroll.defaultOptions, option)), this.type = _ViewScroll.type, this.handleStartInner = (e) => {
      this.formatScrollEvent(e), !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._isStarted = true, this._inited || this._initGrammars(), this.updateView("start", this.handleScrollStart(e, this._state, this.options), "scroll", e));
    }, this.handleEnd = (e) => {
      this._isStarted && (this.formatScrollEvent(e), !e || this.options.shouldEnd && !this.options.shouldEnd(e) || (this.updateView("end", this.handleScrollEnd(e, this._state, this.options), "scroll", e), this._isStarted = false));
    }, this.handleStart = throttle_default(this.handleStartInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }];
  }
};
ViewScroll.type = "view-scroll", ViewScroll.defaultOptions = {
  realtime: true,
  reversed: false,
  trigger: "wheel",
  endTrigger: "pointerup",
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-drag.js
var ViewDrag = class _ViewDrag extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewDrag.defaultOptions, option)), this.type = _ViewDrag.type, this.handleStart = (e) => {
      !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._isStarted = true, this._inited || this._initGrammars(), this.updateView("start", this.handleDragStart(e, this._state, {
        reversed: this.options.reversed
      }), "drag", e));
    }, this.handleUpdateInner = (e) => {
      this._isStarted && e && (!this.options.shouldUpdate || this.options.shouldUpdate(e)) && this.updateView("update", this.handleDragUpdate(e, this._state, {
        reversed: this.options.reversed
      }), "drag", e);
    }, this.handleEnd = (e) => {
      this._isStarted && e && (!this.options.shouldEnd || this.options.shouldEnd(e)) && (this.updateView("end", this.handleDragEnd(e, this._state, {
        reversed: this.options.reversed
      }), "drag", e), this._isStarted = false);
    }, this.handleUpdate = throttle_default(this.handleUpdateInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.updateTrigger,
      handler: this.handleUpdate
    }];
  }
};
ViewDrag.type = "view-drag", ViewDrag.defaultOptions = {
  realtime: true,
  reversed: false,
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: "pointerup",
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-roam.js
var ViewRoam = class _ViewRoam extends ViewNavigationBase {
  constructor(view, option) {
    super(view, merge({}, _ViewRoam.defaultOptions, option)), this.type = _ViewRoam.type, this.handleRoamZoomStartInner = (e) => {
      this.formatZoomEvent(e), !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._inited || this._initGrammars(), this._isZoomStarted = true, this.updateView("start", this.handleZoomStart(e, this._state, this.options.zoom), "zoom", e));
    }, this.handleRoamZoomEnd = (e) => {
      this._isZoomStarted && (this.formatZoomEvent(e), !e || this.options.shouldEnd && !this.options.shouldEnd(e) || (this.updateView("end", this.handleZoomEnd(e, this._state, this.options.zoom), "zoom", e), this._isZoomStarted = false));
    }, this.handleRoamZoomReset = (e) => {
      this._isZoomStarted && e && (!this.options.shouldReset || this.options.shouldReset(e)) && (this.updateView("reset", this.handleZoomReset(e, this._state, this.options.zoom), "zoom", e), this._isZoomStarted = false);
    }, this.handleRoamDragStart = (e) => {
      !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._inited || this._initGrammars(), this._isDragStarted = true, this.updateView("start", this.handleDragStart(e, this._state, this.options.drag), "drag", e));
    }, this.handleRoamDragUpdateInner = (e) => {
      this._isDragStarted && e && (!this.options.shouldUpdate || this.options.shouldUpdate(e)) && this.updateView("update", this.handleDragUpdate(e, this._state, this.options.drag), "drag", e);
    }, this.handleRoamDragEnd = (e) => {
      this._isDragStarted && e && (!this.options.shouldEnd || this.options.shouldEnd(e)) && (this.updateView("end", this.handleDragEnd(e, this._state, this.options.drag), "drag", e), this._isDragStarted = false);
    }, this.handleRoamScrollStartInner = (e) => {
      this.formatScrollEvent(e), !e || this.options.shouldStart && !this.options.shouldStart(e) || (this._inited || this._initGrammars(), this._isScrollStarted = true, this.updateView("start", this.handleScrollStart(e, this._state, this.options.scroll), "scroll", e));
    }, this.handleRoamScrollEnd = (e) => {
      this._isScrollStarted && (this.formatScrollEvent(e), !e || this.options.shouldEnd && !this.options.shouldEnd(e) || (this.updateView("end", this.handleScrollEnd(e, this._state, this.options.scroll), "scroll", e), this._isScrollStarted = true));
    }, this.handleRoamZoomStart = throttle_default(this.handleRoamZoomStartInner, this.options.throttle), this.handleRoamDragUpdate = throttle_default(this.handleRoamDragUpdateInner, this.options.throttle), this.handleRoamScrollStart = throttle_default(this.handleRoamScrollStartInner, this.options.throttle);
  }
  getEvents() {
    var _a, _b, _c;
    const events = [];
    return (null === (_a = this.options.zoom) || void 0 === _a ? void 0 : _a.enable) && (this.options.zoom.trigger && events.push({
      type: this.options.zoom.trigger,
      handler: this.handleRoamZoomStart
    }), this.options.zoom.endTrigger && events.push({
      type: this.options.zoom.endTrigger,
      handler: this.handleRoamZoomEnd
    }), this.options.zoom.triggerOff && events.push({
      type: this.options.zoom.triggerOff,
      handler: this.handleRoamZoomReset
    })), (null === (_b = this.options.scroll) || void 0 === _b ? void 0 : _b.enable) && (this.options.scroll.trigger && events.push({
      type: this.options.scroll.trigger,
      handler: this.handleRoamScrollStart
    }), this.options.scroll.trigger && events.push({
      type: this.options.scroll.endTrigger,
      handler: this.handleRoamScrollEnd
    })), (null === (_c = this.options.drag) || void 0 === _c ? void 0 : _c.enable) && (this.options.drag.trigger && events.push({
      type: this.options.drag.trigger,
      handler: this.handleRoamDragStart
    }), this.options.drag.updateTrigger && events.push({
      type: this.options.drag.updateTrigger,
      handler: this.handleRoamDragUpdate
    }), this.options.drag.endTrigger && events.push({
      type: this.options.drag.endTrigger,
      handler: this.handleRoamDragEnd
    })), events;
  }
};
ViewRoam.type = "view-roam", ViewRoam.defaultOptions = {
  zoom: {
    realtime: true,
    enable: true,
    focus: true,
    trigger: "wheel",
    endTrigger: "pointerup",
    triggerOff: "dblclick",
    rate: 1
  },
  scroll: {
    realtime: true,
    enable: false,
    reversed: false,
    trigger: "wheel",
    endTrigger: "pointerup"
  },
  drag: {
    realtime: true,
    enable: true,
    reversed: false,
    trigger: "pointerdown",
    updateTrigger: "pointermove",
    endTrigger: "pointerup"
  },
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/fish-eye.js
var FishEye = class _FishEye extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _FishEye.type, this.handleStart = (e) => {
      e && (this.options.shouldStart ? this.options.shouldStart(e) : this.shouldHandle(e)) && (this._inited || this._initGrammars(), this._isActive || (this._isActive = true, this.updateView({
        x: e.canvasX,
        y: e.canvasY
      }, e)));
    }, this.handleUpdateInner = (e) => {
      e && (this.options.shouldUpdate ? this.options.shouldUpdate(e) : this.shouldUpdate(e)) && this._isActive && this.updateView({
        x: e.canvasX,
        y: e.canvasY
      }, e);
    }, this.handleEnd = (e) => {
      e && (this.options.shouldEnd ? this.options.shouldEnd(e) : this.shouldHandle(e)) && !this.options.triggerOff && this._isActive && (this._isActive = false, this.updateView(null, e));
    }, this.handleReset = (e) => {
      e && (this.options.shouldReset ? this.options.shouldReset(e) : this.shouldHandle(e)) && this._isActive && (this.updateView(null, e), this._isActive = false);
    }, this.options = Object.assign({}, _FishEye.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this.handleUpdate = throttle_default(this.handleUpdateInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.updateTrigger,
      handler: this.handleUpdate
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  _initStateByDim(dim, distortion, scale4, radius, radiusRatio) {
    const scaleGrammar = isNil_default(scale4) ? null : isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
    this._state[dim] = {
      scale: scaleGrammar,
      distortion,
      radius,
      radiusRatio
    };
  }
  _initGrammars() {
    const { enableX, enableY, scaleX, scaleY, distortionX, distortionY, radiusRatioX, radiusRatioY, radiusX, radiusY } = this.options;
    this._state = {}, false !== enableX && this._initStateByDim("x", distortionX, scaleX, radiusX, radiusRatioX), false !== enableY && this._initStateByDim("y", distortionY, scaleY, radiusY, radiusRatioY), this._inited = true;
  }
  updateView(focus, e) {
    let needUpdate = false;
    focus ? Object.keys(this._state).forEach((dim) => {
      const dimState = this._state[dim];
      dimState.scale && dimState.focus !== focus[dim] && (needUpdate = true, dimState.focus = focus[dim], dimState.scale.setFishEye({
        distortion: dimState.distortion,
        radius: dimState.radius,
        radiusRatio: dimState.radiusRatio,
        focus: focus[dim]
      }), dimState.scale.commit());
    }) : Object.keys(this._state).forEach((dim) => {
      const dimState = this._state[dim];
      dimState.scale && !isNil_default(dimState.focus) && (needUpdate = true, dimState.focus = null, dimState.scale.setFishEye(null), dimState.scale.commit());
    }), needUpdate && this.view.run();
  }
  shouldHandle(e) {
    var _a, _b, _c;
    return this._marks ? e.element && this._marks && this._marks.includes(e.element.mark) : e.target === (null === (_c = null === (_b = null === (_a = this.view) || void 0 === _a ? void 0 : _a.renderer) || void 0 === _b ? void 0 : _b.stage) || void 0 === _c ? void 0 : _c.call(_b));
  }
  shouldUpdate(e) {
    if (this._marks) return e.element && this._marks && this._marks.includes(e.element.mark);
    const viewBox = this.view.getViewBox();
    return e.canvasX >= viewBox.x1 && e.canvasX <= viewBox.x2 && e.canvasY >= viewBox.y1 && e.canvasY <= viewBox.y2;
  }
  unbind() {
    super.unbind(), this._state && Object.keys(this._state).forEach((dim) => {
      const { scale: scale4 } = this._state[dim];
      scale4 && (scale4.setRangeFactor(null), scale4.commit());
    }), this._state = null;
  }
};
FishEye.type = "fish-eye", FishEye.defaultOptions = {
  trigger: "pointerenter",
  updateTrigger: "pointermove",
  endTrigger: "pointerleave",
  distortionX: 2,
  distortionY: 2,
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/toggle-state-mixin.js
var ToggleStateMixin = class {
  updateStates(newStatedElements, prevStatedElements, state, reverseState) {
    return newStatedElements && newStatedElements.length ? (state && reverseState ? prevStatedElements && prevStatedElements.length ? (this.toggleReverseStateOfElements(newStatedElements, prevStatedElements, reverseState), this.toggleStateOfElements(newStatedElements, prevStatedElements, state)) : this.addBothStateOfElements(newStatedElements, state, reverseState) : state && (prevStatedElements && prevStatedElements.length ? this.toggleStateOfElements(newStatedElements, prevStatedElements, state) : this.addStateOfElements(newStatedElements, state)), newStatedElements) : null;
  }
  toggleReverseStateOfElements(newStatedElements, prevStatedElements, reverseState) {
    prevStatedElements.forEach((element) => {
      reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(element.mark) && element.addState(reverseState);
    }), newStatedElements.forEach((element) => {
      reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(element.mark) && element.removeState(reverseState);
    });
  }
  toggleStateOfElements(newStatedElements, prevStatedElements, state) {
    prevStatedElements.forEach((element) => {
      state && this._stateMarks[state] && this._stateMarks[state].includes(element.mark) && element.removeState(state);
    }), newStatedElements.forEach((element) => {
      state && this._stateMarks[state] && this._stateMarks[state].includes(element.mark) && element.addState(state);
    });
  }
  addBothStateOfElements(statedElements, state, reverseState) {
    this._marks.forEach((mark) => {
      var _a;
      const hasReverse = reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(mark), hasState = state && this._stateMarks[state] && this._stateMarks[state].includes(mark);
      (hasReverse || hasState) && (null === (_a = mark.elements) || void 0 === _a || _a.forEach((el) => {
        statedElements && statedElements.includes(el) ? hasState && el.addState(state) : hasReverse && el.addState(reverseState);
      }));
    });
  }
  addStateOfElements(statedElements, state) {
    this._marks.forEach((mark) => {
      var _a;
      const hasState = state && this._stateMarks[state] && this._stateMarks[state].includes(mark);
      hasState && (null === (_a = mark.elements) || void 0 === _a || _a.forEach((el) => {
        statedElements && statedElements.includes(el) && hasState && el.addState(state);
      }));
    });
  }
  clearAllStates(state, reverseState) {
    this._statedElements && this._statedElements.length && this._marks.forEach((mark) => {
      mark && mark.elements && (reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(mark) && mark.elements.forEach((el) => {
        el.removeState(reverseState);
      }), state && this._stateMarks[state] && this._stateMarks[state].includes(mark) && mark.elements.forEach((el) => {
        this._statedElements.includes(el) && el.removeState(state);
      }));
    });
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/index.js
var registerElementActive = () => {
  Factory3.registerInteraction(ElementActive.type, ElementActive);
};
var registerElementSelect = () => {
  mixin(ElementSelect, ToggleStateMixin), Factory3.registerInteraction(ElementSelect.type, ElementSelect);
};
var registerElementHighlight = () => {
  mixin(ElementHighlight, ToggleStateMixin), Factory3.registerInteraction(ElementHighlight.type, ElementHighlight);
};
var registerElementHighlightByKey = () => {
  Factory3.registerInteraction(ElementHighlightByKey.type, ElementHighlightByKey);
};
var registerElementHighlightByGroup = () => {
  Factory3.registerInteraction(ElementHighlightByGroup.type, ElementHighlightByGroup);
};
var registerElementActiveByLegend = () => {
  Factory3.registerInteraction(ElementActiveByLegend.type, ElementActiveByLegend);
};
var registerElementHighlightByLegend = () => {
  Factory3.registerInteraction(ElementHighlightByLegend.type, ElementHighlightByLegend);
};
var registerElementHighlightByName = () => {
  Factory3.registerInteraction(ElementHighlightByName.type, ElementHighlightByName);
};
var registerElementHighlightByGraphicName = () => {
  Factory3.registerInteraction(ElementHighlightByGraphicName.type, ElementHighlightByGraphicName);
};
var registerElementSelectByGraphicName = () => {
  Factory3.registerInteraction(ElementSelectByGraphicName.type, ElementSelectByGraphicName);
};

// node_modules/@visactor/vgrammar-core/es/parse/option.js
var parseOptionValue = (value, params2) => isGrammar(value) ? value.output() : value && isObject_default(value) ? isFunction_default(value.callback) ? (datum) => value.callback(datum, params2) : isFunction_default(value.value) ? value.value(params2) : value : value;
var parseOptions = (options, params2) => options ? isObject_default(options) ? Object.keys(options).reduce((res, key) => {
  const option = options[key];
  return res[key] = parseOptionValue(option, params2), res;
}, {}) : options.map((option) => parseOptionValue(option, params2)) : options;

// node_modules/@visactor/vgrammar-core/es/view/grammar-base.js
var grammarBaseId = -1;
var GrammarBase = class extends import_eventemitter3.default {
  constructor(view) {
    super(), this.spec = {}, this.references = /* @__PURE__ */ new Map(), this.targets = [], this.transforms = [], this.view = view, this.uid = ++grammarBaseId;
  }
  parse(spec) {
    return this.id(spec.id), this.name(spec.name), this.depend(spec.dependency), this;
  }
  depend(grammars) {
    var _a;
    if (null === (_a = this.spec) || void 0 === _a ? void 0 : _a.dependency) {
      const lastGrammars = array(this.spec.dependency).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
      this.detach(lastGrammars);
    }
    this.spec.dependency = grammars;
    const currentGrammars = array(grammars).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
    return this.attach(currentGrammars), this.commit(), this;
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  emit(event, ...args) {
    var _a, _b;
    return null === (_b = null === (_a = this.view) || void 0 === _a ? void 0 : _a.emit) || void 0 === _b || _b.call(_a, event, ...args), super.emit(event, ...args);
  }
  emitGrammarEvent(event, ...args) {
    return super.emit(event, ...args);
  }
  evaluateTransform(transforms, upstream, parameters) {
    if (!transforms || !transforms.length) return upstream;
    let currentUpstreamData = upstream, i = 0;
    const n = transforms.length;
    for (; i < n; ) {
      const task = transforms[i];
      this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type), currentUpstreamData = task.transform(task.isRawOptions ? task.options : parseOptions(task.options, parameters), currentUpstreamData, parameters, this.view), i++, this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);
    }
    return currentUpstreamData;
  }
  set(value) {
    return false;
  }
  id(id) {
    return arguments.length ? (this.view.grammars.unrecord(this), this._id = id, this.view.grammars.record(this), this) : this._id;
  }
  name(name) {
    return arguments.length ? (this._name = name, this) : this._name;
  }
  attach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      isNil_default(reference) || (ref.targets.includes(this) || ref.targets.push(this), this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + count));
    }), this;
  }
  detach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      const refCount = this.references.get(ref) - count;
      refCount > 0 ? this.references.set(ref, refCount - 1) : (this.references.delete(ref), ref.targets.includes(this) && (ref.targets = ref.targets.filter((target) => target !== this)));
    }), this;
  }
  detachAll() {
    this.references.forEach((count, ref) => {
      this.detach(ref, count);
    });
  }
  link(source) {
    this.grammarSource = source;
  }
  run() {
    var _a;
    const upstream = null === (_a = this.grammarSource) || void 0 === _a ? void 0 : _a.output(), parameters = this.parameters();
    return this.evaluate(upstream, parameters);
  }
  commit() {
    this.view.commit(this);
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  getSpec() {
    return this.spec;
  }
  reuse(grammar) {
    return this;
  }
  clear() {
    this.spec = null, this.view = null;
  }
  release() {
    this.clear();
  }
  setFunctionSpec(spec, specField) {
    return isNil_default(this.spec[specField]) || this.detach(parseFunctionType(this.spec[specField], this.view)), this.spec[specField] = spec, this.attach(parseFunctionType(spec, this.view)), this.commit(), this;
  }
};

// node_modules/@visactor/vgrammar-core/es/parse/transform.js
var parseSimpleOptionValue = (key, transformSpecValue, view) => {
  var _a;
  if ("callback" === key && isFunction_default(transformSpecValue)) return {
    references: [],
    value: {
      callback: transformSpecValue,
      dependency: []
    }
  };
  if (!isNil_default(transformSpecValue.data)) {
    const grammarInstance = view.getDataById(transformSpecValue.data);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.customized)) {
    const grammarInstance = view.getCustomizedById(transformSpecValue.customized);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.scale)) {
    const grammarInstance = view.getScaleById(transformSpecValue.scale);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (isSignal(transformSpecValue)) {
    const references = parseFunctionType(transformSpecValue, view);
    return {
      references,
      value: transformSpecValue.callback ? {
        value: transformSpecValue.callback,
        dependency: references
      } : null !== (_a = null == references ? void 0 : references[0]) && void 0 !== _a ? _a : transformSpecValue
    };
  }
  return {
    value: transformSpecValue
  };
};
var parseTransformOption = (key, transformSpecValue, view) => {
  if (isNil_default(transformSpecValue)) return {
    value: transformSpecValue
  };
  if (isArray_default(transformSpecValue)) {
    const values = transformSpecValue.map((v) => parseSimpleOptionValue(key, v, view));
    return {
      references: values.reduce((res, val) => (val.references && res.concat(val.references), res), []),
      value: values.map((entry) => entry.value)
    };
  }
  return parseSimpleOptionValue(key, transformSpecValue, view);
};
var parseTransform2 = (transformSpec, view) => {
  const transformDef = Factory3.getTransform(transformSpec.type);
  if (!transformDef) return;
  const options = {};
  let references = [];
  return Object.keys(transformSpec).forEach((specKey) => {
    var _a;
    if ("type" === specKey) return;
    const specValue = transformSpec[specKey];
    if ("dependency" === specKey) return void ((null == specValue ? void 0 : specValue.length) && (references = references.concat(parseReference(specValue, view))));
    const res = parseTransformOption(specKey, specValue, view);
    res && ((null === (_a = res.references) || void 0 === _a ? void 0 : _a.length) && (references = references.concat(res.references)), options[specKey] = res.value);
  }), {
    markPhase: transformDef.markPhase,
    transform: transformDef.transform,
    canProgressive: transformDef.canProgressive,
    type: transformDef.type,
    options,
    references
  };
};
var parseTransformSpec = (spec, view) => {
  if (null == spec ? void 0 : spec.length) {
    const transforms = [];
    let refs = [];
    return spec.forEach((transformSpec) => {
      var _a;
      const transform30 = parseTransform2(transformSpec, view);
      transform30 && ((null === (_a = transform30.references) || void 0 === _a ? void 0 : _a.length) && (refs = refs.concat(transform30.references)), transforms.push(transform30));
    }), {
      transforms,
      refs
    };
  }
  return null;
};

// node_modules/@visactor/vgrammar-core/es/util/data.js
var jsonParser = (data, options = {}, dataView) => {
  if (!isString_default(data)) return array(data);
  try {
    return array(JSON.parse(data));
  } catch (e) {
    return [];
  }
};
var parsers = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser,
  json: jsonParser
};
var parseFormat = (data, format) => {
  if (!format || !parsers[format.type]) return array(data);
  const options = "dsv" === format.type ? {
    delimiter: format.delimiter
  } : {};
  return parsers[format.type](data, options, new DataView(new DataSet()));
};

// node_modules/@visactor/vgrammar-core/es/view/data.js
var Data = class extends GrammarBase {
  constructor(view, values, format) {
    super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, this._loadTasks = [], this._postFilters = [], this.ingest = (options) => {
      const format2 = invokeParameterFunctionType(options.format, this.parameters());
      return this._input = parseFormat(options.values, format2), this._input;
    }, this.load = (options) => {
      if (options.values) return this.ingest(options);
    }, this.relay = (options) => options[0], this._loadTasks = [], isNil_default(values) || this.values(values, format);
  }
  parse(spec) {
    return super.parse(spec), this._isLoaded = false, this.source(spec.source, spec.format, false), this.url(spec.url, spec.format, false), this.values(spec.values, spec.format, false), this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
  }
  parseDataSource(spec) {
    const refs = [], transforms = [], formatRef = spec.format ? parseFunctionType(spec.format, this.view)[0] : null;
    if (formatRef && refs.push(formatRef), spec.values) {
      const valuesRef = parseFunctionType(spec.values, this.view)[0];
      valuesRef && refs.push(valuesRef), transforms.push({
        type: "ingest",
        transform: this.ingest,
        isRawOptions: true,
        options: {
          values: spec.values,
          format: spec.format
        }
      });
    } else if (spec.url) {
      const urlRef = parseFunctionType(spec.url, this.view)[0];
      urlRef && refs.push(urlRef), transforms.push({
        type: "load",
        transform: this.load,
        options: {
          url: null != urlRef ? urlRef : spec.url,
          format: null != formatRef ? formatRef : spec.format
        }
      });
    } else if (spec.source) {
      const upstreamData = [];
      array(spec.source).forEach((sourceId) => {
        const sourceData = isGrammar(sourceId) ? sourceId : this.view.getDataById(sourceId);
        sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
      }), upstreamData.length && (transforms.push({
        type: "relay",
        transform: this.relay,
        options: upstreamData
      }), this.grammarSource = upstreamData[0]);
    }
    return {
      transforms,
      refs
    };
  }
  evaluate(upstream, parameters) {
    this.view.emit(HOOK_EVENT.BEFORE_EVALUATE_DATA);
    const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
    this.grammarSource && (this._input = upstream);
    const values = this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
    return this.setValues(filteredValues), this._isLoaded = true, this.view.emit(HOOK_EVENT.AFTER_EVALUATE_DATA), this;
  }
  output() {
    return this._values;
  }
  getDataIDKey() {
    return this._dataIDKey;
  }
  values(values, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      values,
      format
    });
    return isNil_default(values) || (spec.url = void 0, spec.source = void 0), load3 ? this.parseLoad(spec) : this;
  }
  url(url, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      url,
      format
    });
    return isNil_default(url) || (spec.values = void 0, spec.source = void 0), load3 ? this.parseLoad(spec) : this;
  }
  source(source, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      source,
      format
    });
    return isNil_default(source) || (spec.values = void 0, spec.url = void 0), load3 ? this.parseLoad(spec) : this;
  }
  parseLoad(spec) {
    this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
    const dataSourceResult = this.parseDataSource(this.spec);
    return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, this._isLoaded = false, this.commit(), this;
  }
  setValues(data) {
    this._values = array(data).map((entry, index) => {
      const datum = entry === Object(entry) ? entry : {
        data: entry
      };
      return datum[this._dataIDKey] = index, datum;
    });
  }
  field(field5) {
    return this._values.map((value) => value[field5]);
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
    const nextTransforms = parseTransformSpec(this.spec.transform, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.commit(), this;
  }
  getValue() {
    return this._values;
  }
  getInput() {
    return this._input;
  }
  addDataFilter(filter2) {
    return this._postFilters = this._postFilters.concat(array(filter2)), this._postFilters.sort((filterA, filterB) => {
      var _a, _b;
      return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
    }), this;
  }
  removeDataFilter(filter2) {
    const filters = array(filter2);
    return this._postFilters = this._postFilters.filter((filter3) => !filters.includes(filter3)), this;
  }
  _evaluateFilter(value, parameters) {
    return this._postFilters.reduce((result2, filter2) => filter2.filter(result2, parameters), value);
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._isLoaded = false, this._values = grammar.output()), this;
  }
  clear() {
    super.clear(), this._input = null, this._values = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/util/grammar-heap.js
function moveToHead(array2, idx2, start, cmp) {
  let parent, pidx;
  const item = array2[idx2];
  for (; idx2 > start && (pidx = Math.floor((idx2 - 1) / 2), parent = array2[pidx], item && parent && cmp(item, parent) < 0); ) array2[idx2] = parent, idx2 = pidx;
  return array2[idx2] = item;
}
function moveToTail(array2, idx2, end, cmp) {
  const start = idx2, endIdx = null != end ? end : array2.length, item = array2[idx2];
  let ridx, cidx = 2 * idx2 + 1;
  for (; cidx < endIdx; ) ridx = cidx + 1, ridx < endIdx && cmp(array2[cidx], array2[ridx]) >= 0 && (cidx = ridx), array2[idx2] = array2[cidx], cidx = 2 * (idx2 = cidx) + 1;
  return array2[idx2] = item, moveToHead(array2, idx2, start, cmp);
}
var Heap = class {
  constructor(compare2) {
    this.compare = compare2, this.nodes = [];
  }
  size() {
    return this.nodes.length;
  }
  last() {
    return this.nodes[0];
  }
  validate() {
    for (let i = this.nodes.length - 1; i > 0; i -= 1) {
      const parentIndex = Math.floor((i - 1) / 2);
      if (this.compare(this.nodes[parentIndex], this.nodes[i]) > 0) return false;
    }
    return true;
  }
  push(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      return moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
    return this.nodes.push(node), moveToHead(this.nodes, this.nodes.length - 1, 0, this.compare);
  }
  remove(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      this.nodes = this.nodes.slice(0, index).concat(this.nodes.slice(index + 1)), moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
  }
  pop() {
    const last2 = this.nodes.pop();
    let item;
    return this.nodes.length ? (item = this.nodes[0], this.nodes[0] = last2, moveToTail(this.nodes, 0, null, this.compare)) : item = last2, item;
  }
  clear() {
    this.nodes = [];
  }
};

// node_modules/@visactor/vgrammar-core/es/util/unique-list.js
var UniqueList = class {
  constructor(idFunc) {
    this.list = [], this.ids = {}, this.idFunc = idFunc || identity;
  }
  add(element) {
    const id = this.idFunc(element);
    return this.ids[id] || (this.ids[id] = 1, this.list.push(element)), this;
  }
  remove(element) {
    const id = this.idFunc(element);
    return this.ids[id] && (this.ids[id] = 0, this.list = this.list.filter((entry) => entry !== element)), this;
  }
  forEach(callback, reverse) {
    reverse ? this.list.slice().reverse().forEach(callback) : this.list.forEach(callback);
  }
  filter(callback) {
    return this.list.filter(callback);
  }
  get length() {
    return this.list.length;
  }
  getElementByIndex(index) {
    return this.list[index];
  }
};

// node_modules/@visactor/vgrammar-core/es/view/dataflow.js
var Dataflow = class {
  constructor() {
    this.grammars = [], this.logger = Logger.getInstance(), this._curRank = 0, this._committed = new UniqueList((grammar) => grammar.uid), this._heap = new Heap((a3, b) => (null == a3 ? void 0 : a3.qrank) - (null == b ? void 0 : b.qrank)), this._beforeRunner = null, this._afterRunner = null, this._updateCounter = 0, this._finishFirstRender = false;
  }
  add(grammar) {
    if (grammar) return this._setRankOfGrammar(grammar), this.commit(grammar), !this.grammars.includes(grammar) && (this.grammars.push(grammar), true);
  }
  remove(grammar) {
    grammar && (this._committed.remove(grammar), this._heap.remove(grammar), this.grammars = this.grammars.filter((storedGrammar) => storedGrammar !== grammar));
  }
  _setRankOfGrammar(grammar) {
    grammar && (grammar.rank = ++this._curRank);
  }
  _reRank(grammar) {
    const queue = [grammar];
    for (; queue.length; ) {
      const cur = queue.pop();
      this._setRankOfGrammar(cur);
      const list = cur.targets;
      list && list.forEach((entry) => {
        queue.push(entry), entry === grammar && this.logger.error("Cycle detected in dataflow graph.");
      });
    }
  }
  _enqueue(grammar) {
    grammar && (grammar.qrank = grammar.rank, this._heap.push(grammar));
  }
  _logGrammarRunInfo(grammar) {
    if (this.logger.canLogError()) {
      const debugStr = [{
        key: "id",
        value: grammar.id()
      }, {
        key: "name",
        value: grammar.name()
      }].reduce((str, entry, index) => isNil_default(entry.value) ? str : `${str}${index ? " , " : ""}${entry.key}: ${entry.value}`, "");
      this.logger.debug("Run Operator: ", grammar, debugStr);
    }
  }
  hasCommitted() {
    return !!this._committed.length;
  }
  commit(grammar) {
    return this._committed.add(grammar), this;
  }
  _beforeEvaluate() {
    this.grammars.forEach((grammar) => {
      grammar.targets.some((target) => (null == target ? void 0 : target.rank) < (null == grammar ? void 0 : grammar.rank)) && this._reRank(grammar);
    }), this._committed.forEach((grammar) => this._enqueue(grammar)), this._committed = new UniqueList((grammar) => grammar.uid);
  }
  _enqueueTargets(grammar) {
    grammar.targets && grammar.targets.length && this._finishFirstRender && grammar.targets.forEach((target) => this._enqueue(target));
  }
  evaluate() {
    if (this._beforeRunner && this._beforeRunner(this), !this._committed.length) return this.logger.info("Dataflow invoked, but nothing to do."), false;
    this._updateCounter += 1;
    let grammar, dt, count = 0;
    for (this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), this._beforeEvaluate(); this._heap.size() > 0; ) grammar = this._heap.pop(), grammar && (grammar.rank === grammar.qrank ? (grammar.run(), this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1) : this._enqueue(grammar));
    return this.logger.canLogInfo() && (dt = Date.now() - dt, this.logger.info(`> ${count} grammars updated; ${dt} ms`)), this._afterRunner && this._afterRunner(this), this._finishFirstRender = true, true;
  }
  runBefore(callback) {
    this._beforeRunner = callback;
  }
  runAfter(callback) {
    this._afterRunner = callback;
  }
  release() {
    this._heap && (this._heap.clear(), this._heap = null), this.logger = null, this._committed = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/mark-tree.js
var traverseMarkTree = (rootMark, childrenKey, apply, filter2, leafFirst) => {
  const traverse2 = (mark) => {
    if (leafFirst || !mark || filter2 && !filter2(mark) || apply.call(null, mark), mark.markType === GrammarMarkType.group) {
      const children = mark[childrenKey];
      children && children.forEach((child) => {
        traverse2(child);
      });
    }
    leafFirst && (!mark || filter2 && !filter2(mark) || apply.call(null, mark));
  };
  traverse2(rootMark);
};

// node_modules/@visactor/vgrammar-core/es/graph/canvas-renderer.js
var CanvasRenderer = class {
  constructor(view) {
    this.handleAfterNextRender = () => {
      this._stage && !this._viewOptions.disableDirtyBounds && this._stage.enableDirtyBounds(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW), this._view.emit(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER);
    }, this._view = view;
  }
  initialize(width, height, options, eventConfig) {
    return this._width = width, this._height = height, this._viewOptions = options, this._eventConfig = eventConfig, this.initStage(), this;
  }
  stage() {
    var _a;
    return null !== (_a = this._stage) && void 0 !== _a ? _a : null;
  }
  gestureController() {
    var _a;
    return null !== (_a = this._gestureController) && void 0 !== _a ? _a : null;
  }
  canvas() {
    return this._stage ? this._stage.window.getNativeHandler().nativeCanvas : null;
  }
  context() {
    return this._stage ? this._stage.window.getContext().nativeContext : null;
  }
  combineIncrementalLayers() {
    return this._stage && waitForAllSubLayers(this._stage).then(() => {
      this._stage && this._stage.defaultLayer.combineSubLayer();
    }), this;
  }
  background(color) {
    if (this._stage) return this._stage.background = color, this;
  }
  setDpr(resolution, redraw) {
    var _a, _b;
    return null === (_b = null === (_a = this._stage) || void 0 === _a ? void 0 : _a.setDpr) || void 0 === _b || _b.call(_a, resolution), redraw && this.renderNextFrame(), this;
  }
  shouldResize(width, height) {
    return width !== this._width || height !== this._height;
  }
  resize(width, height) {
    return this._view.emit(HOOK_EVENT.BEFORE_STAGE_RESIZE), this.shouldResize(width, height) && (this._width = width, this._height = height, this._stage && this._stage.resize(width, height)), this._view.emit(HOOK_EVENT.AFTER_STAGE_RESIZE), this;
  }
  setViewBox(viewBox, rerender = true) {
    return this._stage ? (!viewBox || this._viewBox && viewBox.x1 === this._viewBox.x1 && viewBox.x2 === this._viewBox.x2 && viewBox.y1 === this._viewBox.y1 && viewBox.y2 === this._viewBox.y2 || (this._viewBox = viewBox, this._stage.setViewBox(viewBox.x1, viewBox.y1, viewBox.x2 - viewBox.x1, viewBox.y2 - viewBox.y1, rerender)), this) : this;
  }
  render(immediately = false) {
    return this._view.emit(HOOK_EVENT.BEFORE_VRENDER_DRAW), this.initStage(), this._stage.disableDirtyBounds(), this._stage.afterNextRender(this.handleAfterNextRender), immediately && (this._stage.render(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW)), this;
  }
  renderNextFrame() {
    return this.initStage(), this._stage.renderNextFrame(), this;
  }
  toCanvas() {
    return this._stage ? this._stage.toCanvas() : null;
  }
  preventRender(tag) {
    this._stage && this._stage.preventRender(tag);
  }
  release() {
    var _a;
    this._view.traverseMarkTree((mark) => {
      mark.release();
    }), this._dragController && this._dragController.release(), this._gestureController && this._gestureController.release(), this._stage !== (null === (_a = this._viewOptions) || void 0 === _a ? void 0 : _a.stage) && this._stage.release(), this._stage = null, this._layer = null, this._dragController = null, this._gestureController = null;
  }
  createStage() {
    var _a, _b, _c, _d, _e;
    this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_STAGE);
    const viewOptions = this._viewOptions, stage = null !== (_a = viewOptions.stage) && void 0 !== _a ? _a : createStage({
      width: this._width,
      height: this._height,
      renderStyle: viewOptions.renderStyle,
      viewBox: viewOptions.viewBox,
      dpr: viewOptions.dpr,
      canvas: viewOptions.renderCanvas,
      canvasControled: viewOptions.canvasControled,
      container: viewOptions.container,
      title: viewOptions.rendererTitle,
      beforeRender: viewOptions.beforeRender,
      afterRender: viewOptions.afterRender,
      disableDirtyBounds: true,
      autoRender: true,
      pluginList: viewOptions.pluginList,
      enableHtmlAttribute: viewOptions.enableHtmlAttribute,
      optimize: viewOptions.optimize,
      ticker: viewOptions.ticker,
      supportsTouchEvents: viewOptions.supportsTouchEvents,
      supportsPointerEvents: viewOptions.supportsPointerEvents,
      event: {
        clickInterval: this._eventConfig.clickInterval,
        autoPreventDefault: !!this._eventConfig.autoPreventDefault
      },
      ReactDOM: viewOptions.ReactDOM,
      autoRefresh: viewOptions.autoRefresh
    });
    (null === (_b = viewOptions.options3d) || void 0 === _b ? void 0 : _b.enable) && stage.set3dOptions(viewOptions.options3d), stage.enableIncrementalAutoRender(), this._viewBox = viewOptions.viewBox, this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_STAGE), this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_LAYER);
    const layer = null !== (_c = viewOptions.layer) && void 0 !== _c ? _c : stage.defaultLayer;
    if (this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_LAYER), (null === (_d = this._eventConfig) || void 0 === _d ? void 0 : _d.drag) && Factory3.getStageEventPlugin("drag") && (this._dragController = new (Factory3.getStageEventPlugin("drag"))(stage)), (null === (_e = this._eventConfig) || void 0 === _e ? void 0 : _e.gesture) && Factory3.getStageEventPlugin("gesture")) {
      const gestureConfig = isObject_default(this._eventConfig.gesture) ? this._eventConfig.gesture : {};
      this._gestureController = new (Factory3.getStageEventPlugin("gesture"))(stage, gestureConfig);
    }
    return {
      stage,
      layer
    };
  }
  initStage() {
    if (!this._stage) {
      const { stage, layer } = this.createStage();
      this._stage = stage, this._layer = layer;
      const background = this._view.background();
      this.background(background);
    }
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/util/point.js
function point5(event) {
  ["touches", "changedTouches", "targetTouches"].forEach((touchKey) => {
    event[touchKey] && event[touchKey].length && Array.from(event[touchKey]).forEach((touch) => {
      defineSrPosition(touch, clientToLocal(touch), false);
    });
  });
  const pos = clientToLocal(event);
  return defineSrPosition(event, pos);
}
function clientToLocal(e) {
  return isNil_default(e.offsetX) ? isNil_default(e.x) ? e.changedTouches && e.changedTouches.length ? getChangedTouchesPos(e) : {
    canvasX: 0,
    canvasY: 0
  } : getXYPos(e) : getOffsetPos(e);
}
function getOffsetPos(e) {
  return {
    canvasX: e.offsetX,
    canvasY: e.offsetY
  };
}
function getXYPos(e) {
  return {
    canvasX: e.x,
    canvasY: e.y
  };
}
function getChangedTouchesPos(e) {
  const pos = e.changedTouches[0];
  return {
    canvasX: pos.x,
    canvasY: pos.y
  };
}
function defineSrPosition(event, pos, client = true) {
  const keys = ["canvasX", "canvasY"];
  return client && (keys.push("clientX"), keys.push("clientY")), keys.forEach((key) => {
    isValidNumber_default(pos[key]) && Object.defineProperty(event, key, {
      value: pos[key],
      writable: true
    });
  }), [pos.canvasX, pos.canvasY];
}

// node_modules/@visactor/vgrammar-core/es/view/constants.js
var EVENT_SOURCE_WINDOW = "window";
var EVENT_SOURCE_VIEW = "view";
var BROWSER = "browser";
var SIGNAL_WIDTH = "width";
var SIGNAL_HEIGHT = "height";
var SIGNAL_VIEW_WIDTH = "viewWidth";
var SIGNAL_VIEW_HEIGHT = "viewHeight";
var SIGNAL_PADDING = "padding";
var SIGNAL_VIEW_BOX = "viewBox";
var SIGNAL_AUTOFIT = "autoFit";
var NAME_PREFIX = "@";
var ID_PREFIX = "#";

// node_modules/@visactor/vgrammar-core/es/graph/util/events-extend.js
function getExtendedEvents(view, event, type, source) {
  var _a, _b;
  if (source === EVENT_SOURCE_WINDOW) {
    const e = event.changedTouches ? event.changedTouches[0] : event;
    point5(e);
  }
  let element = null === (_a = event.target) || void 0 === _a ? void 0 : _a[BridgeElementKey];
  if (!element && source === EVENT_SOURCE_VIEW) {
    let target = event.target;
    const rootGraphic = null === (_b = view.rootMark) || void 0 === _b ? void 0 : _b.graphicItem;
    for (; (null == target ? void 0 : target.parent) && target.parent !== rootGraphic; ) if (target = target.parent, target[BridgeElementKey]) {
      element = target[BridgeElementKey];
      break;
    }
  }
  return event.element = element, event;
}

// node_modules/@visactor/vgrammar-core/es/view/signal.js
var Signal = class extends GrammarBase {
  constructor() {
    super(...arguments), this.grammarType = "signal", this.spec = {
      value: null,
      update: null
    };
  }
  parse(spec) {
    return super.parse(spec), this.value(spec.value), this.update(spec.update), this.commit(), this;
  }
  evaluate(upstream, parameters) {
    return this._signal = this.spec.update ? invokeFunctionType(this.spec.update, parameters, this._signal) : this.spec.value, this.spec.value = this._signal, this;
  }
  output() {
    return this._signal;
  }
  getValue() {
    return this.output();
  }
  set(value) {
    if (isArray_default(value) && isArray_default(this.value) && value.length === this.value.length) {
      for (let i = 0; i < value.length; i++) if (this.value[i] !== value[i]) return this._signal = value, this.spec.value = value, true;
      return false;
    }
    return this._signal !== value && (this._signal = value, this.spec.value = value, true);
  }
  update(update3) {
    return isNil_default(update3) || this.value(void 0), this.setFunctionSpec(update3, "update");
  }
  value(value) {
    return isNil_default(value) || this.update(void 0), this.spec.value = value, this.commit(), this;
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._signal = grammar.output()), this;
  }
  clear() {
    super.clear(), this._signal = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/parse/view.js
var markBaseId = -1;
var BuiltInSignalID = [SIGNAL_WIDTH, SIGNAL_HEIGHT, SIGNAL_PADDING, SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_VIEW_BOX, SIGNAL_AUTOFIT];
var builtInSignals = (option, config2, theme2) => {
  var _a, _b, _c, _d, _e;
  return [{
    id: SIGNAL_WIDTH,
    value: null !== (_a = option[SIGNAL_WIDTH]) && void 0 !== _a ? _a : 0
  }, {
    id: SIGNAL_HEIGHT,
    value: null !== (_b = option[SIGNAL_HEIGHT]) && void 0 !== _b ? _b : 0
  }, {
    id: SIGNAL_PADDING,
    value: normalizePadding2(null !== (_d = null !== (_c = option[SIGNAL_PADDING]) && void 0 !== _c ? _c : config2[SIGNAL_PADDING]) && void 0 !== _d ? _d : null == theme2 ? void 0 : theme2.padding)
  }, {
    id: SIGNAL_VIEW_WIDTH,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_WIDTH] - padding.left - padding.right;
      },
      dependency: [SIGNAL_WIDTH, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_HEIGHT,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_HEIGHT] - padding.top - padding.bottom;
      },
      dependency: [SIGNAL_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_BOX,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return (signal || new Bounds()).setValue(padding.left, padding.top, padding.left + params2[SIGNAL_VIEW_WIDTH], padding.top + params2[SIGNAL_VIEW_HEIGHT]);
      },
      dependency: [SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_AUTOFIT,
    value: null !== (_e = option[SIGNAL_AUTOFIT]) && void 0 !== _e ? _e : config2[SIGNAL_AUTOFIT]
  }];
};
var normalizePadding2 = (value) => {
  var _a, _b, _c, _d;
  return isNumber_default(value) ? {
    top: value,
    bottom: value,
    left: value,
    right: value
  } : {
    top: null !== (_a = null == value ? void 0 : value.top) && void 0 !== _a ? _a : 0,
    bottom: null !== (_b = null == value ? void 0 : value.bottom) && void 0 !== _b ? _b : 0,
    left: null !== (_c = null == value ? void 0 : value.left) && void 0 !== _c ? _c : 0,
    right: null !== (_d = null == value ? void 0 : value.right) && void 0 !== _d ? _d : 0
  };
};
var normalizeMarkTree = (spec) => {
  var _a;
  const traverse2 = (spec2, group) => {
    var _a2, _b;
    spec2.group = group;
    const id = null !== (_a2 = spec2.id) && void 0 !== _a2 ? _a2 : "VGRAMMAR_MARK_" + ++markBaseId;
    spec2.id = id, (null !== (_b = spec2.marks) && void 0 !== _b ? _b : []).forEach((child) => traverse2(child, id));
  };
  return (null !== (_a = spec.marks) && void 0 !== _a ? _a : []).forEach((mark) => traverse2(mark, "root")), spec;
};
var normalizeRunningConfig = (runningConfig) => {
  var _a, _b, _c, _d, _e;
  const { reuse = DefaultReuse, morph: morph2 = DefaultMorph, morphAll = DefaultMorphAll, animation = {}, enableExitAnimation = DefaultEnableExitAnimation } = null != runningConfig ? runningConfig : {};
  return {
    reuse,
    morph: morph2,
    morphAll,
    animation: {
      easing: null !== (_a = animation.easing) && void 0 !== _a ? _a : DefaultAnimationEasing,
      delay: null !== (_b = animation.delay) && void 0 !== _b ? _b : DefaultAnimationDelay,
      duration: null !== (_c = animation.duration) && void 0 !== _c ? _c : DefaultAnimationDuration,
      oneByOne: null !== (_d = animation.oneByOne) && void 0 !== _d ? _d : DefaultAnimationOneByOne,
      splitPath: null !== (_e = animation.splitPath) && void 0 !== _e ? _e : DefaultSplitPath
    },
    enableExitAnimation
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/util/env.js
function configureEnvironment(options) {
  options.mode && vglobal.setEnv(options.mode, options.modeParams || {});
}

// node_modules/@visactor/vgrammar-core/es/graph/mark/differ.js
function groupData(data, key, sort) {
  const groupedData = /* @__PURE__ */ new Map();
  if (!data || 0 === data.length) return {
    keys: [],
    data: groupedData
  };
  if (!key) return groupedData.set(DefaultKey, sort ? data.slice().sort(sort) : data.slice()), {
    keys: DefaultGroupKeys,
    data: groupedData
  };
  const keyGetter = parseField(key);
  if (1 === data.length) {
    const key2 = keyGetter(data[0]);
    return groupedData.set(key2, [data[0]]), {
      keys: [key2],
      data: groupedData
    };
  }
  const keys = /* @__PURE__ */ new Set();
  return data.forEach((entry) => {
    var _a;
    const key2 = keyGetter(entry), lastData = null !== (_a = groupedData.get(key2)) && void 0 !== _a ? _a : [];
    lastData.push(entry), groupedData.set(key2, lastData), keys.add(key2);
  }), sort && keys.forEach((key2) => {
    groupedData.get(key2).sort(sort);
  }), {
    keys: Array.from(keys),
    data: groupedData
  };
}
var Differ = class {
  constructor(data, key, sort) {
    this.prevData = (null == data ? void 0 : data.length) ? groupData(data, null != key ? key : null, sort) : null;
  }
  setCurrentData(currentData) {
    this.currentData = currentData;
  }
  getCurrentData() {
    return this.currentData;
  }
  doDiff() {
    if (this.callback) if (this.currentData && this.prevData) {
      const prevMap = new Map(this.prevData.data);
      this.currentData.keys.forEach((key) => {
        this.callback(key, this.currentData.data.get(key), prevMap.get(key)), prevMap.delete(key);
      }), this.prevData.keys.forEach((key) => {
        prevMap.has(key) && this.callback(key, null, prevMap.get(key));
      });
    } else if (this.currentData) {
      this.currentData.keys.forEach((key) => {
        this.callback(key, this.currentData.data.get(key), null);
      });
    } else this.prevData && this.prevData.keys.forEach((key) => {
      this.callback(key, null, this.prevData.data.get(key));
    });
  }
  setCallback(callback) {
    this.callback = callback;
  }
  updateToCurrent() {
    this.prevData = this.currentData, this.currentData = null;
  }
  reset() {
    this.prevData = null;
  }
};
function diffSingle(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData[0]
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data[0]
    }) : result2.update.push({
      next: data[0],
      prev: prevData[0]
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}
function diffMultiple(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data
    }) : result2.update.push({
      next: data,
      prev: prevData
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}

// node_modules/@visactor/vgrammar-core/es/view/mark.js
var Mark = class extends GrammarBase {
  constructor(view, markType, group) {
    super(view), this.grammarType = "mark", this.elements = [], this.elementMap = /* @__PURE__ */ new Map(), this.isUpdated = true, this._isReentered = false, this.differ = new Differ([]), this.markType = markType, this.spec.type = markType, this.spec.encode = {
      update: {}
    }, this.spec.group = group, group && (this.group = group, this.attach(group), group.appendChild(this));
  }
  parse(spec) {
    var _a, _b, _c;
    if (super.parse(spec), this.spec.group) {
      const groupMark2 = isString_default(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;
      this.detach(groupMark2);
    }
    const groupMark = isString_default(spec.group) ? this.view.getMarkById(spec.group) : spec.group;
    return this.attach(groupMark), this.join(null === (_a = spec.from) || void 0 === _a ? void 0 : _a.data, spec.key, spec.sort, spec.groupBy, spec.groupSort), this.coordinate(spec.coordinate), this.state(spec.state, this.spec.stateSort), Object.keys(null !== (_b = this.spec.encode) && void 0 !== _b ? _b : {}).forEach((state) => {
      this.encodeState(state, {}, true);
    }), Object.keys(null !== (_c = spec.encode) && void 0 !== _c ? _c : {}).forEach((state) => {
      this.encodeState(state, spec.encode[state]);
    }), this.animation(spec.animation), this.animationState(spec.animationState), this.morph(spec.morph, spec.morphKey, spec.morphElementKey), this.layout(spec.layout), this.configure(spec), this.transform(spec.transform), this.parseAddition(spec), this.spec = spec, this.markType = spec.type, this.commit(), this;
  }
  parameters() {
    var _a;
    return null !== (_a = this._finalParameters) && void 0 !== _a ? _a : super.parameters();
  }
  parseAddition(spec) {
    return this;
  }
  reuse(grammar) {
    var _b;
    if (grammar.grammarType !== this.grammarType) return this;
    const mark = grammar;
    return this.markType = mark.markType, this.coord = mark.coord, this.elementMap = mark.elementMap, this.elements = mark.elements, this.elementMap.forEach((element) => element.mark = this), this.differ = mark.differ, null === (_b = this.reuseAnimate) || void 0 === _b || _b.call(this, mark), this._context = mark._context, this.graphicItem = mark.graphicItem, this.graphicIndex = mark.graphicIndex, this.graphicParent = mark.graphicParent, this.needClear = mark.needClear, this.isUpdated = mark.isUpdated, this;
  }
  needLayout() {
    return !isNil_default(this.spec.layout);
  }
  handleLayoutEnd() {
  }
  handleRenderEnd() {
    this.needClear && (this.cleanExitElements(), this.elementMap.forEach((element) => {
      element.diffState === DiffState.exit ? element.clearGraphicAttributes() : element.clearChangedGraphicAttributes();
    }), this.differ.updateToCurrent(), this.needClear = false);
  }
  evaluateMainTasks(data, parameters) {
    var _a, _b;
    if (this.needSkipBeforeLayout() && this.view.getLayoutState() === LayoutState.before) return this;
    const stage = null === (_a = this.view.renderer) || void 0 === _a ? void 0 : _a.stage();
    this.init(stage, parameters);
    const transformData = this.evaluateTransform(this._getTransformsBeforeJoin(), null != data ? data : DefaultMarkData, parameters), progressiveTransform = null == transformData ? void 0 : transformData.progressive;
    if (progressiveTransform ? this.renderContext = {
      large: false
    } : (this.evaluateGroup(transformData), this.renderContext = this.parseRenderContext(transformData, parameters)), null === (_b = this.renderContext) || void 0 === _b ? void 0 : _b.progressive) this.differ.reset(), this.elementMap.clear(), this.evaluateProgressive();
    else {
      let inputData = null;
      if (progressiveTransform) {
        if (this.renderContext.parameters = parameters, this.renderContext.beforeTransformProgressive = transformData.progressive, inputData = transformData.progressive.output(), transformData.progressive.canAnimate && transformData.progressive.unfinished()) return this.update(this.spec), this;
      } else inputData = transformData;
      this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(inputData), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), parameters), this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    }
    return this.update(this.spec), this;
  }
  evaluateGroup(data) {
    if (this.markType === GrammarMarkType.group) return;
    const res = groupData(null != data ? data : DefaultMarkData, this.spec.groupBy, this.spec.groupSort);
    this._groupEncodeResult = null, this._groupedData = res;
  }
  _getTransformsAfterEncodeItems() {
    return this.transforms && this.transforms.filter((entry) => "afterEncodeItems" === entry.markPhase);
  }
  _getTransformsAfterEncode() {
    return this.transforms && this.transforms.filter((entry) => isNil_default(entry.markPhase) || "afterEncode" === entry.markPhase);
  }
  _getTransformsBeforeJoin() {
    return this.transforms ? this.transforms.filter((entry) => "beforeJoin" === entry.markPhase) : [];
  }
  evaluate(data, parameters) {
    var _a;
    return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, parameters), this;
  }
  output() {
    return this;
  }
  join(data, key, sort, groupBy2, groupSort) {
    return this.grammarSource && (this.detach(this.grammarSource), this.grammarSource = null), this.spec.from = null, isNil_default(data) || (isString_default(data) ? this.grammarSource = this.view.getDataById(data) : this.grammarSource = data, this.spec.from = {
      data
    }, this.attach(this.grammarSource)), this.spec.key = key, this.spec.sort = sort, this.spec.groupBy = groupBy2, this.spec.groupSort = groupSort, this.commit(), this;
  }
  coordinate(coordinate) {
    return isString_default(coordinate) ? this.coord = this.view.getCoordinateById(coordinate) : this.coord = coordinate, this.attach(this.coord), this.commit(), this;
  }
  state(state, stateSort) {
    return this.spec.stateSort = stateSort, this.setFunctionSpec(state, "state");
  }
  encode(channel, value, clear) {
    return this.encodeState(DiffState.update, channel, value, clear);
  }
  encodeState(state, channel, value, clear) {
    if (state === DiffState.enter && (this._isReentered = true), this.spec.encode[state]) {
      const lastEncoder = this.spec.encode[state];
      if (isFunctionType(lastEncoder)) this.detach(parseEncodeType(lastEncoder, this.view));
      else {
        const isSingleChannel = isString_default(channel);
        isSingleChannel && clear || !isSingleChannel && value ? (Object.keys(lastEncoder).forEach((c3) => {
          this.detach(parseEncodeType(lastEncoder[c3], this.view));
        }), this.spec.encode[state] = {}) : isSingleChannel ? this.detach(parseEncodeType(lastEncoder[channel], this.view)) : Object.keys(channel).forEach((c3) => {
          this.detach(parseEncodeType(lastEncoder[c3], this.view));
        });
      }
    }
    return channel && (this.spec.encode[state] || (this.spec.encode[state] = {}), isString_default(channel) ? (this.spec.encode[state][channel] = value, this.attach(parseEncodeType(value, this.view))) : isFunctionType(channel) ? (this.spec.encode[state] = channel, this.attach(parseEncodeType(channel, this.view))) : channel && (Object.assign(this.spec.encode[state], channel), Object.values(channel).forEach((channelEncoder) => {
      this.attach(parseEncodeType(channelEncoder, this.view));
    }))), this.commit(), this;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this.spec.encode) && void 0 !== _a ? _a : {};
  }
  animation(animationConfig2) {
    return this.spec.animation = animationConfig2, this;
  }
  animationState(animationState) {
    return this.setFunctionSpec(animationState, "animationState");
  }
  layout(layout2) {
    return this.spec.layout = layout2, this.commit(), this;
  }
  morph(enableMorph, morphKey, morphElementKey) {
    return this.spec.morph = enableMorph, this.spec.morphKey = morphKey, this.spec.morphElementKey = morphElementKey, this;
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []);
    const nextTransforms = parseTransformSpec(transforms, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.spec.transform = transforms, this.commit(), this;
  }
  configure(config2) {
    const keys = ["clip", "clipPath", "zIndex", "interactive", "context", "setCustomizedShape", "large", "largeThreshold", "progressiveStep", "progressiveThreshold", "support3d", "morph", "morphKey", "morphElementKey", "attributeTransforms", "skipTheme", "enableSegments", "stateSort", "graphicName", "overflow"];
    return null === config2 ? (keys.forEach((key) => {
      isNil_default(this.spec[key]) || (this.spec[key] = void 0);
    }), this) : (keys.forEach((key) => {
      isNil_default(config2[key]) || (this.spec[key] = config2[key]);
    }), this);
  }
  context(context) {
    return this.spec.context = context, this._context = context, this;
  }
  isCollectionMark() {
    return CollectionMarkType.includes(this.markType);
  }
  needAnimate() {
    var _a;
    return !(null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) && !isNil_default(this.spec.animation);
  }
  getAllElements() {
    const elements = this.elements.slice();
    return this.elementMap.forEach((element) => {
      element.diffState !== DiffState.exit || elements.includes(element) || elements.push(element);
    }), this.spec.sort && elements.sort((elementA, elementB) => this.spec.sort(elementA.getDatum(), elementB.getDatum())), elements;
  }
  getScales() {
    const scales = {};
    return this.references.forEach((count, ref) => {
      ref.grammarType === GrammarTypeEnum.scale && (scales[ref.id()] = ref.output());
    }), scales;
  }
  getScalesByChannel() {
    const encoders = this.spec.encode;
    if (!encoders) return {};
    const res = {}, params2 = this.parameters();
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      useEncoders && !isFunctionType(useEncoders) && Object.keys(useEncoders).forEach((channel) => {
        isScaleEncode(useEncoders[channel]) && (res[channel] = getGrammarOutput(useEncoders[channel].scale, params2));
      });
    }), res;
  }
  getFieldsByChannel() {
    const encoders = this.spec.encode;
    if (!encoders) return {};
    const res = {};
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      isFunctionType(useEncoders) || Object.keys(useEncoders).forEach((channel) => {
        isFieldEncode(useEncoders[channel]) && (res[channel] = useEncoders[channel].field);
      });
    }), res;
  }
  init(stage, parameters) {
    var _b, _c, _d, _e, _f;
    if (this._delegateEvent || (this._delegateEvent = (event, type) => {
      const extendedEvt = getExtendedEvents(this.view, event, type, EVENT_SOURCE_VIEW), activeElement = event.element;
      (null == activeElement ? void 0 : activeElement.mark) === this && this.emitGrammarEvent(type, extendedEvt, activeElement);
    }, this.initEvent()), null === (_b = this.initAnimate) || void 0 === _b || _b.call(this, this.spec), !this.group) {
      const group = getGrammarOutput(this.spec.group, parameters);
      this.group = group, group && group.appendChild(this);
    }
    const groupGraphicItem = this.group ? this.group.getGroupGraphicItem() : stage.defaultLayer, markIndex = null !== (_e = null === (_d = null === (_c = this.group) || void 0 === _c ? void 0 : _c.children) || void 0 === _d ? void 0 : _d.indexOf(this)) && void 0 !== _e ? _e : 0;
    if (this.markType !== GrammarMarkType.group) {
      if (!this.graphicItem) {
        const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
          pickable: false,
          zIndex: null !== (_f = this.spec.zIndex) && void 0 !== _f ? _f : 0,
          overflow: this.spec.overflow
        });
        (this.spec.support3d || Mark3DType.includes(this.markType)) && graphicItem.setMode("3d"), graphicItem.name = `${this.id() || this.markType}`, this.graphicItem = graphicItem;
      }
      this.graphicParent = this.graphicItem, !groupGraphicItem || this.graphicIndex === markIndex && this.graphicItem.parent === groupGraphicItem || groupGraphicItem.insertIntoKeepIdx(this.graphicItem, markIndex);
    } else this.graphicParent = groupGraphicItem, this.graphicParent.setAttributes({
      overflow: this.spec.overflow
    });
    this.graphicIndex = markIndex;
  }
  update(spec) {
    var _b;
    if (this.emit(HOOK_EVENT.BEFORE_MARK_UPDATE), this._context = this.spec.context, this.isUpdated = true, this.renderContext.progressive || null === (_b = this.updateAnimate) || void 0 === _b || _b.call(this, spec), this.markType !== GrammarMarkType.group) {
      if (isNil_default(spec.zIndex) || this.graphicItem.setAttribute("zIndex", spec.zIndex), isNil_default(spec.clip) || this.graphicItem.setAttribute("clip", spec.clip), !isNil_default(spec.clipPath)) {
        const paths = isArray_default(spec.clipPath) ? spec.clipPath : spec.clipPath(this.elements);
        paths && paths.length ? this.graphicItem.setAttribute("path", paths) : this.graphicItem.setAttributes({
          path: paths,
          clip: false
        });
      }
      isNil_default(spec.overflow) || this.graphicItem.setAttribute("overflow", spec.overflow), this.elementMap.forEach((element) => {
        element.updateGraphicItem();
      });
    } else this.elementMap.forEach((element) => {
      element.updateGraphicItem();
    });
    this.emit(HOOK_EVENT.AFTER_MARK_UPDATE);
  }
  createElement() {
    return new Element(this);
  }
  evaluateJoin(data) {
    var _a, _b, _c, _d;
    this.needClear = true;
    const keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), groupKeyGetter = parseField(null !== (_d = this.spec.groupBy) && void 0 !== _d ? _d : () => DefaultKey), sort = this.spec.sort, isCollectionMark = this.isCollectionMark(), enterElements = new Set(this.elements.filter((element) => element.diffState === DiffState.enter)), elements = [];
    this.differ.setCallback((key, data2, prevData) => {
      var _a2;
      const elementKey = key;
      let element;
      if (isNil_default(data2)) element = this.elementMap.get(elementKey), element && (element.diffState = DiffState.exit);
      else if (isNil_default(prevData)) {
        if (element = this.elementMap.has(elementKey) ? this.elementMap.get(elementKey) : this.createElement(), element.diffState === DiffState.exit) {
          element.diffState = DiffState.enter;
          const animators = null === (_a2 = this.animate) || void 0 === _a2 ? void 0 : _a2.getElementAnimators(element, DiffState.exit);
          animators && animators.forEach((animator) => animator.stop("start"));
        }
        element.diffState = DiffState.enter;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter), this.elementMap.set(elementKey, element), elements.push(element);
      } else if (element = this.elementMap.get(elementKey), element) {
        element.diffState = DiffState.update;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter), elements.push(element);
      }
      enterElements.delete(element);
    });
    const currentData = null != data ? data : DefaultMarkData;
    isCollectionMark ? this.differ.setCurrentData(this._groupedData) : this.differ.setCurrentData(groupData(currentData, (datum) => `${groupKeyGetter(datum)}-${keyGetter(datum)}`, void 0)), this.differ.doDiff(), enterElements.forEach((element) => {
      this.elementMap.delete(isCollectionMark ? element.groupKey : `${element.groupKey}-${element.key}`), element.remove(), element.release();
    }), this.elements = elements, sort && this.elements.length >= 2 && this.elements.sort((elementA, elementB) => sort(elementA.getDatum(), elementB.getDatum()));
  }
  evaluateState(elements, stateSpec, parameters) {
    stateSpec && elements.forEach((element) => {
      element.state(stateSpec, parameters);
    });
  }
  evaluateGroupEncode(elements, groupEncode, parameters) {
    if (!this._groupedData || !groupEncode) return;
    const res = {};
    return this._groupedData.keys.forEach((key) => {
      const el = elements.find((el2) => el2.groupKey === key);
      el && (res[key] = invokeEncoder(groupEncode, el.items && el.items[0] && el.items[0].datum, el, parameters));
    }), this._groupEncodeResult = res, res;
  }
  getChannelsFromConfig(element) {
    const spec = this.spec;
    return isNil_default(spec.interactive) ? null : {
      pickable: spec.interactive
    };
  }
  evaluateEncode(elements, encoders, parameters, noGroupEncode) {
    const initAttrs = this.getChannelsFromConfig();
    if (encoders) {
      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
      const groupEncodeAttrs = noGroupEncode ? null : this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
      elements.forEach((element) => {
        this.markType === GrammarMarkType.glyph && this._groupEncodeResult ? element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, this._groupEncodeResult[element.groupKey]);
        }) : (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && !this.isCollectionMark() ? element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, groupEncodeAttrs[element.groupKey]);
        }) : initAttrs && element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs);
        }), element.encodeItems(element.items, encoders, this._isReentered, parameters), this.isCollectionMark() && (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && isValid_default(groupEncodeAttrs[element.groupKey].defined) && (element.items.forEach((item) => {
          item.nextAttrs.defined = groupEncodeAttrs[element.groupKey].defined;
        }), delete groupEncodeAttrs[element.groupKey].defined);
      }), this._isReentered = false, this.evaluateTransform(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
        element.encodeGraphic(this.isCollectionMark() ? null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey] : null);
      }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
    } else elements.forEach((element) => {
      element.initGraphicItem(initAttrs);
    });
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    var _a;
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem) {
      if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) {
        let group;
        if (this._groupedData) {
          const index = this._groupedData.keys.indexOf(groupKey);
          index >= 0 && (group = this.graphicParent.getChildAt(index));
        } else group = this.graphicParent.at(0);
        this.isCollectionMark() ? (graphicItem.incremental = 1, group.appendChild(graphicItem)) : group.incrementalAppendChild(graphicItem);
      } else this.graphicParent.appendChild(graphicItem);
      return graphicItem;
    }
  }
  parseRenderContext(data, parameters) {
    const enableProgressive = this.markType !== GrammarMarkType.group && this.spec.progressiveStep > 0 && this.spec.progressiveThreshold > 0 && this.spec.progressiveStep < this.spec.progressiveThreshold, large = this.spec.large && this.spec.largeThreshold > 0 && data.length >= this.spec.largeThreshold;
    if (enableProgressive) {
      const groupedData = this._groupedData;
      return groupedData && groupedData.keys && groupedData.keys.some((key) => groupedData.data.get(key).length > this.spec.progressiveThreshold) ? {
        large,
        parameters,
        progressive: {
          data,
          step: this.spec.progressiveStep,
          currentIndex: 0,
          totalStep: groupedData.keys.reduce((total, key) => Math.max(Math.ceil(groupedData.data.get(key).length / this.spec.progressiveStep), total), 1),
          groupedData: groupedData.data
        }
      } : {
        large
      };
    }
    return {
      large
    };
  }
  isProgressive() {
    return this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive);
  }
  canAnimateAfterProgressive() {
    return this.renderContext && this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.canAnimate();
  }
  isDoingProgressive() {
    return this.renderContext && (this.renderContext.progressive && this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep || this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished());
  }
  clearProgressive() {
    this.renderContext && this.renderContext.progressive && (this.elements = [], this.graphicParent.children.forEach((group) => {
      group.incrementalClearChild();
    }), this.graphicParent.removeAllChild()), this.renderContext && this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.release(), this.renderContext = null;
  }
  restartProgressive() {
    this.renderContext && this.renderContext.progressive && (this.renderContext.progressive.currentIndex = 0);
  }
  evaluateJoinProgressive() {
    var _a, _b, _c;
    const currentIndex = this.renderContext.progressive.currentIndex, keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), elements = [];
    if (this.isCollectionMark()) return this._groupedData.keys.forEach((key, index) => {
      const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);
      if (0 === currentIndex) {
        const element = this.createElement();
        element.diffState = DiffState.enter, element.updateData(key, dataSlice, keyGetter), elements.push(element);
      } else {
        const element = this.elements[index];
        element.updateData(key, dataSlice, keyGetter), elements.push(element);
      }
    }), elements;
    const groupElements = {};
    return this._groupedData.keys.forEach((key) => {
      const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep), group = [];
      dataSlice.forEach((entry) => {
        const element = this.createElement();
        element.diffState = DiffState.enter, element.updateData(key, [entry], keyGetter), group.push(element), elements.push(element);
      }), groupElements[key] = group;
    }), {
      groupElements,
      elements
    };
  }
  evaluateEncodeProgressive(elements, encoders, parameters) {
    const progressiveIndex = this.renderContext.progressive.currentIndex;
    if (0 === progressiveIndex) {
      if (this.evaluateEncode(elements, encoders, parameters), 0 === progressiveIndex && this._groupEncodeResult && !this.isCollectionMark() && this.markType !== GrammarMarkType.glyph) {
        const firstElement = elements[0], firstChild = firstElement.getGraphicItem(), group = null == firstChild ? void 0 : firstChild.parent;
        group && this._groupEncodeResult[firstElement.groupKey] && group.setTheme({
          common: this._groupEncodeResult[firstElement.groupKey]
        });
      }
    } else this.evaluateEncode(elements, encoders, parameters, true);
  }
  evaluateProgressive() {
    var _a, _b, _c;
    if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.beforeTransformProgressive) {
      const transform30 = this.renderContext.beforeTransformProgressive;
      transform30.progressiveRun();
      const output = transform30.output();
      if (transform30.canAnimate) {
        if (transform30.unfinished()) return;
        this.evaluateGroup(output);
      }
      return this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(output), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters), void this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    }
    if (!(null === (_b = this.renderContext) || void 0 === _b ? void 0 : _b.progressive)) return;
    const parameters = this.renderContext.parameters;
    this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);
    const result2 = this.evaluateJoinProgressive(), elements = Array.isArray(result2) ? result2 : result2.elements;
    if (this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 0 === this.renderContext.progressive.currentIndex ? (this.graphicParent.removeAllChild(), this._groupedData.keys.forEach((key) => {
      const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
        pickable: false,
        zIndex: this.spec.zIndex
      });
      graphicItem.incremental = this.renderContext.progressive.step, this.graphicParent.appendChild(graphicItem);
    }), this.elements = elements) : this.elements = this.elements.concat(elements), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), Array.isArray(result2)) this.evaluateEncodeProgressive(elements, this._getEncoders(), parameters);
    else {
      const groupElements = result2.groupElements;
      Object.keys(groupElements).forEach((key) => {
        this.evaluateEncodeProgressive(groupElements[key], this._getEncoders(), parameters);
      });
    }
    this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    const progressiveTransforms = null === (_c = this._getTransformsAfterEncode()) || void 0 === _c ? void 0 : _c.filter((entry) => true === entry.canProgressive);
    (null == progressiveTransforms ? void 0 : progressiveTransforms.length) && this.evaluateTransform(progressiveTransforms, this.elements, parameters), this.renderContext.progressive.currentIndex += 1;
  }
  isLargeMode() {
    return this.renderContext && this.renderContext.large;
  }
  cleanExitElements() {
    this.elementMap.forEach((element, key) => {
      element.diffState !== DiffState.exit || element.isReserved || (this.elementMap.delete(key), element.remove(), element.release());
    });
  }
  getGroupGraphicItem() {
    if (this.elements && this.elements[0] && this.elements[0].getGraphicItem) return this.elements[0].getGraphicItem();
  }
  getBounds() {
    var _a;
    return this.graphicItem ? this.graphicItem.AABBBounds : null === (_a = this.getGroupGraphicItem()) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getMorphConfig() {
    var _a;
    return {
      morph: null !== (_a = this.spec.morph) && void 0 !== _a && _a,
      morphKey: this.spec.morphKey,
      morphElementKey: this.spec.morphElementKey
    };
  }
  getAttributeTransforms() {
    var _a;
    return null !== (_a = this.spec.attributeTransforms) && void 0 !== _a ? _a : transformsByType[this.markType];
  }
  getContext() {
    return this._context;
  }
  needSkipBeforeLayout() {
    var _a, _b;
    if (true === (null === (_a = this.spec.layout) || void 0 === _a ? void 0 : _a.skipBeforeLayouted)) return true;
    let group = this.group;
    for (; group; ) {
      if (true === (null === (_b = group.getSpec().layout) || void 0 === _b ? void 0 : _b.skipBeforeLayouted)) return true;
      group = group.group;
    }
    return false;
  }
  initEvent() {
    if (this._delegateEvent) {
      const stage = this.view.renderer.stage();
      stage && stage.on("*", this._delegateEvent);
    }
  }
  releaseEvent() {
    if (this._delegateEvent) {
      const stage = this.view.renderer.stage();
      stage && stage.off("*", this._delegateEvent);
    }
  }
  clear() {
    var _a;
    this.releaseEvent(), this.transforms = null, this.elementMap = null, this.elements = null, this.graphicItem = null, this.animate = null, null === (_a = this.group) || void 0 === _a || _a.removeChild(this), this.group = null, super.clear();
  }
  prepareRelease() {
    var _a;
    this.differ.setCurrentData(null), null === (_a = this.animate) || void 0 === _a || _a.stop(), this.elementMap.forEach((element) => element.diffState = DiffState.exit), this._finalParameters = this.parameters();
  }
  release() {
    this.releaseEvent(), this.elements.forEach((element) => element.release()), this.differ = null, this.elements = [], this.elementMap.clear(), this._finalParameters = null, this.animate && this.animate.release(), this.graphicItem && removeGraphicItem(this.graphicItem), this.detachAll(), super.release();
  }
};

// node_modules/@visactor/vgrammar-core/es/view/group.js
var GroupMark = class extends Mark {
  constructor(view, group) {
    super(view, GrammarMarkType.group, group), this.children = [];
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  appendChild(mark) {
    return this.children.push(mark), this;
  }
  removeChild(mark) {
    return this.children = this.children.filter((child) => child !== mark), this;
  }
  includesChild(mark, descendant = true) {
    return !!this.children.includes(mark) || !!descendant && this.children.some((child) => child.markType === GrammarMarkType.group && child.includesChild(mark, true));
  }
  updateLayoutChildren() {
    return this.children.length ? (this.layoutChildren || (this.layoutChildren = []), this.layoutChildren = this.children.filter((child) => child.needLayout()), this) : this;
  }
  getAttributeTransforms() {
    return transformsByType.rect;
  }
  evaluateJoin(data) {
    if (!this.elements.length) {
      const el = this.createElement();
      el.updateData(DefaultKey, DefaultMarkData, () => ""), this.elements = [el], this.elementMap.set(DefaultKey, el);
    }
  }
  getChannelsFromConfig(element) {
    const spec = this.spec, initAttrs = {};
    if (isNil_default(spec.clip) || (initAttrs.clip = spec.clip), isNil_default(spec.zIndex) || (initAttrs.zIndex = spec.zIndex), !isNil_default(spec.clipPath)) {
      const paths = isFunction_default(spec.clipPath) ? spec.clipPath([element]) : spec.clipPath;
      paths && paths.length ? initAttrs.path = paths : (initAttrs.path = null, initAttrs.clip = false);
    }
    return isNil_default(spec.interactive) || (initAttrs.pickable = spec.interactive), initAttrs;
  }
  evaluateGroupEncode(elements, groupEncode, parameters) {
    var _a;
    const el = this.elements[0], nextAttrs = {}, items = [Object.assign({}, null === (_a = el.items) || void 0 === _a ? void 0 : _a[0], {
      nextAttrs
    })];
    return invokeEncoderToItems(el, items, groupEncode, parameters), this._groupEncodeResult = nextAttrs, nextAttrs;
  }
  evaluateEncode(elements, encoders, parameters, noGroupEncode) {
    const initAttrs = this.getChannelsFromConfig();
    if (encoders) {
      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
      const groupEncodeAttrs = noGroupEncode ? null : this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
      elements.forEach((element) => {
        element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, groupEncodeAttrs);
        }), element.encodeItems(element.items, encoders, this._isReentered, parameters);
      }), this._isReentered = false, this.evaluateTransform(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
        element.encodeGraphic();
      }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
    } else elements.forEach((element) => {
      element.initGraphicItem(initAttrs);
    });
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem) return this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK, {
      graphicItem
    }), graphicItem.name = `${this.id() || this.markType}`, this.graphicParent.insertIntoKeepIdx(graphicItem, this.graphicIndex), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK, {
      graphicItem
    }), graphicItem;
  }
};

// node_modules/@visactor/vgrammar-core/es/view/grammar-record.js
var RecordedGrammars = class {
  constructor(mapKey, warningWhenDuplicated) {
    this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    }, this._size = 0, this._mapKey = isString_default(mapKey) ? (grammar) => grammar[mapKey] : mapKey, this._warning = warningWhenDuplicated;
  }
  record(grammar) {
    var _a, _b;
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType].push(grammar), isNil_default(key) || (this._grammarMap[grammarType][key] ? null === (_a = this._warning) || void 0 === _a || _a.call(this, key, grammar) : this._grammarMap[grammarType][key] = grammar)) : (this._grammars.customized.push(grammar), isNil_default(key) || (this._grammarMap.customized[key] ? null === (_b = this._warning) || void 0 === _b || _b.call(this, key, grammar) : this._grammarMap.customized[key] = grammar)), this._size += 1, this;
  }
  unrecord(grammar) {
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType] = this._grammars[grammarType].filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap[grammarType][key] !== grammar || delete this._grammarMap[grammarType][key]) : (this._grammars.customized = this._grammars.customized.filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap.customized[key] !== grammar || delete this._grammarMap.customized[key]), this._size -= 1, this;
  }
  size() {
    return this._size;
  }
  getSignal(key) {
    var _a;
    return null !== (_a = this._grammarMap.signal[key]) && void 0 !== _a ? _a : null;
  }
  getData(key) {
    var _a;
    return null !== (_a = this._grammarMap.data[key]) && void 0 !== _a ? _a : null;
  }
  getScale(key) {
    var _a;
    return null !== (_a = this._grammarMap.scale[key]) && void 0 !== _a ? _a : null;
  }
  getCoordinate(key) {
    var _a;
    return null !== (_a = this._grammarMap.coordinate[key]) && void 0 !== _a ? _a : null;
  }
  getMark(key) {
    var _a;
    return null !== (_a = this._grammarMap.mark[key]) && void 0 !== _a ? _a : null;
  }
  getCustomized(key) {
    var _a;
    return null !== (_a = this._grammarMap.customized[key]) && void 0 !== _a ? _a : null;
  }
  getGrammar(key) {
    return this._grammarMap.data[key] ? this._grammarMap.data[key] : this._grammarMap.signal[key] ? this._grammarMap.signal[key] : this._grammarMap.scale[key] ? this._grammarMap.scale[key] : this._grammarMap.coordinate[key] ? this._grammarMap.coordinate[key] : this._grammarMap.mark[key] ? this._grammarMap.mark[key] : this._grammarMap.customized[key] ? this._grammarMap.customized[key] : null;
  }
  getAllSignals() {
    return this._grammars.signal;
  }
  getAllData() {
    return this._grammars.data;
  }
  getAllScales() {
    return this._grammars.scale;
  }
  getAllCoordinates() {
    return this._grammars.coordinate;
  }
  getAllMarks() {
    return this._grammars.mark;
  }
  getAllCustomized() {
    return this._grammars.customized;
  }
  traverse(func) {
    var _a;
    Object.values(null !== (_a = this._grammars) && void 0 !== _a ? _a : {}).forEach((grammars) => (null != grammars ? grammars : []).forEach((grammar) => {
      func.call(null, grammar);
    }));
  }
  find(func) {
    let targetGrammar = null;
    return this.traverse((grammar) => true === func.call(null, grammar) && (targetGrammar = grammar, true)), targetGrammar;
  }
  filter(func) {
    const targetGrammars = [];
    return this.traverse((grammar) => {
      true === func.call(null, grammar) && targetGrammars.push(grammar);
    }), targetGrammars;
  }
  clear() {
    this._size = 0, this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    };
  }
  release() {
    this._size = 0, this._grammars = null, this._grammarMap = null;
  }
};
var RecordedTreeGrammars = class extends RecordedGrammars {
  constructor() {
    super(...arguments), this._markNodes = [];
  }
  record(grammar) {
    if (super.record(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = {
        mark,
        parent: null,
        children: []
      };
      this._markNodes.forEach((node) => {
        const targetMark = node.mark;
        targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, false) ? (node.children.push(currentNode), currentNode.parent = node) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, false) && (currentNode.children.push(node), node.parent = currentNode);
      }), this._markNodes.push(currentNode);
    }
    return this;
  }
  unrecord(grammar) {
    if (super.unrecord(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = this._markNodes.find((node) => node.mark === mark);
      this._markNodes.forEach((node) => {
        node.mark.markType === GrammarMarkType.group && node.children.includes(currentNode) ? (node.children = node.children.filter((n) => n !== currentNode), currentNode.parent = null) : mark.markType === GrammarMarkType.group && currentNode.children.includes(node) && (currentNode.children = currentNode.children.filter((n) => n !== node), node.parent = null);
      }), this._markNodes = this._markNodes.filter((n) => n !== currentNode);
    }
    return this;
  }
  getAllMarkNodes() {
    return this._markNodes;
  }
  clear() {
    super.clear(), this._markNodes = [];
  }
  release() {
    super.release(), this._markNodes = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/text.js
var Text2 = class extends Mark {
  addGraphicItem(initAttrs, groupKey) {
    const originalAttrs = initAttrs && initAttrs.limitAttrs, isRich = originalAttrs && ("rich" === originalAttrs.textType || originalAttrs.text && "rich" === originalAttrs.text.type), graphicItem = createGraphicItem(this, isRich ? GrammarMarkType.richtext : GrammarMarkType.text, initAttrs);
    return super.addGraphicItem(initAttrs, groupKey, graphicItem);
  }
  release() {
    super.release();
  }
};
Text2.markType = GrammarMarkType.text;

// node_modules/@visactor/vgrammar-core/es/theme/common/component.js
var axis = {
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#89909d",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 100,
    y: 0
  },
  x: 0,
  y: 0
};
var circleAxis = {
  title: {
    space: 4,
    padding: [0, 0, 0, 0],
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    },
    text: "theta"
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#6F6F6F",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  startAngle: 0,
  endAngle: 2 * Math.PI,
  radius: 100,
  innerRadius: 0,
  center: {
    x: 0,
    y: 0
  },
  x: 0,
  y: 0
};
var grid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var circleGrid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var discreteLegend2 = {
  layout: "vertical",
  title: {
    align: "start",
    space: 12,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: 10,
    spaceRow: 10,
    shape: {
      space: 4,
      style: {
        size: 10,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    label: {
      space: 4,
      style: {
        fontSize: 12,
        fill: "black",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          fillOpacity: 0.7,
          fill: "gray"
        },
        unSelectedHover: {
          fillOpacity: 0.2,
          fill: "gray"
        }
      }
    },
    focus: false,
    focusIconStyle: {
      size: 10,
      fill: "#333",
      cursor: "pointer"
    },
    visible: true,
    padding: {
      top: 2,
      bottom: 2,
      left: 2,
      right: 2
    }
  },
  autoPage: true,
  pager: {
    space: 12,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: false,
  items: [{
    index: 0,
    id: "",
    label: "",
    shape: {
      fill: "#6690F2",
      stroke: "#6690F2",
      symbolType: "circle"
    }
  }]
};
var colorLegend2 = {
  title: {
    visible: false,
    text: ""
  },
  colors: [],
  layout: "horizontal",
  railWidth: 200,
  railHeight: 8,
  railStyle: {
    cornerRadius: 5
  }
};
var sizeLegend2 = {
  title: {
    visible: false,
    text: ""
  },
  trackStyle: {
    fill: "#ccc"
  },
  layout: "horizontal",
  align: "bottom",
  railWidth: 200,
  railHeight: 6,
  min: 0,
  max: 1,
  value: [0, 1]
};
var lineCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  }
};
var rectCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  },
  rectStyle: {
    width: 10,
    height: 10
  }
};
var sectorCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: Math.PI / 6
};
var circleCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var polygonCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI,
  sides: 6
};
var slider = {
  layout: "horizontal",
  railWidth: 200,
  railHeight: 10,
  railStyle: {
    cornerRadius: 5
  },
  range: {
    draggableTrack: true
  },
  startText: {
    visible: true,
    text: "",
    space: 8
  },
  endText: {
    visible: true,
    text: "",
    space: 8
  },
  min: 0,
  max: 1,
  value: [0, 1]
};
var dataLabel = {
  size: {
    width: 400,
    height: 400
  },
  dataLabels: []
};
var lineDataLabel = {
  type: "line-data",
  data: [{
    text: ""
  }],
  position: "top",
  overlap: {
    avoidBaseMark: false,
    clampForce: false
  },
  smartInvert: false
};
var lineLabel = {
  type: "line",
  data: [{
    text: "",
    data: {}
  }],
  position: "start",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var areaLabel = {
  type: "area",
  data: [{
    text: "",
    data: {}
  }],
  position: "end",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var rectLabel = {
  type: "rect",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var symbolLabel = {
  type: "symbol",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    avoidBaseMark: true,
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var arcLabel = {
  type: "arc",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  width: 800,
  height: 600,
  position: "outside",
  zIndex: 302
};
var pointLabel = {
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var datazoom = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  start: 0,
  end: 1,
  position: {
    x: 0,
    y: 0
  },
  size: {
    width: 500,
    height: 40
  },
  previewData: []
};
var continuousPlayer = {};
var discretePlayer = {};
var tooltip2 = {};
var title2 = {
  textStyle: {
    fill: "#21252c"
  },
  subtextStyle: {
    fill: "#606773"
  }
};
var scrollbar = {
  width: 12,
  height: 12,
  padding: [2, 2],
  railStyle: {
    fill: "rgba(0, 0, 0, .1)"
  }
};
var defaultComponentTheme = {
  axis,
  circleAxis,
  grid,
  circleGrid,
  discreteLegend: discreteLegend2,
  colorLegend: colorLegend2,
  sizeLegend: sizeLegend2,
  lineCrosshair,
  rectCrosshair,
  sectorCrosshair,
  circleCrosshair,
  polygonCrosshair,
  slider,
  dataLabel,
  pointLabel,
  lineLabel,
  areaLabel,
  rectLabel,
  symbolLabel,
  arcLabel,
  lineDataLabel,
  datazoom,
  continuousPlayer,
  discretePlayer,
  tooltip: tooltip2,
  title: title2,
  scrollbar
};

// node_modules/@visactor/vgrammar-core/es/theme/common/constants.js
var DEFAULT_PADDING = 5;

// node_modules/@visactor/vgrammar-core/es/theme/common/mark.js
var defaultMarkTheme = {
  symbol: {
    shape: "circle",
    size: 8
  },
  text: {
    fontSize: 14,
    fill: "#000000"
  }
};

// node_modules/@visactor/vgrammar-core/es/theme/dark.js
var darkComponents = Object.assign({}, defaultComponentTheme);
darkComponents.axis = Object.assign({}, darkComponents.axis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.circleAxis = Object.assign({}, darkComponents.circleAxis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.grid = Object.assign({}, darkComponents.grid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.circleGrid = Object.assign({}, darkComponents.circleGrid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.rectLabel = Object.assign({}, darkComponents.rectLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.lineLabel = Object.assign({}, darkComponents.lineLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.symbolLabel = Object.assign({}, darkComponents.symbolLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.title = Object.assign({}, darkComponents.title, {
  textStyle: {
    fill: "#fdfdfd"
  },
  subtextStyle: {
    fill: "#888c93"
  }
});
var darkTheme2 = {
  name: "dark",
  padding: DEFAULT_PADDING,
  background: "#202226",
  palette: {
    default: ["#5383F4", "#7BCF8E", "#FF9D2C", "#FFDB26", "#7568D9", "#80D8FB", "#1857A3", "#CAB0E8", "#FF8867", "#B9E493", "#2CB4A8", "#B9E4E3"]
  },
  marks: defaultMarkTheme,
  components: darkComponents
};

// node_modules/@visactor/vgrammar-core/es/theme/default.js
var defaultTheme = {
  name: "default",
  padding: DEFAULT_PADDING,
  palette: {
    default: ["#6690F2", "#70D6A3", "#B4E6E2", "#63B5FC", "#FF8F62", "#FFDC83", "#BCC5FD", "#A29BFE", "#63C4C7", "#F68484"]
  },
  marks: defaultMarkTheme,
  components: defaultComponentTheme
};

// node_modules/@visactor/vgrammar-core/es/theme/theme-manager.js
var ThemeManager2 = class _ThemeManager {
  static registerTheme(name, theme2) {
    name && _ThemeManager._themes.set(name, theme2);
  }
  static unregisterTheme(name) {
    _ThemeManager._themes.delete(name);
  }
  static getTheme(name) {
    return _ThemeManager._themes.get(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.getTheme("default");
  }
};
ThemeManager2._themes = /* @__PURE__ */ new Map(), ThemeManager2.registerTheme("default", defaultTheme), ThemeManager2.registerTheme("dark", darkTheme2);

// node_modules/@visactor/vgrammar-core/es/view/component.js
var Component = class extends Mark {
  constructor(view, componentType, group, mode) {
    super(view, GrammarMarkType.component, group), this._componentDatum = {
      [DefaultKey]: 0
    }, this.componentType = componentType, this.spec.type = "component", this.spec.componentType = componentType, this.mode = mode, this._updateComponentEncoders();
  }
  configureComponent(config2) {
    return this.spec.componentConfig = config2, this.commit(), this;
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : Factory3.createGraphicComponent(this.componentType, attrs, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return graphicItem && (this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK, {
      graphicItem
    }), this.graphicParent.appendChild(graphicItem), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK, {
      graphicItem
    })), graphicItem;
  }
  join(data) {
    return super.join(data, DefaultKey);
  }
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(), this;
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  _prepareRejoin() {
    this._componentDatum[DefaultKey] += 1;
  }
  evaluateJoin(data) {
    return this.spec.key = DefaultKey, data ? (data[DefaultKey] = this._componentDatum[DefaultKey], this._componentDatum = data) : this._componentDatum = {
      [DefaultKey]: this._componentDatum[DefaultKey]
    }, super.evaluateJoin([this._componentDatum]);
  }
  _updateComponentEncoders() {
    this._encoders = this.spec.encode;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/view-diff.js
var EmptyKey = Symbol.for("key");
var ViewDiff = class {
  diffGrammar(prevGrammars, nextGrammars) {
    return diffSingle(prevGrammars, nextGrammars, (grammar) => {
      var _a;
      return null !== (_a = grammar.id()) && void 0 !== _a ? _a : Symbol();
    });
  }
  diffMark(prevMarks, nextMarks, runningConfig) {
    const diffResult = {
      enter: [],
      exit: [],
      update: []
    };
    let prevDiffMarks = [], nextDiffMarks = [];
    prevMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? prevDiffMarks.push(mark) : diffResult.exit.push({
        prev: [mark]
      });
    }), nextMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? nextDiffMarks.push(mark) : diffResult.enter.push({
        next: [mark]
      });
    });
    const keyDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.getMorphConfig().morphKey, (mark) => mark.getMorphConfig().morphKey);
    prevDiffMarks = keyDiffResult.prev, nextDiffMarks = keyDiffResult.next, diffResult.update = diffResult.update.concat(keyDiffResult.update);
    const nameDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.id(), (mark) => mark.id());
    prevDiffMarks = nameDiffResult.prev, nextDiffMarks = nameDiffResult.next, diffResult.update = diffResult.update.concat(nameDiffResult.update);
    const prevParentGroup = groupData(prevDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    }), nextParentGroup = groupData(nextDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    });
    return Object.keys(nextParentGroup).forEach((groupName) => {
      const prevChildren = prevParentGroup.data.get(groupName), nextChildren = nextParentGroup.data.get(groupName);
      if (prevChildren && nextChildren) {
        for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {
          const prevChild = prevChildren[i], nextChild = nextChildren[i];
          prevChild && nextChild ? diffResult.update.push({
            prev: [prevChild],
            next: [nextChild]
          }) : prevChild ? diffResult.exit.push({
            prev: [prevChild]
          }) : nextChild && diffResult.enter.push({
            next: [nextChild]
          });
        }
        prevDiffMarks = prevDiffMarks.filter((mark) => !prevChildren.includes(mark)), nextDiffMarks = nextDiffMarks.filter((mark) => !nextChildren.includes(mark));
      }
    }), prevDiffMarks.forEach((mark) => diffResult.exit.push({
      prev: [mark]
    })), nextDiffMarks.forEach((mark) => diffResult.enter.push({
      next: [mark]
    })), diffResult;
  }
  diffUpdateByGroup(prev, next, prevKey, nextKey) {
    const prevGroup = groupData(prev, (datum) => {
      var _a;
      return null !== (_a = prevKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    }), nextGroup = groupData(next, (datum) => {
      var _a;
      return null !== (_a = nextKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    });
    let prevAfterDiff = prev, nextAfterDiff = next;
    const update3 = [];
    return nextGroup.keys.forEach((key) => {
      if (key !== EmptyKey) {
        const prevKeyData = prevGroup.data.get(key), nextKeyData = nextGroup.data.get(key);
        prevKeyData && nextKeyData && (update3.push({
          prev: prevKeyData,
          next: nextKeyData
        }), prevAfterDiff = prevAfterDiff.filter((datum) => !prevKeyData.includes(datum)), nextAfterDiff = nextAfterDiff.filter((datum) => !nextKeyData.includes(datum)));
      }
    }), {
      prev: prevAfterDiff,
      next: nextAfterDiff,
      update: update3
    };
  }
};

// node_modules/@visactor/vgrammar-core/es/view/View.js
var View = class extends import_eventemitter3.default {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      fn();
    });
  }
  constructor(options = {}, config2 = {}) {
    super(), this._observer = null, this._onResize = debounce_default((...args) => {
      const size = this._getContainerSize();
      size && this.resize(size.width, size.height);
    }, 100), this.delegateEvent = (event, type) => {
      const extendedEvt = getExtendedEvents(this, event, type, EVENT_SOURCE_VIEW);
      this.emit(type, extendedEvt, event.element);
    }, this.handleProgressiveFrame = () => {
      this._progressiveMarks.length && this._progressiveMarks.forEach((mark) => {
        mark.isDoingProgressive() && mark.evaluateProgressive();
      }), this.doPreProgressive();
    }, this._config = config2, this._options = Object.assign({
      mode: BROWSER
    }, options), this.initialize();
  }
  getGrammarById(id) {
    return this.grammars.getGrammar(id);
  }
  getSignalById(id) {
    return this.grammars.getSignal(id);
  }
  getDataById(id) {
    return this.grammars.getData(id);
  }
  getScaleById(id) {
    return this.grammars.getScale(id);
  }
  getCoordinateById(id) {
    return this.grammars.getCoordinate(id);
  }
  getMarkById(id) {
    return this.grammars.getMark(id);
  }
  getCustomizedById(id) {
    return this.grammars.getCustomized(id);
  }
  getGrammarsByName(name) {
    return this.grammars.filter((grammar) => grammar.name() === name);
  }
  getGrammarsByType(grammarType) {
    return this.grammars.filter((grammar) => grammar.grammarType === grammarType);
  }
  getMarksByType(markType) {
    return this.grammars.getAllMarks().filter((mark) => mark.markType === markType);
  }
  getMarksByName(name) {
    return this.grammars.getAllMarks().filter((mark) => mark.name() === name);
  }
  getMarksBySelector(selector) {
    if (!selector) return null;
    const selectors = array(selector), res = [];
    return selectors.forEach((selectorStr) => {
      if (isGrammar(selectorStr)) return void res.push(selectorStr);
      if (selectorStr[0] === ID_PREFIX) {
        const mark = this.getMarkById(selectorStr.slice(1));
        return void (mark && res.push(mark));
      }
      const marks = selectorStr[0] === NAME_PREFIX ? this.getMarksByName(selectorStr.slice(1)) : isMarkType(selectorStr) ? this.getMarksByType(selectorStr) : null;
      marks && marks.length && marks.forEach((mark) => {
        res.push(mark);
      });
    }), res;
  }
  updateSignal(signal, value) {
    isString_default(signal) && (signal = this.getSignalById(signal)), signal.set(value), this.commit(signal);
  }
  signal(value, update3) {
    const signal = new Signal(this);
    return arguments.length >= 1 && signal.value(value), arguments.length >= 2 && signal.update(update3), this.grammars.record(signal), this._dataflow.add(signal), signal;
  }
  data(values) {
    const data = new Data(this, values);
    return this.grammars.record(data), this._dataflow.add(data), data;
  }
  scale(type) {
    const scale4 = Factory3.createGrammar("scale", this, type);
    return scale4 && (this.grammars.record(scale4), this._dataflow.add(scale4)), scale4;
  }
  coordinate(type) {
    const coordinate = Factory3.createGrammar("coordinate", this, type);
    return coordinate && (this.grammars.record(coordinate), this._dataflow.add(coordinate)), coordinate;
  }
  mark(type, group, markOptions) {
    const groupMark = isString_default(group) ? this.getMarkById(group) : group;
    let mark;
    switch (type) {
      case GrammarMarkType.group:
        mark = new GroupMark(this, groupMark);
        break;
      case GrammarMarkType.glyph:
        const GlyphMark2 = Factory3.getMark(GrammarMarkType.glyph);
        GlyphMark2 && (mark = new GlyphMark2(this, null == markOptions ? void 0 : markOptions.glyphType, groupMark));
        break;
      case GrammarMarkType.component:
        mark = Factory3.hasComponent(null == markOptions ? void 0 : markOptions.componentType) ? Factory3.createComponent(null == markOptions ? void 0 : markOptions.componentType, this, groupMark, null == markOptions ? void 0 : markOptions.mode) : new Component(this, null == markOptions ? void 0 : markOptions.componentType, groupMark, null == markOptions ? void 0 : markOptions.mode);
        break;
      case GrammarMarkType.text:
        mark = new Text2(this, type, groupMark);
        break;
      default:
        mark = Factory3.hasMark(type) ? Factory3.createMark(type, this, groupMark) : new Mark(this, type, groupMark);
    }
    return this.grammars.record(mark), this._dataflow.add(mark), mark;
  }
  group(group) {
    return this.mark(GrammarMarkType.group, group);
  }
  glyph(glyphType, group) {
    return this.mark(GrammarMarkType.glyph, group, {
      glyphType
    });
  }
  component(componentType, group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType,
      mode
    });
  }
  axis(group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.axis,
      mode
    });
  }
  grid(group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.grid,
      mode
    });
  }
  legend(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.legend
    });
  }
  slider(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.slider
    });
  }
  label(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.label
    });
  }
  datazoom(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.datazoom
    });
  }
  player(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.player
    });
  }
  title(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.title
    });
  }
  scrollbar(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.scrollbar
    });
  }
  customized(type, spec) {
    const grammar = Factory3.createGrammar(type, this, null == spec ? void 0 : spec.type);
    if (grammar) return grammar.parse(spec), this.grammars.record(grammar), this._dataflow.add(grammar), grammar;
  }
  addGrammar(grammar) {
    return this.grammars.find((storedGrammar) => storedGrammar.uid === grammar.uid) || (this.grammars.record(grammar), this._dataflow.add(grammar), grammar.parse(grammar.getSpec()), this._needBuildLayoutTree = true), this;
  }
  removeGrammar(grammar) {
    const recordedGrammar = isString_default(grammar) ? this.getGrammarById(grammar) : grammar;
    return recordedGrammar && this.grammars.find((storedGrammar) => storedGrammar.uid === recordedGrammar.uid) ? ("mark" === recordedGrammar.grammarType && recordedGrammar.prepareRelease(), this._cachedGrammars.record(recordedGrammar), this._dataflow.remove(recordedGrammar), this.grammars.unrecord(recordedGrammar), this._needBuildLayoutTree = true, this) : this;
  }
  removeAllGrammars() {
    return this.grammars.traverse((grammar) => {
      "signal" === grammar.grammarType && BuiltInSignalID.includes(grammar.id()) || "mark" === grammar.grammarType && "root" === grammar.id() || this.removeGrammar(grammar);
    }), this;
  }
  removeAllGraphicItems() {
    return this.traverseMarkTree((mark) => {
      mark.graphicItem && (removeGraphicItem(mark.graphicItem), mark.elementMap.forEach((element) => {
        element.resetGraphicItem();
      }), mark.graphicItem = null);
    }), this;
  }
  parseSpec(spec) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.emit(HOOK_EVENT.BEFORE_PARSE_VIEW), this._spec = spec, normalizeMarkTree(spec), spec.theme ? this.theme(spec.theme) : this.theme(ThemeManager2.getDefaultTheme()), spec.width && this.width(spec.width), spec.height && this.height(spec.height), this.padding(null !== (_b = null !== (_a = spec.padding) && void 0 !== _a ? _a : this._options.padding) && void 0 !== _b ? _b : this._theme.padding), !this.width() || !this.height()) {
      const size = this._getContainerSize();
      size && (this.updateSignal(SIGNAL_WIDTH, size.width), this.updateSignal(SIGNAL_HEIGHT, size.height));
    }
    (null === (_c = spec.signals) || void 0 === _c ? void 0 : _c.length) && spec.signals.forEach((signal) => {
      this.signal().parse(signal);
    }), (null === (_d = spec.data) || void 0 === _d ? void 0 : _d.length) && spec.data.forEach((data) => {
      this.data(null).parse(data);
    }), (null === (_e = spec.coordinates) || void 0 === _e ? void 0 : _e.length) && spec.coordinates.forEach((coordinate) => {
      var _a2;
      null === (_a2 = this.coordinate(coordinate.type)) || void 0 === _a2 || _a2.parse(coordinate);
    }), (null === (_f = spec.scales) || void 0 === _f ? void 0 : _f.length) && spec.scales.forEach((scale4) => {
      var _a2;
      null === (_a2 = this.scale(scale4.type)) || void 0 === _a2 || _a2.parse(scale4);
    });
    const customizedGrammars = Factory3.getGrammars();
    return Object.keys(customizedGrammars).forEach((key) => {
      const { specKey } = customizedGrammars[key];
      spec[specKey] && spec[specKey].length && spec[specKey].forEach((specValue) => {
        this.customized(key, specValue);
      });
    }), spec.marks && spec.marks.length && spec.marks.forEach((mark) => {
      this.parseMarkSpec(mark);
    }), spec.events && spec.events.length && spec.events.forEach((eventConfig) => {
      var _b2;
      null === (_b2 = this.event) || void 0 === _b2 || _b2.call(this, eventConfig);
    }), spec.interactions && spec.interactions.length && spec.interactions.forEach((interaction) => {
      this.interaction(interaction.type, interaction);
    }), false === spec.animation ? null === (_g = this.animate) || void 0 === _g || _g.disable() : null === (_h = this.animate) || void 0 === _h || _h.enable(), this.emit(HOOK_EVENT.AFTER_PARSE_VIEW), this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this;
  }
  updateSpec(spec) {
    return this.removeAllInteractions(), this.removeAllGrammars(), this.parseSpec(spec);
  }
  parseBuiltIn() {
    builtInSignals(this._options, this._config, this.getCurrentTheme()).forEach((signalSpec) => {
      const signal = this.signal().parse(signalSpec);
      signalSpec.value && signal.set(signalSpec.value);
    });
    this.parseMarkSpec({
      id: "root",
      type: "group",
      encode: {
        enter: {
          x: 0,
          y: 0
        },
        update: {
          width: {
            signal: "width"
          },
          height: {
            signal: "height"
          }
        }
      }
    }), this.rootMark = this.getMarkById("root");
  }
  parseMarkSpec(spec) {
    var _a;
    const markOptions = spec.type === GrammarMarkType.glyph ? {
      glyphType: spec.glyphType
    } : spec.type === GrammarMarkType.component ? {
      componentType: spec.componentType,
      mode: spec.mode
    } : null;
    this.mark(spec.type, spec.group, markOptions).parse(spec), null === (_a = spec.marks) || void 0 === _a || _a.forEach((childSpec) => {
      this.parseMarkSpec(childSpec);
    });
  }
  theme(theme2) {
    var _a, _b, _c, _d, _e, _f;
    isString_default(theme2) ? this._theme = null !== (_a = ThemeManager2.getTheme(theme2)) && void 0 !== _a ? _a : ThemeManager2.getDefaultTheme() : this._theme = theme2;
    const { background, padding } = null !== (_b = this._spec) && void 0 !== _b ? _b : {};
    return this._theme ? (this.background(null !== (_c = null != background ? background : this._options.background) && void 0 !== _c ? _c : this._theme.background), this.padding(null !== (_d = null != padding ? padding : this._options.padding) && void 0 !== _d ? _d : this._theme.padding), null === (_f = null === (_e = this.renderer.stage()) || void 0 === _e ? void 0 : _e.setTheme) || void 0 === _f || _f.call(_e, Object.assign({}, this._theme.marks))) : (this.background(null != background ? background : this._options.background), this.padding(null != padding ? padding : this._options.padding)), this;
  }
  getCurrentTheme() {
    return this._theme;
  }
  setCurrentTheme(theme2, render = true) {
    return this.theme(theme2), this.grammars.getAllMarks().forEach((mark) => {
      mark.commit();
    }), render ? (this.evaluate(), this.renderer.render(true)) : this._dataflow.evaluate(), this;
  }
  background(value) {
    return arguments.length ? (this._background = value, this.renderer.background(value), value) : this._background;
  }
  width(value) {
    const signal = this.getSignalById(SIGNAL_WIDTH);
    return arguments.length ? (this._options.width = value, this.updateSignal(signal, value), value) : signal.output();
  }
  height(value) {
    const signal = this.getSignalById(SIGNAL_HEIGHT);
    return arguments.length ? (this._options.height = value, this.updateSignal(signal, value), value) : signal.output();
  }
  viewWidth(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_WIDTH);
    if (arguments.length) {
      const padding = this.padding();
      return this.width(value + padding.left + padding.right), value;
    }
    return signal.output();
  }
  viewHeight(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_HEIGHT);
    if (arguments.length) {
      const padding = this.padding();
      return this.height(value + padding.top + padding.bottom), value;
    }
    return signal.output();
  }
  padding(value) {
    const signal = this.getSignalById(SIGNAL_PADDING);
    if (arguments.length) {
      const padding = normalizePadding2(value);
      return this.updateSignal(signal, padding), padding;
    }
    return normalizePadding2(signal.output());
  }
  autoFit(value) {
    const signal = this.getSignalById(SIGNAL_AUTOFIT);
    return arguments.length ? (this.updateSignal(signal, value), value) : signal.output();
  }
  getViewBox() {
    const signal = this.getSignalById(SIGNAL_VIEW_BOX);
    return null == signal ? void 0 : signal.output();
  }
  updateLayoutTag() {
    return this._layoutState = LayoutState.before, this;
  }
  getLayoutState() {
    return this._layoutState;
  }
  buildLayoutTree() {
    const markMap = {}, rootMarks = [];
    this.traverseMarkTree((mark) => {
      markMap[mark.id()] = true, mark.group && markMap[mark.group.id()] || rootMarks.push(mark), mark.markType === GrammarMarkType.group && mark.updateLayoutChildren();
    }, (mark) => mark.needLayout()), this._layoutMarks = rootMarks;
  }
  doLayout() {
    var _a;
    const doLayout = this._options.doLayout || Factory3.getDefaultLayout();
    doLayout && (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && (this.emit(HOOK_EVENT.BEFORE_DO_LAYOUT), doLayout(this._layoutMarks, this._options, this), this.emit(HOOK_EVENT.AFTER_DO_LAYOUT));
  }
  handleLayoutEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_LAYOUT_END), this._layoutMarks.forEach((layoutMark) => {
      traverseMarkTree(layoutMark, "layoutChildren", (mark) => {
        mark.handleLayoutEnd();
      }, (mark) => mark !== layoutMark);
    }), this.emit(HOOK_EVENT.AFTER_MARK_LAYOUT_END);
  }
  handleRenderEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_RENDER_END), traverseMarkTree(this.rootMark, "children", (mark) => {
      mark.handleRenderEnd();
    }), this.emit(HOOK_EVENT.AFTER_MARK_RENDER_END);
  }
  commit(grammar) {
    return this._dataflow.commit(grammar), this;
  }
  run(runningConfig) {
    return this.evaluate(runningConfig), this;
  }
  doRender(immediately) {
    this.emit(HOOK_EVENT.BEFORE_DO_RENDER), this.renderer && (!this._progressiveMarks && this.animate ? this.animate.animate() : this.traverseMarkTree((mark) => {
      mark.cleanExitElements();
    }, null, true), this.renderer.render(immediately), this.handleRenderEnd()), this.emit(HOOK_EVENT.AFTER_DO_RENDER);
  }
  evaluate(runningConfig) {
    var _a, _c;
    const normalizedRunningConfig = normalizeRunningConfig(runningConfig), grammarWillDetach = this._cachedGrammars.size() > 0;
    grammarWillDetach && (this.reuseCachedGrammars(normalizedRunningConfig), this.detachCachedGrammar());
    const hasResize = this._resizeRenderer(), hasUpdate = this._dataflow.hasCommitted();
    return grammarWillDetach || hasUpdate || this._layoutState || hasResize ? (this.clearProgressive(), this._dataflow.evaluate(), this._needBuildLayoutTree && (this.buildLayoutTree(), this._needBuildLayoutTree = false), this._layoutState && (this._layoutState = LayoutState.layouting, this.doLayout(), this._dataflow.hasCommitted() && (this._layoutState = LayoutState.reevaluate, this._dataflow.evaluate()), this._layoutState = LayoutState.after, (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && this.handleLayoutEnd()), this._layoutState = null, this.findProgressiveMarks(), this._resizeRenderer(), null === (_c = this.morph) || void 0 === _c || _c.call(this, normalizedRunningConfig), this.releaseCachedGrammars(normalizedRunningConfig), this.doRender(true), this.doPreProgressive(), this) : this;
  }
  reuseCachedGrammars(runningConfig) {
    if (runningConfig.reuse) {
      const reuseDiffUpdate = (diff) => {
        diff.next.reuse(diff.prev), diff.prev.detachAll(), diff.prev.clear(), this._cachedGrammars.unrecord(diff.prev);
      };
      this._differ.diffGrammar(this._cachedGrammars.getAllSignals(), this.grammars.getAllSignals().filter((signal) => !BuiltInSignalID.includes(signal.id()))).update.forEach(reuseDiffUpdate);
      this._differ.diffGrammar(this._cachedGrammars.getAllData(), this.grammars.getAllData()).update.forEach(reuseDiffUpdate);
      this._differ.diffGrammar(this._cachedGrammars.getAllScales(), this.grammars.getAllScales()).update.forEach(reuseDiffUpdate);
      this._differ.diffGrammar(this._cachedGrammars.getAllCoordinates(), this.grammars.getAllCoordinates()).update.forEach(reuseDiffUpdate);
    }
    this._differ.diffMark(this._cachedGrammars.getAllMarks(), this.grammars.getAllMarks().filter((mark) => "root" !== mark.id()), runningConfig).update.forEach((diff) => {
      var _b;
      const matched = 1 === diff.prev.length && 1 === diff.next.length && diff.prev[0].markType === diff.next[0].markType, enableMarkMorphConfig = diff.prev.every((mark) => mark.getMorphConfig().morph) && diff.next.every((mark) => mark.getMorphConfig().morph);
      this.morph && (runningConfig.morph && enableMarkMorphConfig || runningConfig.morphAll) ? null === (_b = this.addMorphMarks) || void 0 === _b || _b.call(this, {
        prev: diff.prev,
        next: diff.next
      }) : matched && runningConfig.reuse && (diff.next[0].reuse(diff.prev[0]), diff.prev[0].detachAll(), diff.prev[0].clear(), this._cachedGrammars.unrecord(diff.prev[0]));
    });
  }
  detachCachedGrammar() {
    this._cachedGrammars.traverse((grammar) => {
      var _a, _b;
      if (grammar.detachAll(), "mark" === grammar.grammarType) {
        const mark = grammar;
        null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.removeChild) || void 0 === _b || _b.call(_a, mark);
      }
    });
  }
  releaseCachedGrammars(runningConfig) {
    this._cachedGrammars.traverse((grammar) => {
      "mark" !== grammar.grammarType && grammar.release();
    });
    const markNodes = this._cachedGrammars.getAllMarkNodes();
    markNodes.forEach((node) => {
      var _a;
      null === (_a = node.mark.animate) || void 0 === _a || _a.stop(), runningConfig.enableExitAnimation && this.animate && this.animate.animateAddition(node.mark);
    });
    const releaseUp = (node) => {
      if (node.mark.view && (!node.mark.animate || 0 === node.mark.animate.getAnimatorCount()) && (!node.children || 0 === node.children.length)) {
        node.mark.release();
        const parent = node.parent;
        parent && (node.parent.children = node.parent.children.filter((n) => n !== node), node.parent = null, releaseUp(parent));
      }
    };
    markNodes.forEach((node) => {
      const mark = node.mark;
      mark.animate && 0 !== mark.animate.getAnimatorCount() ? mark.addEventListener("animationEnd", () => {
        mark.animate && 0 === mark.animate.getAnimatorCount() && releaseUp(node);
      }) : releaseUp(node);
    }), this._cachedGrammars.clear();
  }
  runAfter(callback) {
    return this._dataflow.runAfter(() => {
      callback.call(null, this);
    }), this;
  }
  runBefore(callback) {
    return this._dataflow.runBefore(() => {
      callback.call(null, this);
    }), this;
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._options.mode) return void this.logger.error(new TypeError("getImageBuffer() now only support node environment."));
    const stage = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a);
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return this.logger.error(new ReferenceError("render is not defined")), null;
  }
  traverseMarkTree(apply, filter2, leafFirst) {
    return traverseMarkTree(this.rootMark, "children", apply, filter2, leafFirst), this;
  }
  _bindResizeEvent() {
    var _a, _b, _c, _d, _e, _f;
    if (this.autoFit()) {
      const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
      if (container2) {
        const ResizeObserverWindow = window.ResizeObserver;
        this._observer = new ResizeObserverWindow(this._onResize), null === (_f = this._observer) || void 0 === _f || _f.observe(container2);
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this.autoFit() && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  _getContainerSize() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
    if (container2) {
      const { width: containerWidth, height: containerHeight } = getContainerSize(container2);
      return {
        width: null !== (_h = null !== (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.width) && void 0 !== _g ? _g : this._options.width) && void 0 !== _h ? _h : containerWidth,
        height: null !== (_l = null !== (_k = null === (_j = this._spec) || void 0 === _j ? void 0 : _j.height) && void 0 !== _k ? _k : this._options.height) && void 0 !== _l ? _l : containerHeight
      };
    }
    return null;
  }
  resize(width, height, render = true) {
    let needDataflow = false;
    return width !== this.width() && (needDataflow = true, this.updateSignal(SIGNAL_WIDTH, width)), height !== this.height() && (needDataflow = true, this.updateSignal(SIGNAL_HEIGHT, height)), needDataflow && (render ? this.evaluate({
      morph: false
    }) : this._dataflow.evaluate()), this;
  }
  _resizeRenderer() {
    const width = this.width(), height = this.height();
    return !!this.renderer.shouldResize(width, height) && (this.renderer.resize(width, height), this.emit("resize", {}, {
      width,
      height
    }), true);
  }
  interaction(type, spec) {
    const interaction = Factory3.createInteraction(type, this, spec);
    return interaction && (interaction.bind(), this._boundInteractions || (this._boundInteractions = []), this._boundInteractions.push(interaction)), interaction;
  }
  removeInteraction(type, id) {
    if (this._boundInteractions) {
      const instances = this._boundInteractions.filter((interaction) => {
        var _a;
        return isNil_default(id) ? isString_default(type) ? interaction.type === type : type ? interaction === type : void 0 : (null === (_a = interaction.options) || void 0 === _a ? void 0 : _a.id) === id;
      });
      instances.length && instances.forEach((instance) => {
        instance.unbind();
      });
    }
    return this;
  }
  removeAllInteractions() {
    return this._boundInteractions && (this._boundInteractions.forEach((instance) => {
      instance.unbind();
    }), this._boundInteractions = null), this;
  }
  initializeEventConfig(config2) {
    const eventsConfig = Object.assign({
      defaults: {}
    }, config2), unpack = (obj, keys) => {
      keys.forEach((k2) => {
        isArray_default(obj[k2]) && (obj[k2] = obj[k2].reduce((set2, key) => (set2[key] = true, set2), {}));
      });
    };
    return unpack(eventsConfig.defaults, ["prevent", "allow"]), unpack(eventsConfig, [EVENT_SOURCE_VIEW, EVENT_SOURCE_WINDOW]), eventsConfig;
  }
  initEvent() {
    const stage = this.renderer.stage();
    stage && stage.on("*", this.delegateEvent);
  }
  releaseStageEvent() {
    const stage = this.renderer.stage();
    stage && stage.off("*", this.delegateEvent);
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  initializeRenderer() {
    const width = this._options.width, height = this._options.height;
    this.renderer = new CanvasRenderer(this), this.renderer.initialize(width, height, this._options, this._eventConfig).background(this._background);
  }
  initialize() {
    var _a, _c;
    this.grammars = new RecordedGrammars((grammar) => grammar.id(), (key, grammar) => this.logger.warn(`Grammar id '${key}' has been occupied`, grammar)), this._cachedGrammars = new RecordedTreeGrammars((grammar) => grammar.id()), this._options.logger && Logger.setInstance(this._options.logger), this.logger = Logger.getInstance(null !== (_a = this._options.logLevel) && void 0 !== _a ? _a : 0), this._dataflow = new Dataflow(), this.animate = null === (_c = this.initAnimate) || void 0 === _c ? void 0 : _c.call(this, this), this._differ = new ViewDiff(), this._options.hooks && (Object.keys(this._options.hooks).forEach((key) => {
      this.on(key, this._options.hooks[key]);
    }), this.hooks = this._options.hooks), this.container = null, this.renderer = null, this._eventListeners = [], this._eventConfig = this.initializeEventConfig(this._options.eventConfig), this._theme = this._options.disableTheme ? null : ThemeManager2.getDefaultTheme(), this.parseBuiltIn(), configureEnvironment(this._options), this.initializeRenderer(), this._eventConfig.disable || this.initEvent(), this._bindResizeEvent(), this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this.theme(this._theme);
  }
  pauseProgressive() {
    return false;
  }
  resumeProgressive() {
    return false;
  }
  restartProgressive() {
    return false;
  }
  findProgressiveMarks() {
    const marks = [];
    return this.traverseMarkTree((mark) => {
      marks.push(mark);
    }, (mark) => mark.markType !== GrammarMarkType.group && mark.isProgressive()), marks.length ? (this._progressiveMarks = marks, this.renderer && this.renderer.combineIncrementalLayers(), marks) : (this._progressiveMarks = null, null);
  }
  doPreProgressive() {
    if (this._progressiveMarks && this._progressiveMarks.some((mark) => mark.isDoingProgressive())) {
      const raf = vglobal.getRequestAnimationFrame();
      this._progressiveRafId = raf(this.handleProgressiveFrame);
    } else this._progressiveMarks && this.animate && this._progressiveMarks.every((mark) => mark.canAnimateAfterProgressive()) ? this.animate.animate() : this._progressiveMarks && (this._progressiveMarks = null);
  }
  clearProgressive() {
    if (this._progressiveRafId) {
      vglobal.getCancelAnimationFrame()(this._progressiveRafId);
    }
    this._progressiveMarks && this._progressiveMarks.length && (this._progressiveMarks.forEach((entry) => {
      entry.clearProgressive();
    }), this._progressiveMarks = null);
  }
  release() {
    var _a, _b, _c, _d;
    this.removeAllInteractions(), this.releaseStageEvent(), this._unBindResizeEvent(), this.clearProgressive(), Factory3.unregisterRuntimeTransforms(), Logger.setInstance(null), null === (_a = this.animate) || void 0 === _a || _a.stop(), this.grammars.release(), this._cachedGrammars.release(), this._dataflow.release(), this._dataflow = null, null === (_c = null === (_b = this.renderer) || void 0 === _b ? void 0 : _b.release) || void 0 === _c || _c.call(_b), this.renderer = null, this._boundInteractions = null, this.removeAllListeners(), null === (_d = this._eventListeners) || void 0 === _d || _d.forEach((listener) => {
      listener.source.removeEventListener(listener.type, listener.handler);
    }), this._eventListeners = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/morph.js
var doMorph = (prev, next, runningConfig, onEnd, parameters) => {
  var _a, _b;
  const morphData = {
    prev: prev.map((element) => element.getDatum()),
    next: next.map((element) => element.getDatum())
  }, morphElements = {
    prev: prev.slice(),
    next: next.slice()
  }, easing = runningConfig.animation.easing, delay = invokeFunctionType(runningConfig.animation.delay, parameters, morphData, morphElements), duration = invokeFunctionType(runningConfig.animation.duration, parameters, morphData, morphElements), oneByOne = invokeFunctionType(runningConfig.animation.oneByOne, parameters, morphData, morphElements), splitPath2 = invokeFunctionType(runningConfig.animation.splitPath, parameters, morphData, morphElements), individualDelay = isValidNumber_default(oneByOne) && oneByOne > 0 ? (index) => isNumber_default(oneByOne) ? index * oneByOne : true === oneByOne ? index * duration : 0 : void 0;
  1 !== prev.length && 0 !== prev.length || 1 !== next.length ? 1 === prev.length && next.length > 1 ? oneToMultiMorph(prev[0].getGraphicItem(), next.map((element) => element.getGraphicItem()), {
    delay,
    duration,
    easing,
    onEnd,
    individualDelay,
    splitPath: splitPath2
  }) : prev.length > 1 && 1 === next.length && multiToOneMorph(prev.map((element) => element.getGraphicItem()), next[0].getGraphicItem(), {
    delay,
    duration,
    easing,
    onEnd,
    individualDelay,
    splitPath: splitPath2
  }) : morphPath(null === (_b = null === (_a = prev[0]) || void 0 === _a ? void 0 : _a.getGraphicItem) || void 0 === _b ? void 0 : _b.call(_a), next[0].getGraphicItem(), {
    delay,
    duration,
    easing,
    onEnd
  });
};
var divideElements = (elements, count) => {
  const divideLength = Math.floor(elements.length / count);
  return new Array(count).fill(0).map((i, index) => elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1)));
};
var appendMorphKeyToElements = (mark) => {
  const config2 = mark.getMorphConfig();
  if (!isNil_default(config2.morphElementKey)) {
    const getter2 = parseField(config2.morphElementKey);
    mark.elements && mark.elements.forEach((el) => {
      el.morphKey = getter2(el.getDatum());
    });
  }
};
var morph = (prevMarks, nextMarks, runningConfig) => {
  const prevElements = prevMarks.reduce((elements, mark) => (appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), nextElements = nextMarks.reduce((elements, mark) => (appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), diffResult = diffMultiple(prevElements, nextElements, (element) => {
    var _a;
    return null !== (_a = element.morphKey) && void 0 !== _a ? _a : element.key;
  });
  prevMarks.forEach((mark) => {
    var _a, _b;
    return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
  }), nextMarks.forEach((mark) => {
    var _a, _b;
    return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
  });
  const parameters = prevMarks.concat(nextMarks).reduce((parameters2, mark) => (Object.assign(parameters2, mark.parameters()), parameters2), {});
  let morphCount = 0;
  const onMorphEnd = () => {
    morphCount -= 1, 0 === morphCount && nextMarks.forEach((mark) => {
      var _a, _b;
      null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.enable) || void 0 === _b || _b.call(_a);
    });
  };
  diffResult.enter.forEach((diff) => {
    diff.next.forEach((element) => {
      doMorph([], [element], runningConfig, onMorphEnd, parameters);
    }), morphCount += 1;
  }), diffResult.update.forEach((diff) => {
    const divideCount = Math.min(diff.prev.length, diff.next.length), prevDivide = divideElements(diff.prev, divideCount), nextDivide = divideElements(diff.next, divideCount);
    for (let i = 0; i < divideCount; i++) doMorph(prevDivide[i], nextDivide[i], runningConfig, onMorphEnd, parameters), morphCount += 1;
  });
};

// node_modules/@visactor/vgrammar-core/es/view/view-morph-mixin.js
var ViewMorphMixin = class {
  morph(normalizedRunningConfig) {
    var _a;
    null === (_a = this._willMorphMarks) || void 0 === _a || _a.forEach((morphMarks) => {
      morph(morphMarks.prev, morphMarks.next, normalizedRunningConfig);
    }), this._willMorphMarks = null;
  }
  addMorphMarks(mark) {
    this._willMorphMarks || (this._willMorphMarks = []), this._willMorphMarks.push(mark);
  }
};
var registerViewMorphAPI = () => {
  mixin(View, ViewMorphMixin);
};

// node_modules/@visactor/vgrammar-core/es/graph/mark/graphic.js
var registerArcGraphic2 = () => {
  registerShadowRoot(), registerArc(), Factory3.registerGraphic(GrammarMarkType.arc, createArc), registerArcDataLabel();
};
var registerArc3dGraphic2 = () => {
  registerShadowRoot(), registerArc3d(), Factory3.registerGraphic(GrammarMarkType.arc3d, createArc3d);
};
var registerPyramid3dGraphic2 = () => {
  registerShadowRoot(), registerPyramid3d(), Factory3.registerGraphic(GrammarMarkType.pyramid3d, createPyramid3d);
};
var registerAreaGraphic2 = () => {
  registerShadowRoot(), registerArea(), Factory3.registerGraphic(GrammarMarkType.area, createArea), registerLineDataLabel(), registerSymbolDataLabel();
};
var registerGroupGraphic2 = () => {
  registerShadowRoot(), registerGroup(), Factory3.registerGraphic(GrammarMarkType.group, createGroup);
};
var registerImageGraphic2 = () => {
  registerShadowRoot(), registerImage(), Factory3.registerGraphic(GrammarMarkType.image, createImage);
};
var registerLineGraphic2 = () => {
  registerShadowRoot(), registerLine(), registerLineDataLabel(), registerSymbolDataLabel(), Factory3.registerGraphic(GrammarMarkType.line, createLine);
};
var registerPathGraphic2 = () => {
  registerShadowRoot(), registerPath(), Factory3.registerGraphic(GrammarMarkType.path, createPath);
};
var registerRectGraphic2 = () => {
  registerShadowRoot(), registerRect(), registerRectDataLabel(), Factory3.registerGraphic(GrammarMarkType.rect, createRect);
};
var registerRect3dGraphic2 = () => {
  registerShadowRoot(), registerRect3d(), Factory3.registerGraphic(GrammarMarkType.rect3d, createRect3d);
};
var registerRuleGraphic = () => {
  registerShadowRoot(), registerLine(), Factory3.registerGraphic(GrammarMarkType.rule, createLine);
};
var registerSymbolGraphic2 = () => {
  registerShadowRoot(), registerSymbol(), registerSymbolDataLabel(), Factory3.registerGraphic(GrammarMarkType.symbol, createSymbol);
};
var registerTextGraphic2 = () => {
  registerShadowRoot(), registerText(), registerRichtext(), Factory3.registerGraphic(GrammarMarkType.text, createText);
};
var registerPolygonGraphic2 = () => {
  registerShadowRoot(), registerPolygon(), Factory3.registerGraphic(GrammarMarkType.polygon, createPolygon);
};
var registerRichTextGraphic = () => {
  registerShadowRoot(), registerRichtext(), Factory3.registerGraphic(GrammarMarkType.richtext, createRichText);
};
var registerCellGraphic = () => {
  registerShadowRoot(), registerSymbol(), registerSymbolDataLabel(), Factory3.registerGraphic(GrammarMarkType.cell, createSymbol);
};
var registerGlyphGraphic2 = () => {
  registerShadowRoot(), registerGlyph(), Factory3.registerGraphic(GrammarMarkType.glyph, createGlyph);
};

// node_modules/@visactor/vgrammar-core/es/graph/glyph-element.js
var GlyphElement = class extends Element {
  constructor(mark) {
    super(mark), this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c, _d;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder2 = isRuntimeState ? Object.assign(Object.assign({}, null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName]), this.runtimeStatesEncoder[stateName]) : null === (_c = this.mark.getSpec().encode) || void 0 === _c ? void 0 : _c[stateName], glyphStateAttributes = {};
      if (!encoder2) return glyphStateAttributes;
      if (isFunction_default(encoder2)) return glyphStateAttributes.attributes = encoder2(this.getDatum(), this, stateName, nextStates), glyphStateAttributes;
      if (!isRuntimeState && (null === (_d = this.graphicItem.glyphStates) || void 0 === _d ? void 0 : _d[stateName])) return this.graphicItem.glyphStates[stateName];
      if (encoder2) {
        const item = this.items[0], targetItems = [Object.assign({}, item, {
          nextAttrs: {}
        })];
        return invokeEncoderToItems(this, targetItems, encoder2, this.mark.parameters()), this.coordinateTransformEncode(targetItems), glyphStateAttributes.attributes = targetItems[0].nextAttrs, this.graphicItem.glyphStates ? this.graphicItem.glyphStates[stateName] || (this.graphicItem.glyphStates[stateName] = glyphStateAttributes) : this.graphicItem.glyphStates = {
          [stateName]: glyphStateAttributes
        }, glyphStateAttributes;
      }
      return glyphStateAttributes;
    }, this.glyphMeta = this.mark.getGlyphMeta();
  }
  getGlyphGraphicItems() {
    return this.glyphGraphicItems;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem) return;
    this.graphicItem = this.mark.addGraphicItem(attributes, this.groupKey), this.graphicItem[BridgeElementKey] = this, this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false);
    const glyphMarks = this.glyphMeta.getMarks();
    this.glyphGraphicItems = {}, this.graphicItem.getSubGraphic().forEach((graphic) => {
      const markType = glyphMarks[graphic.name];
      this.glyphGraphicItems[graphic.name] = graphic, graphic.onBeforeAttributeUpdate = (attributes2) => {
        if (!this.mark) return attributes2;
        return transformAttributes(markType, attributes2, this, graphic.name);
      };
    }), this.clearGraphicAttributes();
  }
  useStates(states, hasAnimation) {
    if (!this.graphicItem) return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this), this.states = states.slice();
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : this.hasStateAnimation();
    return this.graphicItem.glyphStateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  encodeGraphic() {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType), isGraphicInit = !this.graphicItem;
    this.graphicItem ? (this.graphicItem.clearStates(), this.graphicItem.states = {}, this.graphicItem.stateProxy = null) : this.initGraphicItem(), this.diffState === DiffState.enter || isGraphicInit ? (this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(true), this.applyGraphicAttributes(graphicAttributes), this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false)) : this.applyGraphicAttributes(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem.states = {};
    }), this.useStates(this.states)), this.items.map((item) => {
      item.nextAttrs = {};
    });
  }
  encodeCustom(nextAttrs) {
    var _a;
    let customEncodeValues = {};
    const channelEncoder = this.glyphMeta.getChannelEncoder(), functionEncoder = this.glyphMeta.getFunctionEncoder();
    if (functionEncoder && (customEncodeValues = functionEncoder.call(null, Object.assign({}, null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, nextAttrs), this.getDatum(), this, this.mark.getGlyphConfig())), channelEncoder) {
      let allAttrs;
      Object.keys(channelEncoder).forEach((channel) => {
        var _a2;
        if (!isNil_default(nextAttrs[channel])) {
          allAttrs || (allAttrs = Object.assign({}, null === (_a2 = this.graphicItem) || void 0 === _a2 ? void 0 : _a2.attribute, nextAttrs));
          const encodeResult = channelEncoder[channel].call(null, channel, nextAttrs[channel], allAttrs, this.getDatum(), this, this.mark.getGlyphConfig());
          Object.keys(null != encodeResult ? encodeResult : {}).forEach((markName) => {
            var _a3;
            customEncodeValues[markName] = Object.assign(null !== (_a3 = customEncodeValues[markName]) && void 0 !== _a3 ? _a3 : {}, encodeResult[markName]);
          });
        }
      });
    }
    return customEncodeValues;
  }
  encodeDefault() {
    const defaultEncodeValues = {};
    if (this.glyphMeta.getDefaultEncoder()) {
      const defaultEncodeResult = this.glyphMeta.getDefaultEncoder().call(null, this.getDatum(), this, this.mark.getGlyphConfig());
      Object.assign(defaultEncodeValues, defaultEncodeResult);
    }
    return defaultEncodeValues;
  }
  _onGlyphAttributeUpdate(first = false) {
    return (attributes) => {
      if (!this.mark) return attributes;
      const glyphMarks = this.glyphMeta.getMarks(), graphicAttributes = transformAttributes(this.mark.getAttributeTransforms(), attributes, this), defaultEncodeValues = first ? this.encodeDefault() : null, customEncodeValues = this.encodeCustom(attributes);
      return Object.keys(glyphMarks).forEach((markName) => {
        const markType = glyphMarks[markName], graphicItem = this.glyphGraphicItems[markName], customAttributes = null == customEncodeValues ? void 0 : customEncodeValues[markName], additionalAttributes = Object.assign({}, customAttributes);
        if (first) {
          const defaultAttributes2 = null == defaultEncodeValues ? void 0 : defaultEncodeValues[markName];
          Object.keys(null != defaultAttributes2 ? defaultAttributes2 : {}).forEach((key) => {
            has_default(this.items[0].nextAttrs, key) || has_default(additionalAttributes, key) || (additionalAttributes[key] = defaultAttributes2[key]);
          });
        }
        const glyphAttributes = Object.assign({}, cloneTransformAttributes(markType, attributes), additionalAttributes), glyphItems = this._generateGlyphItems(markType, this.items, glyphAttributes);
        this.coordinateTransformEncode(glyphItems);
        const graphicAttributes2 = this.transformElementItems(glyphItems, markType);
        this.applyGlyphGraphicAttributes(graphicAttributes2, markName, graphicItem), markType === GrammarMarkType.shape && (graphicItem.datum = glyphItems[0].datum);
      }), graphicAttributes;
    };
  }
  _generateGlyphItems(markType, items, additionalAttributes) {
    const glyphItems = items.map((item) => Object.assign({}, item, {
      nextAttrs: additionalAttributes
    }));
    return CollectionMarkType.includes(markType) && this.mark.getSpec().enableSegments && glyphItems.forEach((glyphItem, index) => {
      glyphItem.nextAttrs = Object.assign({}, items[index].nextAttrs, additionalAttributes);
    }), glyphItems;
  }
  getGraphicAttribute(channel, prev = false, markName) {
    if (!this.graphicItem) return;
    const prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    if (prev && has_default(prevGraphicAttributes, channel)) return prevGraphicAttributes[channel];
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).attribute[channel];
  }
  setGraphicAttribute(channel, value, final = true, markName) {
    if (!this.graphicItem) return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    final && (finalGraphicAttributes[channel] = value), has_default(prevGraphicAttributes, channel) || (prevGraphicAttributes[channel] = graphicItem.attribute[channel]), graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true, markName) {
    if (!this.graphicItem) return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    Object.keys(attributes).forEach((key) => {
      final && (finalGraphicAttributes[key] = attributes[key]), has_default(prevGraphicAttributes, key) || (prevGraphicAttributes[key] = graphicItem.attribute[key]);
    }), graphicItem.setAttributes(attributes);
  }
  diffAttributes(graphicAttributes, markName) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes(markName);
    for (const key in graphicAttributes) has_default(finalGraphicAttributes, key) && isEqual(finalGraphicAttributes[key], graphicAttributes[key]) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  applyGlyphGraphicAttributes(graphicAttributes, markName, graphicItem) {
    var _a, _b;
    if (this.mark.needAnimate()) {
      const nextGraphicAttributes = this.diffAttributes(graphicAttributes, markName), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes(markName)) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes(markName)) && void 0 !== _b ? _b : {};
      Object.keys(nextGraphicAttributes).forEach((channel) => {
        prevGraphicAttributes[channel] = graphicItem.attribute[channel], finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
      }), this.setNextGraphicAttributes(nextGraphicAttributes, markName), this.setPrevGraphicAttributes(prevGraphicAttributes, markName), this.setFinalGraphicAttributes(finalGraphicAttributes, markName), graphicItem.setAttributes(nextGraphicAttributes);
    } else graphicItem.setAttributes(graphicAttributes);
  }
  getFinalGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs;
  }
  setFinalGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs = attributes;
  }
  getPrevGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs;
  }
  setPrevGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs = attributes;
  }
  getNextGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs;
  }
  setNextGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName);
    });
  }
  clearGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), this.setFinalGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName), this.setFinalGraphicAttributes(null, markName);
    });
  }
  remove() {
    this.glyphGraphicItems = null, super.remove();
  }
  release() {
    this.glyphGraphicItems && (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem[BridgeElementKey] = null;
    }), this.glyphGraphicItems = null), super.release();
  }
};

// node_modules/@visactor/vgrammar-core/es/view/glyph.js
var GlyphMark = class extends Mark {
  constructor(view, glyphType, group) {
    super(view, GrammarMarkType.glyph, group), this.glyphType = glyphType, this.glyphMeta = Factory3.getGlyph(glyphType);
  }
  configureGlyph(config2) {
    return this.spec.glyphConfig = config2, this.commit(), this;
  }
  getGlyphMeta() {
    return this.glyphMeta;
  }
  getGlyphConfig() {
    return this.spec.glyphConfig;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = createGlyphGraphicItem(this, this.glyphMeta, attrs);
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
  createElement() {
    return new GlyphElement(this);
  }
};
GlyphMark.markType = GrammarMarkType.glyph;
var registerGlyphMark = () => {
  Factory3.registerMark(GrammarMarkType.glyph, GlyphMark);
};

// node_modules/@visactor/vgrammar-core/es/glyph/boxplot.js
var scaleIn = (computeCenter) => (element, options, animationParameters) => {
  var _a, _b, _c;
  const direction = null !== (_c = null !== (_a = element.getGraphicAttribute("direction", false)) && void 0 !== _a ? _a : null === (_b = element.mark.getGlyphConfig()) || void 0 === _b ? void 0 : _b.direction) && void 0 !== _c ? _c : "vertical", center2 = computeCenter(element, direction, options);
  if (!isValidNumber_default(center2)) return {};
  const x = element.getGraphicAttribute("x", false), y = element.getGraphicAttribute("y", false), min3 = element.getGraphicAttribute("min", false), max3 = element.getGraphicAttribute("max", false), q1 = element.getGraphicAttribute("q1", false), q3 = element.getGraphicAttribute("q3", false), median3 = element.getGraphicAttribute("median", false), animateAttributes = {
    from: {
      x,
      y
    },
    to: {
      x,
      y
    }
  };
  return isValidNumber_default(min3) && (animateAttributes.from.min = center2, animateAttributes.to.min = min3), isValidNumber_default(max3) && (animateAttributes.from.max = center2, animateAttributes.to.max = max3), isValidNumber_default(q1) && (animateAttributes.from.q1 = center2, animateAttributes.to.q1 = q1), isValidNumber_default(q3) && (animateAttributes.from.q3 = center2, animateAttributes.to.q3 = q3), isValidNumber_default(median3) && (animateAttributes.from.median = center2, animateAttributes.to.median = median3), animateAttributes;
};
var scaleOut = (computeCenter) => (element, options, animationParameters) => {
  var _a, _b, _c;
  const direction = null !== (_c = null !== (_a = element.getGraphicAttribute("direction", false)) && void 0 !== _a ? _a : null === (_b = element.mark.getGlyphConfig()) || void 0 === _b ? void 0 : _b.direction) && void 0 !== _c ? _c : "vertical", center2 = computeCenter(element, direction, options);
  if (!isValidNumber_default(center2)) return {};
  const x = element.getGraphicAttribute("x", true), y = element.getGraphicAttribute("y", true), min3 = element.getGraphicAttribute("min", true), max3 = element.getGraphicAttribute("max", true), q1 = element.getGraphicAttribute("q1", true), q3 = element.getGraphicAttribute("q3", true), median3 = element.getGraphicAttribute("median", true), animateAttributes = {
    from: {
      x,
      y
    },
    to: {
      x,
      y
    }
  };
  return isValidNumber_default(min3) && (animateAttributes.to.min = center2, animateAttributes.from.min = min3), isValidNumber_default(max3) && (animateAttributes.to.max = center2, animateAttributes.from.max = max3), isValidNumber_default(q1) && (animateAttributes.to.q1 = center2, animateAttributes.from.q1 = q1), isValidNumber_default(q3) && (animateAttributes.to.q3 = center2, animateAttributes.from.q3 = q3), isValidNumber_default(median3) && (animateAttributes.to.median = center2, animateAttributes.from.median = median3), animateAttributes;
};
var computeBoxplotCenter = (glyphElement, direction, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (options && isValidNumber_default(options.center)) return options.center;
  let median3, max3, min3, q1, q3;
  if (isHorizontal(direction)) {
    median3 = null === (_b = null === (_a = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.x, max3 = null === (_d = null === (_c = glyphElement.getGraphicAttribute("points", false, "max")) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.x, min3 = null === (_f = null === (_e = glyphElement.getGraphicAttribute("points", false, "min")) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.x;
    const boxWidth = glyphElement.getGraphicAttribute("width", false, "box"), boxX = glyphElement.getGraphicAttribute("x", false, "box");
    q1 = boxX, q3 = boxX + boxWidth;
  } else {
    median3 = null === (_h = null === (_g = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.y, max3 = null === (_k = null === (_j = glyphElement.getGraphicAttribute("points", false, "max")) || void 0 === _j ? void 0 : _j[0]) || void 0 === _k ? void 0 : _k.y, min3 = null === (_m = null === (_l = glyphElement.getGraphicAttribute("points", false, "min")) || void 0 === _l ? void 0 : _l[0]) || void 0 === _m ? void 0 : _m.y;
    const boxHeight = glyphElement.getGraphicAttribute("height", false, "box"), boxY = glyphElement.getGraphicAttribute("y", false, "box");
    q1 = boxY, q3 = boxY + boxHeight;
  }
  return isValidNumber_default(median3) ? median3 : isValidNumber_default(q1) && isValidNumber_default(q3) ? (q1 + q3) / 2 : isValidNumber_default(max3) && isValidNumber_default(min3) ? (max3 + min3) / 2 : isValidNumber_default(min3) ? min3 : isValidNumber_default(max3) ? max3 : NaN;
};
var encodeBoxplotSize = (encodeValues, datum, element, config2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const attributes = {
    shaft: {},
    box: {},
    max: {},
    min: {},
    median: {}
  }, x = null !== (_a = encodeValues.x) && void 0 !== _a ? _a : element.getGraphicAttribute("x", false), y = null !== (_b = encodeValues.y) && void 0 !== _b ? _b : element.getGraphicAttribute("y", false), width = null !== (_c = encodeValues.width) && void 0 !== _c ? _c : element.getGraphicAttribute("width", false), height = null !== (_d = encodeValues.height) && void 0 !== _d ? _d : element.getGraphicAttribute("height", false), boxWidth = null !== (_e = encodeValues.boxWidth) && void 0 !== _e ? _e : element.getGraphicAttribute("boxWidth", false), boxHeight = null !== (_f = encodeValues.boxHeight) && void 0 !== _f ? _f : element.getGraphicAttribute("boxHeight", false), ruleWidth = null !== (_g = encodeValues.ruleWidth) && void 0 !== _g ? _g : element.getGraphicAttribute("ruleWidth", false), ruleHeight = null !== (_h = encodeValues.ruleHeight) && void 0 !== _h ? _h : element.getGraphicAttribute("ruleHeight", false);
  return config2 && isHorizontal(config2.direction) ? (isValidNumber_default(boxHeight) ? (Object.assign(attributes.box, {
    y: y - boxHeight / 2,
    y1: y + boxHeight / 2
  }), Object.assign(attributes.median, {
    y: y - boxHeight / 2,
    y1: y + boxHeight / 2
  })) : (Object.assign(attributes.box, {
    y: y - height / 2,
    y1: y + height / 2
  }), Object.assign(attributes.median, {
    y: y - height / 2,
    y1: y + height / 2
  })), isValidNumber_default(ruleHeight) ? (Object.assign(attributes.max, {
    y: y - ruleHeight / 2,
    y1: y + ruleHeight / 2
  }), Object.assign(attributes.min, {
    y: y - ruleHeight / 2,
    y1: y + ruleHeight / 2
  })) : (Object.assign(attributes.max, {
    y: y - height / 2,
    y1: y + height / 2
  }), Object.assign(attributes.min, {
    y: y - height / 2,
    y1: y + height / 2
  }))) : (isValidNumber_default(boxWidth) ? (Object.assign(attributes.box, {
    x: x - boxWidth / 2,
    x1: x + boxWidth / 2
  }), Object.assign(attributes.median, {
    x: x - boxWidth / 2,
    x1: x + boxWidth / 2
  })) : (Object.assign(attributes.box, {
    x: x - width / 2,
    x1: x + width / 2
  }), Object.assign(attributes.median, {
    x: x - width / 2,
    x1: x + width / 2
  })), isValidNumber_default(ruleWidth) ? (Object.assign(attributes.max, {
    x: x - ruleWidth / 2,
    x1: x + ruleWidth / 2
  }), Object.assign(attributes.min, {
    x: x - ruleWidth / 2,
    x1: x + ruleWidth / 2
  })) : (Object.assign(attributes.max, {
    x: x - width / 2,
    x1: x + width / 2
  }), Object.assign(attributes.min, {
    x: x - width / 2,
    x1: x + width / 2
  }))), attributes;
};
var boxplotScaleIn = scaleIn(computeBoxplotCenter);
var boxplotScaleOut = scaleOut(computeBoxplotCenter);
function registerBoxplotGlyph() {
  Factory3.registerGlyph("boxplot", {
    shaft: "rule",
    box: "rect",
    max: "rule",
    min: "rule",
    median: "rule"
  }).registerProgressiveChannels(["x", "y", "q1", "q3", "min", "max", "median", "angle", "width", "height", "boxWidth", "boxHeight", "ruleWidth", "ruleHeight"]).registerFunctionEncoder(encodeBoxplotSize).registerChannelEncoder("x", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? null : {
    shaft: {
      x: encodeValue,
      x1: encodeValue
    }
  }).registerChannelEncoder("y", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      y: encodeValue,
      y1: encodeValue
    }
  } : null).registerChannelEncoder("q1", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    box: {
      x: encodeValue
    }
  } : {
    box: {
      y: encodeValue
    }
  }).registerChannelEncoder("q3", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    box: {
      x1: encodeValue
    }
  } : {
    box: {
      y1: encodeValue
    }
  }).registerChannelEncoder("min", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      x: encodeValue
    },
    min: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    shaft: {
      y: encodeValue
    },
    min: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("max", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      x1: encodeValue
    },
    max: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    shaft: {
      y1: encodeValue
    },
    max: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("median", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    median: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    median: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("angle", (channel, encodeValue, encodeValues, datum, element, config2) => {
    var _a;
    const defaultAnchor = config2 && isHorizontal(config2.direction) ? [(encodeValues.min + encodeValues.max) / 2, encodeValues.y] : [encodeValues.x, (encodeValues.min + encodeValues.max) / 2], anchor = null !== (_a = encodeValues.anchor) && void 0 !== _a ? _a : defaultAnchor;
    return {
      shaft: {
        angle: encodeValue,
        anchor
      },
      box: {
        angle: encodeValue,
        anchor
      },
      max: {
        angle: encodeValue,
        anchor
      },
      min: {
        angle: encodeValue,
        anchor
      },
      median: {
        angle: encodeValue,
        anchor
      }
    };
  }).registerDefaultEncoder(() => ({
    max: {
      visible: false
    },
    min: {
      visible: false
    },
    median: {
      visible: false
    }
  })), Factory3.registerAnimationType("boxplotScaleIn", boxplotScaleIn), Factory3.registerAnimationType("boxplotScaleOut", boxplotScaleOut), registerGlyphMark(), registerGlyphGraphic2(), registerRectGraphic2(), registerRuleGraphic();
}
var computeBarBoxplotCenter = (glyphElement, direction, options) => {
  var _a, _b, _c, _d;
  if (isValidNumber_default(null == options ? void 0 : options.center)) return options.center;
  let median3, max3, min3, q1, q3;
  if (isHorizontal(direction)) {
    median3 = null === (_b = null === (_a = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.x;
    const minMaxBoxWidth = glyphElement.getGraphicAttribute("width", false, "minMaxBox"), minMaxBoxBoxX = glyphElement.getGraphicAttribute("x", false, "minMaxBox");
    min3 = minMaxBoxBoxX, max3 = minMaxBoxBoxX + minMaxBoxWidth;
    const q1q3BoxWidth = glyphElement.getGraphicAttribute("width", false, "q1q3Box"), q1q3BoxX = glyphElement.getGraphicAttribute("x", false, "q1q3Box");
    q1 = q1q3BoxX, q3 = q1q3BoxX + q1q3BoxWidth;
  } else {
    median3 = null === (_d = null === (_c = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.y;
    const minMaxBoxHeight = glyphElement.getGraphicAttribute("height", false, "minMaxBox"), minMaxBoxBoxY = glyphElement.getGraphicAttribute("y", false, "minMaxBox");
    min3 = minMaxBoxBoxY, max3 = minMaxBoxBoxY + minMaxBoxHeight;
    const q1q3BoxHeight = glyphElement.getGraphicAttribute("height", false, "q1q3Box"), q1q3BoxY = glyphElement.getGraphicAttribute("y", false, "q1q3Box");
    q1 = q1q3BoxY, q3 = q1q3BoxY + q1q3BoxHeight;
  }
  return isValidNumber_default(median3) ? median3 : isValidNumber_default(q1) && isValidNumber_default(q3) ? (q1 + q3) / 2 : isValidNumber_default(max3) && isValidNumber_default(min3) ? (max3 + min3) / 2 : isValidNumber_default(min3) ? min3 : isValidNumber_default(max3) ? max3 : NaN;
};
var encodeBarBoxplotSize = (encodeValues, datum, element, config2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const attributes = {
    minMaxBox: {},
    q1q3Box: {},
    median: {}
  }, x = null !== (_a = encodeValues.x) && void 0 !== _a ? _a : element.getGraphicAttribute("x", false), y = null !== (_b = encodeValues.y) && void 0 !== _b ? _b : element.getGraphicAttribute("y", false), width = null !== (_c = encodeValues.width) && void 0 !== _c ? _c : element.getGraphicAttribute("width", false), minMaxWidth = null !== (_d = encodeValues.minMaxWidth) && void 0 !== _d ? _d : element.getGraphicAttribute("minMaxWidth", false), q1q3Width = null !== (_e = encodeValues.q1q3Width) && void 0 !== _e ? _e : element.getGraphicAttribute("q1q3Width", false), height = null !== (_f = encodeValues.height) && void 0 !== _f ? _f : element.getGraphicAttribute("height", false), minMaxHeight = null !== (_g = encodeValues.minMaxHeight) && void 0 !== _g ? _g : element.getGraphicAttribute("minMaxHeight", false), q1q3Height = null !== (_h = encodeValues.q1q3Height) && void 0 !== _h ? _h : element.getGraphicAttribute("q1q3Height", false);
  return config2 && isHorizontal(config2.direction) ? (isValidNumber_default(minMaxHeight) ? Object.assign(attributes.minMaxBox, {
    y: y - minMaxHeight / 2,
    y1: y + minMaxHeight / 2
  }) : Object.assign(attributes.minMaxBox, {
    y: y - height / 2,
    y1: y + height / 2
  }), isValidNumber_default(q1q3Height) ? (Object.assign(attributes.q1q3Box, {
    y: y - q1q3Height / 2,
    y1: y + q1q3Height / 2
  }), Object.assign(attributes.median, {
    y: y - q1q3Height / 2,
    y1: y + q1q3Height / 2
  })) : (Object.assign(attributes.q1q3Box, {
    y: y - height / 2,
    y1: y + height / 2
  }), Object.assign(attributes.median, {
    y: y - height / 2,
    y1: y + height / 2
  }))) : (isValidNumber_default(minMaxWidth) ? Object.assign(attributes.minMaxBox, {
    x: x - minMaxWidth / 2,
    x1: x + minMaxWidth / 2
  }) : Object.assign(attributes.minMaxBox, {
    x: x - width / 2,
    x1: x + width / 2
  }), isValidNumber_default(q1q3Width) ? (Object.assign(attributes.q1q3Box, {
    x: x - q1q3Width / 2,
    x1: x + q1q3Width / 2
  }), Object.assign(attributes.median, {
    x: x - q1q3Width / 2,
    x1: x + q1q3Width / 2
  })) : (Object.assign(attributes.q1q3Box, {
    x: x - width / 2,
    x1: x + width / 2
  }), Object.assign(attributes.median, {
    x: x - width / 2,
    x1: x + width / 2
  }))), attributes;
};
var barBoxplotScaleIn = scaleIn(computeBarBoxplotCenter);
var barBoxplotScaleOut = scaleOut(computeBarBoxplotCenter);
function registerBarBoxplotGlyph() {
  Factory3.registerGlyph("barBoxplot", {
    minMaxBox: "rect",
    q1q3Box: "rect",
    median: "rule"
  }).registerProgressiveChannels(["x", "y", "q1", "q3", "min", "max", "median", "angle", "width", "height", "minMaxWidth", "q1q3Width", "minMaxHeight", "q1q3Height"]).registerFunctionEncoder(encodeBarBoxplotSize).registerChannelEncoder("q1", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    q1q3Box: {
      x: encodeValue
    }
  } : {
    q1q3Box: {
      y: encodeValue
    }
  }).registerChannelEncoder("q3", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    q1q3Box: {
      x1: encodeValue
    }
  } : {
    q1q3Box: {
      y1: encodeValue
    }
  }).registerChannelEncoder("min", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    minMaxBox: {
      x: encodeValue
    }
  } : {
    minMaxBox: {
      y: encodeValue
    }
  }).registerChannelEncoder("max", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    minMaxBox: {
      x1: encodeValue
    }
  } : {
    minMaxBox: {
      y1: encodeValue
    }
  }).registerChannelEncoder("median", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    median: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    median: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("angle", (channel, encodeValue, encodeValues, datum, element, config2) => {
    var _a;
    const anchor = null !== (_a = encodeValues.anchor) && void 0 !== _a ? _a : [encodeValues.x, (encodeValues.min + encodeValues.max) / 2];
    return {
      minMaxBox: {
        angle: encodeValue,
        anchor
      },
      q1q3Box: {
        angle: encodeValue,
        anchor
      },
      median: {
        angle: encodeValue,
        anchor
      }
    };
  }).registerChannelEncoder("lineWidth", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      lineWidth: 0
    },
    q1q3Box: {
      lineWidth: 0
    }
  })).registerChannelEncoder("minMaxFillOpacity", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      fillOpacity: encodeValue
    }
  })).registerChannelEncoder("stroke", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      stroke: false
    },
    q1q3Box: {
      stroke: false
    }
  })).registerDefaultEncoder(() => ({
    minMaxBox: {
      lineWidth: 0
    },
    q1q3Box: {
      lineWidth: 0
    },
    median: {
      visible: false
    }
  })), Factory3.registerAnimationType("barBoxplotScaleIn", barBoxplotScaleIn), Factory3.registerAnimationType("barBoxplotScaleOut", barBoxplotScaleOut), registerGlyphMark(), registerGlyphGraphic2(), registerRectGraphic2(), registerRuleGraphic();
}

// node_modules/@visactor/vgrammar-core/es/glyph/ripple.js
var registerRippleGlyph = () => {
  Factory3.registerGlyph("ripplePoint", {
    symbol: "symbol",
    ripple0: "symbol",
    ripple1: "symbol",
    ripple2: "symbol"
  }).registerFunctionEncoder((encodeValues, datum, element, config2) => {
    var _a;
    const ripple = Math.max(0, Math.min(encodeValues.ripple, 1)), size = null !== (_a = encodeValues.size) && void 0 !== _a ? _a : element.getGraphicAttribute("size"), rippleSize = 0.5 * size;
    return {
      ripple0: {
        size: size + rippleSize * ripple,
        fillOpacity: 0.75 - 0.25 * ripple
      },
      ripple1: {
        size: size + rippleSize * (1 + ripple),
        fillOpacity: 0.5 - 0.25 * ripple
      },
      ripple2: {
        size: size + rippleSize * (2 + ripple),
        fillOpacity: 0.25 - 0.25 * ripple
      }
    };
  }).registerDefaultEncoder(() => ({
    ripple0: {
      fillOpacity: 0.75
    },
    ripple1: {
      fillOpacity: 0.5
    },
    ripple2: {
      fillOpacity: 0.25
    }
  })), registerGlyphMark(), registerGlyphGraphic2(), registerSymbolGraphic2();
};

// node_modules/@visactor/vgrammar-core/es/glyph/wave.js
var registerWaveGlyph = () => {
  Factory3.registerGlyph("wave", {
    wave0: "area",
    wave1: "area",
    wave2: "area"
  }).registerChannelEncoder("wave", (channel, encodeValue, encodeValues, datum, element) => {
    const originPoints = new Array(21).fill(0).map((v, index) => {
      const waveHeight = index % 2 == 0 ? 20 : 0;
      return {
        x: 50 * index - 500,
        y: encodeValues.y + waveHeight,
        y1: encodeValues.y + encodeValues.height
      };
    });
    return {
      wave0: {
        points: originPoints.map((point6) => ({
          x: point6.x + 100 * encodeValue,
          y: point6.y,
          y1: point6.y1
        })),
        x: 0,
        y: 0
      },
      wave1: {
        points: originPoints.map((point6) => ({
          x: point6.x + 200 * encodeValue - 40,
          y: point6.y,
          y1: point6.y1
        })),
        x: 0,
        y: 0
      },
      wave2: {
        points: originPoints.map((point6) => ({
          x: point6.x + 300 * encodeValue - 20,
          y: point6.y,
          y1: point6.y1
        })),
        x: 0,
        y: 0
      }
    };
  }).registerDefaultEncoder(() => ({
    wave0: {
      curveType: "monotoneX",
      fillOpacity: 1
    },
    wave1: {
      curveType: "monotoneX",
      fillOpacity: 0.66
    },
    wave2: {
      curveType: "monotoneX",
      fillOpacity: 0.33
    }
  })), registerGlyphMark(), registerGlyphGraphic2(), registerAreaGraphic2();
};

// node_modules/@visactor/vgrammar-core/es/glyph/link-path.js
var getHorizontalPath2 = (options, ratio) => {
  var _a;
  const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : 0.5, thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let x0 = options.x0, x1 = options.x1, y00 = options.y0, y10 = options.y1, cpx0 = x0 + curvature * (x1 - x0), cpx1 = x1 + curvature * (x0 - x1), formatter = (v) => v;
  false !== options.round && (x0 = Math.round(x0), x1 = Math.round(x1), y00 = Math.round(y00), y10 = Math.round(y10), cpx0 = Math.round(cpx0), cpx1 = Math.round(cpx1), formatter = Math.round);
  "line" === options.pathType || options.pathType;
  "center" === options.align ? (y00 = formatter(options.y0 - thickness / 2), y10 = formatter(options.y1 - thickness / 2)) : "end" === options.align ? (y00 = formatter(options.y0 + options.thickness / 2 - thickness), y10 = formatter(options.y1 + options.thickness / 2 - thickness)) : (y00 = formatter(options.y0 - options.thickness / 2), y10 = formatter(options.y1 - options.thickness / 2));
  const y01 = formatter(y00 + thickness), y11 = formatter(y10 + thickness), hasLength = Math.abs(x1 - x0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x1},${formatter(y10 - thickness / 2)}L${formatter(x1 + thickness)},${formatter((y10 + y11) / 2)}L${x1},${formatter(y11 + thickness / 2)}` : "", startArrowPath = options.startArrow && hasLength ? `L${x0},${formatter(y01 + thickness / 2)}L${formatter(x0 - thickness)},${formatter((y00 + y01) / 2)}L${x0},${formatter(y00 - thickness / 2)}` : "";
  return "line" === options.pathType ? `M${x0},${y00}L${x1},${y10}${endArrowPath}L${x1},${y11}L${x0},${y01}${startArrowPath}Z` : "polyline" === options.pathType ? `M${x0},${y00}L${cpx0},${y00}L${cpx0},${y10}L${x1},${y10}
    ${endArrowPath}L${x1},${y11}L${cpx0},${y11}L${cpx0},${y01}L${x0},${y01}${startArrowPath}Z` : `M${x0},${y00}C${cpx0},${y00},${cpx1},${y10},${x1},${y10}
  ${endArrowPath}L${x1},${y11}C${cpx1},${y11},${cpx0},${y01},${x0},${y01}${startArrowPath}Z`;
};
var getVerticalPath2 = (options, ratio) => {
  var _a;
  const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : 0.5, thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let y0 = options.y0, y1 = options.y1, x00 = options.x0, x10 = options.x1, cpy0 = y0 + curvature * (y1 - y0), cpy1 = y1 + curvature * (y0 - y1), formatter = (v) => v;
  false !== options.round && (formatter = Math.round, y0 = Math.round(y0), y1 = Math.round(y1), x00 = Math.round(x00), x10 = Math.round(x10), cpy0 = Math.round(cpy0), cpy1 = Math.round(cpy1));
  "line" === options.pathType || options.pathType;
  "center" === options.align ? (x00 = formatter(options.x0 - thickness / 2), x10 = formatter(options.x1 - thickness / 2)) : "end" === options.align ? (x00 = formatter(options.x0 + options.thickness / 2 - thickness), x10 = formatter(options.x1 + options.thickness / 2 - thickness)) : (x00 = formatter(options.x0 - options.thickness / 2), x10 = formatter(options.x1 - options.thickness / 2));
  const x01 = formatter(x00 + thickness), x11 = formatter(x10 + thickness), hasLength = Math.abs(y1 - y0) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${formatter(x10 - thickness / 2)},${y1}L${formatter((x10 + x11) / 2)},${formatter(y1 + thickness)}L${formatter(x11 + thickness / 2)},${y1}` : "", startArrowPath = options.startArrow && hasLength ? `L${formatter(x01 + thickness / 2)},${y0}L${formatter((x01 + x00) / 2)},${formatter(y0 - thickness)}L${formatter(x00 - thickness / 2)},${y0}` : "";
  return "line" === options.pathType ? `M${x00},${y0}L${x10},${y1}${endArrowPath}L${x11},${y1}L${x01},${y0}${startArrowPath}Z` : "polyline" === options.pathType ? `M${x00},${y0}L${x00},${cpy0}L${x10},${cpy0}L${x10},${y1}
    ${endArrowPath}L${x11},${y1}L${x11},${cpy0}L${x01},${cpy0}L${x01},${y0}${startArrowPath}Z` : `M${x00},${y0}C${x00},${cpy0},${x10},${cpy1},${x10},${y1}
  ${endArrowPath}L${x11},${y1}C${x11},${cpy1},${x01},${cpy0},${x01},${y0}${startArrowPath}Z`;
};
var encoder = (encodeValues, datum, element, config2) => {
  var _a;
  const direction = null !== (_a = encodeValues.direction) && void 0 !== _a ? _a : null == config2 ? void 0 : config2.direction, parsePath = ["vertical", "TB", "BT"].includes(direction) ? getVerticalPath2 : getHorizontalPath2, isRatioShow = "number" == typeof encodeValues.ratio && encodeValues.ratio >= 0 && encodeValues.ratio <= 1, encodeChannels = Object.keys(encodeValues);
  return ["x0", "y0", "x1", "y1"].every((channel) => encodeChannels.includes(channel)) ? {
    back: {
      path: isRatioShow ? parsePath(encodeValues, 1) : ""
    },
    front: {
      path: parsePath(encodeValues, isRatioShow ? encodeValues.ratio : 1)
    }
  } : {};
};
var linkPathGrowIn = (element, options, animationParameters) => {
  const linkValues = {
    x0: element.getGraphicAttribute("x0", false),
    x1: element.getGraphicAttribute("x1", false),
    y0: element.getGraphicAttribute("y0", false),
    y1: element.getGraphicAttribute("y1", false),
    thickness: element.getGraphicAttribute("thickness", false),
    round: element.getGraphicAttribute("round", false),
    align: element.getGraphicAttribute("align", false),
    pathType: element.getGraphicAttribute("pathType", false),
    endArrow: element.getGraphicAttribute("endArrow", false),
    startArrow: element.getGraphicAttribute("startArrow", false)
  };
  return Object.keys(linkValues).forEach((key) => {
    isNil_default(linkValues[key]) && delete linkValues[key];
  }), {
    from: Object.assign({}, linkValues, {
      x1: linkValues.x0,
      y1: linkValues.y0
    }),
    to: linkValues
  };
};
var linkPathGrowOut = (element, options, animationParameters) => {
  const linkValues = {
    x0: element.getGraphicAttribute("x0", true),
    x1: element.getGraphicAttribute("x1", true),
    y0: element.getGraphicAttribute("y0", true),
    y1: element.getGraphicAttribute("y1", true),
    thickness: element.getGraphicAttribute("thickness", true),
    round: element.getGraphicAttribute("round", true),
    align: element.getGraphicAttribute("align", true),
    pathType: element.getGraphicAttribute("pathType", true),
    endArrow: element.getGraphicAttribute("endArrow", true),
    startArrow: element.getGraphicAttribute("startArrow", true)
  };
  return Object.keys(linkValues).forEach((key) => {
    isNil_default(linkValues[key]) && delete linkValues[key];
  }), {
    from: linkValues,
    to: Object.assign({}, linkValues, {
      x1: linkValues.x0,
      y1: linkValues.y0
    })
  };
};
var linkPathUpdate = (element, options, animationParameters) => {
  const bassLinkValues = {
    thickness: element.getGraphicAttribute("thickness", false),
    round: element.getGraphicAttribute("round", false),
    align: element.getGraphicAttribute("align", false),
    pathType: element.getGraphicAttribute("pathType", false),
    endArrow: element.getGraphicAttribute("endArrow", false),
    startArrow: element.getGraphicAttribute("startArrow", false)
  };
  Object.keys(bassLinkValues).forEach((key) => {
    isNil_default(bassLinkValues[key]) && delete bassLinkValues[key];
  });
  return {
    from: Object.assign(Object.assign({
      x0: element.getGraphicAttribute("x0", true),
      x1: element.getGraphicAttribute("x1", true),
      y0: element.getGraphicAttribute("y0", true),
      y1: element.getGraphicAttribute("y1", true)
    }, bassLinkValues), bassLinkValues),
    to: Object.assign({
      x0: element.getGraphicAttribute("x0", false),
      x1: element.getGraphicAttribute("x1", false),
      y0: element.getGraphicAttribute("y0", false),
      y1: element.getGraphicAttribute("y1", false)
    }, bassLinkValues)
  };
};
var registerLinkPathGlyph = () => {
  Factory3.registerGlyph("linkPath", {
    back: "path",
    front: "path"
  }).registerFunctionEncoder(encoder).registerChannelEncoder("backgroundStyle", (channel, encodeValue) => ({
    back: encodeValue
  })).registerDefaultEncoder(() => ({
    back: {
      zIndex: 0
    },
    front: {
      zIndex: 1
    }
  })), Factory3.registerAnimationType("linkPathGrowIn", linkPathGrowIn), Factory3.registerAnimationType("linkPathGrowOut", linkPathGrowOut), Factory3.registerAnimationType("linkPathUpdate", linkPathUpdate), registerGlyphMark(), registerGlyphGraphic2(), registerPathGraphic2();
};

// node_modules/@visactor/vgrammar-core/es/component/scale.js
var ScaleComponent = class extends Component {
  parseAddition(spec) {
    return super.parseAddition(spec), this.scale(spec.scale), this;
  }
  scale(scale4) {
    if (this.spec.scale) {
      const lastScaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this.detach(lastScaleGrammar), this.spec.scale = void 0;
    }
    const scaleGrammar = isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
    return this.spec.scale = scaleGrammar, this.attach(scaleGrammar), this._updateComponentEncoders(), this.commit(), this;
  }
  getScale() {
    return isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
  }
};

// node_modules/@visactor/vgrammar-core/es/component/axis.js
var generateLineAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.axis) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleAxis) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCoordinateAxisAttribute = (scale4, coordinate, inside, baseValue, layout2, isGrid) => {
  var _a;
  const axisPosition = scale4.getCoordinateAxisPosition();
  layout2 && "auto" === layout2.position && (layout2.position = inside ? "content" : axisPosition);
  const axisPoints = scale4.getCoordinateAxisPoints(baseValue);
  if (axisPoints) {
    const res = {
      start: axisPoints[0],
      end: axisPoints[1],
      verticalFactor: ("top" === axisPosition || "left" === axisPosition ? -1 : 1) * (inside ? -1 : 1) * ((null === (_a = scale4.getSpec().range) || void 0 === _a ? void 0 : _a.reversed) ? -1 : 1)
    };
    if (isGrid && "polar" === coordinate.type) {
      const angle3 = coordinate.angle();
      res.center = coordinate.origin(), res.startAngle = angle3[0], res.endAngle = angle3[1];
    }
    return res;
  }
  const radius = coordinate.radius(), angle2 = coordinate.angle();
  return {
    center: coordinate.origin(),
    radius: radius[1],
    innerRadius: radius[0],
    inside,
    startAngle: angle2[0],
    endAngle: angle2[1]
  };
};
var Axis = class extends ScaleComponent {
  constructor(view, group, mode) {
    super(view, ComponentEnum.axis, group), this.spec.componentType = ComponentEnum.axis, this.mode = mode;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.axisType(spec.axisType), this.tickCount(spec.tickCount), this.inside(spec.inside), this.baseValue(spec.baseValue), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._axisComponentType = null, this;
  }
  axisType(axisType) {
    return this.spec.axisType = axisType, this._axisComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory3.createGraphicComponent(this._getAxisComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  getAxisComponentType() {
    return this._axisComponentType;
  }
  _updateComponentEncoders() {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let addition = invokeEncoder(encoder2, datum, element, parameters);
          const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element), coordinate = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
          coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout), addition));
          const scale4 = null === (_b = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getAxisComponentType()) {
            case AxisEnum.lineAxis:
              return generateLineAxisAttributes(scale4, theme2, addition, tickCount);
            case AxisEnum.circleAxis:
              return generateCircleAxisAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getAxisComponentType() {
    var _a;
    if (this._axisComponentType) return this._axisComponentType;
    let type = this.spec.axisType;
    if (isNil_default(type)) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      type = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? "line" : "circle" : "line";
    }
    return this._axisComponentType = "circle" === type ? AxisEnum.circleAxis : AxisEnum.lineAxis, this._axisComponentType;
  }
};
Axis.componentType = ComponentEnum.axis;
var registerLineAxis = () => {
  Factory3.registerGraphicComponent(AxisEnum.lineAxis, (attrs, options) => new LineAxis(attrs, options)), Factory3.registerComponent(ComponentEnum.axis, Axis);
};
var registerCircleAxis = () => {
  Factory3.registerGraphicComponent(AxisEnum.circleAxis, (attrs) => new CircleAxis(attrs)), Factory3.registerComponent(ComponentEnum.axis, Axis);
};

// node_modules/@visactor/vgrammar-core/es/interactions/legend-filter.js
var LegendFilter = class _LegendFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _LegendFilter.type, this.options = Object.assign({}, _LegendFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "legend" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const legend = this._marks[0];
    if (!this._data || !legend) return [];
    const isContinuous2 = legend.isContinuousLegend(), filter2 = this.options.target.filter, transform30 = this.options.target.transform, dataFilter = isString_default(filter2) ? isContinuous2 ? (datum, filterValue) => datum[filter2] >= filterValue.start && datum[filter2] <= filterValue.end : (datum, filterValue) => filterValue.includes(datum[filter2]) : filter2;
    this._filterData(this._data, legend, DataFilterRank.legend, (event) => isContinuous2 ? {
      start: event.detail.value[0],
      end: event.detail.value[1]
    } : event.detail.currentSelected, dataFilter, transform30);
    return [{
      type: isContinuous2 ? "change" : LegendEvent.legendItemClick,
      handler: this.handleFilter
    }];
  }
};
LegendFilter.type = "legend-filter", LegendFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/legend.js
var generateDiscreteLegendAttributes = (scale4, theme2, addition, shapeScale) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.discreteLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const items = Array.from(new Set(array(scale4.domain()))).map((item, index) => {
    var _a2, _b, _c, _d, _e, _f;
    const value = scale4.scale(item), color = parseColor(value), shape = color ? Object.assign(Object.assign({}, null !== (_c = null === (_b = null === (_a2 = null == legendTheme ? void 0 : legendTheme.items) || void 0 === _a2 ? void 0 : _a2[0]) || void 0 === _b ? void 0 : _b.shape) && void 0 !== _c ? _c : {}), {
      fill: color,
      stroke: color
    }) : null !== (_f = null === (_e = null === (_d = null == legendTheme ? void 0 : legendTheme.items) || void 0 === _d ? void 0 : _d[0]) || void 0 === _e ? void 0 : _e.shape) && void 0 !== _f ? _f : {};
    return shapeScale && Object.assign(shape, {
      symbolType: shapeScale.scale(item)
    }), {
      label: item.toString(),
      id: item,
      shape,
      index
    };
  });
  return merge({}, legendTheme, {
    items
  }, null != addition ? addition : {});
};
var generateColorLegendAttributes = (scale4, theme2, addition) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.colorLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const domain = scale4.domain();
  return merge({}, legendTheme, {
    colors: scale4.range().slice(),
    min: domain[0],
    max: last(domain)
  }, null != addition ? addition : {});
};
var generateSizeLegendAttributes = (scale4, theme2, addition) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.sizeLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const domain = scale4.domain(), attributes = {
    min: domain[0],
    max: domain[domain.length - 1],
    value: [domain[0], domain[domain.length - 1]]
  };
  return merge({}, legendTheme, attributes, null != addition ? addition : {});
};
var Legend = class extends ScaleComponent {
  constructor(view, group) {
    super(view, ComponentEnum.legend, group), this.spec.componentType = ComponentEnum.legend, this.spec.legendType = "auto";
  }
  parseAddition(spec) {
    return this.shapeScale(spec.shapeScale), super.parseAddition(spec), this.legendType(spec.legendType), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._legendComponentType = null, this;
  }
  shapeScale(shapeScale) {
    if (this.spec.shapeScale) {
      const lastScaleGrammar = isString_default(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale;
      this.detach(lastScaleGrammar), this.spec.shapeScale = void 0;
    }
    const scaleGrammar = isString_default(shapeScale) ? this.view.getScaleById(shapeScale) : shapeScale;
    return this.spec.shapeScale = scaleGrammar, this.attach(scaleGrammar), this.commit(), this;
  }
  legendType(legendType) {
    return this.spec.legendType = legendType, this._legendComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  isContinuousLegend() {
    return this._getLegendComponentType() !== LegendEnum.discreteLegend;
  }
  setSelected(selectedValues) {
    return this.getGroupGraphicItem().setSelected(selectedValues), this;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = Factory3.createGraphicComponent(this._getLegendComponentType(), attrs, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, shapeScaleGrammar = isString_default(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters), scale4 = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
          switch (this._getLegendComponentType()) {
            case LegendEnum.discreteLegend:
              return generateDiscreteLegendAttributes(scale4, theme2, addition, null === (_b = null == shapeScaleGrammar ? void 0 : shapeScaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(shapeScaleGrammar));
            case LegendEnum.colorLegend:
              return generateColorLegendAttributes(scale4, theme2, addition);
            case LegendEnum.sizeLegend:
              return generateSizeLegendAttributes(scale4, theme2, addition);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getLegendComponentType() {
    var _a;
    if (this._legendComponentType) return this._legendComponentType;
    if (this.spec.legendType && "auto" !== this.spec.legendType) this._legendComponentType = "color" === this.spec.legendType ? "colorLegend" : "size" === this.spec.legendType ? "sizeLegend" : "discreteLegend";
    else {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, scaleType = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getScaleType) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
      if (scaleType && isContinuous(scaleType)) {
        const range2 = scaleGrammar.getScale().range();
        parseColor(null == range2 ? void 0 : range2[0]) ? this._legendComponentType = LegendEnum.colorLegend : this._legendComponentType = LegendEnum.sizeLegend;
      } else this._legendComponentType = LegendEnum.discreteLegend;
    }
    return this._legendComponentType;
  }
};
Legend.componentType = ComponentEnum.legend;

// node_modules/@visactor/vgrammar-core/es/interactions/slider-filter.js
var SliderFilter = class _SliderFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _SliderFilter.type, this.options = Object.assign({}, _SliderFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "slider" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const slider2 = this._marks[0];
    if (!this._data || !slider2) return [];
    const filter2 = this.options.target.filter, transform30 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => datum[filter2] >= filterValue.start && datum[filter2] <= filterValue.end : filter2;
    return this._filterData(this._data, slider2, DataFilterRank.slider, (event) => ({
      start: event.detail.value[0],
      end: event.detail.value[1]
    }), dataFilter, transform30), [{
      type: "change",
      handler: this.handleFilter
    }];
  }
};
SliderFilter.type = "slider-filter", SliderFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/slider.js
var generateSliderAttributes = (min3, max3, theme2, addition) => {
  var _a;
  const sliderTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.slider;
  return merge({}, sliderTheme, {
    min: min3,
    max: max3,
    value: [min3, max3]
  }, null != addition ? addition : {});
};
var Slider2 = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.slider, group), this.spec.componentType = ComponentEnum.slider;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.min(spec.min), this.max(spec.max), this;
  }
  min(min3) {
    return this.setFunctionSpec(min3, "min");
  }
  max(max3) {
    return this.setFunctionSpec(max3, "max");
  }
  setStartEndValue(start, end) {
    return this.getGroupGraphicItem().setValue([start, end]), this;
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          const min3 = isNil_default(this.spec.min) ? 0 : invokeFunctionType(this.spec.min, parameters, datum, element), max3 = isNil_default(this.spec.max) ? 1 : invokeFunctionType(this.spec.max, parameters, datum, element), theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateSliderAttributes(min3, max3, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Slider2.componentType = ComponentEnum.slider;

// node_modules/@visactor/vgrammar-core/es/component/label.js
var __rest14 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var generateLabelAttributes = (marks, groupSize, encoder2, labelStyle, parameters, theme2 = {}) => {
  var _a;
  const labelTheme2 = null === (_a = theme2.components) || void 0 === _a ? void 0 : _a.dataLabel, dataLabels = marks.map((mark, index) => {
    var _a2, _b, _c, _d, _e;
    const labelParameters = Object.assign(Object.assign({}, parameters), {
      labelIndex: index
    }), addition = null !== (_a2 = invokeFunctionType(labelStyle, labelParameters, mark)) && void 0 !== _a2 ? _a2 : {}, { components = {} } = theme2;
    let currentTheme = {};
    switch (mark.markType) {
      case GrammarMarkType.line:
      case GrammarMarkType.area:
        currentTheme = "line" === addition.type ? components.lineLabel : "area" === addition.type ? components.areaLabel : components.lineDataLabel;
        break;
      case GrammarMarkType.rect:
      case GrammarMarkType.rect3d:
      case GrammarMarkType.interval:
        currentTheme = components.rectLabel;
        break;
      case GrammarMarkType.symbol:
      case GrammarMarkType.circle:
      case GrammarMarkType.cell:
        currentTheme = components.symbolLabel;
        break;
      case GrammarMarkType.arc:
      case GrammarMarkType.arc3d:
        currentTheme = components.arcLabel;
        break;
      case GrammarMarkType.polygon:
      case GrammarMarkType.path:
      default:
        currentTheme = components.pointLabel;
    }
    const data = null !== (_b = addition.data) && void 0 !== _b ? _b : [], themeDatum = null !== (_d = null === (_c = null == currentTheme ? void 0 : currentTheme.data) || void 0 === _c ? void 0 : _c[0]) && void 0 !== _d ? _d : {};
    if (data && data.length > 0) data.forEach((d, index2) => {
      if (mark.elements[index2]) {
        const attributes = invokeEncoder(encoder2, d, mark.elements[index2], labelParameters);
        merge(d, themeDatum, attributes);
      }
    });
    else {
      const mergeAttributes = (attributes, themeDatum2) => {
        const { data: labelData } = attributes, restAttribute = __rest14(attributes, ["data"]);
        return Object.assign(Object.assign({}, merge({}, themeDatum2, restAttribute)), {
          data: labelData
        });
      };
      mark.elements.forEach((element) => {
        if ("willRelease" !== element.getGraphicItem().releaseStatus) if (mark.isCollectionMark()) {
          element.getDatum().forEach((entry) => {
            const attributes = invokeEncoder(encoder2, entry, element, labelParameters);
            data.push(mergeAttributes(attributes, themeDatum));
          });
        } else {
          const attributes = invokeEncoder(encoder2, element.getDatum(), element, labelParameters);
          data.push(mergeAttributes(attributes, themeDatum));
        }
      });
    }
    const graphicItemName = null === (_e = mark.graphicItem) || void 0 === _e ? void 0 : _e.name, result3 = merge({}, currentTheme, {
      baseMarkGroupName: graphicItemName,
      getBaseMarks: () => mark.elements.map((element) => element.getGraphicItem())
    }, null != addition ? addition : {});
    return result3.data = null != data ? data : currentTheme.data, result3;
  }).filter((label) => !isNil_default(label)), result2 = merge({}, labelTheme2, {
    size: groupSize
  });
  return result2.dataLabels = dataLabels, result2;
};
var Label = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.label, group), this.spec.componentType = ComponentEnum.label;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.labelStyle(spec.labelStyle), this.size(spec.size), this.target(spec.target), this;
  }
  labelStyle(style) {
    return this.setFunctionSpec(style, "labelStyle");
  }
  size(size) {
    return this.setFunctionSpec(size, "size");
  }
  target(mark) {
    if (this.spec.target) {
      const prevMarks = array(this.spec.target).map((m4) => isString_default(m4) ? this.view.getMarkById(m4) : m4);
      this.detach(prevMarks);
    }
    if (this.spec.target = mark, mark) {
      const nextMarks = array(mark).map((m4) => isString_default(m4) ? this.view.getMarkById(m4) : m4);
      this.attach(nextMarks);
    }
    return this.commit(), this;
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c, _d;
          const marks = array(this.spec.target).map((m4) => isString_default(m4) ? this.view.getMarkById(m4) : m4), groupGraphicItem = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.getGroupGraphicItem) || void 0 === _b ? void 0 : _b.call(_a);
          let size = invokeFunctionType(this.spec.size, parameters);
          size || (size = groupGraphicItem ? {
            width: null !== (_c = groupGraphicItem.attribute.width) && void 0 !== _c ? _c : groupGraphicItem.AABBBounds.width(),
            height: null !== (_d = groupGraphicItem.attribute.height) && void 0 !== _d ? _d : groupGraphicItem.AABBBounds.height()
          } : {
            width: 1 / 0,
            height: 1 / 0
          });
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          return generateLabelAttributes(marks, size, encoder2, this.spec.labelStyle, parameters, theme2);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Label.componentType = ComponentEnum.label;
var registerLabel = () => {
  Factory3.registerGraphicComponent(ComponentEnum.label, (attrs) => new DataLabel(attrs)), Factory3.registerComponent(ComponentEnum.label, Label);
};

// node_modules/@visactor/vgrammar-core/es/interactions/datazoom-filter.js
var DatazoomFilter = class _DatazoomFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _DatazoomFilter.type, this.options = Object.assign({}, _DatazoomFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "datazoom" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const datazoom2 = this._marks[0];
    if (!this._data || !datazoom2) return [];
    const filter2 = this.options.target.filter, transform30 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => {
      if (isNil_default(filterValue.start) || isNil_default(filterValue.end)) return true;
      const scale4 = datazoom2.getDatazoomMainScale(), datumRatio = getScaleRangeRatio(scale4, datum[filter2]);
      return filterValue.startRatio <= datumRatio && filterValue.endRatio >= datumRatio;
    } : filter2;
    return this._filterData(this._data, datazoom2, DataFilterRank.datazoom, (event) => {
      const startRatio = event.detail.start, endRatio = event.detail.end;
      return {
        startRatio,
        endRatio,
        start: datazoom2.invertDatazoomRatio(startRatio),
        end: datazoom2.invertDatazoomRatio(endRatio)
      };
    }, dataFilter, transform30), [{
      type: "change",
      handler: this.handleFilter
    }];
  }
};
DatazoomFilter.type = "datazoom-filter", DatazoomFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/datazoom.js
var generateDatazoomAttributes = (data, theme2, addition) => {
  var _a;
  const datazoomTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.datazoom;
  return data ? merge({}, datazoomTheme, {
    previewData: data
  }, null != addition ? addition : {}) : merge({}, datazoomTheme, null != addition ? addition : {});
};
var Datazoom = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.datazoom, group), this.spec.componentType = ComponentEnum.datazoom;
  }
  parseAddition(spec) {
    var _a;
    super.parseAddition(spec);
    const { data, x, y, x1, y1 } = null !== (_a = spec.preview) && void 0 !== _a ? _a : {};
    return this.preview(data, x, y, x1, y1), this._updateComponentEncoders(), this;
  }
  preview(data, x, y, x1, y1) {
    if (!isNil_default(this.spec.preview)) {
      const lastData = this.spec.preview.data, lastDataGrammar = isString_default(lastData) ? this.view.getDataById(lastData) : lastData;
      this.detach(lastDataGrammar), this.detach(parseEncodeType(this.spec.preview.x, this.view)), this.detach(parseEncodeType(this.spec.preview.y, this.view)), this.detach(parseEncodeType(this.spec.preview.x1, this.view)), this.detach(parseEncodeType(this.spec.preview.y1, this.view));
    }
    if (this.spec.preview = void 0, data) {
      this.spec.preview = {
        data,
        x,
        y,
        x1,
        y1
      };
      const dataGrammar = isString_default(data) ? this.view.getDataById(data) : data;
      this.attach(dataGrammar), this.attach(parseEncodeType(x, this.view)), this.attach(parseEncodeType(y, this.view)), this.attach(parseEncodeType(x1, this.view)), this.attach(parseEncodeType(y1, this.view));
    }
    return this._updateComponentEncoders(), this.commit(), this;
  }
  setStartEndValue(start, end) {
    const datazoom2 = this.getGroupGraphicItem();
    return datazoom2 && datazoom2.setStartAndEnd && datazoom2.setStartAndEnd(start, end), this;
  }
  getStartEndValue() {
    const datazoom2 = this.getGroupGraphicItem();
    if (datazoom2) {
      const state = datazoom2.state;
      return {
        start: state.start,
        end: state.end
      };
    }
    return null;
  }
  addGraphicItem(attrs, groupKey) {
    var _a;
    const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), initialAttributes = Object.assign({}, null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.datazoom, attrs), graphicItem = Factory3.createGraphicComponent(this.componentType, initialAttributes, {
      skipDefault: this.spec.skipTheme
    });
    return this.setDatazoomHandlers(graphicItem), super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  reuse(grammar) {
    return super.reuse(grammar), this.setDatazoomHandlers(), this;
  }
  _updateComponentEncoders() {
    var _a;
    const data = null === (_a = this.spec.preview) || void 0 === _a ? void 0 : _a.data, dataGrammar = isString_default(data) ? this.view.getDataById(data) : data, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a2;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateDatazoomAttributes(null === (_a2 = null == dataGrammar ? void 0 : dataGrammar.getValue) || void 0 === _a2 ? void 0 : _a2.call(dataGrammar), theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  invertDatazoomRatio(ratio) {
    const scale4 = this.getDatazoomMainScale();
    if (scale4) {
      const range2 = scale4.range(), scaledValue = (range2[range2.length - 1] - range2[0]) * ratio + range2[0];
      return scale4.invert(scaledValue);
    }
    return null;
  }
  getDatazoomMainScale() {
    var _a, _b;
    const datazoom2 = this.getGroupGraphicItem();
    if (datazoom2 && this.spec.preview) {
      const scale4 = "top" === datazoom2.attribute.orient || "bottom" === datazoom2.attribute.orient ? null === (_a = this.spec.preview.x) || void 0 === _a ? void 0 : _a.scale : null === (_b = this.spec.preview.y) || void 0 === _b ? void 0 : _b.scale, scaleGrammar = isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
      return null == scaleGrammar ? void 0 : scaleGrammar.getScale();
    }
    return null;
  }
  setDatazoomHandlers(graphicItem) {
    var _a;
    const datazoom2 = null != graphicItem ? graphicItem : this.getGroupGraphicItem();
    datazoom2.setStatePointToData((state) => {
      var _a2;
      return this.spec.preview && null !== (_a2 = this.invertDatazoomRatio(state)) && void 0 !== _a2 ? _a2 : state;
    });
    const { data, x, y, x1, y1 } = null !== (_a = this.spec.preview) && void 0 !== _a ? _a : {};
    datazoom2.setPreviewPointsX((datum) => {
      if (x && data) return invokeEncoder({
        x
      }, datum, this.elements[0], this.parameters()).x;
    }), datazoom2.setPreviewPointsY((datum) => {
      if (y && data) return invokeEncoder({
        y
      }, datum, this.elements[0], this.parameters()).y;
    }), datazoom2.setPreviewPointsX1((datum) => {
      if (x1 && data) return invokeEncoder({
        x1
      }, datum, this.elements[0], this.parameters()).x1;
    }), datazoom2.setPreviewPointsY1((datum) => {
      if (y1 && data) return invokeEncoder({
        y1
      }, datum, this.elements[0], this.parameters()).y1;
    });
  }
};
Datazoom.componentType = ComponentEnum.datazoom;

// node_modules/@visactor/vgrammar-core/es/interactions/player-filter.js
var PlayerFilter = class _PlayerFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _PlayerFilter.type, this.options = Object.assign({}, _PlayerFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "player" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const player2 = this._marks[0];
    if (!this._data || !player2) return [];
    const transform30 = this.options.target.transform;
    return this._filterData(this._data, player2, DataFilterRank.player, (event) => ({
      index: event.detail.index,
      value: event.detail.value
    }), void 0, (data, filterValue) => transform30 ? transform30(data, filterValue) : filterValue.value), [{
      type: PlayerEventEnum.OnChange,
      handler: this.handleFilter
    }];
  }
};
PlayerFilter.type = "player-filter", PlayerFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/player.js
var generateContinuousPlayerAttributes = (data, theme2, addition) => {
  var _a;
  const playerTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.continuousPlayer;
  return merge({}, playerTheme, {
    data,
    dataIndex: 0
  }, null != addition ? addition : {});
};
var generateDiscretePlayerAttributes = (data, theme2, addition) => {
  var _a;
  const playerTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.discretePlayer;
  return merge({}, playerTheme, {
    data,
    dataIndex: 0
  }, null != addition ? addition : {});
};
var Player = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.player, group), this.spec.componentType = ComponentEnum.player, this.spec.playerType = "auto";
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.playerType(spec.playerType), this.source(spec.source), this;
  }
  playerType(playerType) {
    return this.spec.playerType = playerType, this._playerComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  source(source) {
    var _a;
    if (this.spec.source) {
      const lastSource = null === (_a = this.spec) || void 0 === _a ? void 0 : _a.source, lastSourceDataGrammar = isArray_default(lastSource) ? null : isString_default(lastSource) ? this.view.getDataById(lastSource) : lastSource;
      this.detach(lastSourceDataGrammar);
    }
    this.spec.source = source;
    const sourceDataGrammar = isArray_default(source) ? null : isString_default(source) ? this.view.getDataById(source) : source;
    return this.attach(sourceDataGrammar), this.commit(), this;
  }
  play() {
    return this.getGroupGraphicItem().play(), this;
  }
  pause() {
    return this.getGroupGraphicItem().pause(), this;
  }
  backward() {
    return this.getGroupGraphicItem().backward(), this;
  }
  forward() {
    return this.getGroupGraphicItem().forward(), this;
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const initialAttributes = merge({
      slider: {
        handlerStyle: {
          size: 16
        }
      }
    }, attrs), graphicItem = null != newGraphicItem ? newGraphicItem : Factory3.createGraphicComponent(this._getPlayerComponentType(), initialAttributes, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters), source = this.spec.source, sourceDataGrammar = isArray_default(source) ? null : isString_default(source) ? this.view.getDataById(source) : source, sourceData = isArray_default(source) ? source : null !== (_a = null == sourceDataGrammar ? void 0 : sourceDataGrammar.getValue()) && void 0 !== _a ? _a : [];
          switch (this._getPlayerComponentType()) {
            case "continuousPlayer":
              return generateContinuousPlayerAttributes(sourceData, theme2, addition);
            case "discretePlayer":
              return generateDiscretePlayerAttributes(sourceData, theme2, addition);
          }
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getPlayerComponentType() {
    return this._playerComponentType || (this.spec.playerType && "auto" !== this.spec.playerType ? this._playerComponentType = "discrete" === this.spec.playerType ? "discretePlayer" : "continuous" === this.spec.playerType ? "continuousPlayer" : "discretePlayer" : this._playerComponentType = "discretePlayer"), this._playerComponentType;
  }
};
Player.componentType = ComponentEnum.player;

// node_modules/@visactor/vgrammar-core/es/component/title.js
var generateTitleAttributes = (title3, subTitle, theme2, addition) => {
  var _a;
  const titleTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.title, attributes = {};
  return isValid_default(title3) && (attributes.text = title3), isValid_default(subTitle) && (attributes.subtext = subTitle), merge({}, titleTheme, attributes, null != addition ? addition : {});
};
var Title2 = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.title, group), this.spec.componentType = ComponentEnum.title;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.title(spec.title), this.subTitle(spec.subTitle), this;
  }
  title(text2) {
    return this.setFunctionSpec(text2, "title");
  }
  subTitle(text2) {
    return this.setFunctionSpec(text2, "subTitle");
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), title3 = invokeFunctionType(this.spec.title, parameters, datum, element), subTitle = invokeFunctionType(this.spec.subTitle, parameters, datum, element), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateTitleAttributes(title3, subTitle, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Title2.componentType = ComponentEnum.title;

// node_modules/@visactor/vgrammar-core/es/component/grid.js
var generateLineAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.grid) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleGrid) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var Grid = class extends ScaleComponent {
  constructor(view, group, mode) {
    super(view, ComponentEnum.grid, group), this.spec.componentType = ComponentEnum.grid, this.mode = mode;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.target(spec.target), this.gridType(spec.gridType), this.gridShape(spec.gridShape), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._gridComponentType = null, this;
  }
  gridType(gridType) {
    return this.spec.gridType = gridType, this._gridComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  gridShape(gridShape) {
    return this.spec.gridShape = gridShape, this.commit(), this;
  }
  target(axis2) {
    if (this.spec.target) {
      const prevAxis = isString_default(this.spec.target) ? this.view.getMarkById(this.spec.target) : this.spec.target;
      this.detach(prevAxis);
    }
    this.spec.target = axis2;
    const nextAxis = isString_default(axis2) ? this.view.getMarkById(axis2) : axis2;
    return this.attach(nextAxis), this._targetAxis = nextAxis, this._gridComponentType = null, this._updateComponentEncoders(), this.commit(), this;
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory3.createGraphicComponent(this._getGridComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c, _d;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let scaleGrammar, addition = invokeEncoder(encoder2, datum, element, parameters);
          const baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element);
          if (this._targetAxis) {
            const targetScale = null === (_a = this._targetAxis.getSpec()) || void 0 === _a ? void 0 : _a.scale;
            scaleGrammar = isString_default(targetScale) ? this.view.getScaleById(targetScale) : targetScale;
            const targetElement = this._targetAxis.elements[0];
            if (targetElement) switch (this._getGridComponentType()) {
              case GridEnum.lineAxisGrid:
                addition = Object.assign({
                  x: targetElement.getGraphicAttribute("x"),
                  y: targetElement.getGraphicAttribute("y"),
                  start: targetElement.getGraphicAttribute("start"),
                  end: targetElement.getGraphicAttribute("end"),
                  verticalFactor: null !== (_b = targetElement.getGraphicAttribute("verticalFactor")) && void 0 !== _b ? _b : 1
                }, addition);
                break;
              case GridEnum.circleAxisGrid:
                addition = Object.assign({
                  x: targetElement.getGraphicAttribute("x"),
                  y: targetElement.getGraphicAttribute("y"),
                  center: targetElement.getGraphicAttribute("center"),
                  radius: targetElement.getGraphicAttribute("radius"),
                  innerRadius: targetElement.getGraphicAttribute("innerRadius"),
                  inside: targetElement.getGraphicAttribute("inside"),
                  startAngle: targetElement.getGraphicAttribute("startAngle"),
                  endAngle: targetElement.getGraphicAttribute("endAngle")
                }, addition);
            }
          } else {
            scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
            const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), coordinate = null === (_c = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _c ? void 0 : _c.call(scaleGrammar);
            coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout, true), addition));
          }
          this._getGridComponentType() === GridEnum.lineAxisGrid && (addition = "line" !== this.spec.gridShape && this.spec.gridShape ? Object.assign({
            center: addition.start,
            closed: true
          }, addition, {
            type: this.spec.gridShape
          }) : Object.assign({}, addition, {
            type: "line"
          }));
          const scale4 = null === (_d = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _d ? void 0 : _d.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getGridComponentType()) {
            case GridEnum.lineAxisGrid:
              return generateLineAxisGridAttributes(scale4, theme2, addition, tickCount);
            case GridEnum.circleAxisGrid:
              return generateCircleAxisGridAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getGridComponentType() {
    var _a;
    if (this._gridComponentType) return this._gridComponentType;
    if (this.spec.gridType) if ("circle" === this.spec.gridType) this._gridComponentType = GridEnum.circleAxisGrid;
    else this._gridComponentType = GridEnum.lineAxisGrid;
    else if (this._targetAxis) {
      switch (this._targetAxis.getAxisComponentType()) {
        case AxisEnum.circleAxis:
          this._gridComponentType = GridEnum.circleAxisGrid;
          break;
        case AxisEnum.lineAxis:
        default:
          this._gridComponentType = GridEnum.lineAxisGrid;
      }
    } else if (this.spec.scale) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this._gridComponentType = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? GridEnum.lineAxisGrid : GridEnum.circleAxisGrid : GridEnum.lineAxisGrid;
    } else this._gridComponentType = GridEnum.lineAxisGrid;
    return this._gridComponentType;
  }
};
Grid.componentType = ComponentEnum.grid;
var registerLineGrid = () => {
  Factory3.registerGraphicComponent(GridEnum.lineAxisGrid, (attrs, options) => new LineAxisGrid(attrs, options)), Factory3.registerComponent(ComponentEnum.grid, Grid);
};
var registerCircleGrid = () => {
  Factory3.registerGraphicComponent(GridEnum.circleAxisGrid, (attrs, options) => new CircleAxisGrid(attrs, options)), Factory3.registerComponent(ComponentEnum.grid, Grid);
};

// node_modules/@visactor/vgrammar-core/es/interactions/scrollbar-filter.js
var ScrollbarFilter = class _ScrollbarFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _ScrollbarFilter.type, this.options = Object.assign({}, _ScrollbarFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "scrollbar" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const scrollbar2 = this._marks[0];
    if (!this._data || !scrollbar2) return [];
    const filter2 = this.options.target.filter, transform30 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => {
      const scale4 = scrollbar2.getScale().getScale(), range2 = scale4.range(), datumRatio = (scale4.scale(datum[filter2]) - range2[0]) / (range2[range2.length - 1] - range2[0]);
      return filterValue.startRatio <= datumRatio && filterValue.endRatio >= datumRatio;
    } : filter2;
    return this._filterData(this._data, scrollbar2, DataFilterRank.scrollbar, (event) => {
      if (isString_default(filter2)) {
        const range2 = event.detail.value, scaleGrammar = scrollbar2.getScale();
        if (scaleGrammar) {
          const scale4 = scaleGrammar.getScale(), scaleRange = scale4.range();
          return {
            start: scale4.invert(range2[0] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
            end: scale4.invert(range2[1] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
            startRatio: range2[0],
            endRatio: range2[1]
          };
        }
        return {
          startRatio: range2[0],
          endRatio: range2[1]
        };
      }
      return {
        startRatio: event.detail.value[0],
        endRatio: event.detail.value[1]
      };
    }, dataFilter, transform30), [{
      type: "scrollUp",
      handler: this.handleFilter
    }, {
      type: "scrollDrag",
      handler: this.handleFilter
    }];
  }
};
ScrollbarFilter.type = "scrollbar-filter", ScrollbarFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/scrollbar.js
var generateScrollbarAttributes = (groupSize, direction, position, theme2, addition) => {
  var _a, _b, _c, _d, _e;
  const scrollbarTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.scrollbar;
  let finalDirection = "horizontal", finalPosition = "bottom";
  isValidDirection(direction) || isValidPosition(position) ? !isValidDirection(direction) && isValidPosition(position) ? (finalDirection = isHorizontalPosition(position) ? "horizontal" : "vertical", finalPosition = position) : isValidDirection(direction) && !isValidPosition(position) ? (finalDirection = direction, finalPosition = isHorizontal(direction) ? "bottom" : "right") : (finalDirection = direction, finalPosition = isHorizontal(direction) && !isHorizontalPosition(position) ? "bottom" : isVertical(direction) && isHorizontalPosition(position) ? "right" : position) : (finalDirection = "horizontal", finalPosition = "bottom");
  const attributes = {
    direction: finalDirection
  };
  if (isHorizontal(finalDirection)) {
    const size = null !== (_c = null !== (_b = addition.height) && void 0 !== _b ? _b : null == scrollbarTheme ? void 0 : scrollbarTheme.height) && void 0 !== _c ? _c : 12;
    "top" === finalPosition ? Object.assign(attributes, {
      width: groupSize.width,
      height: size,
      x: 0,
      y: 0
    }) : Object.assign(attributes, {
      width: groupSize.width,
      height: size,
      x: 0,
      y: groupSize.height - size
    });
  } else {
    const size = null !== (_e = null !== (_d = addition.width) && void 0 !== _d ? _d : null == scrollbarTheme ? void 0 : scrollbarTheme.width) && void 0 !== _e ? _e : 12;
    "left" === finalPosition ? Object.assign(attributes, {
      width: size,
      height: groupSize.height,
      x: 0,
      y: 0
    }) : Object.assign(attributes, {
      width: size,
      height: groupSize.height,
      x: groupSize.width - size,
      y: 0
    });
  }
  return merge({}, scrollbarTheme, attributes, null != addition ? addition : {});
};
var Scrollbar = class extends ScaleComponent {
  constructor(view, group) {
    super(view, ComponentEnum.scrollbar, group), this.spec.componentType = ComponentEnum.scrollbar;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.container(spec.container), this.direction(spec.direction), this.position(spec.position), this;
  }
  container(container2) {
    if (this.spec.container) {
      const prevContainer = isString_default(this.spec.container) ? this.view.getMarkById(this.spec.container) : this.spec.container;
      this.detach(prevContainer);
    }
    if (this.spec.container = container2, container2) {
      const nextContainer = isString_default(container2) ? this.view.getMarkById(container2) : container2;
      this.attach(nextContainer);
    }
    return this.commit(), this;
  }
  direction(direction) {
    return this.setFunctionSpec(direction, "direction");
  }
  position(position) {
    return this.setFunctionSpec(position, "position");
  }
  setScrollStart(start) {
    var _a;
    const scrollbar2 = this.getGroupGraphicItem(), range2 = null === (_a = null == scrollbar2 ? void 0 : scrollbar2.attribute) || void 0 === _a ? void 0 : _a.range;
    if (scrollbar2 && range2) {
      const nextRange = [start, range2[1] - range2[0] + start];
      scrollbar2.setScrollRange(nextRange);
    }
    return this;
  }
  getScrollRange() {
    const scrollbar2 = this.getGroupGraphicItem();
    if (scrollbar2) return scrollbar2.getScrollRange();
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      range: [0, 1]
    }, attrs), graphicItem = Factory3.createGraphicComponent(ComponentEnum.scrollbar, initialAttributes, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), direction = invokeFunctionType(this.spec.direction, parameters, datum, element), position = invokeFunctionType(this.spec.position, parameters, datum, element), addition = invokeEncoder(encoder2, datum, element, parameters), targetMark = this.spec.container ? isString_default(this.spec.container) ? this.view.getMarkById(this.spec.container) : this.spec.container : null, groupGraphicItem = (targetMark && targetMark.markType === GrammarMarkType.group ? targetMark : this.group).getGroupGraphicItem(), size = groupGraphicItem ? {
            width: null !== (_a = groupGraphicItem.attribute.width) && void 0 !== _a ? _a : groupGraphicItem.AABBBounds.width(),
            height: null !== (_b = groupGraphicItem.attribute.height) && void 0 !== _b ? _b : groupGraphicItem.AABBBounds.height()
          } : {
            width: this.view.width(),
            height: this.view.height()
          };
          return generateScrollbarAttributes(size, direction, position, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Scrollbar.componentType = ComponentEnum.scrollbar;

// node_modules/@visactor/vgrammar-core/es/transforms/data/filter.js
var transform = (options, data, parameters) => data.filter((entry) => options.callback(entry, parameters));

// node_modules/@visactor/vgrammar-core/es/transforms/data/map.js
var transform2 = (options, upstreamData, params2) => {
  const func = options.callback, as = options.as;
  if (!options.all) return upstreamData.forEach((entry) => {
    const data2 = func(entry, params2);
    if (!isNil_default(as)) {
      if (isNil_default(entry)) return;
      entry[as] = data2;
    }
    return data2;
  }), upstreamData;
  const data = func(upstreamData, params2);
  return isNil_default(as) || isNil_default(upstreamData) ? data : (upstreamData[as] = data, upstreamData);
};

// node_modules/@visactor/vgrammar-core/es/transforms/data/kde.js
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2PI2 = Math.sqrt((2 * Math.PI) ** 2);

// node_modules/@visactor/vgrammar-core/es/transforms/util/util.js
function sum2(arr) {
  return arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}
function average2(arr) {
  if (0 === arr.length) return 0;
  return sum2(arr) / arr.length;
}

// node_modules/@visactor/vgrammar-core/es/transforms/data/sampling.js
var samplerMap = {
  min: minInArray,
  max: maxInArray,
  average: average2,
  sum: sum2
};
function lttb(size, array2, isGroup, yfield) {
  const frameSize = Math.floor(array2.length / size), newIndices = [], len = array2.length;
  let maxArea, area2, nextIndex, currentIndex = 0, sampledIndex = 0;
  newIndices[sampledIndex++] = currentIndex;
  for (let i = 1; i < len - 1; i += frameSize) {
    const nextFrameStart = Math.min(i + frameSize, len - 1), nextFrameEnd = Math.min(i + 2 * frameSize, len), avgX = (nextFrameEnd + nextFrameStart) / 2;
    let avgY = 0;
    for (let idx2 = nextFrameStart; idx2 < nextFrameEnd; idx2++) {
      const value = array2[idx2][yfield];
      Number.isNaN(value) || (avgY += value);
    }
    avgY /= nextFrameEnd - nextFrameStart;
    const frameStart = i, frameEnd = Math.min(i + frameSize, len), pointAX = i - 1, pointAY = array2[currentIndex][yfield];
    maxArea = -1, nextIndex = frameStart;
    for (let idx2 = frameStart; idx2 < frameEnd; idx2++) {
      const value = array2[idx2][yfield];
      Number.isNaN(yfield) || (area2 = Math.abs((pointAX - avgX) * (value - pointAY) - (pointAX - idx2) * (avgY - pointAY)), area2 > maxArea && (maxArea = area2, nextIndex = idx2));
    }
    newIndices[sampledIndex++] = nextIndex, currentIndex = nextIndex;
  }
  newIndices[sampledIndex - 1] !== len - 1 && (newIndices[sampledIndex++] = len - 1);
  return newIndices.map((i) => isGroup ? array2[i].i : i);
}
function sample(size, array2, isGroup, mode, yfield) {
  let frameSize = Math.floor(array2.length / size);
  const newIndices = [], len = array2.length;
  let sampledIndex = 0, frameValues = [];
  newIndices.push(sampledIndex), array2[sampledIndex][yfield] = array2[sampledIndex][yfield];
  for (let i = 1; i < len - 1; i += frameSize) {
    frameSize > len - i && (frameSize = len - i, frameValues.length = frameSize), frameValues = [];
    for (let k2 = 0; k2 < frameSize; k2++) frameValues.push(array2[i + k2][yfield]);
    const value = samplerMap[mode](frameValues);
    sampledIndex = Math.min(Math.round(i + frameValues.length / 2) || 0, len - 1), array2[sampledIndex][yfield] = value, newIndices.push(sampledIndex);
  }
  return newIndices.map((i) => isGroup ? array2[i].i : i);
}
function sampleMin(size, array2, isGroup, yfield) {
  return sample(size, array2, isGroup, "min", yfield);
}
function sampleMax(size, array2, isGroup, yfield) {
  return sample(size, array2, isGroup, "max", yfield);
}
function sampleAverage(size, array2, isGroup, yfield) {
  return sample(size, array2, isGroup, "average", yfield);
}
function sampleSum(size, array2, isGroup, yfield) {
  return sample(size, array2, isGroup, "sum", yfield);
}
var transform3 = (options, upstreamData) => {
  let size = options.size;
  const factor = options.factor || 1;
  if (Array.isArray(size) && (size = Math.floor(size[1] - size[0])), size *= factor, size <= 0) return [];
  if (upstreamData.length <= size) return upstreamData;
  if (options.skipfirst) return upstreamData.slice(0, 1);
  const { mode, yfield: y, groupBy: groupBy2 } = options, yfield = null != y ? y : "y";
  let sampler = lttb;
  if ("min" === mode ? sampler = sampleMin : "max" === mode ? sampler = sampleMax : "average" === mode ? sampler = sampleAverage : "sum" === mode && (sampler = sampleSum), upstreamData.length) {
    const groups2 = {};
    if (groupBy2) {
      for (let i = 0, n = upstreamData.length; i < n; i++) {
        const datum = upstreamData[i], groupId = datum[groupBy2];
        groups2[groupId] ? groups2[groupId].push({
          [yfield]: datum[yfield],
          i
        }) : (groups2[groupId] = [], groups2[groupId].push({
          [yfield]: datum[yfield],
          i
        }));
      }
      let rawIndice = [];
      return Object.keys(groups2).forEach((groupName) => {
        const group = groups2[groupName];
        if (group.length <= size) {
          const indices = group.map((datum) => datum.i);
          rawIndice = rawIndice.concat(indices);
        } else {
          const indices = sampler(size, group, true, yfield);
          rawIndice = rawIndice.concat(indices), group.forEach((datum) => upstreamData[datum.i][yfield] = datum[yfield]);
        }
      }), rawIndice.sort((a3, b) => a3 - b), rawIndice.map((index) => upstreamData[index]);
    }
    return sampler(size, upstreamData, false, yfield).map((index) => upstreamData[index]);
  }
  return [];
};

// node_modules/@visactor/vgrammar-core/es/transforms/mark/mark-overlap.js
function reset2(elements) {
  return elements.forEach((element) => {
    element.getGraphicAttribute(MARK_OVERLAP_HIDE_KEY) && (element.setGraphicAttribute("visible", true), element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, false));
  }), elements;
}
function overlapX(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastX = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastX = currentX, lastR = r;
    });
  }
}
function overlapY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastY = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r = element.getGraphicAttribute("size") / 2, currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r;
    });
  }
}
function overlapXY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    const lastX = -1 / 0;
    let lastY = -1 / 0, lastR = 0, dis = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x"), currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (lastX - currentX) ** 2 + (lastY - currentY) ** 2, dis < (itemDelta + lastR + r) ** 2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r;
    });
  }
}
var transform4 = (options, upstreamData) => {
  if (!upstreamData || 0 === upstreamData.length) return;
  let { radius } = options;
  isNil_default(radius) && "symbol" === upstreamData[0].mark.markType && (radius = true);
  const { direction, delta, deltaMul = 1, groupBy: groupBy2 } = options, handleOverlap = (elements) => {
    reset2(elements);
    const sortedElements = options.sort ? elements.slice().sort((a3, b) => a3.getGraphicAttribute("x") - b.getGraphicAttribute("x")) : elements;
    0 === direction ? overlapXY(sortedElements, delta, deltaMul, radius) : 1 === direction ? overlapX(sortedElements, delta, deltaMul, radius) : overlapY(sortedElements, delta, deltaMul, radius);
  };
  if (groupBy2) {
    const map4 = upstreamData.reduce((res, element) => {
      const groupName = element.getDatum()[groupBy2];
      return res[groupName] ? res[groupName].push(element) : res[groupName] = [element], res;
    }, {});
    Object.keys(map4).forEach((key) => {
      handleOverlap(map4[key]);
    });
  } else handleOverlap(upstreamData);
  return upstreamData;
};

// node_modules/@visactor/vgrammar-core/es/transforms/index.js
var registerFilterTransform = () => {
  Factory3.registerTransform("filter", {
    transform,
    markPhase: "beforeJoin"
  }, true);
};
var registerMapTransform = () => {
  Factory3.registerTransform("map", {
    transform: transform2,
    markPhase: "beforeJoin"
  }, true);
};
var registerSampleTransform = () => {
  Factory3.registerTransform("sampling", {
    transform: transform3,
    markPhase: "afterEncode"
  }, true);
};
var registerMarkOverlapTransform = () => {
  Factory3.registerTransform("markoverlap", {
    transform: transform4,
    markPhase: "afterEncode"
  }, true);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/clip.js
var clipIn = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", false), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", false)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange: 0,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange: 0
    },
    to: {
      clipRange
    }
  };
};
var clipOut = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", true), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", true)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange: 0,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange
    },
    to: {
      clipRange: 0
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/fade.js
var fadeIn2 = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  const attrs = null !== (_a = element.getFinalAnimationAttributes()) && void 0 !== _a ? _a : {};
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_b = attrs.opacity) && void 0 !== _b ? _b : 1,
      fillOpacity: null !== (_c = attrs.fillOpacity) && void 0 !== _c ? _c : 1,
      strokeOpacity: null !== (_d = attrs.strokeOpacity) && void 0 !== _d ? _d : 1
    }
  };
};
var fadeOut2 = (element, options, animationParameters) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = element.getGraphicAttribute("opacity", true)) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = element.getGraphicAttribute("fillOpacity", true)) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = element.getGraphicAttribute("strokeOpacity", true)) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-cartesian.js
var growCenterIn = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
      return {
        from: isValid_default(width) ? {
          x: x + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x + x1) / 2,
          x1: (x + x1) / 2,
          width: void 0
        },
        to: {
          x,
          x1,
          width
        }
      };
    }
    case "y": {
      const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
      return {
        from: isValid_default(height) ? {
          y: y + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y + y1) / 2,
          y1: (y + y1) / 2,
          height: void 0
        },
        to: {
          y,
          y1,
          height
        }
      };
    }
    default: {
      const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width"), y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height"), from = {};
      return isValid_default(width) ? (from.x = x + width / 2, from.width = 0, from.x1 = void 0) : (from.x = (x + x1) / 2, from.x1 = (x + x1) / 2, from.width = void 0), isValid_default(height) ? (from.y = y + height / 2, from.height = 0, from.y1 = void 0) : (from.y = (y + y1) / 2, from.y1 = (y + y1) / 2, from.height = void 0), {
        from,
        to: {
          x,
          y,
          x1,
          y1,
          width,
          height
        }
      };
    }
  }
};
var growCenterOut = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
      return {
        to: isValid_default(width) ? {
          x: x + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x + x1) / 2,
          x1: (x + x1) / 2,
          width: void 0
        }
      };
    }
    case "y": {
      const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
      return {
        to: isValid_default(height) ? {
          y: y + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y + y1) / 2,
          y1: (y + y1) / 2,
          height: void 0
        }
      };
    }
    default: {
      const x = element.getFinalAnimationAttribute("x"), y = element.getFinalAnimationAttribute("y"), x1 = element.getFinalAnimationAttribute("x1"), y1 = element.getFinalAnimationAttribute("y1"), width = element.getFinalAnimationAttribute("width"), height = element.getFinalAnimationAttribute("height"), to = {};
      return isValid_default(width) ? (to.x = x + width / 2, to.width = 0, to.x1 = void 0) : (to.x = (x + x1) / 2, to.x1 = (x + x1) / 2, to.width = void 0), isValid_default(height) ? (to.y = y + height / 2, to.height = 0, to.y1 = void 0) : (to.y = (y + y1) / 2, to.y1 = (y + y1) / 2, to.height = void 0), {
        to
      };
    }
  }
};
function growWidthInIndividual(element, options, animationParameters) {
  const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x, x + width) : Math.max(x, x1);
    return {
      from: {
        x: computedX1,
        x1: isNil_default(x1) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      },
      to: {
        x,
        x1,
        width
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x, x + width) : Math.min(x, x1);
  return {
    from: {
      x: computedX,
      x1: isNil_default(x1) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x,
      x1,
      width
    }
  };
}
function growWidthInOverall(element, options, animationParameters) {
  var _a;
  const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? null == options ? void 0 : options.overall : 0, {
    from: {
      x: overallValue,
      x1: isNil_default(x1) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x,
      x1,
      width
    }
  };
}
var growWidthIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthInOverall(element, options, animationParameters) : growWidthInIndividual(element, options, animationParameters);
};
function growWidthOutIndividual(element, options, animationParameters) {
  const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x, x + width) : Math.max(x, x1);
    return {
      to: {
        x: computedX1,
        x1: isNil_default(x1) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x, x + width) : Math.min(x, x1);
  return {
    to: {
      x: computedX,
      x1: isNil_default(x1) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
function growWidthOutOverall(element, options, animationParameters) {
  var _a;
  const x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      x: overallValue,
      x1: isNil_default(x1) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
var growWidthOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthOutOverall(element, options, animationParameters) : growWidthOutIndividual(element, options, animationParameters);
};
function growHeightInIndividual(element, options, animationParameters) {
  const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y, y + height) : Math.max(y, y1);
    return {
      from: {
        y: computedY1,
        y1: isNil_default(y1) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      },
      to: {
        y,
        y1,
        height
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y, y + height) : Math.min(y, y1);
  return {
    from: {
      y: computedY,
      y1: isNil_default(y1) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y,
      y1,
      height
    }
  };
}
function growHeightInOverall(element, options, animationParameters) {
  var _a;
  const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    from: {
      y: overallValue,
      y1: isNil_default(y1) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y,
      y1,
      height
    }
  };
}
var growHeightIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightInOverall(element, options, animationParameters) : growHeightInIndividual(element, options, animationParameters);
};
function growHeightOutIndividual(element, options, animationParameters) {
  const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y, y + height) : Math.max(y, y1);
    return {
      to: {
        y: computedY1,
        y1: isNil_default(y1) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y, y + height) : Math.min(y, y1);
  return {
    to: {
      y: computedY,
      y1: isNil_default(y1) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
function growHeightOutOverall(element, options, animationParameters) {
  var _a;
  const y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      y: overallValue,
      y1: isNil_default(y1) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
var growHeightOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(element, options, animationParameters) : growHeightOutIndividual(element, options, animationParameters);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-polar.js
var growAngleInIndividual = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes();
  return options && "anticlockwise" === options.orient ? {
    from: {
      startAngle: null == attrs ? void 0 : attrs.endAngle
    },
    to: {
      startAngle: null == attrs ? void 0 : attrs.startAngle
    }
  } : {
    from: {
      endAngle: null == attrs ? void 0 : attrs.startAngle
    },
    to: {
      endAngle: null == attrs ? void 0 : attrs.endAngle
    }
  };
};
var growAngleInOverall = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes();
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: overallValue2,
        endAngle: overallValue2
      },
      to: {
        startAngle: null == attrs ? void 0 : attrs.startAngle,
        endAngle: null == attrs ? void 0 : attrs.endAngle
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: overallValue,
      endAngle: overallValue
    },
    to: {
      startAngle: null == attrs ? void 0 : attrs.startAngle,
      endAngle: null == attrs ? void 0 : attrs.endAngle
    }
  };
};
var growAngleIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleInOverall(element, options) : growAngleInIndividual(element, options);
};
var growAngleOutIndividual = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes();
  return options && "anticlockwise" === options.orient ? {
    from: {
      startAngle: element.getGraphicAttribute("startAngle", true)
    },
    to: {
      startAngle: null == attrs ? void 0 : attrs.endAngle
    }
  } : {
    from: {
      endAngle: element.getGraphicAttribute("endAngle", true)
    },
    to: {
      endAngle: null == attrs ? void 0 : attrs.startAngle
    }
  };
};
var growAngleOutOverall = (element, options, animationParameters) => {
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: element.getGraphicAttribute("startAngle", true),
        endAngle: element.getGraphicAttribute("endAngle", true)
      },
      to: {
        startAngle: overallValue2,
        endAngle: overallValue2
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: element.getGraphicAttribute("startAngle", true),
      endAngle: element.getGraphicAttribute("endAngle", true)
    },
    to: {
      startAngle: overallValue,
      endAngle: overallValue
    }
  };
};
var growAngleOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(element, options) : growAngleOutIndividual(element, options);
};
var growRadiusInIndividual = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes();
  return options && "inside" === options.orient ? {
    from: {
      innerRadius: null == attrs ? void 0 : attrs.outerRadius
    },
    to: {
      innerRadius: null == attrs ? void 0 : attrs.innerRadius
    }
  } : {
    from: {
      outerRadius: null == attrs ? void 0 : attrs.innerRadius
    },
    to: {
      outerRadius: null == attrs ? void 0 : attrs.outerRadius
    }
  };
};
var growRadiusInOverall = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes(), overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: overallValue,
      outerRadius: overallValue
    },
    to: {
      innerRadius: null == attrs ? void 0 : attrs.innerRadius,
      outerRadius: null == attrs ? void 0 : attrs.outerRadius
    }
  };
};
var growRadiusIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusInOverall(element, options) : growRadiusInIndividual(element, options);
};
var growRadiusOutIndividual = (element, options, animationParameters) => {
  const attrs = element.getFinalAnimationAttributes();
  return options && "inside" === options.orient ? {
    from: {
      innerRadius: element.getGraphicAttribute("innerRadius", true)
    },
    to: {
      innerRadius: null == attrs ? void 0 : attrs.outerRadius
    }
  } : {
    from: {
      outerRadius: element.getGraphicAttribute("outerRadius", true)
    },
    to: {
      outerRadius: null == attrs ? void 0 : attrs.innerRadius
    }
  };
};
var growRadiusOutOverall = (element, options, animationParameters) => {
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: element.getGraphicAttribute("innerRadius", true),
      outerRadius: element.getGraphicAttribute("outerRadius", true)
    },
    to: {
      innerRadius: overallValue,
      outerRadius: overallValue
    }
  };
};
var growRadiusOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusOutOverall(element, options) : growRadiusOutIndividual(element, options);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-points.js
var getCenterPoints = (element, options, animationParameters) => {
  const points = element.getGraphicAttribute("points", false), center2 = {
    x: 0,
    y: 0
  };
  return points.forEach((point6) => {
    center2.x += point6.x, center2.y += point6.y;
  }), center2.x /= points.length, center2.y /= points.length, options && options.center && (isValidNumber_default(options.center.x) && (center2.x = options.center.x), isValidNumber_default(options.center.y) && (center2.y = options.center.y)), "area" === element.mark.markType && (center2.x1 = center2.x, center2.y1 = center2.y), points.map((point6) => Object.assign({}, point6, center2));
};
var growPointsIn = (element, options, animationParameters) => ({
  from: {
    points: getCenterPoints(element, options)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: getCenterPoints(element, options)
  }
});
var changePointsX = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point6) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupRight = animationParameters.width;
    return animationParameters.group && (groupRight = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = groupRight), Object.assign(Object.assign({}, point6), {
      x: groupRight,
      y: point6.y,
      x1: groupRight,
      y1: point6.y1,
      defined: false !== point6.defined
    });
  }
  return Object.assign(Object.assign({}, point6), {
    x: 0,
    y: point6.y,
    x1: 0,
    y1: point6.y1,
    defined: false !== point6.defined
  });
});
var growPointsXIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsX(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsXOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsX(element, options, animationParameters)
  }
});
var changePointsY = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point6) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupBottom = animationParameters.height;
    return animationParameters.group && (groupBottom = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = groupBottom), Object.assign(Object.assign({}, point6), {
      x: point6.x,
      y: groupBottom,
      x1: point6.x1,
      y1: groupBottom,
      defined: false !== point6.defined
    });
  }
  return Object.assign(Object.assign({}, point6), {
    x: point6.x,
    y: 0,
    x1: point6.x1,
    y1: 0,
    defined: false !== point6.defined
  });
});
var growPointsYIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsY(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsYOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsY(element, options, animationParameters)
  }
});

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/move.js
var moveIn = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction, point: pointOpt, excludeChannels = [] } = null != options ? options : {};
  let changedX = 0, changedY = 0;
  "negative" === orient && (animationParameters.group ? (changedX = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), changedY = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), animationParameters.groupWidth = changedX, animationParameters.groupHeight = changedY) : (changedX = animationParameters.width, changedY = animationParameters.height)), changedX += offset, changedY += offset;
  const point6 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point6 && isValidNumber_default(point6.x) ? point6.x : changedX, fromY = point6 && isValidNumber_default(point6.y) ? point6.y : changedY, finalAttrsX = excludeChannels.includes("x") ? element.getGraphicAttribute("x") : element.getFinalAnimationAttribute("x"), finalAttrsY = excludeChannels.includes("y") ? element.getGraphicAttribute("y") : element.getFinalAnimationAttribute("y");
  switch (direction) {
    case "x":
      return {
        from: {
          x: fromX
        },
        to: {
          x: finalAttrsX
        }
      };
    case "y":
      return {
        from: {
          y: fromY
        },
        to: {
          y: finalAttrsY
        }
      };
    default:
      return {
        from: {
          x: fromX,
          y: fromY
        },
        to: {
          x: finalAttrsX,
          y: finalAttrsY
        }
      };
  }
};
var moveOut = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction, point: pointOpt } = null != options ? options : {}, groupBounds = animationParameters.group ? animationParameters.group.getBounds() : null, groupWidth = null !== (_a = null == groupBounds ? void 0 : groupBounds.width()) && void 0 !== _a ? _a : animationParameters.width, groupHeight = null !== (_b = null == groupBounds ? void 0 : groupBounds.height()) && void 0 !== _b ? _b : animationParameters.height, changedX = ("negative" === orient ? groupWidth : 0) + offset, changedY = ("negative" === orient ? groupHeight : 0) + offset, point6 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point6 && isValidNumber_default(point6.x) ? point6.x : changedX, fromY = point6 && isValidNumber_default(point6.y) ? point6.y : changedY;
  switch (direction) {
    case "x":
      return {
        from: {
          x: element.getGraphicAttribute("x", true)
        },
        to: {
          x: fromX
        }
      };
    case "y":
      return {
        from: {
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          y: fromY
        }
      };
    default:
      return {
        from: {
          x: element.getGraphicAttribute("x", true),
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          x: fromX,
          y: fromY
        }
      };
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/scale.js
var scaleIn2 = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  const attrs = element.getFinalAnimationAttributes();
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: 0
        },
        to: {
          scaleX: null !== (_a = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _a ? _a : 1
        }
      };
    case "y":
      return {
        from: {
          scaleY: 0
        },
        to: {
          scaleY: null !== (_b = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _b ? _b : 1
        }
      };
    default:
      return {
        from: {
          scaleX: 0,
          scaleY: 0
        },
        to: {
          scaleX: null !== (_c = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _d ? _d : 1
        }
      };
  }
};
var scaleOut2 = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: null !== (_a = element.getGraphicAttribute("scaleX", true)) && void 0 !== _a ? _a : 1
        },
        to: {
          scaleX: 0
        }
      };
    case "y":
      return {
        from: {
          scaleY: null !== (_b = element.getGraphicAttribute("scaleY", true)) && void 0 !== _b ? _b : 1
        },
        to: {
          scaleY: 0
        }
      };
    default:
      return {
        from: {
          scaleX: null !== (_c = element.getGraphicAttribute("scaleX", true)) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = element.getGraphicAttribute("scaleY", true)) && void 0 !== _d ? _d : 1
        },
        to: {
          scaleX: 0,
          scaleY: 0
        }
      };
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/update.js
var BUILT_IN_EXCLUDE_CHANNELS = {
  symbol: ["_mo_hide_", "visible"]
};
var update2 = (element, options, animationParameters) => {
  const from = Object.assign({}, element.getPrevGraphicAttributes()), to = Object.assign({}, element.getNextGraphicAttributes());
  let excludeChannels;
  options && array(options.excludeChannels).forEach((key) => {
    delete from[key], delete to[key];
  }), element.mark && element.mark.markType && (excludeChannels = BUILT_IN_EXCLUDE_CHANNELS[element.mark.markType]) && excludeChannels.forEach((key) => {
    delete from[key], delete to[key];
  }), Object.keys(to).forEach((key) => {
    isEqual(from[key], to[key]) && (delete from[key], delete to[key]);
  });
  const final = element.getFinalGraphicAttributes();
  return Object.keys(from).forEach((key) => {
    isNil_default(to[key]) && (isNil_default(final[key]) || isEqual(from[key], final[key]) ? delete from[key] : to[key] = final[key]);
  }), {
    from,
    to
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/rotate.js
var rotateIn = (element, options, animationParameters) => {
  var _a;
  const attributeAngle = null !== (_a = element.getFinalAnimationAttribute("angle")) && void 0 !== _a ? _a : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(attributeAngle / (2 * Math.PI), 0) ? Math.round(attributeAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(attributeAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(attributeAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: angle2
    },
    to: {
      angle: attributeAngle
    }
  };
};
var rotateOut = (element, options, animationParameters) => {
  var _a;
  const finalAngle = null !== (_a = element.getGraphicAttribute("angle", true)) && void 0 !== _a ? _a : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: finalAngle
    },
    to: {
      angle: angle2
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/index.js
var registerClipInAnimation = () => {
  Factory3.registerAnimationType("clipIn", clipIn);
};
var registerClipOutAnimation = () => {
  Factory3.registerAnimationType("clipOut", clipOut);
};
var registerFadeInAnimation = () => {
  Factory3.registerAnimationType("fadeIn", fadeIn2);
};
var registerFadeOutAnimation = () => {
  Factory3.registerAnimationType("fadeOut", fadeOut2);
};
var registerGrowCenterInAnimation = () => {
  Factory3.registerAnimationType("growCenterIn", growCenterIn);
};
var registerGrowCenterOutAnimation = () => {
  Factory3.registerAnimationType("growCenterOut", growCenterOut);
};
var registerGrowHeightInAnimation = () => {
  Factory3.registerAnimationType("growHeightIn", growHeightIn);
};
var registerGrowHeightOutAnimation = () => {
  Factory3.registerAnimationType("growHeightOut", growHeightOut);
};
var registerGrowWidthInAnimation = () => {
  Factory3.registerAnimationType("growWidthIn", growWidthIn);
};
var registerGrowWidthOutAnimation = () => {
  Factory3.registerAnimationType("growWidthOut", growWidthOut);
};
var registerGrowPointsInAnimation = () => {
  Factory3.registerAnimationType("growPointsIn", growPointsIn);
};
var registerGrowPointsOutAnimation = () => {
  Factory3.registerAnimationType("growPointsOut", growPointsOut);
};
var registerGrowPointsXInAnimation = () => {
  Factory3.registerAnimationType("growPointsXIn", growPointsXIn);
};
var registerGrowPointsXOutAnimation = () => {
  Factory3.registerAnimationType("growPointsXOut", growPointsXOut);
};
var registerGrowPointsYInAnimation = () => {
  Factory3.registerAnimationType("growPointsYIn", growPointsYIn);
};
var registerGrowPointsYOutAnimation = () => {
  Factory3.registerAnimationType("growPointsYOut", growPointsYOut);
};
var registerGrowAngleInAnimation = () => {
  Factory3.registerAnimationType("growAngleIn", growAngleIn);
};
var registerGrowAngleOutAnimation = () => {
  Factory3.registerAnimationType("growAngleOut", growAngleOut);
};
var registerGrowRadiusInAnimation = () => {
  Factory3.registerAnimationType("growRadiusIn", growRadiusIn);
};
var registerGrowRadiusOutAnimation = () => {
  Factory3.registerAnimationType("growRadiusOut", growRadiusOut);
};
var registerMoveInAnimation = () => {
  Factory3.registerAnimationType("moveIn", moveIn);
};
var registerMoveOutAnimation = () => {
  Factory3.registerAnimationType("moveOut", moveOut);
};
var registerScaleInAnimation = () => {
  Factory3.registerAnimationType("scaleIn", scaleIn2);
};
var registerScaleOutAnimation = () => {
  Factory3.registerAnimationType("scaleOut", scaleOut2);
};
var registerRotateInAnimation = () => {
  Factory3.registerAnimationType("rotateIn", rotateIn);
};
var registerRotateOutAnimation = () => {
  Factory3.registerAnimationType("rotateOut", rotateOut);
};
var registerUpdateAnimation = () => {
  Factory3.registerAnimationType("update", update2);
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/cell.js
var Cell = class extends Mark {
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(state), this;
  }
  _updateComponentEncoders(state) {
    this._encoders || (this._encoders = {});
    const userEncoder = this.spec.encode[state];
    if (userEncoder && "update" === state) {
      const params2 = this.parameters(), scales = isFunctionType(userEncoder) ? null : Object.keys(userEncoder).reduce((res, channel) => (isScaleEncode(userEncoder[channel]) && (res[channel] = getGrammarOutput(userEncoder[channel].scale, params2)), res), {});
      this._encoders[state] = {
        callback: (datum, element, parameters) => {
          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);
          if (isNil_default(userEncodeRes.size)) {
            const sizeX = scales.x ? getBandWidthOfScale(scales.x) : void 0, sizeY = scales.y ? getBandWidthOfScale(scales.y) : void 0;
            isNil_default(sizeX) && isNil_default(sizeY) ? userEncodeRes.size = 10 : isNil_default(sizeX) ? userEncodeRes.size = sizeY : isNil_default(sizeY) && (userEncodeRes.size = sizeX), userEncodeRes.size = [sizeX, sizeY];
          }
          return isNil_default(userEncodeRes.shape) && (userEncodeRes.shape = "rect"), userEncodeRes;
        }
      };
    } else this._encoders[state] = userEncoder;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
  getAttributeTransforms() {
    return [{
      channels: ["size", "padding"],
      transform: (graphicAttributes, nextAttrs, storedAttrs) => {
        if (isNumber_default(storedAttrs.padding) && storedAttrs.padding > 0) graphicAttributes.size = isArray_default(storedAttrs.size) ? storedAttrs.size.map((entry) => Math.max(entry - storedAttrs.padding, 1)) : Math.max(storedAttrs.size - storedAttrs.padding, 1);
        else if (isArray_default(storedAttrs.padding) && 2 === storedAttrs.padding.length) {
          const arraySize = isArray_default(storedAttrs.size) ? storedAttrs.size : [storedAttrs.size, storedAttrs.size];
          graphicAttributes.size = [Math.max(arraySize[0] - storedAttrs.padding[0], 1), Math.max(arraySize[1] - storedAttrs.padding[1], 1)];
        } else graphicAttributes.size = storedAttrs.size;
      },
      storedAttrs: "paddingAttrs"
    }].concat(transformsByType.symbol);
  }
  release() {
    super.release(), this._encoders = null;
  }
};
Cell.markType = GrammarMarkType.cell;
var registerCellMark = () => {
  Factory3.registerMark(GrammarMarkType.cell, Cell);
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/interval.js
var Interval = class extends Mark {
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(state), this;
  }
  _updateComponentEncoders(state) {
    this._encoders || (this._encoders = {});
    const userEncoder = this.spec.encode[state];
    if (userEncoder && "update" === state) {
      const params2 = this.parameters(), scales = isFunctionType(userEncoder) ? null : Object.keys(userEncoder).reduce((res, channel) => (isScaleEncode(userEncoder[channel]) && (res[channel] = getGrammarOutput(userEncoder[channel].scale, params2)), res), {});
      this._encoders[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c;
          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);
          if (this.disableCoordinateTransform = false, scales && scales.x && scales.x.type === ScaleEnum.Band) {
            if (!isNil_default(scales.y)) {
              const domain = scales.y.domain(), min3 = minInArray(domain), max3 = maxInArray(domain), baseValue = min3 > 0 ? min3 : max3 < 0 ? max3 : 0;
              userEncodeRes.y1 = scales.y.scale(baseValue);
            }
            const bandWidth = scales.x.bandwidth();
            userEncodeRes.x = userEncodeRes.x + bandWidth / 4, userEncodeRes.x1 = userEncodeRes.x + bandWidth / 2;
          } else if (scales && scales.y && scales.y.type === ScaleEnum.Band) {
            if (!isNil_default(scales.x)) {
              const domain = scales.x.domain(), min3 = minInArray(domain), max3 = maxInArray(domain), baseValue = min3 > 0 ? min3 : max3 < 0 ? max3 : 0;
              userEncodeRes.x1 = scales.x.scale(baseValue);
            }
            const bandWidth = scales.y.bandwidth();
            userEncodeRes.y = userEncodeRes.y + bandWidth / 4, userEncodeRes.y1 = userEncodeRes.y + bandWidth / 2;
          }
          if (scales) {
            const coord = (null !== (_b = this.view.getScaleById(null === (_a = userEncoder.x) || void 0 === _a ? void 0 : _a.scale)) && void 0 !== _b ? _b : this.view.getScaleById(null === (_c = userEncoder.y) || void 0 === _c ? void 0 : _c.scale)).getCoordinate();
            if (coord && "polar" === coord.type) {
              this.disableCoordinateTransform = true;
              const origin = coord.origin();
              userEncodeRes.cx = origin.x, userEncodeRes.cy = origin.y;
            }
          }
          return userEncodeRes;
        }
      };
    } else this._encoders[state] = userEncoder;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
  getAttributeTransforms() {
    return this.coord && "polar" === this.coord.output().type ? [{
      channels: ["x", "y", "x1", "y1", "cx", "cy"],
      transform: (graphicAttributes, nextAttrs, storedAttrs) => {
        graphicAttributes.x = storedAttrs.cx, graphicAttributes.y = storedAttrs.cy, this.coord.output().isTransposed() ? (graphicAttributes.startAngle = storedAttrs.y, graphicAttributes.endAngle = storedAttrs.y1, graphicAttributes.innerRadius = storedAttrs.x, graphicAttributes.outerRadius = storedAttrs.x1) : (graphicAttributes.startAngle = storedAttrs.x, graphicAttributes.endAngle = storedAttrs.x1, graphicAttributes.innerRadius = storedAttrs.y, graphicAttributes.outerRadius = storedAttrs.y1);
      },
      storedAttrs: "sizeAttrs"
    }] : transformsByType.rect;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = createGraphicItem(this, this.coord && "polar" === this.coord.output().type ? GrammarMarkType.arc : GrammarMarkType.rect, attrs);
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
  release() {
    super.release(), this._encoders = null;
  }
};
Interval.markType = GrammarMarkType.interval;

// node_modules/@visactor/vgrammar-core/es/graph/layout/relative.js
var defaultLayoutOrder = {
  [ComponentEnum.axis]: 0,
  [ComponentEnum.legend]: 1,
  [ComponentEnum.slider]: 2,
  [ComponentEnum.player]: 3,
  [ComponentEnum.datazoom]: 4
};

// node_modules/@visactor/vgrammar-core/es/view/animate.js
var ViewAnimate = class {
  constructor(view) {
    this._animations = [], this._additionalAnimateMarks = [], this.isEnabled = true, this._onAnimationStart = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_START, {}), this._animations = this._animations.concat({
        config: event.animationConfig,
        mark: event.mark
      });
    }, this._onAnimationEnd = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), this._animations = this._animations.filter((animation) => animation.config !== event.animationConfig || animation.mark !== event.mark), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_END, {});
    }, this._view = view, this._view.addEventListener(HOOK_EVENT.ANIMATION_START, this._onAnimationStart), this._view.addEventListener(HOOK_EVENT.ANIMATION_END, this._onAnimationEnd);
  }
  stop() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  pause() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this;
  }
  resume() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this;
  }
  enable() {
    return this.isEnabled = true, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enable) || void 0 === _b || _b.call(_a));
    }), this;
  }
  disable() {
    return this.isEnabled = false, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disable) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  enableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  disableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  isAnimating() {
    return 0 !== this._animations.length || this._additionalAnimateMarks.some((mark) => {
      var _a;
      return (null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating()) || false;
    });
  }
  animate() {
    return this.isEnabled ? (this._view.traverseMarkTree((mark) => {
      mark.isUpdated && mark.animate && mark.animate.animate(), mark.cleanExitElements(), mark.isUpdated = false;
    }, null, true), this) : this;
  }
  animateAddition(additionMark) {
    var _a;
    const animate = null === (_a = additionMark.animate) || void 0 === _a ? void 0 : _a.animate();
    return animate && animate.isAnimating() && this._additionalAnimateMarks.push(additionMark), this;
  }
  release() {
    this._additionalAnimateMarks = [], this._animations = [], this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_START, this._onAnimationStart), this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_END, this._onAnimationEnd), this._view = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/view/view-animate-mixin.js
var ViewAnimateMixin = class {
  initAnimate(view) {
    return this.animate = new ViewAnimate(view), this.animate;
  }
};
var registerViewAnimateAPI = () => {
  mixin(View, ViewAnimateMixin);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/attribute.js
var transformAnimationAttributes = (attributes, element) => {
  if (!attributes) return null;
  if (attributes.from) {
    const from = attributes.from, fromKeys = Object.keys(from);
    fromKeys.forEach((channel) => {
      isNil_default(from[channel]) && delete from[channel];
    });
    const computePoints = isValidPointsChannel(fromKeys, element.mark.markType) && !isValid_default(from.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, from)
      }));
      attributes.from = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  if (attributes.to) {
    const to = attributes.to, toKeys = Object.keys(to);
    toKeys.forEach((channel) => {
      isNil_default(to[channel]) && delete to[channel];
    });
    const computePoints = isValidPointsChannel(toKeys, element.mark.markType) && !isValid_default(to.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, to)
      }));
      attributes.to = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  return attributes;
};
function typeAnimationAttributes(element, effect, animationParameters, parameters) {
  const options = isFunction_default(effect.options) ? effect.options.call(null, element.getDatum(), element, parameters) : effect.options;
  if (!effect.type || !Factory3.getAnimationType(effect.type)) return null;
  const attributes = Factory3.getAnimationType(effect.type)(element, options, animationParameters);
  return transformAnimationAttributes(attributes, element);
}
var parseChannelValue = (element, channel, channelValue, animationParameters, parameters) => isFunction_default(channelValue) ? channelValue(element.getDatum(), element, parameters) : channelValue;
function channelAnimationAttributes(element, effect, animationParameters, parameters) {
  const channel = effect.channel;
  let attributes = null;
  return isArray_default(channel) ? attributes = channel.reduce((res, key) => (res.from[key] = element.getGraphicAttribute(key, true), res.to[key] = element.getGraphicAttribute(key, false), res), {
    from: {},
    to: {}
  }) : isObject_default(channel) && (attributes = Object.keys(channel).reduce((res, key) => {
    var _a, _b;
    const hasFrom = !isNil_default(null === (_a = channel[key]) || void 0 === _a ? void 0 : _a.from), hasTo = !isNil_default(null === (_b = channel[key]) || void 0 === _b ? void 0 : _b.to);
    return (hasFrom || hasTo) && (res.from[key] = hasFrom ? parseChannelValue(element, 0, channel[key].from, 0, parameters) : void 0, res.to[key] = hasTo ? parseChannelValue(element, 0, channel[key].to, 0, parameters) : element.getGraphicAttribute(key, false)), res;
  }, {
    from: {},
    to: {}
  })), transformAnimationAttributes(attributes, element);
}
var CustomInterpolator = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this._interpolator = null == params2 ? void 0 : params2.interpolator, this._element = null == params2 ? void 0 : params2.element;
  }
  onBind() {
    var _a, _b;
    this.from = null !== (_a = this.from) && void 0 !== _a ? _a : {}, this.to = null !== (_b = this.to) && void 0 !== _b ? _b : {};
  }
  getEndProps() {
    return this.to;
  }
  onUpdate(end, ratio, out) {
    this._interpolator && this._element && this._interpolator.call(this, ratio, this.from, this.to, out, this._element.getDatum(), this._element, this.params.parameters);
  }
};
var AttributeAnimate = class extends ACustomAnimate {
  getEndProps() {
    return this.to;
  }
  onBind() {
    var _a;
    const excludedChannelMap = null !== (_a = this.target.constructor.NOWORK_ANIMATE_ATTR) && void 0 !== _a ? _a : NOWORK_ANIMATE_ATTR, excludedChannels = Object.keys(excludedChannelMap).filter((channel) => 0 !== excludedChannelMap[channel]);
    this.subAnimate.animate.preventAttrs(excludedChannels);
    const from = Object.assign({}, this.from), to = Object.assign({}, this.to), animatedChannels = [];
    Object.keys(to).forEach((k2) => {
      excludedChannels.includes(k2) ? (from[k2] = to[k2], this.from[k2] = to[k2]) : isNil_default(from[k2]) ? from[k2] = this.target.getComputedAttribute(k2) : animatedChannels.push(k2);
    }), this.target.animates.forEach((a3) => {
      a3 !== this.subAnimate.animate && a3.preventAttrs(animatedChannels);
    }), this._fromAttribute = from, this._toAttribute = to;
  }
  onStart() {
    if (this._fromAttribute) {
      const from = {};
      Object.keys(this._fromAttribute).forEach((key) => {
        this.subAnimate.animate.validAttr(key) && (from[key] = this._fromAttribute[key]);
      }), this.target.setAttributes(from, false, {
        type: AttributeUpdateType.ANIMATE_UPDATE,
        animationState: {
          ratio: 0,
          end: false
        }
      });
    }
  }
  onEnd() {
    if (this._toAttribute) {
      const out = {};
      Object.keys(this._toAttribute).forEach((key) => {
        this.subAnimate.animate.validAttr(key) && (out[key] = this._toAttribute[key]);
      }), this.target.setAttributes(out, false, {
        type: AttributeUpdateType.ANIMATE_END
      });
    }
  }
  update(end, ratio, out) {
    0 === this.updateCount && this.onFirstRun(), this.updateCount += 1;
    const lastProps = this.step.getLastProps();
    Object.keys(lastProps).forEach((key) => {
      this.subAnimate.animate.validAttr(key) && (out[key] = lastProps[key]);
    }), this.onUpdate(end, ratio, out), end && this.onEnd();
  }
  onUpdate(end, ratio, out) {
    this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this._toAttribute, this._fromAttribute);
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animator.js
Animate.mode |= AnimateMode.SET_ATTR_IMMEDIATELY;
var GlobalAnimatorId = 0;
var isCustomAnimateCtor = (custom) => {
  var _a;
  if (isNil_default(custom) || isNil_default(custom.prototype)) return false;
  const prototype = null !== (_a = custom.prototype) && void 0 !== _a ? _a : {};
  return prototype instanceof ACustomAnimate || "onBind" in prototype && "onStart" in prototype && "onEnd" in prototype && "onUpdate" in prototype;
};
var Animator = class {
  constructor(element, unit, animationOptions) {
    this.id = GlobalAnimatorId++, this.isAnimating = false, this.runnings = [], this.element = element, this.animationOptions = animationOptions, this.unit = unit;
  }
  callback(callbackFunction) {
    return this.callbackFunction = callbackFunction, this;
  }
  animate(animationParameters, parameters) {
    return this.isAnimating = true, this.animateElement(animationParameters, parameters), 0 === this.runnings.length && this.animationEnd(), this;
  }
  stop(stopState = "end", invokeCallback = true) {
    return this.runnings.forEach((running) => running.stop(stopState)), this.animationEnd(invokeCallback), this;
  }
  pause() {
    return this.runnings.forEach((running) => running.pause()), this;
  }
  resume() {
    return this.runnings.forEach((running) => running.resume()), this;
  }
  startAt(startTime) {
    return this.runnings.forEach((running) => {
      const initialDelay = this.unit.initialDelay;
      running.startAt(initialDelay + startTime);
    }), this;
  }
  getTotalAnimationTime() {
    var _a;
    const timeLineDuration = this.unit.initialDelay + this.unit.loopDuration * this.unit.loopCount;
    return null !== (_a = this.unit.totalTime) && void 0 !== _a ? _a : timeLineDuration;
  }
  getEndAttributes() {
    return this.runnings.reduce((attributes, running) => Object.assign(attributes, running.getEndProps()), {});
  }
  animationEnd(invokeCallback = true) {
    var _a;
    this.isAnimating = false, this.runnings = null, invokeCallback && (null === (_a = this.callbackFunction) || void 0 === _a || _a.call(null));
  }
  animateElement(animationParameters, parameters) {
    const graphicItem = this.element.getGraphicItem();
    if (!graphicItem) return;
    const graphicAnimate = graphicItem.animate();
    this.runnings.push(graphicAnimate), graphicAnimate.startAt(this.unit.initialDelay), graphicAnimate.wait(this.unit.loopDelay), this.unit.timeSlices.forEach((timeSlice) => {
      this.animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters);
    }), graphicAnimate.wait(this.unit.loopDelayAfter), graphicAnimate.loop(this.unit.loopCount - 1), isValidNumber_default(this.unit.totalTime) && setTimeout(() => {
      graphicAnimate && graphicAnimate.stop("end");
    }, this.unit.totalTime), graphicAnimate.onEnd(() => {
      this.runnings = this.runnings.filter((running) => running !== graphicAnimate), 0 === this.runnings.length && this.animationEnd();
    });
  }
  animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters) {
    const delay = timeSlice.delay, delayAfter = timeSlice.delayAfter, duration = timeSlice.duration, effects = timeSlice.effects;
    if (delay > 0 && graphicAnimate.wait(delay), effects.length < 0) graphicAnimate.wait(duration);
    else {
      const customAnimates = effects.map((effect, index) => {
        var _a;
        const attributes = null !== (_a = effect.type ? typeAnimationAttributes(this.element, effect, animationParameters, parameters) : effect.channel ? channelAnimationAttributes(this.element, effect, animationParameters, parameters) : void 0) && void 0 !== _a ? _a : {}, customOption = attributes.custom || (null == effect ? void 0 : effect.custom), customParametersOption = (null == attributes ? void 0 : attributes.customParameters) || (null == effect ? void 0 : effect.customParameters);
        attributes.from && Object.keys(attributes.from).length && this.unit && this.animationOptions.timeline.controlOptions.immediatelyApply && "component" !== this.element.mark.markType && this.element.getGraphicItem().setAttributes(attributes.from);
        const isCustomAnimate = isCustomAnimateCtor(customOption);
        return !isNil_default(customOption) && !isCustomAnimateCtor(customOption) ? new CustomInterpolator(attributes.from, attributes.to, duration, effect.easing, {
          interpolator: customOption,
          element: this.element,
          parameters: customParametersOption
        }) : isCustomAnimate ? new customOption(attributes.from, attributes.to, duration, effect.easing, customParametersOption) : attributes.to ? new AttributeAnimate(attributes.from, attributes.to, duration, effect.easing) : void 0;
      }).filter((animate) => !isNil_default(animate));
      1 === customAnimates.length ? graphicAnimate.play(customAnimates[0]) : customAnimates.length > 1 && graphicAnimate.play(new AnimateGroup(duration, customAnimates));
    }
    delayAfter > 0 && graphicAnimate.wait(delayAfter);
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/config.js
function transformToTimelineConfig(animationConfig2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (isNil_default(animationConfig2.timeSlices)) {
    const typeConfig = animationConfig2;
    return {
      startTime: null !== (_a = typeConfig.startTime) && void 0 !== _a ? _a : DefaultAnimationStartTime,
      totalTime: typeConfig.totalTime,
      oneByOne: null !== (_b = typeConfig.oneByOne) && void 0 !== _b ? _b : DefaultAnimationOneByOne,
      loop: null !== (_c = typeConfig.loop) && void 0 !== _c ? _c : DefaultAnimationLoop,
      controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_d = typeConfig.controlOptions) && void 0 !== _d ? _d : {}),
      timeSlices: [{
        duration: null !== (_e = typeConfig.duration) && void 0 !== _e ? _e : DefaultAnimationDuration,
        delay: null !== (_f = typeConfig.delay) && void 0 !== _f ? _f : DefaultAnimationDelay,
        delayAfter: null !== (_g = typeConfig.delayAfter) && void 0 !== _g ? _g : DefaultAnimationDelayAfter,
        effects: [{
          type: typeConfig.type,
          channel: typeConfig.channel,
          custom: typeConfig.custom,
          easing: null !== (_h = typeConfig.easing) && void 0 !== _h ? _h : DefaultAnimationEasing,
          customParameters: typeConfig.customParameters,
          options: typeConfig.options
        }]
      }]
    };
  }
  const formattedTimeSlices = array(animationConfig2.timeSlices).filter((timeSlice) => timeSlice.effects && array(timeSlice.effects).filter((effect) => effect.channel || effect.type).length);
  if (formattedTimeSlices.length) return {
    startTime: null !== (_j = animationConfig2.startTime) && void 0 !== _j ? _j : DefaultAnimationStartTime,
    totalTime: animationConfig2.totalTime,
    oneByOne: null !== (_k = animationConfig2.oneByOne) && void 0 !== _k ? _k : DefaultAnimationOneByOne,
    loop: null !== (_l = animationConfig2.loop) && void 0 !== _l ? _l : DefaultAnimationLoop,
    controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_m = animationConfig2.controlOptions) && void 0 !== _m ? _m : {}),
    timeSlices: formattedTimeSlices.map((timeSlice) => {
      var _a2, _b2;
      return {
        duration: timeSlice.duration,
        delay: null !== (_a2 = timeSlice.delay) && void 0 !== _a2 ? _a2 : DefaultAnimationDelay,
        delayAfter: null !== (_b2 = timeSlice.delayAfter) && void 0 !== _b2 ? _b2 : DefaultAnimationDelayAfter,
        effects: array(timeSlice.effects).filter((effect) => effect.channel || effect.type).map((effect) => {
          var _a3;
          return {
            type: effect.type,
            channel: effect.channel,
            custom: effect.custom,
            easing: null !== (_a3 = effect.easing) && void 0 !== _a3 ? _a3 : DefaultAnimationEasing,
            customParameters: effect.customParameters,
            options: effect.options
          };
        })
      };
    }),
    partitioner: animationConfig2.partitioner,
    sort: animationConfig2.sort
  };
}
function normalizeAnimationConfig(config2) {
  let normalizedConfig = [];
  return Object.keys(config2).forEach((state) => {
    normalizedConfig = normalizedConfig.concat(normalizeStateAnimationConfig(state, config2[state]));
  }), normalizedConfig;
}
function normalizeStateAnimationConfig(state, config2, initialIndex = 0) {
  const normalizedConfig = [];
  let index = initialIndex;
  return array(config2).forEach((animationConfig2) => {
    var _a;
    const timelineConfig = transformToTimelineConfig(animationConfig2);
    timelineConfig && (normalizedConfig.push({
      state,
      id: null !== (_a = timelineConfig.id) && void 0 !== _a ? _a : `${state}-${index}`,
      timeline: timelineConfig,
      originConfig: animationConfig2
    }), index += 1);
  }), normalizedConfig;
}
function invokeAnimateSpec(spec, element, parameters) {
  return isFunction_default(spec) ? spec.call(null, element.getDatum(), element, parameters) : spec;
}

// node_modules/@visactor/vgrammar-core/es/graph/animation/arranger.js
var Arranger = class {
  constructor(animators) {
    this.parallelArrangers = [this], this.totalTime = 0, this.startTime = 0, this.endTime = 0, this.animators = animators.filter((animator) => !isNil_default(animator)), this.totalTime = this.animators.reduce((time, animator) => Math.max(time, animator.getTotalAnimationTime()), 0);
  }
  parallel(arranger) {
    const parallelArrangers = Array.from(new Set(this.parallelArrangers.concat(arranger.parallelArrangers)));
    return parallelArrangers.forEach((arranger2) => {
      arranger2.parallelArrangers = parallelArrangers;
    }), this.arrangeTime(), this;
  }
  after(arranger) {
    return this.afterArranger = arranger, this.arrangeTime(), this;
  }
  arrangeTime() {
    const parallelTime = this.parallelArrangers.reduce((time, arranger) => Math.max(time, arranger.totalTime), this.totalTime), startTime = this.parallelArrangers.reduce((time, arranger) => {
      var _a, _b;
      return Math.max(time, null !== (_b = null === (_a = arranger.afterArranger) || void 0 === _a ? void 0 : _a.endTime) && void 0 !== _b ? _b : 0);
    }, 0);
    this.parallelArrangers.forEach((arranger) => {
      arranger.startTime = startTime, arranger.endTime = startTime + parallelTime, arranger.animators.forEach((animator) => {
        animator.startAt(startTime);
      });
    });
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animate.js
var Animate2 = class {
  constructor(mark, config2) {
    this.state = null, this.immediateConfigs = [], this.isEnabled = true, this.disabledStates = [], this.animators = /* @__PURE__ */ new Map(), this.elementRecorder = /* @__PURE__ */ new WeakMap(), this.timelineCount = {}, this.mark = mark, this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  getAnimationConfigs(animationState) {
    var _a;
    return this.isEnabled ? (null !== (_a = this.configs) && void 0 !== _a ? _a : []).filter((config2) => config2.state === animationState) : [];
  }
  updateConfig(config2) {
    this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  updateState(state) {
    this.state = state;
  }
  animate() {
    if (!this.isEnabled || !this.configs || !this.configs.length) return;
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters();
    return elements.forEach((element) => {
      var _a;
      element.isReserved && element.diffState !== DiffState.exit && (element.isReserved = false);
      const prevElementState = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.prevState;
      (this.configs.some((config2) => prevElementState !== element.diffState && config2.state === prevElementState && config2.timeline.controlOptions.stopWhenStateChange) || element.diffState === DiffState.exit && prevElementState !== element.diffState) && this.clearElementAnimation(element, false);
    }), this.configs.forEach((config2) => {
      this.animateByTimeline(config2, elements, parameters);
    }), this.mark.cleanExitElements(), this;
  }
  runAnimationByState(animationState) {
    if (!this.isEnabled) return;
    const stateConfigs = this.configs.filter((config2) => config2.state === animationState), elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = stateConfigs.reduce((animators2, config2) => animators2.concat(this.animateByTimeline(config2, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stopAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.stop("end")), this;
  }
  pauseAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.pause()), this;
  }
  resumeAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.resume()), this;
  }
  run(config2) {
    if (!this.isEnabled) return;
    const parsedConfigs = normalizeStateAnimationConfig(ImmediateAnimationState, config2, this.immediateConfigs.length);
    this.immediateConfigs = this.immediateConfigs.concat(parsedConfigs);
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = parsedConfigs.reduce((animators2, config3) => animators2.concat(this.animateByTimeline(config3, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stop() {
    return this.animators.forEach((animators) => {
      animators.forEach((animator) => animator.stop("end"));
    }), this;
  }
  pause() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.pause())), this;
  }
  resume() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.resume())), this;
  }
  reverse() {
    return this;
  }
  restart() {
    return this;
  }
  record() {
    return this;
  }
  recordEnd() {
    return this;
  }
  isAnimating() {
    let isAnimating = false;
    return this.animators.forEach((animators) => {
      isAnimating = isAnimating || animators.some((animator) => animator.isAnimating);
    }), isAnimating;
  }
  isElementAnimating(element) {
    var _a;
    const stateAnimationCounts = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.count;
    return isNil_default(stateAnimationCounts) || Object.values(stateAnimationCounts).every((count) => 0 === count);
  }
  getAnimatorCount() {
    let count = 0;
    return this.animators.forEach((animators) => count += animators.length), count;
  }
  getAllAnimators() {
    const allAnimators = [];
    return this.animators.forEach((animators) => {
      allAnimators.push(...animators);
    }), allAnimators;
  }
  getElementAnimators(element, animationState) {
    var _a;
    const elements = array(element);
    let animators = [];
    return animationState ? animators = null !== (_a = this.animators.get(animationState)) && void 0 !== _a ? _a : [] : this.animators.forEach((stateAnimators) => {
      animators = animators.concat(stateAnimators);
    }), animators.filter((animator) => elements.includes(animator.element));
  }
  enable() {
    return this.isEnabled = true, this;
  }
  disable() {
    return this.isEnabled = false, this.stop(), this.animators.clear(), this;
  }
  enableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.filter((state2) => !states.includes(state2)), this;
  }
  disableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.concat(states), this;
  }
  release() {
    this.stop(), this.animators.clear(), this.configs = null, this.animators = null, this.elementRecorder = null, this.timelineCount = null;
  }
  animateByTimeline(config2, elements, parameters, forceState = false) {
    var _a;
    const animators = [], animatedElements = elements.filter((element) => {
      const checkExit = !(element.isReserved && element.diffState === DiffState.exit), state = this.getAnimationState(element), checkDisabled = !this.disabledStates.includes(state), checkState = forceState || state === config2.state, checkPartitioner = !config2.timeline.partitioner || config2.timeline.partitioner(element.getDatum(), element, parameters);
      return checkExit && checkDisabled && checkState && checkPartitioner;
    });
    if (animatedElements.length) {
      isNil_default(this.timelineCount[config2.id]) && (this.timelineCount[config2.id] = 0), config2.timeline.sort && animatedElements.sort((elementA, elementB) => config2.timeline.sort(elementA.getDatum(), elementB.getDatum(), elementA, elementB, parameters));
      const animationParameters = {
        width: this.mark.view.width(),
        height: this.mark.view.height(),
        group: null !== (_a = this.mark.group) && void 0 !== _a ? _a : null,
        mark: this.mark,
        view: this.mark.view,
        elementCount: animatedElements.length,
        elementIndex: 0
      };
      animatedElements.forEach((element) => {
        var _a2;
        (null !== (_a2 = this.animators.get(config2.state)) && void 0 !== _a2 ? _a2 : []).filter((animator) => animator.element === element && animator.animationOptions.id === config2.id).forEach((animator) => {
          animator.stop(null, false), this.handleAnimatorEnd(animator, false);
        });
      }), animatedElements.forEach((element, index) => {
        animationParameters.elementIndex = index;
        const mergedParameters = Object.assign({
          [DefaultAnimationParameters]: animationParameters
        }, parameters), animationUnit = this.getAnimationUnit(config2.timeline, element, index, animatedElements.length, mergedParameters);
        animators.push(this.animateElement(config2, animationUnit, element, animationParameters, mergedParameters));
      });
    }
    return animators;
  }
  animateElement(config2, animationUnit, element, animationParameters, parameters) {
    var _a, _b;
    const animator = new Animator(element, animationUnit, config2);
    if (animator.animate(animationParameters, parameters), !animator.isAnimating) return;
    element.diffState === DiffState.exit && (element.isReserved = true);
    const isFirstAnimator = 0 === this.timelineCount[config2.id];
    this.timelineCount[config2.id] += 1;
    const elementRecord = null !== (_a = this.elementRecorder.get(element)) && void 0 !== _a ? _a : {
      prevState: config2.state,
      count: {}
    };
    elementRecord.prevState = config2.state, elementRecord.count[config2.state] = (null !== (_b = elementRecord.count[config2.state]) && void 0 !== _b ? _b : 0) + 1, this.elementRecorder.set(element, elementRecord);
    const stateData = this.animators.get(config2.state);
    stateData ? stateData.push(animator) : this.animators.set(config2.state, [animator]), animator.callback(() => {
      this.handleAnimatorEnd(animator);
    });
    const animationEvent = {
      mark: this.mark,
      animationState: config2.state,
      animationConfig: config2.originConfig
    };
    return isFirstAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_START, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_START, animationEvent, element), animator;
  }
  getAnimationState(element) {
    const customState = invokeFunctionType(this.state, this.mark.parameters(), element.getDatum(), element);
    return null != customState ? customState : element.diffState;
  }
  getAnimationUnit(timeline, element, index, elementCount, parameters) {
    const timeSlices = [], startTime = invokeAnimateSpec(timeline.startTime, element, parameters), totalTime = invokeAnimateSpec(timeline.totalTime, element, parameters), oneByOne = invokeAnimateSpec(timeline.oneByOne, element, parameters), loop = invokeAnimateSpec(timeline.loop, element, parameters);
    let loopTime = 0;
    timeline.timeSlices.forEach((timeSlice) => {
      var _a;
      const delay = invokeAnimateSpec(timeSlice.delay, element, parameters), delayAfter = invokeAnimateSpec(timeSlice.delayAfter, element, parameters), duration = null !== (_a = invokeAnimateSpec(timeSlice.duration, element, parameters)) && void 0 !== _a ? _a : totalTime / elementCount, effects = array(timeSlice.effects).map((effect) => Object.assign({}, effect, {
        customParameters: invokeAnimateSpec(effect.customParameters, element, parameters)
      }));
      timeSlices.push({
        effects,
        duration,
        delay,
        delayAfter
      }), loopTime += delay + duration + delayAfter;
    });
    const oneByOneDelay = isNumber_default(oneByOne) ? oneByOne : true === oneByOne ? loopTime : 0;
    return {
      initialDelay: startTime,
      loopCount: isNumber_default(loop) ? loop : true === loop ? 1 / 0 : 1,
      loopDelay: oneByOneDelay * index,
      loopDelayAfter: oneByOneDelay * (elementCount - index - 1),
      loopAnimateDuration: loopTime,
      loopDuration: loopTime + oneByOneDelay * (elementCount - 1),
      totalTime,
      timeSlices
    };
  }
  clearElementAnimation(element, clearElement = true) {
    this.animators.forEach((animators) => {
      animators.forEach((animator) => {
        animator.element === element && (animator.animationOptions.state === DiffState.exit ? animator.stop("start", false) : animator.stop("end", false), this.handleAnimatorEnd(animator, clearElement));
      });
    }), this.elementRecorder.delete(element);
  }
  clearAllElements() {
    const elements = this.mark.getAllElements();
    elements && elements.forEach((element, i) => {
      this.clearElement(element, i === elements.length - 1);
    });
  }
  clearElement(element, updateMark = true) {
    this.clearElementAnimation(element), element.getGraphicItem() && (element.clearGraphicAttributes(), element.diffState === DiffState.exit && (element.isReserved = false), updateMark && this.mark.cleanExitElements());
  }
  handleAnimatorEnd(animator, clearElement = true) {
    const element = animator.element, animationOptions = animator.animationOptions, animationState = animationOptions.state, isImmediateAnimation = animationState === ImmediateAnimationState, stateAnimationCounts = this.elementRecorder.get(element).count;
    stateAnimationCounts[animationState] -= 1, this.animators.set(animationState, this.animators.get(animationState).filter((ani) => ani !== animator)), 0 === this.animators.get(animationState).length && this.animators.delete(animationState), this.timelineCount[animationOptions.id] -= 1;
    const isLastAnimator = 0 === this.timelineCount[animationOptions.id], originAnimationConfig = isImmediateAnimation ? this.immediateConfigs.find((config2) => config2.id === animationOptions.id).originConfig : this.configs.find((config2) => config2.id === animationOptions.id).originConfig;
    isLastAnimator && (delete this.timelineCount[animationOptions.id], isImmediateAnimation && (this.immediateConfigs = this.immediateConfigs.filter((config2) => config2.id !== animationOptions.id))), clearElement && (0 === Object.keys(this.timelineCount).length ? this.clearAllElements() : animationState === DiffState.exit && 0 === stateAnimationCounts[DiffState.exit] && this.clearElement(element));
    const animationEvent = {
      mark: this.mark,
      animationState,
      animationConfig: originAnimationConfig
    };
    isLastAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_END, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_END, animationEvent, element);
  }
};

// node_modules/@visactor/vgrammar-core/es/view/mark-animate-mixin.js
var MarkAnimateMixin = class {
  constructor() {
    this.animate = new Animate2(this, {});
  }
  initAnimate(spec) {
    this.animate || (this.animate = new Animate2(this, spec.animation), this.needAnimate() && this.animate.updateState(spec.animationState));
  }
  reuseAnimate(mark) {
    this.animate = mark.animate, this.animate.mark = this;
  }
  updateAnimate(spec) {
    this.animate.updateConfig(spec.animation), this.animate.updateState(spec.animationState);
  }
};
var registerMarkAnimateAPI = () => {
  mixin(Mark, MarkAnimateMixin);
};

// node_modules/@visactor/vgrammar-core/es/index.js
var registerDragPlugin = () => {
  Factory3.registerStageEventPlugin("drag", DragNDrop);
};
var registerGesturePlugin = () => {
  Factory3.registerStageEventPlugin("gesture", Gesture);
};
var registerAnimate = () => {
  registerViewAnimateAPI(), registerMarkAnimateAPI();
};

// node_modules/@visactor/vchart/esm/constant/event.js
var BASE_EVENTS = ["pointerdown", "pointerup", "pointerupoutside", "pointertap", "pointerover", "pointermove", "pointerenter", "pointerleave", "pointerout", "mousedown", "mouseup", "mouseupoutside", "rightdown", "rightup", "rightupoutside", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mouseenter", "mouseleave", "wheel", "touchstart", "touchend", "touchendoutside", "touchmove", "touchcancel", "tap", "dragstart", "drag", "dragenter", "dragleave", "dragover", "dragend", "drop", "pan", "panstart", "panend", "press", "pressup", "pressend", "pinch", "pinchstart", "pinchend", "swipe"];
var ChartEvent;
!function(ChartEvent2) {
  ChartEvent2.initialized = "initialized", ChartEvent2.rendered = "rendered", ChartEvent2.renderFinished = "renderFinished", ChartEvent2.animationFinished = "animationFinished", ChartEvent2.regionSeriesDataFilterOver = "regionSeriesDataFilterOver", ChartEvent2.afterInitData = "afterInitData", ChartEvent2.afterInitEvent = "afterInitEvent", ChartEvent2.afterInitMark = "afterInitMark", ChartEvent2.rawDataUpdate = "rawDataUpdate", ChartEvent2.viewDataFilterOver = "viewDataFilterOver", ChartEvent2.viewDataUpdate = "viewDataUpdate", ChartEvent2.viewDataStatisticsUpdate = "viewDataStatisticsUpdate", ChartEvent2.markDeltaYUpdate = "markDeltaYUpdate", ChartEvent2.viewDataLabelUpdate = "viewDataLabelUpdate", ChartEvent2.scaleDomainUpdate = "scaleDomainUpdate", ChartEvent2.scaleUpdate = "scaleUpdate", ChartEvent2.dataZoomChange = "dataZoomChange", ChartEvent2.drill = "drill", ChartEvent2.layoutStart = "layoutStart", ChartEvent2.layoutEnd = "layoutEnd", ChartEvent2.layoutRectUpdate = "layoutRectUpdate", ChartEvent2.playerPlay = "playerPlay", ChartEvent2.playerPause = "playerPause", ChartEvent2.playerEnd = "playerEnd", ChartEvent2.playerChange = "playerChange", ChartEvent2.playerForward = "playerForward", ChartEvent2.playerBackward = "playerBackward", ChartEvent2.scrollBarChange = "scrollBarChange", ChartEvent2.brushStart = "brushStart", ChartEvent2.brushChange = "brushChange", ChartEvent2.brushEnd = "brushEnd", ChartEvent2.brushClear = "brushClear", ChartEvent2.brushActive = "brushActive", ChartEvent2.legendSelectedDataChange = "legendSelectedDataChange", ChartEvent2.legendFilter = "legendFilter", ChartEvent2.legendItemClick = "legendItemClick", ChartEvent2.legendItemHover = "legendItemHover", ChartEvent2.legendItemUnHover = "legendItemUnHover", ChartEvent2.tooltipShow = "tooltipShow", ChartEvent2.tooltipHide = "tooltipHide", ChartEvent2.tooltipRelease = "tooltipRelease", ChartEvent2.afterResize = "afterResize", ChartEvent2.afterRender = "afterRender", ChartEvent2.afterLayout = "afterLayout";
}(ChartEvent || (ChartEvent = {}));
var Event_Source_Type;
!function(Event_Source_Type2) {
  Event_Source_Type2.chart = "chart", Event_Source_Type2.window = "window", Event_Source_Type2.canvas = "canvas";
}(Event_Source_Type || (Event_Source_Type = {}));
var Event_Bubble_Level;
!function(Event_Bubble_Level2) {
  Event_Bubble_Level2.vchart = "vchart", Event_Bubble_Level2.chart = "chart", Event_Bubble_Level2.model = "model", Event_Bubble_Level2.mark = "mark";
}(Event_Bubble_Level || (Event_Bubble_Level = {}));
var EventBubbleLevels = [Event_Bubble_Level.mark, Event_Bubble_Level.model, Event_Bubble_Level.chart, Event_Bubble_Level.vchart];

// node_modules/@visactor/vchart/esm/event/events/dimension/util/common.js
var isInBound = (pos, min3, max3) => pos.x >= min3.x && pos.x <= max3.x && pos.y >= min3.y && pos.y <= max3.y;
var isInRegionBound = (chart, axis2, pos) => {
  const regionList = chart.getRegionsInIds(array(axis2.layout.layoutBindRegionID));
  return null == regionList ? void 0 : regionList.some((region) => {
    const rect = region.getLayoutRect(), startPoint = region.getLayoutStartPoint();
    return isInBound(pos, {
      x: startPoint.x,
      y: startPoint.y
    }, {
      x: rect.width + startPoint.x,
      y: rect.height + startPoint.y
    });
  });
};
var isSameDimensionInfo = (a3, b) => {
  var _a, _b;
  return a3 === b || !isNil_default(a3) && !isNil_default(b) && (a3.value === b.value && (null === (_a = a3.axis) || void 0 === _a ? void 0 : _a.id) === (null === (_b = b.axis) || void 0 === _b ? void 0 : _b.id));
};
var resolveTooltipFilterRange = (spec, scale4) => {
  const range2 = spec.tooltipFilterRange, rangeValue = "function" == typeof range2 ? range2({
    scale: scale4
  }) : range2;
  return isValidNumber_default(rangeValue) ? [-rangeValue, rangeValue] : rangeValue;
};
var getDimensionData = (value, axis2, coordinate, getDimensionField) => {
  var _a;
  const scale4 = axis2.getScale(), isDiscreteAxis2 = isDiscrete(scale4.type), data = [], seriesList = axis2.getOption().getChart().getSeriesInIndex(axis2.getSpecInfo().seriesIndexes);
  for (const series2 of seriesList) if (series2.coordinate === coordinate) {
    const dimensionField = array(getDimensionField(series2)), viewData = null === (_a = series2.getViewData()) || void 0 === _a ? void 0 : _a.latestData;
    if (dimensionField && viewData) if (isDiscreteAxis2) {
      const datums = [], datumIdList = [];
      viewData.forEach((datum, i) => {
        var _a2;
        (null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString()) && (datums.push(datum), datumIdList.push(i));
      }), data.push({
        series: series2,
        datum: datums,
        key: getDimensionDataKey(series2, datumIdList)
      });
    } else if (isValid_default(dimensionField[1])) {
      const datums = [], datumIdList = [];
      viewData.forEach((datum, i) => {
        var _a2;
        ((null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString()) || isValid_default(datum[dimensionField[0]]) && isValid_default(datum[dimensionField[1]]) && value >= datum[dimensionField[0]] && value < datum[dimensionField[1]]) && (datums.push(datum), datumIdList.push(i));
      }), data.push({
        series: series2,
        datum: datums,
        key: getDimensionDataKey(series2, datumIdList)
      });
    } else {
      const spec = axis2.getSpec(), rangeArr = resolveTooltipFilterRange(spec, scale4);
      let datums = [], datumIdList = [];
      if (rangeArr) viewData.forEach((datum, i) => {
        if (isValid_default(datum[dimensionField[0]])) {
          const delta = datum[dimensionField[0]] - value;
          delta >= rangeArr[0] && delta <= rangeArr[1] && (datums.push(datum), datumIdList.push(i));
        }
      });
      else {
        let minDelta = 1 / 0, deltaSign = 0;
        viewData.forEach((datum, i) => {
          if (isValid_default(datum[dimensionField[0]])) {
            const delta = Math.abs(datum[dimensionField[0]] - value), sign2 = Math.sign(datum[dimensionField[0]] - value);
            delta < minDelta ? (minDelta = delta, datums = [datum], datumIdList = [i], deltaSign = sign2) : delta === minDelta && sign2 === deltaSign && (datums.push(datum), datumIdList.push(i));
          }
        });
      }
      data.push({
        series: series2,
        datum: datums,
        key: getDimensionDataKey(series2, datumIdList)
      });
    }
  }
  return data;
};
var getDimensionDataKey = (series2, datumIdList) => `${series2.id}_${datumIdList.join("_")}`;
var getAxis = (chart, filter2, pos) => {
  const axesComponents = chart.getAllComponents().filter((c3) => "axes" === c3.specKey && filter2(c3) && isInRegionBound(chart, c3, pos));
  return axesComponents.length ? axesComponents : null;
};

// node_modules/@visactor/vchart/esm/event/events/dimension/util/polar.js
var angleStandardize = (angle2, range2) => {
  const unit = 2 * Math.PI, min3 = minInArray(range2), max3 = maxInArray(range2);
  return angle2 < min3 ? angle2 += Math.ceil((min3 - angle2) / unit) * unit : angle2 > max3 && (angle2 -= Math.ceil((angle2 - max3) / unit) * unit), angle2;
};
var getPolarDimensionInfo = (chart, pos) => {
  if (!chart) return null;
  const angleAxisList = getAxis(chart, (cmp) => "angle" === cmp.getOrient(), pos), radiusAxisList = getAxis(chart, (cmp) => "radius" === cmp.getOrient(), pos);
  if (!(angleAxisList && angleAxisList.length || radiusAxisList && radiusAxisList.length)) return null;
  const targetAxisInfo = [], getDimensionField = (series2) => series2.getDimensionField()[0], { x, y } = pos;
  return angleAxisList && angleAxisList.forEach((axis2) => {
    var _a;
    const angleScale = axis2.getScale();
    if (angleScale && isDiscrete(angleScale.type)) {
      const angleDomain = angleScale.domain(), angleRange = angleScale.range(), center2 = axis2.getCenter(), vector = {
        x: x - axis2.getLayoutStartPoint().x - center2.x,
        y: y - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 = angleStandardize(angle2, angleRange);
      const radius = distance(vector), radiusScale = null === (_a = radiusAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
      const value = axis2.invert(angle2);
      if (isNil_default(value)) return;
      let index = angleDomain.findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        position: angleScale.scale(value),
        axis: axis2,
        data
      });
    }
  }), radiusAxisList && radiusAxisList.forEach((axis2) => {
    var _a;
    const radiusScale = axis2.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
    if (radiusScale && isDiscrete(radiusScale.type)) {
      const center2 = axis2.getCenter(), vector = {
        x: x - axis2.getLayoutStartPoint().x - center2.x,
        y: y - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 < -Math.PI / 2 && (angle2 = 2 * Math.PI + angle2);
      const radius = distance(vector), angleScale = null === (_a = angleAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), angleRange = null == angleScale ? void 0 : angleScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
      const value = radiusScale.invert(radius);
      if (isNil_default(value)) return;
      let index = radiusScale.domain().findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        position: radiusScale.scale(value),
        axis: axis2,
        data
      });
    }
  }), targetAxisInfo.length ? targetAxisInfo : null;
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/util/common.js
function isXAxis(orient) {
  return "bottom" === orient || "top" === orient;
}
function isYAxis(orient) {
  return "left" === orient || "right" === orient;
}
function isZAxis(orient) {
  return "z" === orient;
}
function autoAxisType(orient, isHorizontal4) {
  return isHorizontal4 ? isXAxis(orient) ? "linear" : "band" : isXAxis(orient) ? "band" : "linear";
}
function getOrient(spec, whiteList) {
  return isValidOrient(spec.orient) || whiteList && whiteList.includes(spec.orient) ? spec.orient : "left";
}
function getDirectionByOrient(orient) {
  return "top" === orient || "bottom" === orient ? "horizontal" : "vertical";
}
function transformInverse(spec, isHorizontal4) {
  let inverse = spec.inverse;
  return isHorizontal4 && !isXAxis(spec.orient) && (inverse = !isValid_default(spec.inverse) || !spec.inverse), inverse;
}
function getCartesianAxisInfo(spec, isHorizontal4) {
  var _a;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : autoAxisType(spec.orient, isHorizontal4);
  return {
    axisType,
    componentName: `${ComponentTypeEnum.cartesianAxis}-${axisType}`
  };
}

// node_modules/@visactor/vchart/esm/event/events/dimension/util/cartesian.js
var discreteXAxisGetDimensionField = (series2) => series2.fieldX[0];
var discreteYAxisGetDimensionField = (series2) => series2.fieldY[0];
var continuousXAxisGetDimensionField = (series2) => {
  var _a;
  return [series2.fieldX[0], null !== (_a = series2.fieldX2) && void 0 !== _a ? _a : series2.fieldX[1]];
};
var continuousYAxisGetDimensionField = (series2) => {
  var _a;
  return [series2.fieldY[0], null !== (_a = series2.fieldY2) && void 0 !== _a ? _a : series2.fieldY[1]];
};
var getDimensionFieldFunc = (isXAxis2, isDiscreteAxis2) => isXAxis2 ? isDiscreteAxis2 ? discreteXAxisGetDimensionField : continuousXAxisGetDimensionField : isDiscreteAxis2 ? discreteYAxisGetDimensionField : continuousYAxisGetDimensionField;
var getCartesianDimensionInfo = (chart, pos, isTooltip) => {
  var _a, _b;
  if (!chart) return null;
  const { x, y } = pos, xAxisList = null !== (_a = getAxis(chart, (cmp) => isXAxis(cmp.getOrient()), pos)) && void 0 !== _a ? _a : [], yAxisList = null !== (_b = getAxis(chart, (cmp) => isYAxis(cmp.getOrient()), pos)) && void 0 !== _b ? _b : [];
  if (!xAxisList.length && !yAxisList.length) return null;
  const bandAxisSet = /* @__PURE__ */ new Set(), linearAxisSet = /* @__PURE__ */ new Set(), forceAxisSet = /* @__PURE__ */ new Set();
  [xAxisList, yAxisList].forEach((axisList) => axisList.forEach((axis2) => {
    isDiscrete(axis2.getScale().type) ? bandAxisSet.add(axis2) : linearAxisSet.add(axis2), isTooltip && axis2.getSpec().hasDimensionTooltip && forceAxisSet.add(axis2);
  }));
  const targetAxisInfo = [], addAxisDimensionInfo = (orient) => {
    const isXAxis2 = "x" === orient, posValue = isXAxis2 ? x : y;
    (isXAxis2 ? xAxisList : yAxisList).forEach((axis2) => {
      if (forceAxisSet.size > 0) {
        if (forceAxisSet.has(axis2)) {
          const info = getDimensionInfoByPosition(axis2, posValue, getDimensionFieldFunc(isXAxis2, isDiscrete(axis2.getScale().type)));
          info && targetAxisInfo.push(info);
        }
      } else {
        const hasDiscreteAxis = bandAxisSet.size > 0;
        if ((hasDiscreteAxis ? bandAxisSet : linearAxisSet).has(axis2)) {
          const info = getDimensionInfoByPosition(axis2, posValue, getDimensionFieldFunc(isXAxis2, hasDiscreteAxis));
          info && targetAxisInfo.push(info);
        }
      }
    });
  };
  return "horizontal" === chart.getSpec().direction ? (addAxisDimensionInfo("y"), 0 === targetAxisInfo.length && addAxisDimensionInfo("x")) : (addAxisDimensionInfo("x"), 0 === targetAxisInfo.length && addAxisDimensionInfo("y")), targetAxisInfo.length ? targetAxisInfo : null;
};
var getDimensionInfoByPosition = (axis2, posValue, getDimensionField) => {
  const value = axis2.positionToData(posValue, true);
  return isNil_default(value) ? null : getDimensionInfoByValue(axis2, value, getDimensionField);
};
var getDimensionInfoByValue = (axis2, value, getDimensionField) => {
  const scale4 = axis2.getScale();
  if (isNil_default(value)) return null;
  let index = scale4.domain().findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
  index < 0 && (index = void 0);
  const data = getDimensionData(value, axis2, "cartesian", null != getDimensionField ? getDimensionField : isXAxis(axis2.getOrient()) ? discreteXAxisGetDimensionField : discreteYAxisGetDimensionField);
  return {
    index,
    value,
    position: scale4.scale(value),
    axis: axis2,
    data
  };
};

// node_modules/@visactor/vchart/esm/event/events/dimension/base.js
var DimensionEvent = class {
  constructor(eventDispatcher, mode) {
    this._eventDispatcher = eventDispatcher, this._mode = mode;
  }
  get chart() {
    var _a, _b;
    return this._chart || (this._chart = null === (_b = (_a = this._eventDispatcher.globalInstance).getChart) || void 0 === _b ? void 0 : _b.call(_a)), this._chart;
  }
  register(eType, handler) {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  unregister() {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  getTargetDimensionInfo(x, y) {
    var _a, _b;
    const cartesianInfo = null !== (_a = getCartesianDimensionInfo(this.chart, {
      x,
      y
    })) && void 0 !== _a ? _a : [], polarInfo = null !== (_b = getPolarDimensionInfo(this.chart, {
      x,
      y
    })) && void 0 !== _b ? _b : [], result2 = [].concat(cartesianInfo, polarInfo);
    return 0 === result2.length ? null : result2;
  }
  dispatch(v, opt) {
    var _a;
    const axes = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c3) => "axes" === c3.specKey && (!(null == opt ? void 0 : opt.filter) || opt.filter(c3))), discreteAxes = axes.filter((axis2) => {
      const scale4 = axis2.getScale();
      return isDiscrete(scale4.type);
    }), dimAxes = discreteAxes.length ? discreteAxes : axes.filter((axis2) => {
      const orient = axis2.getOrient();
      return isXAxis(orient) || "angle" === orient;
    }), dimensionInfo = [];
    return dimAxes.forEach((a3) => {
      const info = getDimensionInfoByValue(a3, v);
      info && dimensionInfo.push(info);
    }), this._callback.call(null, {
      action: "enter",
      dimensionInfo
    }), dimensionInfo;
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/dimension-click.js
var DimensionClickEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this.onClick = (params2) => {
      if (!params2) return;
      const x = params2.event.viewX, y = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x, y);
      targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "click",
        dimensionInfo: targetDimensionInfo.slice()
      }));
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointertap", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onClick
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointertap", {
      query: null,
      callback: this.onClick
    });
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/dimension-hover.js
var DimensionHoverEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this._cacheDimensionInfo = null, this.onMouseMove = (params2) => {
      if (!params2) return;
      const x = params2.event.viewX, y = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x, y);
      null === targetDimensionInfo && null !== this._cacheDimensionInfo ? (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo) : null === targetDimensionInfo || null !== this._cacheDimensionInfo && targetDimensionInfo.length === this._cacheDimensionInfo.length && !targetDimensionInfo.some((info, i) => !isSameDimensionInfo(info, this._cacheDimensionInfo[i])) ? null !== targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "move",
        dimensionInfo: targetDimensionInfo.slice()
      })) : (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "enter",
        dimensionInfo: targetDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo);
    }, this.onMouseOut = (params2) => {
      params2 && (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo ? this._cacheDimensionInfo.slice() : []
      })), this._cacheDimensionInfo = null);
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointermove", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    }), this._eventDispatcher.register("pointerout", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.canvas
      }),
      callback: this.onMouseOut
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.register("pointerdown", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointermove", {
      query: null,
      callback: this.onMouseMove
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.unregister("pointerdown", {
      query: null,
      callback: this.onMouseMove
    });
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/interface.js
var DimensionEventEnum;
!function(DimensionEventEnum2) {
  DimensionEventEnum2.dimensionHover = "dimensionHover", DimensionEventEnum2.dimensionClick = "dimensionClick";
}(DimensionEventEnum || (DimensionEventEnum = {}));

// node_modules/@visactor/vchart/esm/event/events/index.js
var ComposedEventMapper = {
  [DimensionEventEnum.dimensionHover]: DimensionHoverEvent,
  [DimensionEventEnum.dimensionClick]: DimensionClickEvent
};

// node_modules/@visactor/vchart/esm/event/event.js
var Event2 = class {
  getComposedEventMap() {
    return this._composedEventMap;
  }
  constructor(eventDispatcher, mode) {
    this._composedEventMap = /* @__PURE__ */ new Map(), this._eventDispatcher = eventDispatcher, this._mode = mode;
  }
  on(eType, query, callback) {
    const handler = "function" == typeof query ? {
      query: null,
      callback: query
    } : {
      query,
      callback
    };
    if (ComposedEventMapper[eType]) {
      const composedEvent = new ComposedEventMapper[eType](this._eventDispatcher, this._mode);
      composedEvent.register(eType, handler), this._composedEventMap.set(callback, {
        eventType: eType,
        event: composedEvent
      });
    } else this._eventDispatcher.register(eType, handler);
    return this;
  }
  off(eType, query, cb) {
    var _a, _b;
    const callback = null != cb ? cb : query;
    if (ComposedEventMapper[eType]) if (callback) null === (_a = this._composedEventMap.get(callback)) || void 0 === _a || _a.event.unregister(), this._composedEventMap.delete(callback);
    else for (const entry of this._composedEventMap.entries()) entry[1].eventType === eType && (null === (_b = this._composedEventMap.get(entry[0])) || void 0 === _b || _b.event.unregister(), this._composedEventMap.delete(entry[0]));
    else if (callback) {
      const handler = {
        callback,
        query: null,
        filter: {
          nodeName: null,
          type: eType,
          level: null,
          source: query.source,
          markName: null,
          filter: null,
          userId: null
        }
      };
      this._eventDispatcher.unregister(eType, handler);
    } else this._eventDispatcher.unregister(eType);
    return this;
  }
  emit(eType, params2, level) {
    return this._eventDispatcher.dispatch(eType, params2, level), this;
  }
  prevent(eType, except) {
    return this._eventDispatcher.prevent(eType, except), this;
  }
  allow(eType) {
    return this._eventDispatcher.allow(eType), this;
  }
  release() {
    this._eventDispatcher.clear(), this._composedEventMap.clear();
  }
};

// node_modules/@visactor/vchart/esm/event/bubble.js
var Bubble = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._levelNodes = /* @__PURE__ */ new Map(), this._levelNodes.set(Event_Bubble_Level.vchart, []), this._levelNodes.set(Event_Bubble_Level.chart, []), this._levelNodes.set(Event_Bubble_Level.model, []), this._levelNodes.set(Event_Bubble_Level.mark, []);
  }
  addHandler(handler, level) {
    var _a;
    const node = {
      level,
      handler
    };
    return null === (_a = this._levelNodes.get(level)) || void 0 === _a || _a.push(node), this._map.set(handler.callback, node), this;
  }
  removeHandler(handler) {
    const node = this._map.get(handler.callback);
    if (!node) return this;
    this._map.delete(handler.callback);
    const nodes = this._levelNodes.get(node.level), index = null == nodes ? void 0 : nodes.findIndex((n) => n.handler.callback === handler.callback);
    return void 0 !== index && index >= 0 && (null == nodes || nodes.splice(index, 1)), this;
  }
  preventHandler(handler) {
    return handler && (handler.prevented = true), this;
  }
  allowHandler(handler) {
    return handler && (handler.prevented = false), this;
  }
  getHandlers(level) {
    var _a;
    return (null === (_a = this._levelNodes.get(level)) || void 0 === _a ? void 0 : _a.map((node) => node.handler)) || [];
  }
  getAllHandlers() {
    return Array.from(this._map.values()).map((node) => node.handler) || [];
  }
  getCount() {
    return this._map.size;
  }
  release() {
    this._map.clear(), this._levelNodes.clear();
  }
};

// node_modules/@visactor/vchart/esm/event/event-dispatcher.js
var componentTypeMap = {
  cartesianAxis: "axis",
  "cartesianAxis-band": "axis",
  "cartesianAxis-linear": "axis",
  "cartesianAxis-time": "axis",
  polarAxis: "axis",
  "polarAxis-band": "axis",
  "polarAxis-linear": "axis",
  discreteLegend: "legend",
  continuousLegend: "legend",
  colorLegend: "legend",
  sizeLegend: "legend"
};
var EventDispatcher = class {
  constructor(vchart, compiler) {
    this._viewBubbles = /* @__PURE__ */ new Map(), this._windowBubbles = /* @__PURE__ */ new Map(), this._canvasBubbles = /* @__PURE__ */ new Map(), this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this._onDelegate = (listenerParams) => {
      var _a, _b;
      const chart = this.globalInstance.getChart(), model = isValid_default(listenerParams.modelId) && (null == chart ? void 0 : chart.getModelById(listenerParams.modelId)) || void 0, mark = isValid_default(listenerParams.markId) && (null == chart ? void 0 : chart.getMarkById(listenerParams.markId)) || null, itemMap = /* @__PURE__ */ new Map();
      let targetMark = null === (_a = listenerParams.item) || void 0 === _a ? void 0 : _a.mark;
      for (targetMark && isValid_default(targetMark.id()) && itemMap.set(targetMark.id(), listenerParams.item); null == targetMark ? void 0 : targetMark.elements; ) {
        const id = targetMark.id();
        isValid_default(id) && !itemMap.has(id) && itemMap.set(id, targetMark.elements[0]), targetMark = targetMark.group;
      }
      const node = get_default(listenerParams.event, "target");
      let datum = listenerParams.datum;
      model && "component" === model.modelType && (datum = null !== (_b = model.getDatum(node)) && void 0 !== _b ? _b : datum);
      const params2 = {
        event: listenerParams.event,
        item: listenerParams.item,
        source: listenerParams.source,
        datum,
        itemMap,
        chart,
        model,
        mark: null != mark ? mark : void 0,
        node: get_default(listenerParams.event, "target")
      };
      this.dispatch(listenerParams.type, params2);
    }, this._onDelegateInteractionEvent = (listenerParams) => {
      const chart = this.globalInstance.getChart(), event = listenerParams.event;
      let items = null;
      event.elements && (items = event.elements);
      const params2 = {
        event: listenerParams.event,
        chart,
        items,
        datums: items && items.map((item) => item.getDatum())
      };
      this.dispatch(listenerParams.type, params2);
    }, this.globalInstance = vchart, this._compiler = compiler;
  }
  register(eType, handler) {
    var _a, _b, _c, _d, _e;
    this._parseQuery(handler);
    const bubbles = this.getEventBubble((null === (_a = handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    bubbles.get(eType) || bubbles.set(eType, new Bubble());
    if (bubbles.get(eType).addHandler(handler, null === (_c = handler.filter) || void 0 === _c ? void 0 : _c.level), this._isValidEvent(eType) && !listeners.has(eType)) {
      const callback = this._onDelegate.bind(this);
      this._compiler.addEventListener(null === (_d = handler.filter) || void 0 === _d ? void 0 : _d.source, eType, callback), listeners.set(eType, callback);
    } else if (this._isInteractionEvent(eType) && !listeners.has(eType)) {
      const callback = this._onDelegateInteractionEvent.bind(this);
      this._compiler.addEventListener(null === (_e = handler.filter) || void 0 === _e ? void 0 : _e.source, eType, callback), listeners.set(eType, callback);
    }
    return this;
  }
  unregister(eType, handler) {
    var _a, _b, _c, _d;
    let clean = false;
    const bubbles = this.getEventBubble((null === (_a = null == handler ? void 0 : handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = null == handler ? void 0 : handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    if (handler) {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.removeHandler(handler), 0 === (null == bubble ? void 0 : bubble.getCount()) && (null == bubble || bubble.release(), bubbles.delete(eType), clean = true), (null === (_c = null == handler ? void 0 : handler.wrappedCallback) || void 0 === _c ? void 0 : _c.cancel) && handler.wrappedCallback.cancel();
    } else {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.release(), bubbles.delete(eType), clean = true;
    }
    if (clean && this._isValidEvent(eType)) {
      const callback = listeners.get(eType);
      this._compiler.removeEventListener((null === (_d = null == handler ? void 0 : handler.filter) || void 0 === _d ? void 0 : _d.source) || Event_Source_Type.chart, eType, callback), listeners.delete(eType);
    }
    return this;
  }
  dispatch(eType, params2, level) {
    const bubble = this.getEventBubble(params2.source || Event_Source_Type.chart).get(eType);
    if (!bubble) return this;
    let stopBubble = false;
    if (level) {
      const handlers = bubble.getHandlers(level);
      stopBubble = this._invoke(handlers, eType, params2);
    } else {
      let i = 0;
      for (; !stopBubble && i < EventBubbleLevels.length; ) stopBubble = this._invoke(bubble.getHandlers(EventBubbleLevels[i]), eType, params2), i++;
    }
    return this;
  }
  prevent(eType, except) {
    return ["canvas", "chart", "window"].forEach((type) => {
      const bubble = this.getEventBubble(type).get(eType);
      bubble && bubble.getAllHandlers().forEach((handler) => {
        except ? EventBubbleLevels.indexOf(handler.filter.level) < EventBubbleLevels.indexOf(except.level) && handler.callback !== except.handler && bubble.preventHandler(handler) : bubble.preventHandler(handler);
      });
    }), this;
  }
  allow(eType) {
    return ["canvas", "chart", "window"].forEach((type) => {
      const bubble = this.getEventBubble(type).get(eType);
      bubble && bubble.getAllHandlers().forEach((handler) => bubble.allowHandler(handler));
    }), this;
  }
  clear() {
    [Event_Source_Type.chart, Event_Source_Type.window, Event_Source_Type.canvas].forEach((type) => {
      const listeners = this.getEventListeners(type);
      for (const entry of listeners.entries()) this._compiler.removeEventListener(type, entry[0], entry[1]);
      listeners.clear();
    }), [this._viewBubbles, this._windowBubbles, this._canvasBubbles].forEach((bubbles) => {
      for (const bubble of bubbles.values()) bubble.release();
      bubbles.clear();
    });
  }
  release() {
    this.clear(), this.globalInstance = null, this._compiler = null;
  }
  _filter(filter2, evt, params2) {
    var _a, _b, _c;
    if (isFunction_default(filter2.filter) && !filter2.filter(params2)) return false;
    if (filter2.nodeName && get_default(params2, "node.name") !== filter2.nodeName) return false;
    if (filter2.markName && (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name) !== filter2.markName) return false;
    let modelType = null === (_b = params2.model) || void 0 === _b ? void 0 : _b.type;
    return componentTypeMap[modelType] && (modelType = componentTypeMap[modelType]), (!filter2.type || modelType === filter2.type) && (!("mark" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.mark)) && (!("model" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.model)) && (!isValid_default(filter2.userId) || (null === (_c = params2.model) || void 0 === _c ? void 0 : _c.userId) === filter2.userId)));
  }
  _prepareParams(filter2, params2) {
    if (filter2.markName && params2.mark && params2.itemMap) {
      const markId = params2.mark.getProductId(), item = params2.itemMap.get(markId), datum = null == item ? void 0 : item.getDatum();
      return Object.assign(Object.assign({}, params2), {
        item,
        datum
      });
    }
    return Object.assign({}, params2);
  }
  _invoke(handlers, type, params2) {
    return handlers.map((handler) => {
      var _a, _b, _c;
      const filter2 = handler.filter;
      if (!handler.prevented && (!handler.query || this._filter(filter2, type, params2))) {
        const stopBubble = (handler.wrappedCallback || handler.callback).call(null, this._prepareParams(filter2, params2)), doStopBubble = null != stopBubble ? stopBubble : null === (_a = handler.query) || void 0 === _a ? void 0 : _a.consume;
        return doStopBubble && (null === (_b = params2.event) || void 0 === _b || _b.stopPropagation(), null === (_c = params2.event) || void 0 === _c || _c.preventDefault()), !!doStopBubble;
      }
    }).some((r) => true === r);
  }
  _getQueryLevel(query) {
    return query ? query.level ? query.level : isValid_default(query.id) ? Event_Bubble_Level.model : Event_Bubble_Level.vchart : Event_Bubble_Level.vchart;
  }
  _parseQuery(handler) {
    var _a;
    const query = handler.query;
    (null == query ? void 0 : query.throttle) ? handler.wrappedCallback = throttle_default(handler.callback, query.throttle) : (null == query ? void 0 : query.debounce) && (handler.wrappedCallback = debounce_default(handler.callback, query.debounce));
    let level = this._getQueryLevel(query), type = null, source = Event_Source_Type.chart, nodeName = null, markName = null, userId = null;
    return (null == query ? void 0 : query.nodeName) && (nodeName = query.nodeName), (null == query ? void 0 : query.markName) && (markName = query.markName), !(null == query ? void 0 : query.type) || level !== Event_Bubble_Level.model && level !== Event_Bubble_Level.mark || (type = query.type), (null == query ? void 0 : query.source) && (source = query.source), isValid_default(null == query ? void 0 : query.id) && (userId = null == query ? void 0 : query.id, level = Event_Bubble_Level.model), handler.filter = {
      level,
      markName,
      type,
      source,
      nodeName,
      userId,
      filter: null !== (_a = null == query ? void 0 : query.filter) && void 0 !== _a ? _a : null
    }, handler;
  }
  getEventBubble(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewBubbles;
      case Event_Source_Type.window:
        return this._windowBubbles;
      case Event_Source_Type.canvas:
        return this._canvasBubbles;
      default:
        return this._viewBubbles;
    }
  }
  getEventListeners(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewListeners;
      case Event_Source_Type.window:
        return this._windowListeners;
      case Event_Source_Type.canvas:
        return this._canvasListeners;
      default:
        return this._viewListeners;
    }
  }
  _isValidEvent(eType) {
    return BASE_EVENTS.includes(eType) || Object.values(HOOK_EVENT).includes(eType);
  }
  _isInteractionEvent(eType) {
    let interactionType;
    return eType && (interactionType = eType.split(":")[0], interactionType) && Factory3.hasInteraction(interactionType);
  }
};

// node_modules/@visactor/vchart/esm/data/register.js
function registerDataSetInstanceTransform(dataSet, name, transform30) {
  dataSet.getTransform(name) || dataSet.registerTransform(name, transform30);
}
function registerDataSetInstanceParser(dataSet, name, parse2) {
  dataSet.getParser(name) || dataSet.registerParser(name, parse2);
}

// node_modules/@visactor/vchart/esm/series/map/geo-source.js
var geoSourceMap = /* @__PURE__ */ new Map();
var mapDataSet;
function initMapDataSet() {
  mapDataSet || (mapDataSet = new DataSet(), registerDataSetInstanceParser(mapDataSet, "geojson", geoJSONParser), registerDataSetInstanceParser(mapDataSet, "topojson", topoJSONParser), registerDataSetInstanceTransform(mapDataSet, "simplify", simplify));
}
function registerMapSource(key, source, option = {
  type: "geojson",
  centroid: true
}) {
  geoSourceMap.has(key) && warn(`map type of '${key}' already exists, will be overwritten.`), initMapDataSet();
  const dataView = new DataView(mapDataSet), options = merge({}, {
    centroid: true,
    simplify: false
  }, option);
  "topojson" === option.type ? dataView.parse(source, {
    type: "topojson",
    options
  }) : dataView.parse(source, {
    type: "geojson",
    options
  });
  const { simplify: simplify2 } = option;
  true === simplify2 ? dataView.transform({
    type: "simplify"
  }) : isObject_default(simplify2) && dataView.transform({
    type: "simplify",
    options: simplify2
  }), geoSourceMap.set(key, dataView);
}
function unregisterMapSource(key) {
  geoSourceMap.has(key) ? geoSourceMap.delete(key) : warn(`map type of '${key}' does not exists.`);
}
function getMapSource(type) {
  return geoSourceMap.get(type);
}

// node_modules/@visactor/vchart/esm/data/transforms/copy-data-view.js
function copyOneDataView(d, deep = false) {
  let _deep = deep;
  return d.latestData instanceof DataView && (_deep = false), _deep ? cloneDeep(d.latestData) : d.latestData && d.latestData.slice();
}
var copyDataView = (data, options) => 0 === data.length ? [] : 1 === data.length ? copyOneDataView(data[0], null == options ? void 0 : options.deep) : data.map((d) => copyOneDataView(d, null == options ? void 0 : options.deep));

// node_modules/@visactor/vchart/esm/data/initialize.js
function dataViewFromDataView(rawData, dataSet, op) {
  dataSet = dataSet instanceof DataSet ? dataSet : rawData.dataSet, registerDataSetInstanceTransform(dataSet, "copyDataView", copyDataView);
  const viewData = new DataView(dataSet, op);
  return viewData.parse([rawData], {
    type: "dataview"
  }), viewData.transform({
    type: "copyDataView",
    level: TransformLevel.copyDataView
  }), viewData;
}
function dataToDataView(data, dataSet, sourceDataViews = []) {
  var _a;
  if (data instanceof DataView) return data;
  const { id, values = [], fromDataIndex, fromDataId, transforms = [] } = data, parser = data.parser ? cloneDeep(data.parser) : {
    clone: true
  }, fields2 = cloneDeep(data.fields);
  let dataView;
  parser.clone = !(false === parser.clone);
  const existDataView = sourceDataViews.find((dv) => dv.name === id);
  if (existDataView) dataView = existDataView;
  else {
    const initOption = {
      name: id
    };
    if (fields2 && (initOption.fields = fields2), dataView = new DataView(dataSet, initOption), "string" == typeof fromDataId) {
      const fromDataView = sourceDataViews.find((dv) => dv.name === fromDataId);
      if (!fromDataView) return warn(`no data matches fromDataId ${fromDataId}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else if ("number" == typeof fromDataIndex) {
      const fromDataView = sourceDataViews[fromDataIndex];
      if (!fromDataView) return warn(`no data matches fromDataIndex ${fromDataIndex}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else Array.isArray(values) ? dataView.parse(values, parser) : !isString_default(values) || parser && !["csv", "dsv", "tsv"].includes(parser.type) ? (dataView.parse([]), warn("values should be array")) : dataView.parse(values, null !== (_a = parser) && void 0 !== _a ? _a : {
      type: "csv"
    });
    transforms && transforms.length && transforms.forEach((transform30) => {
      dataSet.getTransform(transform30.type) && dataView.transform(transform30);
    });
  }
  return dataView;
}
function updateDataViewInData(dataView, data, forceMerge) {
  dataView && (data.fields && dataView.setFields(data.fields, forceMerge), dataView.parseNewData(data.values, data.parser));
}
var TransformLevel;
!function(TransformLevel2) {
  TransformLevel2[TransformLevel2.copyDataView = -10] = "copyDataView", TransformLevel2[TransformLevel2.treemapFilter = -8] = "treemapFilter", TransformLevel2[TransformLevel2.treemapFlatten = -7] = "treemapFlatten", TransformLevel2[TransformLevel2.dotObjFlat = -7] = "dotObjFlat", TransformLevel2[TransformLevel2.linkDotInfo = -7] = "linkDotInfo", TransformLevel2[TransformLevel2.sankeyLayout = -7] = "sankeyLayout", TransformLevel2[TransformLevel2.dataZoomFilter = -6] = "dataZoomFilter", TransformLevel2[TransformLevel2.legendFilter = -5] = "legendFilter";
}(TransformLevel || (TransformLevel = {}));

// node_modules/@visactor/vchart/esm/animation/interface.js
var AnimationStateEnum;
!function(AnimationStateEnum2) {
  AnimationStateEnum2.appear = "appear", AnimationStateEnum2.disappear = "disappear", AnimationStateEnum2.enter = "enter", AnimationStateEnum2.update = "update", AnimationStateEnum2.state = "state", AnimationStateEnum2.exit = "exit", AnimationStateEnum2.normal = "normal", AnimationStateEnum2.none = "none";
}(AnimationStateEnum || (AnimationStateEnum = {}));

// node_modules/@visactor/vchart/esm/compile/interface/compilable-item.js
var GrammarType;
!function(GrammarType2) {
  GrammarType2.data = "data", GrammarType2.signal = "signal", GrammarType2.mark = "mark";
}(GrammarType || (GrammarType = {}));

// node_modules/@visactor/vchart/esm/compile/util.js
function toRenderMode(mode) {
  switch (mode) {
    case RenderModeEnum["desktop-browser"]:
    case RenderModeEnum["mobile-browser"]:
      return "browser";
    case RenderModeEnum.node:
    case RenderModeEnum.worker:
      return "node";
    case RenderModeEnum.miniApp:
    case RenderModeEnum["desktop-miniApp"]:
      return "feishu";
    case RenderModeEnum.lynx:
      return "lynx";
    case RenderModeEnum.wx:
      return "wx";
    case RenderModeEnum.tt:
      return "tt";
    case RenderModeEnum.harmony:
      return "harmony";
  }
  return "browser";
}

// node_modules/@visactor/vchart/esm/compile/compiler.js
var __rest15 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var Compiler = class {
  getVGrammarView() {
    return this._view;
  }
  getModel() {
    return this._model;
  }
  constructor(container2, option) {
    this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this.isInited = false, this._released = false, this._model = {
      [GrammarType.signal]: {},
      [GrammarType.data]: {},
      [GrammarType.mark]: {}
    }, this._compileChart = null, this.handleStageRender = () => {
      var _a, _b;
      null === (_b = null === (_a = this._compileChart) || void 0 === _a ? void 0 : _a.getEvent()) || void 0 === _b || _b.emit(ChartEvent.afterRender, {
        chart: this._compileChart
      });
    }, this._container = container2, this._option = option;
  }
  getRenderer() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer;
  }
  getCanvas() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.canvas();
  }
  getStage() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.stage();
  }
  initView() {
    var _a, _b, _c, _d;
    if (this._released) return;
    if (this.isInited = true, this._view) return;
    const logger = new Logger(null !== (_a = this._option.logLevel) && void 0 !== _a ? _a : LoggerLevel.Error);
    (null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError) && logger.addErrorHandler((...args) => {
      var _a2, _b2;
      null === (_b2 = null === (_a2 = this._option) || void 0 === _a2 ? void 0 : _a2.onError) || void 0 === _b2 || _b2.call(_a2, ...args);
    });
    const _e = this._option, { performanceHook, autoRefreshDpr, dpr, mode, gestureConfig, interactive, clickInterval, autoPreventDefault } = _e, restOption = __rest15(_e, ["performanceHook", "autoRefreshDpr", "dpr", "mode", "gestureConfig", "interactive", "clickInterval", "autoPreventDefault"]);
    this._view = new View(Object.assign(Object.assign({
      width: this._width,
      height: this._height,
      container: null !== (_c = this._container.dom) && void 0 !== _c ? _c : null,
      renderCanvas: null !== (_d = this._container.canvas) && void 0 !== _d ? _d : null,
      hooks: performanceHook
    }, restOption), {
      dpr,
      autoRefresh: isValid_default(autoRefreshDpr) ? autoRefreshDpr : !isValid_default(dpr),
      mode: toRenderMode(mode),
      autoFit: false,
      eventConfig: {
        gesture: isValid_default(gestureConfig) ? gestureConfig : isMobileLikeMode(mode),
        disable: false === interactive,
        clickInterval,
        autoPreventDefault
      },
      doLayout: () => {
        var _a2;
        null === (_a2 = this._compileChart) || void 0 === _a2 || _a2.onLayout(this._view);
      },
      logger,
      logLevel: logger.level()
    })), this._setCanvasStyle(), this.getStage().hooks.afterRender.tap("chart-event", this.handleStageRender), false !== interactive && this._viewListeners.forEach((listener) => {
      var _a2;
      null === (_a2 = this._view) || void 0 === _a2 || _a2.addEventListener(listener.type, listener.callback);
    });
  }
  _setCanvasStyle() {
    if (this._view && this._container.dom && !isString_default(this._container.dom)) {
      this._container.dom.style.display = "block", this._container.dom.style.position = "relative";
      const canvas = this.getCanvas();
      canvas && (canvas.style.display = "block");
    }
  }
  compileInteractions() {
    var _a;
    if (this._view.removeAllInteractions(), null === (_a = this._interactions) || void 0 === _a ? void 0 : _a.length) {
      const regionCombindInteractions = {};
      this._interactions.forEach((interaction) => {
        var _a2;
        if (interaction.regionId) {
          const interactionId = `${interaction.regionId}-${interaction.type}-${null !== (_a2 = interaction.id) && void 0 !== _a2 ? _a2 : ""}`, spec = regionCombindInteractions[interactionId];
          regionCombindInteractions[interactionId] = spec ? Object.assign(Object.assign(Object.assign({}, spec), interaction), {
            selector: [...spec.selector, ...interaction.selector]
          }) : interaction;
        } else this._view.interaction(interaction.type, interaction);
      }), Object.keys(regionCombindInteractions).forEach((key) => {
        const interaction = this._view.interaction(regionCombindInteractions[key].type, regionCombindInteractions[key]);
        if (this._compileChart) {
          const region = this._compileChart.getRegionsInIds([regionCombindInteractions[key].regionId])[0];
          region && region.interaction.addVgrammarInteraction(interaction.getStartState(), interaction);
        }
      });
    }
  }
  compile(ctx, option) {
    if (this._released) return;
    const { chart } = ctx;
    this._compileChart = chart, this.initView(), this._view && (chart.compile(), chart.afterCompile(), this.updateDepend(), this.compileInteractions());
  }
  clearNextRender() {
    return !!this._nextRafId && (vglobal.getCancelAnimationFrame()(this._nextRafId), this._nextRafId = null, true);
  }
  clear(ctx, removeGraphicItems = false) {
    const { chart } = ctx;
    this.clearNextRender(), chart.clear(), this.releaseGrammar(removeGraphicItems);
  }
  renderNextTick(morphConfig) {
    this._released || this._nextRafId || (this._nextRafId = vglobal.getRequestAnimationFrame()(() => {
      this._nextRafId = null, this.render(morphConfig);
    }));
  }
  render(morphConfig) {
    var _a, _b;
    this._released || (this.initView(), this._view && (null === (_a = this._view) || void 0 === _a || _a.run(morphConfig), this.clearNextRender() && (null === (_b = this._view) || void 0 === _b || _b.run(morphConfig))));
  }
  updateViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  resize(width, height, reRender = true) {
    this._view && (this._width = width, this._height = height, this._view.resize(width, height), reRender && this.render({
      morph: false
    }));
  }
  setBackground(color) {
    var _a;
    null === (_a = this._view) || void 0 === _a || _a.background(color);
  }
  setSize(width, height) {
    this._width = width, this._height = height, this._view && (this._view.width(width), this._view.height(height));
  }
  setViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  addEventListener(source, type, callback) {
    var _a, _b;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = (function(event, element) {
          var _a2, _b2, _c;
          const context = null !== (_b2 = null === (_a2 = null == element ? void 0 : element.mark) || void 0 === _a2 ? void 0 : _a2.getContext()) && void 0 !== _b2 ? _b2 : {}, modelId = isValid_default(context.modelId) ? context.modelId : null, markId = isValid_default(context.markId) ? context.markId : null, modelUserId = isValid_default(context.modelUserId) ? context.modelUserId : null, markUserId = isValid_default(context.markUserId) ? context.markUserId : null, params2 = {
            event,
            type,
            source,
            item: element,
            datum: (null === (_c = null == element ? void 0 : element.getDatum) || void 0 === _c ? void 0 : _c.call(element)) || null,
            markId,
            modelId,
            markUserId,
            modelUserId
          };
          callback.call(null, params2);
        }).bind(this);
        this._viewListeners.set(callback, {
          type,
          callback: wrappedCallback
        }), null === (_a = this._view) || void 0 === _a || _a.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.window) {
        const wrappedCallback = (function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }).bind(this);
        this._windowListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const windowObject = this._getGlobalThis();
        null == windowObject || windowObject.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.canvas) {
        const wrappedCallback = (function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }).bind(this);
        this._canvasListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const canvasObject = null === (_b = this.getStage()) || void 0 === _b ? void 0 : _b.window;
        null == canvasObject || canvasObject.addEventListener(type, wrappedCallback);
      }
    }
  }
  removeEventListener(source, type, callback) {
    var _a, _b, _c, _d, _e;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = null === (_a = this._viewListeners.get(callback)) || void 0 === _a ? void 0 : _a.callback;
        wrappedCallback && (null === (_b = this._view) || void 0 === _b || _b.removeEventListener(type, wrappedCallback)), this._viewListeners.delete(callback);
      } else if (source === Event_Source_Type.window) {
        const windowObject = this._getGlobalThis(), wrappedCallback = null === (_c = this._windowListeners.get(callback)) || void 0 === _c ? void 0 : _c.callback;
        wrappedCallback && (null == windowObject || windowObject.removeEventListener(type, wrappedCallback)), this._windowListeners.delete(callback);
      } else if (source === Event_Source_Type.canvas) {
        const canvasObject = null === (_d = this.getStage()) || void 0 === _d ? void 0 : _d.window, wrappedCallback = null === (_e = this._canvasListeners.get(callback)) || void 0 === _e ? void 0 : _e.callback;
        canvasObject && wrappedCallback && (null == canvasObject || canvasObject.removeEventListener(type, wrappedCallback)), this._canvasListeners.delete(callback);
      }
    }
  }
  releaseEvent() {
    const stage = this.getStage();
    stage && stage.hooks.afterRender.unTap("chart-event", this.handleStageRender), this._viewListeners.clear(), this._windowListeners.clear(), this._canvasListeners.clear();
  }
  release() {
    var _a;
    this.clearNextRender(), this.releaseEvent(), this._option = this._container = null, this._releaseModel(), null === (_a = this._view) || void 0 === _a || _a.release(), this._view = null, this.isInited = false, this._compileChart = null, this._released = true;
  }
  releaseGrammar(removeGraphicItems = false) {
    var _a, _b;
    this._releaseModel(), removeGraphicItems && (null === (_a = this._view) || void 0 === _a || _a.removeAllGraphicItems()), null === (_b = this._view) || void 0 === _b || _b.removeAllGrammars();
  }
  _releaseModel() {
    Object.keys(this._model).forEach((type) => {
      Object.values(this._model[type]).forEach((grammarItemMap) => {
        Object.values(grammarItemMap).forEach((item) => {
          item.removeProduct(true);
        });
      }), this._model[type] = {};
    });
  }
  addGrammarItem(grammarItem) {
    const product = grammarItem.getProduct();
    if (isNil_default(product)) return;
    const id = product.id(), type = grammarItem.grammarType;
    isNil_default(this._model[type][id]) && (this._model[type][id] = {}), this._model[type][id][grammarItem.id] = grammarItem;
  }
  removeGrammarItem(grammarItem, reserveVGrammarModel) {
    var _a;
    const product = grammarItem.getProduct();
    if (isNil_default(product)) return;
    const id = product.id(), type = grammarItem.grammarType, map4 = this._model[type][id];
    isValid_default(map4) && (delete map4[grammarItem.id], 0 === Object.keys(map4).length && delete this._model[type][id]), reserveVGrammarModel || null === (_a = this._view) || void 0 === _a || _a.removeGrammar(product);
  }
  addInteraction(interaction) {
    this._interactions || (this._interactions = []), this._interactions.push(interaction);
  }
  removeInteraction(seriesId) {
    this._interactions && (this._interactions = this._interactions.filter((entry) => entry.seriesId !== seriesId));
  }
  updateDepend(items) {
    return isValid_default(items) && items.length > 0 ? items.every((item) => item.updateDepend()) : (Object.values(this._model).forEach((productMap) => {
      Object.values(productMap).forEach((grammarItemMap) => {
        const grammarItems = Object.values(grammarItemMap), product = grammarItems[0].getProduct(), dependList = grammarItems.reduce((depend, item) => item.getDepend().length > 0 ? depend.concat(item.getDepend()) : depend, []).filter((grammarItem) => !!grammarItem).map((grammarItem) => grammarItem.getProduct());
        product.depend(dependList);
      });
    }), true);
  }
  _getGlobalThis() {
    var _a;
    return isTrueBrowser(this._option.mode) ? globalThis : null === (_a = this.getStage()) || void 0 === _a ? void 0 : _a.window;
  }
};

// node_modules/@visactor/vchart/esm/util/image.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function URLToImage(name = "vchart", url) {
  const link2 = document.createElement("a");
  link2.setAttribute("href", url), link2.setAttribute("target", "_blank"), link2.setAttribute("download", `${name}.png`), link2.dispatchEvent(new MouseEvent("click"));
}
function OffscreenCanvasToDataURL(c3) {
  return new Promise((r) => {
    c3.convertToBlob().then((b) => {
      const reader = new FileReader();
      reader.readAsDataURL(b), reader.onload = () => {
        r(reader.result);
      };
    });
  });
}
function getCanvasDataURL(c3, ctx) {
  var _a;
  return __awaiter11(this, void 0, void 0, function* () {
    if (!c3) return "";
    try {
      if (void 0 !== OffscreenCanvas && c3 instanceof OffscreenCanvas) return OffscreenCanvasToDataURL(c3);
    } catch (_error) {
      (null !== (_a = null == ctx ? void 0 : ctx.onError) && void 0 !== _a ? _a : error)(`getCanvasDataURL error : ${_error.toString()}`);
    }
    return c3.toDataURL();
  });
}

// node_modules/@visactor/vchart/esm/chart/util.js
function setDefaultCrosshairForCartesianChart(spec) {
  spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
    ["horizontal" === spec.direction ? "yField" : "xField"]: {
      visible: true,
      line: {
        visible: true,
        type: "rect"
      }
    }
  }, crosshairCfg));
}
function calculateChartSize(spec, option, defaultSize) {
  var _a;
  const { width: userWidth, height: userHeight } = spec;
  if (isValid_default(userWidth) && isValid_default(userHeight)) return {
    width: userWidth,
    height: userHeight
  };
  let width = defaultSize.width, height = defaultSize.height;
  const container2 = option.container, canvas = option.canvas;
  if (container2) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container2, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (canvas && isTrueBrowser(option.mode)) {
    let canvasNode;
    canvasNode = isString_default(canvas) ? vglobal.getElementById(canvas) : canvas;
    const { width: containerWidth, height: containerHeight } = getContainerSize(canvasNode, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (isMiniAppLikeMode(option.mode) && (null === (_a = option.modeParams) || void 0 === _a ? void 0 : _a.domref)) {
    const domRef = option.modeParams.domref;
    width = domRef.width, height = domRef.height;
  }
  return width = null != userWidth ? userWidth : width, height = null != userHeight ? userHeight : height, {
    width,
    height
  };
}
function mergeUpdateResult(target, ...sources) {
  const merge2 = (key) => sources.reduce((value, cur) => value || (null == cur ? void 0 : cur[key]), target[key]);
  return Object.assign(target, {
    change: merge2("change"),
    reCompile: merge2("reCompile"),
    reMake: merge2("reMake"),
    reRender: merge2("reRender"),
    reSize: merge2("reSize"),
    reTransformSpec: merge2("reTransformSpec"),
    changeTheme: merge2("changeTheme"),
    changeBackground: merge2("changeBackground")
  }), target;
}
function getTrimPaddingConfig(chartType, spec) {
  return "line" === chartType || "area" === chartType || "common" === chartType && spec.series.every((item) => "area" === item.type || "line" === item.type) ? {
    paddingInner: 1,
    paddingOuter: 0
  } : {
    paddingOuter: 0
  };
}

// node_modules/@visactor/vchart/esm/compile/mark/interface.js
var STATE_VALUE_ENUM;
!function(STATE_VALUE_ENUM2) {
  STATE_VALUE_ENUM2.STATE_NORMAL = "normal", STATE_VALUE_ENUM2.STATE_HOVER = "hover", STATE_VALUE_ENUM2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER = "dimension_hover", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM2.STATE_SELECTED = "selected", STATE_VALUE_ENUM2.STATE_SELECTED_REVERSE = "selected_reverse", STATE_VALUE_ENUM2.STATE_SANKEY_EMPHASIS = "selected", STATE_VALUE_ENUM2.STATE_SANKEY_EMPHASIS_REVERSE = "blur";
}(STATE_VALUE_ENUM || (STATE_VALUE_ENUM = {}));
var STATE_VALUE_ENUM_REVERSE;
!function(STATE_VALUE_ENUM_REVERSE2) {
  STATE_VALUE_ENUM_REVERSE2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_SELECTED_REVERSE = "selected_reverse";
}(STATE_VALUE_ENUM_REVERSE || (STATE_VALUE_ENUM_REVERSE = {}));

// node_modules/@visactor/vchart/esm/mark/mark-set/index.js
var MarkSet = class _MarkSet {
  constructor() {
    this._children = [], this._markNameMap = {}, this._infoMap = /* @__PURE__ */ new Map();
  }
  getMarkNameMap() {
    return this._markNameMap;
  }
  addMark(mark, markInfo) {
    isNil_default(mark) || (this._children.push(mark), this._markNameMap[mark.name] = mark, this._infoMap.set(mark, merge({}, _MarkSet.defaultMarkInfo, markInfo)));
  }
  removeMark(markName) {
    const index = this._children.findIndex((m4) => m4.name === markName);
    index >= 0 && (this._infoMap.delete(this._children[index]), delete this._markNameMap[markName], this._children.splice(index, 1));
  }
  clear() {
    this._children = [], this._markNameMap = {}, this._infoMap.clear();
  }
  forEach(callbackfn) {
    this._children.forEach(callbackfn);
  }
  includes(mark, fromIndex) {
    return this._children.includes(mark, fromIndex);
  }
  get(key) {
    return isNaN(Number(key)) ? this._markNameMap[key] : this._children[key];
  }
  getMarks() {
    return this._children.slice();
  }
  getMarksInType(type) {
    const types = array(type);
    return this._children.filter((m4) => types.includes(m4.type));
  }
  getMarkInId(markId) {
    return this._children.find((m4) => m4.id === markId);
  }
  getMarkWithInfo(info) {
    return this._children.find((mark) => Object.keys(info).every((key) => info[key] === this._infoMap.get(mark)[key]));
  }
};
MarkSet.defaultMarkInfo = {};

// node_modules/@visactor/vchart/esm/interaction/dimension-trigger.js
var DimensionTrigger = class {
  get hover() {
    return this._hover;
  }
  get select() {
    return this._select;
  }
  constructor(option) {
    this._marks = new MarkSet(), this._markReverse = new MarkSet(), this.onHover = (params2) => {
      switch (params2.action) {
        case "enter":
          this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER).forEach((e) => this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE, e)), this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, false);
          this.getEventElement(params2).forEach((el) => this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, el)), this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER);
          break;
        case "leave":
          this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, true), params2 = null;
      }
    }, this._option = option, this.event = this._option.model.getOption().getChart().getEvent(), this.interaction = option.interaction, this.initConfig(option.mode);
  }
  setStateKeys(fields2) {
  }
  registerMark(mark) {
    isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]) || this._marks.addMark(mark), isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE]) || this._markReverse.addMark(mark);
  }
  init() {
    this.initEvent();
  }
  release() {
    this.releaseEvent();
  }
  initEvent() {
    this.event.on(DimensionEventEnum.dimensionHover, this.onHover);
  }
  releaseEvent() {
    this.event.release();
  }
  initConfig(mode) {
  }
  getEventElement(params2, reverse = false) {
    const items = [];
    return params2.dimensionInfo.forEach((df) => {
      df.data.forEach((dd) => {
        (reverse ? this._markReverse : this._marks).getMarks().filter((m4) => m4.model === dd.series && m4.getVisible()).forEach((m4) => {
          const markProduct = m4.getProduct();
          if (!markProduct || !markProduct.elements) return;
          const elements = markProduct.elements.filter((e) => {
            const datum = e.getDatum();
            let c3;
            return c3 = isArray_default(datum) ? datum.every((oneData, i) => oneData === dd.datum[i]) : dd.datum.some((dd_d) => dd_d === datum), reverse ? !c3 : c3;
          });
          items.push(...elements);
        });
      });
    }), items;
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/util.js
function isStateAttrChangeable(key, stateStyle, facetField) {
  var _a;
  const style = null === (_a = stateStyle[key]) || void 0 === _a ? void 0 : _a.style;
  if (isGradientAttribute(key, style)) return true;
  if (isFunction_default(style)) return true;
  return !(!(null == style ? void 0 : style.scale) || style.field === facetField);
}
function isGradientAttribute(key, style) {
  return ("fill" === key || "stroke" === key) && (null == style ? void 0 : style.gradient) && (null == style ? void 0 : style.stops);
}
var DEFAULT_STATE_VALUE_ENUM = {};
Object.values(STATE_VALUE_ENUM).forEach((v) => {
  DEFAULT_STATE_VALUE_ENUM[v] = true;
});
function stateInDefaultEnum(state) {
  return !!DEFAULT_STATE_VALUE_ENUM[state];
}
var DEFAULT_STATE_VALUE_TO_REVERSE = {
  [STATE_VALUE_ENUM.STATE_HOVER]: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
  [STATE_VALUE_ENUM.STATE_SELECTED]: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
  [STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE
};
function stateToReverse(state) {
  return DEFAULT_STATE_VALUE_TO_REVERSE[state];
}

// node_modules/@visactor/vchart/esm/interaction/interaction.js
var Interaction = class {
  constructor() {
    this._stateMarks = /* @__PURE__ */ new Map(), this._stateElements = /* @__PURE__ */ new Map(), this._vgrammarInteractions = /* @__PURE__ */ new Map(), this._disableTriggerEvent = false;
  }
  addVgrammarInteraction(state, i) {
    state && (this._vgrammarInteractions.get(state) ? this._vgrammarInteractions.get(state).push(i) : this._vgrammarInteractions.set(state, [i]));
  }
  static markStateEnable(mark, state) {
    return !isEmpty_default(mark.stateStyle[state]);
  }
  setDisableActiveEffect(disable) {
    this._disableTriggerEvent = disable;
  }
  registerMark(state, mark) {
    var _a;
    this._stateMarks.has(state) || this._stateMarks.set(state, []), null === (_a = this._stateMarks.get(state)) || void 0 === _a || _a.push(mark);
  }
  getStateMark(state) {
    return this._stateMarks.get(state);
  }
  filterEventMark(params2, state) {
    var _a;
    return !(!params2.mark || !(null === (_a = this._stateMarks.get(state)) || void 0 === _a ? void 0 : _a.includes(params2.mark)));
  }
  getEventElement(stateValue) {
    var _a;
    return null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
  }
  getEventElementData(stateValue) {
    return this.getEventElement(stateValue).map((e) => e.getDatum());
  }
  exchangeEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent) return;
    const reState = stateToReverse(stateValue);
    null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e) => {
      e.removeState(stateValue), reState && this.addEventElement(reState, e);
    }), element.getStates().includes(stateValue) || (element.addState(stateValue), reState && element.removeState(reState)), this._stateElements.set(stateValue, [element]);
  }
  removeEventElement(stateValue, element) {
    var _a, _b;
    if (this._disableTriggerEvent) return;
    element.removeState(stateValue);
    const list = null !== (_b = null === (_a = this._stateElements.get(stateValue)) || void 0 === _a ? void 0 : _a.filter((e) => e !== element)) && void 0 !== _b ? _b : [];
    this._stateElements.set(stateValue, list);
    const reState = stateToReverse(stateValue);
    reState && (0 === list.length ? this.clearEventElement(reState, false) : this.addEventElement(reState, element));
  }
  addEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent) return;
    element.getStates().includes(stateValue) || element.addState(stateValue);
    const list = null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
    list.push(element), this._stateElements.set(stateValue, list);
  }
  clearEventElement(stateValue, clearReverse) {
    var _a;
    if (!this._disableTriggerEvent && (null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e) => {
      e.removeState(stateValue);
    }), this._stateElements.set(stateValue, []), clearReverse)) {
      const reState = stateToReverse(stateValue);
      reState && this.clearEventElement(reState, false);
    }
  }
  clearAllEventElement() {
    if (!this._disableTriggerEvent) for (const [stateValue, elements] of this._stateElements) elements.forEach((e) => {
      e.clearStates();
    }), this._stateElements.set(stateValue, []);
  }
  reverseEventElement(stateValue) {
    if (this._disableTriggerEvent) return;
    const state = stateToReverse(stateValue);
    if (!state) return;
    const marks = this.getStateMark(state);
    if (!marks) return;
    const activeElements = this.getEventElement(stateValue);
    if (!activeElements.length) return;
    this.getEventElement(state).length || (1 === activeElements.length ? marks.forEach((m4) => {
      m4.getProduct().elements.filter((e) => e !== activeElements[0]).forEach((e) => {
        this.addEventElement(state, e);
      });
    }) : marks.forEach((m4) => {
      m4.getProduct().elements.filter((e) => !activeElements.includes(e)).forEach((e) => {
        this.addEventElement(state, e);
      });
    }));
  }
  startInteraction(stateValue, element) {
    const interactions = this._vgrammarInteractions.get(stateValue);
    interactions && interactions.forEach((vgInteraction) => {
      vgInteraction.start(element);
    });
  }
  resetInteraction(stateValue, element) {
    const interactions = this._vgrammarInteractions.get(stateValue);
    interactions && interactions.forEach((vgInteraction) => {
      vgInteraction.reset(element);
    });
  }
  resetAllInteraction() {
    for (const [stateValue, interactions] of this._vgrammarInteractions) interactions && interactions.forEach((vgInteraction) => {
      vgInteraction.reset(null);
    });
  }
};

// node_modules/@visactor/vchart/esm/constant/layout.js
var USER_LAYOUT_RECT_LEVEL = 9;
var DEFAULT_LAYOUT_RECT_LEVEL = 0;
var LayoutZIndex;
!function(LayoutZIndex2) {
  LayoutZIndex2[LayoutZIndex2.SeriesGroup = 0] = "SeriesGroup", LayoutZIndex2[LayoutZIndex2.Axis_Grid = 50] = "Axis_Grid", LayoutZIndex2[LayoutZIndex2.CrossHair_Grid = 100] = "CrossHair_Grid", LayoutZIndex2[LayoutZIndex2.Region = 450] = "Region", LayoutZIndex2[LayoutZIndex2.Mark = 300] = "Mark", LayoutZIndex2[LayoutZIndex2.Node = 400] = "Node", LayoutZIndex2[LayoutZIndex2.Axis = 100] = "Axis", LayoutZIndex2[LayoutZIndex2.MarkLine = 500] = "MarkLine", LayoutZIndex2[LayoutZIndex2.MarkArea = 100] = "MarkArea", LayoutZIndex2[LayoutZIndex2.MarkPoint = 500] = "MarkPoint", LayoutZIndex2[LayoutZIndex2.DataZoom = 500] = "DataZoom", LayoutZIndex2[LayoutZIndex2.ScrollBar = 500] = "ScrollBar", LayoutZIndex2[LayoutZIndex2.Player = 500] = "Player", LayoutZIndex2[LayoutZIndex2.Legend = 500] = "Legend", LayoutZIndex2[LayoutZIndex2.CrossHair = 500] = "CrossHair", LayoutZIndex2[LayoutZIndex2.Indicator = 500] = "Indicator", LayoutZIndex2[LayoutZIndex2.Title = 500] = "Title", LayoutZIndex2[LayoutZIndex2.Label = 500] = "Label", LayoutZIndex2[LayoutZIndex2.Brush = 500] = "Brush", LayoutZIndex2[LayoutZIndex2.CustomMark = 500] = "CustomMark", LayoutZIndex2[LayoutZIndex2.Interaction = 700] = "Interaction";
}(LayoutZIndex || (LayoutZIndex = {}));
var LayoutLevel;
!function(LayoutLevel2) {
  LayoutLevel2[LayoutLevel2.Indicator = 10] = "Indicator", LayoutLevel2[LayoutLevel2.Region = 20] = "Region", LayoutLevel2[LayoutLevel2.Axis = 30] = "Axis", LayoutLevel2[LayoutLevel2.DataZoom = 40] = "DataZoom", LayoutLevel2[LayoutLevel2.Player = 40] = "Player", LayoutLevel2[LayoutLevel2.ScrollBar = 40] = "ScrollBar", LayoutLevel2[LayoutLevel2.Legend = 50] = "Legend", LayoutLevel2[LayoutLevel2.Title = 70] = "Title", LayoutLevel2[LayoutLevel2.CustomMark = 70] = "CustomMark";
}(LayoutLevel || (LayoutLevel = {}));

// node_modules/@visactor/vchart/esm/constant/attribute.js
var AttributeLevel;
!function(AttributeLevel2) {
  AttributeLevel2[AttributeLevel2.Default = 0] = "Default", AttributeLevel2[AttributeLevel2.Theme = 1] = "Theme", AttributeLevel2[AttributeLevel2.Chart = 2] = "Chart", AttributeLevel2[AttributeLevel2.Base_Series = 3] = "Base_Series", AttributeLevel2[AttributeLevel2.Series = 4] = "Series", AttributeLevel2[AttributeLevel2.Mark = 5] = "Mark", AttributeLevel2[AttributeLevel2.User_Chart = 6] = "User_Chart", AttributeLevel2[AttributeLevel2.User_Series = 7] = "User_Series", AttributeLevel2[AttributeLevel2.User_Mark = 8] = "User_Mark", AttributeLevel2[AttributeLevel2.User_SeriesStyle = 9] = "User_SeriesStyle", AttributeLevel2[AttributeLevel2.Built_In = 99] = "Built_In";
}(AttributeLevel || (AttributeLevel = {}));

// node_modules/@visactor/vchart/esm/compile/compilable-base.js
var CompilableBase = class {
  getOption() {
    return this._option;
  }
  constructor(option) {
    this._option = option, this.getCompiler = this._option.getCompiler;
  }
  getVGrammarView() {
    var _a;
    return null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
  }
  release() {
    this._option = null, this.getCompiler = null;
  }
};

// node_modules/@visactor/vchart/esm/compile/grammar-item.js
var GrammarItem = class extends CompilableBase {
  constructor() {
    super(...arguments), this.id = createID(), this._compiledProductId = null, this._depend = [];
  }
  getProduct() {
    if (isValid_default(this._product)) return this._product;
    const view = this.getVGrammarView(), id = this.getProductId();
    return isValid_default(id) && isValid_default(view) && (this._product = this._lookupGrammar(id)), this._product;
  }
  getProductId() {
    var _a;
    return null !== (_a = this._compiledProductId) && void 0 !== _a ? _a : this.generateProductId();
  }
  getDepend() {
    return this._depend;
  }
  setDepend(...depend) {
    this._depend = depend;
  }
  compile(option) {
    this._compileProduct(option), this._afterCompile(option);
  }
  _afterCompile(option) {
    var _a;
    isValid_default(this._product) && (null === (_a = this.getCompiler()) || void 0 === _a || _a.addGrammarItem(this));
  }
  updateDepend() {
    if (isValid_default(this._product)) {
      const depend = this.getDepend().map((item) => item.getProduct()).filter(isValid_default);
      return this._product.depend(depend), depend.length === this.getDepend().length;
    }
    return false;
  }
  release() {
    this.removeProduct(), super.release(), this._depend = [];
  }
  removeProduct(reserveVGrammarModel) {
    this.getCompiler().removeGrammarItem(this, reserveVGrammarModel), this._product = null, this._compiledProductId = null;
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/compilable-signal.js
var CompilableSignal = class extends GrammarItem {
  getValue() {
    return this._value;
  }
  getUpdateFunc() {
    return this._updateFunc;
  }
  constructor(option, name, value, updateFunc) {
    super(option), this.grammarType = GrammarType.signal, this.name = name, this._value = value, this._updateFunc = updateFunc;
  }
  updateSignal(value, updateFunc) {
    this._value = value, this._updateFunc = updateFunc, this.compile();
  }
  _compileProduct() {
    const view = this.getVGrammarView();
    if (!view) return;
    if (!this.getProduct()) {
      const id = this.getProductId();
      this._product = view.signal().id(id), this._compiledProductId = id;
    }
    isValid_default(this._value) && this._product.value(this._value), isValid_default(this._updateFunc) && this._product.update(this._updateFunc);
  }
  generateProductId() {
    return this.name;
  }
  _lookupGrammar(id) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getSignalById(id);
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/signal-manager.js
var SignalManager = class extends CompilableBase {
  constructor() {
    super(...arguments), this._signalMap = {};
  }
  getSignalMap() {
    return this._signalMap;
  }
  getSignal(name) {
    return this._signalMap[name];
  }
  updateSignal(name, value, updateFunc) {
    this._signalMap[name] ? this._signalMap[name].updateSignal(value, updateFunc) : (this._signalMap[name] = new CompilableSignal(this._option, name, value, updateFunc), this._signalMap[name].compile());
  }
  compile() {
    Object.values(this._signalMap).forEach((signal) => {
      signal.compile();
    });
  }
  release() {
    super.release(), Object.values(this._signalMap).forEach((signal) => {
      signal.release();
    }), this._signalMap = {};
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/state-manager.js
var StateManager = class extends SignalManager {
  getStateMap() {
    return this._stateMap;
  }
  _getDefaultStateMap() {
    return {};
  }
  constructor(option) {
    super(option), option.stateKeyToSignalName ? this.stateKeyToSignalName = option.stateKeyToSignalName : this.stateKeyToSignalName = () => "state_signal", this.initStateMap();
  }
  initStateMap(state) {
    this._stateMap = null != state ? state : this._getDefaultStateMap();
  }
  compile(stateMap) {
    const state = null != stateMap ? stateMap : this._stateMap;
    Object.keys(state).forEach((key) => {
      const name = this.stateKeyToSignalName(key), value = state[key];
      this.updateSignal(name, value);
    });
  }
  updateState(newState, noRender) {
    if (newState && (merge(this._stateMap, newState), this.compile(newState), !noRender)) return this.getCompiler().renderNextTick();
  }
};

// node_modules/@visactor/vchart/esm/animation/animate-manager.js
var AnimateManager = class extends StateManager {
  constructor() {
    super(...arguments), this.id = createID(), this.stateKeyToSignalName = (key) => `${PREFIX}_animate_${this.id}_${key}`;
  }
  getAnimationStateSignalName() {
    return this.stateKeyToSignalName("animationState");
  }
  updateAnimateState(state, noRender) {
    state === AnimationStateEnum.update ? this.updateState({
      animationState: {
        callback: (datum, element) => element.diffState
      }
    }, noRender) : state === AnimationStateEnum.appear ? this.updateState({
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.none : AnimationStateEnum.appear
      }
    }, noRender) : this.updateState({
      animationState: {
        callback: (datum, element) => state
      }
    }, noRender);
  }
  _getDefaultStateMap() {
    return {
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.exit : "update" === element.diffState ? AnimationStateEnum.update : AnimationStateEnum.appear
      }
    };
  }
};

// node_modules/@visactor/vchart/esm/model/base-model-transformer.js
var BaseModelSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type;
  }
  _initTheme(spec, chartSpec) {
    return this._theme = this.getTheme(spec, chartSpec), this._mergeThemeToSpec(spec, chartSpec);
  }
  getTheme(spec, chartSpec) {
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    this._transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo);
    const result2 = this._initTheme(spec, chartSpec);
    return this._transformSpecAfterMergingTheme(result2.spec, chartSpec, chartSpecInfo), result2;
  }
  _transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec), merge2 = (originalSpec) => mergeSpec({}, theme2, specFromChart, originalSpec);
      return isArray_default(spec) ? {
        spec: spec.map((specItem) => merge2(specItem)),
        theme: theme2
      } : {
        spec: merge2(spec),
        theme: theme2
      };
    }
    return {
      spec,
      theme: theme2
    };
  }
  _shouldMergeThemeToSpec() {
    return true;
  }
  _getDefaultSpecFromChart(chartSpec) {
  }
};

// node_modules/@visactor/vchart/esm/model/base-model.js
var BaseModel = class extends CompilableBase {
  getSpec() {
    return this._spec || {};
  }
  getSpecPath() {
    var _a;
    return null === (_a = this._option) || void 0 === _a ? void 0 : _a.specPath;
  }
  getSpecInfoPath() {
    var _a, _b, _c;
    return null !== (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.specInfoPath) && void 0 !== _b ? _b : null === (_c = this._option) || void 0 === _c ? void 0 : _c.specPath;
  }
  getData() {
    return this._data;
  }
  get layout() {
    return this._layout;
  }
  getOption() {
    return this._option;
  }
  getMarks() {
    var _a, _b;
    return null !== (_b = null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarks()) && void 0 !== _b ? _b : [];
  }
  getMarkNameMap() {
    var _a;
    return null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarkNameMap();
  }
  getMarkSet() {
    return this._marks;
  }
  getChart() {
    return this._option.getChart();
  }
  get _theme() {
    var _a;
    return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.theme;
  }
  constructor(spec, option) {
    var _a;
    super(option), this.transformerConstructor = BaseModelSpecTransformer, this.type = "null", this.modelType = "null", this.userId = void 0, this._data = null, this._layout = null, this.specKey = "", this._marks = new MarkSet(), this._lastLayoutRect = null, this.id = createID(), this.userId = spec.id, this._spec = spec, this.effect = {}, this.event = new Event2(option.eventDispatcher, option.mode), null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
  }
  _releaseEvent() {
    this.event.release();
  }
  created() {
    this.setAttrFromSpec();
  }
  init(option) {
  }
  afterInit() {
  }
  getVisible() {
    var _a;
    return false !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.visible);
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutEnd(ctx), this.getMarks().forEach((m4) => m4.updateLayoutState(true, true));
  }
  onEvaluateEnd(ctx) {
  }
  onDataUpdate() {
  }
  beforeRelease() {
  }
  clear() {
    this.getMarks().forEach((m4) => {
      var _a;
      return null === (_a = m4.clear) || void 0 === _a ? void 0 : _a.call(m4);
    });
  }
  release() {
    var _a;
    this._releaseEvent(), this._spec = void 0, this.getMarks().forEach((m4) => m4.release()), null === (_a = this._data) || void 0 === _a || _a.release(), this._data = null, this._marks.clear(), super.release();
  }
  updateSpec(spec) {
    const result2 = this._compareSpec(spec, this._spec);
    return this._spec = spec, result2;
  }
  _compareSpec(spec, prevSpec) {
    return {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
  }
  reInit(spec) {
    spec && (this._spec = spec), this.setAttrFromSpec();
  }
  updateLayoutAttribute() {
  }
  setAttrFromSpec() {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.setAttrFromSpec(this._spec, this._option.getChartViewRect());
  }
  _convertMarkStyle(style) {
    return Object.assign({}, style);
  }
  setMarkStyle(mark, style, state, level) {
    isValid_default(mark) && isValid_default(style) && mark.setStyle(this._convertMarkStyle(style), state, level);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (!isValid_default(mark) || !isValid_default(spec)) return;
    const { style, state } = spec, newSpec = Object.assign({}, spec);
    style && (newSpec.style = this._convertMarkStyle(style)), state && (newSpec.state = {}, Object.keys(state).forEach((key2) => {
      newSpec.state[key2] = this._convertMarkStyle(state[key2]);
    })), mark.initStyleWithSpec(newSpec, key);
  }
  stateKeyToSignalName(key, opt) {
    let name = `${PREFIX}_${this.modelType}_${this.type}_${this.id}_${key}`;
    return opt && (name += `_${opt}`), name;
  }
  compileData() {
    var _a;
    null === (_a = this._data) || void 0 === _a || _a.compile();
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      m4.compile({
        group
      });
    });
  }
  _createMark(markInfo, option = {}, config2) {
    const { type, name } = markInfo, m4 = Factory2.createMark(type, name, Object.assign({
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._option.globalScale
    }, option));
    return m4 && (m4.created(), config2 && m4.setMarkConfig(config2)), m4;
  }
  _getDataIdKey() {
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
  getSpecInfo() {
    var _a, _b, _c;
    const specInfo = null !== (_c = null === (_b = (_a = this._option).getSpecInfo) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : {};
    return getProperty(specInfo, this.getSpecInfoPath());
  }
  getSpecIndex() {
    const path = this.getSpecPath();
    if (!(null == path ? void 0 : path.length)) return 0;
    const index = Number(path[path.length - 1]);
    return isNaN(index) ? 0 : index;
  }
};

// node_modules/@visactor/vchart/esm/layout/layout-item.js
var LayoutItem = class {
  getSpec() {
    return this._spec || {};
  }
  getLayoutStartPoint() {
    return this._layoutStartPoint;
  }
  get layoutRectLevelMap() {
    return this._layoutRectLevelMap;
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v) {
    this._minWidth = v;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v) {
    this._maxWidth = v;
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v) {
    this._minHeight = v;
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v) {
    this._maxHeight = v;
  }
  getLastComputeOutBounds() {
    return this._lastComputeOutBounds;
  }
  get layoutOrient() {
    return this._layoutOrient;
  }
  set layoutOrient(v) {
    this._layoutOrient = v;
  }
  get model() {
    return this._model;
  }
  get type() {
    return this._model.type;
  }
  constructor(model, option) {
    var _a;
    this.layoutClip = false, this.autoIndent = false, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutRectLevelMap = {
      width: DEFAULT_LAYOUT_RECT_LEVEL,
      height: DEFAULT_LAYOUT_RECT_LEVEL
    }, this._minWidth = null, this._maxWidth = null, this._minHeight = null, this._maxHeight = null, this._lastComputeRect = null, this._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this.getLayoutRect = () => this._layoutRect, this.layoutType = "normal", this._layoutOrient = "left", this.layoutPaddingLeft = 0, this.layoutPaddingTop = 0, this.layoutPaddingRight = 0, this.layoutPaddingBottom = 0, this.layoutOffsetX = 0, this.layoutOffsetY = 0, this.layoutLevel = LayoutLevel.Region, this._model = model, this._option = option, this.layoutLevel = option.layoutLevel, this.layoutType = option.layoutType, option.layoutOrient && (this.layoutOrient = option.layoutOrient), this._spec = null === (_a = null == model ? void 0 : model.getSpec) || void 0 === _a ? void 0 : _a.call(model);
  }
  _setLayoutAttributeFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    if (this._spec && false !== this._spec.visible) {
      const padding = normalizeLayoutPaddingSpec(spec.padding), paddingValue = calcPadding(padding, chartViewRect, chartViewRect);
      this.layoutPaddingLeft = paddingValue.left, this.layoutPaddingRight = paddingValue.right, this.layoutPaddingTop = paddingValue.top, this.layoutPaddingBottom = paddingValue.bottom, this._minHeight = isNil_default(spec.minHeight) ? null !== (_a = this._minHeight) && void 0 !== _a ? _a : null : calcLayoutNumber(spec.minHeight, chartViewRect.height, chartViewRect), this._maxHeight = isNil_default(spec.maxHeight) ? null !== (_b = this._maxHeight) && void 0 !== _b ? _b : null : calcLayoutNumber(spec.maxHeight, chartViewRect.height, chartViewRect), this._minWidth = isNil_default(spec.minWidth) ? null !== (_c = this._minWidth) && void 0 !== _c ? _c : null : calcLayoutNumber(spec.minWidth, chartViewRect.width, chartViewRect), this._maxWidth = isNil_default(spec.maxWidth) ? null !== (_d = this._maxWidth) && void 0 !== _d ? _d : null : calcLayoutNumber(spec.maxWidth, chartViewRect.width, chartViewRect), spec.width && this.setLayoutRect({
        width: calcLayoutNumber(spec.width, chartViewRect.width, chartViewRect)
      }, {
        width: USER_LAYOUT_RECT_LEVEL
      }), spec.height && this.setLayoutRect({
        height: calcLayoutNumber(spec.height, chartViewRect.height, chartViewRect)
      }, {
        height: USER_LAYOUT_RECT_LEVEL
      }), isNil_default(spec.offsetX) || (this.layoutOffsetX = calcLayoutNumber(spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(spec.offsetY) || (this.layoutOffsetY = calcLayoutNumber(spec.offsetY, chartViewRect.height, chartViewRect)), spec.alignSelf && (this.alignSelf = spec.alignSelf);
    }
  }
  setAttrFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    this._spec = spec, this.layoutType = null !== (_a = spec.layoutType) && void 0 !== _a ? _a : this.layoutType, this.layoutLevel = null !== (_b = spec.layoutLevel) && void 0 !== _b ? _b : this.layoutLevel, this.layoutOrient = null !== (_c = spec.orient) && void 0 !== _c ? _c : this.layoutOrient, this._setLayoutAttributeFromSpec(spec, chartViewRect), this.layoutClip = null !== (_d = spec.clip) && void 0 !== _d ? _d : this.layoutClip;
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._setLayoutAttributeFromSpec(this._spec, viewRect);
  }
  onLayoutEnd(option) {
  }
  _getAbsoluteSpecValue(layoutRect) {
    const result2 = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };
    return ["top", "bottom", "left", "right"].forEach((k2) => {
      isNil_default(this._spec[k2]) || (result2[k2] = calcLayoutNumber(this._spec[k2], "top" === k2 || "bottom" === k2 ? layoutRect.height : layoutRect.width, layoutRect));
    }), result2;
  }
  absoluteLayoutInRect(layoutRect) {
    const { top, bottom, left: left2, right: right2 } = this._getAbsoluteSpecValue(layoutRect), layoutSize = {
      width: layoutRect.width - this.layoutPaddingLeft - this.layoutPaddingRight,
      height: layoutRect.height - this.layoutPaddingTop - this.layoutPaddingBottom
    };
    isNil_default(left2) || (layoutSize.width -= left2), isNil_default(right2) || (layoutSize.width -= right2), isNil_default(top) || (layoutSize.height -= top), isNil_default(bottom) || (layoutSize.height -= bottom), this.setLayoutRect(layoutSize);
    const { width, height } = this.computeBoundsInRect(this.getLayoutRect());
    this.setLayoutRect({
      width,
      height
    });
    const pos = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    true === this._spec.center ? (pos.x = layoutRect.x + 0.5 * layoutRect.width - 0.5 * width, pos.y = layoutRect.y + 0.5 * layoutRect.height - 0.5 * height) : (isNil_default(left2) ? isNil_default(right2) || (pos.x = layoutRect.x + layoutRect.width - this.layoutPaddingRight - right2 - width) : pos.x = layoutRect.x + left2 + this.layoutPaddingLeft, isNil_default(top) ? isNil_default(bottom) || (pos.y = layoutRect.y + layoutRect.height - this.layoutPaddingBottom - bottom - height) : pos.y = layoutRect.y + top + this.layoutPaddingTop), this.setLayoutStartPosition(pos);
  }
  setLayoutStartPosition(pos) {
    var _a, _b;
    this._option.transformLayoutPosition && (pos = this._option.transformLayoutPosition(pos)), isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y), null === (_b = (_a = this._model).afterSetLayoutStartPoint) || void 0 === _b || _b.call(_a, this._layoutStartPoint);
  }
  setLayoutRect({ width, height }, levelMap) {
    var _a, _b, _c, _d;
    isValidNumber_default(width) && (null !== (_a = null == levelMap ? void 0 : levelMap.width) && void 0 !== _a ? _a : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.width && (this._layoutRect.width = width, this._layoutRectLevelMap.width = null !== (_b = null == levelMap ? void 0 : levelMap.width) && void 0 !== _b ? _b : DEFAULT_LAYOUT_RECT_LEVEL), isValidNumber_default(height) && (null !== (_c = null == levelMap ? void 0 : levelMap.height) && void 0 !== _c ? _c : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.height && (this._layoutRect.height = height, this._layoutRectLevelMap.height = null !== (_d = null == levelMap ? void 0 : levelMap.height) && void 0 !== _d ? _d : DEFAULT_LAYOUT_RECT_LEVEL), this.setRectInSpec(this._layoutRect);
  }
  getLayout() {
    return {
      x: this._layoutStartPoint.x,
      y: this._layoutStartPoint.y,
      width: this._layoutRect.width,
      height: this._layoutRect.height
    };
  }
  mergeLayoutRect({ width, height }) {
    const rect = {
      width,
      height
    };
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (rect.width = this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (rect.height = this._layoutRect.height), rect;
  }
  getOrientPosAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "x" : "y";
  }
  getOrientSizeAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "width" : "height";
  }
  changeBoundsBySetting(bounds) {
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.x2 = bounds.x1 + this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.y2 = bounds.y1 + this._layoutRect.height), bounds.x1 -= this._layoutStartPoint.x, bounds.x2 -= this._layoutStartPoint.x, bounds.y1 -= this._layoutStartPoint.y, bounds.y2 -= this._layoutStartPoint.y, bounds;
  }
  setRectInSpec(rect) {
    const result2 = Object.assign({}, rect);
    return this._layoutRectLevelMap.width < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minWidth) || (result2.width = Math.max(result2.width, this._minWidth)), isNil_default(this._maxWidth) || (result2.width = Math.min(result2.width, this._maxWidth))) : result2.width = this._layoutRect.width, this._layoutRectLevelMap.height < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minHeight) || (result2.height = Math.max(result2.height, this._minHeight)), isNil_default(this._maxHeight) || (result2.height = Math.min(result2.height, this._maxHeight))) : result2.height = this._layoutRect.height, result2;
  }
  computeBoundsInRect(rect) {
    if (this._lastComputeRect = rect, !("region-relative" !== this.layoutType && "region-relative-overlap" !== this.layoutType || (this._layoutRectLevelMap.width !== USER_LAYOUT_RECT_LEVEL || "left" !== this.layoutOrient && "right" !== this.layoutOrient) && (this._layoutRectLevelMap.height !== USER_LAYOUT_RECT_LEVEL || "bottom" !== this.layoutOrient && "top" !== this.layoutOrient))) return this._layoutRect;
    const bounds = Object.assign({}, this._model.getBoundsInRect(this.setRectInSpec(rect), rect));
    this.changeBoundsBySetting(bounds), this.autoIndent && bounds.x2 - bounds.x1 > 0 && bounds.y2 - bounds.y1 > 0 && (this._lastComputeOutBounds.x1 = Math.ceil(-bounds.x1), this._lastComputeOutBounds.x2 = Math.ceil(bounds.x2 - rect.width), this._lastComputeOutBounds.y1 = Math.ceil(-bounds.y1), this._lastComputeOutBounds.y2 = Math.ceil(bounds.y2 - rect.height));
    let result2 = this.setRectInSpec(boundsInRect(bounds, rect));
    return this._option.transformLayoutRect && (result2 = this._option.transformLayoutRect(result2)), result2;
  }
  getModelId() {
    return this._model.id;
  }
  getModelVisible() {
    return this._model.getVisible();
  }
};

// node_modules/@visactor/vchart/esm/model/layout-model.js
var LayoutModel = class extends BaseModel {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutLevel = 0, this.layoutZIndex = 0, this._forceLayoutTag = false, this._layout = null, this._orient = null, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutStartPos = {
      x: 0,
      y: 0
    }, this._isLayout = true, this.getGraphicBounds = () => this._layout ? {
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this._transformLayoutRect = null, this._transformLayoutPosition = null;
  }
  get layoutOrient() {
    return this._orient;
  }
  set layoutOrient(v) {
    this._orient = v, this._layout && (this._layout.layoutOrient = v);
  }
  initLayout() {
    "none" !== this.layoutType && (this._layout = new LayoutItem(this, {
      layoutType: this.layoutType,
      layoutLevel: this.layoutLevel,
      layoutOrient: this._orient,
      transformLayoutRect: this._transformLayoutRect,
      transformLayoutPosition: this._transformLayoutPosition
    }), this._orient && "radius" !== this._orient && "angle" !== this._orient && this._layout && (this._layout.layoutOrient = this._orient));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._isLayout = true, super.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.updateLayoutAttribute();
    const layoutRect = this.getLayoutRect();
    !this._forceLayoutTag && isEqual(this._lastLayoutRect, layoutRect) || (this._lastLayoutRect = Object.assign({}, layoutRect)), this._forceLayoutTag = false, this._isLayout = false;
  }
  afterSetLayoutStartPoint(_pos) {
  }
  _forceLayout() {
    var _a;
    this._isLayout || (this._forceLayoutTag = true, null === (_a = this._option.globalInstance.getChart()) || void 0 === _a || _a.setLayoutTag(true));
  }
  getLayoutStartPoint() {
    return this._layout ? this._layout.getLayoutStartPoint() : this._layoutStartPos;
  }
  setLayoutStartPosition(pos) {
    return this._layout ? this._layout.setLayoutStartPosition(pos) : this._layoutStartPos = merge(this._layoutStartPos, pos);
  }
  getLayoutRect() {
    return this._layout ? this._layout.getLayoutRect() : this._layoutRect;
  }
  setLayoutRect(rect, levelMap) {
    return this._layout ? this._layout.setLayoutRect(rect) : this._lastLayoutRect = merge(this._layoutRect, rect);
  }
  getLastComputeOutBounds() {
    var _a;
    return null === (_a = this._layout) || void 0 === _a ? void 0 : _a.getLastComputeOutBounds();
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec(), this.layoutClip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this.layoutClip, this.layoutZIndex = null !== (_b = this._spec.zIndex) && void 0 !== _b ? _b : this.layoutZIndex, this.layoutType = null !== (_c = this._spec.layoutType) && void 0 !== _c ? _c : this.layoutType, this._orient = null !== (_d = this._spec.orient) && void 0 !== _d ? _d : this._orient, this.layoutLevel = null !== (_e = this._spec.layoutLevel) && void 0 !== _e ? _e : this.layoutLevel;
  }
};

// node_modules/@visactor/vchart/esm/region/region-transformer.js
var RegionSpecTransformer = class extends BaseModelSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// node_modules/@visactor/vchart/esm/region/region.js
var Region = class _Region extends LayoutModel {
  getMaxWidth() {
    return this._layout.maxWidth;
  }
  setMaxWidth(value) {
    this._layout.maxWidth = value;
  }
  getMaxHeight() {
    return this._layout.maxHeight;
  }
  setMaxHeight(value) {
    this._layout.maxHeight = value;
  }
  getGroupMark() {
    return this._groupMark;
  }
  getInteractionMark() {
    return this._interactionMark;
  }
  getStackInverse() {
    return true === this._spec.stackInverse;
  }
  getStackSort() {
    return true === this._spec.stackSort;
  }
  constructor(spec, ctx) {
    var _a;
    super(spec, ctx), this.transformerConstructor = RegionSpecTransformer, this.modelType = "region", this.specKey = "region", this.type = _Region.type, this._series = [], this.layoutType = "region", this.layoutZIndex = LayoutZIndex.Region, this.interaction = new Interaction(), this.seriesDataFilterOver = () => {
      this.event.emit(ChartEvent.regionSeriesDataFilterOver, {
        model: this,
        chart: this.getChart()
      }), this._series.forEach((s2) => {
        s2.getViewDataFilter() && s2.reTransformViewData();
      });
    }, this.getBoundsInRect = () => ({
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    }), this.userId = spec.id, this.coordinate = null !== (_a = spec.coordinate) && void 0 !== _a ? _a : "cartesian", this._option.animation && (this.animate = new AnimateManager({
      getCompiler: ctx.getCompiler
    })), this.interaction.setDisableActiveEffect(this._option.disableTriggerEvent);
  }
  _getClipDefaultValue() {
    var _a, _b, _c, _d;
    const chartSpec = this._option.getChart().getSpec(), hasDataZoom = null === (_b = null === (_a = chartSpec.dataZoom) || void 0 === _a ? void 0 : _a.some) || void 0 === _b ? void 0 : _b.call(_a, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "filter");
    }), hasScrollBar = null === (_d = null === (_c = chartSpec.scrollBar) || void 0 === _c ? void 0 : _c.some) || void 0 === _d ? void 0 : _d.call(_c, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "axis");
    });
    return !(!hasDataZoom && !hasScrollBar) || this._layout.layoutClip;
  }
  created() {
    var _a, _b;
    this.initLayout(), super.created();
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    this._groupMark = this._createGroupMark("regionGroup", this.userId, this.layoutZIndex), this._spec.roam && this._groupMark.setMarkConfig({
      interactive: true
    }), this._interactionMark = this._createGroupMark("regionInteractionGroup", (null !== (_b = this.userId) && void 0 !== _b ? _b : this.type) + "_interaction", LayoutZIndex.Interaction), isEmpty_default(this._spec.style) || (this._backgroundMark = this._createMark({
      type: "rect",
      name: "regionBackground"
    }), clip && (this._foregroundMark = this._createMark({
      type: "rect",
      name: "regionForeground"
    })), [this._backgroundMark, this._foregroundMark].forEach((mark) => {
      mark && (mark.created(), this.setMarkStyle(mark, {
        width: () => this.getLayoutRect().width,
        height: () => this.getLayoutRect().height
      }, "normal", AttributeLevel.Built_In), this._groupMark.addMark(mark));
    }), this._backgroundMark && this._backgroundMark.setMarkConfig({
      zIndex: LayoutZIndex.SeriesGroup - 1
    }), this._foregroundMark && this._foregroundMark.setMarkConfig({
      zIndex: LayoutZIndex.Mark + 1
    })), this.createTrigger();
  }
  _createGroupMark(name, userId, zIndex) {
    var _a, _b;
    const groupMark = this._createMark({
      type: "group",
      name
    });
    groupMark.setUserId(userId), groupMark.setMarkConfig({
      zIndex
    });
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    return this.setMarkStyle(groupMark, {
      x: () => this.getLayoutStartPoint().x,
      y: () => this.getLayoutStartPoint().y,
      width: () => this.getLayoutRect().width,
      height: () => this.getLayoutRect().height,
      clip
    }, "normal", AttributeLevel.Built_In), this.setMarkStyle(groupMark, {
      cornerRadius: null === (_b = this._spec.style) || void 0 === _b ? void 0 : _b.cornerRadius
    }, "normal", AttributeLevel.User_Mark), this._marks.addMark(groupMark), groupMark;
  }
  init(option) {
    super.init(option), this.initMark(), this.initSeriesDataflow(), this.initInteraction(), this.initTrigger();
  }
  initMark() {
    this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  _initBackgroundMarkStyle() {
    var _a, _b;
    this._backgroundMark && (this.setMarkStyle(this._backgroundMark, Object.assign({
      fillOpacity: (null === (_a = this._spec.style) || void 0 === _a ? void 0 : _a.fill) ? 1 : 0
    }, this._spec.style), "normal", AttributeLevel.User_Mark), (null !== (_b = this._spec.clip) && void 0 !== _b ? _b : this._getClipDefaultValue()) && this.setMarkStyle(this._backgroundMark, {
      strokeOpacity: 0
    }, "normal", AttributeLevel.Built_In));
  }
  _initForegroundMarkStyle() {
    this._foregroundMark && this.setMarkStyle(this._foregroundMark, Object.assign(Object.assign({}, this._spec.style), {
      fillOpacity: 0,
      pickable: false
    }), "normal", AttributeLevel.User_Mark);
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(null == prevSpec ? void 0 : prevSpec.style, null == spec ? void 0 : spec.style) || (result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  addSeries(s2) {
    s2 && (this._series.includes(s2) || this._series.push(s2));
  }
  removeSeries(s2) {
    if (!s2) return;
    const index = this._series.findIndex((s_) => s_ === s2);
    index >= 0 && this._series.splice(index, 1);
  }
  getSeries(opt = {}) {
    return this._series.filter((s2) => {
      var _a, _b;
      return (!opt.name || (null == s2 ? void 0 : s2.name) === opt.name) && (!opt.userId || array(opt.userId).includes(s2.userId)) && (!isValid_default(opt.specIndex) || array(opt.specIndex).includes(s2.getSpecIndex())) && (!opt.id || s2.id === opt.id) && (!opt.type || s2.type === opt.type) && (!opt.coordinateType || s2.coordinate === opt.coordinateType) && (!opt.dataName || (null === (_b = null === (_a = s2.getRawData) || void 0 === _a ? void 0 : _a.call(s2)) || void 0 === _b ? void 0 : _b.name) === opt.dataName);
    });
  }
  getSeriesInName(name) {
    return this.getSeries({
      name
    })[0];
  }
  getSeriesInUserId(userId) {
    return this.getSeries({
      userId
    })[0];
  }
  getSeriesInId(id) {
    return this.getSeries({
      id
    })[0];
  }
  getSeriesInType(type) {
    return this.getSeries({
      type
    });
  }
  getSeriesInCoordinateType(coordinateType) {
    return this.getSeries({
      coordinateType
    });
  }
  getSeriesInDataName(dataName) {
    return this.getSeries({
      dataName
    });
  }
  onRender(ctx) {
  }
  initSeriesDataflow() {
    const viewDataFilters = this._series.map((s2) => {
      var _a;
      return null !== (_a = s2.getViewDataFilter()) && void 0 !== _a ? _a : s2.getViewData();
    }).filter((v) => !!v);
    this._option.dataSet.multipleDataViewAddListener(viewDataFilters, "change", this.seriesDataFilterOver);
  }
  release() {
    super.release(), this._series = [];
  }
  createTrigger() {
    const triggerOptions = Object.assign(Object.assign({}, this._option), {
      model: this,
      interaction: this.interaction
    });
    this._trigger = new DimensionTrigger(triggerOptions);
  }
  initTrigger() {
    this._series.forEach((s2) => {
      s2.getMarksWithoutRoot().forEach((m4) => {
        this._trigger.registerMark(m4);
      });
    }), this._trigger.init();
  }
  initInteraction() {
    this._option.disableTriggerEvent || this._series.forEach((s2) => {
      s2.getMarksWithoutRoot().forEach((m4) => {
        for (const key in STATE_VALUE_ENUM_REVERSE) isEmpty_default(m4.stateStyle[STATE_VALUE_ENUM_REVERSE[key]]) || this.interaction.registerMark(STATE_VALUE_ENUM_REVERSE[key], m4);
      });
    });
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      var _a;
      m4.compile({
        group,
        context: {
          model: this
        }
      }), null === (_a = m4.getProduct()) || void 0 === _a || _a.layout((group2, children, parentLayoutBounds, options) => {
      });
    });
  }
  compile() {
    var _a;
    null === (_a = this.animate) || void 0 === _a || _a.compile(), this.compileMarks();
  }
  onLayoutEnd(ctx) {
    this._series.forEach((s2) => s2.onLayoutEnd(ctx)), super.onLayoutEnd(ctx);
  }
};
Region.type = "region", Region.transformerConstructor = RegionSpecTransformer, Region.specKey = "region";

// node_modules/@visactor/vchart/esm/layout/util.js
function getPositionItems(items) {
  const startItems = [], middleItems = [], endItems = [];
  return items.forEach((item) => {
    isNil_default(item.getSpec().position) || "start" === item.getSpec().position ? startItems.push(item) : "middle" === item.getSpec().position ? middleItems.push(item) : "end" === item.getSpec().position && endItems.push(item);
  }), {
    startItems,
    endItems,
    middleItems
  };
}
function adjustItemsToCenter(allItems, isVertical3, containerLength) {
  isVertical3 ? allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().y + lastItem.getLayoutRect().height - items[0].getLayoutStartPoint().y, centerY = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x,
        y: item.getLayoutStartPoint().y + centerY
      });
    });
  }) : allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().x + lastItem.getLayoutRect().width - items[0].getLayoutStartPoint().x, centerX = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x + centerX,
        y: item.getLayoutStartPoint().y
      });
    });
  });
}
function alignSelfOfItems(allItems, isVertical3, maxSizes, sign2) {
  let maxSize;
  allItems.forEach((lineItems, index) => {
    lineItems.length > 1 && (maxSize = maxSizes[index], lineItems.forEach((item) => {
      if (!item.alignSelf || "start" === item.alignSelf) return;
      const pos = item.getLayoutStartPoint(), ratio = "middle" === item.alignSelf ? 0.5 : 1, delta = isVertical3 ? maxSize - (item.getLayoutRect().width + item.layoutPaddingLeft + item.layoutPaddingRight) : maxSize - (item.getLayoutRect().height + item.layoutPaddingTop + item.layoutPaddingBottom);
      isVertical3 ? item.setLayoutStartPosition({
        x: pos.x + sign2 * delta * ratio,
        y: pos.y
      }) : item.setLayoutStartPosition({
        x: pos.x,
        y: pos.y + sign2 * delta * ratio
      });
    }));
  });
}
function layoutLeftRightStartOrMiddleItems(items, layout2, limitHeight, isMiddle, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout2.rightCurrent : layout2.leftCurrent, preTop = layout2.topCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preTop + item.layoutOffsetY + item.layoutPaddingTop
      }), preTop += itemTotalHeight, preTop > limitHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preTop = layout2.topCurrent + itemTotalHeight, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: layout2.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxWidth = Math.max(maxWidth, itemTotalWidth), singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isMiddle && adjustItemsToCenter(allItems, true, limitHeight), isRight ? layout2.rightCurrent = preX + xSign * maxWidth : layout2.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutLeftRightEndItems(items, layout2, limitWidth, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout2.rightCurrent : layout2.leftCurrent, preBottom = layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      preBottom < itemTotalHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preBottom = layout2.bottomCurrent, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), maxWidth = Math.max(maxWidth, itemTotalWidth), preBottom -= itemTotalHeight, singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isRight ? layout2.rightCurrent = preX + xSign * maxWidth : layout2.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutTopBottomStartOrMiddleItems(items, layout2, limitWidth, isMiddle, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preLeft = layout2.leftCurrent, preY = isTop ? layout2.topCurrent : layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      item.setLayoutStartPosition({
        x: preLeft + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), preLeft += itemTotalWidth, preLeft > limitWidth && singleLineItems.length ? (maxHeights.push(maxHeight), preLeft = layout2.leftCurrent + itemTotalWidth, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout2.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxHeight = Math.max(maxHeight, itemTotalHeight), singleLineItems.push(item));
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isMiddle && adjustItemsToCenter(allItems, false, limitWidth), isTop ? layout2.topCurrent = preY + ySign * maxHeight : layout2.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutTopBottomEndItems(items, layout2, limitWidth, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preRight = layout2.rightCurrent, preY = isTop ? layout2.topCurrent : layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      preRight < itemTotalWidth && singleLineItems.length ? (preRight = layout2.rightCurrent, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout2.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (singleLineItems.push(item), item.setLayoutStartPosition({
        x: preRight + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), maxHeight = Math.max(maxHeight, itemTotalHeight), preRight -= itemTotalWidth);
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isTop ? layout2.topCurrent = preY + ySign * maxHeight : layout2.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutLeftInlineItems(items, layout2, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout2, limitHeight, false, "left"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout2, limitHeight, true, "left"), endItems.length && layoutLeftRightEndItems(endItems, layout2, limitHeight, "left");
}
function layoutRightInlineItems(items, layout2, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout2, limitHeight, false, "right"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout2, limitHeight, true, "right"), endItems.length && layoutLeftRightEndItems(endItems, layout2, limitHeight, "right");
}
function layoutTopInlineItems(items, layout2, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout2, limitWidth, false, "top"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout2, limitWidth, true, "top"), endItems.length && layoutTopBottomEndItems(endItems, layout2, limitWidth, "top");
}
function layoutBottomInlineItems(items, layout2, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout2, limitWidth, false, "bottom"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout2, limitWidth, true, "bottom"), endItems.length && layoutTopBottomEndItems(endItems, layout2, limitWidth, "bottom");
}

// node_modules/@visactor/vchart/esm/layout/base-layout.js
var Layout = class {
  constructor(_spec, ctx) {
    this.leftCurrent = 0, this.topCurrent = 0, this.rightCurrent = 0, this.bottomCurrent = 0, this._onError = null == ctx ? void 0 : ctx.onError;
  }
  _layoutInit(_chart, items, chartLayoutRect, chartViewBox) {
    this._chartLayoutRect = chartLayoutRect, this._chartViewBox = chartViewBox, this.leftCurrent = chartLayoutRect.x, this.topCurrent = chartLayoutRect.y, this.rightCurrent = chartLayoutRect.x + chartLayoutRect.width, this.bottomCurrent = chartLayoutRect.height + chartLayoutRect.y, items.sort((a3, b) => b.layoutLevel - a3.layoutLevel);
  }
  _layoutNormalItems(items) {
    this.layoutNormalInlineItems(items.filter((x) => "normal-inline" === x.layoutType)), this.layoutNormalItems(items.filter((x) => "normal" === x.layoutType));
  }
  _groupItems(items) {
    const regionItems = items.filter((x) => "region" === x.layoutType), relativeItems = items.filter((x) => "region-relative" === x.layoutType), relativeOverlapItems = items.filter((x) => "region-relative-overlap" === x.layoutType), allRelatives = relativeItems.concat(relativeOverlapItems), overlapItems = {
      left: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      right: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      top: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      bottom: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      z: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      }
    };
    return relativeOverlapItems.forEach((i) => {
      overlapItems[i.layoutOrient].items.push(i);
    }), {
      regionItems,
      relativeItems,
      relativeOverlapItems,
      allRelatives,
      overlapItems
    };
  }
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._layoutInit(_chart, items, chartLayoutRect, chartViewBox), this._layoutNormalItems(items);
    const layoutTemp = {
      left: this.leftCurrent,
      top: this.topCurrent,
      right: this.rightCurrent,
      bottom: this.bottomCurrent
    }, { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
    this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems), this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp), this.layoutAbsoluteItems(items.filter((x) => "absolute" === x.layoutType));
  }
  _processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }, allRelatives, layoutTemp) {
    if (allRelatives.some((i) => i.autoIndent)) {
      const { top, bottom, left: left2, right: right2 } = this._checkAutoIndent(allRelatives, layoutTemp);
      (top || bottom || left2 || right2) && (this.topCurrent = layoutTemp.top + top, this.bottomCurrent = layoutTemp.bottom - bottom, this.leftCurrent = layoutTemp.left + left2, this.rightCurrent = layoutTemp.right - right2, this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems));
    }
  }
  layoutNormalItems(normalItems) {
    normalItems.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "right" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "bottom" === item.layoutOrient && (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingRight,
        y: this.bottomCurrent + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom);
    });
  }
  layoutNormalInlineItems(normalItems) {
    const leftItems = normalItems.filter((item) => "left" === item.layoutOrient), rightItems = normalItems.filter((item) => "right" === item.layoutOrient), topItems = normalItems.filter((item) => "top" === item.layoutOrient), bottomItems = normalItems.filter((item) => "bottom" === item.layoutOrient), limitWidth = this._chartLayoutRect.width + this._chartLayoutRect.x, limitHeight = this._chartLayoutRect.height + this._chartLayoutRect.y;
    leftItems.length && layoutLeftInlineItems(leftItems, this, limitHeight), topItems.length && layoutTopInlineItems(topItems, this, limitWidth), rightItems.length && layoutRightInlineItems(rightItems, this, limitHeight), bottomItems.length && layoutBottomInlineItems(bottomItems, this, limitWidth);
  }
  _layoutRelativeOverlap(orient, info) {
    info.items.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      info.rect.width = Math.max(rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, info.rect.width), info.rect.height = Math.max(rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, info.rect.height);
    }), info.items.forEach((item) => {
      item.setLayoutRect(info.rect), "left" === orient ? item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX
      }) : "right" === orient ? item.setLayoutStartPosition({
        x: this.rightCurrent - info.rect.width + item.layoutOffsetX
      }) : "top" === orient ? item.setLayoutStartPosition({
        x: this.topCurrent + item.layoutOffsetY
      }) : item.setLayoutStartPosition({
        x: this.bottomCurrent - info.rect.height + item.layoutOffsetY
      });
    }), "left" === orient ? this.leftCurrent += info.rect.width : "right" === orient ? this.rightCurrent -= info.rect.width : "top" === orient ? this.topCurrent += info.rect.height : this.bottomCurrent -= info.rect.height;
  }
  _layoutRelativeItem(item, layoutRect) {
    const rect = item.computeBoundsInRect(layoutRect);
    "left" === item.layoutOrient || "right" === item.layoutOrient ? item.setLayoutRect({
      width: rect.width
    }) : item.setLayoutRect({
      height: rect.height
    }), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
      x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "right" === item.layoutOrient ? (this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, item.setLayoutStartPosition({
      x: this.rightCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    })) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
      y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "bottom" === item.layoutOrient && (this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, item.setLayoutStartPosition({
      y: this.bottomCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }));
  }
  _layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight) {
    const regionWidth = Math.max(Math.min(regionRelativeTotalWidth, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxWidth) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0), regionHeight = Math.max(Math.min(regionRelativeTotalHeight, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxHeight) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0);
    return regionItems.forEach((region) => {
      const width = regionWidth - region.layoutPaddingLeft - region.layoutPaddingRight, height = regionHeight - region.layoutPaddingTop - region.layoutPaddingBottom;
      region.setLayoutRect({
        width,
        height
      }), region.setLayoutStartPosition({
        x: this.leftCurrent + region.layoutOffsetX + region.layoutPaddingLeft,
        y: this.topCurrent + region.layoutOffsetY + region.layoutPaddingTop
      });
    }), {
      regionHeight,
      regionWidth
    };
  }
  layoutRegionItems(regionItems, regionRelativeItems, regionRelativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }) {
    let regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    regionRelativeItems.filter((x) => "left" === x.layoutOrient || "right" === x.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("left", overlapItems.left), this._layoutRelativeOverlap("right", overlapItems.right), regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeItems.filter((x) => "top" === x.layoutOrient || "bottom" === x.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("top", overlapItems.top), this._layoutRelativeOverlap("bottom", overlapItems.bottom), regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    const { regionWidth, regionHeight } = this._layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight);
    regionRelativeItems.concat(regionRelativeOverlapItems).forEach((item) => {
      if (["left", "right"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          height: relativeRegion.getLayoutRect().height
        }), item.setLayoutStartPosition({
          y: relativeRegion.getLayoutStartPoint().y + item.layoutOffsetY + item.layoutPaddingTop
        }), "right" === item.layoutOrient && item.setLayoutStartPosition({
          x: item.getLayoutStartPoint().x + regionWidth - regionRelativeTotalWidth
        });
      } else if (["top", "bottom"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          width: relativeRegion.getLayoutRect().width
        }), item.setLayoutStartPosition({
          x: relativeRegion.getLayoutStartPoint().x + item.layoutOffsetX + item.layoutPaddingLeft
        }), "bottom" === item.layoutOrient && item.setLayoutStartPosition({
          y: item.getLayoutStartPoint().y + regionHeight - regionRelativeTotalHeight
        });
      }
    });
  }
  layoutAbsoluteItems(absoluteItems) {
    absoluteItems.forEach((item) => {
      item.absoluteLayoutInRect(this._chartLayoutRect);
    });
  }
  filterRegionsWithID(items, id) {
    var _a;
    const target = items.find((x) => x.getModelId() === id);
    return target || (null !== (_a = this._onError) && void 0 !== _a ? _a : error)("can not find target region item, invalid id"), target;
  }
  getItemComputeLayoutRect(item) {
    return {
      width: this.rightCurrent - this.leftCurrent - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: this.bottomCurrent - this.topCurrent - item.layoutPaddingTop - item.layoutPaddingBottom
    };
  }
  _checkAutoIndent(items, layoutTemp) {
    const result2 = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    };
    return items.forEach((i) => {
      if (!i.getModelVisible() || !i.autoIndent) return;
      const vOrH = "left" === i.layoutOrient || "right" === i.layoutOrient, itemOuter = i.getLastComputeOutBounds(), outer = this._getOutInLayout(itemOuter, i, layoutTemp);
      vOrH ? (result2.top = Math.max(result2.top, outer.top), result2.bottom = Math.max(result2.bottom, outer.bottom)) : (result2.left = Math.max(result2.left, outer.left), result2.right = Math.max(result2.right, outer.right));
    }), result2;
  }
  _getOutInLayout(itemOuter, i, tempBorder) {
    const { x, y } = i.getLayoutStartPoint(), { width, height } = i.getLayoutRect();
    return {
      left: tempBorder.left - (x - itemOuter.x1),
      right: x + width + itemOuter.x2 - tempBorder.right,
      top: tempBorder.top - (y - itemOuter.y1),
      bottom: y + height + itemOuter.y2 - tempBorder.bottom
    };
  }
};
Layout.type = "base";

// node_modules/@visactor/vchart/esm/constant/gradient.js
var GradientType = ["linear", "radial", "conical"];
var DEFAULT_LINEAR_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1
};
var DEFAULT_RADIAL_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1,
  r0: 0,
  r1: 1
};
var DEFAULT_CONICAL_GRADIENT_CONFIG = {
  x: 0.5,
  y: 0.5,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var DEFAULT_GRADIENT_CONFIG = {
  linear: DEFAULT_LINEAR_GRADIENT_CONFIG,
  radial: DEFAULT_RADIAL_GRADIENT_CONFIG,
  conical: DEFAULT_CONICAL_GRADIENT_CONFIG
};

// node_modules/@visactor/vchart/esm/mark/utils/common.js
var MultiDatumMark = ["line", "area", "trail"];
function isMultiDatumMark(type) {
  return MultiDatumMark.includes(type);
}
function curveTypeTransform(type, direction) {
  return "monotone" === type ? "horizontal" === direction ? "monotoneY" : "monotoneX" : type;
}
function is3DMark(type) {
  return ["arc3d", "rect3d", "pyramid3d"].includes(type);
}

// node_modules/@visactor/vchart/esm/compile/mark/mark-state-manager.js
var MarkStateManager = class extends StateManager {
  getStateInfoList() {
    return this._stateInfoList;
  }
  constructor(option, mark) {
    super(option), this._stateInfoList = [], this._mark = mark;
  }
  _getDefaultStateMap() {
    return {
      markUpdateRank: 1
    };
  }
  getStateInfo(stateValue) {
    return this._stateInfoList.find((s2) => s2.stateValue === stateValue);
  }
  addStateInfo(stateInfo) {
    if (this.getStateInfo(stateInfo.stateValue)) return;
    stateInfo.level = stateInfo.level || 0;
    let needPush = true;
    for (let i = 0; i < this._stateInfoList.length; i++) {
      const level = this._stateInfoList[i].level;
      if (level && level > stateInfo.level) {
        this._stateInfoList.splice(i, 0, stateInfo), needPush = false;
        break;
      }
    }
    needPush && this._stateInfoList.push(stateInfo);
  }
  _clearStateBeforeSet(state) {
    state.datums = null, state.items = null, state.fields = null, state.filter = null;
  }
  changeStateInfo(stateInfo) {
    const s2 = this.getStateInfo(stateInfo.stateValue);
    if (s2) {
      if (void 0 !== stateInfo.datums && (this._clearStateBeforeSet(s2), s2.datums = stateInfo.datums, s2.datumKeys = stateInfo.datumKeys), void 0 !== stateInfo.items && (this._clearStateBeforeSet(s2), s2.items = stateInfo.items), void 0 !== stateInfo.fields) if (this._clearStateBeforeSet(s2), null === stateInfo.fields) s2.fields = stateInfo.fields;
      else {
        s2.fields = s2.fields || {};
        for (const key in stateInfo.fields) {
          const new_f = stateInfo.fields[key];
          s2.fields[key] = s2.fields[key] || {};
          const old_f = s2.fields[key];
          isValid_default(new_f.domain) && (old_f.domain = new_f.domain), isValid_default(new_f.type) && (old_f.type = new_f.type);
        }
      }
      stateInfo.filter && (this._clearStateBeforeSet(s2), s2.filter = stateInfo.filter);
    } else this.addStateInfo(stateInfo);
  }
  clearStateInfo(stateValues) {
    stateValues.forEach((stateValue) => {
      this.getStateInfo(stateValue) && this.changeStateInfo({
        stateValue,
        datumKeys: null,
        datums: null,
        fields: null,
        items: null,
        filter: null,
        cache: {}
      });
    });
  }
  checkOneState(renderNode, datum, state, isMultiMark) {
    var _a;
    isMultiMark = isBoolean_default(isMultiDatumMark) ? isMultiMark : !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    let inState = false, stateChecked = false;
    if (isValid_default(state.datums) && state.datums.length > 0) inState = this.checkDatumState(state, datum, isMultiMark), stateChecked = true;
    else if (state.items) inState = null !== (_a = this.checkItemsState(state, renderNode)) && void 0 !== _a && _a, stateChecked = true;
    else if (state.fields) inState = this.checkFieldsState(state, datum, renderNode, isMultiMark), stateChecked = true;
    else if (!inState && state.filter) {
      const options = {
        mark: this._mark,
        renderNode,
        type: renderNode.mark.markType
      };
      inState = state.filter(datum, options), stateChecked = true;
    }
    return stateChecked ? inState ? "in" : "out" : "skip";
  }
  checkState(renderNode, datum) {
    const result2 = renderNode.getStates().filter((s2) => stateInDefaultEnum(s2)).map((s2) => [s2, 10]), isMultiMark = !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    for (let i = 0; i < this._stateInfoList.length; i++) {
      const state = this._stateInfoList[i], inOut = this.checkOneState(renderNode, datum, state, isMultiMark);
      "skip" !== inOut && ("in" === inOut && result2.push([state.stateValue, state.level]));
    }
    return result2.map((res) => res[0]);
  }
  checkDatumState(state, datum, isMultiMark) {
    let inState = false;
    const datum_v = isMultiMark ? datum[0] : datum;
    if (isArray_default(state.datums)) {
      const keys = state.datumKeys || Object.keys(state.datums[0]).filter((k2) => !k2.startsWith(PREFIX));
      inState = state.datums.some((d) => isMultiMark && isArray_default(null == d ? void 0 : d.items) ? keys.every((k2) => {
        var _a, _b;
        return (null === (_b = null === (_a = null == d ? void 0 : d.items) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b[k2]) === (null == datum_v ? void 0 : datum_v[k2]);
      }) : keys.every((k2) => (null == d ? void 0 : d[k2]) === (null == datum_v ? void 0 : datum_v[k2])));
    } else if (isObject_default(state.datums)) {
      inState = (state.datumKeys || Object.keys(state.datums).filter((k2) => !k2.startsWith(PREFIX))).every((k2) => {
        var _a, _b;
        return isMultiMark ? (null === (_a = state.datums.items) || void 0 === _a ? void 0 : _a[0][k2]) === datum_v[k2] : (null === (_b = state.datums) || void 0 === _b ? void 0 : _b[k2]) === datum_v[k2];
      });
    } else inState = datum === state.datums;
    return inState;
  }
  checkItemsState(state, item) {
    var _a;
    return null === (_a = state.items) || void 0 === _a ? void 0 : _a.includes(item);
  }
  checkFieldsState(state, datum, item, isMultiMark) {
    var _a;
    let inState = true;
    for (const key in state.fields) {
      const field5 = state.fields[key], type = field5.type, domain = field5.domain, datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
      if (isContinuous(type) && domain.length > 1) {
        if (this.checkLinearFieldState(domain, key, datum, item, isMultiMark)) {
          inState = false;
          break;
        }
        inState = true;
      } else {
        if (!domain.some((d) => d === datum_v)) {
          inState = false;
          break;
        }
        inState = true;
      }
    }
    return inState;
  }
  checkLinearFieldState(domain, key, datum, item, isMultiMark) {
    var _a;
    const datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
    return datum_v < domain[0] || datum_v > domain[domain.length - 1];
  }
  updateLayoutState(noRender) {
    return this._stateMap.markUpdateRank++, this.updateState({
      markUpdateRank: this._stateMap.markUpdateRank
    }, noRender);
  }
  compileState(product, stateSort) {
    product.state({
      callback: (datum, element) => this.checkState(element, datum)
    }, stateSort);
  }
};

// node_modules/@visactor/vchart/esm/compile/data/compilable-data.js
var CompilableData = class extends GrammarItem {
  getDataView() {
    return this._data;
  }
  setDataView(d) {
    this._data = d;
  }
  getLatestData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
  }
  constructor(option, dataView) {
    super(option), this.grammarType = GrammarType.data, this._data = null, this._data = dataView;
  }
  release() {
    super.release(), this._data = null;
  }
  updateData(noRender) {
    const product = this.getProduct(), data = this.getLatestData();
    if (product && data && (product.values(data), !noRender)) return this.getCompiler().renderNextTick();
  }
  _compileProduct() {
    const data = this.getLatestData();
    isNil_default(data) || (isNil_default(this.getProduct()) ? this._initProduct(data) : this._product.values(data));
  }
  _initProduct(data) {
    var _a, _b;
    const view = this.getVGrammarView();
    if (!view || !data) return;
    const id = this.getProductId();
    this._product = null === (_b = null === (_a = null == view ? void 0 : view.data) || void 0 === _a ? void 0 : _a.call(view, data)) || void 0 === _b ? void 0 : _b.id(id), this._compiledProductId = id;
  }
  generateProductId() {
    var _a;
    return `${null === (_a = this.getDataView()) || void 0 === _a ? void 0 : _a.name}`;
  }
  _lookupGrammar(id) {
    var _a, _b;
    return null === (_b = null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getDataById) || void 0 === _b ? void 0 : _b.call(_a, id);
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/mark-data.js
var MarkData = class extends CompilableData {
  constructor(option) {
    super(option), this._mark = option.mark;
  }
  setCompiledProductId(name) {
    this._compiledProductId = name;
  }
  generateProductId() {
    const name = super.generateProductId();
    return isValid_default(name) ? name : `${PREFIX}_markData_${this._mark.id}`;
  }
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct(data);
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/compilable-mark.js
var __rest16 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var CompilableMark = class extends GrammarItem {
  getMarkConfig() {
    return this._markConfig;
  }
  setMarkConfig(config2) {
    Object.keys(config2).forEach((key) => {
      this._markConfig[key] = config2[key];
    });
  }
  getVisible() {
    return this._visible;
  }
  setVisible(visible) {
    this._visible = visible;
  }
  getUserId() {
    return this._userId;
  }
  setUserId(userId) {
    isValid_default(userId) && (this._userId = userId);
  }
  getDataView() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  setDataView(d, productId) {
    isNil_default(this._data) && this.initMarkData(Object.assign(Object.assign({}, this._option), {
      mark: this
    })), isValid_default(productId) && this._data.setCompiledProductId(productId), this._data.setDataView(d);
  }
  getData() {
    return this._data;
  }
  setData(d) {
    this._data = d;
  }
  hasState(state) {
    return state in this.state.getStateMap();
  }
  getState(state) {
    return this.state.getStateMap()[state];
  }
  getAnimationConfig() {
    return this._animationConfig;
  }
  setAnimationConfig(config2) {
    this._animationConfig = config2;
  }
  setSkipBeforeLayouted(skip) {
    this._skipBeforeLayouted = skip;
  }
  getSkipBeforeLayouted() {
    return this._skipBeforeLayouted;
  }
  getGroupKey() {
    return this._groupKey;
  }
  setGroupKey(groupKey) {
    this._groupKey = groupKey;
  }
  setStateSortCallback(stateSort) {
    this._stateSort = stateSort;
  }
  constructor(option, name, model) {
    super(option), this.grammarType = GrammarType.mark, this.type = void 0, this.name = "mark", this._markConfig = {
      zIndex: LayoutZIndex.Mark,
      morph: false
    }, this._visible = true, this.stateStyle = {}, this._unCompileChannel = {}, this._skipBeforeLayouted = false, this.name = name, this.model = model, this.key = option.key, this.state = new MarkStateManager(Object.assign(Object.assign({}, option), {
      stateKeyToSignalName: this.stateKeyToSignalName.bind(this)
    }), this), this._event = new Event2(model.getOption().eventDispatcher, model.getOption().mode);
  }
  setTransform(transform30) {
    this._transform = transform30;
  }
  initMarkData(option) {
    this._data = new MarkData(option);
  }
  stateKeyToSignalName(key) {
    return `${PREFIX}_${this.type}_${this.id}_${key}`;
  }
  getAttribute(key, datum, state, opt) {
  }
  _compileProduct(option) {
    const product = this.getProduct();
    if (!this.getVisible()) return void (isValid_default(product) && this.removeProduct());
    if (isValid_default(product)) return;
    this.getCompiler().isInited && (this._initProduct(null == option ? void 0 : option.group), isNil_default(this._product) || (this.compileSignal(), this.compileData(), this.compileState(), this.compileEncode(), this.compileAnimation(), this.compileContext(null == option ? void 0 : option.context), this.compileTransform()));
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id = this.getProductId();
    this._product = view.mark(this.type, null != group ? group : view.rootMark).id(id), this.name && this._product && this._product.name(this.name), this._compiledProductId = id;
  }
  generateProductId() {
    return this._userId ? `${this._userId}` : `${this.name}_${this.id}`;
  }
  compileData() {
    if (isNil_default(this._data)) return;
    this._data.compile();
    const dataProduct = this._data.getProduct();
    isValid_default(this._product) && isValid_default(dataProduct) && this._product.join(dataProduct, this.key, void 0, this.getGroupKey());
  }
  updateStaticEncode() {
    if (!this._product) return;
    const { enterStyles, updateStyles } = this._separateStyle();
    this._product.encodeState("group", enterStyles, true), this._product.encode(updateStyles, true);
  }
  _separateStyle() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, normalStyle = _a[_b], enterStyles = (__rest16(_a, ["symbol" == typeof _b ? _b : _b + ""]), this._option.noSeparateStyle ? null : {}), updateStyles = {};
    return Object.keys(normalStyle).forEach((key) => {
      this._unCompileChannel[key] || (this._option.noSeparateStyle || isStateAttrChangeable(key, normalStyle, this.getGroupKey()) ? updateStyles[key] = {
        callback: this.compileCommonAttributeCallback(key, "normal"),
        dependency: [this.stateKeyToSignalName("markUpdateRank")]
      } : enterStyles[key] = this.compileCommonAttributeCallback(key, "normal"));
    }), {
      enterStyles,
      updateStyles
    };
  }
  compileEncode() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, temp2 = (_a[_b], __rest16(_a, ["symbol" == typeof _b ? _b : _b + ""])), { enterStyles, updateStyles } = this._separateStyle();
    this._product.encode(updateStyles, true), this._product.encodeState("group", enterStyles, true), Object.keys(temp2).forEach((state) => {
      const styles = {};
      Object.keys(temp2[state]).forEach((key) => {
        this._unCompileChannel[key] || (styles[key] = {
          callback: this.compileCommonAttributeCallback(key, state),
          dependency: [this.stateKeyToSignalName("markUpdateRank")]
        });
      }), this._product.encodeState(state, styles, true);
    }), this._skipBeforeLayouted && this._product.layout({
      skipBeforeLayouted: this._skipBeforeLayouted
    });
  }
  compileState() {
    this.state.compileState(this._product, this._stateSort);
  }
  compileAnimation() {
    var _a, _b, _c, _d;
    if (this._animationConfig) {
      let stateSignal;
      if ("component" === this.type) stateSignal = null === (_a = this.model.animate) || void 0 === _a ? void 0 : _a.getAnimationStateSignalName();
      else {
        const region = null === (_c = (_b = this.model).getRegion) || void 0 === _c ? void 0 : _c.call(_b);
        stateSignal = null === (_d = null == region ? void 0 : region.animate) || void 0 === _d ? void 0 : _d.getAnimationStateSignalName();
      }
      this._product.animation(this._animationConfig), this._product.animationState({
        callback: (datum, element, parameters) => {
          var _a2;
          return null === (_a2 = parameters[stateSignal]) || void 0 === _a2 ? void 0 : _a2.callback(datum, element);
        },
        dependency: stateSignal
      }), this._animationConfig.normal && (this._animationConfig.appear ? this._event.on(HOOK_EVENT.ANIMATION_END, ({ event }) => {
        event.mark === this.getProduct() && event.animationState === AnimationStateEnum.appear && this.runAnimationByState(AnimationStateEnum.normal);
      }) : this._event.on(HOOK_EVENT.AFTER_DO_RENDER, () => {
        this.runAnimationByState(AnimationStateEnum.normal);
      }));
    }
  }
  compileContext(extraContext) {
    const config2 = Object.assign(Object.assign({}, this._markConfig), {
      context: Object.assign({
        markId: this.id,
        modelId: this.model.id,
        markUserId: this._userId,
        modelUserId: this.model.userId
      }, extraContext)
    });
    this._product.configure(config2);
  }
  compileSignal() {
    this.state.compile();
  }
  _computeAttribute(key, state) {
    return (datum, opt) => {
    };
  }
  compileCommonAttributeCallback(key, state) {
    const attributeFunctor = this._computeAttribute(key, state), opt = {
      mark: null,
      parent: null,
      element: null
    };
    return (datum, element) => (opt.mark = element.mark, opt.parent = element.mark.group, opt.element = element, attributeFunctor(datum, opt));
  }
  compileTransform() {
    var _a;
    (null === (_a = this._transform) || void 0 === _a ? void 0 : _a.length) && this.getProduct().transform(this._transform);
  }
  _lookupGrammar(id) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getMarkById(id);
  }
  updateState(newState, noRender) {
    return this.state.updateState(newState, noRender);
  }
  updateLayoutState(noRender, recursion) {
    return recursion && this.getMarks().length > 0 && this.getMarks().forEach((m4) => m4.state.updateLayoutState(true)), this.state.updateLayoutState(noRender);
  }
  updateMarkState(key) {
    if (!this._product) return;
    const stateInfo = this.state.getStateInfo(key);
    this._product.elements.forEach((e) => {
      "in" === this.state.checkOneState(e, e.getDatum(), stateInfo) ? e.addState(key) : e.removeState(key);
    });
  }
  getMarks() {
    return [];
  }
  runAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.runAnimationByState(state);
  }
  stopAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.stopAnimationByState(state);
  }
  pauseAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.pauseAnimationByState(state);
  }
  resumeAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.resumeAnimationByState(state);
  }
  getProductElements() {
    const product = this.getProduct();
    if (product) return product.elements;
  }
  clear() {
    this._event.off(HOOK_EVENT.AFTER_DO_RENDER);
  }
  release() {
    super.release(), this.state.release();
  }
};

// node_modules/@visactor/vchart/esm/mark/base/base-mark.js
var __rest17 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseMark = class extends CompilableMark {
  constructor(name, option) {
    var _a;
    super(option, name, option.model), this._extensionChannel = {}, this._computeExChannel = {}, this._attributeContext = option.attributeContext, null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
  }
  created() {
    this._initStyle();
  }
  initStyleWithSpec(spec, key) {
    spec && (isValid_default(spec.id) && (this._userId = spec.id), isBoolean_default(spec.interactive) && (this._markConfig.interactive = spec.interactive), isValid_default(spec.zIndex) && (this._markConfig.zIndex = spec.zIndex), isBoolean_default(spec.visible) && this.setVisible(spec.visible), this._initSpecStyle(spec, this.stateStyle, key));
  }
  _transformStyleValue(styleConverter, transform30) {
    if (styleConverter.scale) {
      const scale4 = styleConverter.scale, range2 = scale4.range();
      return scale4.range(range2.map(transform30)), styleConverter;
    }
    return "function" == typeof styleConverter ? (...args) => transform30(styleConverter(...args)) : transform30(styleConverter);
  }
  convertAngleToRadian(styleConverter) {
    return this._transformStyleValue(styleConverter, degreeToRadian);
  }
  isUserLevel(level) {
    return [AttributeLevel.User_Mark, AttributeLevel.User_Series, AttributeLevel.User_Chart, AttributeLevel.User_SeriesStyle].includes(level);
  }
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style)) return;
    void 0 === stateStyle[state] && (stateStyle[state] = {});
    const isUserLevel = this.isUserLevel(level);
    Object.keys(style).forEach((attr) => {
      let attrStyle = style[attr];
      isNil_default(attrStyle) || (attrStyle = this._filterAttribute(attr, attrStyle, state, level, isUserLevel, stateStyle), this.setAttribute(attr, attrStyle, state, level, stateStyle));
    });
  }
  getStyle(key, state = "normal") {
    var _a;
    return null === (_a = this.stateStyle[state][key]) || void 0 === _a ? void 0 : _a.style;
  }
  _filterAttribute(attr, style, state, level, isUserLevel, stateStyle = this.stateStyle) {
    let newStyle = this._styleConvert(style);
    if (isUserLevel) switch (attr) {
      case "angle":
        newStyle = this.convertAngleToRadian(newStyle);
        break;
      case "innerPadding":
      case "outerPadding":
        newStyle = this._transformStyleValue(newStyle, (value) => -value);
        break;
      case "curveType":
        newStyle = this._transformStyleValue(newStyle, (value) => curveTypeTransform(value, this._option.model.direction));
    }
    return newStyle;
  }
  setReferer(mark, styleKey, state, stateStyle = this.stateStyle) {
    var _a;
    if (mark) if (styleKey && state) {
      const style = null !== (_a = stateStyle[state]) && void 0 !== _a ? _a : {
        [styleKey]: {}
      };
      stateStyle[state][styleKey] = Object.assign(Object.assign({}, style[styleKey]), {
        referer: mark
      });
    } else Object.entries(stateStyle).forEach(([state2, style]) => {
      Object.entries(style).forEach(([styleKey2, style2]) => {
        stateStyle[state2][styleKey2].referer = mark;
      });
    });
  }
  setPostProcess(key, postProcessFunc, state = "normal") {
    var _a;
    (null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key]) && (this.stateStyle[state][key].postProcess = postProcessFunc);
  }
  getAttribute(key, datum, state = "normal", opt) {
    return this._computeAttribute(key, state)(datum, opt);
  }
  setAttribute(attr, style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    var _a;
    void 0 === stateStyle[state] && (stateStyle[state] = {}), void 0 === stateStyle[state][attr] && (stateStyle[state][attr] = {
      level,
      style,
      referer: void 0
    });
    const attrLevel = null === (_a = stateStyle[state][attr]) || void 0 === _a ? void 0 : _a.level;
    isValid_default(attrLevel) && attrLevel <= level && mergeSpec(stateStyle[state][attr], {
      style,
      level
    }), "normal" !== state && attr in this._extensionChannel && this._extensionChannel[attr].forEach((key) => {
      void 0 === stateStyle[state][key] && (stateStyle[state][key] = stateStyle.normal[key]);
    });
  }
  _getDefaultStyle() {
    return {
      visible: true,
      x: 0,
      y: 0
    };
  }
  _styleConvert(style) {
    if (!style) return style;
    if (isValidScaleType(style.type) || style.scale) {
      const scale4 = createScaleWithSpec(style, {
        globalScale: this._option.globalScale,
        seriesId: this._option.seriesId
      });
      if (scale4) return {
        scale: scale4,
        field: style.field,
        changeDomain: style.changeDomain
      };
    }
    return style;
  }
  _computeAttribute(key, state) {
    var _a;
    let stateStyle = null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key];
    stateStyle || (stateStyle = this.stateStyle.normal[key]);
    const baseValueFunctor = this._computeStateAttribute(stateStyle, key, state), hasPostProcess = isFunction_default(null == stateStyle ? void 0 : stateStyle.postProcess), hasExCompute = key in this._computeExChannel;
    if (hasPostProcess && hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => {
        let baseValue = baseValueFunctor(datum, opt);
        return baseValue = stateStyle.postProcess(baseValue, datum, this._attributeContext, opt, this.getDataView()), exCompute(key, datum, state, opt, baseValue);
      };
    }
    if (hasPostProcess) return (datum, opt) => stateStyle.postProcess(baseValueFunctor(datum, opt), datum, this._attributeContext, opt, this.getDataView());
    if (hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => exCompute(key, datum, state, opt, baseValueFunctor(datum, opt));
    }
    return baseValueFunctor;
  }
  _computeStateAttribute(stateStyle, key, state) {
    var _a;
    return stateStyle ? stateStyle.referer ? stateStyle.referer._computeAttribute(key, state) : stateStyle.style ? "function" == typeof stateStyle.style ? (datum, opt) => stateStyle.style(datum, this._attributeContext, opt, this.getDataView()) : GradientType.includes(stateStyle.style.gradient) ? this._computeGradientAttr(stateStyle.style) : ["outerBorder", "innerBorder"].includes(key) ? this._computeBorderAttr(stateStyle.style) : isValidScaleType(null === (_a = stateStyle.style.scale) || void 0 === _a ? void 0 : _a.type) ? (datum, opt) => {
      let data = datum;
      return "series" === this.model.modelType && this.model.getMarkData && (data = this.model.getMarkData(datum)), stateStyle.style.scale.scale(data[stateStyle.style.field]);
    } : (datum, opt) => stateStyle.style : (datum, opt) => stateStyle.style : (datum, opt) => {
    };
  }
  _initStyle() {
    const defaultStyle = this._getDefaultStyle();
    this.setStyle(defaultStyle, "normal", 0);
  }
  _initSpecStyle(spec, stateStyle, key) {
    spec.style && this.setStyle(spec.style, "normal", AttributeLevel.User_Mark, stateStyle);
    const state = spec.state;
    state && Object.keys(state).forEach((key2) => {
      const stateTemp = state[key2];
      if ("style" in stateTemp) {
        const style = stateTemp.style;
        let stateInfo = {
          stateValue: key2
        };
        "level" in stateTemp && (stateInfo.level = stateTemp.level), "filter" in stateTemp && (stateInfo = isFunction_default(stateTemp.filter) ? Object.assign({
          filter: stateTemp.filter
        }, stateInfo) : Object.assign(Object.assign({}, stateTemp.filter), stateInfo)), this.state.addStateInfo(stateInfo), this.setStyle(style, key2, AttributeLevel.User_Mark, stateStyle);
      } else this.setStyle(stateTemp, key2, AttributeLevel.User_Mark, stateStyle);
    });
  }
  _computeGradientAttr(gradientStyle) {
    var _a, _b;
    const { gradient, scale: scale4, field: field5 } = gradientStyle, rest = __rest17(gradientStyle, ["gradient", "scale", "field"]);
    let colorScale = scale4, colorField = field5;
    if (!(scale4 && field5 || "series" !== this.model.modelType)) {
      const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
      scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField);
    }
    const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain()), mergedStyle = Object.assign(Object.assign({}, DEFAULT_GRADIENT_CONFIG[gradient]), rest);
    return (data, opt) => {
      const computeStyle = {}, markData = this.getDataView();
      return Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        "stops" === key ? computeStyle.stops = value.map((stop) => {
          const { opacity, color, offset } = stop;
          let computeColor = null != color ? color : null == colorScale ? void 0 : colorScale.scale(data[colorField]);
          return isFunction_default(color) && (computeColor = color(data, this._attributeContext, opt, markData)), isValid_default(opacity) && (computeColor = Color.SetOpacity(computeColor, opacity)), {
            offset: isFunction_default(offset) ? offset(data, this._attributeContext, opt, markData) : offset,
            color: computeColor || themeColor[0]
          };
        }) : isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, markData) : computeStyle[key] = value;
      }), computeStyle.gradient = gradient, computeStyle;
    };
  }
  _computeBorderAttr(borderStyle) {
    const { scale: scale4, field: field5 } = borderStyle, mergedStyle = __rest17(borderStyle, ["scale", "field"]);
    return (data, opt) => {
      var _a, _b, _c;
      const computeStyle = {};
      if (Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, this.getDataView()) : computeStyle[key] = value;
      }), "stroke" in computeStyle) GradientType.includes(null === (_c = mergedStyle.stroke) || void 0 === _c ? void 0 : _c.gradient) && (computeStyle.stroke = this._computeGradientAttr(mergedStyle.stroke)(data, opt));
      else {
        const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain());
        let colorScale = scale4, colorField = field5;
        if (!(scale4 && field5 || "series" !== this.model.modelType)) {
          const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
          scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField), computeStyle.stroke = (null == colorScale ? void 0 : colorScale.scale(data[colorField])) || themeColor[0];
        }
      }
      return computeStyle;
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/group.js
var GroupMark2 = class _GroupMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _GroupMark.type, this._marks = [];
  }
  getMarks() {
    return this._marks;
  }
  _getDefaultStyle() {
    return Object.assign({}, super._getDefaultStyle());
  }
  isMarkExist(mark) {
    return void 0 !== this._marks.find((m4) => m4.id === mark.id);
  }
  addMark(mark) {
    return this.isMarkExist(mark) ? (warn("Mark already exists, add mark failed."), false) : (this._marks.push(mark), true);
  }
  removeMark(mark) {
    const index = this._marks.findIndex((m4) => m4.id === mark.id || m4.name === mark.name);
    return -1 === index ? (warn("Mark does not exists, removeMark failed."), false) : (this._marks.splice(index, 1), true);
  }
  getMarkInType(type) {
    return this._marks.filter((m4) => m4.type === type);
  }
  getMarkInId(id) {
    return this._marks.find((m4) => m4.id === id);
  }
  getMarkInUserId(id) {
    let result2;
    if (this._marks.forEach((m4) => {
      m4.getUserId() === id && (result2 = m4);
    }), !result2) for (let i = 0; i < this._marks.length; i++) {
      const mark = this._marks[i];
      if ("group" === mark.type && (result2 = mark.getMarkInUserId(id)), result2) break;
    }
    return result2;
  }
  getMarkInName(name) {
    return this._marks.filter((m4) => m4.name === name);
  }
  _compileProduct(option) {
    super._compileProduct(option), this._product.configure({
      zIndex: this._markConfig.zIndex
    }), (null == option ? void 0 : option.ignoreChildren) || this.getMarks().forEach((mark) => {
      mark.getProduct() && mark.removeProduct(), mark.compile({
        group: this._product
      });
    });
  }
};
GroupMark2.type = "group";
var registerGroupMark = () => {
  registerGroupGraphic2(), Factory2.registerMark(GroupMark2.type, GroupMark2);
};

// node_modules/@visactor/vchart/esm/core/util.js
var VCHART_UTILS = {
  measureText
};

// node_modules/@visactor/vchart/esm/core/expression-function.js
var ExpressionFunction = class _ExpressionFunction {
  static instance() {
    return _ExpressionFunction.instance_ || (_ExpressionFunction.instance_ = new _ExpressionFunction()), _ExpressionFunction.instance_;
  }
  constructor() {
    this.functions = {};
  }
  registerFunction(name, fun) {
    name && fun && (this.functions[name] = fun);
  }
  unregisterFunction(name) {
    name && delete this.functions[name];
  }
  getFunction(name) {
    return this.functions[name] || null;
  }
  getFunctionNameList() {
    return Object.keys(this.functions);
  }
};

// node_modules/@visactor/vchart/esm/env/env.js
var registerAllEnv = () => {
  initAllEnv();
};
var registerBrowserEnv = () => {
  loadBrowserEnv(container);
};
var registerLarkEnv = () => {
  loadFeishuEnv(container);
};
var registerLynxEnv = () => {
  loadLynxEnv(container);
};
var registerNodeEnv = () => {
  loadNodeEnv(container);
};
var registerTaroEnv = () => {
  loadTaroEnv(container);
};
var registerWXEnv = () => {
  loadWxEnv(container);
};
var registerTTEnv = () => {
  loadTTEnv(container);
};
var registerHarmonyEnv = () => {
  loadHarmonyEnv(container);
};

// node_modules/@visactor/vchart/esm/plugin/base/base-plugin-service.js
var BasePluginService = class {
  constructor() {
    this.id = createID(), this._plugins = [];
  }
  add(plugins) {
    if (!plugins || 0 === plugins.length) return null;
    const unloadedPlugins = [];
    return plugins.forEach((plugin) => {
      this._plugins.find((p) => p.id === plugin.id) ? warn("不要重复添加相同的plugin") : (this._plugins.push(plugin), unloadedPlugins.push(plugin), plugin.onAdd && plugin.onAdd(this));
    }), unloadedPlugins;
  }
  load(plugins) {
    const unloadedPlugins = this.add(plugins);
    unloadedPlugins && unloadedPlugins.length && this.activate(plugins);
  }
  activate(plugins) {
    plugins.length && plugins.forEach((plugin) => {
      plugin.init && plugin.init();
    });
  }
  get(id) {
    return this._plugins.find((p) => p.id === id);
  }
  getAll() {
    return this._plugins.slice();
  }
  release(pluginsId) {
    const plugin = this.get(pluginsId);
    plugin && (plugin.release(this), this._plugins = this._plugins.filter((entry) => entry !== plugin));
  }
  releaseAll() {
    this._plugins.forEach((plugin) => {
      plugin.release(this);
    }), this._plugins = [];
  }
  clear(pluginsId) {
    const plugin = this.get(pluginsId);
    plugin && plugin.clear(this);
  }
  clearAll() {
    this._plugins.forEach((plugin) => {
      var _a;
      null === (_a = plugin.clear) || void 0 === _a || _a.call(plugin, this);
    });
  }
};

// node_modules/@visactor/vchart/esm/plugin/chart/plugin-service.js
var ChartPluginService = class extends BasePluginService {
  constructor(globalInstance) {
    super(), this.globalInstance = globalInstance;
  }
  onInit(chartSpec) {
    this._plugins.forEach((plugin) => {
      plugin.onInit && plugin.onInit(this, chartSpec);
    });
  }
  onBeforeResize(width, height) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeResize && plugin.onBeforeResize(this, width, height);
    });
  }
  onAfterChartSpecTransform(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onAfterChartSpecTransform && plugin.onAfterChartSpecTransform(this, chartSpec, actionSource);
    });
  }
  onAfterModelSpecTransform(chartSpec, chartSpecInfo, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onAfterModelSpecTransform && plugin.onAfterModelSpecTransform(this, chartSpec, chartSpecInfo, actionSource);
    });
  }
  onBeforeInitChart(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeInitChart && plugin.onBeforeInitChart(this, chartSpec, actionSource);
    });
  }
  releaseAll() {
    super.releaseAll(), this.globalInstance = null;
  }
};

// node_modules/@visactor/vchart/esm/series/pictogram/svg-source.js
var svgSourceMap = /* @__PURE__ */ new Map();
var svgDataSet;
function initSVGDataSet() {
  svgDataSet || (svgDataSet = new DataSet(), registerDataSetInstanceParser(svgDataSet, "svg", svgParser));
}
function registerSVGSource(key, source) {
  svgSourceMap.has(key) && warn(`svg source key of '${key}' already exists, will be overwritten.`), initSVGDataSet();
  const dataView = new DataView(svgDataSet);
  dataView.parse(source, {
    type: "svg"
  }), svgSourceMap.set(key, dataView);
}
function unregisterSVGSource(key) {
  svgSourceMap.has(key) ? svgSourceMap.delete(key) : warn(`map type of '${key}' does not exists.`);
}
function getSVGSource(type) {
  return svgSourceMap.get(type);
}

// node_modules/@visactor/vchart/esm/core/vchart.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest18 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var VChart = class _VChart {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      "function" == typeof fn ? fn() : console.error("Invalid function:", fn);
    });
  }
  static useChart(charts) {
    charts.forEach((c3) => Factory2.registerChart(c3.type, c3));
  }
  static useSeries(series2) {
    series2.forEach((s2) => Factory2.registerSeries(s2.type, s2));
  }
  static useComponent(components) {
    components.forEach((c3) => Factory2.registerComponent(c3.type, c3));
  }
  static useMark(marks) {
    marks.forEach((m4) => {
      var _a;
      return Factory2.registerMark(null !== (_a = m4.constructorType) && void 0 !== _a ? _a : m4.type, m4);
    });
  }
  static useLayout(layouts) {
    layouts.forEach((l) => Factory2.registerLayout(l.type, l));
  }
  static registerDataSetTransform(name, transform30) {
    Factory2.registerTransform(name, transform30);
  }
  static registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  static unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  static getFunction(key) {
    return key ? ExpressionFunction.instance().getFunction(key) : null;
  }
  static getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  static registerMap(key, source, option) {
    const impl = Factory2.getImplementInKey("registerMap");
    impl && impl(key, source, option);
  }
  static unregisterMap(key) {
    const impl = Factory2.getImplementInKey("unregisterMap");
    impl && impl(key);
  }
  static getMap(key) {
    return getMapSource(key);
  }
  static registerSVG(key, source, option) {
    const impl = Factory2.getImplementInKey("registerSVG");
    impl && impl(key, source, option);
  }
  static unregisterSVG(key) {
    const impl = Factory2.getImplementInKey("unregisterSVG");
    impl && impl(key);
  }
  static getSVG(key) {
    return getSVGSource(key);
  }
  static hideTooltip(excludeId = []) {
    InstanceManager.forEach((instance) => {
      var _a;
      return null === (_a = null == instance ? void 0 : instance.hideTooltip) || void 0 === _a ? void 0 : _a.call(instance);
    }, excludeId);
  }
  static getLogger() {
    return Logger.getInstance();
  }
  getSpec() {
    return this._spec;
  }
  getSpecInfo() {
    return this._specInfo;
  }
  getDataSet() {
    return this._dataSet;
  }
  constructor(spec, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.id = createID(), this._userEvents = [], this._autoSize = true, this._option = {
      mode: RenderModeEnum["desktop-browser"],
      onError: (msg) => {
        throw new Error(msg);
      },
      optimize: {
        disableCheckGraphicWidthOutRange: true
      }
    }, this._observer = null, this._context = {}, this._doResize = () => {
      const { width, height } = this.getCurrentSize();
      this._currentSize.width === width && this._currentSize.height === height || (this._currentSize = {
        width,
        height
      }, this.resizeSync(width, height));
    }, this._renderSync = (option = {}) => {
      var _a2;
      const self = this;
      return this._beforeRender(option) ? (null === (_a2 = this._compiler) || void 0 === _a2 || _a2.render(option.morphConfig), this._afterRender(), self) : self;
    }, this._updateSpec = (spec2, forceMerge = false, userUpdateOptions) => {
      var _a2, _b2;
      const lastSpec = this._spec, result2 = {
        changeBackground: false,
        reTransformSpec: false,
        change: false,
        reMake: false,
        reCompile: false,
        reSize: false,
        changeTheme: false
      };
      if (!this._setNewSpec(spec2, forceMerge)) return;
      isEqual(lastSpec.theme, this._spec.theme) ? isEqual(this._spec.background, lastSpec.background) || (result2.reMake = true, result2.changeBackground = true) : result2.changeTheme = true;
      const reSize = this._shouldChartResize(lastSpec);
      if (result2.reSize = reSize, this._spec.type !== lastSpec.type) return null === (_b2 = null === (_a2 = this._compiler) || void 0 === _a2 ? void 0 : _a2.getVGrammarView()) || void 0 === _b2 || _b2.updateLayoutTag(), result2.reMake = true, result2.reTransformSpec = true, result2.change = true, result2.changeTheme = true, result2;
      this._initChartSpec(this._spec, "updateSpec");
      const res = mergeUpdateResult(this._chart.updateSpec(this._spec), result2);
      return userUpdateOptions ? Object.assign(Object.assign({}, res), userUpdateOptions) : res;
    }, this._option = Object.assign(Object.assign(Object.assign({}, this._option), {
      animation: false !== spec.animation
    }), options), (null == options ? void 0 : options.optimize) && (this._option.optimize = Object.assign(Object.assign({}, this._option.optimize), options.optimize)), this._onError = null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError;
    const _j = this._option, { dom, renderCanvas, mode, stage, poptip: poptip2 } = _j, restOptions = __rest18(_j, ["dom", "renderCanvas", "mode", "stage", "poptip"]), isTrueBrowseEnv = isTrueBrowser(mode);
    if (isTrueBrowseEnv ? registerBrowserEnv() : "node" === mode && registerNodeEnv(), isTrueBrowseEnv && dom && (this._container = isString_default(dom) ? vglobal.getElementById(dom) : dom), renderCanvas && (this._canvas = renderCanvas), stage && (this._stage = stage), "node" !== mode && !this._container && !this._canvas && !this._stage) return void (null === (_b = this._option) || void 0 === _b || _b.onError("please specify container or renderCanvas!"));
    this._viewBox = this._option.viewBox, this._currentThemeName = ThemeManager.getCurrentThemeName(), this._setNewSpec(spec), this._updateCurrentTheme(), this._currentSize = this.getCurrentSize();
    const pluginList = [];
    false != !poptip2 && pluginList.push("poptipForText"), "sankey" === spec.type && pluginList.push("scrollbar");
    const performanceHook = Object.assign({}, restOptions.performanceHook || {});
    Object.keys(performanceHook).forEach((hookKey) => {
      restOptions.performanceHook[hookKey] = (...args) => {
        performanceHook[hookKey](...args, this);
      };
    }), this._compiler = new Compiler({
      dom: null !== (_c = this._container) && void 0 !== _c ? _c : "none",
      canvas: renderCanvas
    }, Object.assign(Object.assign({
      mode: this._option.mode,
      stage,
      pluginList
    }, restOptions), {
      background: this._getBackground(),
      onError: this._onError
    })), this._compiler.setSize(this._currentSize.width, this._currentSize.height), this._eventDispatcher = new EventDispatcher(this, this._compiler), this._event = new Event2(this._eventDispatcher, mode), this._compiler.initView(), this._setFontFamilyTheme(null === (_d = this._currentTheme) || void 0 === _d ? void 0 : _d.fontFamily), this._initDataSet(this._option.dataSet), this._autoSize = !!isTrueBrowseEnv && (null === (_f = null !== (_e = spec.autoFit) && void 0 !== _e ? _e : this._option.autoFit) || void 0 === _f || _f), this._bindResizeEvent(), this._bindVGrammarViewEvent(), this._initChartPlugin(), InstanceManager.registerInstance(this), null === (_h = null === (_g = this._option.performanceHook) || void 0 === _g ? void 0 : _g.afterCreateVChart) || void 0 === _h || _h.call(_g, this);
  }
  _setNewSpec(spec, forceMerge) {
    return !!spec && (isString_default(spec) && (spec = JSON.parse(spec)), forceMerge && this._originalSpec && (spec = mergeSpec({}, this._originalSpec, spec)), this._originalSpec = spec, this._spec = this._getSpecFromOriginalSpec(), true);
  }
  _getSpecFromOriginalSpec() {
    var _a;
    const spec = specTransform(this._originalSpec);
    return spec.data = null !== (_a = spec.data) && void 0 !== _a ? _a : [], spec;
  }
  _initChartSpec(spec, actionSource) {
    var _a, _b;
    _VChart.getFunctionList() && _VChart.getFunctionList().length && (spec = functionTransform(spec, _VChart)), this._spec = spec, this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, this._getChartOption(this._spec.type))), null === (_a = this._chartSpecTransformer) || void 0 === _a || _a.transformSpec(this._spec), this._chartPluginApply("onAfterChartSpecTransform", this._spec, actionSource), this._specInfo = null === (_b = this._chartSpecTransformer) || void 0 === _b ? void 0 : _b.transformModelSpec(this._spec), this._chartPluginApply("onAfterModelSpecTransform", this._spec, this._specInfo, actionSource);
  }
  _updateSpecInfo() {
    var _a;
    this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, this._getChartOption(this._spec.type))), this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.createSpecInfo(this._spec);
  }
  _initChart(spec) {
    var _a, _b, _c;
    if (!this._compiler) return void (null === (_a = this._option) || void 0 === _a || _a.onError("compiler is not initialized"));
    if (this._chart) return void (null === (_b = this._option) || void 0 === _b || _b.onError("chart is already initialized"));
    const chart = Factory2.createChart(spec.type, spec, this._getChartOption(spec.type));
    chart ? (this._chart = chart, this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height), this._chart.created(this._chartSpecTransformer), this._chart.init(), this._event.emit(ChartEvent.initialized, {
      chart,
      vchart: this
    })) : null === (_c = this._option) || void 0 === _c || _c.onError("init chart fail");
  }
  _releaseData() {
    this._dataSet && (this._dataSet.dataViewMap = {}, this._dataSet = null);
  }
  _bindVGrammarViewEvent() {
    if (!this._compiler) return;
    const view = this._compiler.getVGrammarView();
    view.addEventListener(HOOK_EVENT.ALL_ANIMATION_END, () => {
      this._event.emit(ChartEvent.animationFinished, {
        chart: this._chart,
        vchart: this
      });
    }), view.addEventListener(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER, () => {
      this._event.emit(ChartEvent.renderFinished, {
        chart: this._chart,
        vchart: this
      });
    });
  }
  _bindResizeEvent() {
    var _a, _b;
    if (this._autoSize) {
      if (this._onResize = throttle_default(this._doResize, null !== (_a = this._option.resizeDelay) && void 0 !== _a ? _a : 100), this._container) {
        const ResizeObserverWindow = window.ResizeObserver;
        ResizeObserverWindow && (this._observer = new ResizeObserverWindow(this._onResize), null === (_b = this._observer) || void 0 === _b || _b.observe(this._container));
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this._autoSize && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  getCurrentSize() {
    var _a, _b, _c, _d;
    return calculateChartSize(this._spec, {
      container: this._container,
      canvas: this._canvas,
      mode: this._getMode(),
      modeParams: this._option.modeParams
    }, {
      width: null !== (_b = null === (_a = this._currentSize) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : DEFAULT_CHART_WIDTH,
      height: null !== (_d = null === (_c = this._currentSize) || void 0 === _c ? void 0 : _c.height) && void 0 !== _d ? _d : DEFAULT_CHART_HEIGHT
    });
  }
  _initDataSet(dataSet) {
    this._dataSet = dataSet instanceof DataSet ? dataSet : new DataSet(), registerDataSetInstanceParser(this._dataSet, "dataview", dataViewParser), registerDataSetInstanceParser(this._dataSet, "array", arrayParser), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView);
    for (const key in Factory2.transforms) registerDataSetInstanceTransform(this._dataSet, key, Factory2.transforms[key]);
    for (const key in Factory2.dataParser) registerDataSetInstanceParser(this._dataSet, key, Factory2.dataParser[key]);
  }
  updateCustomConfigAndRerender(updateSpecResult, sync, option = {}) {
    if (!this._isReleased && updateSpecResult) return isFunction_default(updateSpecResult) && (updateSpecResult = updateSpecResult()), updateSpecResult.reAnimate && (this.stopAnimation(), this._updateAnimateState(true)), this._reCompile(updateSpecResult), sync ? this._renderSync(option) : this._renderAsync(option);
  }
  _updateCustomConfigAndRecompile(updateSpecResult, option = {}) {
    return !!updateSpecResult && (this._reCompile(updateSpecResult), this._beforeRender(option));
  }
  _reCompile(updateResult, morphConfig) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (updateResult.reMake && (this._releaseData(), this._initDataSet(), null === (_a = this._chart) || void 0 === _a || _a.release(), this._chart = null), updateResult.reTransformSpec && (this._chartSpecTransformer = null), updateResult.changeTheme ? (this._setCurrentTheme(), this._setFontFamilyTheme(null === (_b = this._currentTheme) || void 0 === _b ? void 0 : _b.fontFamily)) : updateResult.changeBackground && (null === (_c = this._compiler) || void 0 === _c || _c.setBackground(this._getBackground())), updateResult.reMake) null === (_d = this._compiler) || void 0 === _d || _d.releaseGrammar(false === (null === (_e = this._option) || void 0 === _e ? void 0 : _e.animation) || false === (null === (_f = this._spec) || void 0 === _f ? void 0 : _f.animation)), this._userEvents.forEach((e) => {
      var _a2;
      return null === (_a2 = this._event) || void 0 === _a2 ? void 0 : _a2.on(e.eType, e.query, e.handler);
    }), updateResult.reSize && this._doResize();
    else if (updateResult.reCompile && (null === (_g = this._compiler) || void 0 === _g || _g.clear({
      chart: this._chart,
      vChart: this
    }, false === (null === (_h = this._option) || void 0 === _h ? void 0 : _h.animation) || false === (null === (_j = this._spec) || void 0 === _j ? void 0 : _j.animation)), null === (_k = this._compiler) || void 0 === _k || _k.compile({
      chart: this._chart,
      vChart: this
    }, {})), updateResult.reSize) {
      const { width, height } = this.getCurrentSize();
      this._chart.onResize(width, height, false), this._compiler.resize(width, height, false);
    }
  }
  _beforeRender(option = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._isReleased) return false;
    if (this._chart) return true;
    const { transformSpec, actionSource } = option;
    return transformSpec && this._initChartSpec(this._spec, "render"), this._chartPluginApply("onBeforeInitChart", this._spec, actionSource), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeInitializeChart) || void 0 === _b || _b.call(_a, this), this._initChart(this._spec), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterInitializeChart) || void 0 === _d || _d.call(_c, this), !(!this._chart || !this._compiler) && (null === (_f = null === (_e = this._option.performanceHook) || void 0 === _e ? void 0 : _e.beforeCompileToVGrammar) || void 0 === _f || _f.call(_e), this._compiler.compile({
      chart: this._chart,
      vChart: this
    }, {
      performanceHook: this._option.performanceHook
    }), null === (_h = null === (_g = this._option.performanceHook) || void 0 === _g ? void 0 : _g.afterCompileToVGrammar) || void 0 === _h || _h.call(_g), true);
  }
  _afterRender() {
    return !this._isReleased && (this._updateAnimateState(), this._event.emit(ChartEvent.rendered, {
      chart: this._chart,
      vchart: this
    }), true);
  }
  renderSync(morphConfig) {
    return this._renderSync({
      morphConfig,
      transformSpec: true,
      actionSource: "render"
    });
  }
  renderAsync(morphConfig) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this._renderAsync({
        morphConfig,
        transformSpec: true,
        actionSource: "render"
      });
    });
  }
  _renderAsync(option = {}) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this._renderSync(option);
    });
  }
  _updateAnimateState(initial) {
    var _a, _b;
    if (this._option.animation) {
      const animationState = initial ? AnimationStateEnum.appear : AnimationStateEnum.update;
      null === (_a = this._chart) || void 0 === _a || _a.getAllRegions().forEach((region) => {
        var _a2;
        null === (_a2 = region.animate) || void 0 === _a2 || _a2.updateAnimateState(animationState, true);
      }), null === (_b = this._chart) || void 0 === _b || _b.getAllComponents().forEach((component2) => {
        var _a2;
        null === (_a2 = component2.animate) || void 0 === _a2 || _a2.updateAnimateState(animationState, true);
      });
    }
  }
  release() {
    var _a, _b, _c, _d;
    (null === (_a = this._onResize) || void 0 === _a ? void 0 : _a.cancel) && this._onResize.cancel(), this._chartPluginApply("releaseAll"), this._chartPlugin = null, this._chartSpecTransformer = null, null === (_b = this._chart) || void 0 === _b || _b.release(), null === (_c = this._eventDispatcher) || void 0 === _c || _c.release(), null === (_d = this._compiler) || void 0 === _d || _d.release(), this._unBindResizeEvent(), this._releaseData(), this._onError = null, this._onResize = null, this._container = null, this._currentTheme = null, this._option = null, this._chart = null, this._compiler = null, this._spec = null, this._specInfo = null, this._originalSpec = null, this._userEvents = null, this._event = null, this._eventDispatcher = null, this._isReleased = true, InstanceManager.unregisterInstance(this);
  }
  updateData(id, data, parserOptions, userUpdateOptions) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.updateDataSync(id, data, parserOptions, userUpdateOptions);
    });
  }
  _updateDataById(id, data, parserOptions) {
    const preDV = this._spec.data.find((dv) => dv.name === id || dv.id === id);
    preDV ? preDV.id === id ? preDV.values = data : preDV.name === id && preDV.parse(data, parserOptions) : isArray_default(data) ? this._spec.data.push({
      id,
      values: data
    }) : this._spec.data.push(data);
  }
  updateDataInBatches(list) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this._chart ? (this._chart.updateFullData(list.map(({ id, data, options }) => ({
        id,
        values: data,
        parser: options
      }))), this._chart.updateGlobalScaleDomain(), this._compiler.render(), this) : (this._spec.data = array(this._spec.data), list.forEach(({ id, data, options }) => {
        this._updateDataById(id, data, options);
      }), this);
    });
  }
  updateDataSync(id, data, parserOptions, userUpdateOptions) {
    return isNil_default(this._dataSet) ? this : this._chart ? ((null == userUpdateOptions ? void 0 : userUpdateOptions.reAnimate) && (this.stopAnimation(), this._updateAnimateState(true)), this._chart.updateData(id, data, true, parserOptions), this._compiler.render(), this) : (this._spec.data = array(this._spec.data), this._updateDataById(id, data, parserOptions), this);
  }
  updateFullDataSync(data, reRender = true, userUpdateOptions) {
    if (this._chart) return (null == userUpdateOptions ? void 0 : userUpdateOptions.reAnimate) && (this.stopAnimation(), this._updateAnimateState(true)), this._chart.updateFullData(data), reRender && this._compiler.render(), this;
    const prevData = array(this._spec.data);
    return array(data).forEach((d) => {
      const { id, values, parser, fields: fields2 } = d, preDV = prevData.find((dv) => dv.name === id);
      if (preDV) preDV instanceof DataView ? (preDV.setFields(cloneDeep(fields2)), preDV.parse(values, cloneDeep(parser))) : (preDV.values = values, isValid_default(parser) && (preDV.parser = parser), isValid_default(fields2) && (preDV.fields = fields2));
      else {
        const dataView = dataToDataView(d, this._dataSet, prevData);
        isArray_default(this._spec.data) && this._spec.data.push(dataView);
      }
    }), this;
  }
  updateFullData(data, reRender = true) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.updateFullDataSync(data, reRender);
    });
  }
  updateSpec(spec, forceMerge = false, morphConfig, userUpdateOptions) {
    return __awaiter12(this, void 0, void 0, function* () {
      const result2 = this._updateSpec(spec, forceMerge, userUpdateOptions);
      return result2 ? (yield this.updateCustomConfigAndRerender(result2, false, {
        morphConfig,
        transformSpec: result2.reTransformSpec,
        actionSource: "updateSpec"
      }), this) : this;
    });
  }
  updateSpecSync(spec, forceMerge = false, morphConfig, userUpdateOptions) {
    const result2 = this._updateSpec(spec, forceMerge, userUpdateOptions);
    return result2 ? (this.updateCustomConfigAndRerender(result2, true, {
      morphConfig,
      transformSpec: result2.reTransformSpec,
      actionSource: "updateSpec"
    }), this) : this;
  }
  updateSpecAndRecompile(spec, forceMerge = false, option = {}) {
    const result2 = this._updateSpec(spec, forceMerge);
    return this._updateCustomConfigAndRecompile(result2, Object.assign({
      actionSource: "updateSpecAndRecompile"
    }, option));
  }
  updateModelSpec(filter2, spec, forceMerge = false, morphConfig) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.updateModelSpecSync(filter2, spec, forceMerge, morphConfig);
    });
  }
  updateModelSpecSync(filter2, spec, forceMerge = false, morphConfig) {
    if (!spec || !this._spec) return this;
    if (isString_default(spec) && (spec = JSON.parse(spec)), isFunction_default(filter2) || mergeSpecWithFilter(this._spec, filter2, spec, forceMerge), this._chart) {
      const model = this._chart.getModelInFilter(filter2);
      if (model) return this._updateModelSpec(model, spec, true, forceMerge, morphConfig);
    }
    return this;
  }
  _updateModelSpec(model, spec, sync = false, forceMerge = false, morphConfig) {
    forceMerge && (spec = mergeSpec({}, model.getSpec(), spec));
    const result2 = model.updateSpec(spec);
    return model.reInit(spec), (result2.change || result2.reCompile || result2.reMake || result2.reSize || result2.reRender) && this._chart.reDataFlow(), this.updateCustomConfigAndRerender(result2, sync, {
      morphConfig,
      transformSpec: false,
      actionSource: "updateModelSpec"
    });
  }
  resize(width, height) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.resizeSync(width, height);
    });
  }
  resizeSync(width, height) {
    var _a, _b;
    return this._beforeResize(width, height) ? (null === (_b = (_a = this._compiler).resize) || void 0 === _b || _b.call(_a, width, height), this._afterResize()) : this;
  }
  _beforeResize(width, height) {
    var _a, _b, _c, _d;
    if (!this._chart || !this._compiler) return false;
    const chartCanvasRect = this._chart.getCanvasRect();
    return (!chartCanvasRect || chartCanvasRect.width !== width || chartCanvasRect.height !== height) && (this._chartPluginApply("onBeforeResize", width, height), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeResizeWithUpdate) || void 0 === _b || _b.call(_a), this._chart.onResize(width, height, false), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterResizeWithUpdate) || void 0 === _d || _d.call(_c), true);
  }
  _afterResize() {
    return this._isReleased || this._event.emit(ChartEvent.afterResize, {
      chart: this._chart
    }), this;
  }
  updateViewBox(viewBox, reRender = true, reLayout = true) {
    return this._chart && this._compiler ? (this._viewBox = viewBox, this._chart.updateViewBox(viewBox, reLayout), reLayout && (this._compiler.render(), this._chart.onEvaluateEnd()), this._compiler.updateViewBox(viewBox, reRender), this) : this;
  }
  on(eType, query, handler) {
    var _a;
    this._userEvents && (this._userEvents.push({
      eType,
      query: "function" == typeof query ? null : query,
      handler: "function" == typeof query ? query : handler
    }), null === (_a = this._event) || void 0 === _a || _a.on(eType, query, handler));
  }
  off(eType, handler) {
    var _a;
    if (this._userEvents && 0 !== this._userEvents.length) if (handler) {
      const index = this._userEvents.findIndex((e) => e.eType === eType && e.handler === handler);
      index >= 0 && (this._userEvents.splice(index, 1), null === (_a = this._event) || void 0 === _a || _a.off(eType, handler));
    } else this._userEvents.forEach((e) => {
      var _a2;
      e.eType === eType && (null === (_a2 = this._event) || void 0 === _a2 || _a2.off(eType, e.handler));
    }), this._userEvents = this._userEvents.filter((e) => e.eType !== eType);
  }
  updateState(state, filter2) {
    this._chart && this._chart.updateState(state, filter2);
  }
  setSelected(datum, filter2, region) {
    this._chart && this._chart.setSelected(datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._chart && this._chart.setHovered(datum, filter2, region);
  }
  clearState(state) {
    this._chart && this._chart.clearState(state);
  }
  clearAllStates() {
    this._chart && this._chart.clearAllStates();
  }
  clearSelected() {
    this._chart && this._chart.clearSelected();
  }
  clearHovered() {
    this._chart && this._chart.clearHovered();
  }
  _updateCurrentTheme(nextThemeName) {
    var _a, _b, _c;
    const optionTheme = this._option.theme, specTheme = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.theme, chartType = null === (_b = this._spec) || void 0 === _b ? void 0 : _b.type;
    nextThemeName && (this._currentThemeName = nextThemeName);
    const processThemeByChartType = (type, theme2) => {
      var _a2;
      return (null === (_a2 = theme2.chart) || void 0 === _a2 ? void 0 : _a2[type]) && (theme2 = mergeTheme({}, theme2, theme2.chart[type])), theme2;
    };
    let currentTheme;
    if (isEmpty_default(optionTheme) && isEmpty_default(specTheme)) currentTheme = getThemeObject(this._currentThemeName, true), this._currentTheme = processThemeByChartType(chartType, currentTheme);
    else if (isString_default(optionTheme) && (!specTheme || isString_default(specTheme)) || isString_default(specTheme) && (!optionTheme || isString_default(optionTheme))) {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName, true), getThemeObject(optionTheme, true), getThemeObject(specTheme, true));
      this._currentTheme = processThemeByChartType(chartType, finalTheme);
    } else {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName), getThemeObject(optionTheme), getThemeObject(specTheme));
      this._currentTheme = preprocessTheme(processThemeByChartType(chartType, finalTheme));
    }
    setPoptipTheme(get_default(this._currentTheme, "component.poptip")), null === (_c = this._compiler) || void 0 === _c || _c.setBackground(this._getBackground());
  }
  _shouldChartResize(oldSpec) {
    var _a, _b;
    let resize = false;
    isNil_default(this._spec.width) ? !isNil_default(oldSpec.width) && (this._spec.width = oldSpec.width) : this._spec.width !== oldSpec.width && (resize = true), isNil_default(this._spec.height) ? !isNil_default(oldSpec.height) && (this._spec.height = oldSpec.height) : this._spec.height !== oldSpec.height && (resize = true);
    const lasAutoSize = this._autoSize;
    return this._autoSize = !!isTrueBrowser(this._option.mode) && (null === (_b = null !== (_a = this._spec.autoFit) && void 0 !== _a ? _a : this._option.autoFit) || void 0 === _b || _b), this._autoSize !== lasAutoSize && (resize = true), resize;
  }
  _getBackground() {
    return ("string" == typeof this._spec.background || isObject_default(this._spec.background) && this._spec.background.gradient ? this._spec.background : null) || this._currentTheme.background || this._option.background;
  }
  getCurrentTheme() {
    return getThemeObject(this._currentThemeName);
  }
  getCurrentThemeName() {
    return this._currentThemeName;
  }
  setCurrentTheme(name) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.setCurrentThemeSync(name);
    });
  }
  setCurrentThemeSync(name) {
    var _a;
    if (!ThemeManager.themeExist(name)) return this;
    const result2 = this._setCurrentTheme(name);
    return this._setFontFamilyTheme(null === (_a = this._currentTheme) || void 0 === _a ? void 0 : _a.fontFamily), this.updateCustomConfigAndRerender(result2, true, {
      transformSpec: false,
      actionSource: "setCurrentTheme"
    }), this;
  }
  _setCurrentTheme(name) {
    var _a;
    return this._updateCurrentTheme(name), this._initChartSpec(this._getSpecFromOriginalSpec(), "setCurrentTheme"), null === (_a = this._chart) || void 0 === _a || _a.setCurrentTheme(), {
      change: true,
      reMake: false
    };
  }
  _setFontFamilyTheme(fontFamily) {
    var _a;
    fontFamily && (null === (_a = this.getStage()) || void 0 === _a || _a.setTheme({
      text: {
        fontFamily
      },
      richtext: {
        fontFamily
      }
    }));
  }
  _getTooltipComponent() {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.tooltip)[0];
  }
  setTooltipHandler(tooltipHandler) {
    var _a, _b;
    this._context.tooltipHandler = tooltipHandler;
    const tooltip3 = this._getTooltipComponent();
    tooltip3 && (null === (_b = null === (_a = tooltip3.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), tooltip3.tooltipHandler = tooltipHandler);
  }
  getTooltipHandlerByUser() {
    var _a;
    return null === (_a = this._context) || void 0 === _a ? void 0 : _a.tooltipHandler;
  }
  getTooltipHandler() {
    const tooltip3 = this._getTooltipComponent();
    return tooltip3 ? tooltip3.tooltipHandler : this._context.tooltipHandler;
  }
  showTooltip(datum, options) {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = isValid_default(datum) && "none" !== (null == tooltip3 ? void 0 : tooltip3.showTooltip(datum, options))) && void 0 !== _a && _a;
  }
  hideTooltip() {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = null == tooltip3 ? void 0 : tooltip3.hideTooltip()) && void 0 !== _a && _a;
  }
  getLegendDataById(id) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
    return legendComponent ? legendComponent.getLegendData() : [];
  }
  getLegendDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    return legends && legends[index] ? legends[index].getLegendData() : [];
  }
  getLegendSelectedDataById(id) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
    return legendComponent ? legendComponent.getSelectedData() : [];
  }
  getLegendSelectedDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    return legends && legends[index] ? legends[index].getSelectedData() : [];
  }
  setLegendSelectedDataById(id, selectedData) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
    legendComponent && legendComponent.setSelectedData(selectedData);
  }
  setLegendSelectedDataByIndex(index = 0, selectedData) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    legends && legends[index] && legends[index].setSelectedData(selectedData);
  }
  getDataURL() {
    var _a;
    return __awaiter12(this, void 0, void 0, function* () {
      const stage = this.getStage();
      if (this._chart && stage) {
        stage.render();
        const canvas = this._chart.getCanvas();
        return yield getCanvasDataURL(canvas, {
          onError: this._onError
        });
      }
      return null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined")), null;
    });
  }
  exportImg(name) {
    var _a, _b;
    return __awaiter12(this, void 0, void 0, function* () {
      if (!isTrueBrowser(this._option.mode)) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("non-browser environment can not export img")));
      const dataURL = yield this.getDataURL();
      dataURL ? URLToImage(name, dataURL) : null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined"));
    });
  }
  exportCanvas() {
    var _a;
    const stage = this.getStage();
    if (this._chart && stage) return stage.toCanvas();
    null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined"));
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._option.mode) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("getImageBuffer() now only support node environment.")));
    const stage = this.getStage();
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined")), null;
  }
  setLayout(layout2) {
    var _a;
    this._option.layout = layout2, null === (_a = this._chart) || void 0 === _a || _a.setLayout(layout2);
  }
  reLayout() {
    var _a;
    null === (_a = this._chart) || void 0 === _a || _a.setLayoutTag(true);
  }
  getCompiler() {
    return this._compiler;
  }
  getChart() {
    return this._chart;
  }
  getStage() {
    return this._compiler.getStage();
  }
  getCanvas() {
    var _a;
    return null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getCanvas();
  }
  getContainer() {
    var _a;
    if (isValid_default(this._container)) return this._container;
    let canvasNode;
    return canvasNode = isString_default(this._canvas) ? vglobal.getElementById(this._canvas) : this._canvas, isValid_default(canvasNode) ? canvasNode.parentElement : null === (_a = this.getCanvas()) || void 0 === _a ? void 0 : _a.parentElement;
  }
  getComponents() {
    return this._chart.getAllComponents();
  }
  getScale(scaleId) {
    var _a;
    const globalScale = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getGlobalScale();
    return null == globalScale ? void 0 : globalScale.getScale(scaleId);
  }
  setDimensionIndex(value, opt = {}) {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.setDimensionIndex(value, opt);
  }
  stopAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.stop();
  }
  pauseAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.pause();
  }
  resumeAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.resume();
  }
  convertDatumToPosition(datum, dataLinkInfo = {}, isRelativeToCanvas = false, checkInViewData) {
    var _a;
    if (!this._chart) return null;
    if (isEmpty_default(datum)) return null;
    const { seriesId, seriesIndex = 0 } = dataLinkInfo;
    let series2;
    if (isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_a = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _a ? void 0 : _a[0]), series2) {
      const keys = Object.keys(datum), handledDatum = series2.getViewData().latestData.find((viewDatum) => keys.every((k2) => viewDatum[k2] == datum[k2])), seriesLayoutStartPoint = series2.getRegion().getLayoutStartPoint();
      let point6;
      return point6 = handledDatum ? series2.dataToPosition(handledDatum, checkInViewData) : series2.dataToPosition(datum, checkInViewData), point6 ? convertPoint(point6, seriesLayoutStartPoint, isRelativeToCanvas) : null;
    }
    return null;
  }
  convertValueToPosition(value, dataLinkInfo, isRelativeToCanvas = false) {
    var _a, _b;
    if (!this._chart || isNil_default(value) || isEmpty_default(dataLinkInfo)) return null;
    if (!isArray_default(value)) {
      const { axisId, axisIndex } = dataLinkInfo;
      let axis2;
      if (isValid_default(axisId) ? axis2 = this._chart.getComponentsByKey("axes").find((s2) => s2.userId === axisId) : isValid_default(axisIndex) && (axis2 = null === (_a = this._chart.getComponentsByKey("axes")) || void 0 === _a ? void 0 : _a[axisIndex]), !axis2) return warn("Please check whether the `axisId` or `axisIndex` is set!"), null;
      const pointValue = null == axis2 ? void 0 : axis2.valueToPosition(value);
      if (isRelativeToCanvas) {
        const axisLayoutStartPoint = axis2.getLayoutStartPoint(), axisOrient = axis2.getOrient();
        return pointValue + ("bottom" === axisOrient || "top" === axisOrient ? axisLayoutStartPoint.x : axisLayoutStartPoint.y);
      }
      return pointValue;
    }
    const { seriesId, seriesIndex } = dataLinkInfo;
    let series2;
    return isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_b = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _b ? void 0 : _b[0]), series2 ? convertPoint(series2.valueToPosition(value[0], value[1]), series2.getRegion().getLayoutStartPoint(), isRelativeToCanvas) : (warn("Please check whether the `seriesId` or `seriesIndex` is set!"), null);
  }
  getFunction(key) {
    return ExpressionFunction.instance().getFunction(key);
  }
  registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  setRuntimeSpec(spec) {
    this._spec = spec, this._updateSpecInfo();
  }
  updateIndicatorDataById(id, datum) {
    var _a;
    const indicator2 = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
    indicator2 && indicator2.updateDatum(datum);
  }
  updateIndicatorDataByIndex(index = 0, datum) {
    var _a;
    const indicators = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.indicator);
    indicators && indicators[index] && indicators[index].updateDatum(datum);
  }
  geoZoomByIndex(regionIndex = 0, zoom, center2) {
    this._geoZoomByQuery({
      regionIndex
    }, zoom, center2);
  }
  geoZoomById(regionId, zoom, center2) {
    this._geoZoomByQuery({
      regionId
    }, zoom, center2);
  }
  _geoZoomByQuery(query, zoom, center2) {
    var _a, _b;
    const region = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getRegionsInQuerier(query)[0], geoCoordinates = null === (_b = this._chart) || void 0 === _b ? void 0 : _b.getComponentsByType(ComponentTypeEnum.geoCoordinate), coord = null == geoCoordinates ? void 0 : geoCoordinates.find((coord2) => {
      var _a2;
      return null === (_a2 = coord2.getRegions()) || void 0 === _a2 ? void 0 : _a2.includes(region);
    });
    coord && coord.dispatchZoom(zoom, center2);
  }
  _initChartPlugin() {
    const pluginList = Factory2.getChartPlugins();
    pluginList.length > 0 && (this._chartPlugin = new ChartPluginService(this), this._chartPlugin.load(pluginList.map((p) => new p())), this._chartPluginApply("onInit", this._spec));
  }
  _chartPluginApply(funcName, ...args) {
    this._chartPlugin && this._chartPlugin[funcName] && this._chartPlugin[funcName].apply(this._chartPlugin, args);
  }
  _getMode() {
    return this._option.mode || RenderModeEnum["desktop-browser"];
  }
  _getChartOption(type) {
    return {
      type,
      globalInstance: this,
      eventDispatcher: this._eventDispatcher,
      dataSet: this._dataSet,
      container: this._container,
      canvas: this._canvas,
      map: /* @__PURE__ */ new Map(),
      mode: this._getMode(),
      modeParams: this._option.modeParams,
      getCompiler: () => this._compiler,
      performanceHook: this._option.performanceHook,
      viewBox: this._viewBox,
      animation: this._option.animation,
      getTheme: () => {
        var _a;
        return null !== (_a = this._currentTheme) && void 0 !== _a ? _a : {};
      },
      getSpecInfo: () => {
        var _a;
        return null !== (_a = this._specInfo) && void 0 !== _a ? _a : {};
      },
      layout: this._option.layout,
      onError: this._onError,
      disableTriggerEvent: true === this._option.disableTriggerEvent
    };
  }
};
VChart.InstanceManager = InstanceManager, VChart.ThemeManager = ThemeManager, VChart.globalConfig = {
  uniqueTooltip: true
}, VChart.Utils = VCHART_UTILS, VChart.vglobal = vglobal;
Factory2.registerRegion("region", Region), Factory2.registerLayout("base", Layout), registerGroupMark(), View.useRegisters([registerGesturePlugin]), registerElementHighlight(), registerElementSelect(), registerTheme(darkTheme.name, darkTheme), Logger.getInstance(LoggerLevel.Error);

// node_modules/@visactor/vchart/esm/core/index.js
var version = "1.13.9";

// node_modules/@visactor/vchart/esm/data/transforms/add-property.js
var addVChartProperty = (data, op) => {
  const context = op.beforeCall();
  return data && data.forEach((d, i) => op.call(d, i, context)), context.keyMap && (context.keyMap.clear(), context.keyMap = null), data;
};

// node_modules/@visactor/vchart/esm/component/util.js
function getComponentThemeFromOption(type, chartTheme) {
  return get_default(chartTheme, `component.${type}`);
}
function getFormatFunction(formatMethod, formatter, text2, datum) {
  if (formatMethod) return {
    formatFunc: formatMethod,
    args: [text2, datum]
  };
  const formatterImpl = Factory2.getFormatter();
  return formatter && formatterImpl ? {
    formatFunc: formatterImpl,
    args: [text2, datum, formatter]
  } : {};
}
var getSpecInfo = (chartSpec, specKey, compType, filter2) => {
  if (isNil_default(chartSpec[specKey])) return;
  const isArraySpec = isArray_default(chartSpec[specKey]), spec = isArraySpec ? chartSpec[specKey] : [chartSpec[specKey]], specInfos = [];
  return spec.forEach((s2, i) => {
    !s2 || filter2 && !filter2(s2) || specInfos.push({
      spec: s2,
      specPath: isArraySpec ? [specKey, i] : [specKey],
      specInfoPath: ["component", specKey, i],
      type: compType
    });
  }), specInfos;
};

// node_modules/@visactor/vchart/esm/component/tooltip/utils/get-value.js
var getTooltipContentValue = (field5, datum, params2, formatter) => {
  let value;
  if (value = isFunction_default(field5) ? field5(datum, params2) : isPlainObject_default(field5) && isValid_default(field5.field) ? get_default(datum, field5.field) : field5, formatter) {
    const { formatFunc, args } = getFormatFunction(void 0, formatter, field5, datum);
    formatFunc && args && (value = formatFunc(...args));
  }
  return value;
};
var getTooltipPatternValue = (field5, data, params2) => isNil_default(field5) ? field5 : isFunction_default(field5) ? field5(data, params2) : field5;
function getFirstDatumFromTooltipData(data) {
  var _a;
  const dimInfoList = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.series) ? [{
    data,
    value: ""
  }] : data;
  for (const { data: dataList } of dimInfoList) for (const { datum: datumList } of dataList) for (const datumItem of null != datumList ? datumList : []) if (datumItem) return datumItem;
}

// node_modules/@visactor/vchart/esm/component/tooltip/utils/common.js
var __rest19 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var getTooltipActualActiveType = (spec) => {
  var _a, _b, _c;
  if (false === (null == spec ? void 0 : spec.visible)) return [];
  const activeTypeMap = {
    mark: false !== (null === (_a = null == spec ? void 0 : spec.mark) || void 0 === _a ? void 0 : _a.visible),
    dimension: false !== (null === (_b = null == spec ? void 0 : spec.dimension) || void 0 === _b ? void 0 : _b.visible),
    group: false !== (null === (_c = null == spec ? void 0 : spec.group) || void 0 === _c ? void 0 : _c.visible)
  };
  return isValid_default(null == spec ? void 0 : spec.activeType) && Object.keys(activeTypeMap).forEach((t) => {
    var _a2;
    activeTypeMap[t] = null === (_a2 = null == spec ? void 0 : spec.activeType) || void 0 === _a2 ? void 0 : _a2.includes(t);
  }), Object.keys(activeTypeMap).filter((t) => activeTypeMap[t]);
};
var isActiveTypeVisible = (type, spec) => !spec || false !== spec.visible && ((!spec[type] || false !== spec[type].visible) && !(spec.activeType && !(isArray_default(spec.activeType) ? spec.activeType.includes(type) : spec.activeType === type)));
function isEmptyPos(params2) {
  return isNil_default(params2.mark) && isNil_default(params2.model) && isNil_default(params2.datum);
}
function addContentLine(result2, contentSpec, defaultContent, shapeAttrs, datum, params2) {
  const addByDatum = (spec) => {
    if (spec) {
      const res = {
        datum
      }, finalSpec = isNil_default(spec.key) && isNil_default(spec.value) && !isEmpty_default(spec) ? Object.assign(Object.assign(Object.assign({}, shapeAttrs), defaultContent), spec) : Object.assign(Object.assign({}, shapeAttrs), spec), { key, keyFormatter, keyTimeFormat, keyTimeFormatMode, value, valueFormatter, valueTimeFormat, valueTimeFormatMode } = finalSpec, others = __rest19(finalSpec, ["key", "keyFormatter", "keyTimeFormat", "keyTimeFormatMode", "value", "valueFormatter", "valueTimeFormat", "valueTimeFormatMode"]);
      res.key = getTimeString(getTooltipContentValue(key, datum, params2, keyFormatter), keyTimeFormat, keyTimeFormatMode), res.value = getTimeString(getTooltipContentValue(value, datum, params2, valueFormatter), valueTimeFormat, valueTimeFormatMode), Object.keys(others).forEach((k2) => {
        res[k2] = getTooltipContentValue(finalSpec[k2], datum, params2);
      }), false !== res.visible && (isValid_default(res.key) || isValid_default(res.value)) && result2.push(res);
    }
  };
  isArray_default(contentSpec) ? contentSpec.forEach((spec) => {
    addByDatum(spec);
  }) : addByDatum(contentSpec);
}
function parseContentFunction(result2, contentSpec, defaultContent, shapeAttrs, data, datum, params2) {
  if (isFunction_default(contentSpec)) {
    addContentLine(result2, contentSpec(data, params2), defaultContent, shapeAttrs, datum, params2);
  } else contentSpec && addContentLine(result2, contentSpec, defaultContent, shapeAttrs, datum, params2);
}
function parseContent(contentSpec, defaultContent, shapeAttrs, data, datum, params2) {
  if (datum && datum.length) {
    const contents = [];
    return datum.forEach((d) => {
      isArray_default(contentSpec) ? contentSpec.forEach((spec) => {
        parseContentFunction(contents, spec, defaultContent, shapeAttrs, data, d, params2);
      }) : isFunction_default(contentSpec) ? parseContentFunction(contents, contentSpec, defaultContent, shapeAttrs, data, d, params2) : contentSpec && addContentLine(contents, contentSpec, defaultContent, shapeAttrs, d, params2);
    }), contents;
  }
  return null;
}
function combineContents(patternList) {
  if (!patternList || !patternList.length) return null;
  const defaultPatternContent = [];
  return patternList.forEach(({ content }) => {
    content && content.forEach((c3) => {
      defaultPatternContent.push(c3);
    });
  }), defaultPatternContent.length ? Object.assign(Object.assign({}, patternList[0]), {
    content: defaultPatternContent
  }) : patternList[0];
}
var getTimeString = (value, timeFormat, timeFormatMode) => {
  if (!timeFormat && !timeFormatMode) return "object" != typeof value ? null == value ? void 0 : value.toString() : value;
  const timeUtil = TimeUtil.getInstance();
  timeFormat = timeFormat || "%Y%m%d";
  return ("local" === (timeFormatMode = timeFormatMode || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat)(timeFormat, value);
};

// node_modules/@visactor/vchart/esm/series/base/tooltip-helper.js
var BaseSeriesTooltipHelper = class {
  constructor(series2) {
    this.activeTriggerSet = {
      mark: /* @__PURE__ */ new Set(),
      group: /* @__PURE__ */ new Set()
    }, this.ignoreTriggerSet = {
      mark: /* @__PURE__ */ new Set()
    }, this._getSeriesCacheInfo = () => {
      var _a, _b, _c;
      const { series: series3 } = this, _seriesField = series3.getSeriesField();
      return {
        seriesFields: isValid_default(_seriesField) ? array(_seriesField) : null !== (_a = series3.getSeriesKeys()) && void 0 !== _a ? _a : [],
        dimensionFields: null !== (_b = series3.getDimensionField()) && void 0 !== _b ? _b : [],
        measureFields: null !== (_c = series3.getMeasureField()) && void 0 !== _c ? _c : [],
        type: series3.type
      };
    }, this._getDimensionData = (datum) => {
      const { dimensionFields } = this._seriesCacheInfo;
      return dimensionFields[0] && (null == datum ? void 0 : datum[dimensionFields[0]]);
    }, this._getMeasureData = (datum) => {
      const { measureFields } = this._seriesCacheInfo;
      return measureFields[0] && (null == datum ? void 0 : datum[measureFields[0]]);
    }, this._getSeriesFieldData = (datum) => {
      const { dimensionFields, seriesFields } = this._seriesCacheInfo;
      if (isValid_default(seriesFields[0]) && (null == datum ? void 0 : datum[seriesFields[0]])) return null == datum ? void 0 : datum[seriesFields[0]];
      const subDimensionField = dimensionFields[dimensionFields.length - 1];
      return dimensionFields.length > 1 && (0 === seriesFields.length || this.series.getSeriesKeys().length), null == datum ? void 0 : datum[subDimensionField];
    }, this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a;
      for (const key of array(styleKey)) {
        const value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (isValid_default(value)) return value;
      }
      return defaultValue;
    }, this.markTooltipKeyCallback = (datum, params2) => this._getSeriesFieldData(datum), this.markTooltipValueCallback = (datum, params2) => this._getMeasureData(datum), this.shapeTypeCallback = (datum, params2) => {
      var _a;
      return null !== (_a = this._getSeriesStyle(datum, "shape", null)) && void 0 !== _a ? _a : this._getSeriesStyle(datum, "symbolType", this.series.getDefaultShapeType());
    }, this.shapeColorCallback = (datum, params2) => this._getSeriesStyle(datum, ["fill", "stroke"]), this.shapeStrokeCallback = (datum, params2) => this._getSeriesStyle(datum, ["stroke", "fill"]), this.dimensionTooltipTitleCallback = (datum, params2) => this._getDimensionData(datum), this.groupTooltipTitleCallback = (datum, params2) => this._getSeriesFieldData(datum), this.groupTooltipKeyCallback = (datum, params2) => {
      const { seriesFields } = this._seriesCacheInfo;
      let dimensionFields = this._seriesCacheInfo.dimensionFields;
      return seriesFields[0] && (dimensionFields = dimensionFields.filter((field5) => field5 !== seriesFields[0])), dimensionFields.map((field5) => null == datum ? void 0 : datum[field5]).join("-");
    }, this.getHasShape = (isContent) => !!isContent, this.series = series2, this.updateTooltipSpec();
  }
  updateTooltipSpec() {
    var _a;
    const seriesTooltipSpec = null === (_a = this.series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip;
    this.spec = seriesTooltipSpec, this._seriesCacheInfo = this._getSeriesCacheInfo();
  }
  getShapeAttrs(activeType, isContent, chartTooltipSpec) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const key = isContent ? "content" : "title", shapeAttrs = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, null === (_a = null == chartTooltipSpec ? void 0 : chartTooltipSpec.style) || void 0 === _a ? void 0 : _a.shape), null == chartTooltipSpec ? void 0 : chartTooltipSpec[activeType]), null === (_b = null == chartTooltipSpec ? void 0 : chartTooltipSpec[activeType]) || void 0 === _b ? void 0 : _b[key]), null === (_c = this.spec) || void 0 === _c ? void 0 : _c[activeType]), null === (_e = null === (_d = this.spec) || void 0 === _d ? void 0 : _d[activeType]) || void 0 === _e ? void 0 : _e[key]);
    return {
      shapeType: null !== (_f = shapeAttrs.shapeType) && void 0 !== _f ? _f : this.shapeTypeCallback,
      shapeFill: null !== (_h = null !== (_g = shapeAttrs.shapeFill) && void 0 !== _g ? _g : shapeAttrs.shapeColor) && void 0 !== _h ? _h : this.shapeColorCallback,
      shapeStroke: null !== (_j = shapeAttrs.shapeStroke) && void 0 !== _j ? _j : this.shapeStrokeCallback,
      shapeHollow: null !== (_k = shapeAttrs.shapeHollow) && void 0 !== _k && _k,
      shapeLineWidth: shapeAttrs.shapeLineWidth,
      shapeSize: null !== (_l = shapeAttrs.shapeSize) && void 0 !== _l ? _l : shapeAttrs.size,
      hasShape: null !== (_m = shapeAttrs.hasShape) && void 0 !== _m ? _m : this.getHasShape(isContent)
    };
  }
  enableByType(activeType) {
    return true;
  }
  getDefaultContentList(activeType) {
    return [this.getDefaultContentPattern(activeType)];
  }
  getContentList(activeType, spec, shapeAttrs, data, datum, params2) {
    var _a;
    return parseContent(null !== (_a = null == spec ? void 0 : spec.content) && void 0 !== _a ? _a : this.getDefaultContentList(activeType), this.getDefaultContentPattern(activeType), shapeAttrs, data, datum, params2);
  }
  getTitleResult(activeType, titleSpec, shapeAttrs, data, params2) {
    let titlePattern = isFunction_default(titleSpec) ? titleSpec(data, params2) : titleSpec;
    if (titlePattern ? isNil_default(titlePattern.value) && (titlePattern = Object.assign(Object.assign({}, this.getDefaultTitlePattern(activeType)), titlePattern)) : titlePattern = this.getDefaultTitlePattern(activeType), titlePattern && false !== titlePattern.visible) {
      const datum = getFirstDatumFromTooltipData(data), res = {
        visible: getTooltipContentValue(titlePattern.visible, datum, params2),
        value: getTimeString(getTooltipContentValue(titlePattern.value, datum, params2, titlePattern.valueFormatter), titlePattern.valueTimeFormat, titlePattern.valueTimeFormatMode),
        valueStyle: getTooltipContentValue(titlePattern.valueStyle, datum, params2),
        hasShape: titlePattern.hasShape
      };
      return Object.keys(shapeAttrs).forEach((key) => {
        res[key] = getTooltipContentValue(shapeAttrs[key], datum, params2);
      }), res;
    }
    return {
      hasShape: false,
      visible: false
    };
  }
  getTooltipData(activeType, chartTooltipSpec, data, datum, params2) {
    var _a, _b;
    if (!(this.enableByType(activeType) && isActiveTypeVisible(activeType, this.spec) && ("dimension" !== activeType || datum && datum.length))) return null;
    const patternSpec = null !== (_b = null === (_a = this.spec) || void 0 === _a ? void 0 : _a[activeType]) && void 0 !== _b ? _b : null == chartTooltipSpec ? void 0 : chartTooltipSpec[activeType], contentShapeAttrs = this.getShapeAttrs(activeType, true, chartTooltipSpec), titleShapeAttrs = this.getShapeAttrs(activeType, false, chartTooltipSpec);
    let content;
    if ("dimension" === activeType) {
      content = [];
      this.getContentList(activeType, patternSpec, contentShapeAttrs, data, datum, params2).forEach((entry) => {
        content.push(entry);
      });
    } else content = this.getContentList(activeType, patternSpec, contentShapeAttrs, data, datum, params2);
    return {
      visible: true,
      activeType,
      data,
      title: this.getTitleResult(activeType, null == patternSpec ? void 0 : patternSpec.title, titleShapeAttrs, data, params2),
      content
    };
  }
  getDefaultTitlePattern(activeType) {
    return {
      key: void 0,
      value: "group" === activeType ? this.groupTooltipTitleCallback : this.dimensionTooltipTitleCallback
    };
  }
  getDefaultContentPattern(activeType) {
    return {
      seriesId: this.series.id,
      key: "group" === activeType ? this.groupTooltipKeyCallback : this.markTooltipKeyCallback,
      value: this.markTooltipValueCallback
    };
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/dimension-statistics.js
var methods3 = {
  min: (arr) => arr.length ? minInArray(arr.map((n) => 1 * n)) : 0,
  max: (arr) => arr.length ? maxInArray(arr.map((n) => 1 * n)) : 0,
  "array-min": (arr) => arr.length ? minInArray(arr.map((n) => 1 * n)) : 0,
  "array-max": (arr) => arr.length ? maxInArray(arr.map((n) => 1 * n)) : 0,
  values: (arr) => {
    const map4 = {}, res = [];
    for (const entry of arr) map4[entry] || (res.push(entry), map4[entry] = 1);
    return res;
  }
};
var dimensionStatistics = (data, op) => {
  var _a, _b;
  let fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length)) return {};
  fields2 = mergeFields([], fields2);
  const dataKey = "parser" === op.target ? "parserData" : "latestData", latestData = data[0][dataKey] ? data[0][dataKey] : data || [], dataFields = null === (_b = (_a = data[0]).getFields) || void 0 === _b ? void 0 : _b.call(_a);
  return dimensionStatisticsOfSimpleData(latestData, fields2, dataFields);
};
var dimensionStatisticsOfSimpleData = (latestData, fields2, dataFields) => {
  const result2 = {};
  let fValues = [], nextFValues = [];
  return fields2.forEach((f) => {
    const key = f.key;
    result2[key] = {};
    const dataFieldInKey = null == dataFields ? void 0 : dataFields[key], operations = f.operations, isNumberField = operations.some((op) => "min" === op || "max" === op || "allValid" === op);
    let allValid = true;
    fValues.length = 0, latestData && latestData.forEach((d) => {
      d && fValues.push(d[key]);
    });
    const len = fValues.length;
    if (isNumberField) {
      nextFValues.length = 0, fValues.forEach((item, i) => {
        couldBeValidNumber(item) && nextFValues.push(item);
      });
      const t = fValues;
      fValues = nextFValues, nextFValues = t, allValid = fValues.length === len;
    } else fValues = operations.some((op) => "array-min" === op || "array-max" === op) ? fValues.reduce((res, entry) => (entry && entry.forEach((d) => {
      couldBeValidNumber(d) && res.push(d);
    }), res), []) : fValues.filter((entry) => void 0 !== entry);
    f.filter && (fValues = fValues.filter(f.filter)), operations.forEach((op) => {
      if (f.customize) result2[key][op] = f.customize;
      else {
        if (dataFieldInKey && true === dataFieldInKey.lockStatisticsByDomain && !isNil_default(dataFieldInKey.domain)) {
          if ("values" === op) return void (result2[key][op] = dataFieldInKey.domain.slice());
        } else if ("allValid" === op) return;
        result2[key][op] = methods3[op](fValues), "array-max" === op && (result2[key].max = result2[key][op]), "array-min" === op && (result2[key].min = result2[key][op]);
      }
    }), isNumberField && (result2[key].allValid = allValid);
  }), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/invalid-travel.js
var invalidTravel = (data, op) => {
  const { config: config2 } = op;
  if (!config2) return data;
  const { invalidType, checkField } = config2();
  return "zero" !== invalidType || checkField && checkField.length && data.forEach((datum) => {
    checkField.forEach((field5) => {
      couldBeValidNumber(datum[field5]) || (datum[field5] = 0);
    });
  }), data;
};

// node_modules/@visactor/vchart/esm/series/base/series-data.js
var SeriesData = class extends CompilableData {
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct([]);
  }
  generateProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.name;
  }
};

// node_modules/@visactor/vchart/esm/constant/hierarchy.js
var DEFAULT_HIERARCHY_DEPTH = `${PREFIX}_HIERARCHY_DEPTH`;
var DEFAULT_HIERARCHY_ROOT = `${PREFIX}_HIERARCHY_ROOT`;
var DEFAULT_HIERARCHY_ROOT_INDEX = `${PREFIX}_HIERARCHY_ROOT_INDEX`;

// node_modules/@visactor/vchart/esm/data/transforms/data-key.js
function initKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: !this._seriesField,
    defaultSeriesField: this._seriesField ? null : this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey)
  };
}
function addDataKey(d, i, context) {
  d && (context.needDefaultSeriesField && (d[DEFAULT_DATA_SERIES_FIELD] = context.defaultSeriesField), d[DEFAULT_DATA_INDEX] = i, d[DEFAULT_DATA_KEY] = context.getKey(d, i, context));
}
function initHierarchyKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: true,
    defaultSeriesField: this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey),
    categoryField: this.getCategoryField()
  };
}
function addHierarchyDataKey(d, i, context, depth = 0, root, rootIndex) {
  void 0 === rootIndex && (rootIndex = i), addDataKey(d, i, context), d[DEFAULT_HIERARCHY_DEPTH] = depth, d[DEFAULT_HIERARCHY_ROOT] = root || d[context.categoryField], d[DEFAULT_HIERARCHY_ROOT_INDEX] = rootIndex, d.children && d.children.length && d.children.forEach((_d, _i) => addHierarchyDataKey(_d, _i, context, d[DEFAULT_HIERARCHY_DEPTH] + 1, d[DEFAULT_HIERARCHY_ROOT], rootIndex));
}

// node_modules/@visactor/vchart/esm/series/base/constant.js
var baseSeriesMark = {
  label: {
    name: "label",
    type: "text"
  }
};
var RECT_X = `${PREFIX}_rect_x`;
var RECT_X1 = `${PREFIX}_rect_x1`;
var RECT_Y = `${PREFIX}_rect_y`;
var RECT_Y1 = `${PREFIX}_rect_y1`;
var defaultSeriesIgnoreCheckKeys = {
  data: true
};
var defaultSeriesCompileCheckKeys = {
  invalidType: true,
  animation: true,
  animationAppear: true,
  animationEnter: true,
  animationUpdate: true,
  animationExit: true,
  animationNormal: true
};

// node_modules/@visactor/vchart/esm/series/line/animation.js
var Appear_ClipIn = (params2) => ({
  type: "clipIn",
  options: {
    clipDimension: "horizontal" === params2.direction ? "y" : "x"
  }
});
var Appear_FadeIn = {
  type: "fadeIn"
};
var Appear_Grow = (params2) => ({
  type: "horizontal" === params2.direction ? "growPointsXIn" : "growPointsYIn",
  options: {
    orient: "horizontal" === params2.direction ? "positive" : "negative"
  }
});
function linePresetAnimation(params2, preset) {
  switch (preset) {
    case "grow":
      return Appear_Grow(params2);
    case "fadeIn":
      return Appear_FadeIn;
    default:
      return Appear_ClipIn(params2);
  }
}

// node_modules/@visactor/vchart/esm/animation/config.js
var DEFAULT_ANIMATION_CONFIG = {
  appear: {
    duration: 1e3,
    easing: "cubicOut"
  },
  update: {
    type: "update",
    duration: 300,
    easing: "linear"
  },
  enter: {
    duration: 300,
    easing: "linear"
  },
  exit: {
    duration: 300,
    easing: "linear"
  },
  disappear: {
    duration: 500,
    easing: "cubicIn"
  },
  state: {
    duration: 300,
    easing: "linear"
  }
};
var ScaleInOutAnimation = {
  appear: {
    type: "scaleIn"
  },
  enter: {
    type: "scaleIn"
  },
  exit: {
    type: "scaleOut"
  },
  disappear: {
    type: "scaleOut"
  }
};
var FadeInOutAnimation = {
  appear: {
    type: "fadeIn"
  },
  enter: {
    type: "fadeIn"
  },
  exit: {
    type: "fadeOut"
  },
  disappear: {
    type: "fadeOut"
  }
};
var registerScaleInOutAnimation = () => {
  Factory2.registerAnimation("scaleInOut", () => ScaleInOutAnimation);
};
var registerFadeInOutAnimation = () => {
  Factory2.registerAnimation("fadeInOut", () => FadeInOutAnimation);
};
var registerCartesianGroupClipAnimation = () => {
  Factory2.registerAnimation("cartesianGroupClip", (params2) => ({
    appear: {
      custom: ClipDirectionAnimate,
      customParameters: (datum, element) => ({
        animationType: "in",
        group: element.getGraphicItem(),
        direction: params2.direction(),
        width: params2.width(),
        height: params2.height(),
        orient: params2.orient()
      })
    },
    disappear: {
      custom: ClipDirectionAnimate,
      customParameters: (datum, element) => ({
        animationType: "out",
        group: element.getGraphicItem(),
        direction: params2.direction(),
        width: params2.width(),
        height: params2.height(),
        orient: params2.orient()
      })
    }
  }));
};
var lineOrAreaAnimation = (params2, preset) => ({
  appear: linePresetAnimation(params2, preset),
  enter: {
    type: "fadeIn"
  },
  exit: {
    type: "fadeOut"
  },
  update: [{
    type: "update",
    options: {
      excludeChannels: ["points", "defined", "segments"]
    }
  }, {
    channel: ["points", "segments"],
    custom: TagPointsUpdate,
    duration: DEFAULT_ANIMATION_CONFIG.update.duration,
    easing: DEFAULT_ANIMATION_CONFIG.update.easing,
    customParameters: {
      clipRangeByDimension: "horizontal" === params2.direction ? "y" : "x"
    }
  }],
  disappear: {
    type: "clipOut"
  }
});
var registerLineAnimation = () => {
  Factory2.registerAnimation("line", lineOrAreaAnimation);
};
var registerAreaAnimation = () => {
  Factory2.registerAnimation("area", lineOrAreaAnimation);
};
var registerVGrammarCommonAnimation = () => {
  View.useRegisters([registerScaleInAnimation, registerScaleOutAnimation, registerFadeInAnimation, registerFadeOutAnimation, registerMoveInAnimation, registerMoveOutAnimation, registerRotateInAnimation, registerRotateOutAnimation, registerUpdateAnimation]);
};
var registerVGrammarRectAnimation = () => {
  View.useRegisters([registerGrowHeightInAnimation, registerGrowHeightOutAnimation, registerGrowWidthInAnimation, registerGrowWidthOutAnimation, registerGrowCenterInAnimation, registerGrowCenterOutAnimation]);
};
var registerVGrammarArcAnimation = () => {
  View.useRegisters([registerGrowRadiusInAnimation, registerGrowRadiusOutAnimation, registerGrowAngleInAnimation, registerGrowAngleOutAnimation]);
};
var registerVGrammarLineOrAreaAnimation = () => {
  View.useRegisters([registerGrowPointsInAnimation, registerGrowPointsOutAnimation, registerGrowPointsXInAnimation, registerGrowPointsXOutAnimation, registerGrowPointsYInAnimation, registerGrowPointsYOutAnimation, registerClipInAnimation, registerClipOutAnimation]);
};
var registerVGrammarPolygonAnimation = () => {
  View.useRegisters([registerGrowPointsInAnimation, registerGrowPointsOutAnimation]);
};

// node_modules/@visactor/vchart/esm/animation/utils.js
var AnimationStates = [...Object.keys(DEFAULT_ANIMATION_CONFIG), "normal"];
function animationConfig(defaultConfig = {}, userConfig, params2) {
  const config2 = {};
  for (let i = 0; i < AnimationStates.length; i++) {
    const state = AnimationStates[i], userStateConfig = userConfig ? userConfig[state] : void 0;
    if (false === userStateConfig) continue;
    if ("normal" === state) {
      userStateConfig && (config2.normal = userStateConfig);
      continue;
    }
    if ("state" === state) {
      false !== userStateConfig && (config2.state = null != userStateConfig ? userStateConfig : DEFAULT_ANIMATION_CONFIG.state);
      continue;
    }
    if ("update" !== state && !userStateConfig && !defaultConfig[state]) continue;
    let defaultStateConfig, stateConfig;
    (defaultStateConfig = isArray_default(defaultConfig[state]) ? defaultConfig[state] : [Object.assign(Object.assign({}, DEFAULT_ANIMATION_CONFIG[state]), defaultConfig[state])], "exit" === state && defaultStateConfig.forEach((exitConfig) => {
      exitConfig.controlOptions = {
        stopWhenStateChange: true
      };
    }), userStateConfig) ? (stateConfig = isArray_default(userStateConfig) ? userStateConfig.map((userConfig2, i2) => {
      var _a;
      let singleConfig = userConfig2;
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }) : defaultStateConfig.map((stateConfig2, i2) => {
      var _a;
      let singleConfig = mergeSpec({}, defaultStateConfig[i2], userStateConfig);
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }), config2[state] = stateConfig) : config2[state] = defaultStateConfig;
  }
  return config2;
}
function userAnimationConfig(markName, spec, ctx) {
  var _a, _b, _c, _d, _e, _f;
  const userConfig = {};
  return isValid_default(spec.animationAppear) && (userConfig.appear = null !== (_a = spec.animationAppear[markName]) && void 0 !== _a ? _a : spec.animationAppear), isValid_default(spec.animationDisappear) && (userConfig.disappear = null !== (_b = spec.animationDisappear[markName]) && void 0 !== _b ? _b : spec.animationDisappear), isValid_default(spec.animationEnter) && (userConfig.enter = null !== (_c = spec.animationEnter[markName]) && void 0 !== _c ? _c : spec.animationEnter), isValid_default(spec.animationExit) && (userConfig.exit = null !== (_d = spec.animationExit[markName]) && void 0 !== _d ? _d : spec.animationExit), isValid_default(spec.animationUpdate) && (userConfig.update = null !== (_e = spec.animationUpdate[markName]) && void 0 !== _e ? _e : spec.animationUpdate), isValid_default(spec.animationState) && (userConfig.state = null !== (_f = spec.animationState[markName]) && void 0 !== _f ? _f : spec.animationState), spec.animationNormal && spec.animationNormal[markName] && (userConfig.normal = spec.animationNormal[markName]), uniformAnimationConfig(userConfig, ctx);
}
function produceOneByOne(stateConfig, dataIndex, dataCount) {
  const { oneByOne, duration, delay, delayAfter } = stateConfig;
  return stateConfig.delay = (datum, element, params2) => {
    const index = dataIndex(datum, params2), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelay = isFunction_default(delay) ? delay(datum, element, params2) : isValidNumber_default(delay) ? delay : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    return false === oneByOneTime ? userDelay : (oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelay + index * (durationTime + oneByOneTime));
  }, stateConfig.delayAfter = (datum, element, params2) => {
    const index = dataIndex(datum, params2), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelayAfter = isFunction_default(delayAfter) ? delayAfter(datum, element, params2) : isValidNumber_default(delayAfter) ? delayAfter : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    if (false === oneByOneTime) return userDelayAfter;
    return oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelayAfter + ((dataCount ? dataCount() : element.mark.elements.length) - index) * (durationTime + oneByOneTime);
  }, delete stateConfig.oneByOne, stateConfig;
}
function defaultDataIndex(datum, params2) {
  var _a, _b;
  return null !== (_a = null == datum ? void 0 : datum[DEFAULT_DATA_INDEX]) && void 0 !== _a ? _a : null === (_b = null == params2 ? void 0 : params2.VGRAMMAR_ANIMATION_PARAMETERS) || void 0 === _b ? void 0 : _b.elementIndex;
}
function shouldMarkDoMorph(spec, markName) {
  var _a, _b, _c, _d, _e;
  if (false === spec.animation) return false;
  if (false === (null === (_a = spec.morph) || void 0 === _a ? void 0 : _a.enable)) return false;
  const appearAnimationEnabled = false !== (null !== (_c = null === (_b = spec.animationAppear) || void 0 === _b ? void 0 : _b[markName]) && void 0 !== _c ? _c : spec.animationAppear), updateAnimationEnabled = false !== (null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d[markName]) && void 0 !== _e ? _e : spec.animationUpdate);
  return !(!appearAnimationEnabled || !updateAnimationEnabled);
}
function isTimeLineAnimation(animationConfig2) {
  return isValid_default(animationConfig2.timeSlices);
}
function isChannelAnimation(animationConfig2) {
  return !isTimeLineAnimation(animationConfig2) && isValid_default(animationConfig2.channel);
}
function uniformAnimationConfig(config2, ctx) {
  if (!config2) return config2;
  const excludeKeys = ["custom", "customParameters"];
  return traverseSpec(config2 = cloneDeep(config2, null, excludeKeys), (node) => {
    var _a;
    if (isFunction_default(node) && (null === (_a = node.prototype) || void 0 === _a ? void 0 : _a.constructor) !== node) {
      return (...args) => node(...args, ctx);
    }
    return node;
  }, excludeKeys), config2;
}
function traverseSpec(spec, transform30, excludeKeys = []) {
  if (isArray_default(spec)) spec.forEach((i, index) => {
    spec[index] = transform30(spec[index], index), traverseSpec(spec[index], transform30, excludeKeys);
  });
  else if (isObject_default(spec)) for (const key in spec) excludeKeys.includes(key) || (spec[key] = transform30(spec[key], key), traverseSpec(spec[key], transform30, excludeKeys));
}
function isAnimationEnabledForSeries(series2) {
  var _a, _b, _c, _d;
  const seriesSpec = series2.getSpec();
  if (false === seriesSpec.animation) return false;
  if (!isValid_default(series2.getRegion().animate)) return false;
  let animationThreshold = null !== (_a = seriesSpec.animationThreshold) && void 0 !== _a ? _a : Number.MAX_SAFE_INTEGER;
  return null === (_b = series2.getMarks()) || void 0 === _b || _b.forEach((m4) => {
    const config2 = m4.getMarkConfig();
    config2 && (config2.large && config2.largeThreshold && (animationThreshold = Math.min(animationThreshold, config2.largeThreshold)), config2.progressiveThreshold && (animationThreshold = Math.min(animationThreshold, config2.progressiveThreshold)));
  }), !((null === (_d = null === (_c = series2.getRawData()) || void 0 === _c ? void 0 : _c.latestData) || void 0 === _d ? void 0 : _d.length) >= animationThreshold);
}

// node_modules/@visactor/vchart/esm/series/base/base-series-transformer.js
var BaseSeriesSpecTransformer = class extends BaseModelSpecTransformer {
  constructor() {
    super(...arguments), this.markLabelSpec = {};
  }
  getLabelSpec(markName) {
    return this.markLabelSpec[markName];
  }
  setLabelSpec(markName, label) {
    this.markLabelSpec[markName] = array(label);
  }
  addLabelSpec(markName, label, head = false) {
    this.markLabelSpec[markName] || (this.markLabelSpec[markName] = []), head ? this.markLabelSpec[markName].unshift(label) : this.markLabelSpec[markName].push(label);
  }
  getTheme(spec, chartSpec) {
    var _a, _b, _c;
    const direction = getDirectionFromSeriesSpec(spec), chartTheme = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getTheme(), { markByName: markByName2, mark } = chartTheme, type = this._option.type, theme2 = Factory2.getSeriesMarkMap(type) ? transformSeriesThemeToMerge(get_default(chartTheme, `series.${type}`), type, mark, markByName2) : {}, themeWithDirection = get_default(chartTheme, `series.${type}_${direction}`), themeWithStack = (null !== (_c = null !== (_b = this.stack) && void 0 !== _b ? _b : null == themeWithDirection ? void 0 : themeWithDirection.stack) && void 0 !== _c ? _c : null == theme2 ? void 0 : theme2.stack) ? get_default(chartTheme, `series.${type}_stack`) : void 0;
    return mergeSpec({}, theme2, themeWithDirection, themeWithStack);
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    this._transformStack(spec);
    const result2 = super.transformSpec(spec, chartSpec, chartSpecInfo);
    return this._transformLabelSpec(result2.spec), Object.assign(Object.assign({}, result2), {
      markLabelSpec: this.markLabelSpec,
      stack: this.stack
    });
  }
  _transformLabelSpec(spec) {
  }
  _transformStack(spec) {
    isBoolean_default(spec.stack) && (this.stack = spec.stack), isBoolean_default(spec.percent) && (this.stack = spec.percent || this.stack), isNil_default(this.stack) && this._supportStack && spec.seriesField && (this.stack = true);
  }
  _addMarkLabelSpec(spec, markName, labelSpecKey = "label", styleHandlerName = "initLabelMarkStyle", hasAnimation = true, head) {
    if (!spec) return;
    array(spec[labelSpecKey]).forEach((labelSpec) => {
      var _a, _b, _c;
      if (labelSpec && labelSpec.visible) {
        const { animation = true, animationUpdate: labelAnimationUpdate = true, animationEnter: labelAnimationEnter = true, animationExit: labelAnimationExit = true } = labelSpec, { animationUpdate = true, animationEnter = true, animationExit = true } = spec, labelAnimationEnabled = !!(null !== (_c = null !== (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.animation) && void 0 !== _b ? _b : spec.animation) && void 0 !== _c ? _c : labelSpec.animation) && !!hasAnimation;
        this.addLabelSpec(isFunction_default(markName) ? markName(labelSpec) : markName, Object.assign(Object.assign({}, labelSpec), {
          animation: !!labelAnimationEnabled && animation,
          animationUpdate: !!(labelAnimationEnabled && animationUpdate && labelAnimationUpdate) && animationUpdate,
          animationEnter: !!(labelAnimationEnabled && animationEnter && labelAnimationEnter) && animationEnter,
          animationExit: !!(labelAnimationEnabled && animationEnter && labelAnimationExit) && animationExit,
          getStyleHandler: (series2) => {
            var _a2;
            return null === (_a2 = series2[styleHandlerName]) || void 0 === _a2 ? void 0 : _a2.bind(series2);
          }
        }), head);
      }
    });
  }
  _getDefaultSpecFromChart(chartSpec) {
    var _a;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, { outerRadius, innerRadius, direction } = chartSpec;
    return isValid_default(outerRadius) && (spec.outerRadius = outerRadius), isValid_default(innerRadius) && (spec.innerRadius = innerRadius), isValid_default(direction) && (spec.direction = direction), Object.keys(spec).length > 0 ? spec : void 0;
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec), merge2 = (originalSpec) => {
        const result2 = mergeSpec({}, theme2, specFromChart, originalSpec), labelTheme2 = theme2.label;
        return labelTheme2 && isObject_default(labelTheme2) && isArray_default(result2.label) && (result2.label = result2.label.map((label) => mergeSpec({}, labelTheme2, label))), result2;
      };
      return isArray_default(spec) ? {
        spec: spec.map((specItem) => merge2(specItem)),
        theme: theme2
      } : {
        spec: merge2(spec),
        theme: theme2
      };
    }
    return {
      spec,
      theme: theme2
    };
  }
};

// node_modules/@visactor/vchart/esm/interaction/config.js
function getDefaultInteractionConfigByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    hover: {
      enable: true,
      trigger: "pointermove",
      triggerOff: "view:pointerleave"
    },
    select: {
      enable: true,
      trigger: "pointertap"
    }
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    hover: {
      enable: true,
      trigger: ["pointerdown", "pointermove"],
      triggerOff: "view:pointerleave"
    },
    select: {
      enable: true,
      trigger: "tap"
    }
  } : null;
}

// node_modules/@visactor/vchart/esm/series/base/base-series.js
var BaseSeries = class extends BaseModel {
  getRegion() {
    return this._region;
  }
  getLayoutStartPoint() {
    return this._region.getLayoutStartPoint();
  }
  getRootMark() {
    return this._rootMark;
  }
  getSeriesMark() {
    return this._seriesMark;
  }
  getRawData() {
    return this._rawData;
  }
  getViewDataFilter() {
    return this._viewDataFilter;
  }
  getViewData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  getViewDataProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getProductId();
  }
  getViewDataStatistics() {
    return this._viewDataStatistics;
  }
  getViewStackData() {
    return this._viewStackData;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field5) {
    isValid_default(field5) && (this._seriesField = field5);
  }
  getGroups() {
    return this._groups;
  }
  getStack() {
    var _a;
    return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.stack;
  }
  getStackValue() {
    var _a;
    return null !== (_a = this._spec.stackValue) && void 0 !== _a ? _a : `${PREFIX}_series_${this.type}`;
  }
  getPercent() {
    return this._spec.percent;
  }
  getStackOffsetSilhouette() {
    return this._spec.stackOffsetSilhouette;
  }
  get tooltipHelper() {
    return this._tooltipHelper || this.initTooltip(), this._tooltipHelper;
  }
  getInvalidType() {
    return this._invalidType;
  }
  setInvalidType(t) {
    var _a;
    this._invalidType = t, null === (_a = this.getViewData()) || void 0 === _a || _a.reRunAllTransform();
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "series", this.type = "series", this.layoutType = "absolute", this.modelType = "series", this.name = void 0, this.transformerConstructor = BaseSeriesSpecTransformer, this.coordinate = "none", this._region = null, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: null,
      height: null
    }, this.getLayoutRect = () => {
      var _a2, _b;
      return {
        width: null !== (_a2 = this._layoutRect.width) && void 0 !== _a2 ? _a2 : this._region.getLayoutRect().width,
        height: null !== (_b = this._layoutRect.height) && void 0 !== _b ? _b : this._region.getLayoutRect().height
      };
    }, this._rootMark = null, this._seriesMark = null, this._viewDataMap = /* @__PURE__ */ new Map(), this._viewDataFilter = null, this._data = null, this.layoutZIndex = LayoutZIndex.SeriesGroup, this._invalidType = "break", this._region = options.region, this._dataSet = options.dataSet, (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.name) && (this.name = this._spec.name);
  }
  created() {
    super.created(), this._buildMarkAttributeContext(), this.initData(), this.initGroups(), this.initStatisticalData(), this.event.emit(ChartEvent.afterInitData, {
      model: this
    }), this.initRootMark(), this.initMark();
    const hasAnimation = isAnimationEnabledForSeries(this);
    this._initExtensionMark({
      hasAnimation
    }), this.initMarkStyle(), this.initMarkState(), hasAnimation && this.initAnimation(), this._option.disableTriggerEvent || this.initInteraction(), this.afterInitMark(), this.initEvent(), this.event.emit(ChartEvent.afterInitEvent, {
      model: this
    });
  }
  _buildMarkAttributeContext() {
    this._markAttributeContext = {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      },
      seriesColor: (seriesValue) => {
        var _a;
        return isNil_default(seriesValue) && (seriesValue = this.getSeriesKeys()[0]), null === (_a = this._option.globalScale.getScale("color")) || void 0 === _a ? void 0 : _a.scale(seriesValue);
      },
      getRegion: () => this._region
    };
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setSeriesField(this._spec.seriesField), isValid_default(this._spec.invalidType) && (this._invalidType = this._spec.invalidType);
  }
  getInvalidCheckFields() {
    return [this.getStackValueField()];
  }
  initInvalidDataTransform() {
    var _a, _b;
    "zero" === this._invalidType && (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "invalidTravel", invalidTravel), null === (_b = this._rawData) || void 0 === _b || _b.transform({
      type: "invalidTravel",
      options: {
        config: () => ({
          invalidType: this._invalidType,
          checkField: this.getInvalidCheckFields()
        })
      }
    }, false));
  }
  initData() {
    var _a, _b, _c;
    const d = null !== (_a = this._spec.data) && void 0 !== _a ? _a : this._option.getSeriesData(this._spec.dataId, this._spec.dataIndex);
    if (d && (this._rawData = dataToDataView(d, this._dataSet, this._option.sourceDataList)), null === (_c = null === (_b = this._rawData) || void 0 === _b ? void 0 : _b.target) || void 0 === _c || _c.addListener("change", this.rawDataUpdate.bind(this)), this._addDataIndexAndKey(), this._rawData) {
      this.getStack() && (this._viewDataFilter = dataViewFromDataView(this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewDataFilter`
      }));
      const viewData = dataViewFromDataView(this.getStack() ? this._viewDataFilter : this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewData`
      });
      this._data = new SeriesData(this._option, viewData), this.getStack() && this._viewDataFilter.target.removeListener("change", viewData.reRunAllTransform);
    }
    this.initInvalidDataTransform();
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = {
      fields: groupFields
    });
  }
  initStatisticalData() {
    this._data && this._statisticViewData();
  }
  getRawDataStatisticsByField(field5, isNumeric) {
    var _a, _b, _c;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field5] || isNumeric && (isNil_default(this._rawStatisticsCache[field5].min) || isNil_default(this._rawStatisticsCache[field5].max)) || !isNumeric && isNil_default(this._rawStatisticsCache[field5].values)) {
      if (this._viewDataStatistics && (!this._viewDataFilter || this._viewDataFilter.transformsArr.length <= 1) && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field5])) this._rawStatisticsCache[field5] = this._viewDataStatistics.latestData[field5];
      else if (this._rawData) {
        const fieldInfo = null === (_b = this._rawData.getFields()) || void 0 === _b ? void 0 : _b[field5];
        if (fieldInfo && fieldInfo.lockStatisticsByDomain && fieldInfo.domain) this._rawStatisticsCache[field5] = {}, isNumeric ? (this._rawStatisticsCache[field5].min = minInArray(fieldInfo.domain), this._rawStatisticsCache[field5].max = maxInArray(fieldInfo.domain)) : this._rawStatisticsCache[field5].values = fieldInfo.domain;
        else {
          const result2 = dimensionStatisticsOfSimpleData(this._rawData.latestData, [{
            key: field5,
            operations: isNumeric ? ["min", "max"] : ["values"]
          }])[field5];
          this._rawStatisticsCache[field5] = merge(null !== (_c = this._rawStatisticsCache[field5]) && void 0 !== _c ? _c : {}, result2);
        }
      }
    }
    return this._rawStatisticsCache[field5];
  }
  _statisticViewData() {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const viewDataStatisticsName = `${this.type}_${this.id}_viewDataStatic`;
    this._viewDataStatistics = new DataView(this._dataSet, {
      name: viewDataStatisticsName
    }), this._viewDataStatistics.parse([this._data.getDataView()], {
      type: "dataview"
    }), this._viewDataStatistics.transform({
      type: "dimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), this._data.getDataView().target.removeListener("change", this._viewDataStatistics.reRunAllTransform), this.getStack() && this.createdStackData();
  }
  createStatisticalData(dataName, rawData, staticFields) {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse([rawData], {
      type: "dataview"
    }), data.transform({
      type: "dimensionStatistics",
      options: {
        operations: ["max", "min", "values"],
        fields: () => {
          var _a;
          const fields2 = mergeFields(this.getStatisticFields(), null !== (_a = null == staticFields ? void 0 : staticFields(rawData.name)) && void 0 !== _a ? _a : []);
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), data;
  }
  createdStackData() {
    const dataName = `${this.type}_${this.id}_viewStackData`;
    this._viewStackData = new DataView(this._dataSet, {
      name: dataName
    }), this._viewStackData.parse([this._viewDataFilter], {
      type: "dataview"
    }), this._viewStackData.transform({
      type: "stackSplit",
      options: {
        fields: this.getStackGroupFields()
      }
    }, false);
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  generateDefaultDataKey(dataKey) {
    var _a;
    return isNil_default(dataKey) ? (datum, index, context) => {
      if (false === this._spec.animation) {
        const v = this._noAnimationDataKey(datum, index);
        if (void 0 !== v) return v;
      }
      const { keyMap: keyMap2 } = context, seriesDataKey = this._getSeriesDataKey(datum);
      return void 0 === keyMap2.get(seriesDataKey) ? (keyMap2.set(seriesDataKey, 0), seriesDataKey) : (keyMap2.set(seriesDataKey, keyMap2.get(seriesDataKey) + 1), `${seriesDataKey}_${keyMap2.get(seriesDataKey)}`);
    } : isString_default(dataKey) ? (datum) => datum[dataKey] : isArray_default(dataKey) && dataKey.every((d) => isString_default(d)) ? (datum) => dataKey.map((k2) => datum[k2]).join("-") : isFunction_default(dataKey) ? (datum, index) => dataKey(datum, index) : (null === (_a = this._option) || void 0 === _a || _a.onError(`invalid dataKey: ${dataKey}`), (datum, index) => {
    });
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false));
  }
  updateRawData(d) {
    this._rawData && this._rawData.updateRawData(d);
  }
  rawDataUpdate(d) {
    var _a;
    null === (_a = this._rawDataStatistics) || void 0 === _a || _a.reRunAllTransform(), this._rawStatisticsCache = null, this.event.emit(ChartEvent.rawDataUpdate, {
      model: this
    });
  }
  viewDataFilterOver(d) {
    this.event.emit(ChartEvent.viewDataFilterOver, {
      model: this
    });
  }
  viewDataUpdate(d) {
    var _a;
    this.event.emit(ChartEvent.viewDataUpdate, {
      model: this
    }), null === (_a = this._data) || void 0 === _a || _a.updateData(), this._viewDataStatistics && this._viewDataStatistics.reRunAllTransform();
  }
  viewDataStatisticsUpdate(d) {
    this.event.emit(ChartEvent.viewDataStatisticsUpdate, {
      model: this
    });
  }
  getDatumPositionValue(datum, field5) {
    return !datum || isNil_default(field5) ? null : datum[field5];
  }
  getDatumPositionValues(datum, fields2) {
    return !datum || isNil_default(fields2) ? [] : isString_default(fields2) ? [datum[fields2]] : fields2.map((f) => datum[f]);
  }
  setValueFieldToStack() {
  }
  setValueFieldToPercent() {
  }
  setValueFieldToStackOffsetSilhouette() {
  }
  initRootMark() {
    var _a, _b, _c;
    this._rootMark = this._createMark({
      type: "group",
      name: `seriesGroup_${this.type}_${this.id}`
    }, {
      parent: null === (_b = (_a = this._region).getGroupMark) || void 0 === _b ? void 0 : _b.call(_a),
      dataView: false
    }), this._rootMark.setMarkConfig({
      zIndex: null !== (_c = this._spec.zIndex) && void 0 !== _c ? _c : this.layoutZIndex
    });
  }
  _getExtensionMarkNamePrefix() {
    return `${this.type}_${this.id}_extensionMark`;
  }
  _initExtensionMark(options) {
    var _a;
    if (!this._spec.extensionMark) return;
    const mainMarks = this.getMarksWithoutRoot();
    options.depend = mainMarks, null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((m4, i) => {
      this._createExtensionMark(m4, null, this._getExtensionMarkNamePrefix(), i, options);
    });
  }
  _createExtensionMark(spec, parentMark, namePrefix, index, options) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: isValid_default(spec.name) ? `${spec.name}` : `${namePrefix}_${index}`
    }, {
      skipBeforeLayouted: true,
      markSpec: spec,
      parent: parentMark,
      dataView: false,
      componentType: spec.componentType,
      depend: options.depend,
      key: spec.dataKey
    }, {
      setCustomizedShape: null == spec ? void 0 : spec.customShape
    });
    if (mark) {
      if (isValid_default(spec.id) && mark.setUserId(spec.id), options.hasAnimation) {
        const config2 = animationConfig({}, userAnimationConfig(spec.type, spec, this._markAttributeContext));
        mark.setAnimationConfig(config2);
      }
      if ("group" === spec.type) namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s2, i) => {
        this._createExtensionMark(s2, mark, namePrefix, i, options);
      });
      else if (!(parentMark || isNil_default(spec.dataId) && isNil_default(spec.dataIndex))) {
        const dataView = this._option.getSeriesData(spec.dataId, spec.dataIndex);
        dataView === this._rawData ? mark.setDataView(this.getViewData(), this.getViewDataProductId()) : (mark.setDataView(dataView), dataView.target.addListener("change", () => {
          mark.getData().updateData();
        }));
      }
    }
  }
  _updateExtensionMarkSpec() {
    var _a;
    null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((spec, i) => {
      const mark = this._marks.getMarkWithInfo({
        name: isValid_default(spec.name) ? `${spec.name}` : `${this._getExtensionMarkNamePrefix()}_${i}`
      });
      mark && (this.initMarkStyleWithSpec(mark, spec), mark.updateStaticEncode(), mark.updateLayoutState());
    });
  }
  getStackData() {
    var _a;
    return null === (_a = this._viewStackData) || void 0 === _a ? void 0 : _a.latestData;
  }
  _parseSelectorOfInteraction(interactionSpec, marks) {
    if (!marks || !marks.length) return [];
    const selector = [];
    return interactionSpec.markIds ? marks.filter((mark) => {
      interactionSpec.markIds.includes(mark.getProductId()) && selector.push(`#${mark.getProductId()}`);
    }) : interactionSpec.markNames ? marks.forEach((mark) => {
      interactionSpec.markNames.includes(mark.name) && selector.push(`#${mark.getProductId()}`);
    }) : marks.forEach((mark) => {
      selector.push(`#${mark.getProductId()}`);
    }), selector;
  }
  _parseDefaultInteractionConfig(mainMarks) {
    if (!(null == mainMarks ? void 0 : mainMarks.length)) return [];
    const defaultConfig = getDefaultInteractionConfigByMode(this._option.mode);
    let finalHoverSpec = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.hover), finalSelectSpec = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.select);
    const hoverSpec = this._spec.hover;
    isBoolean_default(hoverSpec) ? finalHoverSpec.enable = hoverSpec : isObject_default(hoverSpec) && (finalHoverSpec.enable = true, finalHoverSpec = mergeSpec(finalHoverSpec, hoverSpec));
    const selectSpec = this._spec.select;
    isBoolean_default(selectSpec) ? finalSelectSpec.enable = selectSpec : isObject_default(selectSpec) && (finalSelectSpec.enable = true, finalSelectSpec = mergeSpec(finalSelectSpec, selectSpec));
    const res = [];
    if (finalHoverSpec.enable) {
      const selector = this._parseSelectorOfInteraction(finalHoverSpec, mainMarks);
      selector.length && res.push(this._defaultHoverConfig(selector, finalHoverSpec));
    }
    if (finalSelectSpec.enable) {
      const selector = this._parseSelectorOfInteraction(finalSelectSpec, mainMarks);
      selector.length && res.push(this._defaultSelectConfig(selector, finalSelectSpec));
    }
    return res;
  }
  _defaultHoverConfig(selector, finalHoverSpec) {
    return {
      seriesId: this.id,
      regionId: this._region.id,
      selector,
      type: "element-highlight",
      trigger: finalHoverSpec.trigger,
      triggerOff: finalHoverSpec.triggerOff,
      blurState: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
      highlightState: STATE_VALUE_ENUM.STATE_HOVER
    };
  }
  _defaultSelectConfig(selector, finalSelectSpec) {
    const isMultiple = "multiple" === finalSelectSpec.mode, triggerOff = isValid_default(finalSelectSpec.triggerOff) ? finalSelectSpec.triggerOff : isMultiple ? ["empty"] : ["empty", finalSelectSpec.trigger];
    return {
      type: "element-select",
      seriesId: this.id,
      regionId: this._region.id,
      selector,
      trigger: finalSelectSpec.trigger,
      triggerOff,
      reverseState: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
      state: STATE_VALUE_ENUM.STATE_SELECTED,
      isMultiple
    };
  }
  _parseInteractionConfig(mainMarks) {
    const compiler = this.getCompiler();
    if (!compiler) return;
    const { interactions } = this._spec, res = this._parseDefaultInteractionConfig(mainMarks);
    res && res.length && res.forEach((interaction) => {
      compiler.addInteraction(interaction);
    }), interactions && interactions.length && interactions.forEach((interaction) => {
      const selectors = this._parseSelectorOfInteraction(interaction, this.getMarks());
      selectors.length && compiler.addInteraction(Object.assign(Object.assign({}, interaction), {
        selector: selectors,
        seriesId: this.id,
        regionId: this._region.id
      }));
    });
  }
  initInteraction() {
    const marks = this.getMarksWithoutRoot();
    this._parseInteractionConfig(marks);
  }
  initAnimation() {
  }
  initMarkState() {
    this.initSeriesStyleState();
  }
  initSeriesStyleState() {
    var _a;
    const seriesStyle = this._spec.seriesStyle;
    if (!seriesStyle || !seriesStyle.length) return;
    const groupBy2 = null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD;
    this.getMarksWithoutRoot().forEach((mark) => {
      const filterMap = {}, attrMap = {}, markStyle = {};
      seriesStyle.forEach((item) => {
        var _a2;
        const style2 = null === (_a2 = item[mark.name]) || void 0 === _a2 ? void 0 : _a2.style;
        style2 && (filterMap[item.name] = true, markStyle[item.name] = markStyle[item.name] || {}, Object.keys(style2).forEach((key) => {
          attrMap[key] = true, markStyle[item.name][key] = style2[key];
        }));
      }), mark.state.addStateInfo({
        stateValue: DEFAULT_SERIES_STYLE_NAME,
        level: -1,
        filter: (datum) => Array.isArray(datum) ? 0 !== datum.length && true === filterMap[datum[0][groupBy2]] : true === filterMap[datum[groupBy2]]
      });
      const style = {};
      Object.keys(attrMap).forEach((key) => {
        style[key] = (datum) => {
          var _a2, _b;
          let style2;
          if (Array.isArray(datum)) {
            if (0 === datum.length) return;
            style2 = null === (_a2 = markStyle[datum[0][groupBy2]]) || void 0 === _a2 ? void 0 : _a2[key];
          }
          return style2 = null === (_b = markStyle[datum[groupBy2]]) || void 0 === _b ? void 0 : _b[key], isValid_default(style2) ? style2 : mark.getAttribute(key, datum);
        };
      }), this.setMarkStyle(mark, style, DEFAULT_SERIES_STYLE_NAME, AttributeLevel.User_SeriesStyle);
    });
  }
  afterInitMark() {
    this.event.emit(ChartEvent.afterInitMark, {
      model: this
    }), this.setSeriesField(this._spec.seriesField), this.getMarks().forEach((m4) => {
      var _a, _b;
      (null === (_b = null === (_a = m4.stateStyle) || void 0 === _a ? void 0 : _a.normal) || void 0 === _b ? void 0 : _b.lineWidth) && m4.setAttribute("stroke", this.getColorAttribute(), "normal", AttributeLevel.Base_Series);
    });
  }
  getMarksWithoutRoot() {
    return this.getMarks().filter((m4) => {
      var _a;
      return !(null === (_a = m4.name) || void 0 === _a ? void 0 : _a.includes("seriesGroup"));
    });
  }
  getMarksInType(type) {
    return this._marks.getMarksInType(type);
  }
  getMarkInName(name) {
    return this._marks.get(name);
  }
  getMarkInId(markId) {
    return this.getMarks().find((m4) => m4.id === markId);
  }
  initEvent() {
    var _a, _b, _c;
    null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.target.addListener("change", this.viewDataUpdate.bind(this)), null === (_c = this._viewDataStatistics) || void 0 === _c || _c.target.addListener("change", this.viewDataStatisticsUpdate.bind(this));
  }
  _releaseEvent() {
    super._releaseEvent(), this.getCompiler().removeInteraction(this.id);
  }
  initTooltip() {
    this._tooltipHelper = new BaseSeriesTooltipHelper(this);
  }
  _compareExtensionMarksSpec(newMarks, prevMarks, compareResult) {
    newMarks.length !== prevMarks.length || prevMarks.some((prev, index) => prev.type !== newMarks[index].type || prev.id !== newMarks[index].id || prev.name !== newMarks[index].name) ? compareResult.reMake = true : prevMarks.some((prev, index) => prev.visible !== newMarks[index].visible) && (compareResult.reCompile = true);
  }
  _compareLabelSpec(newLabels, prevLabels, compareResult) {
    newLabels.length !== prevLabels.length || prevLabels.some((prev, index) => prev.labelLayout !== newLabels[index].labelLayout || prev.visible !== newLabels[index].visible) ? compareResult.reMake = true : !compareResult.reCompile && prevLabels.some((prev, index) => !isEqual(prev, newLabels[index])) && (compareResult.reCompile = true);
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    const result2 = super._compareSpec(spec, prevSpec), currentKeys = Object.keys(prevSpec || {}).sort(), nextKeys = Object.keys(spec || {}).sort();
    if (!isEqual(currentKeys, nextKeys)) return result2.reMake = true, result2;
    const ignores = Object.assign(Object.assign(Object.assign(Object.assign({}, defaultSeriesIgnoreCheckKeys), defaultSeriesCompileCheckKeys), ignoreCheckKeys), {
      extensionMark: true,
      label: true,
      totalLabel: true
    });
    return this._compareExtensionMarksSpec(array(spec.extensionMark), array(prevSpec.extensionMark), result2), !result2.reMake && this._compareLabelSpec(array(spec.label), array(prevSpec.label), result2), !result2.reMake && this._compareLabelSpec(array(spec.totalLabel), array(prevSpec.totalLabel), result2), result2.reMake ? result2 : (!result2.reCompile && this._marks.getMarks().some((m4) => {
      var _a, _b;
      return ignores[m4.name] = true, (null === (_a = prevSpec[m4.name]) || void 0 === _a ? void 0 : _a.visible) !== (null === (_b = spec[m4.name]) || void 0 === _b ? void 0 : _b.visible);
    }) && (result2.reCompile = true), !result2.reCompile && currentKeys.some((k2) => defaultSeriesCompileCheckKeys[k2] && !isEqual(spec[k2], prevSpec[k2])) && (result2.reCompile = true), currentKeys.some((k2) => !ignores[k2] && !isEqual(spec[k2], prevSpec[k2])) ? (result2.reMake = true, result2) : result2);
  }
  _updateSpecData() {
    !this._rawData || !this._spec.data || this._spec.data instanceof DataView || updateDataViewInData(this._rawData, this._spec.data, true);
  }
  reInit(spec) {
    super.reInit(spec);
    const marks = this.getMarksWithoutRoot();
    marks.forEach((mark) => {
      this._spec[mark.name] && this.initMarkStyleWithSpec(mark, this._spec[mark.name]);
    }), this.initMarkStyle(), marks.forEach((mark) => {
      mark.updateStaticEncode(), mark.updateLayoutState(true);
    }), this._updateExtensionMarkSpec(), this._updateSpecData(), this._tooltipHelper && this._tooltipHelper.updateTooltipSpec();
    isAnimationEnabledForSeries(this) && this.initAnimation();
  }
  onEvaluateEnd(ctx) {
    this._data.updateData();
  }
  onRender(ctx) {
  }
  release() {
    var _a, _b, _c;
    super.release(), this._viewDataMap.clear();
    const transformIndex = null === (_b = null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.transformsArr) || void 0 === _b ? void 0 : _b.findIndex((t) => "addVChartProperty" === t.type);
    transformIndex >= 0 && this._rawData.transformsArr.splice(transformIndex, 1), null === (_c = this._data) || void 0 === _c || _c.release(), this._dataSet = this._data = this._rawData = this._rawDataStatistics = this._spec = this._region = this._viewDataStatistics = this._viewStackData = null;
  }
  setLayoutStartPosition(pos) {
    isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y);
  }
  setLayoutRect({ width, height }, levelMap) {
    isValidNumber_default(width) && (this._layoutRect.width = width), isValidNumber_default(height) && (this._layoutRect.height = height);
  }
  getSeriesKeys() {
    var _a, _b;
    return this._seriesField ? null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b;
      return null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  _getSeriesInfo(field5, keys) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys.map((key) => ({
      key,
      originalKey: key,
      style: this.getSeriesStyle({
        [field5]: key
      }),
      shapeType: defaultShapeType
    }));
  }
  getSeriesInfoInField(field5) {
    var _a, _b;
    return this._getSeriesInfo(field5, null !== (_b = null === (_a = this.getRawDataStatisticsByField(field5)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : []);
  }
  getSeriesInfoList() {
    var _a;
    return this._getSeriesInfo(null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD, this.getSeriesKeys());
  }
  _getDefaultColorScale() {
    var _a, _b;
    const colorDomain = this.getDefaultColorDomain(), colorRange = this._getDataScheme();
    return null === (_b = (_a = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _b ? void 0 : _b.call(_a, colorRange);
  }
  _getDataScheme() {
    return getDataScheme(this.getColorScheme(), this.type);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesField ? null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesField]) || void 0 === _b ? void 0 : _b.values : [];
  }
  getColorAttribute() {
    var _a, _b;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_b = this._seriesField) && void 0 !== _b ? _b : DEFAULT_DATA_SERIES_FIELD
    };
  }
  getDimensionField() {
    return [];
  }
  getMeasureField() {
    return [];
  }
  onMarkPositionUpdate() {
    this.onMarkTreePositionUpdate(this.getMarksWithoutRoot());
  }
  onMarkTreePositionUpdate(marks) {
  }
  _createMark(markInfo, option = {}, config2 = {}) {
    var _a, _b, _c, _d, _e, _f;
    const { key, groupKey, skipBeforeLayouted, themeSpec = {}, markSpec, dataView, dataProductId, parent, isSeriesMark, depend, stateSort, noSeparateStyle = false } = option, m4 = super._createMark(markInfo, {
      key: null != key ? key : this._getDataIdKey(),
      seriesId: this.id,
      attributeContext: this._markAttributeContext,
      componentType: option.componentType,
      noSeparateStyle
    });
    if (isValid_default(m4)) {
      const spec = this.getSpec() || {};
      this._marks.addMark(m4, {
        name: markInfo.name
      }), isSeriesMark && (this._seriesMark = m4), isNil_default(parent) ? null === (_a = this._rootMark) || void 0 === _a || _a.addMark(m4) : false !== parent && parent.addMark(m4), isNil_default(dataView) ? (m4.setDataView(this.getViewData(), this.getViewDataProductId()), m4.setSkipBeforeLayouted(true)) : false !== dataView && m4.setDataView(dataView, dataProductId), isBoolean_default(skipBeforeLayouted) && m4.setSkipBeforeLayouted(skipBeforeLayouted), isValid_default(depend) && m4.setDepend(...array(depend)), isNil_default(groupKey) || m4.setGroupKey(groupKey), stateSort && m4.setStateSortCallback(stateSort);
      const markConfig = Object.assign(Object.assign({}, config2), {
        morph: null !== (_b = config2.morph) && void 0 !== _b && _b,
        support3d: is3DMark(markInfo.type) || (null !== (_c = config2.support3d) && void 0 !== _c ? _c : spec.support3d || !!spec.zField),
        morphKey: (null === (_d = spec.morph) || void 0 === _d ? void 0 : _d.morphKey) || `${this.getSpecIndex()}_${this.getMarks().length}`,
        morphElementKey: null !== (_f = null === (_e = spec.morph) || void 0 === _e ? void 0 : _e.morphElementKey) && void 0 !== _f ? _f : config2.morphElementKey
      });
      m4.setMarkConfig(markConfig), this.initMarkStyleWithSpec(m4, mergeSpec({}, themeSpec, markSpec || spec[m4.name]));
    }
    return m4;
  }
  _getDataIdKey() {
    var _a;
    return null !== (_a = super._getDataIdKey()) && void 0 !== _a ? _a : DEFAULT_DATA_KEY;
  }
  _getSeriesDataKey(datum) {
    let key = "";
    if (!datum) return key;
    const dimensionFields = this.getDimensionField();
    key = dimensionFields.map((field5) => datum[field5]).join("_");
    const seriesField = this.getSeriesField();
    return seriesField && !dimensionFields.includes(seriesField) && (key += `_${datum[seriesField]}`), key;
  }
  addViewDataFilter(option) {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.transform(option, false);
  }
  reFilterViewData() {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.reRunAllTransform();
  }
  reTransformViewData() {
    var _a, _b;
    null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  fillData() {
    var _a;
    null === (_a = this.getRawData()) || void 0 === _a || _a.reRunAllTransform();
  }
  compile() {
    this.compileData();
  }
  getDefaultShapeType() {
    return "circle";
  }
  getFieldAlias(field5) {
    var _a;
    return field5 !== STACK_FIELD_END && field5 !== STACK_FIELD_END_PERCENT && field5 !== STACK_FIELD_START && field5 !== STACK_FIELD_START_PERCENT || (field5 = this.getStackValueField()), null !== (_a = getFieldAlias(this.getRawData(), field5)) && void 0 !== _a ? _a : field5;
  }
  _getInvalidConnectType() {
    return "zero" === this._invalidType ? "zero" : "link" === this._invalidType ? "connect" : "none";
  }
  _getInvalidDefined(datum) {
    const checkFields = this.getInvalidCheckFields();
    return !checkFields.length || checkFields.every((field5) => couldBeValidNumber(datum[field5]));
  }
  _getRelatedComponentSpecInfo(specKey) {
    var _a;
    const specIndex = this.getSpecIndex(), relatedComponent = null === (_a = this._option.getSpecInfo().component[specKey]) || void 0 === _a ? void 0 : _a.filter((componentInfo) => componentInfo.seriesIndexes.includes(specIndex));
    return null != relatedComponent ? relatedComponent : [];
  }
  _forEachStackGroup(callback, node) {
    var _a, _b;
    (node = null != node ? node : null === (_a = this._viewStackData) || void 0 === _a ? void 0 : _a.latestData) && ((null === (_b = node.values) || void 0 === _b ? void 0 : _b.length) ? callback(node) : node.nodes && Object.values(node.nodes).forEach((n) => {
      this._forEachStackGroup(callback, n);
    }));
  }
  isDatumInViewData(datum) {
    if (!datum) return false;
    const viewDataList = this.getViewData().latestData;
    return !!viewDataList && (!!viewDataList.includes(datum) || viewDataList.some((viewDatum) => Object.keys(datum).every((key) => datum[key] === viewDatum[key])));
  }
  getSeriesFieldValue(datum, seriesField) {
    var _a;
    return datum[null !== (_a = null != seriesField ? seriesField : this.getSeriesField()) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD];
  }
};
BaseSeries.mark = baseSeriesMark, BaseSeries.transformerConstructor = BaseSeriesSpecTransformer;

// node_modules/@visactor/vchart/esm/series/util/utils.js
function isPolarAxisSeries(type) {
  return [SeriesTypeEnum.rose, SeriesTypeEnum.radar, SeriesTypeEnum.circularProgress].includes(type);
}
function sortDataInAxisHelper(axisHelper, field5, dataList) {
  const scale4 = axisHelper.getScale(0), isRevert = "isInverse" in axisHelper && axisHelper.isInverse();
  isContinuous(scale4.type) ? dataList.sort((datumA, datumB) => (datumA[field5] - datumB[field5]) * (isRevert ? -1 : 1)) : dataList.sort((datumA, datumB) => (scale4.index(datumA[field5]) - scale4.index(datumB[field5])) * (isRevert ? -1 : 1));
}
function getGroupAnimationParams(series2) {
  return {
    dataIndex: (datum) => {
      var _a, _b;
      const indexField = "horizontal" === series2.direction ? series2.fieldY[0] : series2.fieldX[0], indexValue = null == datum ? void 0 : datum[indexField], scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).indexOf(indexValue) || 0;
    },
    dataCount: () => {
      var _a, _b, _c;
      const scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return null !== (_c = (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).length) && void 0 !== _c ? _c : 0;
    }
  };
}

// node_modules/@visactor/vchart/esm/series/cartesian/cartesian.js
var CartesianSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "cartesian", this._bandPosition = 0.5, this._scaleConfig = {
      bandPosition: this._bandPosition
    }, this._direction = "vertical", this._sortDataByAxis = false, this._getPositionXEncoder = () => {
      var _a;
      return null === (_a = this._positionXEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setPositionXEncoder = (encoder2) => {
      this._positionXEncoder = encoder2.bind(this);
    }, this._getPositionYEncoder = () => {
      var _a;
      return null === (_a = this._positionYEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setPositionYEncoder = (encoder2) => {
      this._positionYEncoder = encoder2.bind(this);
    };
  }
  _buildScaleConfig() {
    this._scaleConfig = {
      bandPosition: this._bandPosition
    };
  }
  get fieldX() {
    return this._fieldX;
  }
  setFieldX(f) {
    this._fieldX = array(f);
  }
  get fieldY() {
    return this._fieldY;
  }
  setFieldY(f) {
    this._fieldY = array(f);
  }
  get fieldZ() {
    return this._fieldZ;
  }
  setFieldZ(f) {
    this._fieldZ = f && array(f);
  }
  get fieldX2() {
    return this._fieldX2;
  }
  setFieldX2(f) {
    this._fieldX2 = f;
  }
  get fieldY2() {
    return this._fieldY2;
  }
  setFieldY2(f) {
    this._fieldY2 = f;
  }
  get direction() {
    return this._direction;
  }
  get scaleX() {
    return this._scaleX;
  }
  setScaleX(s2) {
    this._scaleX = s2;
  }
  get scaleY() {
    return this._scaleY;
  }
  setScaleY(s2) {
    this._scaleY = s2;
  }
  get scaleZ() {
    return this._scaleZ;
  }
  setScaleZ(s2) {
    this._scaleZ = s2;
  }
  getXAxisHelper() {
    return this._xAxisHelper;
  }
  setXAxisHelper(h) {
    this._xAxisHelper = h, this.onXAxisHelperUpdate();
  }
  getYAxisHelper() {
    return this._yAxisHelper;
  }
  setYAxisHelper(h) {
    this._yAxisHelper = h, this.onYAxisHelperUpdate();
  }
  getZAxisHelper() {
    return this._zAxisHelper;
  }
  setZAxisHelper(h) {
    this._zAxisHelper = h, this.onYAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  getStatisticFields() {
    const fields2 = [];
    return [{
      axisHelper: this.getXAxisHelper(),
      fields: this._fieldX2 ? [...this._fieldX, this._fieldX2] : this._fieldX
    }, {
      axisHelper: this.getYAxisHelper(),
      fields: this._fieldY2 ? [...this._fieldY, this._fieldY2] : this._fieldY
    }, {
      axisHelper: this.getZAxisHelper(),
      fields: this._fieldZ
    }].forEach((axisOption) => {
      axisOption.axisHelper && axisOption.axisHelper.getScale && axisOption.fields && axisOption.fields.forEach((f) => {
        const result2 = {
          key: f,
          operations: []
        }, scale4 = axisOption.axisHelper.getScale(0);
        isContinuous(scale4.type) ? (result2.operations = ["max", "min"], "log" === scale4.type && (result2.filter = (fv) => fv > 0)) : result2.operations = ["values"], fields2.push(result2);
      });
    }), this.getStack() && fields2.push({
      key: this.getStackValueField(),
      operations: ["allValid"]
    }), fields2;
  }
  getGroupFields() {
    return "vertical" === this.direction ? this._fieldX : this._fieldY;
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getStackValue() {
    var _a, _b;
    const axisId = null === (_a = "horizontal" === this.direction ? this.getXAxisHelper() : this.getYAxisHelper()) || void 0 === _a ? void 0 : _a.getAxisId();
    return null !== (_b = this._spec.stackValue) && void 0 !== _b ? _b : `${PREFIX}_series_${this.type}_${axisId}`;
  }
  getStackValueField() {
    return "horizontal" === this.direction ? array(this._spec.xField)[0] : array(this._spec.yField)[0];
  }
  setValueFieldToStack() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END), this.setFieldX2(STACK_FIELD_START)) : (this.setFieldY(STACK_FIELD_END), this.setFieldY2(STACK_FIELD_START));
  }
  setValueFieldToPercent() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END_PERCENT), this.setFieldX2(STACK_FIELD_START_PERCENT)) : (this.setFieldY(STACK_FIELD_END_PERCENT), this.setFieldY2(STACK_FIELD_START_PERCENT));
  }
  setValueFieldToStackOffsetSilhouette() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END_OffsetSilhouette), this.setFieldX2(STACK_FIELD_START_OffsetSilhouette)) : (this.setFieldY(STACK_FIELD_END_OffsetSilhouette), this.setFieldY2(STACK_FIELD_START_OffsetSilhouette));
  }
  onXAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onYAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onZAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setFieldX(this._spec.xField), this.setFieldY(this._spec.yField), this.setFieldZ(this._spec.zField), this._specXField = array(this._spec.xField), this._specYField = array(this._spec.yField), isValid_default(this._spec.direction) && (this._direction = this._spec.direction), this.setFieldX2(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.x2Field), this.setFieldY2(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.y2Field), this.getStack() && this.setValueFieldToStack(), this.getPercent() && this.setValueFieldToPercent(), this.getStackOffsetSilhouette() && this.setValueFieldToStackOffsetSilhouette(), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  dataToPosition(datum, checkInViewData) {
    return datum ? checkInViewData && !this.isDatumInViewData(datum) ? null : {
      x: this.dataToPositionX(datum),
      y: this.dataToPositionY(datum)
    } : null;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToX = this.valueToPositionX.bind(this), this._markAttributeContext.valueToY = this.valueToPositionY.bind(this), this._markAttributeContext.xBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getXAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.yBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getYAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this);
  }
  valueToPosition(xValue, yValue) {
    return {
      x: this.valueToPositionX(xValue),
      y: this.valueToPositionY(yValue)
    };
  }
  _axisPosition(helper, value, datum) {
    return this._scaleConfig.datum = datum, helper.isContinuous ? helper.valueToPosition(value, this._scaleConfig) : helper.dataToPosition(array(value), this._scaleConfig);
  }
  valueToPositionX(value, datum) {
    return this._axisPosition(this._xAxisHelper, value, datum);
  }
  valueToPositionY(value, datum) {
    return this._axisPosition(this._yAxisHelper, value, datum);
  }
  _dataToPosition(datum, axisHelper, field5, scaleDepth, getEncoder, setEncoder) {
    const encoder2 = getEncoder();
    if (encoder2) return encoder2(datum);
    if (!axisHelper) return setEncoder((datum2) => Number.NaN), Number.NaN;
    const fields2 = (axisHelper.getFields ? axisHelper.getFields() : field5).slice(0, scaleDepth);
    return fields2 && 0 !== fields2.length ? (axisHelper.isContinuous ? setEncoder((datum2) => (this._scaleConfig.datum = datum2, axisHelper.valueToPosition(this.getDatumPositionValue(datum2, fields2[0]), this._scaleConfig))) : setEncoder((datum2) => (this._scaleConfig.datum = datum2, axisHelper.dataToPosition(array(this.getDatumPositionValues(datum2, fields2)), this._scaleConfig))), getEncoder()(datum)) : (setEncoder((datum2) => null), null);
  }
  dataToPositionX(datum) {
    return this._dataToPosition(datum, this._xAxisHelper, this.fieldX, void 0, this._getPositionXEncoder, this._setPositionXEncoder);
  }
  dataToPositionY(datum) {
    return this._dataToPosition(datum, this._yAxisHelper, this.fieldY, void 0, this._getPositionYEncoder, this._setPositionYEncoder);
  }
  dataToPositionZ(datum) {
    if (!this._zAxisHelper) return Number.NaN;
    const { dataToPosition } = this._zAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldZ), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionX1(datum) {
    return this._xAxisHelper ? this._fieldX2 && this._fieldX2 in datum ? this.valueToPositionX(this.getDatumPositionValues(datum, this._fieldX2)) : this.valueToPositionX(0) : Number.NaN;
  }
  dataToPositionY1(datum) {
    return this._yAxisHelper ? this._fieldY2 && this._fieldY2 in datum ? this.valueToPositionY(this.getDatumPositionValues(datum, this._fieldY2)) : this.valueToPositionY(0) : Number.NaN;
  }
  positionToData(p) {
    return p ? {
      x: this.positionToDataX(p.x),
      y: this.positionToDataY(p.y)
    } : null;
  }
  positionToDataX(xPos) {
    return this._scaleX ? this._scaleX.invert(xPos) : null;
  }
  positionToDataY(yPos) {
    return this._scaleY ? this._scaleY.invert(yPos) : null;
  }
  getRegionRectLeft() {
    if (!this._xAxisHelper) return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[0];
  }
  getRegionRectRight() {
    if (!this._xAxisHelper) return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[1];
  }
  afterInitMark() {
    super.afterInitMark(), this.setFieldX(this._fieldX), this.setFieldY(this._fieldY), this._buildScaleConfig();
  }
  getDimensionField() {
    return "horizontal" === this._direction ? this._specYField : this._specXField;
  }
  getDimensionContinuousField() {
    return "horizontal" === this._direction ? [this.fieldY[0], this.fieldY2] : [this.fieldX[0], this.fieldX2];
  }
  getMeasureField() {
    return "horizontal" === this._direction ? this._specXField : this._specYField;
  }
  initEvent() {
    super.initEvent(), this.sortDataByAxis && this.event.on(ChartEvent.scaleDomainUpdate, {
      filter: (param) => {
        var _a;
        return param.model.id === (null === (_a = "horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper) || void 0 === _a ? void 0 : _a.getAxisId());
      }
    }, () => {
      this._sortDataInAxisDomain();
    });
  }
  _sortDataInAxisDomain() {
    var _a, _b, _c;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && (sortDataInAxisHelper("horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper, "horizontal" === this._direction ? this._fieldY[0] : this._fieldX[0], this.getViewData().latestData), null === (_c = this._data) || void 0 === _c || _c.updateData(true));
  }
  getInvalidCheckFields() {
    const fields2 = [];
    if (this._xAxisHelper && this._xAxisHelper.isContinuous && this._xAxisHelper.getAxisType() !== ComponentTypeEnum.geoCoordinate) {
      (this._xAxisHelper.getFields ? this._xAxisHelper.getFields() : this._specXField).forEach((f) => {
        fields2.push(f);
      });
    }
    if (this._yAxisHelper && this._yAxisHelper.isContinuous && this._yAxisHelper.getAxisType() !== ComponentTypeEnum.geoCoordinate) {
      (this._yAxisHelper.getFields ? this._yAxisHelper.getFields() : this._specYField).forEach((f) => {
        fields2.push(f);
      });
    }
    return fields2;
  }
  reInit(spec) {
    this._positionXEncoder && (this._positionXEncoder = null), this._positionYEncoder && (this._positionYEncoder = null), super.reInit(spec);
  }
};

// node_modules/@visactor/vchart/esm/typings/interpolate.js
var DEFAULT_SMOOTH_INTERPOLATE = "monotone";
var DEFAULT_LINEAR_INTERPOLATE = "linear";

// node_modules/@visactor/vchart/esm/typings/line-stroke.js
var DEFAULT_CLOSE_STROKE_JOIN = "bevel";

// node_modules/@visactor/vchart/esm/series/mixin/constant.js
var lineLikeSeriesMark = {
  point: {
    name: "point",
    type: "symbol"
  },
  line: {
    name: "line",
    type: "line"
  }
};

// node_modules/@visactor/vchart/esm/series/mixin/line-mixin.js
var LineLikeSeriesMixin = class {
  addSamplingCompile() {
    if (this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "horizontal" === this._direction ? height : width,
        factor: this._spec.samplingFactor,
        yfield: "horizontal" === this._direction ? fieldsX[0] : fieldsY[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  addOverlapCompile() {
    var _a;
    if (this._spec.markOverlap) {
      const overlapTrans = [];
      overlapTrans.push({
        type: "markoverlap",
        direction: "horizontal" === this._direction && "cartesian" === this.coordinate ? 2 : 1,
        delta: this._spec.pointDis,
        deltaMul: this._spec.pointDisMul,
        groupBy: this._seriesField
      }), null === (_a = this._symbolMark) || void 0 === _a || _a.getProduct().transform(overlapTrans);
    }
  }
  reCompileSampling() {
    this._spec.sampling && this.compile();
  }
  initLineMark(progressive, isSeriesMark) {
    var _a, _b;
    return this._lineMark = this._createMark(lineLikeSeriesMark.line, {
      groupKey: this._seriesField,
      isSeriesMark: null == isSeriesMark || isSeriesMark,
      stateSort: null === (_a = this._spec.line) || void 0 === _a ? void 0 : _a.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      setCustomizedShape: null === (_b = this._spec.line) || void 0 === _b ? void 0 : _b.customShape,
      morphElementKey: this.getDimensionField()[0]
    })), this._lineMark;
  }
  initLineMarkStyle(direction, areaCurveType) {
    var _a, _b;
    const lineMark = this._lineMark;
    if (lineMark) {
      if (this.setMarkStyle(lineMark, {
        stroke: this.getColorAttribute()
      }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(lineMark, {
        defined: this._getInvalidDefined.bind(this),
        connectedType: this._getInvalidConnectType()
      }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
        filter: (param) => param.model === this
      }, () => {
        this.encodeDefined(lineMark, "defined");
      }), "polar" === this.coordinate) this.setMarkStyle(lineMark, {
        lineJoin: DEFAULT_CLOSE_STROKE_JOIN,
        curveType: DEFAULT_LINEAR_INTERPOLATE,
        closePath: true
      }, "normal", AttributeLevel.Series);
      else {
        const userCurveType = null != areaCurveType ? areaCurveType : null === (_b = null === (_a = this.getSpec().line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "horizontal" === direction ? "monotoneY" : "monotoneX" : userCurveType;
        this.setMarkStyle(lineMark, {
          curveType
        }, "normal", AttributeLevel.Built_In);
      }
      this.setMarkStyle(lineMark, {
        x: this.dataToPositionX.bind(this),
        y: this.dataToPositionY.bind(this),
        z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
      }, "normal", AttributeLevel.Series);
    }
    return lineMark;
  }
  _getEventElement(params2, reverse = false) {
    let data = [];
    return params2.dimensionInfo.some((df) => (df.data.some((dd) => dd.series === this && (data = dd.datum, true)), !data.length)), data;
  }
  _dimensionTrigger(params2) {
    const elements = this._getEventElement(params2);
    switch (params2.action) {
      case "enter":
        this._symbolActiveMark.getDataView().parse(elements), this._symbolActiveMark.getData().updateData(false);
        break;
      case "leave":
        this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(false);
    }
  }
  initSymbolMark(progressive, isSeriesMark) {
    const pointSpec = this._spec.point || {};
    if (false !== pointSpec.visible && (this._symbolMark = this._createMark(lineLikeSeriesMark.point, {
      groupKey: this._seriesField,
      isSeriesMark: !!isSeriesMark,
      stateSort: pointSpec.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      setCustomizedShape: pointSpec.customShape,
      morph: shouldMarkDoMorph(this._spec, lineLikeSeriesMark.point.name),
      morphElementKey: this.getDimensionField()[0]
    }))), true === this._spec.activePoint) {
      const activeData = new DataView(this._option.dataSet, {
        name: `${PREFIX}_series_${this.id}_active_point`
      });
      activeData.parse([]), this._symbolActiveMark = this._createMark({
        name: `active_point_${this.id}`,
        type: "symbol"
      }, {
        groupKey: this._seriesField,
        isSeriesMark: false,
        dataView: activeData,
        parent: this._region.getInteractionMark(),
        stateSort: pointSpec.stateSort
      }, {
        setCustomizedShape: pointSpec.customShape,
        morph: false
      }), this._symbolActiveMark.setVisible(false);
    }
    return this._symbolMark;
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    if (!symbolMark) return this._initSymbolActiveMarkAlone(), symbolMark;
    if (this._initSymbolMark(symbolMark), this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover) {
      this._symbolActiveMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this));
      for (const state in this._symbolMark.stateStyle) {
        this._symbolActiveMark.stateStyle[state] = {};
        for (const key in this._symbolMark.stateStyle[state]) "visible" !== key && (this._symbolActiveMark.stateStyle[state][key] = {
          style: null,
          level: AttributeLevel.Series,
          referer: symbolMark
        });
      }
      this._symbolActiveMark.state.changeStateInfo({
        stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
        filter: () => true
      });
    }
    return symbolMark;
  }
  _initSymbolMark(symbolMark) {
    symbolMark && (this.setMarkStyle(symbolMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), this.setMarkStyle(symbolMark, {
      x: (datum) => "zero" === this._invalidType || this._getInvalidDefined(datum) ? this.dataToPositionX(datum) : Number.NaN,
      y: (datum) => "zero" === this._invalidType || this._getInvalidDefined(datum) ? this.dataToPositionY(datum) : Number.NaN,
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, "normal", AttributeLevel.Series));
  }
  _initSymbolActiveMarkAlone() {
    var _a, _b;
    const symbolMark = this._symbolActiveMark;
    symbolMark && (this._initSymbolMark(symbolMark), symbolMark && (null === (_b = null === (_a = this._spec[lineLikeSeriesMark.point.name]) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.dimension_hover) && (symbolMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this)), this.initMarkStyleWithSpec(symbolMark, mergeSpec({}, this._spec[lineLikeSeriesMark.point.name], {
      visible: true
    })), this._symbolActiveMark.state.changeStateInfo({
      stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
      filter: () => true
    })));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    labelMark && ("symbol" !== (null === (_a = labelMark.getTarget()) || void 0 === _a ? void 0 : _a.type) && labelMark.setRule("line-data"), this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined.bind(this)
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(labelMark, "visible");
    }));
  }
  initLineLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => {
        var _a;
        return null !== (_a = datum[this.getSeriesField()]) && void 0 !== _a ? _a : this.getSeriesKeys()[0];
      },
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  encodeDefined(mark, attr) {
    var _a, _b, _c, _d;
    if (!mark) return;
    const allValid = this._isFieldAllValid();
    if ("zero" === this._invalidType || allValid) {
      if (true === (null === (_b = null === (_a = mark.stateStyle.normal) || void 0 === _a ? void 0 : _a[attr]) || void 0 === _b ? void 0 : _b.style)) return;
      this.setMarkStyle(mark, {
        [attr]: true
      }, "normal", AttributeLevel.Series);
    } else {
      if (true !== (null === (_d = null === (_c = mark.stateStyle.normal) || void 0 === _c ? void 0 : _c[attr]) || void 0 === _d ? void 0 : _d.style)) return;
      this.setMarkStyle(mark, {
        [attr]: this._getInvalidDefined.bind(this)
      }, "normal", AttributeLevel.Series);
    }
    mark.getProduct() && mark.compileEncode();
  }
  _isFieldAllValid() {
    const viewStatistics = this.getViewDataStatistics(), field5 = this.getStackValueField();
    return !!(viewStatistics && viewStatistics.latestData && field5) && (viewStatistics.latestData[field5] && viewStatistics.latestData[field5].allValid);
  }
};

// node_modules/@visactor/vchart/esm/series/line/constant.js
var lineSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark);

// node_modules/@visactor/vchart/esm/mark/base/base-line.js
var BaseLineMark = class extends BaseMark {
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style)) return;
    void 0 === stateStyle[state] && (stateStyle[state] = {});
    const ignoreAttributes = this._getIgnoreAttributes(), segmentAttributes = ["strokeWidth", "lineWidth", "lineDash", "strokeDash", "lineJoin", "stroke", "strokeOpacity", "opacity", "fill", "fillOpacity", "texture", "texturePadding", "textureSize", "textureColor"], isUserLevel = this.isUserLevel(level);
    let enableSegments = false;
    Object.keys(style).forEach((attr) => {
      const attrStyle = style[attr];
      if (isNil_default(attrStyle) || ignoreAttributes.includes(attr)) return;
      isUserLevel && segmentAttributes.includes(attr) && (isValidScaleType(null == attrStyle ? void 0 : attrStyle.type) || (null == attrStyle ? void 0 : attrStyle.scale) || isFunction_default(attrStyle)) && (enableSegments = true);
      const styleConverter = this._filterAttribute(attr, attrStyle, state, level, isUserLevel, stateStyle);
      this.setAttribute(attr, styleConverter, state, level, stateStyle);
    }), enableSegments && this.setMarkConfig({
      enableSegments: true
    });
  }
};

// node_modules/@visactor/vchart/esm/mark/line.js
var LineMark = class _LineMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _LineMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 1
    });
  }
  _getIgnoreAttributes() {
    var _a, _b;
    return (null === (_a = this.model) || void 0 === _a ? void 0 : _a.type) === SeriesTypeEnum.radar && "polar" === (null === (_b = this.model) || void 0 === _b ? void 0 : _b.coordinate) ? [] : ["fill", "fillOpacity"];
  }
};
LineMark.type = "line";
var registerLineMark = () => {
  Factory2.registerMark(LineMark.type, LineMark), registerLineGraphic2(), registerVGrammarLineOrAreaAnimation();
};

// node_modules/@visactor/vchart/esm/mark/symbol.js
var BaseSymbolMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      size: 1,
      symbolType: "circle",
      fill: void 0,
      lineWidth: 0
    });
  }
};
var SymbolMark = class _SymbolMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _SymbolMark.type;
  }
};
SymbolMark.type = "symbol";
var registerSymbolMark = () => {
  Factory2.registerMark(SymbolMark.type, SymbolMark), registerSymbolGraphic2();
};

// node_modules/@visactor/vchart/esm/series/mixin/line-mixin-transformer.js
var LineLikeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible) ? this._addMarkLabelSpec(spec, "point") : this._addMarkLabelSpec(spec, "line"), this._addMarkLabelSpec(spec, "line", "lineLabel", "initLineLabelMarkStyle", void 0, true);
  }
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync/zero-align-transform.js
function isValidAlignDomain(domain) {
  return domain.length >= 2 && isValidNumber_default(domain[0]) && isValidNumber_default(last(domain)) && last(domain) >= domain[0];
}
function getScaleInfo(axis2, domain) {
  var _a;
  const total = last(domain) - domain[0], includeZero = last(domain) * domain[0] < 0;
  let negative = domain[0] <= 0 ? 0 - domain[0] : 0, positive = last(domain) > 0 ? last(domain) - 0 : 0;
  0 === total ? domain[0] < 0 ? (negative = 1, positive = 0) : domain[0] > 0 && (negative = 0, positive = 1) : (negative /= total, positive /= total);
  const domainSpec = axis2.getDomainSpec(), result2 = {
    total,
    negative,
    positive,
    includeZero,
    domain,
    extendable_min: !isValidNumber_default(domainSpec.min),
    extendable_max: !isValidNumber_default(domainSpec.max)
  };
  if (null === (_a = axis2._break) || void 0 === _a ? void 0 : _a.scope) {
    const index = domain.findIndex((value) => value >= 0);
    let scope, domainTemp;
    0 === index ? (scope = axis2._break.scope[index], domainTemp = [domain[0], domain[1]], result2.positive = 1, result2.negative = 0) : last(domain) <= 0 ? (result2.positive = 0, result2.negative = 1, domainTemp = [domain[domain.length - 2], domain[domain.length - 1]]) : (scope = axis2._break.scope[index - 1], domainTemp = [domain[index - 1], domain[index]], result2.negative = scope[0] + (0 - domainTemp[0]) / (domainTemp[1] - domainTemp[0]) * (scope[1] - scope[0]), result2.positive = 1 - result2.negative), result2.break = true, result2.extendable_max = false, result2.extendable_min = false, result2.domain = domainTemp;
  }
  return result2;
}
function inDifferentCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, domain: domain2 } = info2;
  if (positive2 > 0) {
    if (!s2Extendable_min) return false;
    let comp = negative1 / positive1;
    s1Extendable_max && (comp = negative1 / Math.max(positive1, positive2), domain1[1] = -domain1[0] / comp), domain2[0] = -domain2[1] * comp;
  } else if (negative2 > 0) {
    if (!s2Extendable_max) return false;
    let comp = positive1 / negative1;
    s1Extendable_min && (comp = positive1 / Math.max(negative1, negative1), domain1[0] = -domain1[1] / comp), domain2[1] = -domain2[0] * comp;
  }
  return true;
}
function inOnlyZeroDomain(info1, info2) {
  const { extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, domain: domain2 } = info2;
  return (0 !== positive2 || 0 !== negative2) && (!(positive2 > 0 && !s1Extendable_max) && (!(negative2 > 0 && !s1Extendable_min) && (domain1[0] = domain2[0], domain1[1] = domain2[1], true)));
}
function inAllCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, domain: domain2 } = info2;
  if (s1Extendable_max && s2Extendable_min) {
    const comp = Math.max(negative1, negative2) / Math.max(positive1, positive2);
    domain1[1] = -domain1[0] / comp, domain2[0] = -domain2[1] * comp;
  } else if (s2Extendable_min) {
    const comp = negative1 / positive1;
    domain2[0] = -domain2[1] * comp;
  } else {
    if (!s1Extendable_max) return false;
    {
      const comp = negative2 / positive2;
      domain1[1] = -domain1[0] / comp;
    }
  }
  return true;
}
function inNoCrossDifferentSide(info1, info2) {
  const { extendable_min: s1Extendable_min, domain: domain1 } = info1, { extendable_max: s2Extendable_max, domain: domain2 } = info2;
  return !(!s1Extendable_min || !s2Extendable_max) && (domain1[0] = -domain1[1], domain2[1] = -domain2[0], true);
}
var zeroAlign = (targetAxis, currentAxis) => {
  var _a, _b, _c, _d, _e, _f;
  const s1 = targetAxis.getScale(), s2 = currentAxis.getScale();
  if (!s1 || !s2) return;
  const domain1 = null !== (_c = null === (_b = (_a = targetAxis).getDomainAfterSpec) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : [0, 1], domain2 = null !== (_f = null === (_e = (_d = currentAxis).getDomainAfterSpec) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : [0, 1];
  if (!(domain1 && domain2 && isValidAlignDomain(domain1) && isValidAlignDomain(domain2))) return;
  const info1 = getScaleInfo(targetAxis, domain1), info2 = getScaleInfo(currentAxis, domain2);
  if (true === info1.break && true === info2.break) return;
  const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, includeZero: includeZero1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, includeZero: includeZero2 } = info2;
  if (0 === positive1 && 0 === negative1) {
    if (!inOnlyZeroDomain(info1, info2)) return;
  } else if (0 === positive2 && 0 === negative2) {
    if (!inOnlyZeroDomain(info2, info1)) return;
  } else if (includeZero1 || includeZero2) if (includeZero1 && !includeZero2) {
    if (!inDifferentCrossZero(info1, info2)) return;
  } else if (includeZero2 && !includeZero1) {
    if (!inDifferentCrossZero(info2, info1)) return;
  } else {
    if (negative1 === negative2) return;
    if (negative1 > negative2) {
      if (!inAllCrossZero(info1, info2)) return;
    } else if (!inAllCrossZero(info2, info1)) return;
  }
  else {
    if (0 === negative1 && 0 === positive2) {
      if (!inNoCrossDifferentSide(info1, info2)) return;
    } else if (0 === negative2 && 0 === positive1 && !inNoCrossDifferentSide(info2, info1)) return;
    if (0 === negative1 && 0 === negative2) if (0 === domain1[0] && domain2[0] > 0) {
      if (!s2Extendable_min) return;
      domain2[0] = 0;
    } else {
      if (!(0 === domain2[0] && domain1[0] > 0)) return;
      if (!s1Extendable_min) return;
      domain1[0] = 0;
    }
    if (0 === positive1 && 0 === positive2) if (0 === domain1[1] && domain2[1] > 0) {
      if (!s2Extendable_max) return;
      domain2[1] = 0;
    } else {
      if (!(0 === domain2[1] && domain1[1] > 0)) return;
      if (!s1Extendable_max) return;
      domain1[1] = 0;
    }
  }
  s1.domain(domain1), s2.domain(domain2);
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync/tick-align-transform.js
function saveTick(value, minInput, inputRange, minOutput, outputRange) {
  const sub = precisionSub(value, minInput), decimalPlaces = Math.max(getDecimalPlaces(inputRange), getDecimalPlaces(sub));
  return outputRange * (Math.round(sub * 10 ** decimalPlaces) / Math.round(inputRange * 10 ** decimalPlaces)) + minOutput;
}
var tickAlign = (data, op) => {
  var _a, _b, _c, _d, _e;
  if (!data) return data;
  const targetAxis = null === (_a = null == op ? void 0 : op.targetAxis) || void 0 === _a ? void 0 : _a.call(op);
  if (!targetAxis) return data;
  const currentAxis = null === (_b = null == op ? void 0 : op.currentAxis) || void 0 === _b ? void 0 : _b.call(op);
  if (!currentAxis) return data;
  const currentData = null === (_c = currentAxis.getTickData()) || void 0 === _c ? void 0 : _c.getDataView();
  if (!currentData) return data;
  if (!currentData.transformsArr.find((t) => t.type.includes("ticks"))) return data;
  const currentScale = currentAxis.getScale();
  if (!currentScale) return data;
  const targetData = null === (_e = null === (_d = targetAxis.getTickData()) || void 0 === _d ? void 0 : _d.getDataView()) || void 0 === _e ? void 0 : _e.latestData;
  if (!(null == targetData ? void 0 : targetData.length)) return data;
  const targetScale = targetAxis.getScale();
  if (!targetScale) return data;
  const targetDomain = targetScale.domain(), targetRange = last(targetDomain) - targetDomain[0];
  if (0 === targetRange) return data;
  const currentDomain = currentScale.domain(), currentRange = last(currentDomain) - currentDomain[0];
  if (0 === targetRange) return data;
  const newTicks = targetData.map((d) => saveTick(d.value, targetDomain[0], targetRange, currentDomain[0], currentRange));
  return convertDomainToTickData(newTicks);
};

// node_modules/@visactor/vchart/esm/plugin/base/base-plugin.js
var BasePlugin = class {
  constructor(type) {
    this.id = createID(), this.name = `${type}_${this.id}`;
  }
  onAdd(service) {
    this.service = service;
  }
  release() {
    this.service = null;
  }
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync/axis-sync.js
var AxisSyncPlugin = class _AxisSyncPlugin extends BasePlugin {
  constructor() {
    super(_AxisSyncPlugin.type), this.type = "AxisSyncPlugin";
  }
  _checkEnableSync(axis2) {
    if (!isContinuous(axis2.getScale().type)) return false;
    const sync = axis2.getSpec().sync;
    return !!(null == sync ? void 0 : sync.axisId) && sync;
  }
  _getTargetAxis(axis2, sync) {
    const targetAxis = axis2.getOption().getChart().getComponentByUserId(sync.axisId);
    return (null == targetAxis ? void 0 : targetAxis.type.startsWith("cartesianAxis")) ? targetAxis : null;
  }
  onInit(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync) return;
    if (!sync.zeroAlign) return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    targetAxis && axis2.event.on(ChartEvent.scaleDomainUpdate, {
      filter: ({ model }) => model.id === axis2.id || model.id === targetAxis.id
    }, () => {
      zeroAlign(targetAxis, axis2);
    });
  }
  onDidCompile(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync) return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    if (targetAxis && sync.tickAlign) {
      registerDataSetInstanceTransform(axis2.getOption().dataSet, "tickAlign", tickAlign);
      const opt = {
        targetAxis: () => targetAxis,
        currentAxis: () => axis2
      };
      axis2.addTransformToTickData({
        type: "tickAlign",
        options: opt,
        level: Number.MAX_SAFE_INTEGER
      }, false);
    }
  }
};
AxisSyncPlugin.pluginType = "component", AxisSyncPlugin.type = "AxisSyncPlugin";

// node_modules/@visactor/vchart/esm/component/axis/util.js
var DEFAULT_TITLE_STYLE = {
  left: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  right: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  radius: {},
  angle: {}
};
function transformAxisLineStyle(lineCfg) {
  return (lineCfg = transformComponentStyle(lineCfg)).startSymbol = transformComponentStyle(lineCfg.startSymbol), lineCfg.endSymbol = transformComponentStyle(lineCfg.endSymbol), lineCfg;
}
function getAxisLabelOffset(axisSpec) {
  let labelOffset = 0;
  return get_default(axisSpec, "tick.visible") && (labelOffset += get_default(axisSpec, "tick.tickSize")), get_default(axisSpec, "label.visible") && (labelOffset += get_default(axisSpec, "label.space")), labelOffset;
}
function getLinearAxisSpecDomain(axisSpec, defaultDomain) {
  var _a, _b, _c, _d, _e, _f;
  return {
    min: null !== (_c = null !== (_a = axisSpec.min) && void 0 !== _a ? _a : null === (_b = axisSpec.range) || void 0 === _b ? void 0 : _b.min) && void 0 !== _c ? _c : null == defaultDomain ? void 0 : defaultDomain.min,
    max: null !== (_f = null !== (_d = axisSpec.max) && void 0 !== _d ? _d : null === (_e = axisSpec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null == defaultDomain ? void 0 : defaultDomain.max
  };
}
function isValidCartesianAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "top" === orient || "bottom" === orient || "left" === orient || "right" === orient || "z" === orient;
}
function isValidPolarAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "angle" === orient || "radius" === orient;
}
var getCartesianAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : ["linear", "log", "symlog"].includes(type) ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = isXAxis(orient) ? getComponentThemeFromOption("axisX", chartTheme) : isYAxis(orient) ? getComponentThemeFromOption("axisY", chartTheme) : getComponentThemeFromOption("axisZ", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var getPolarAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : "linear" === type ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = getComponentThemeFromOption("angle" === orient ? "axisAngle" : "axisRadius", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var isDiscreteAxis = (axisType) => "band" === axisType || "ordinal" === axisType || "point" === axisType;
function getAxisItem(value, normalizedValue) {
  return {
    id: value,
    label: value,
    value: normalizedValue,
    rawValue: value
  };
}
function shouldUpdateAxis(preHelper, curHelper, forceUpdate) {
  return forceUpdate || !preHelper || preHelper.getAxisId() === curHelper.getAxisId();
}

// node_modules/@visactor/vchart/esm/plugin/components/plugin-service.js
var ComponentPluginService = class extends BasePluginService {
  constructor(component2) {
    super(), this.component = component2;
  }
  releaseAll() {
    super.releaseAll(), this.component = null;
  }
};

// node_modules/@visactor/vchart/esm/component/crosshair/utils/common.js
function limitTagInBounds(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1, y1, x2, y2 } = shape.AABBBounds, { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  let dx = 0, dy = 0;
  x1 < regionMinX && (dx = regionMinX - x1), y1 < regionMinY && (dy = regionMinY - y1), x2 > regionMaxX && (dx = regionMaxX - x2), y2 > regionMaxY && (dy = regionMaxY - y2), dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}
function getDatumByValue(data, value, startField, endField) {
  for (let i = 0, len = data.length; i < len; i++) {
    const record = data[i];
    if (record) {
      const startValue = record[startField], endValue = record[endField || startField];
      if (startValue <= value && endValue >= value) return record;
    }
  }
  return null;
}
var getCartesianCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, xField, yField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, xAxis = axes.find((axis2) => isXAxis(axis2.orient));
  let newXField;
  newXField = isValid_default(xAxis) ? mergeSpec({}, isDiscreteAxis(xAxis.type) ? bandField : linearField, xField) : xField;
  const yAxis = axes.find((axis2) => isYAxis(axis2.orient));
  let newYField;
  return newYField = isValid_default(yAxis) ? mergeSpec({}, isDiscrete(yAxis.type) ? bandField : linearField, yField) : yField, {
    xField: newXField,
    yField: newYField
  };
};
var getPolarCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, categoryField, valueField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, angleAxis = axes.find((axis2) => "angle" === axis2.orient);
  let newAngleField;
  newAngleField = isValid_default(angleAxis) ? mergeSpec({}, isDiscreteAxis(angleAxis.type) ? bandField : linearField, categoryField) : categoryField;
  const radiusAxis = axes.find((axis2) => "radius" === axis2.orient);
  let newRadiusField;
  return newRadiusField = isValid_default(radiusAxis) ? mergeSpec({}, isDiscrete(radiusAxis.type) ? bandField : linearField, valueField) : valueField, {
    categoryField: newAngleField,
    valueField: newRadiusField
  };
};

// node_modules/@visactor/vchart/esm/component/base/util.js
function getComponentThemeFromGlobalTheme(type, chartTheme, componentSpec, chartSpec) {
  switch (type) {
    case ComponentTypeEnum.cartesianBandAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "band", chartTheme);
    case ComponentTypeEnum.cartesianLinearAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "linear", chartTheme);
    case ComponentTypeEnum.cartesianLogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "log", chartTheme);
    case ComponentTypeEnum.cartesianSymlogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "symlog", chartTheme);
    case ComponentTypeEnum.cartesianAxis:
    case ComponentTypeEnum.cartesianTimeAxis:
      return getCartesianAxisTheme(getOrient(componentSpec), void 0, chartTheme);
    case ComponentTypeEnum.polarBandAxis:
      return getPolarAxisTheme(componentSpec.orient, "band", chartTheme);
    case ComponentTypeEnum.polarLinearAxis:
      return getPolarAxisTheme(componentSpec.orient, "linear", chartTheme);
    case ComponentTypeEnum.polarAxis:
      return getPolarAxisTheme(componentSpec.orient, void 0, chartTheme);
    case ComponentTypeEnum.cartesianCrosshair:
      return getCartesianCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.polarCrosshair:
      return getPolarCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.colorLegend:
    case ComponentTypeEnum.sizeLegend:
    case ComponentTypeEnum.discreteLegend:
    case ComponentTypeEnum.dataZoom:
    case ComponentTypeEnum.scrollBar:
      return getComponentThemeWithDirection(componentSpec, getComponentThemeFromOption(type, chartTheme));
    default:
      return getComponentThemeFromOption(type, chartTheme);
  }
}
var getComponentThemeWithDirection = (componentSpec, originalTheme) => {
  var _a;
  const orient = null !== (_a = componentSpec.orient) && void 0 !== _a ? _a : originalTheme.orient, directionTheme = originalTheme[getDirectionByOrient(orient)], finalTheme = mergeSpec({}, originalTheme, directionTheme);
  return delete finalTheme.horizontal, delete finalTheme.vertical, finalTheme;
};

// node_modules/@visactor/vchart/esm/component/base/base-component-transformer.js
var BaseComponentSpecTransformer = class extends BaseModelSpecTransformer {
  getTheme(spec, chartSpec) {
    return getComponentThemeFromGlobalTheme(this.type, this._option.getTheme(), spec, chartSpec);
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const { spec: newSpec, theme: theme2 } = super._mergeThemeToSpec(spec, chartSpec);
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
  _adjustPadding(spec) {
    const { padding, noOuterPadding = true, orient } = spec;
    noOuterPadding && padding && orient && (spec.padding = Object.assign(Object.assign({}, normalizeLayoutPaddingSpec(padding)), {
      [orient]: 0
    }));
  }
};

// node_modules/@visactor/vchart/esm/component/base/base-component.js
var __rest20 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseComponent = class extends LayoutModel {
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest20(specInfo, ["spec"]);
    return new this(spec, Object.assign(Object.assign({}, options), others));
  }
  getRegions() {
    return this._regions;
  }
  created() {
    super.created(), this.initLayout(), this.pluginService = new ComponentPluginService(this);
  }
  constructor(spec, options) {
    super(spec, options), this.name = "component", this.modelType = "component", this.transformerConstructor = BaseComponentSpecTransformer, this._delegateEvent = (component2, event, type, item = null, datum = null) => {
      var _a, _b;
      event instanceof CustomEvent || this.event.emit(type, {
        model: this,
        node: component2,
        event,
        item,
        datum,
        source: Event_Source_Type.chart,
        chart: null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b ? void 0 : _b.getChart()
      }, "model");
    }, this._option.animation && (this.animate = new AnimateManager({
      getCompiler: options.getCompiler
    }));
  }
  initLayout() {
    var _a;
    super.initLayout(), this._regions = null !== (_a = this._regions) && void 0 !== _a ? _a : this._option.getRegionsInIndex(), this._layout && (this._layout.layoutBindRegionID = this._regions.map((x) => null == x ? void 0 : x.id));
  }
  changeRegions(regions) {
    throw new Error("Method not implemented.");
  }
  _getNeedClearVRenderComponents() {
    throw new Error("Method not implemented.");
  }
  onRender(ctx) {
    throw new Error("Method not implemented.");
  }
  getVRenderComponents() {
    return this._getNeedClearVRenderComponents();
  }
  callPlugin(cb) {
    this.pluginService && this.pluginService.getAll().forEach((plugin) => cb(plugin));
  }
  getContainer() {
    var _a;
    return this._container || (this._container = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance.getStage().find((node) => "root" === node.name, true)), this._container;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || (result2.reMake = ["seriesId", "seriesIndex", "regionId", "regionIndex"].some((k2) => !isEqual(null == prevSpec ? void 0 : prevSpec[k2], spec[k2]))), (null == prevSpec ? void 0 : prevSpec.visible) !== spec.visible && (result2.reCompile = true), result2;
  }
  release() {
    var _a;
    super.release(), this.clear(), null === (_a = this.pluginService) || void 0 === _a || _a.releaseAll(), this.pluginService = null;
  }
  clear() {
    var _a;
    const components = this._getNeedClearVRenderComponents();
    components && components.length && components.forEach((c3) => {
      var _a2;
      c3 && (null === (_a2 = this.getContainer()) || void 0 === _a2 || _a2.removeChild(c3), c3 = null);
    }), this._container = null, null === (_a = this.pluginService) || void 0 === _a || _a.clearAll();
  }
  compile() {
    this.compileMarks(), this.reAppendComponents();
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      m4.compile({
        group,
        context: {
          model: this
        }
      });
    });
  }
  reAppendComponents() {
    const components = this._getNeedClearVRenderComponents();
    components && components.length && components.forEach((c3) => {
      var _a;
      c3 && !c3.stage && (null === (_a = this.getContainer()) || void 0 === _a || _a.appendChild(c3));
    });
  }
  getBoundsInRect(rect, fullRect) {
    return {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
  getDatum(graphic) {
  }
};
BaseComponent.transformerConstructor = BaseComponentSpecTransformer;

// node_modules/@visactor/vchart/esm/mark/component.js
var ComponentMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = "component", this._componentType = option.componentType, this._mode = option.mode;
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id = this.getProductId();
    this._product = view.mark(GrammarMarkType.component, null != group ? group : view.rootMark, {
      componentType: this._componentType,
      mode: this._mode
    }).id(id), this._compiledProductId = id;
  }
};
ComponentMark.type = "component";
var registerComponentMark = () => {
  Factory2.registerMark(ComponentMark.type, ComponentMark);
};

// node_modules/@visactor/vchart/esm/data/parser/scale.js
var scaleParser = (scale4) => scale4;

// node_modules/@visactor/vchart/esm/component/axis/base-axis.js
var __rest21 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var AxisComponent = class extends BaseComponent {
  getOrient() {
    return this._orient;
  }
  getScale() {
    return this._scale;
  }
  getScales() {
    return this._scales;
  }
  getTickData(index = 0) {
    return this._tickData[index];
  }
  get visible() {
    return this._visible;
  }
  getInverse() {
    return this._inverse;
  }
  getCoordinateType() {
    return this._coordinateType;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "axes", this._scales = [], this._tickData = [], this._visible = true, this._tick = void 0, this._visible = null === (_a = spec.visible) || void 0 === _a || _a, this._coordinateType = "none";
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  getVRenderComponents() {
    var _a, _b, _c, _d;
    return [null === (_b = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem(), null === (_d = null === (_c = this._gridMark) || void 0 === _c ? void 0 : _c.getProduct()) || void 0 === _d ? void 0 : _d.getGroupGraphicItem()].filter(isValid_default);
  }
  created() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    if (super.created(), this.setSeriesAndRegionsFromSpec(), this.initEvent(), this.initScales(), this.updateSeriesScale(), this._shouldComputeTickData() && this._initData(), this._visible) {
      const axisMark = this._createMark({
        type: "component",
        name: `axis-${this.getOrient()}`
      }, {
        componentType: "angle" === this.getOrient() ? "circleAxis" : "axis",
        mode: this._spec.mode,
        noSeparateStyle: true
      }, {
        skipTheme: true
      });
      if (this._axisMark = axisMark, axisMark.setMarkConfig({
        zIndex: this.layoutZIndex
      }), isValid_default(this._spec.id) && axisMark.setUserId(this._spec.id), axisMark.setMarkConfig({
        interactive: null !== (_a = this._spec.interactive) && void 0 !== _a ? _a : this.getDefaultInteractive()
      }), this._marks.addMark(axisMark), null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.visible) {
        const gridMark = this._createMark({
          type: "component",
          name: `axis-${this.getOrient()}-grid`
        }, {
          componentType: "angle" === this.getOrient() ? GridEnum.circleAxisGrid : GridEnum.lineAxisGrid,
          mode: this._spec.mode,
          noSeparateStyle: true
        }, {
          skipTheme: true
        });
        gridMark.setMarkConfig({
          zIndex: null !== (_g = null !== (_e = null === (_d = null === (_c = this._spec.grid) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.zIndex) && void 0 !== _e ? _e : null === (_f = this._spec.grid) || void 0 === _f ? void 0 : _f.zIndex) && void 0 !== _g ? _g : LayoutZIndex.Axis_Grid,
          interactive: false
        }), this._marks.addMark(gridMark), this._gridMark = gridMark;
      }
      if (false !== this._option.animation && false !== get_default(this._option.getChart().getSpec(), "animation") && true === this._spec.animation) {
        const axisAnimateConfig = animationConfig(null === (_h = Factory2.getAnimationInKey("axis")) || void 0 === _h ? void 0 : _h(), {
          appear: null !== (_k = null !== (_j = this._spec.animationAppear) && void 0 !== _j ? _j : get_default(this._option.getChart().getSpec(), "animationAppear.axis")) && void 0 !== _k ? _k : get_default(this._option.getChart().getSpec(), "animationAppear"),
          disappear: null !== (_m = null !== (_l = this._spec.animationDisappear) && void 0 !== _l ? _l : get_default(this._option.getChart().getSpec(), "animationDisappear.axis")) && void 0 !== _m ? _m : get_default(this._option.getChart().getSpec(), "animationDisappear"),
          enter: null !== (_p = null !== (_o = this._spec.animationEnter) && void 0 !== _o ? _o : get_default(this._option.getChart().getSpec(), "animationEnter.axis")) && void 0 !== _p ? _p : get_default(this._option.getChart().getSpec(), "animationEnter"),
          exit: null !== (_r = null !== (_q = this._spec.animationExit) && void 0 !== _q ? _q : get_default(this._option.getChart().getSpec(), "animationExit.axis")) && void 0 !== _r ? _r : get_default(this._option.getChart().getSpec(), "animationExit"),
          update: null !== (_t = null !== (_s = this._spec.animationUpdate) && void 0 !== _s ? _s : get_default(this._option.getChart().getSpec(), "animationUpdate.axis")) && void 0 !== _t ? _t : get_default(this._option.getChart().getSpec(), "animationUpdate")
        });
        axisAnimateConfig.enter && (axisAnimateConfig.update[0].customParameters = {
          enter: axisAnimateConfig.enter[0]
        }), this._marks.forEach((m4) => m4.setAnimationConfig(axisAnimateConfig));
      }
    }
  }
  _shouldComputeTickData() {
    return this.getVisible() || this._spec.forceInitTick;
  }
  _initData() {
    const tickData = this._initTickDataSet(this._tickTransformOption());
    tickData.target.addListener("change", this._forceLayout.bind(this)), this._tickData = [new CompilableData(this._option, tickData)];
  }
  collectData(depth, rawData) {
    const data = [];
    return eachSeries(this._regions, (s2) => {
      var _a;
      let field5 = this.collectSeriesField(depth, s2);
      if (field5 = isArray_default(field5) ? isContinuous(this._scale.type) ? field5 : [field5[0]] : [field5], depth || (this._dataFieldText = s2.getFieldAlias(field5[0])), field5) {
        const viewData = s2.getViewData();
        if (rawData) field5.forEach((f) => {
          data.push(s2.getRawDataStatisticsByField(f, false));
        });
        else if (viewData && viewData.latestData && viewData.latestData.length) {
          const seriesData = null === (_a = s2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(s2), userSetBreaks = this.type === ComponentTypeEnum.cartesianLinearAxis && this._spec.breaks && this._spec.breaks.length;
          field5.forEach((f) => {
            var _a2;
            (null === (_a2 = null == seriesData ? void 0 : seriesData.latestData) || void 0 === _a2 ? void 0 : _a2[f]) && (userSetBreaks ? data.push(Object.assign(Object.assign({}, seriesData.latestData[f]), {
              values: viewData.latestData.map((obj) => obj[f])
            })) : data.push(seriesData.latestData[f]));
          });
        }
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), data;
  }
  isSeriesDataEnable() {
    let enable = true;
    return eachSeries(this._regions, (s2) => {
      var _a;
      isArray_default(null === (_a = s2.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) && (enable = false);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), enable;
  }
  setSeriesAndRegionsFromSpec() {
    const { seriesId, seriesIndex, regionId, regionIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex), this.layout.layoutBindRegionID = this._regions.map((x) => x.id);
  }
  getBindSeriesFilter() {
    return {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    };
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this));
    const viewStatistics = getSeries(this._regions, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }).map((s2) => s2.getViewDataStatistics()).filter((v) => !!v);
    viewStatistics.length > 1 ? this._option.dataSet.multipleDataViewAddListener(viewStatistics, "change", () => {
      this.updateScaleDomain();
    }) : 1 === viewStatistics.length && viewStatistics[0].target.addListener("change", () => {
      this.updateScaleDomain();
    }), eachSeries(this._regions, (s2) => {
      s2.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
      }, () => {
        this._clearRawDomain();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  updateScaleDomain() {
  }
  _clearRawDomain() {
  }
  onLayoutEnd(ctx) {
    this.updateScaleRange();
    this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "range"
    }), super.onLayoutEnd(ctx);
  }
  computeData(updateType) {
    "force" !== updateType || this._tickData && this._tickData.length ? !this._tickData || !this._tickData.length || "force" !== updateType && isEqual(this._scale.range(), [0, 1]) || this._tickData.forEach((tickData) => {
      tickData.getDataView().reRunAllTransform(), tickData.updateData();
    }) : eachSeries(this._regions, (s2) => {
      var _a;
      null === (_a = s2.getViewData()) || void 0 === _a || _a.reRunAllTransform();
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  initScales() {
    this._scales = [this._scale];
    const groups2 = [];
    if (eachSeries(this._regions, (s2) => {
      const g = s2.getGroups();
      g && groups2.push(g);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), 0 !== groups2.length) {
      const depth = maxInArray(groups2.map((g) => g.fields.length));
      for (let i = 1; i < depth; i++) {
        const scale4 = this._scale.clone();
        this._scales.push(scale4);
      }
    }
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake ? result2 : (result2.reRender = true, (null == prevSpec ? void 0 : prevSpec.type) !== (null == spec ? void 0 : spec.type) || (null == prevSpec ? void 0 : prevSpec.visible) !== (null == spec ? void 0 : spec.visible) ? (result2.reMake = true, result2) : (result2.reMake = ["grid", "subGrid", "tick", "subTick", "label", "domainLine", "title"].some((k2) => {
      var _a, _b;
      return (null === (_a = null == prevSpec ? void 0 : prevSpec[k2]) || void 0 === _a ? void 0 : _a.visible) !== (null === (_b = null == spec ? void 0 : spec[k2]) || void 0 === _b ? void 0 : _b.visible);
    }), result2));
  }
  _getAxisAttributes() {
    const spec = this._spec, axisAttrs = {
      orient: this.getOrient(),
      select: true !== this._option.disableTriggerEvent && spec.select,
      hover: true !== this._option.disableTriggerEvent && spec.hover
    };
    if (spec.domainLine && spec.domainLine.visible ? axisAttrs.line = transformAxisLineStyle(spec.domainLine) : axisAttrs.line = {
      visible: false
    }, spec.label && spec.label.visible) {
      const labelSpec = pickWithout(spec.label, ["style", "formatMethod", "state"]);
      axisAttrs.label = labelSpec, spec.label.style && (axisAttrs.label.style = isFunction_default(spec.label.style) ? (datum, index, data, layer) => {
        var _a;
        const style = spec.label.style(datum.rawValue, index, datum, data, layer);
        return transformToGraphic(mergeSpec({}, null === (_a = this._theme.label) || void 0 === _a ? void 0 : _a.style, style));
      } : transformToGraphic(spec.label.style)), (spec.label.formatMethod || spec.label.formatter) && (axisAttrs.label.formatMethod = this._getLabelFormatMethod()), spec.label.state && (axisAttrs.label.state = transformAxisLabelStateStyle(spec.label.state)), isFunction_default(spec.label.dataFilter) && (axisAttrs.label.dataFilter = (data, layer) => spec.label.dataFilter(data, layer, {
        vchart: this._option.globalInstance
      }));
    } else axisAttrs.label = {
      visible: false
    };
    if (spec.tick && spec.tick.visible ? (axisAttrs.tick = {
      visible: spec.tick.visible,
      length: spec.tick.tickSize,
      inside: spec.tick.inside,
      alignWithLabel: spec.tick.alignWithLabel,
      dataFilter: isFunction_default(spec.tick.dataFilter) ? (data) => spec.tick.dataFilter(data, {
        vchart: this._option.globalInstance
      }) : void 0
    }, spec.tick.style && (axisAttrs.tick.style = isFunction_default(spec.tick.style) ? (value, index, datum, data) => {
      var _a;
      const style = spec.tick.style(value, index, datum, data);
      return transformToGraphic(mergeSpec({}, null === (_a = this._theme.tick) || void 0 === _a ? void 0 : _a.style, style));
    } : transformToGraphic(spec.tick.style)), spec.tick.state && (axisAttrs.tick.state = transformStateStyle(spec.tick.state))) : axisAttrs.tick = {
      visible: false
    }, spec.subTick && spec.subTick.visible ? (axisAttrs.subTick = {
      visible: spec.subTick.visible,
      length: spec.subTick.tickSize,
      inside: spec.subTick.inside,
      count: spec.subTick.tickCount
    }, spec.subTick.style && (axisAttrs.subTick.style = isFunction_default(spec.subTick.style) ? (value, index, datum, data) => {
      var _a;
      const style = spec.subTick.style(value, index, datum, data);
      return transformToGraphic(mergeSpec({}, null === (_a = this._theme.subTick) || void 0 === _a ? void 0 : _a.style, style));
    } : transformToGraphic(spec.subTick.style)), spec.subTick.state && (axisAttrs.subTick.state = transformStateStyle(spec.subTick.state))) : axisAttrs.subTick = {
      visible: false
    }, spec.title && spec.title.visible) {
      const _a = spec.title, { autoRotate: autoRotate2, angle: angle2, style: titleStyle = {}, background: titleBackgroundSpec, state: titleState, shape: titleShapeSpec } = _a, restTitleAttrs = __rest21(_a, ["autoRotate", "angle", "style", "background", "state", "shape"]);
      let titleTextStyle, titleAngle = angle2;
      "left" !== spec.orient && "right" !== spec.orient || autoRotate2 && isNil_default(titleAngle) && (titleAngle = "left" === spec.orient ? -90 : 90, titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient]), axisAttrs.title = Object.assign(Object.assign({}, restTitleAttrs), {
        autoRotate: false,
        angle: titleAngle ? degreeToRadian(titleAngle) : null,
        textStyle: mergeSpec({}, titleTextStyle, transformToGraphic(titleStyle)),
        pickable: false !== titleStyle.pickable,
        childrenPickable: false !== titleStyle.pickable,
        state: {}
      }), titleShapeSpec && titleShapeSpec.visible ? (axisAttrs.title.shape = Object.assign(Object.assign({}, titleShapeSpec), {
        style: transformToGraphic(titleShapeSpec.style)
      }), titleShapeSpec.state && (axisAttrs.title.state.shape = transformStateStyle(titleShapeSpec.state))) : axisAttrs.title.shape = {
        visible: false
      }, titleBackgroundSpec && titleBackgroundSpec.visible ? (axisAttrs.title.background = Object.assign(Object.assign({}, titleBackgroundSpec), {
        style: transformToGraphic(titleBackgroundSpec.style)
      }), titleBackgroundSpec.state && (axisAttrs.title.state.background = transformStateStyle(titleBackgroundSpec.state))) : axisAttrs.title.background = {
        visible: false
      }, titleState && (axisAttrs.title.state.text = transformStateStyle(titleState));
    } else axisAttrs.title = {
      visible: false
    };
    return spec.background && spec.background.visible ? (axisAttrs.panel = {
      visible: true
    }, spec.background.style && (axisAttrs.panel.style = transformToGraphic(spec.background.style)), spec.background.state && (axisAttrs.panel.state = transformStateStyle(spec.background.state))) : axisAttrs.panel = {
      visible: false
    }, axisAttrs;
  }
  _getGridAttributes() {
    const spec = this._spec;
    return {
      alternateColor: spec.grid.alternateColor,
      alignWithLabel: spec.grid.alignWithLabel,
      style: isFunction_default(spec.grid.style) ? () => (datum, index) => {
        var _a, _b;
        const style = spec.grid.style(null === (_a = datum.datum) || void 0 === _a ? void 0 : _a.rawValue, index, datum.datum);
        return transformToGraphic(mergeSpec({}, null === (_b = this._theme.grid) || void 0 === _b ? void 0 : _b.style, style));
      } : transformToGraphic(spec.grid.style),
      subGrid: false === spec.subGrid.visible ? {
        visible: false
      } : {
        type: "line",
        visible: spec.subGrid.visible,
        alternateColor: spec.subGrid.alternateColor,
        style: transformToGraphic(spec.subGrid.style)
      }
    };
  }
  _getLabelFormatMethod() {
    const { formatMethod, formatter } = this._spec.label, { formatFunc } = getFormatFunction(formatMethod, formatter);
    return formatFunc ? (value, datum, index) => formatFunc(datum.rawValue, datum, formatter) : null;
  }
  _initTickDataSet(options, index = 0) {
    registerDataSetInstanceParser(this._option.dataSet, "scale", scaleParser);
    const name = this.registerTicksTransform();
    return new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_ticks_${index}`
    }).parse(this._scales[index], {
      type: "scale"
    }).transform({
      type: name,
      options
    }, false);
  }
  _tickTransformOption() {
    const tick = this._tick || {}, label = this._spec.label || {}, { tickCount, forceTickCount, tickStep: tickStep2, tickMode } = tick, { style: labelStyle, formatMethod: labelFormatter, minGap: labelGap } = label;
    return {
      sampling: false !== this._spec.sampling,
      tickCount,
      forceTickCount,
      tickStep: tickStep2,
      tickMode,
      axisOrientType: this._orient,
      coordinateType: this._coordinateType,
      labelStyle,
      labelFormatter,
      labelGap
    };
  }
  addTransformToTickData(options, execute) {
    this._tickData.forEach((tickData) => {
      var _a;
      null === (_a = null == tickData ? void 0 : tickData.getDataView()) || void 0 === _a || _a.transform(options, execute);
    });
  }
  dataToPosition(values) {
    return this._scale.scale(values);
  }
  getDatum(childGraphic) {
    var _a, _b;
    return childGraphic && childGraphic.name === AXIS_ELEMENT_NAME.label ? childGraphic.data : this._axisMark ? null === (_b = null === (_a = this._axisMark.getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem()) || void 0 === _b ? void 0 : _b.attribute.items : void 0;
  }
};
AxisComponent.specKey = "axes";
var registerAxis2 = () => {
  registerComponentMark(), Factory2.registerAnimation("axis", () => ({
    appear: {
      custom: GroupFadeIn
    },
    update: {
      custom: GroupTransition
    },
    exit: {
      custom: GroupFadeOut
    }
  }));
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/axis.js
var __rest22 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var CartesianAxisPlugin = [AxisSyncPlugin];
var CartesianAxis = class extends AxisComponent {
  getOrient() {
    return this._orient;
  }
  getDefaultInteractive() {
    return true;
  }
  set autoIndentOnce(v) {
    this._autoIndentOnce = v;
  }
  getScales() {
    return this._scales;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianAxis, this.name = ComponentTypeEnum.cartesianAxis, this._defaultBandPosition = 0.5, this._defaultBandInnerPadding = 0.1, this._defaultBandOuterPadding = 0.3, this.layoutType = "region-relative", this.layoutZIndex = LayoutZIndex.Axis, this.layoutLevel = LayoutLevel.Axis, this._orient = "left", this._autoIndentOnce = false, this._hasAutoIndent = false, this._scales = [], this._tick = void 0, this._layoutCache = {
      width: 0,
      height: 0,
      _lastComputeOutBounds: {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      }
    }, this._innerOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s2) => {
          const orient = this.getOrient();
          isXAxis(orient) ? shouldUpdateAxis(s2.getXAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && s2.setXAxisHelper(this.axisHelper()) : isYAxis(orient) ? shouldUpdateAxis(s2.getYAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && s2.setYAxisHelper(this.axisHelper()) : isZAxis(orient) && shouldUpdateAxis(s2.getZAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && s2.setZAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      let { x, y } = pos;
      return isValidNumber_default(x) && (x += Number("left" === this._orient) * this.getLayoutRect().width), isValidNumber_default(y) && (y += Number("top" === this._orient) * this.getLayoutRect().height), {
        x,
        y
      };
    }, this._transformLayoutRect = (result2) => {
      if (!this._visible) return result2;
      const bounds = this._latestBounds.clone().translate(-this.getLayoutStartPoint().x, -this.getLayoutStartPoint().y);
      switch (this._layout.layoutOrient) {
        case "left":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x1 < 0 ? -bounds.x1 : 0);
          break;
        case "right":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x2 > 0 ? bounds.x2 : 0);
          break;
        case "top":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y1 < 0 ? -bounds.y1 : 0);
          break;
        case "bottom":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y2 > 0 ? bounds.y2 : 0);
      }
      return result2.width = Math.ceil(result2.width), result2.height = Math.ceil(result2.height), this._layout.setRectInSpec(this._layoutCacheProcessing(result2));
    }, this._updateAxisLayout = () => {
      const startPoint = this.getLayoutStartPoint(), _a = this._getUpdateAttribute(false), { grid: updateGridAttrs } = _a, updateAxisAttrs = __rest22(_a, ["grid"]), axisProduct = this._axisMark.getProduct(), axisAttrs = mergeSpec({
        x: startPoint.x,
        y: startPoint.y
      }, this._axisStyle, updateAxisAttrs);
      if (axisProduct.encode(axisAttrs), this._gridMark) {
        this._gridMark.getProduct().encode(mergeSpec({
          x: startPoint.x,
          y: startPoint.y
        }, this._getGridAttributes(), updateGridAttrs));
      }
    }, this._fixAxisOnZero = () => {
      const { onZero, visible } = this._spec.domainLine;
      if (this.visible && onZero && false !== visible) {
        const { onZeroAxisId, onZeroAxisIndex } = this._spec.domainLine, axesComponents = this._option.getComponentsByKey("axes"), isX = isXAxis(this.getOrient()), isValidAxis = (item) => {
          var _a;
          return (isX ? !isXAxis(item.getOrient()) : isXAxis(item.getOrient())) && isContinuous(item.getScale().type) && (item.getTickData() ? null === (_a = item.getTickData().getLatestData()) || void 0 === _a ? void 0 : _a.find((d) => 0 === d.value) : item.getScale().domain()[0] <= 0 && last(item.getScale().domain()) >= 0);
        }, relativeAxes = axesComponents.filter((item) => isValidAxis(item));
        if (relativeAxes.length) {
          let bindAxis;
          if (isValid_default(onZeroAxisId)) bindAxis = relativeAxes.find((axis2) => axis2.id === onZeroAxisId);
          else if (isValid_default(onZeroAxisIndex)) {
            const indexAxis = axesComponents[onZeroAxisIndex];
            isValidAxis(indexAxis) && (bindAxis = indexAxis);
          } else bindAxis = relativeAxes[0];
          if (bindAxis) {
            const axisMark = this._axisMark.getProduct(), position = bindAxis.valueToPosition(0);
            isX ? axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dy: "bottom" === this._orient ? -((bindAxis.getInverse() ? bindAxis.getScale().range()[1] : bindAxis.getScale().range()[0]) - position) : position
              })
            }) : axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dx: "left" === this._orient ? position : -((bindAxis.getInverse() ? bindAxis.getScale().range()[0] : bindAxis.getScale().range()[1]) - position)
              })
            });
          }
        }
      }
    }, this._orient = getOrient(spec, ["z"]), isZAxis(this._orient) && (this.layoutType = "absolute"), this._dataSet = options.dataSet, this._coordinateType = "cartesian";
  }
  static getSpecInfo(chartSpec) {
    const axesSpec = chartSpec[this.specKey];
    if (!axesSpec) return null;
    const isHorizontal4 = "horizontal" === chartSpec.direction;
    if (!isArray_default(axesSpec)) {
      if (!isValidCartesianAxis(axesSpec)) return null;
      const { axisType, componentName } = getCartesianAxisInfo(axesSpec, isHorizontal4);
      return axesSpec.type = axisType, [{
        spec: axesSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: componentName
      }];
    }
    let valid = true;
    if (axesSpec.filter((s2) => "z" === s2.orient)[0]) {
      const xAxis = axesSpec.filter((s2) => "bottom" === s2.orient)[0], yAxis = axesSpec.filter((s2) => isYAxis(s2.orient))[0];
      valid = 3 === axesSpec.length && xAxis && yAxis;
    }
    let axesSpecList = axesSpec.map((spec, index) => ({
      spec,
      index
    }));
    valid || (axesSpecList = axesSpecList.filter(({ spec }) => "z" !== spec.orient));
    const specInfos = [];
    return axesSpecList.forEach(({ spec, index }) => {
      if (!isValidCartesianAxis(spec)) return;
      const { axisType, componentName } = getCartesianAxisInfo(spec, isHorizontal4);
      spec.type = axisType, specInfos.push({
        spec,
        specPath: [this.specKey, index],
        specInfoPath: ["component", this.specKey, index],
        type: componentName
      });
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest22(specInfo, ["spec"]), C = Factory2.getComponentInKey(others.type);
    return C ? new C(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  initLayout() {
    super.initLayout(), this._layout.autoIndent = false !== this._spec.autoIndent, this._layout.layoutOrient = this._orient;
  }
  setLayout3dBox(box3d) {
    this.layout3dBox = box3d;
  }
  getNewScaleRange() {
    const { width, height } = this.getLayoutRect(), { left: left2, right: right2, top, bottom } = this._innerOffset;
    let newRange = [];
    return isXAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2]) : isZAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2], this._scale.range(newRange)) : isValidNumber_default(height) && (newRange = this._inverse ? [top, height - bottom] : [height - bottom, top]), newRange;
  }
  updateScaleRange() {
    let isScaleChange = false;
    const newRange = this.getNewScaleRange(), range2 = this._scale.range();
    return newRange.length === range2.length && newRange.every((value, index) => value === range2[index]) ? isScaleChange = false : (isScaleChange = true, this._scale.range(newRange)), isScaleChange;
  }
  init(option) {
    var _a;
    super.init(option), null === (_a = this.pluginService) || void 0 === _a || _a.load(CartesianAxisPlugin.map((P) => new P())), this.callPlugin((plugin) => {
      this.pluginService && plugin.onInit && plugin.onInit(this.pluginService, this);
    });
  }
  setAttrFromSpec() {
    var _a;
    if (super.setAttrFromSpec(), this.visible) {
      isXAxis(this.getOrient()) ? isUndefined_default(this._spec.maxHeight) && (this._spec.maxHeight = "30%") : isUndefined_default(this._spec.maxWidth) && (this._spec.maxWidth = "30%");
      const axisStyle = this._getAxisAttributes();
      axisStyle.label.formatMethod = this._getLabelFormatMethod(), axisStyle.verticalFactor = "top" === this.getOrient() || "right" === this.getOrient() ? -1 : 1, this._axisStyle = axisStyle;
    }
    this._tick = this._spec.tick;
    const chartSpec = null === (_a = this._option.getChart()) || void 0 === _a ? void 0 : _a.getSpec();
    this._inverse = transformInverse(this._spec, "horizontal" === (null == chartSpec ? void 0 : chartSpec.direction));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    if (super.onLayoutStart(layoutRect, viewRect, ctx), !isZAxis(this.getOrient()) && this._spec.innerOffset) {
      const spec = this._spec;
      isYAxis(this.getOrient()) ? ["top", "bottom"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.height, viewRect);
      }) : ["left", "right"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.width, viewRect);
      });
    }
  }
  getSeriesStatisticsField(s2) {
    let f;
    return f = isXAxis(this.getOrient()) ? s2.fieldX : isZAxis(this.getOrient()) ? s2.fieldZ : s2.fieldY, isContinuous(this._scale.type) ? f : [f[0]];
  }
  _tickTransformOption() {
    var _a, _b, _c, _d;
    return Object.assign(Object.assign({}, super._tickTransformOption()), {
      noDecimals: null === (_a = this._tick) || void 0 === _a ? void 0 : _a.noDecimals,
      labelLastVisible: null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.lastVisible,
      labelFirstVisible: null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.firstVisible,
      labelFlush: null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.flush
    });
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      getScale: (depth = 0) => this._scales[depth],
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => true === this._inverse,
      getSpec: () => this._spec
    };
  }
  afterCompile() {
    var _a;
    const product = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
    product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
      if (false === this._isLayout && (isXAxis(this.getOrient()) ? this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutHorizontal && plugin.onDidLayoutHorizontal(this.pluginService, this);
      }) : this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutVertical && plugin.onDidLayoutVertical(this.pluginService, this);
      }), this._unitText)) {
        const { x, y } = this.getLayoutStartPoint(), pos = isXAxis(this._orient) ? {
          x: maxInArray(this._scale.range()) + x,
          y
        } : {
          x,
          y: minInArray(this._scale.range()) + y
        };
        this._unitText.setAttributes(pos);
      }
    }), this.callPlugin((plugin) => {
      this.pluginService && plugin.onDidCompile && plugin.onDidCompile(this.pluginService, this);
    });
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  collectScale() {
    const scales = [];
    return eachSeries(this._regions, (s2) => {
      scales.push("left" === this.getOrient() || "right" === this.getOrient() ? s2.scaleY : s2.scaleX);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), scales;
  }
  collectSeriesField(depth, series2) {
    var _a, _b;
    let field5;
    return field5 = depth > 0 ? null === (_b = null === (_a = series2.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : isXAxis(this.getOrient()) ? series2.getSpec().x2Field ? [...series2.fieldX, series2.fieldX2] : series2.fieldX : isZAxis(this.getOrient()) ? series2.fieldZ : series2.getSpec().y2Field ? [...series2.fieldY, series2.fieldY2] : series2.fieldY, field5;
  }
  updateSeriesScale() {
    const orient = this.getOrient();
    eachSeries(this._regions, (s2) => {
      isXAxis(orient) ? shouldUpdateAxis(s2.getXAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.setScaleX(this._scale), s2.setXAxisHelper(this.axisHelper())) : isYAxis(orient) ? shouldUpdateAxis(s2.getYAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.setScaleY(this._scale), s2.setYAxisHelper(this.axisHelper())) : isZAxis(orient) && shouldUpdateAxis(s2.getZAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.setScaleZ(this._scale), s2.setZAxisHelper(this.axisHelper()));
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getBoundsInRect(rect) {
    var _a;
    let result2 = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    if (!this._visible) return result2;
    this._verticalLimitSize = isXAxis(this.getOrient()) ? rect.height : rect.width, this.setLayoutRect(rect);
    !this.updateScaleRange() && isArray_default(null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData()) || this.computeData("range");
    const context = {
      skipLayout: false
    }, isX = isXAxis(this.getOrient());
    this.pluginService && (isX ? this.callPlugin((plugin) => {
      plugin.onWillLayoutHorizontal && plugin.onWillLayoutHorizontal(this.pluginService, context, this);
    }) : this.callPlugin((plugin) => {
      plugin.onWillLayoutVertical && plugin.onWillLayoutVertical(this.pluginService, context, this);
    }));
    const product = this._axisMark.getProduct();
    let hasBounds2 = false;
    if (!context.skipLayout) {
      const attrs = this._getUpdateAttribute(true), axisComponent = product.getGroupGraphicItem(), spec = mergeSpec(Object.assign({}, this.getLayoutStartPoint()), this._axisStyle, attrs, {
        line: {
          visible: false
        }
      });
      let updateBounds = axisComponent.getBoundsWithoutRender(spec);
      updateBounds.empty() && (updateBounds = new Bounds().set(spec.x, spec.y, spec.x, spec.y)), hasBounds2 = true, this._latestBounds = updateBounds, result2 = this._appendAxisUnit(updateBounds, isX);
    }
    return hasBounds2 || (this._latestBounds = product.getBounds()), result2;
  }
  positionToData(pos, isViewPos) {
    const isX = isXAxis(this.getOrient());
    isViewPos && (pos -= isX ? this.getLayoutStartPoint().x : this.getLayoutStartPoint().y), this._innerOffset && (pos = isX ? clamp_default(pos, this._innerOffset.left, this.getLayoutRect().width - this._innerOffset.right) : clamp_default(pos, this._innerOffset.top, this.getLayoutRect().height - this._innerOffset.bottom));
    const range2 = this._scale.range();
    return (pos - range2[0]) * (pos - last(range2)) > 0 ? null : this._scale.invert(pos);
  }
  _getTitleLimit(isX) {
    var _a, _b, _c, _d, _e;
    const titleSpec = this._spec.title;
    if (titleSpec.visible && isNil_default(null === (_a = titleSpec.style) || void 0 === _a ? void 0 : _a.maxLineWidth)) {
      const angle2 = null !== (_e = null !== (_c = null === (_b = this._axisStyle.title) || void 0 === _b ? void 0 : _b.angle) && void 0 !== _c ? _c : null === (_d = titleSpec.style) || void 0 === _d ? void 0 : _d.angle) && void 0 !== _e ? _e : 0;
      if (isX) {
        const width = this.getLayoutRect().width, cosValue = Math.abs(Math.cos(angle2));
        return cosValue < 1e-6 ? 1 / 0 : width / cosValue;
      }
      const height = this.getLayoutRect().height, sinValue = Math.abs(Math.sin(angle2));
      return sinValue < 1e-6 ? 1 / 0 : height / sinValue;
    }
    return null;
  }
  _getUpdateAttribute(ignoreGrid) {
    var _a;
    let regionHeight = 0, regionWidth = 0;
    if (!ignoreGrid) {
      const regions = this.getRegions();
      let { x: minX, y: minY } = regions[0].getLayoutStartPoint(), maxX = minX + regions[0].getLayoutRect().width, maxY2 = minY + regions[0].getLayoutRect().height;
      for (let index = 1; index < regions.length; index++) {
        const region = regions[index], { x, y } = region.getLayoutStartPoint(), { width: width2, height: height2 } = region.getLayoutRect();
        minX = Math.min(minX, x), maxX = Math.max(maxX, width2 + x), minY = Math.min(minY, y), maxY2 = Math.max(maxY2, height2 + y);
      }
      regionHeight = Math.abs(maxY2 - minY), regionWidth = Math.abs(maxX - minX);
    }
    const { width, height } = this.getLayoutRect(), isX = isXAxis(this._orient), isY = isYAxis(this._orient), isZ = isZAxis(this._orient), depth = this.layout3dBox ? this.layout3dBox.length : 0;
    let end = {
      x: 0,
      y: 0
    }, gridLength = regionHeight, axisLength = width;
    isX ? end = {
      x: width,
      y: 0
    } : isY ? (end = {
      x: 0,
      y: height
    }, gridLength = regionWidth, axisLength = height) : isZ && (end = {
      x: depth,
      y: 0
    });
    const items = this.getLabelItems(axisLength), attrs = {
      start: {
        x: 0,
        y: 0
      },
      end,
      title: {
        text: this._spec.title.text || this._dataFieldText,
        maxWidth: this._getTitleLimit(isX)
      },
      items
    };
    if (ignoreGrid || (attrs.grid = {
      type: "line",
      start: {
        x: 0,
        y: 0
      },
      end,
      items: items[0],
      verticalFactor: this._axisStyle.verticalFactor,
      depth,
      length: gridLength
    }), isZ) {
      const directionStr = null !== (_a = this.directionStr) && void 0 !== _a ? _a : "r2l", depthZ = this.layout3dBox ? this.layout3dBox.width : 0;
      let anchor3d = [0, 0], alpha = -Math.PI / 2, z = 0;
      "l2r" === directionStr && (z = this.layout3dBox.length, anchor3d = [0, 0, 0], alpha = Math.PI / 2), attrs.z = z, attrs.alpha = alpha, attrs.anchor3d = anchor3d, ignoreGrid || (attrs.grid.depth = depthZ);
    } else {
      let verticalMinSize = isX ? this.layout.minHeight : this.layout.minWidth;
      (isX && this._layout.layoutRectLevelMap.height === USER_LAYOUT_RECT_LEVEL || isY && this._layout.layoutRectLevelMap.width === USER_LAYOUT_RECT_LEVEL) && (verticalMinSize = this._verticalLimitSize), attrs.verticalLimitSize = this._verticalLimitSize, attrs.verticalMinSize = verticalMinSize, attrs.label = {
        overflowLimitLength: this._getLabelOverflowLimit(isX)
      };
    }
    return attrs;
  }
  getLabelItems(length2) {
    var _a;
    const tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    return tickLatestData && tickLatestData.length ? [tickLatestData.map((obj) => {
      const normalizedValue = this._getNormalizedValue([obj.value], length2);
      return getAxisItem(obj.value, normalizedValue);
    }).filter((entry) => {
      const { value, rawValue } = entry, domain = this._scale.domain();
      return "log" === this.getSpec().type ? value >= 0 && value <= 1 : isContinuous(this._scale.type) ? rawValue >= domain[0] && rawValue <= last(domain) : domain.includes(rawValue);
    })] : [];
  }
  initEvent() {
    super.initEvent(), this.visible && (this.event.on(ChartEvent.layoutEnd, this._updateAxisLayout), this.event.on(ChartEvent.layoutEnd, this._fixAxisOnZero), this.event.on(ChartEvent.layoutRectUpdate, () => {
      this._clearLayoutCache();
    }));
  }
  _getNormalizedValue(values, length2) {
    return 0 === length2 ? 0 : this.dataToPosition(values) / length2;
  }
  _layoutCacheProcessing(rect) {
    return ["width", "height"].forEach((key) => {
      rect[key] < this._layoutCache[key] ? rect[key] = this._layoutCache[key] : this._layoutCache[key] = rect[key];
    }), this._autoIndentOnce && this._hasAutoIndent ? ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key];
    }) : (this._hasAutoIndent = true, ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] < this._layoutCache._lastComputeOutBounds[key] ? this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key] : this._layoutCache._lastComputeOutBounds[key] = this.layout.getLastComputeOutBounds()[key];
    })), rect;
  }
  _clearLayoutCache() {
    this._hasAutoIndent = false, this._layoutCache.width = 0, this._layoutCache.height = 0, this._layoutCache._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
  onDataUpdate() {
    this._clearLayoutCache();
  }
  _appendAxisUnit(bounds, isX) {
    var _a;
    if (this._spec.unit && this._spec.unit.visible) {
      const { text: text2, style } = this._spec.unit;
      let pos, unitTextStyle;
      const { x, y } = this.getLayoutStartPoint();
      isX ? (pos = {
        x: maxInArray(this._scale.range()) + x,
        y
      }, unitTextStyle = {
        textAlign: "left",
        textBaseline: "middle"
      }) : (pos = {
        x,
        y: minInArray(this._scale.range()) + y
      }, unitTextStyle = {
        textAlign: "left" === this._orient ? "left" : "right",
        textBaseline: "bottom"
      }), unitTextStyle = Object.assign(Object.assign(Object.assign({}, unitTextStyle), style), {
        x: pos.x,
        y: pos.y,
        text: text2
      }), this._unitText ? this._unitText.setAttributes(unitTextStyle) : (this._unitText = createText(unitTextStyle), this._unitText.name = "axis-unit", null === (_a = this.getContainer()) || void 0 === _a || _a.add(this._unitText));
      const textBounds = this._unitText.AABBBounds;
      isX ? (bounds.x2 += textBounds.x2 > bounds.x2 ? textBounds.x2 - bounds.x2 : 0, bounds.y2 += textBounds.y2 > bounds.y2 ? textBounds.y2 - bounds.y2 : 0) : (bounds.x1 += textBounds.x1 < bounds.x1 ? textBounds.x1 - bounds.x1 : 0, bounds.y1 += textBounds.y1 < bounds.y1 ? textBounds.y1 - bounds.y1 : 0);
    }
    return bounds;
  }
  _getNeedClearVRenderComponents() {
    return this._unitText ? [this._unitText] : [];
  }
  _getLabelOverflowLimit(isX) {
    var _a, _b;
    if (isX && false !== (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.visible) && true === (null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.autoLimit)) {
      const axesComponents = this._option.getComponentsByKey("axes"), relativeRegions = this.getRegions(), relativeAxes = axesComponents.filter((item) => {
        const orient = item.getOrient();
        return ("left" === orient || "right" === orient) && item.getRegions().some((region) => relativeRegions.includes(region));
      });
      let leftLimitLength = 0, rightLimitLength = 0;
      const startX = this.getLayoutStartPoint().x, endX = startX + this.getLayoutRect().width;
      return relativeAxes.forEach((axis2) => {
        const relativeStartX = axis2.getLayoutStartPoint().x;
        if ("left" === axis2.getOrient() && relativeStartX === startX) {
          const leftAxisWidth = axis2.getLayoutRect().width;
          leftLimitLength = Math.max(leftLimitLength, leftAxisWidth);
        } else if (relativeStartX === endX) {
          const rightAxisWidth = axis2.getLayoutRect().width;
          rightLimitLength = Math.max(rightLimitLength, rightAxisWidth);
        }
      }), {
        left: leftLimitLength,
        right: rightLimitLength
      };
    }
  }
};
CartesianAxis.type = ComponentTypeEnum.cartesianAxis, CartesianAxis.specKey = "axes";

// node_modules/@visactor/vchart/esm/component/axis/mixin/util/break-data.js
var setDomain = (min3, max3, breaks) => breaks.reduce((r, b, i) => (r.push([b, breaks.length === i + 1 ? max3 : breaks[i + 1]]), r), [[min3, breaks[0]]]);
function breakDomain(data, points) {
  const min3 = data[0], max3 = data[data.length - 1], breaks = points.filter((point6) => point6 > min3 && point6 < max3);
  return 0 === breaks.length ? [[min3, max3]] : setDomain(min3, max3, breaks);
}
var sorter = (a3, b) => a3 - b;
var fillBins = (data, points) => {
  const bins = [{
    count: 0,
    sub: [],
    max: points[0],
    min: points[0]
  }];
  let i = 0, j = 0;
  for (; i < points.length; ) data[j] <= points[i] ? (bins[i].count += 1, bins[i].sub.push(data[j]), j += 1) : (i += 1, bins[i] = {
    count: 0,
    sub: [],
    max: points[i],
    min: points[i]
  });
  bins.forEach((bin) => {
    bin.count && (bin.min = Math.min.apply(null, bin.sub));
  });
  const remain = data.slice(j);
  return bins[i] = {
    count: remain.length,
    sub: remain,
    min: points[points.length - 1],
    max: Math.max.apply(null, remain)
  }, bins;
};
function breakScope(data, points, scopeType = "count") {
  const bins = fillBins(data, points), totalLength = "count" === scopeType ? data.length : bins.reduce((res2, bin, i) => bin.count > 0 ? res2 + bin.max - bin.min : res2, 0), res = [];
  let acc = 0, resIndex = 0;
  return bins.forEach((bin, i) => {
    if (0 === totalLength) res.push([0, i / bins.length - 1]);
    else {
      const length2 = "count" === scopeType ? bin.count : bin.max - bin.min, b0 = res[resIndex - 1] ? res[resIndex - 1][1] : 0, b1 = i === bins.length - 1 ? 1 : Math.min((acc + length2) / totalLength, 1);
      (b0 !== b1 || 0 !== b0 && 1 !== b0) && (resIndex += 1, res.push([b0, b1]), acc += length2);
    }
  }), res;
}
function breakData(data, points, scopeType) {
  return data.sort(sorter), points.sort(sorter), {
    domain: breakDomain(data, points),
    scope: breakScope(data, points, scopeType)
  };
}

// node_modules/@visactor/vchart/esm/component/axis/mixin/linear-axis-mixin.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
var LinearAxisMixin = class {
  constructor() {
    this._extend = {}, this.niceLabelFormatter = null;
  }
  setExtraAttrFromSpec() {
    isValid_default(this._spec.nice) && (this._nice = this._spec.nice), isValid_default(this._spec.zero) && (this._zero = this._spec.zero), this._expand = this._spec.expand, this._domain = getLinearAxisSpecDomain(this._spec);
  }
  transformScaleDomain() {
    this.setScaleNice();
  }
  setLinearScaleNice() {
    var _a;
    if (!this._nice) return false;
    let tickCount = 5;
    const tick = this._spec.tick || {};
    if (isValidNumber_default(tick.forceTickCount)) tickCount = tick.forceTickCount;
    else if (isFunction_default(tick.tickCount)) {
      const range2 = this._scale.range();
      let rangeSize = Math.abs(last(range2) - range2[0]);
      if (1 === rangeSize && this._option) {
        rangeSize = isXAxis(this._orient) ? this._option.getChartViewRect().width : this._option.getChartViewRect().height;
      }
      tickCount = tick.tickCount({
        axisLength: rangeSize,
        labelStyle: this._spec.label && this._spec.label.style
      });
    } else tickCount = isValidNumber_default(tick.tickCount) ? tick.tickCount : 5;
    "accurateFirst" === this._spec.niceType && (tickCount = Math.max(5, tickCount));
    const { min: min3, max: max3 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    return isNil_default(min3) && isNil_default(max3) && isNil_default(this._softMaxValue) && isNil_default(this._softMinValue) ? this._scale.nice(tickCount) : (isValid_default(min3) || isValid_default(this._softMinValue)) && isNil_default(max3) && isNil_default(this._softMaxValue) ? this._scale.niceMax(tickCount) : !(!isNil_default(min3) || !isNil_default(this._softMinValue) || !isValid_default(max3) && !isValid_default(this._softMaxValue)) && this._scale.niceMin(tickCount);
  }
  setLogScaleNice() {
    var _a;
    if (!this._nice) return false;
    const { min: min3, max: max3 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    return isNil_default(min3) && isNil_default(max3) && isNil_default(this._softMaxValue) && isNil_default(this._softMinValue) ? this._scale.nice() : (isValid_default(min3) || isValid_default(this._softMinValue)) && isNil_default(max3) && isNil_default(this._softMaxValue) ? this._scale.niceMax() : !(!isNil_default(min3) || !isNil_default(this._softMinValue) || !isValid_default(max3) && !isValid_default(this._softMaxValue)) && this._scale.niceMin();
  }
  setScaleNice() {
    return "log" === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
  }
  dataToPosition(values, cfg) {
    return this.valueToPosition(values[0]);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  computeLinearDomain(data) {
    let domain = [];
    if (data.length) {
      const userSetBreaks = this._spec.breaks && this._spec.breaks.length;
      let minDomain, maxDomain, values = [];
      if (data.forEach((d) => {
        const { min: min3, max: max3 } = d;
        minDomain = void 0 === minDomain ? min3 : Math.min(minDomain, min3), maxDomain = void 0 === maxDomain ? max3 : Math.max(maxDomain, max3), userSetBreaks && (values = values.concat(d.values));
      }), userSetBreaks) {
        const breakRanges = [], breaks = [], breakMaxLimit = isNil_default(this._domain.max) ? maxDomain : this._domain.max;
        for (let index = 0; index < this._spec.breaks.length; index++) {
          const { range: range2 } = this._spec.breaks[index];
          range2[0] <= range2[1] && range2[1] <= breakMaxLimit && (breakRanges.push(range2), breaks.push(this._spec.breaks[index]));
        }
        if (breakRanges.sort((a3, b) => a3[0] - b[0]), breakRanges.length) {
          const { domain: breakDomains, scope: breakScopes } = breakData(values, combineDomains(breakRanges), this._spec.breaks[0].scopeType);
          domain = combineDomains(breakDomains), this._break = {
            domain: breakDomains,
            scope: breakScopes,
            breakDomains: breakRanges,
            breaks
          };
        } else domain = [minDomain, maxDomain];
      } else domain = [minDomain, maxDomain];
    } else domain[0] = 0, domain[1] = 0;
    return this.setSoftDomainMinMax(domain), this.expandDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), domain;
  }
  expandDomain(domain) {
    if (!this._expand) return;
    let domainMin = domain[0], domainMax = last(domain);
    domainMin === domainMax && (0 === domainMax ? domainMax = 1 : domainMax > 0 ? domainMin = 0 : domainMax < 0 && (domainMax = 0)), isValid_default(this._expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this._expand.min), isValid_default(this._expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this._expand.max);
  }
  niceDomain(domain) {
    const { min: userMin, max: userMax } = getLinearAxisSpecDomain(this._spec);
    if (isValid_default(userMin) || isValid_default(userMax) || "linear" !== this._spec.type) return domain;
    if (Math.abs(minInArray(domain) - maxInArray(domain)) <= 1e-12) {
      let num = domain[0];
      const flag = num >= 0 ? 1 : -1;
      if (num = Math.abs(num), num < 1) domain[0] = 0, domain[domain.length - 1] = 1;
      else {
        let step = num / 5;
        const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
        step = (err >= e102 ? 10 : err >= e52 ? 5 : err >= e22 ? 2 : 1) * Math.pow(10, power), domain[0] = 0, domain[domain.length - 1] = 10 * step;
      }
      flag < 0 && (domain.reverse(), domain[0] *= -1, domain[domain.length - 1] *= -1);
    }
    return domain;
  }
  includeZero(domain) {
    this._zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(last(domain), 0));
  }
  setExtendDomain(key, value) {
    if (void 0 === value) return void delete this._extend[key];
    this._extend[key] = value;
    const domain = this._scale.domain();
    if (this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this._nice) {
      !this.setScaleNice() && this._scale.rescale();
    }
    this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  extendDomain(domain) {
    let temp2;
    const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min3 = reverse ? domainLast : 0, max3 = reverse ? 0 : domainLast;
    for (const key in this._extend) temp2 = this._extend[key], temp2 > domain[max3] && (domain[max3] = temp2), temp2 < domain[min3] && (domain[min3] = temp2);
  }
  getDomainSpec() {
    return this._domain;
  }
  setDomainMinMax(domain) {
    if (!this._domain) return;
    const { min: min3, max: max3 } = this._domain;
    isValid_default(min3) && (domain[0] = min3), isValid_default(max3) && (domain[domain.length - 1] = max3);
  }
  setSoftDomainMinMax(domain) {
    const { softMin, softMax } = this._spec;
    if (isValid_default(softMin)) {
      let softMinValue = isFunction_default(softMin) ? softMin(domain) : softMin;
      isNil_default(softMinValue) && (softMinValue = domain[0]), softMinValue <= domain[0] && (domain[0] = softMinValue, this._softMinValue = softMinValue);
    }
    if (isValid_default(softMax)) {
      let softMaxValue = isFunction_default(softMax) ? softMax(domain) : softMax;
      isNil_default(softMaxValue) && (softMaxValue = last(domain)), softMaxValue >= last(domain) && (domain[domain.length - 1] = softMaxValue), this._softMaxValue = softMaxValue;
    }
  }
  setZero(zero2) {
    this._zero !== zero2 && (this._zero = zero2, this.updateScaleDomain());
  }
  updateScaleDomain() {
    if (!this.isSeriesDataEnable()) return;
    const data = this.collectData(), domain = this.computeLinearDomain(data);
    this.updateScaleDomainByModel(domain);
  }
  updateScaleDomainByModel(domain) {
    if (domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this._nice) {
      !this.setScaleNice() && this._scale.rescale();
    }
    this._updateNiceLabelFormatter(domain), this._domainAfterSpec = this._scale.domain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  getDomainAfterSpec() {
    return this._domainAfterSpec;
  }
  _updateNiceLabelFormatter(domain) {
    const domainSpan = Math.abs(last(domain) - domain[0]), n = Math.max(-Math.floor(Math.log10(domainSpan)), 0) + 2, unit = Math.pow(10, n);
    this.niceLabelFormatter = (value) => isValidNumber_default(+value) ? Math.round(+value * unit) / unit : value;
  }
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/linear-axis.js
var CartesianLinearAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLinearAxis, this._zero = true, this._nice = true, this._extend = {}, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
    const tickTransform = null === (_b = null === (_a = this._tickData) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.getDataView().transformsArr.find((t) => t.type === this.registerTicksTransform());
    tickTransform && (tickTransform.options = this._tickTransformOption());
  }
  initScales() {
    var _a, _b;
    super.initScales();
    const range2 = [0, 1];
    isValid_default(null === (_a = this._domain) || void 0 === _a ? void 0 : _a.min) && (range2[0] = this._domain.min), isValid_default(null === (_b = this._domain) || void 0 === _b ? void 0 : _b.max) && (range2[1] = this._domain.max), this._scale.domain(range2);
  }
  _tickTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._tickTransformOption()), {
      breakData: (null === (_a = this._spec.breaks) || void 0 === _a ? void 0 : _a.length) ? () => this._break : null
    });
  }
  _getUpdateAttribute(ignoreGrid) {
    var _a, _b;
    const attrs = super._getUpdateAttribute(ignoreGrid);
    if (!isZAxis(this._orient) && (null === (_b = null === (_a = this._break) || void 0 === _a ? void 0 : _a.breaks) || void 0 === _b ? void 0 : _b.length)) {
      const { width, height } = this.getLayoutRect(), isX = isXAxis(this._orient), axisLength = isX ? width : height;
      attrs.breaks = this._break.breaks.map((obj) => {
        const { range: range2, breakSymbol, gap = 6 } = obj, ratio = this.valueToPosition((range2[0] + range2[1]) / 2) / axisLength;
        let gapRatio;
        gapRatio = isPercent(gap) ? Number(gap.substring(0, gap.length - 1)) / 100 : gap / axisLength;
        const symbolAngle = isValidNumber_default(null == breakSymbol ? void 0 : breakSymbol.angle) ? breakSymbol.angle : isX ? 60 : 15;
        return {
          range: [ratio - gapRatio / 2, ratio + gapRatio / 2],
          breakSymbol: Object.assign(Object.assign({
            visible: true
          }, breakSymbol), {
            angle: symbolAngle * Math.PI / 180
          }),
          rawRange: range2
        };
      });
    }
    return attrs;
  }
  getNewScaleRange() {
    var _a, _b;
    let newRange = super.getNewScaleRange();
    return (null === (_a = this._spec.breaks) || void 0 === _a ? void 0 : _a.length) && (null === (_b = this._break) || void 0 === _b ? void 0 : _b.scope) && (newRange = combineDomains(this._break.scope).map((val) => newRange[0] + (last(newRange) - newRange[0]) * val)), newRange;
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  axisHelper() {
    const helper = super.axisHelper();
    return helper.setExtendDomain = this.setExtendDomain.bind(this), helper.valueToPosition = this.valueToPosition.bind(this), helper;
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), name;
  }
};
CartesianLinearAxis.type = ComponentTypeEnum.cartesianLinearAxis, CartesianLinearAxis.specKey = "axes", mixin(CartesianLinearAxis, LinearAxisMixin);
var registerCartesianLinearAxis = () => {
  registerLineAxis(), registerLineGrid(), registerAxis2(), Factory2.registerComponent(CartesianLinearAxis.type, CartesianLinearAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/mixin/band-axis-mixin.js
var BandAxisMixin = class {
  constructor() {
    this._rawDomainIndex = [];
  }
  _initData() {
    var _a;
    if (this._spec.showAllGroupLayers && this._scales.length > 1) for (let layer = 0; layer < this._scales.length; layer++) {
      const layerConfig = (null !== (_a = this._spec.layers) && void 0 !== _a ? _a : [])[this._scales.length - 1 - layer] || {};
      if (false !== layerConfig.visible && 0 !== layerConfig.tickCount && 0 !== layerConfig.forceTickCount) {
        const tickData = this._initTickDataSet(Object.assign(Object.assign({}, this._tickTransformOption()), layerConfig), layer);
        tickData.target.addListener("change", this._forceLayout.bind(this));
        const compilableData = new CompilableData(this._option, tickData);
        this._tickData.push(compilableData), this._tickDataMap || (this._tickDataMap = {}), this._tickDataMap[layer] = compilableData;
      }
    }
    else {
      const tickData = this._initTickDataSet(this._tickTransformOption());
      tickData.target.addListener("change", this._forceLayout.bind(this));
      const compilableData = new CompilableData(this._option, tickData);
      this._tickData = [compilableData], this._tickDataMap = {
        0: compilableData
      };
    }
  }
  dataToPosition(values, cfg = {}) {
    var _a, _b;
    if (0 === values.length || 0 === this._scales.length) return 0;
    const { position, bandScale } = this.getPosition(values);
    return position + bandScale.bandwidth() * (null !== (_b = null !== (_a = cfg.bandPosition) && void 0 !== _a ? _a : this._spec.bandPosition) && void 0 !== _b ? _b : this._defaultBandPosition);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  updateGroupScaleRange() {
    let parentScale = this._scale;
    this._scales.forEach((scale4, i) => {
      i > 0 && (scale4.range([0, parentScale.bandwidth()]), parentScale = scale4);
    });
  }
  getPosition(values) {
    let position = 0, bandScale = this._scale;
    if (1 === this._scales.length || 1 === values.length) position = this.valueToPosition(values[0]);
    else {
      const max3 = Math.min(values.length, this._scales.length);
      for (let i = 0; i < max3; i++) position += this._scales[i].scale(values[i]);
      bandScale = this._scales[max3 - 1];
    }
    return {
      position,
      bandScale
    };
  }
  calcScales(DEFAULT_BAND_INNER_PADDING, DEFAULT_BAND_OUTER_PADDING) {
    var _a, _b;
    const { bandPadding, paddingInner, paddingOuter } = this._spec, isBandPaddingArray = isArray_default(bandPadding), isPaddingInnerArray = isArray_default(paddingInner), isPaddingOuterArray = isArray_default(paddingOuter);
    for (let i = 0; i < this._scales.length; i++) {
      const _padding = isBandPaddingArray ? bandPadding[i] : bandPadding, _paddingInner = isPaddingInnerArray ? paddingInner[i] : paddingInner, _paddingOuter = isPaddingOuterArray ? paddingOuter[i] : paddingOuter;
      this._scales[i].paddingInner(null !== (_a = null != _paddingInner ? _paddingInner : _padding) && void 0 !== _a ? _a : DEFAULT_BAND_INNER_PADDING, true).paddingOuter(null !== (_b = null != _paddingOuter ? _paddingOuter : _padding) && void 0 !== _b ? _b : DEFAULT_BAND_OUTER_PADDING, true);
    }
  }
  computeBandDomain(data) {
    if (!data.length) return [];
    if (1 === data.length) return data[0].values;
    const tempSet = /* @__PURE__ */ new Set();
    for (let i = 0; i < data.length; i++) for (let j = 0; j < data[i].values.length; j++) tempSet.add(data[i].values[j]);
    return Array.from(tempSet);
  }
  updateScaleDomain() {
    var _a;
    if (!this.isSeriesDataEnable()) return;
    !(null === (_a = this._rawDomainIndex) || void 0 === _a ? void 0 : _a.length) && this._scales.length && this._updateRawDomain();
    const userDomain = this._spec.domain;
    for (let i = 0; i < this._scales.length; i++) if (userDomain && userDomain.length && 0 === i) this._scales[i].domain(userDomain);
    else {
      const data = this.collectData(i), domain = this.computeBandDomain(data);
      this._scales[i].domain(domain.sort((a3, b) => this._rawDomainIndex[i][a3] - this._rawDomainIndex[i][b]));
    }
    this.transformScaleDomain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  getLabelItems(length2) {
    const labelItems = [];
    let preData = [];
    return this._scales.forEach((scale4, index) => {
      var _a;
      const tickData = this._tickDataMap[index], isTickDataHaveData = null === (_a = null == tickData ? void 0 : tickData.getLatestData()) || void 0 === _a ? void 0 : _a.length, ticks4 = isTickDataHaveData ? tickData.getLatestData().map((obj) => obj.value) : scale4.domain();
      if (ticks4 && ticks4.length) if (preData && preData.length) {
        const currentLabelItems = [], curData = [];
        preData.forEach((value) => {
          ticks4.forEach((tick) => {
            const values = array(value).concat(tick);
            if (curData.push(values), isTickDataHaveData) {
              const axisItem = getAxisItem(tick, this._getNormalizedValue(values, length2));
              currentLabelItems.push(axisItem);
            }
          });
        }), isTickDataHaveData && labelItems.push(currentLabelItems.filter((entry) => entry.value >= 0 && entry.value <= 1)), preData = curData;
      } else ticks4.forEach((tick) => {
        preData.push(tick);
      }), isTickDataHaveData && labelItems.push(tickData.getLatestData().map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2))).filter((entry) => entry.value >= 0 && entry.value <= 1));
    }), labelItems.reverse();
  }
  _updateRawDomain() {
    this._rawDomainIndex = [];
    const userDomain = this._spec.domain;
    for (let i = 0; i < this._scales.length; i++) if (userDomain && userDomain.length && 0 === i) this._scales[i].domain(userDomain);
    else {
      const data = this.collectData(i, true), domain = this.computeBandDomain(data);
      this._rawDomainIndex[i] = {}, domain.forEach((d, _i) => this._rawDomainIndex[i][d] = _i);
    }
  }
  _clearRawDomain() {
    this._rawDomainIndex = [];
  }
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/band-axis.js
var CartesianBandAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  axisHelper() {
    const getScale2 = (depth = 0) => this._scales[depth];
    return {
      isContinuous: false,
      dataToPosition: this.dataToPosition.bind(this),
      getScale: getScale2,
      getBandwidth: (depth = 0) => getScale2(depth).bandwidth(),
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => this._inverse,
      getSpec: () => this._spec
    };
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, linearDiscreteTicks), name;
  }
  transformScaleDomain() {
    this.updateFixedWholeLength();
  }
  updateFixedWholeLength() {
    if (this._scale) {
      const { bandSize, maxBandSize, minBandSize } = this._getOuterBandSizeFromSpec();
      if (bandSize && this._scale.bandwidth(bandSize), maxBandSize && this._scale.maxBandwidth(maxBandSize), minBandSize && this._scale.minBandwidth(minBandSize), this._scale.isBandwidthFixed() && this._spec.autoRegionSize && (bandSize || maxBandSize)) {
        const rangeSize = scaleWholeRangeSize(this._scale.domain().length, null != bandSize ? bandSize : maxBandSize, this._scale.paddingInner(), this._scale.paddingOuter());
        ["bottom", "top"].includes(this._orient) ? this._regions.forEach((region) => region.setMaxWidth(rangeSize)) : ["left", "right"].includes(this._orient) && this._regions.forEach((region) => region.setMaxHeight(rangeSize));
      }
    }
  }
  _getOuterBandSizeFromSpec() {
    var _a;
    let { bandSize, maxBandSize, minBandSize, bandSizeLevel = 0 } = this._spec;
    const { gap, extend = 0 } = null !== (_a = this._spec.bandSizeExtend) && void 0 !== _a ? _a : {};
    bandSizeLevel = Math.min(bandSizeLevel, this._scales.length - 1);
    for (let i = bandSizeLevel; i > 0; i--) {
      const scale4 = this._scales[i], domain = scale4.domain(), paddingInner = scale4.paddingInner(), paddingOuter = scale4.paddingOuter(), getOuterBandSize = (b) => {
        const extendValue = i === bandSizeLevel ? extend : 0;
        if (isNil_default(gap) || i < bandSizeLevel) return scaleWholeRangeSize(domain.length, b, paddingInner, paddingOuter) + extendValue;
        return (b + (isString_default(gap) ? b * (Number(gap.substring(0, gap.length - 1)) / 100) : gap)) * domain.length / (this._scales[i - 1].paddingInner() + 1) + extendValue;
      };
      isValid_default(bandSize) && (bandSize = getOuterBandSize(bandSize)), isValid_default(maxBandSize) && (maxBandSize = getOuterBandSize(maxBandSize)), isValid_default(minBandSize) && (minBandSize = getOuterBandSize(minBandSize));
    }
    return {
      bandSize,
      maxBandSize,
      minBandSize
    };
  }
};
CartesianBandAxis.type = ComponentTypeEnum.cartesianBandAxis, CartesianBandAxis.specKey = "axes", mixin(CartesianBandAxis, BandAxisMixin);
var registerCartesianBandAxis = () => {
  registerLineAxis(), registerLineGrid(), registerAxis2(), Factory2.registerComponent(CartesianBandAxis.type, CartesianBandAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/time-axis.js
var CartesianTimeAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianTimeAxis, this._zero = false, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s2) => {
          isXAxis(this.getOrient()) ? shouldUpdateAxis(s2.getXAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && s2.setXAxisHelper(this.axisHelper()) : shouldUpdateAxis(s2.getYAxisHelper(), this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && s2.setYAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._tick = mergeSpec({}, this._spec.tick, null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[0]);
  }
  _initData() {
    var _a;
    if (super._initData(), null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) {
      const layerTickData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_layer_1_ticks`
      }).parse(this._scale, {
        type: "scale"
      }).transform({
        type: `${this.type}-ticks`,
        options: Object.assign(Object.assign({}, this._tickTransformOption()), {
          tickCount: this._spec.layers[1].tickCount,
          forceTickCount: this._spec.layers[1].forceTickCount,
          tickStep: this._spec.layers[1].tickStep
        })
      }, false);
      this._layerTickData = new CompilableData(this._option, layerTickData);
    }
  }
  computeData(updateType) {
    super.computeData(updateType), this._layerTickData && (this._layerTickData.getDataView().reRunAllTransform(), this._layerTickData.updateData());
  }
  _getLabelFormatMethod() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const timeUtil = TimeUtil.getInstance(), timeFormat1 = (null === (_b = null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) || void 0 === _b ? void 0 : _b.timeFormat) || "%Y%m%d", timeFormatter1 = "local" === ((null === (_d = null === (_c = this._spec.layers) || void 0 === _c ? void 0 : _c[1]) || void 0 === _d ? void 0 : _d.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat, timeFormat0 = (null === (_f = null === (_e = this._spec.layers) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.timeFormat) || "%Y%m%d", timeFormatter0 = "local" === ((null === (_h = null === (_g = this._spec.layers) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat;
    return (value, datum, index, data, layer) => {
      var _a2;
      let timeValue;
      return timeValue = 0 === layer ? timeFormatter0(timeFormat0, value) : timeFormatter1(timeFormat1, value), (null === (_a2 = this._spec.label) || void 0 === _a2 ? void 0 : _a2.formatMethod) ? this._spec.label.formatMethod(timeValue, datum) : timeValue;
    };
  }
  getLabelItems(length2) {
    var _a, _b;
    const items = [], tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    tickLatestData && tickLatestData.length && items.push(tickLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2))));
    const layerLatestData = null === (_b = this._layerTickData) || void 0 === _b ? void 0 : _b.getLatestData();
    return layerLatestData && layerLatestData.length && items.push(layerLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2)))), items;
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), name;
  }
  transformScaleDomain() {
  }
};
CartesianTimeAxis.type = ComponentTypeEnum.cartesianTimeAxis, CartesianTimeAxis.specKey = "axes";
var registerCartesianTimeAxis = () => {
  registerLineAxis(), registerLineGrid(), registerAxis2(), Factory2.registerComponent(CartesianTimeAxis.type, CartesianTimeAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/log-axis.js
var CartesianLogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLogAxis, this._zero = false, this._scale = new LogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.base(null !== (_a = this._spec.base) && void 0 !== _a ? _a : 10), this._scale.clamp(true, null, false);
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), name;
  }
  transformScaleDomain() {
  }
};
CartesianLogAxis.type = ComponentTypeEnum.cartesianLogAxis, CartesianLogAxis.specKey = "axes", mixin(CartesianLogAxis, LinearAxisMixin);
var registerCartesianLogAxis = () => {
  registerLineAxis(), registerLineGrid(), registerAxis2(), Factory2.registerComponent(CartesianLogAxis.type, CartesianLogAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/symlog-axis.js
var CartesianSymlogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianSymlogAxis, this._zero = false, this._scale = new SymlogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.constant(null !== (_a = this._spec.constant) && void 0 !== _a ? _a : 10);
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), name;
  }
  transformScaleDomain() {
  }
};
CartesianSymlogAxis.type = ComponentTypeEnum.cartesianSymlogAxis, CartesianSymlogAxis.specKey = "axes", mixin(CartesianSymlogAxis, LinearAxisMixin);
var registerCartesianSymlogAxis = () => {
  registerLineAxis(), registerLineGrid(), registerAxis2(), Factory2.registerComponent(CartesianSymlogAxis.type, CartesianSymlogAxis);
};

// node_modules/@visactor/vchart/esm/series/line/line.js
var LineSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.line, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "line";
    this.initLineMark(progressive, "line" === seriesMark), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initTooltip() {
    super.initTooltip();
    const { group, mark } = this._tooltipHelper.activeTriggerSet;
    this._lineMark && group.add(this._lineMark), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  initMarkStyle() {
    this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const lineAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._lineMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("line")) || void 0 === _c ? void 0 : _c(lineAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    var _a;
    const isLineAsSeriesMark = "point" !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.seriesMark);
    return (attribute) => {
      var _a2, _b;
      return isLineAsSeriesMark && "fill" === attribute && (attribute = "stroke"), null !== (_b = null === (_a2 = this._seriesMark) || void 0 === _a2 ? void 0 : _a2.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._lineMark, this._symbolMark];
  }
};
LineSeries.type = SeriesTypeEnum.line, LineSeries.mark = lineSeriesMark, LineSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(LineSeries, LineLikeSeriesMixin);
var registerLineSeries = () => {
  registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerSymbolMark(), registerLineAnimation(), registerScaleInOutAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(LineSeries.type, LineSeries);
};

// node_modules/@visactor/vchart/esm/chart/chart-meta/data.js
var ChartData = class {
  get dataList() {
    return this._dataArr;
  }
  constructor(dataSet) {
    this._dataArr = [], this._dataSet = dataSet;
  }
  parseData(dataSpec) {
    this._dataArr = [];
    const list = array(dataSpec);
    for (let i = 0; i < list.length; i++) this._dataArr.push(dataToDataView(list[i], this._dataSet, this._dataArr));
  }
  updateData(dataSpec, fullUp = false, forceMerge = true) {
    const list = array(dataSpec);
    return (!fullUp || list.length === this._dataArr.length) && (this._dataValueForEach(list, (_data, dv) => {
      dv.markRunning();
    }), this._dataValueForEach(list, (data, dv) => {
      updateDataViewInData(dv, data, forceMerge);
    }), true);
  }
  _dataValueForEach(list, callBack) {
    list.forEach((data, i) => {
      if (data instanceof DataView) return;
      const dv = this.getSeriesData(data.id, i);
      dv && callBack(data, dv, i);
    });
  }
  getSeriesData(id, index) {
    if (!this._dataArr.length) return null;
    if ("string" == typeof id) {
      const metchData = this._dataArr.filter((data) => data.name === id);
      if (metchData[0]) return metchData[0];
      warn(`no data matches dataId ${id}!`);
    }
    if ("number" == typeof index) {
      if (this._dataArr[index]) return this._dataArr[index];
      warn(`no data matches dataIndex ${index}!`);
    }
    return this._dataArr[0];
  }
};

// node_modules/@visactor/vchart/esm/scale/global-scale.js
var GlobalScale = class {
  constructor(spec, chart) {
    this._scaleSpecMap = /* @__PURE__ */ new Map(), this._scaleMap = /* @__PURE__ */ new Map(), this._modelScaleSpecMap = /* @__PURE__ */ new Map(), this._markAttributeScaleMap = /* @__PURE__ */ new Map(), this._spec = null, this._chart = null, this.getStatisticalFields = (dataId) => {
      const result2 = [];
      return this._scaleSpecMap.forEach((v, k2) => {
        isDataDomainSpec(v.domain) && v.domain.forEach((spec2) => {
          spec2.dataId === dataId && spec2.fields.forEach((key) => {
            mergeFields(result2, [{
              key,
              operations: isContinuous(v.type) ? ["max", "min"] : ["values"]
            }]);
          });
        });
      }), this._markAttributeScaleMap.forEach((specList, scaleName) => {
        const scale4 = this.getScale(scaleName);
        specList.forEach((spec2) => {
          this._getSeriesBySeriesId(spec2.seriesId).getRawData().name === dataId && spec2.field && mergeFields(result2, [{
            key: spec2.field,
            operations: isContinuous(scale4.type) ? ["max", "min"] : ["values"]
          }]);
        });
      }), result2;
    }, this._spec = spec, this._chart = chart, this._setAttrFromSpec();
  }
  _createFromSpec(s2) {
    if (!s2.id) return null;
    let scale4 = this._scaleMap.get(s2.id);
    return scale4 || (scale4 = "ordinal" === s2.type && "color" === s2.id ? createScale("colorOrdinal") : createScale(s2.type)), scale4 ? (isArray_default(s2.range) && scale4.range(s2.range), isArray_default(s2.domain) && (isDataDomainSpec(s2.domain) || scale4.domain(s2.domain)), s2.specified && scale4.specified && scale4.specified(s2.specified), s2.clamp && scale4.clamp && scale4.clamp(s2.clamp), scale4) : null;
  }
  _setAttrFromSpec() {
    var _a;
    if (!(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.length)) return;
    const newScaleMap = /* @__PURE__ */ new Map(), newScaleSpecMap = /* @__PURE__ */ new Map();
    this._spec.forEach((s2) => {
      const scale4 = this._createFromSpec(s2);
      scale4 && (newScaleMap.set(s2.id, scale4), newScaleSpecMap.set(s2.id, s2));
    }), this._modelScaleSpecMap.forEach((s2) => {
      const scale4 = this._createFromSpec(s2);
      scale4 && (newScaleMap.set(s2.id, scale4), newScaleSpecMap.set(s2.id, s2));
    }), this._scaleSpecMap = newScaleSpecMap, this._scaleMap = newScaleMap;
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (isEqual(spec, this._spec)) return result2;
    result2.change = true;
    for (let i = 0; i < spec.length; i++) {
      const s2 = spec[i], scale4 = this._scaleMap.get(s2.id);
      if (!scale4) return result2.reMake = true, result2;
      const lastSpec = this._spec.find((_s) => _s.id === s2.id);
      if (!lastSpec.id) return result2.reMake = true, result2;
      if (lastSpec.type !== s2.type) return result2.reMake = true, result2;
      if (!isEqual(lastSpec.specified, s2.specified)) return result2.reMake = true, result2;
      s2.range && !isEqual(s2.range, scale4.range()) && (scale4.range(s2.range), result2.reRender = true), isDataDomainSpec(s2.domain) ? result2.reRender = true : isEqual(s2.domain, scale4.domain()) || (scale4.domain(s2.domain), result2.reRender = true), this._scaleSpecMap.set(s2.id, s2);
    }
    return this._spec = spec, result2;
  }
  registerModelScale(spec) {
    const scale4 = this._createFromSpec(spec);
    scale4 && (this._modelScaleSpecMap.set(spec.id, spec), this._scaleSpecMap.set(spec.id, spec), this._scaleMap.set(spec.id, scale4));
  }
  removeModelScale(filter2) {
    this._modelScaleSpecMap.forEach((spec) => {
      filter2(spec) && (this._modelScaleSpecMap.delete(spec.id), this._scaleSpecMap.delete(spec.id), this._scaleMap.delete(spec.id));
    });
  }
  getScale(user_id) {
    return this._scaleMap.get(user_id);
  }
  getScaleSpec(user_id) {
    return this._scaleSpecMap.get(user_id);
  }
  _getSeriesByRawDataId(id) {
    const series2 = this._chart.getAllSeries();
    for (let i = 0; i < series2.length; i++) {
      const s2 = series2[i];
      if (s2.getRawData().name === id) return s2;
    }
    return null;
  }
  _getSeriesBySeriesId(id) {
    const series2 = this._chart.getAllSeries();
    for (let i = 0; i < series2.length; i++) {
      const s2 = series2[i];
      if (s2.id === id) return s2;
    }
    return null;
  }
  updateScaleDomain(defaultDomain) {
    this._scaleSpecMap.forEach((scaleSpec, id) => {
      const scale4 = this._scaleMap.get(id);
      if (!scale4) return;
      if (!isDataDomainSpec(scaleSpec.domain)) return scaleSpec.domain && 0 !== scaleSpec.domain.length || scale4.domain(defaultDomain), void this._updateMarkScale(id, scale4, scale4.domain().slice());
      let domain;
      domain = isContinuous(scaleSpec.type) ? [null, null] : /* @__PURE__ */ new Set(), scaleSpec.domain.forEach((spec) => {
        const series2 = this._getSeriesByRawDataId(spec.dataId);
        if (!series2) return;
        const isContinuousField = isContinuous(scaleSpec.type);
        spec.fields.forEach((key) => {
          const statistics2 = series2.getRawDataStatisticsByField(key, isContinuousField);
          statistics2 && (isContinuousField ? (isNil_default(domain[0]) ? domain[0] = statistics2.min : domain[0] = Math.min(statistics2.min, domain[0]), isNil_default(domain[1]) ? domain[1] = statistics2.max : domain[1] = Math.max(statistics2.max, domain[1])) : statistics2.values.forEach((value) => {
            domain.add(value);
          }));
        });
      });
      const scaleDomain = domain;
      isContinuous(scaleSpec.type) || (domain = Array.from(domain)), scale4.domain(domain), this._updateMarkScale(id, scale4, scaleDomain);
    });
  }
  _updateMarkScale(id, scale4, domain) {
    const list = this._markAttributeScaleMap.get(id);
    list && 0 !== list.length && list.forEach((info) => {
      if (!info.field || !info.markScale || info.markScale === scale4) return;
      if (isNil_default(info.changeDomain) || "none" === info.changeDomain || isNil_default(info.seriesId)) return void (isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain)));
      const series2 = this._getSeriesBySeriesId(info.seriesId), isContinuousScale = isContinuous(scale4.type), statistics2 = series2.getRawDataStatisticsByField(info.field, isContinuousScale);
      if (!isEmpty_default(statistics2)) return "expand" === info.changeDomain ? (isContinuousScale ? (domain[0] = Math.min(domain[0], statistics2.min), domain[1] = Math.max(domain[1], statistics2.max)) : (statistics2.values.forEach((value) => {
        domain.add(value);
      }), domain = Array.from(domain)), void info.markScale.domain(domain)) : void ("replace" !== info.changeDomain || (isContinuousScale ? info.markScale.domain([statistics2.min, statistics2.max]) : info.markScale.domain(statistics2.values)));
      isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain));
    });
  }
  registerMarkAttributeScale(spec, seriesId) {
    const scale4 = this._scaleMap.get(spec.scale);
    let list = this._markAttributeScaleMap.get(spec.scale);
    list || (list = [], this._markAttributeScaleMap.set(spec.scale, list));
    let markScale = scale4;
    return (isNil_default(spec.field) || !isNil_default(spec.changeDomain) && "none" !== spec.changeDomain && !isNil_default(seriesId)) && (markScale = scale4.clone()), list.push(Object.assign(Object.assign({}, spec), {
      seriesId,
      markScale
    })), markScale;
  }
};

// node_modules/@visactor/vchart/esm/chart/base/base-chart.js
var __rest23 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseChart = class extends CompilableBase {
  getSpec() {
    return this._spec;
  }
  setSpec(s2) {
    this._spec = s2;
  }
  getOption() {
    return this._option;
  }
  getLayoutRect() {
    return this._layoutRect;
  }
  getViewRect() {
    return this._viewRect;
  }
  getLayoutTag() {
    return this._layoutTag;
  }
  setLayoutTag(tag, morphConfig, renderNextTick = true) {
    this._layoutTag = tag;
    const compiler = this.getCompiler();
    return (null == compiler ? void 0 : compiler.getVGrammarView()) && (compiler.getVGrammarView().updateLayoutTag(), tag && renderNextTick && compiler.renderNextTick(morphConfig)), this._layoutTag;
  }
  getGlobalScale() {
    return this._globalScale;
  }
  getEvent() {
    return this._event;
  }
  get chartData() {
    return this._chartData;
  }
  constructor(spec, option) {
    var _a, _b, _c;
    super(option), this.type = "chart", this.id = createID(), this._regions = [], this._series = [], this._components = [], this._layoutRect = {
      x: 0,
      y: 0,
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewRect = {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewBox = {
      x1: 0,
      y1: 0,
      x2: DEFAULT_CHART_WIDTH,
      y2: DEFAULT_CHART_HEIGHT
    }, this._layoutTag = true, this._idMap = /* @__PURE__ */ new Map(), this.state = {
      layoutUpdateRank: 1
    }, this.padding = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }, this.getAllSeries = () => {
      var _a2;
      return null !== (_a2 = this._series) && void 0 !== _a2 ? _a2 : [];
    }, this.getRegionsInIndex = (index) => index && 0 !== index.length ? this._regions.filter((_r, i) => index.includes(i)) : [this._regions[0]], this.getAllRegions = () => this._regions, this.getRegionsInIds = (ids) => ids ? this._regions.filter((r) => ids.includes(r.id)) : [], this.getRegionsInQuerier = (region) => region ? this._regions.filter((r, index) => array(region).some((regionFilter) => isValid_default(regionFilter.regionId) && regionFilter.regionId === r.userId || regionFilter.regionIndex === index)) : this._regions, this.getRegionsInUserId = (userId) => {
      if (userId) return this._regions.find((r) => r.userId === userId);
    }, this.getRegionsInUserIdOrIndex = (user_ids, index) => this.getAllRegions().filter((r) => (null == user_ids ? void 0 : user_ids.length) ? r.userId && user_ids.includes(r.userId) : !(null == index ? void 0 : index.length) || index.includes(r.getSpecIndex())), this.getComponents = () => this._components, this.getSeriesInIndex = (index) => index && 0 !== index.length ? this._series.filter((_r, i) => index.includes(i)) : [this._series[0]], this.getSeriesInIds = (ids) => ids ? this._series.filter((r) => ids.includes(r.id)) : [], this.getSeriesInUserId = (userId) => {
      if (userId) return this._series.find((r) => r.userId === userId);
    }, this.getSeriesInUserIdOrIndex = (user_ids, index) => this.getAllSeries().filter((s2) => (null == user_ids ? void 0 : user_ids.length) ? s2.userId && user_ids.includes(s2.userId) : !(null == index ? void 0 : index.length) || index.includes(s2.getSpecIndex())), this.getComponentByIndex = (key, index) => {
      const components = this._components.filter((c3) => (c3.specKey || c3.type) === key);
      if (components && 0 !== components.length) return components[index];
    }, this.getComponentsByKey = (key) => this._components.filter((c3) => (c3.specKey || c3.type) === key), this.getComponentByUserId = (userId) => {
      const component2 = this._components.find((s2) => s2.userId === userId);
      if (component2) return component2;
    }, this.getComponentsByType = (type) => this._components.filter((c3) => c3.type === type), this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = spec.padding) && void 0 !== _a ? _a : option.getTheme().padding), this._event = new Event2(option.eventDispatcher, option.mode), this._dataSet = option.dataSet, this._chartData = new ChartData(this._dataSet), this._modelOption = Object.assign(Object.assign({}, option), {
      mode: this._option.mode,
      map: this._idMap,
      getChartLayoutRect: () => this._layoutRect,
      getChartViewRect: () => this._viewRect,
      getChart: () => this,
      globalScale: this._globalScale,
      onError: null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError,
      disableTriggerEvent: true === (null === (_c = this._option) || void 0 === _c ? void 0 : _c.disableTriggerEvent),
      getSeriesData: this._chartData.getSeriesData.bind(this._chartData)
    }), this._spec = spec;
  }
  created(transformer) {
    this._chartData.parseData(this._spec.data), this._createGlobalScale(), this._createBackground(), this._createLayout(), transformer.forEachRegionInSpec(this._spec, this._createRegion.bind(this)), transformer.forEachSeriesInSpec(this._spec, this._createSeries.bind(this)), transformer.forEachComponentInSpec(this._spec, this._createComponent.bind(this), this._option.getSpecInfo());
  }
  init() {
    var _b, _d;
    null === (_b = this._beforeInit) || void 0 === _b || _b.call(this), this._regions.forEach((r) => r.init({})), this._series.forEach((s2) => s2.init({})), this._components.forEach((c3) => c3.init({
      dataSet: this._dataSet
    })), this._initEvent(), null === (_d = this._initStack) || void 0 === _d || _d.call(this), this.reDataFlow();
  }
  reDataFlow() {
    this._series.forEach((s2) => {
      var _a;
      return null === (_a = s2.getRawData()) || void 0 === _a ? void 0 : _a.markRunning();
    }), this._series.forEach((s2) => s2.fillData()), this.updateGlobalScaleDomain();
  }
  onResize(width, height, reRender = true) {
    const canvasRect = {
      width,
      height
    };
    this._canvasRect = canvasRect, this._updateLayoutRect(this._option.viewBox), this.setLayoutTag(true, null, reRender);
  }
  updateViewBox(viewBox, reLayout) {
    this._option.viewBox = viewBox, this._updateLayoutRect(viewBox), this.setLayoutTag(true, null, reLayout);
  }
  _createBackground() {
    const bg = this._spec.background;
    if (!bg || "object" != typeof bg || isValid_default(bg.gradient)) return;
    const backgroundStyle = pickWithout(bg, ["x", "y", "width", "height", "x1", "y1", "image"]);
    backgroundStyle.background = bg.image, this._backgroundMark = Factory2.createMark("group", "chart-background", {
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._globalScale
    }), this._backgroundMark.created(), this._backgroundMark.setStyle(Object.assign(Object.assign({}, backgroundStyle), {
      x: () => this._viewBox.x1,
      y: () => this._viewBox.y1,
      width: () => this._viewBox.x2 - this._viewBox.x1,
      height: () => this._viewBox.y2 - this._viewBox.y1
    })), this._backgroundMark.setMarkConfig({
      zIndex: LayoutZIndex.SeriesGroup - 2
    });
  }
  _createRegion(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest23(specInfo, ["spec"]), region = new constructor(spec, Object.assign(Object.assign({}, this._modelOption), others));
    region && (region.created(), this._regions.push(region));
  }
  _createSeries(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest23(specInfo, ["spec"]);
    let region;
    if (isValid_default(spec.regionId) ? region = this.getRegionsInUserId(spec.regionId) : isValid_default(spec.regionIndex) && (region = this.getRegionsInIndex([spec.regionIndex])[0]), !region && !(region = this._regions[0])) return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      type: spec.type,
      region,
      globalScale: this._globalScale,
      sourceDataList: this._chartData.dataList
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
  getSeriesById(id) {
    return this._series.find((x) => x.id === id);
  }
  _createComponent(constructor, specInfo) {
    const component2 = constructor.createComponent(specInfo, Object.assign(Object.assign({}, this._modelOption), {
      type: constructor.type,
      getAllRegions: this.getAllRegions,
      getRegionsInIndex: this.getRegionsInIndex,
      getRegionsInIds: this.getRegionsInIds,
      getRegionsInUserIdOrIndex: this.getRegionsInUserIdOrIndex,
      getAllSeries: this.getAllSeries,
      getSeriesInIndex: this.getSeriesInIndex,
      getSeriesInIds: this.getSeriesInIds,
      getSeriesInUserIdOrIndex: this.getSeriesInUserIdOrIndex,
      getAllComponents: this.getComponents,
      getComponentByIndex: this.getComponentByIndex,
      getComponentByUserId: this.getComponentByUserId,
      getComponentsByKey: this.getComponentsByKey,
      getComponentsByType: this.getComponentsByType
    }));
    component2 && (component2.created(), this._components.push(component2));
  }
  getAllComponents() {
    return this._components;
  }
  getAllModels() {
    return [].concat(this.getAllSeries(), this.getAllComponents(), this.getAllRegions());
  }
  getModelInFilter(filter2) {
    if (isString_default(filter2)) return this.getAllModels().find((m4) => m4.userId === filter2);
    if (isFunction_default(filter2)) return this.getAllModels().find((m4) => filter2(m4));
    let index = 0;
    return this.getAllModels().find((m4) => {
      var _a;
      if ((null !== (_a = m4.specKey) && void 0 !== _a ? _a : m4.type) === filter2.type) {
        if (index === filter2.index) return true;
        index++;
      }
      return false;
    });
  }
  _createLayout() {
    this._updateLayoutRect(this._option.viewBox), this._initLayoutFunc();
  }
  setLayout(layout2) {
    this._option.layout = layout2, this._initLayoutFunc();
  }
  _initLayoutFunc() {
    var _a, _b, _c;
    if (this._layoutFunc = this._option.layout, !this._layoutFunc) {
      let use3dLayout = false;
      (this._spec.zField || this._spec.series && this._spec.series.some((s2) => s2.zField)) && (use3dLayout = true);
      const constructor = Factory2.getLayoutInKey(null !== (_b = null === (_a = this._spec.layout) || void 0 === _a ? void 0 : _a.type) && void 0 !== _b ? _b : use3dLayout ? "layout3d" : "base");
      if (constructor) {
        const layout2 = new constructor(this._spec.layout, {
          onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError
        });
        this._layoutFunc = layout2.layoutItems.bind(layout2);
      }
    }
  }
  layout(params2) {
    var _a, _b, _c, _d;
    if (null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeLayoutWithSceneGraph) || void 0 === _b || _b.call(_a), this.getLayoutTag()) {
      this._event.emit(ChartEvent.layoutStart, {
        chart: this,
        vchart: this._option.globalInstance
      }), this.onLayoutStart(params2);
      const elements = this.getLayoutElements();
      this._layoutFunc(this, elements, this._layoutRect, this._viewBox), this._event.emit(ChartEvent.afterLayout, {
        elements,
        chart: this
      }), this.setLayoutTag(false), this.onLayoutEnd(params2), this._event.emit(ChartEvent.layoutEnd, {
        chart: this,
        vchart: this._option.globalInstance
      });
    }
    null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterLayoutWithSceneGraph) || void 0 === _d || _d.call(_c);
  }
  onLayoutStart(option) {
    this.getAllModels().forEach((element) => element.onLayoutStart(this._layoutRect, this._viewRect, option));
  }
  onLayoutEnd(option) {
    this.getAllModels().forEach((element) => {
      "series" !== element.modelType && element.onLayoutEnd(option);
    });
  }
  onEvaluateEnd(option) {
    [...this._components, ...this._regions, ...this._series].forEach((element) => element.onEvaluateEnd(option));
  }
  getLayoutElements() {
    return this.getAllModels().map((i) => i.layout).filter((i) => !!i);
  }
  getModelById(id) {
    const model = this._idMap.get(id);
    if (model && model instanceof BaseModel) return model;
  }
  getModelByUserId(userId) {
    const series2 = this.getSeriesInUserId(userId);
    if (series2) return series2;
    const region = this.getRegionsInUserId(userId);
    if (region) return region;
    const component2 = this.getComponentByUserId(userId);
    return component2 || void 0;
  }
  getAllMarks() {
    return Array.from(this._idMap.values()).filter((item) => item && item instanceof BaseMark);
  }
  getMarkById(id) {
    const mark = this._idMap.get(id);
    if (mark && mark instanceof BaseMark) return mark;
  }
  getMarkByUserName(name) {
    return this.getAllMarks().filter((m4) => m4.name && m4.name === name);
  }
  updateData(id, data, updateGlobalScale = true, options) {
    const dv = this._dataSet.getDataView(id);
    dv && (dv.markRunning(), dv.parseNewData(data, options)), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  updateFullData(data, updateGlobalScale = true) {
    array(data).forEach((d) => {
      const dv = this._dataSet.getDataView(d.id);
      dv && dv.markRunning();
    }), array(data).forEach((d) => {
      const dv = this._dataSet.getDataView(d.id);
      dv && updateDataViewInData(dv, d, true);
    }), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  onRender(option) {
  }
  setCanvasRect(width, height) {
    this._canvasRect = {
      width,
      height
    };
  }
  getCanvasRect() {
    return this._canvasRect || (this._canvasRect = calculateChartSize(this._spec, this._option, {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    })), this._canvasRect;
  }
  getSeriesData(id, index) {
    return this._chartData.getSeriesData(id, index);
  }
  _transformSpecScale() {
    var _a;
    const scales = this._spec.scales ? [...this._spec.scales] : [];
    let colorScaleSpec = scales.find((s2) => "color" === s2.id);
    const colorScheme3 = this.getColorScheme();
    if (!colorScaleSpec && (colorScaleSpec = {
      type: "ordinal",
      id: "color",
      domain: null,
      range: null
    }, scales.push(colorScaleSpec), this._spec.color)) {
      const colorSpec = this._spec.color;
      if (isArray_default(colorSpec)) colorScaleSpec.range = colorSpec;
      else {
        const tempSpec = colorSpec;
        Object.prototype.hasOwnProperty.call(tempSpec, "type") && (colorScaleSpec.type = tempSpec.type), Object.prototype.hasOwnProperty.call(tempSpec, "domain") && (colorScaleSpec.domain = tempSpec.domain), Object.prototype.hasOwnProperty.call(tempSpec, "range") && (colorScaleSpec.range = tempSpec.range), Object.prototype.hasOwnProperty.call(tempSpec, "specified") && (colorScaleSpec.specified = tempSpec.specified), Object.prototype.hasOwnProperty.call(tempSpec, "clamp") && (colorScaleSpec.clamp = tempSpec.clamp);
      }
    }
    return (null === (_a = colorScaleSpec.range) || void 0 === _a ? void 0 : _a.length) || (colorScaleSpec.range = getDataScheme(colorScheme3), colorScaleSpec.rangeTheme = true), scales;
  }
  _createGlobalScale() {
    this._globalScale = new GlobalScale(this._transformSpecScale(), this), this._modelOption.globalScale = this._globalScale;
  }
  updateGlobalScaleDomain() {
    const domainSet = /* @__PURE__ */ new Set();
    this._series.forEach((s2) => {
      const keys = s2.getSeriesKeys();
      keys && keys.forEach((k2) => domainSet.add(k2));
    });
    const domain = Array.from(domainSet);
    this._globalScale.updateScaleDomain(domain);
  }
  updateGlobalScale(result2) {
    mergeUpdateResult(result2, this._globalScale.updateSpec(this._transformSpecScale()));
  }
  updateGlobalScaleTheme() {
    const colorSpec = this._globalScale.getScaleSpec("color"), colorScheme3 = this.getColorScheme();
    colorSpec.rangeTheme && (colorSpec.range = getDataScheme(colorScheme3), this._globalScale.getScale("color").range(colorSpec.range));
  }
  _getSpecKeys(spec) {
    const ignoreKeys = {
      width: true,
      height: true
    };
    return Object.keys(spec).filter((key) => !ignoreKeys[key]).sort();
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (this.setLayoutTag(true, null, false), spec.type !== this.type) return result2.reMake = true, result2;
    const currentKeys = this._getSpecKeys(this._spec), nextKeys = this._getSpecKeys(spec);
    if (!isEqual(currentKeys, nextKeys)) return result2.reMake = true, result2;
    for (let i = 0; i < currentKeys.length; i++) {
      const key = currentKeys[i];
      if (isArray_default(this._spec[key]) && this._spec[key].length !== array(spec[key]).length) return result2.reMake = true, result2;
    }
    const oldSpec = this._spec;
    return this._spec = spec, this.updateChartConfig(result2, oldSpec), result2.reMake ? result2 : (this.updateGlobalScale(result2), result2.reMake ? result2 : (this.updateRegionSpec(result2), result2.reMake ? result2 : (this.updateComponentSpec(result2), result2.reMake ? result2 : (this.updateSeriesSpec(result2), result2.reMake || (this.reInit(), this.updateDataSpec(), this.updateGlobalScaleDomain()), result2))));
  }
  updateChartConfig(result2, oldSpec) {
    var _a, _b;
    this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = this._spec.padding) && void 0 !== _a ? _a : null === (_b = this._option) || void 0 === _b ? void 0 : _b.getTheme().padding), this._updateLayoutRect(this._viewBox);
  }
  updateDataSpec() {
    this._spec.data && this._chartData.updateData(this._spec.data, false, true);
  }
  updateRegionSpec(result2) {
    var _a;
    (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.region) && (this._spec.region.length === this._regions.length ? this._regions.forEach((r) => {
      mergeUpdateResult(result2, r.updateSpec(this._spec.region[r.getSpecIndex()]));
    }) : result2.reMake = true);
  }
  updateComponentSpec(result2) {
    const componentCache = {}, checkVisibleComponents = {
      [ComponentTypeEnum.title]: true,
      [ComponentTypeEnum.brush]: true,
      [ComponentTypeEnum.mapLabel]: true,
      [ComponentTypeEnum.indicator]: true
    };
    this._components.forEach((c3) => {
      var _a, _b;
      if (c3.type === ComponentTypeEnum.label || c3.type === ComponentTypeEnum.totalLabel) return;
      checkVisibleComponents[c3.type] && (checkVisibleComponents[c3.type] = false);
      const compSpecKey = c3.specKey || c3.type, cmpSpec = null !== (_a = this._spec[compSpecKey]) && void 0 !== _a ? _a : {};
      isArray_default(cmpSpec) ? (componentCache[compSpecKey] = componentCache[compSpecKey] || {
        specCount: cmpSpec.length,
        componentCount: 0
      }, componentCache[compSpecKey].componentCount++, mergeUpdateResult(result2, c3.updateSpec(null !== (_b = cmpSpec[c3.getSpecIndex()]) && void 0 !== _b ? _b : {}, cmpSpec))) : mergeUpdateResult(result2, c3.updateSpec(cmpSpec));
    });
    for (const key in componentCache) if (Object.prototype.hasOwnProperty.call(componentCache, key)) {
      const element = componentCache[key];
      element.componentCount !== element.specCount && (result2.reMake = true);
    }
    const isVisible2 = (compSpec) => compSpec && false !== compSpec.visible;
    Object.keys(checkVisibleComponents).forEach((type) => {
      if (checkVisibleComponents[type]) {
        const compSpec = this._spec[type];
        (isArray_default(compSpec) ? compSpec.some(isVisible2) : isVisible2(compSpec)) && (result2.reMake = true);
      }
    });
  }
  updateSeriesSpec(result2) {
    this._spec.series.length === this._series.length ? this._series.forEach((s2) => {
      const spec = this._spec.series[s2.getSpecIndex()];
      mergeUpdateResult(result2, s2.updateSpec(spec));
    }) : result2.reMake = true;
  }
  getCanvas() {
    var _a, _b;
    return null !== (_b = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getCanvas()) && void 0 !== _b ? _b : null;
  }
  _updateLayoutRect(viewBox) {
    let viewRect = this.getCanvasRect();
    if (viewBox) {
      this._viewBox = viewBox;
      const { x1 = 0, y1 = 0, x2, y2 } = viewBox;
      viewRect = {
        width: x2 - x1,
        height: y2 - y1
      };
    } else this._viewBox = {
      x1: 0,
      y1: 0,
      x2: viewRect.width,
      y2: viewRect.height
    };
    this._viewRect = viewRect, this.padding = calcPadding(this._paddingSpec, viewRect, viewRect), this._layoutRect.width = viewRect.width - this.padding.left - this.padding.right, this._layoutRect.height = viewRect.height - this.padding.top - this.padding.bottom, this._layoutRect.x = this.padding.left, this._layoutRect.y = this.padding.top, this._event.emit(ChartEvent.layoutRectUpdate, {
      chart: this
    });
  }
  setCurrentTheme() {
    this.updateChartConfig({
      change: true,
      reMake: false
    }, this._spec), this.setLayoutTag(true, null, false), this.updateGlobalScaleTheme(), this.reInit();
  }
  reInit() {
    [...this._regions, ...this._series, ...this._components].forEach((model) => {
      const specInfo = model.getSpecInfo();
      specInfo && specInfo.spec && model.reInit(specInfo.spec);
    });
  }
  clear() {
    this.getAllModels().forEach((i) => {
      var _a;
      return null === (_a = i.clear) || void 0 === _a ? void 0 : _a.call(i);
    });
  }
  compile() {
    this.compileBackground(), this.compileLayout(), this.compileRegions(), this.compileSeries(), this.compileComponents();
  }
  afterCompile() {
    this.getAllRegions().forEach((r) => {
      var _a;
      null === (_a = r.afterCompile) || void 0 === _a || _a.call(r);
    }), this.getAllSeries().forEach((s2) => {
      var _a;
      null === (_a = s2.afterCompile) || void 0 === _a || _a.call(s2);
    }), this.getAllComponents().forEach((c3) => {
      var _a;
      null === (_a = c3.afterCompile) || void 0 === _a || _a.call(c3);
    });
  }
  compileLayout() {
    const { width, height } = this.getCanvasRect();
    this.getCompiler().setSize(width, height);
  }
  compileBackground() {
    var _a;
    this._backgroundMark && (this._backgroundMark.compile({
      context: {
        model: this
      }
    }), null === (_a = this._backgroundMark.getProduct()) || void 0 === _a || _a.layout(() => {
    }));
  }
  compileRegions() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeRegionCompile) || void 0 === _b || _b.call(_a), this.getAllRegions().forEach((r) => {
      r.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterRegionCompile) || void 0 === _d || _d.call(_c);
  }
  compileSeries() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeSeriesCompile) || void 0 === _b || _b.call(_a), this.getAllSeries().forEach((s2) => {
      s2.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterSeriesCompile) || void 0 === _d || _d.call(_c);
  }
  compileComponents() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeComponentCompile) || void 0 === _b || _b.call(_a), this.getAllComponents().forEach((c3) => {
      c3.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterComponentCompile) || void 0 === _d || _d.call(_c);
  }
  release() {
    [...this._components, ...this._regions, ...this._series].forEach((m4) => {
      m4.beforeRelease();
    }), super.release(), this.clear(), [...this._components, ...this._regions, ...this._series].forEach((m4) => {
      m4.release();
    }), this._components = this._regions = this._series = [], this._spec = {}, this._dataSet = this._globalScale = this._layoutFunc = null, this._layoutTag = false, this._idMap.clear();
  }
  onLayout(srView) {
    const root = srView.rootMark;
    this.layout({
      group: root,
      srView
    });
  }
  updateState(state, filter2) {
    const seriesArr = this.getAllSeries();
    for (const key in state) {
      if (isEmpty_default(state[key])) continue;
      const stateSpec = state[key];
      let stateInfo = {
        stateValue: key
      };
      stateInfo = isFunction_default(stateSpec.filter) ? Object.assign({
        filter: stateSpec.filter
      }, stateInfo) : Object.assign(Object.assign({}, stateSpec.filter), stateInfo), stateSpec.level && (stateInfo.level = stateSpec.level), seriesArr.forEach((series2) => {
        series2.getMarks().forEach((m4) => {
          m4.stateStyle[key] && (filter2 && !filter2(series2, m4, key) || (m4.state.changeStateInfo(stateInfo), m4.updateMarkState(key)));
        });
      });
    }
  }
  setSelected(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_SELECTED, true, datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_HOVER, true, datum, filter2, region);
  }
  clearState(state) {
    this.getAllRegions().forEach((r) => {
      r.interaction.clearEventElement(state, true), r.interaction.resetInteraction(state, null);
    });
  }
  clearAllStates() {
    this.getAllRegions().forEach((r) => {
      r.interaction.clearAllEventElement(), r.interaction.resetAllInteraction();
    });
  }
  clearSelected() {
    this.clearState(STATE_VALUE_ENUM.STATE_SELECTED);
  }
  clearHovered() {
    this.clearState(STATE_VALUE_ENUM.STATE_HOVER);
  }
  _initEvent() {
    [ChartEvent.dataZoomChange, ChartEvent.scrollBarChange].forEach((event) => {
      this._event.on(event, ({ value }) => {
        this._disableMarkAnimation(["exit", "update"]);
        const enableMarkAnimate = () => {
          this._enableMarkAnimation(["exit", "update"]), this._event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
        };
        this._event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
      });
    });
  }
  _enableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && product.animate && product.animate.enableAnimationState(states);
    });
  }
  _disableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && product.animate && product.animate.disableAnimationState(states);
    });
  }
  filterGraphicsByDatum(datum, opt = {}) {
    var _a;
    const keys = (datum = datum ? array(datum) : null) ? Object.keys(datum[0]) : null, allElements = [], getDatumOfElement = null !== (_a = opt.getDatum) && void 0 !== _a ? _a : (el) => el.getDatum();
    return this.getRegionsInQuerier(opt.region).forEach((r) => {
      const pickElements = [];
      datum && r.getSeries().forEach((s2) => {
        s2.getMarks().forEach((m4) => {
          if (m4.getProduct() && (!opt.filter || isFunction_default(opt.filter) && opt.filter(s2, m4))) {
            const isCollect = m4.getProduct().isCollectionMark(), elements = m4.getProduct().elements;
            if (isCollect) elements.filter((e) => {
              const elDatum = getDatumOfElement(e, m4, s2, r);
              elDatum && datum.every((d, index) => keys.every((k2) => d[k2] == elDatum[index][k2])) && (pickElements.push(e), allElements.push(e), opt.callback && opt.callback(e, m4, s2, r));
            });
            else if (datum.length > 1) {
              const datumTemp = datum.slice();
              elements.forEach((e) => {
                const elDatum = getDatumOfElement(e, m4, s2, r), index = elDatum && datumTemp.findIndex((d) => keys.every((k2) => d[k2] == elDatum[k2]));
                index >= 0 && (datumTemp.splice(index, 1), pickElements.push(e), allElements.push(e), opt.callback && opt.callback(e, m4, s2, r));
              });
            } else {
              const el = elements.find((e) => {
                const elDatum = getDatumOfElement(e, m4, s2, r);
                return elDatum && keys.every((k2) => datum[0][k2] == elDatum[k2]);
              });
              el && (pickElements.push(el), allElements.push(el), opt.callback && opt.callback(el, m4, s2, r));
            }
          }
        });
      }), opt.regionCallback && opt.regionCallback(pickElements, r);
    }), allElements;
  }
  _setStateInDatum(stateKey, checkReverse, datum, filter2, region) {
    this.filterGraphicsByDatum(datum, {
      filter: filter2,
      region,
      regionCallback: (elements, r) => {
        datum ? elements.length && (elements.forEach((e) => {
          r.interaction.startInteraction(stateKey, e);
        }), checkReverse && r.interaction.reverseEventElement(stateKey)) : r.interaction.clearEventElement(stateKey, true);
      }
    });
  }
  setDimensionIndex(value, opt) {
    var _a, _b;
    let dimensionInfo = null;
    Array.from(this._event.getComposedEventMap().values()).forEach((e) => {
      const { eventType, event } = e;
      if (eventType === DimensionEventEnum.dimensionHover || eventType === DimensionEventEnum.dimensionClick) {
        const info = event.dispatch(value, opt);
        (null == info ? void 0 : info.length) && (dimensionInfo = info);
      }
    });
    const isUnableValue = isNil_default(value) || !dimensionInfo || dimensionInfo.every((d) => isDiscrete(d.axis.getScale().type) && isNil_default(d.index));
    if (false !== opt.tooltip) {
      const tooltip3 = this.getComponentsByType(ComponentTypeEnum.tooltip)[0];
      if (null == tooltip3 ? void 0 : tooltip3.getVisible()) if (isUnableValue) null === (_b = (_a = tooltip3).hideTooltip) || void 0 === _b || _b.call(_a);
      else {
        const dataFilter = {};
        dimensionInfo.forEach((d) => {
          const { axis: axis2, value: value2, data } = d, isY = "left" === axis2.getOrient() || "right" === axis2.getOrient();
          data.forEach((d2) => {
            var _a2, _b2, _c;
            const field5 = isY ? d2.series.fieldY[0] : d2.series.fieldX[0];
            dataFilter[field5] = null !== (_c = null === (_b2 = null === (_a2 = d2.datum) || void 0 === _a2 ? void 0 : _a2[0]) || void 0 === _b2 ? void 0 : _b2[field5]) && void 0 !== _c ? _c : value2;
          });
        }), tooltip3.showTooltip(dataFilter, opt.showTooltipOption);
      }
    }
    if (false !== opt.crosshair) {
      const crosshair2 = this.getComponentsByType(ComponentTypeEnum.cartesianCrosshair)[0];
      crosshair2 && crosshair2.clearAxisValue && crosshair2.setAxisValue && (isUnableValue ? crosshair2.hideCrosshair() : crosshair2.showCrosshair(dimensionInfo));
    }
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
};

// node_modules/@visactor/vchart/esm/chart/base/util.js
var getRelatedRegionInfo = (modelInfo, currentChartSpecInfo) => {
  var _a;
  const spec = modelInfo.spec, { regionId, regionIndex } = spec;
  if (isValid_default(regionId)) {
    const regionIdList = array(regionId);
    return null === (_a = currentChartSpecInfo.region) || void 0 === _a ? void 0 : _a.filter(({ spec: spec2 }) => regionIdList.includes(spec2.id));
  }
  if (isValid_default(regionIndex)) return array(regionIndex).map((index) => {
    var _a2;
    return null === (_a2 = currentChartSpecInfo.region) || void 0 === _a2 ? void 0 : _a2[index];
  }).filter(isValid_default);
};
var getRelatedSeriesInfo = (modelInfo, currentChartSpecInfo) => {
  var _a;
  const spec = modelInfo.spec, { seriesId, seriesIndex } = spec;
  if (isValid_default(seriesId)) {
    const seriesIdList = array(seriesId);
    return null === (_a = currentChartSpecInfo.series) || void 0 === _a ? void 0 : _a.filter(({ spec: spec2 }) => seriesIdList.includes(spec2.id));
  }
  if (isValid_default(seriesIndex)) return array(seriesIndex).map((index) => {
    var _a2;
    return null === (_a2 = currentChartSpecInfo.series) || void 0 === _a2 ? void 0 : _a2[index];
  }).filter(isValid_default);
};

// node_modules/@visactor/vchart/esm/chart/base/base-chart-transformer.js
var BaseChartSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type, this.seriesType = option.seriesType;
  }
  initChartSpec(chartSpec) {
    return this.transformSpec(chartSpec), this.transformModelSpec(chartSpec);
  }
  transformSpec(chartSpec) {
    chartSpec.region && 0 !== chartSpec.region.length || (chartSpec.region = [{}]), void 0 === chartSpec.tooltip && (chartSpec.tooltip = {}), isValid_default(chartSpec.stackInverse) && chartSpec.region.forEach((r) => {
      !isValid_default(r.stackInverse) && (r.stackInverse = chartSpec.stackInverse);
    }), isValid_default(chartSpec.stackSort) && chartSpec.region.forEach((r) => {
      !isValid_default(r.stackSort) && (r.stackSort = chartSpec.stackSort);
    });
  }
  generateTransform(chartSpec, isRuntime) {
    return (constructor, specInfo, chartSpecInfo) => {
      const { spec, specPath, specInfoPath, type } = specInfo, transformer = new constructor.transformerConstructor(Object.assign(Object.assign({}, this._option), {
        type
      })), transformResult = transformer.transformSpec(spec, chartSpec, chartSpecInfo), chartSpecInfoValue = Object.assign(Object.assign({}, specInfo), transformResult);
      isRuntime ? chartSpecInfoValue.theme = transformer.getTheme(spec, chartSpec) : setProperty(chartSpec, specPath, transformResult.spec), setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, chartSpecInfoValue);
    };
  }
  transformModelSpec(chartSpec) {
    return this.createSpecInfo(chartSpec, this.generateTransform(chartSpec, false));
  }
  createSpecInfo(chartSpec, transform30) {
    var _a, _b;
    transform30 || (transform30 = this.generateTransform(chartSpec, true));
    const currentChartSpecInfo = {};
    return this.forEachRegionInSpec(chartSpec, transform30, currentChartSpecInfo), this.forEachSeriesInSpec(chartSpec, transform30, currentChartSpecInfo), null === (_a = currentChartSpecInfo.series) || void 0 === _a || _a.forEach((seriesSpecInfo, i) => {
      var _a2, _b2;
      const region = (null !== (_b2 = null !== (_a2 = getRelatedRegionInfo(seriesSpecInfo, currentChartSpecInfo)) && void 0 !== _a2 ? _a2 : currentChartSpecInfo.region) && void 0 !== _b2 ? _b2 : [])[0];
      region && (region.seriesIndexes || (region.seriesIndexes = []), region.seriesIndexes.push(i), seriesSpecInfo.regionIndexes = region.regionIndexes.slice());
    }), this.forEachComponentInSpec(chartSpec, transform30, currentChartSpecInfo), Object.values(null !== (_b = currentChartSpecInfo.component) && void 0 !== _b ? _b : {}).forEach((specInfoList) => specInfoList.forEach((componentSpecInfo, i) => {
      var _a2, _b2, _c;
      if (componentSpecInfo) {
        if (!componentSpecInfo.regionIndexes) {
          const relatedRegion = null !== (_b2 = null !== (_a2 = getRelatedRegionInfo(componentSpecInfo, currentChartSpecInfo)) && void 0 !== _a2 ? _a2 : currentChartSpecInfo.region) && void 0 !== _b2 ? _b2 : [];
          componentSpecInfo.regionIndexes = relatedRegion.map((region) => region.regionIndexes[0]);
        }
        if (!componentSpecInfo.seriesIndexes) {
          const seriesInfo = getRelatedSeriesInfo(componentSpecInfo, currentChartSpecInfo);
          if (seriesInfo) componentSpecInfo.seriesIndexes = seriesInfo.map(({ seriesIndexes }) => seriesIndexes[0]);
          else {
            const seriesIndexSet = /* @__PURE__ */ new Set();
            (null !== (_c = componentSpecInfo.regionIndexes) && void 0 !== _c ? _c : []).forEach((regionIndex) => {
              var _a3, _b3;
              const region = null === (_a3 = currentChartSpecInfo.region) || void 0 === _a3 ? void 0 : _a3[regionIndex];
              null === (_b3 = null == region ? void 0 : region.seriesIndexes) || void 0 === _b3 || _b3.forEach((seriesIndex) => seriesIndexSet.add(seriesIndex));
            }), componentSpecInfo.seriesIndexes = Array.from(seriesIndexSet);
          }
        }
      }
    })), currentChartSpecInfo;
  }
  _isValidSeries(seriesType) {
    return true;
  }
  _getDefaultSeriesSpec(chartSpec, pickKeys, pickKeys2) {
    var _a, _b, _c, _d;
    const series2 = {
      dataKey: chartSpec.dataKey,
      hover: chartSpec.hover,
      select: chartSpec.select,
      label: chartSpec.label,
      seriesStyle: chartSpec.seriesStyle,
      animation: null !== (_a = chartSpec.animation) && void 0 !== _a ? _a : this._option.animation,
      animationThreshold: null !== (_b = chartSpec.animationThreshold) && void 0 !== _b ? _b : null === (_d = (_c = this._option).getTheme) || void 0 === _d ? void 0 : _d.call(_c).animationThreshold,
      animationAppear: chartSpec.animationAppear,
      animationDisappear: chartSpec.animationDisappear,
      animationEnter: chartSpec.animationEnter,
      animationUpdate: chartSpec.animationUpdate,
      animationExit: chartSpec.animationExit,
      animationNormal: chartSpec.animationNormal,
      animationState: chartSpec.animationState,
      extensionMark: chartSpec.extensionMark,
      large: chartSpec.large,
      largeThreshold: chartSpec.largeThreshold,
      progressiveStep: chartSpec.progressiveStep,
      progressiveThreshold: chartSpec.progressiveThreshold,
      background: chartSpec.seriesBackground,
      invalidType: chartSpec.invalidType,
      seriesField: chartSpec.seriesField,
      morph: chartSpec.morph,
      interactions: chartSpec.interactions
    }, seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = chartSpec[seriesType]), pickKeys && pickKeys.length && pickKeys.forEach((k2) => {
      series2[k2] = chartSpec[k2];
    }), pickKeys2 && pickKeys2.length && pickKeys2.forEach((k2) => {
      series2[k2] = chartSpec[k2];
    }), series2;
  }
  forEachRegionInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.region) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getRegionInType("region"), {
      spec,
      specPath: ["region", index],
      type: "region",
      regionIndexes: [index]
    }, chartSpecInfo));
  }
  forEachSeriesInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.series) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getSeriesInType(spec.type), {
      spec,
      specPath: ["series", index],
      type: spec.type,
      seriesIndexes: [index]
    }, chartSpecInfo));
  }
  forEachComponentInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a, _b, _c;
    const results = [], components = Factory2.getComponents();
    let cartesianAxis, polarAxis, geoCoordinate, tooltip3;
    const otherComponents = [];
    for (let index = 0; index < components.length; index++) {
      const { cmp, alwaysCheck } = components[index];
      cmp.type.startsWith(ComponentTypeEnum.cartesianAxis) ? cartesianAxis = cmp : cmp.type.startsWith(ComponentTypeEnum.polarAxis) ? polarAxis = cmp : cmp.type === ComponentTypeEnum.geoCoordinate ? geoCoordinate = cmp : (alwaysCheck || chartSpec[null !== (_a = cmp.specKey) && void 0 !== _a ? _a : cmp.type]) && (cmp.type === ComponentTypeEnum.tooltip ? tooltip3 = cmp : otherComponents.push(cmp));
    }
    let hasInitAxis = false;
    if (cartesianAxis) {
      const infoList = cartesianAxis.getSpecInfo(chartSpec, chartSpecInfo);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    if (polarAxis && !hasInitAxis) {
      const infoList = polarAxis.getSpecInfo(chartSpec, chartSpecInfo);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    return geoCoordinate && !hasInitAxis && (null === (_b = geoCoordinate.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _b || _b.forEach((info) => {
      results.push(callbackfn(geoCoordinate, info, chartSpecInfo));
    })), otherComponents.forEach((C) => {
      var _a2;
      null === (_a2 = C.getSpecInfo ? C.getSpecInfo(chartSpec, chartSpecInfo) : getSpecInfo(chartSpec, C.specKey, C.type)) || void 0 === _a2 || _a2.forEach((info) => {
        results.push(callbackfn(C, info, chartSpecInfo));
      });
    }), tooltip3 && (null === (_c = getSpecInfo(chartSpec, tooltip3.specKey, tooltip3.type)) || void 0 === _c || _c.forEach((info) => {
      results.push(callbackfn(tooltip3, info, chartSpecInfo));
    })), results;
  }
  transformSeriesSpec(spec) {
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s2) => {
      this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
        k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
  _findBandAxisBySeries(seriesSpec, seriesIndex, axesSpec) {
    const matchOrient = "horizontal" === (null == seriesSpec ? void 0 : seriesSpec.direction) ? ["left", "right"] : ["top", "bottom"];
    return axesSpec.find((axis2) => {
      if (!matchOrient.includes(axis2.orient)) return false;
      if (isValid_default(axis2.seriesId)) {
        if (array(axis2.seriesId).includes(null == seriesSpec ? void 0 : seriesSpec.id)) return true;
      } else if (isValid_default(axis2.seriesIndex)) {
        if (array(axis2.seriesIndex).includes(seriesIndex)) return true;
      } else if ("band" === axis2.type) return true;
      return true;
    });
  }
  _applyAxisBandSize(axis2, extend, barWidthSpec) {
    const { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = barWidthSpec;
    let hasBarWidth = false;
    isNumber_default(barMinWidth) ? (axis2.minBandSize = barMinWidth, hasBarWidth = true) : isNumber_default(barWidth) ? (axis2.minBandSize = barWidth, hasBarWidth = true) : isNumber_default(barMaxWidth) && (axis2.minBandSize = barMaxWidth, hasBarWidth = true), hasBarWidth && (axis2.bandSizeLevel = Number.MAX_VALUE, axis2.bandSizeExtend = {
      extend,
      gap: isArray_default(barGapInGroup) ? barGapInGroup[barGapInGroup.length - 1] : barGapInGroup
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/cartesian/cartesian-transformer.js
var CartesianChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return true;
  }
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  _getDefaultSeriesSpec(spec, pickKeys) {
    return super._getDefaultSeriesSpec(spec, ["xField", "yField", "zField", "direction", "stack", "percent", "stackOffsetSilhouette", "totalLabel", "sortDataByAxis"], pickKeys);
  }
  transformSpec(spec) {
    super.transformSpec(spec), super.transformSeriesSpec(spec), this._transformAxisSpec(spec);
  }
  _setDefaultXAxisSpec(spec) {
    return {
      orient: "bottom"
    };
  }
  _setDefaultYAxisSpec(spec) {
    return {
      orient: "left"
    };
  }
  _setDefaultZAxisSpec(spec) {
    return {
      orient: "z"
    };
  }
  _transformAxisSpec(spec) {
    if (this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        x: false,
        y: false,
        z: false
      };
      spec.axes.forEach((axis2) => {
        const { orient } = axis2;
        let defaultSpec = null;
        "top" !== orient && "bottom" !== orient || (haxAxes.x = true, defaultSpec = this._setDefaultXAxisSpec(spec)), "left" !== orient && "right" !== orient || (haxAxes.y = true, defaultSpec = this._setDefaultYAxisSpec(spec)), "z" === orient && (haxAxes.z = true, defaultSpec = this._setDefaultZAxisSpec(spec)), defaultSpec && Object.keys(defaultSpec).forEach((key) => {
          isNil_default(axis2[key]) && (axis2[key] = defaultSpec[key]);
        }), get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
      }), haxAxes.x || spec.axes.push(this._setDefaultXAxisSpec(spec)), haxAxes.y || spec.axes.push(this._setDefaultYAxisSpec(spec)), spec.zField && !haxAxes.z && spec.axes.push(this._setDefaultZAxisSpec(spec));
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/line/line-transformer.js
var LineChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    const seriesSpec = super._getDefaultSeriesSpec(spec, ["point", "line", "activePoint", "sampling", "samplingFactor", "pointDis", "pointDisMul", "markOverlap", "lineLabel"]);
    return seriesSpec.seriesMark = null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "line", seriesSpec;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/stack-split.js
var stackSplit = (data, op) => {
  const result2 = {
    nodes: {}
  }, { fields: fields2 } = op;
  if (!(null == fields2 ? void 0 : fields2.length)) return result2;
  const lastFieldIndex = fields2.length - 1;
  let nextNode, leaf, temp2 = result2;
  return data.forEach((dv) => {
    dv.latestData && dv.latestData.forEach((d) => {
      temp2 = result2;
      for (let i = 0; i < fields2.length; i++) {
        const f = fields2[i], fV = d[f];
        if (isNil_default(fV)) break;
        temp2.groupField = f, temp2.nodes[fV] || (i === lastFieldIndex ? temp2.nodes[fV] = {
          values: []
        } : (nextNode = {
          nodes: {}
        }, temp2.nodes[fV] = nextNode)), i === lastFieldIndex ? (leaf = temp2.nodes[fV], leaf.values.push(d)) : temp2 = temp2.nodes[fV];
      }
    });
  }), result2;
};

// node_modules/@visactor/vchart/esm/chart/stack.js
var Stack = class {
  constructor(chart, options) {
    this.stackRegion = ({ model }) => {
      var _a;
      const series2 = model.getSeries();
      if (!series2.some((s2) => s2.getStack())) return;
      const hasTotalLabel = series2.some((s2) => {
        var _a2, _b, _c, _d;
        return !!(null === (_b = null === (_a2 = s2.getSpec()) || void 0 === _a2 ? void 0 : _a2.totalLabel) || void 0 === _b ? void 0 : _b.alwayCalculateTotal) || (null === (_d = null === (_c = s2.getSpec()) || void 0 === _c ? void 0 : _c.totalLabel) || void 0 === _d ? void 0 : _d.visible);
      }), hasPercent = hasTotalLabel || series2.some((s2) => s2.getPercent()), hasOffsetSilhouette = series2.some((s2) => s2.getStackOffsetSilhouette()), stackValueGroup = getRegionStackGroup(model, true);
      for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stack(stackValueGroup[stackValue].nodes[key], model.getStackInverse(), hasPercent, hasTotalLabel);
      if (hasOffsetSilhouette) for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackOffsetSilhouette(stackValueGroup[stackValue].nodes[key]);
      hasTotalLabel && model.getSeries().forEach((s2) => {
        const stackData = s2.getStackData(), stackValue = s2.getStackValue(), stackValueField = s2.getStackValueField();
        stackData && stackValueField && stackTotal(stackValueGroup[stackValue], stackValueField);
      }), (null === (_a = this._options) || void 0 === _a ? void 0 : _a.afterStackRegion) && this._options.afterStackRegion(model, stackValueGroup);
    }, this._chart = chart, this._options = options;
  }
  init() {
    this._chart.getAllRegions().forEach((r) => {
      r.event.on(ChartEvent.regionSeriesDataFilterOver, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === r.id
      }, this.stackRegion);
    });
  }
  stackAll() {
    this._chart.getAllRegions().forEach((r) => {
      this.stackRegion({
        model: r
      });
    });
  }
};
var StackChartMixin = class {
  _beforeInit() {
    this._dataSet && registerDataSetInstanceTransform(this._dataSet, "stackSplit", stackSplit);
  }
  _initStack() {
    this._stack = new Stack(this), this._stack.init();
  }
};

// node_modules/@visactor/vchart/esm/chart/line/line.js
var LineChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LineChartSpecTransformer, this.type = "line", this.seriesType = SeriesTypeEnum.line;
  }
};
LineChart.type = "line", LineChart.seriesType = SeriesTypeEnum.line, LineChart.transformerConstructor = LineChartSpecTransformer, mixin(LineChart, StackChartMixin);
var registerLineChart = () => {
  registerLineSeries(), Factory2.registerChart(LineChart.type, LineChart);
};

// node_modules/@visactor/vchart/esm/mark/area.js
var AreaMark = class _AreaMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _AreaMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
  _getIgnoreAttributes() {
    return [];
  }
};
AreaMark.type = "area";
var registerAreaMark = () => {
  Factory2.registerMark(AreaMark.type, AreaMark), registerAreaGraphic2(), registerVGrammarLineOrAreaAnimation();
};

// node_modules/@visactor/vchart/esm/series/area/tooltip-helpter.js
var AreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a, _b, _c, _d;
      for (const key of array(styleKey)) {
        let value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (false !== value || "fill" !== key && "stroke" !== key || (value = "fill" === key ? null === (_c = null === (_b = this.series.getSeriesStyle(datum)) || void 0 === _b ? void 0 : _b("stroke")) || void 0 === _c ? void 0 : _c[0] : null === (_d = this.series.getSeriesStyle(datum)) || void 0 === _d ? void 0 : _d("fill")), isValid_default(value)) return value;
      }
      return defaultValue;
    };
  }
};

// node_modules/@visactor/vchart/esm/series/area/constant.js
var areaSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// node_modules/@visactor/vchart/esm/series/area/animation.js
var registerAreaSeriesAnimation = () => {
  registerAreaAnimation(), registerLineAnimation(), registerScaleInOutAnimation();
};

// node_modules/@visactor/vchart/esm/series/area/area-transformer.js
var AreaSeriesSpecTransformer = class extends LineLikeSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    const isPointVisible = false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible);
    this._addMarkLabelSpec(spec, (spec2) => {
      const isAreaMiddle = "inside-middle" === spec2.position;
      return !isPointVisible || isAreaMiddle ? "area" : "point";
    }), this._addMarkLabelSpec(spec, "area", "areaLabel", "initLineLabelMarkStyle", void 0, true);
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
    var _a, _b, _c, _d, _e;
    super._transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo);
    const { area: area2 = {}, line: line2 = {}, seriesMark } = spec, isAreaVisible = false !== area2.visible && false !== (null === (_a = area2.style) || void 0 === _a ? void 0 : _a.visible), isLineVisible = false !== line2.visible && false !== (null === (_b = line2.style) || void 0 === _b ? void 0 : _b.visible);
    area2.support3d = !(!area2.support3d && !line2.support3d), area2.zIndex = isValid_default(area2.zIndex) || isValid_default(line2.zIndex) ? Math.max(null !== (_c = area2.zIndex) && void 0 !== _c ? _c : 0, null !== (_d = line2.zIndex) && void 0 !== _d ? _d : 0) : void 0, area2.style && delete area2.style.stroke, area2.state && Object.keys(area2.state).forEach((state) => {
      "style" in area2.state[state] ? delete area2.state[state].style.stroke : delete area2.state[state].stroke;
    });
    let mainSpec = area2, subSpec = line2;
    ("line" === seriesMark || isLineVisible && !isAreaVisible) && (mainSpec = line2, subSpec = area2), area2.style = mergeSpec({}, subSpec.style, mainSpec.style), area2.state = mergeSpec({}, subSpec.state, mainSpec.state), false === area2.interactive && (area2.style.fillPickable = false), false === line2.interactive && (line2.style.strokePickable = false), area2.interactive = !(!area2.interactive && null !== (_e = line2.interactive) && void 0 !== _e && !_e), spec.area = area2, spec.line = line2;
  }
};

// node_modules/@visactor/vchart/esm/series/area/area.js
var AreaSeries = class _AreaSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.area, this.transformerConstructor = AreaSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, areaSpec = this._spec.area || {}, seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area", isAreaMarkVisible = this._isAreaVisible() || this._isLineVisible();
    this._areaMark = this._createMark(_AreaSeries.mark.area, {
      groupKey: this._seriesField,
      isSeriesMark: isAreaMarkVisible && "point" !== seriesMark,
      stateSort: areaSpec.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      morphElementKey: this.getDimensionField()[0],
      setCustomizedShape: areaSpec.customShape
    })), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    this.initAreaMarkStyle(), this.initSymbolMarkStyle();
  }
  initAreaMarkStyle() {
    var _a, _b, _c, _d, _e;
    const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "horizontal" === this._direction ? "monotoneY" : "monotoneX" : userCurveType, areaMark = this._areaMark;
    if (areaMark) {
      const isAreaVisible = this._isAreaVisible(), isLineVisible = this._isLineVisible();
      isAreaVisible || isLineVisible ? areaMark.setVisible(true) : areaMark.setVisible(false), "horizontal" === this._direction ? this.setMarkStyle(this._areaMark, {
        x: this.dataToPositionX.bind(this),
        x1: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionX1(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
        },
        y: this.dataToPositionY.bind(this),
        y1: this.dataToPositionY.bind(this),
        z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
        orient: this._direction
      }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
        x: this.dataToPositionX.bind(this),
        x1: this.dataToPositionX.bind(this),
        y1: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionY1(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
        },
        y: this.dataToPositionY.bind(this),
        z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
      }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
        fill: !!isAreaVisible && this.getColorAttribute(),
        stroke: !!isLineVisible && this.getColorAttribute()
      }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
        defined: this._getInvalidDefined.bind(this),
        connectedType: this._getInvalidConnectType()
      }, "normal", AttributeLevel.Series), this.getStack() && this.setMarkStyle(areaMark, {
        zIndex: (datum) => -datum[STACK_FIELD_END]
      }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
        curveType
      }, "normal", AttributeLevel.Built_In), Object.keys(areaMark.stateStyle).forEach((state) => {
        areaMark.stateStyle[state].stroke && areaMark.setPostProcess("stroke", (result2) => [result2, false, false, false], state);
      });
    }
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const areaAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._lineMark && this._lineMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("line")) || void 0 === _b ? void 0 : _b(areaAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._areaMark && this._areaMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("area")) || void 0 === _c ? void 0 : _c(areaAnimationParams, appearPreset), userAnimationConfig("area", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  _isAreaVisible() {
    var _a;
    const areaSpec = this._spec.area || {};
    return false !== areaSpec.visible && false !== (null === (_a = areaSpec.style) || void 0 === _a ? void 0 : _a.visible);
  }
  _isLineVisible() {
    var _a;
    const lineSpec = this._spec.line || {};
    return false !== lineSpec.visible && false !== (null === (_a = lineSpec.style) || void 0 === _a ? void 0 : _a.visible);
  }
  initTooltip() {
    this._tooltipHelper = new AreaSeriesTooltipHelper(this);
    const { group, mark } = this._tooltipHelper.activeTriggerSet;
    this._areaMark && group.add(this._areaMark), this._lineMark && group.add(this._lineMark), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  viewDataStatisticsUpdate(d) {
    super.viewDataStatisticsUpdate(d), this.encodeDefined(this._areaMark, "defined");
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d, _e;
      const seriesMarkType = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area";
      let result2 = null !== (_c = null === (_b = this._seriesMark) || void 0 === _b ? void 0 : _b.getAttribute(attribute, datum)) && void 0 !== _c ? _c : void 0;
      return "fill" !== attribute || result2 && "line" !== seriesMarkType || (attribute = "stroke", result2 = null !== (_e = null === (_d = this._seriesMark) || void 0 === _d ? void 0 : _d.getAttribute(attribute, datum)) && void 0 !== _e ? _e : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
AreaSeries.type = SeriesTypeEnum.area, AreaSeries.mark = areaSeriesMark, AreaSeries.transformerConstructor = AreaSeriesSpecTransformer, mixin(AreaSeries, LineLikeSeriesMixin);
var registerAreaSeries = () => {
  registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerAreaMark(), registerSymbolMark(), registerAreaSeriesAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(AreaSeries.type, AreaSeries);
};

// node_modules/@visactor/vchart/esm/chart/area/area-transformer.js
var AreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["point", "line", "area", "seriesMark", "activePoint", "sampling", "samplingFactor", "pointDis", "pointDisMul", "markOverlap", "areaLabel"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/area/area.js
var AreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = AreaChartSpecTransformer, this.type = "area", this.seriesType = SeriesTypeEnum.area;
  }
};
AreaChart.type = "area", AreaChart.seriesType = SeriesTypeEnum.area, AreaChart.transformerConstructor = AreaChartSpecTransformer, mixin(AreaChart, StackChartMixin);
var registerAreaChart = () => {
  registerAreaSeries(), Factory2.registerChart(AreaChart.type, AreaChart);
};

// node_modules/@visactor/vchart/esm/series/bar/animation.js
function barGrowOption(barParams, isOverall = true) {
  return (datum, element, params2) => {
    const field5 = "vertical" === barParams.direction ? barParams.yField : barParams.xField, data = null == datum ? void 0 : datum[field5];
    return "vertical" === barParams.direction ? {
      overall: isOverall ? barParams.growFrom() : isOverall,
      orient: data > 0 ? "negative" : "positive"
    } : {
      overall: !!isOverall && barParams.growFrom(),
      orient: data > 0 ? "positive" : "negative"
    };
  };
}
var barGrowIn = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: barGrowOption(params2, isOverall)
});
var barGrowOut = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthOut" : "growHeightOut",
  options: barGrowOption(params2, isOverall)
});
var Appear_FadeIn2 = {
  type: "fadeIn"
};
var Appear_ScaleIn = {
  type: "growCenterIn"
};
function barPresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn2;
    case "scaleIn":
      return Appear_ScaleIn;
    default:
      return barGrowIn(params2);
  }
}
var registerBarAnimation = () => {
  Factory2.registerAnimation("bar", (params2, preset) => ({
    appear: barPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2)
  }));
};
var registerBar3dAnimation = () => {
  Factory2.registerAnimation("bar3d", (params2, preset) => ({
    appear: barPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2)
  }));
};

// node_modules/@visactor/vchart/esm/mark/rect.js
var RectMark = class _RectMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RectMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      lineWidth: 0
    });
  }
};
RectMark.type = "rect";
var registerRectMark = () => {
  Factory2.registerMark(RectMark.type, RectMark), registerRectGraphic2(), registerVGrammarRectAnimation();
};

// node_modules/@visactor/vchart/esm/series/bar/constant.js
var barSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar: {
    name: "bar",
    type: "rect"
  },
  barBackground: {
    name: "barBackground",
    type: "rect"
  }
});
var bar3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar3d: {
    name: "bar3d",
    type: "rect3d"
  }
});

// node_modules/@visactor/vchart/esm/series/util/stack.js
function stackWithMinHeight(stackCache, stackInverse, context) {
  var _a, _b;
  if (stackCache.values.length > 0) {
    let lastY;
    if (stackCache.sortDatums.length) {
      let sortDatums = stackCache.sortDatums;
      stackInverse && (sortDatums = stackCache.sortDatums.slice().reverse());
      for (let index = 0; index < sortDatums.length; index++) lastY = computeOneDatumY(sortDatums[index].datum, lastY, sortDatums[index].series, context, null === (_b = (_a = sortDatums[index].series[context.axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), 0 === index);
    } else {
      let seriesInfo = stackCache.series;
      stackInverse && (seriesInfo = seriesInfo.slice().reverse()), seriesInfo.forEach(({ s: s2, values }, sIndex) => {
        var _a2, _b2;
        const seriesScale = null === (_b2 = (_a2 = s2[context.axisHelper]).getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0);
        for (let index = 0; index < values.length; index++) {
          const obj = values[stackInverse ? values.length - 1 - index : index];
          lastY = computeOneDatumY(obj, lastY, s2, context, seriesScale, 0 === index && 0 === sIndex);
        }
      });
    }
  }
  for (const key in stackCache.nodes) stackWithMinHeight(stackCache.nodes[key], stackInverse, context);
}
function computeOneDatumY(obj, lastY, s2, context, seriesScale, isFirst) {
  const barMinHeight = s2.getSpec().barMinHeight, inverse = s2[context.axisHelper].isInverse(), y1 = valueInScaleRange(s2[context.startMethod](obj), seriesScale);
  let y = valueInScaleRange(s2[context.endMethod](obj), seriesScale);
  isFirst && (lastY = y1);
  let height = Math.abs(y1 - y);
  height < barMinHeight && (height = barMinHeight);
  let flag = 1;
  return y < y1 ? flag = -1 : y === y1 && (flag = context.isVertical ? inverse ? 1 : -1 : inverse ? -1 : 1), y = lastY + flag * height, obj[context.start] = lastY, obj[context.end] = y, y;
}

// node_modules/@visactor/vchart/esm/series/bar/bar-transformer.js
var BarSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar");
  }
};

// node_modules/@visactor/vchart/esm/series/bar/bar.js
var BarSeries = class _BarSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar, this._barMarkName = "bar", this._barMarkType = "rect", this.transformerConstructor = BarSeriesSpecTransformer, this._bandPosition = 0, this._getBarXStart = (datum, scale4, useWholeRange) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, false, useWholeRange) : valueInScaleRange(this._dataToPosX(datum), scale4, useWholeRange), this._getBarXEnd = (datum, scale4, useWholeRange) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X1]) : valueInScaleRange(this._dataToPosX1(datum), scale4, useWholeRange), this._getBarYStart = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, true) : valueInScaleRange(this._dataToPosY(datum), scale4), this._getBarYEnd = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y1]) : valueInScaleRange(this._dataToPosY1(datum), scale4), this._getBarBackgroundXStart = (scale4) => {
      const range2 = scale4.range();
      return Math.min(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundXEnd = (scale4) => {
      const range2 = scale4.range();
      return Math.max(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundYStart = (scale4) => {
      const range2 = scale4.range();
      return Math.min(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundYEnd = (scale4) => {
      const range2 = scale4.range();
      return Math.max(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundPositionXEncoder = () => {
      var _a;
      return null === (_a = this._barBackgroundPositionXEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setBarBackgroundPositionXEncoder = (encoder2) => {
      this._barBackgroundPositionXEncoder = encoder2.bind(this);
    }, this._getBarBackgroundPositionYEncoder = () => {
      var _a;
      return null === (_a = this._barBackgroundPositionYEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setBarBackgroundPositionYEncoder = (encoder2) => {
      this._barBackgroundPositionYEncoder = encoder2.bind(this);
    };
  }
  initMark() {
    var _a, _b;
    this._initBarBackgroundMark(), this._barMark = this._createMark(Object.assign(Object.assign({}, _BarSeries.mark.bar), {
      name: this._barMarkName,
      type: this._barMarkType
    }), {
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.bar) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold,
      morphElementKey: this.getDimensionField()[0],
      morph: shouldMarkDoMorph(this._spec, this._barMarkName),
      setCustomizedShape: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.customShape
    });
  }
  _initBarBackgroundMark() {
    this._spec.barBackground && this._spec.barBackground.visible && (this._barBackgroundMark = this._createMark(_BarSeries.mark.barBackground, {
      dataView: this._barBackgroundViewData.getDataView(),
      dataProductId: this._barBackgroundViewData.getProductId(),
      stateSort: this._spec.barBackground.stateSort
    }, {
      setCustomizedShape: this._spec.barBackground.customShape,
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }));
  }
  initMarkStyle() {
    this._barMark && this.setMarkStyle(this._barMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  initTooltip() {
    super.initTooltip();
    const { mark, group } = this._tooltipHelper.activeTriggerSet;
    this._barMark && (mark.add(this._barMark), group.add(this._barMark));
  }
  _statisticViewData() {
    var _a, _b;
    super._statisticViewData();
    const spec = null !== (_a = this._spec.barBackground) && void 0 !== _a ? _a : {};
    if (!spec.visible) return;
    const hasBandAxis = this._getRelatedComponentSpecInfo("axes").some((axisInfo) => axisInfo.type === ComponentTypeEnum.cartesianBandAxis);
    let barBackgroundData;
    if (registerDataSetInstanceTransform(this._option.dataSet, "addVChartProperty", addVChartProperty), hasBandAxis) {
      const dimensionItems = ([data], { scaleDepth }) => {
        var _a2, _b2;
        let dataCollect = [{}];
        const fields2 = this.getDimensionField(), depth = isNil_default(scaleDepth) ? fields2.length : Math.min(fields2.length, scaleDepth);
        for (let i = 0; i < depth; i++) {
          const field5 = fields2[i], values = null === (_a2 = data.latestData[field5]) || void 0 === _a2 ? void 0 : _a2.values;
          if (!(null == values ? void 0 : values.length)) continue;
          const newDataCollect = [], dataKey = null !== (_b2 = this._spec.dataKey) && void 0 !== _b2 ? _b2 : DEFAULT_DATA_KEY;
          for (let j = 0; j < values.length; j++) for (let k2 = 0; k2 < dataCollect.length; k2++) newDataCollect.push(Object.assign(Object.assign({}, dataCollect[k2]), {
            [field5]: values[j],
            [dataKey]: values[j]
          }));
          dataCollect = newDataCollect;
        }
        return dataCollect;
      };
      registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", dimensionItems), barBackgroundData = new DataView(this._option.dataSet).parse([this._viewDataStatistics], {
        type: "dataview"
      }).transform({
        type: "dimensionItems",
        options: {
          scaleDepth: isNil_default(spec.fieldLevel) ? void 0 : spec.fieldLevel + 1
        }
      }, false).transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), null === (_b = this._viewDataStatistics) || void 0 === _b || _b.target.addListener("change", barBackgroundData.reRunAllTransform);
    } else {
      const dimensionItems = ([data]) => {
        const dataCollect = [], [field0, field1] = this.getDimensionContinuousField(), map4 = {};
        return viewData.latestData.forEach((datum) => {
          const key = `${datum[field0]}-${datum[field1]}`;
          map4[key] || (map4[key] = {
            [field0]: datum[field0],
            [field1]: datum[field1]
          }, dataCollect.push(map4[key]));
        }), dataCollect;
      };
      registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", dimensionItems);
      const viewData = this.getViewData();
      barBackgroundData = new DataView(this._option.dataSet).parse([viewData], {
        type: "dataview"
      }).transform({
        type: "dimensionItems"
      }, false).transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), null == viewData || viewData.target.addListener("change", barBackgroundData.reRunAllTransform);
    }
    this._barBackgroundViewData = new SeriesData(this._option, barBackgroundData);
  }
  init(option) {
    var _a, _b;
    super.init(option), "vertical" === this.direction ? "band" === (null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle() : "band" === (null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle();
  }
  _shouldDoPreCalculate() {
    const region = this.getRegion();
    return this.getStack() && region.getSeries().filter((s2) => s2.type === this.type && s2.getSpec().barMinHeight).length;
  }
  _calculateStackRectPosition(isVertical3) {
    const region = this.getRegion();
    if (region._bar_series_position_calculated) return;
    let start, end, startMethod, endMethod, axisHelper;
    region._bar_series_position_calculated = true, isVertical3 ? (start = RECT_Y1, end = RECT_Y, startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (start = RECT_X1, end = RECT_X, startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const stackValueGroup = getRegionStackGroup(region, false, (s2) => s2.type === this.type);
    for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackWithMinHeight(stackValueGroup[stackValue].nodes[key], region.getStackInverse(), {
      isVertical: isVertical3,
      start,
      end,
      startMethod,
      endMethod,
      axisHelper
    });
  }
  _calculateRectPosition(datum, isVertical3, useWholeRange) {
    var _a, _b;
    let startMethod, endMethod, axisHelper;
    isVertical3 ? (startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const seriesScale = null === (_b = (_a = this[axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = this[axisHelper].isInverse(), barMinHeight = this._spec.barMinHeight, y1 = valueInScaleRange(this[startMethod](datum), seriesScale, useWholeRange), y = valueInScaleRange(this[endMethod](datum), seriesScale, useWholeRange);
    let height = Math.abs(y1 - y);
    height < barMinHeight && (height = barMinHeight);
    let flag = 1;
    return y < y1 ? flag = -1 : y === y1 && (flag = isVertical3 ? inverse ? 1 : -1 : inverse ? -1 : 1), y1 + flag * height;
  }
  _dataToPosX(datum) {
    return this.dataToPositionX(datum);
  }
  _dataToPosX1(datum) {
    return this.dataToPositionX1(datum);
  }
  _dataToPosY(datum) {
    return this.dataToPositionY(datum);
  }
  _dataToPosY1(datum) {
    return this.dataToPositionY1(datum);
  }
  initBandRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    "horizontal" === this.direction ? this.setMarkStyle(this._barMark, {
      x: (datum) => this._getBarXStart(datum, xScale),
      x1: (datum) => this._getBarXEnd(datum, xScale),
      y: (datum) => this._getPosition(this.direction, datum),
      height: () => this._getBarWidth(this._yAxisHelper),
      width: () => {
      },
      y1: () => {
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
      y: (datum) => this._getBarYStart(datum, yScale),
      y1: (datum) => this._getBarYEnd(datum, yScale),
      x: (datum) => this._getPosition(this.direction, datum),
      width: () => this._getBarWidth(this._xAxisHelper),
      x1: () => {
      },
      height: () => {
      }
    }, "normal", AttributeLevel.Series), this._initStackBarMarkStyle(), this._initBandBarBackgroundMarkStyle();
  }
  _initStackBarMarkStyle() {
    var _a, _b, _c, _d;
    if (!this._spec.stackCornerRadius) return;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    this._barMark.setMarkConfig({
      clip: true,
      clipPath: () => {
        const rectPaths = [];
        return this._forEachStackGroup((node) => {
          let min3 = 1 / 0, max3 = -1 / 0, hasPercent = false, minPercent = 1 / 0, maxPercent = -1 / 0;
          node.values.forEach((datum) => {
            const start = datum[STACK_FIELD_START], end = datum[STACK_FIELD_END], startPercent = datum[STACK_FIELD_START_PERCENT], endPercent = datum[STACK_FIELD_END_PERCENT];
            min3 = Math.min(min3, start, end), max3 = Math.max(max3, start, end), isValid_default(startPercent) && isValid_default(endPercent) && (hasPercent = true, minPercent = Math.min(minPercent, startPercent, endPercent), maxPercent = Math.max(maxPercent, startPercent, endPercent));
          });
          const mockDatum = Object.assign(Object.assign(Object.assign({}, node.values[0]), {
            [STACK_FIELD_START]: min3,
            [STACK_FIELD_END]: max3
          }), hasPercent ? {
            [STACK_FIELD_START_PERCENT]: minPercent,
            [STACK_FIELD_END_PERCENT]: maxPercent
          } : void 0), rectAttr = "horizontal" === this.direction ? {
            x: this._getBarXStart(mockDatum, xScale),
            x1: this._getBarXEnd(mockDatum, xScale),
            y: this._getPosition(this.direction, mockDatum),
            height: this._getBarWidth(this._yAxisHelper)
          } : {
            y: this._getBarYStart(mockDatum, yScale),
            y1: this._getBarYEnd(mockDatum, yScale),
            x: this._getPosition(this.direction, mockDatum),
            width: this._getBarWidth(this._xAxisHelper)
          };
          rectPaths.push(createRect(Object.assign(Object.assign({}, rectAttr), {
            cornerRadius: isFunction_default(this._spec.stackCornerRadius) ? this._spec.stackCornerRadius(rectAttr, mockDatum, this._markAttributeContext) : this._spec.stackCornerRadius,
            fill: true
          })));
        }), rectPaths;
      }
    });
  }
  initLinearRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    if ("horizontal" === this.direction) {
      const yChannels = isValid_default(this._fieldY2) ? {
        y: (datum) => valueInScaleRange(this._dataToPosY(datum), yScale, true),
        y1: (datum) => valueInScaleRange(this._dataToPosY1(datum), yScale, true)
      } : {
        y: (datum) => valueInScaleRange(this._dataToPosY(datum) - this._getBarWidth(this._yAxisHelper) / 2, yScale, true),
        height: (datum) => this._getBarWidth(this._yAxisHelper)
      };
      this.setMarkStyle(this._barMark, Object.assign({
        x: (datum) => this._getBarXStart(datum, xScale, true),
        x1: (datum) => this._getBarXEnd(datum, xScale, true)
      }, yChannels), "normal", AttributeLevel.Series), this.setMarkStyle(this._barBackgroundMark, Object.assign({
        x: () => this._getBarBackgroundXStart(xScale),
        x1: () => this._getBarBackgroundXEnd(xScale)
      }, yChannels), "normal", AttributeLevel.Series);
    } else {
      const xChannels = isValid_default(this._fieldX2) ? {
        x: (datum) => valueInScaleRange(this._dataToPosX(datum), xScale, true),
        x1: (datum) => valueInScaleRange(this._dataToPosX1(datum), xScale, true)
      } : {
        x: (datum) => valueInScaleRange(this._dataToPosX(datum) - this._getBarWidth(this._xAxisHelper) / 2, xScale, true),
        width: (datum) => this._getBarWidth(this._xAxisHelper)
      };
      this.setMarkStyle(this._barMark, Object.assign(Object.assign({}, xChannels), {
        y: (datum) => this._getBarYStart(datum, yScale),
        y1: (datum) => this._getBarYEnd(datum, yScale)
      }), "normal", AttributeLevel.Series), this.setMarkStyle(this._barBackgroundMark, Object.assign(Object.assign({}, xChannels), {
        y: () => this._getBarBackgroundYStart(yScale),
        y1: () => this._getBarBackgroundYEnd(yScale)
      }), "normal", AttributeLevel.Series);
    }
  }
  _initBandBarBackgroundMarkStyle() {
    var _a, _b, _c, _d, _e;
    if (!this._barBackgroundMark) return;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0), spec = null !== (_e = this._spec.barBackground) && void 0 !== _e ? _e : {}, scaleDepth = isNil_default(spec.fieldLevel) ? void 0 : spec.fieldLevel + 1;
    "horizontal" === this.direction ? this.setMarkStyle(this._barBackgroundMark, {
      x: () => this._getBarBackgroundXStart(xScale),
      x1: () => this._getBarBackgroundXEnd(xScale),
      y: (datum) => this._getPosition(this.direction, datum, scaleDepth, "barBackground"),
      height: () => this._getBarWidth(this._yAxisHelper, scaleDepth),
      width: () => {
      },
      y1: () => {
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barBackgroundMark, {
      x: (datum) => this._getPosition(this.direction, datum, scaleDepth, "barBackground"),
      y: () => this._getBarBackgroundYStart(yScale),
      y1: () => this._getBarBackgroundYEnd(yScale),
      width: () => this._getBarWidth(this._xAxisHelper, scaleDepth),
      x1: () => {
      },
      height: () => {
      }
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const barAnimationParams = {
      yField: this._fieldY[0],
      xField: this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2;
        const scale4 = "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0) : this._yAxisHelper.getScale(0);
        if (scale4) {
          const domain = scale4.domain(), domainMin = minInArray(domain), domainMax = maxInArray(domain);
          return domainMax < 0 ? scale4.scale(domainMax) : domainMin > 0 ? scale4.scale(domainMin) : scale4.scale(0);
        }
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("bar")) || void 0 === _b ? void 0 : _b(barAnimationParams, appearPreset), userAnimationConfig(this._barMarkName, this._spec, this._markAttributeContext), animationParams));
  }
  _getBarWidth(axisHelper, scaleDepth) {
    var _a, _b;
    const depthFromSpec = this._groups ? this._groups.fields.length : 1, depth = isNil_default(scaleDepth) ? depthFromSpec : Math.min(depthFromSpec, scaleDepth), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, depth - 1)) && void 0 !== _b ? _b : 6, hasBarWidth = isValid_default(this._spec.barWidth) && depth === depthFromSpec, hasBarMinWidth = isValid_default(this._spec.barMinWidth), hasBarMaxWidth = isValid_default(this._spec.barMaxWidth);
    let width = bandWidth;
    return hasBarWidth && (width = getActualNumValue(this._spec.barWidth, bandWidth)), hasBarMinWidth && (width = Math.max(width, getActualNumValue(this._spec.barMinWidth, bandWidth))), hasBarMaxWidth && (width = Math.min(width, getActualNumValue(this._spec.barMaxWidth, bandWidth))), width;
  }
  _getPosition(direction, datum, scaleDepth, mark) {
    var _a, _b, _c, _d, _e;
    let axisHelper, sizeAttribute, dataToPosition;
    "horizontal" === direction ? (axisHelper = this.getYAxisHelper(), sizeAttribute = "height", dataToPosition = "barBackground" === mark ? this.dataToBarBackgroundPositionY.bind(this) : this.dataToPositionY.bind(this)) : (axisHelper = this.getXAxisHelper(), sizeAttribute = "width", dataToPosition = "barBackground" === mark ? this.dataToBarBackgroundPositionX.bind(this) : this.dataToPositionX.bind(this));
    const scale4 = axisHelper.getScale(0), depthFromSpec = this._groups ? this._groups.fields.length : 1, depth = isNil_default(scaleDepth) ? depthFromSpec : Math.min(depthFromSpec, scaleDepth), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, depth - 1)) && void 0 !== _b ? _b : 6, size = depth === depthFromSpec ? this._barMark.getAttribute(sizeAttribute, datum) : bandWidth;
    if (depth > 1 && isValid_default(this._spec.barGapInGroup)) {
      const groupFields = this._groups.fields, barInGroup = array(this._spec.barGapInGroup);
      let totalWidth = 0, offSet = 0;
      for (let index = groupFields.length - 1; index >= 1; index--) {
        const groupField = groupFields[index], groupValues = null !== (_d = null === (_c = axisHelper.getScale(index)) || void 0 === _c ? void 0 : _c.domain()) && void 0 !== _d ? _d : [], groupCount = groupValues.length, gap = getActualNumValue(null !== (_e = barInGroup[index - 1]) && void 0 !== _e ? _e : last(barInGroup), bandWidth), i = groupValues.indexOf(datum[groupField]);
        index === groupFields.length - 1 ? (totalWidth += groupCount * size + (groupCount - 1) * gap, offSet += i * (size + gap)) : (offSet += i * (totalWidth + gap), totalWidth += totalWidth + (groupCount - 1) * gap);
      }
      return scale4.scale(datum[groupFields[0]]) + axisHelper.getBandwidth(0) / 2 - totalWidth / 2 + offSet;
    }
    const continuous = isContinuous(scale4.type || "band");
    return dataToPosition(datum, depth) + 0.5 * (bandWidth - size) + (continuous ? -bandWidth / 2 : 0);
  }
  dataToBarBackgroundPositionX(datum, scaleDepth) {
    return this._dataToPosition(datum, this._xAxisHelper, this.fieldX, scaleDepth, this._getBarBackgroundPositionXEncoder, this._setBarBackgroundPositionXEncoder);
  }
  dataToBarBackgroundPositionY(datum, scaleDepth) {
    return this._dataToPosition(datum, this._yAxisHelper, this.fieldY, scaleDepth, this._getBarBackgroundPositionYEncoder, this._setBarBackgroundPositionYEncoder);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx);
    this.getRegion()._bar_series_position_calculated = false, this._spec.sampling && this.compile();
  }
  compile() {
    if (super.compile(), this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "horizontal" === this._direction ? height : width,
        factor: this._spec.samplingFactor,
        yfield: "horizontal" === this._direction ? fieldsX[0] : fieldsY[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._barMark];
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.compile();
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  viewDataUpdate(d) {
    var _a, _b, _c;
    super.viewDataUpdate(d), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._barBackgroundViewData) || void 0 === _c || _c.updateData();
  }
  release() {
    var _a;
    super.release(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.release(), this._barBackgroundViewData = null;
  }
};
BarSeries.type = SeriesTypeEnum.bar, BarSeries.mark = barSeriesMark, BarSeries.transformerConstructor = BarSeriesSpecTransformer;
var registerBarSeries = () => {
  registerSampleTransform(), registerRectMark(), registerBarAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(BarSeries.type, BarSeries);
};

// node_modules/@visactor/vchart/esm/chart/bar/bar-transformer.js
var BarChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["barWidth", "barMaxWidth", "barMinWidth", "barGapInGroup", "barMinHeight", "sampling", "samplingFactor", "barBackground", "stackCornerRadius"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
  _transformAxisSpec(spec) {
    var _a, _b;
    if (super._transformAxisSpec(spec), !spec.axes) return;
    const isHorizontal4 = spec.series.some((series2) => "horizontal" === series2.direction), bandAxis = null !== (_a = spec.axes.find((axis2) => "band" === axis2.type)) && void 0 !== _a ? _a : spec.axes.find((axis2) => (isHorizontal4 ? ["left", "right"] : ["top", "bottom"]).includes(axis2.orient));
    if (bandAxis && !bandAxis.bandSize && !bandAxis.maxBandSize && !bandAxis.minBandSize && spec.autoBandSize) {
      const extend = isObject_default(spec.autoBandSize) && null !== (_b = spec.autoBandSize.extend) && void 0 !== _b ? _b : 0, { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = spec.series.find((series2) => "bar" === series2.type);
      this._applyAxisBandSize(bandAxis, extend, {
        barMaxWidth,
        barMinWidth,
        barWidth,
        barGapInGroup
      });
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/bar/bar.js
var BarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BarChartSpecTransformer, this.type = "bar", this.seriesType = SeriesTypeEnum.bar;
  }
};
BarChart.type = "bar", BarChart.seriesType = SeriesTypeEnum.bar, BarChart.transformerConstructor = BarChartSpecTransformer, mixin(BarChart, StackChartMixin);
var registerBarChart = () => {
  registerBarSeries(), Factory2.registerChart(BarChart.type, BarChart);
};

// node_modules/@visactor/vchart/esm/mark/rect-3d.js
var Rect3dMark = class _Rect3dMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _Rect3dMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      length: 3
    });
  }
};
Rect3dMark.type = "rect3d";
var registerRect3dMark = () => {
  Factory2.registerMark(Rect3dMark.type, Rect3dMark), registerRect3dGraphic2(), registerVGrammarRectAnimation();
};

// node_modules/@visactor/vchart/esm/series/bar/bar-3d-transformer.js
var Bar3dSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar3d");
  }
};

// node_modules/@visactor/vchart/esm/series/bar/bar-3d.js
var Bar3dSeries = class extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar3d, this._barMarkName = "bar3d", this._barMarkType = "rect3d", this.transformerConstructor = Bar3dSeriesSpecTransformer;
  }
};
Bar3dSeries.type = SeriesTypeEnum.bar3d, Bar3dSeries.mark = bar3dSeriesMark, Bar3dSeries.transformerConstructor = Bar3dSeriesSpecTransformer;
var registerBar3dSeries = () => {
  registerBar3dAnimation(), registerRect3dMark(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(Bar3dSeries.type, Bar3dSeries);
};

// node_modules/@visactor/vchart/esm/chart/bar/3d/bar-3d-transformer.js
var Bar3dChartSpecTransformer = class extends BarChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const seriesSpec = super._getDefaultSeriesSpec(spec);
    return seriesSpec.barWidth = spec.barWidth, seriesSpec.barMaxWidth = spec.barMaxWidth, seriesSpec.barMinWidth = spec.barMinWidth, seriesSpec.barGapInGroup = spec.barGapInGroup, seriesSpec;
  }
};

// node_modules/@visactor/vchart/esm/plugin/other.js
var register3DPlugin = () => {
  registerDirectionalLight(), registerOrthoCamera(), registerViewTransform3dPlugin();
};
var registerAnimate2 = () => {
  registerAnimate(), registerVGrammarCommonAnimation();
};
var registerMorph = registerViewMorphAPI;

// node_modules/@visactor/vchart/esm/chart/bar/3d/bar-3d.js
var Bar3dChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Bar3dChartSpecTransformer, this.type = "bar3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Bar3dChart.type = "bar3d", Bar3dChart.seriesType = SeriesTypeEnum.bar3d, Bar3dChart.transformerConstructor = Bar3dChartSpecTransformer;
var registerBar3dChart = () => {
  register3DPlugin(), registerBar3dSeries(), Factory2.registerChart(Bar3dChart.type, Bar3dChart);
};

// node_modules/@visactor/vchart/esm/constant/scatter.js
var SCATTER_DEFAULT_SIZE = 10;
var SCATTER_DEFAULT_RANGE_SIZE = [10, 20];
var SCATTER_DEFAULT_SIZE_SCALE_TYPE = ScaleEnum.Linear;
var SCATTER_DEFAULT_SHAPE = "circle";
var SCATTER_DEFAULT_SHAPE_SCALE_TYPE = ScaleEnum.Ordinal;
var SCATTER_DEFAULT_RANGE_SHAPE = ["circle", "square", "triangle", "diamond", "star"];

// node_modules/@visactor/vchart/esm/series/scatter/animation.js
var scatterPresetAnimation = (_params, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "scaleIn"
};
var registerScatterAnimation = () => {
  Factory2.registerAnimation("scatter", (params2, preset) => Object.assign({
    appear: scatterPresetAnimation(0, preset)
  }, ScaleInOutAnimation));
};

// node_modules/@visactor/vchart/esm/series/scatter/constant.js
var scatterSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  point: {
    name: "point",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/scatter/scatter-transformer.js
var ScatterSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "point");
  }
};

// node_modules/@visactor/vchart/esm/series/scatter/scatter.js
var ScatterSeries = class _ScatterSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.scatter, this.transformerConstructor = ScatterSeriesSpecTransformer, this._invalidType = "zero";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
  }
  _getSeriesAttribute(field5, spec, { defaultScaleType, defaultRange }, key) {
    var _a, _b, _c, _d;
    if (isFunction_default(spec)) return spec;
    if (isArray_default(spec)) {
      if (isNil_default(field5)) return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), spec;
      if ("ordinal" !== defaultScaleType && spec.length > 2) return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`;
      return this._option.globalScale.registerModelScale({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field5]
        }],
        range: spec
      }), {
        scale: scaleName,
        field: field5
      };
    }
    if (isObject_default(spec)) {
      if (isNil_default(field5)) return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field5]
        }],
        range: defaultRange
      }, spec);
      return this._option.globalScale.registerModelScale(visualSpec), {
        scale: visualSpec.id,
        field: field5
      };
    }
    return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), spec;
  }
  getSizeAttribute(field5, sizeSpec) {
    return isNil_default(sizeSpec) ? SCATTER_DEFAULT_SIZE : isNumber_default(sizeSpec) ? sizeSpec : isString_default(sizeSpec) && isNumeric_default(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field5, sizeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SIZE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SIZE
    }, "size");
  }
  getShapeAttribute(field5, shapeSpec) {
    return isNil_default(shapeSpec) ? SCATTER_DEFAULT_SHAPE : isString_default(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field5, shapeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SHAPE
    }, "shape");
  }
  initMark() {
    var _a, _b;
    this._symbolMark = this._createMark(_ScatterSeries.mark.point, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold,
      morph: shouldMarkDoMorph(this._spec, _ScatterSeries.mark.point.name),
      morphElementKey: this.getDimensionField()[0],
      setCustomizedShape: null === (_b = this._spec.point) || void 0 === _b ? void 0 : _b.customShape
    });
  }
  initMarkStyle() {
    this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._symbolMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
      visible: this._getInvalidDefined.bind(this)
    }), this.setMarkStyle(symbolMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
      fill: this.getColorAttribute(),
      size: isNumber_default(this._size) || isFunction_default(this._size) ? this._size : SCATTER_DEFAULT_SIZE,
      symbolType: isString_default(this._shape) || isFunction_default(this._shape) ? this._shape : SCATTER_DEFAULT_SHAPE
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), (isValid_default(this._sizeField) || isValid_default(this._size)) && this.setMarkStyle(symbolMark, {
      size: this.getSizeAttribute(this._sizeField, this._size)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), (isValid_default(this._shapeField) || isValid_default(this._shape)) && this.setMarkStyle(symbolMark, {
      symbolType: this.getShapeAttribute(this._shapeField, this._shape)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark));
  }
  initTooltip() {
    super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
  }
  viewDataStatisticsUpdate(d) {
    super.viewDataStatisticsUpdate(d);
    const allValid = [this.getDimensionField()[0], this.getStackValueField()].every((field5) => {
      var _a, _b, _c;
      return field5 && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field5]) || void 0 === _c ? void 0 : _c.allValid);
    });
    "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
      visible: true
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
      visible: this._getInvalidDefined.bind(this)
    }, "normal", AttributeLevel.Series), this._symbolMark.getProduct() && this._symbolMark.compileEncode();
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined.bind(this)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  handleZoom(e) {
    var _a, _b;
    this.getMarksWithoutRoot().forEach((mark) => {
      const vGrammarMark = mark.getProduct();
      if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
      vGrammarMark.elements.forEach((el, i) => {
        const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
        newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
      });
    });
    const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  handlePan(e) {
    this.handleZoom(e);
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._symbolMark];
  }
};
ScatterSeries.type = SeriesTypeEnum.scatter, ScatterSeries.mark = scatterSeriesMark, ScatterSeries.transformerConstructor = ScatterSeriesSpecTransformer;
var registerScatterSeries = () => {
  registerSymbolMark(), registerScatterAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(ScatterSeries.type, ScatterSeries);
};

// node_modules/@visactor/vchart/esm/chart/scatter/scatter-transformer.js
var ScatterChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["point", "size", "shape", "shapeField", "sizeField"]);
  }
};

// node_modules/@visactor/vchart/esm/chart/scatter/scatter.js
var ScatterChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = ScatterChartSpecTransformer, this.type = "scatter", this.seriesType = SeriesTypeEnum.scatter;
  }
};
ScatterChart.type = "scatter", ScatterChart.seriesType = SeriesTypeEnum.scatter, ScatterChart.transformerConstructor = ScatterChartSpecTransformer, mixin(ScatterChart, StackChartMixin);
var registerScatterChart = () => {
  registerScatterSeries(), Factory2.registerChart(ScatterChart.type, ScatterChart);
};

// node_modules/@visactor/vgrammar-projection/es/projections.js
var defaultPath2 = path_default();
var projections = {};
var projectionProperties2 = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "precision", "reflectX", "reflectY", "parallels", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
function create(type, constructor) {
  return function projectionGenerator() {
    const p = constructor();
    return p.type = type, p.path = path_default().projection(p), p.copy = p.copy || function() {
      const c3 = projectionGenerator();
      return projectionProperties2.forEach((prop) => {
        p[prop] && c3[prop](p[prop]());
      }), c3.path.pointRadius(p.path.pointRadius()), c3;
    }, p;
  };
}
function projection2(type, proj) {
  type && isString_default(type) || error2("Projection type must be a name string.");
  const projectionType = type.toLowerCase();
  return arguments.length > 1 && (projections[projectionType] = create(projectionType, proj)), projections[projectionType] || null;
}
var builtInProjections = {
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default,
  mercator: mercator_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
Object.keys(builtInProjections).forEach((projectionType) => {
  projection2(projectionType, builtInProjections[projectionType]);
});

// node_modules/@visactor/vgrammar-projection/es/projection.js
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => !isNil_default(d)).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}
function collectGeoJSON(data) {
  const arrayData = array(data);
  return 1 === arrayData.length ? arrayData[0] : {
    type: FeatureCollection,
    features: arrayData.reduce((a3, f) => a3.concat(featurize(f)), [])
  };
}
function create2(type) {
  const constructor = projection2((type || "mercator").toLowerCase());
  return constructor || error2("Unrecognized projection type: " + type), constructor();
}
function set(proj, key, value) {
  isFunction_default(proj[key]) && proj[key](value);
}
var projectionOptions = projectionProperties2.concat(["pointRadius", "fit", "extent", "size"]);
function parseProjection(spec, view) {
  let refs = [];
  return spec ? (Object.keys(spec).forEach((key) => {
    projectionOptions.includes(key) && (refs = refs.concat(parseFunctionType(spec[key], view)));
  }), refs) : refs;
}
var Projection = class extends GrammarBase {
  constructor(view) {
    super(view), this.grammarType = "projection";
  }
  parse(spec) {
    return super.parse(spec), this.pointRadius(spec.pointRadius), this.size(spec.size), this.extent(spec.extent), this.fit(spec.fit), this.configure(spec), this.commit(), this;
  }
  pointRadius(pointRadius) {
    return isNil_default(this.spec.pointRadius) || this.detach(parseFunctionType(this.spec.pointRadius, this.view)), this.spec.pointRadius = pointRadius, this.attach(parseFunctionType(pointRadius, this.view)), this.commit(), this;
  }
  size(data) {
    return isNil_default(this.spec.size) || this.detach(parseFunctionType(this.spec.size, this.view)), this.spec.size = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  extent(data) {
    return isNil_default(this.spec.extent) || this.detach(parseFunctionType(this.spec.extent, this.view)), this.spec.extent = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  fit(data) {
    return isNil_default(this.spec.fit) || this.detach(parseFunctionType(this.spec.fit, this.view)), this.spec.fit = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  configure(config2) {
    return this.detach(parseProjection(this.spec, this.view)), isNil_default(config2) ? this.spec = {
      type: this.spec.type,
      fit: this.spec.fit,
      extent: this.spec.extent,
      size: this.spec.size,
      pointRadius: this.spec.pointRadius
    } : (Object.assign(this.spec, config2), this.attach(parseProjection(this.spec, this.view))), this.commit(), this;
  }
  evaluate(upstream, parameters) {
    if (this.projection && this.projection.type === this.spec.type || (this.projection = create2(this.spec.type), this.projection.type = this.spec.type), projectionProperties2.forEach((prop) => {
      isNil_default(this.spec[prop]) || set(this.projection, prop, invokeFunctionType(this.spec[prop], parameters, projection2));
    }), isNil_default(this.spec.pointRadius) || this.projection.path.pointRadius(invokeFunctionType(this.spec.pointRadius, parameters, projection2)), !(isNil_default(this.spec.fit) || isNil_default(this.spec.extent) && isNil_default(this.spec.size))) {
      const data = collectGeoJSON(invokeFunctionType(this.spec.fit, parameters, projection2));
      this.spec.extent ? this.projection.fitExtent(invokeFunctionType(this.spec.extent, parameters, projection2), data) : this.spec.size && this.projection.fitSize(invokeFunctionType(this.spec.size, parameters, projection2), data);
    }
    return this.projection;
  }
  output() {
    return this.projection;
  }
};

// node_modules/@visactor/vgrammar-projection/es/index.js
var registerProjection = () => {
  Factory3.registerGrammar("projection", Projection, "projections");
};

// node_modules/@visactor/vchart/esm/data/transforms/lookup.js
var lookup = (data, opt) => {
  if (!opt.from || !opt.from()) return data;
  const fields2 = opt.fields, key = opt.key, values = opt.values, defaultValue = opt.default, as = opt.as || [fields2], index = opt.from().reduce(function(map4, obj) {
    return obj[fields2] && map4.set(obj[fields2], obj), map4;
  }, /* @__PURE__ */ new Map());
  let set2;
  if (isFunction_default(opt.set)) set2 = function(d) {
    const v = index.get(d[key]);
    opt.set(d, v);
  };
  else if (values) {
    const m4 = values.length;
    set2 = function(d) {
      const v = index.get(d[key]);
      if (isNil_default(v)) for (let i = 0; i < m4; ++i) d[as[i]] = defaultValue;
      else for (let i = 0; i < m4; ++i) d[as[i]] = v[values[i]];
    };
  } else set2 = function(d) {
    const v = index.get(d[key]);
    d[as[0]] = isValid_default(v) ? v : defaultValue;
  };
  return 0 === data.length ? [] : data.map((d) => (set2(d), d));
};

// node_modules/@visactor/vchart/esm/series/geo/geo.js
var GeoSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.geo, this.coordinate = "geo", this._nameProperty = "name";
  }
  getMapViewData() {
    var _a;
    return null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView();
  }
  get nameField() {
    return this._nameField;
  }
  set nameField(f) {
    this._nameField = f;
  }
  get valueField() {
    return this._valueField;
  }
  set valueField(f) {
    this._valueField = f;
  }
  getNameProperty() {
    return this._nameProperty;
  }
  getCentroidProperty() {
    return this._centroidProperty;
  }
  getCoordinateHelper() {
    return this._coordinateHelper;
  }
  setCoordinateHelper(h) {
    this._coordinateHelper = h;
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  getGroupFields() {
    return null;
  }
  dataToPosition(datum, checkInViewData) {
    var _a;
    let result2 = null;
    if (!datum) return result2;
    if (checkInViewData && !this.isDatumInViewData(datum)) return result2;
    const { dataToPosition, latitudeField, longitudeField } = this._coordinateHelper;
    if (result2 = this.nameToPosition(datum), null === result2) {
      const lonValue = longitudeField ? null == datum ? void 0 : datum[longitudeField] : Number.NaN, latValue = latitudeField ? null == datum ? void 0 : datum[latitudeField] : Number.NaN;
      result2 = null !== (_a = null == dataToPosition ? void 0 : dataToPosition([lonValue, latValue])) && void 0 !== _a ? _a : null;
    }
    return result2;
  }
  nameToPosition(datum) {
    const name = this.getDatumName(datum);
    return isNil_default(name) ? null : this.nameValueToPosition(name);
  }
  nameValueToPosition(name) {
    var _a, _b;
    const mapData = null === (_b = null === (_a = this.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.filter((data) => this.getDatumName(data) === name)[0];
    if (isNil_default(mapData)) return null;
    const { dataToPosition } = this._coordinateHelper, center2 = this.getDatumCenter(mapData), pos = null == dataToPosition ? void 0 : dataToPosition(center2);
    return isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) ? null : pos;
  }
  dataToLatitude(latValue) {
    if (!this._coordinateHelper) return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(latValue);
  }
  dataToLongitude(lonValue) {
    if (!this._coordinateHelper) return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(lonValue);
  }
  valueToPosition(lonValue, latValue) {
    return {
      x: this.dataToLongitude(lonValue),
      y: this.dataToLatitude(latValue)
    };
  }
  positionToData(p) {
  }
  latitudeToData(lat) {
  }
  longitudeToData(lon) {
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionZ(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  release() {
    super.release(), this._mapViewData.release(), this._mapViewData = this._mapViewDataStatistics = null;
  }
  getStackGroupFields() {
    return [this._nameField];
  }
  getStackValueField() {
    return this._spec.valueField;
  }
  compileData() {
    var _a;
    null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
  }
  initStatisticalData() {
    if (super.initStatisticalData(), this._mapViewData) {
      const viewDataName = `${PREFIX}_series_${this.id}_mapViewDataStatic`;
      this._mapViewDataStatistics = this.createStatisticalData(viewDataName, this._mapViewData.getDataView()), this._mapViewData.getDataView().target.removeListener("change", this._mapViewDataStatistics.reRunAllTransform);
    }
  }
  getSeriesKeys() {
    var _a, _b, _c, _d, _e;
    return this._seriesField ? null !== (_e = null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : null === (_d = null === (_c = this._mapViewDataStatistics) || void 0 === _c ? void 0 : _c.latestData[this._seriesField]) || void 0 === _d ? void 0 : _d.values) && void 0 !== _e ? _e : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_a = this._mapViewData.getDataView()) || void 0 === _a || _a.reRunAllTransform(), null === (_b = this._mapViewDataStatistics) || void 0 === _b || _b.reRunAllTransform();
  }
  getActiveMarks() {
    return [];
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/map.js
var DEFAULT_MAP_LOOK_UP_KEY = `${PREFIX}_MAP_LOOK_UP_KEY`;
var map3 = (data, opt) => (data.features && data.features.forEach((f, index) => {
  var _a;
  f[DEFAULT_DATA_INDEX] = index;
  const name = null === (_a = f.properties) || void 0 === _a ? void 0 : _a[opt.nameProperty];
  opt.nameMap && opt.nameMap[name] ? f[DEFAULT_MAP_LOOK_UP_KEY] = opt.nameMap[name] : f[DEFAULT_MAP_LOOK_UP_KEY] = name;
}), data.features);

// node_modules/@visactor/vchart/esm/series/map/tooltip-helper.js
var MapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum) => {
      var _a;
      const series2 = this.series;
      return null !== (_a = this._getDimensionData(datum)) && void 0 !== _a ? _a : series2.getDatumName(datum);
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/path.js
var PathMark = class _PathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _PathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0,
      path: ""
    });
  }
};
PathMark.type = "path";
var registerPathMark = () => {
  Factory2.registerMark(PathMark.type, PathMark), registerPathGraphic2();
};

// node_modules/@visactor/vchart/esm/series/map/constant.js
var mapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  area: {
    name: "area",
    type: "path"
  }
});

// node_modules/@visactor/vchart/esm/component/geo/projection.js
var Projection2 = class {
  constructor(projectionSpec) {
    this.projection = projection2(projectionSpec.type)();
  }
  fit(start, size, features) {
    const fitData = {
      type: "FeatureCollection",
      features
    };
    this.projection.fitExtent([start, size], fitData);
  }
  center(center2) {
    var _a, _b;
    null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.center) || void 0 === _b || _b.call(_a, center2);
  }
  project(point6) {
    var _a;
    return null === (_a = this.projection) || void 0 === _a ? void 0 : _a.call(this, point6);
  }
  shape(data) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.path) || void 0 === _b ? void 0 : _b.call(_a, data);
  }
  invert(point6) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.invert) || void 0 === _b ? void 0 : _b.call(_a, point6);
  }
  scale(scale4) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === scale4) return this.projection.scale();
      this.projection.scale(scale4);
    }
  }
  translate(point6) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === point6) return this.projection.translate();
      this.projection.translate(point6);
    }
  }
  evaluate(start, size, features) {
    const tmp = this.projection.copy();
    return null == tmp ? void 0 : tmp.fitExtent([start, size], {
      type: "FeatureCollection",
      features
    });
  }
};

// node_modules/@visactor/vchart/esm/component/common/trigger/desktop.js
var DeskTopTrigger = class {
  parserScrollEvent(e) {
    return e ? !(e.ctrlKey || 0 === e.deltaY && 0 === e.deltaX) && (e.scrollX = e.deltaX, e.scrollY = e.deltaY, e) : e;
  }
  parserZoomEvent(e) {
    if (!e) return e;
    const zoom = Math.pow(1.0005, -e.deltaY * Math.pow(16, e.deltaMode));
    return e.zoomDelta = zoom, e.zoomX = e.canvasX, e.zoomY = e.canvasY, e;
  }
  clearZoom() {
  }
  clearScroll() {
  }
  clearDrag() {
  }
};

// node_modules/@visactor/vchart/esm/component/common/trigger/mobile.js
var MobileTrigger = class {
  constructor() {
    this._lastScale = 0;
  }
  clearZoom() {
    this._lastScale = 0;
  }
  parserZoomEvent(event) {
    const scale4 = event.scale;
    if (0 === this._lastScale) return this._lastScale = scale4, event;
    event.zoomDelta = scale4 / this._lastScale;
    const center2 = event.center;
    return event.zoomX = center2.x, event.zoomY = center2.y, this._lastScale = scale4, event;
  }
  parserScrollEvent(event) {
    return event;
  }
  clearScroll() {
  }
  clearDrag() {
  }
};

// node_modules/@visactor/vchart/esm/component/common/trigger/config.js
function getDefaultTriggerEventByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    start: "pointerdown",
    move: "pointermove",
    end: ["pointerup", "pointerupoutside"],
    zoom: "wheel",
    zoomEnd: "pointerup",
    scroll: "wheel",
    trigger: DeskTopTrigger
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    start: "pointerdown",
    move: "pointermove",
    end: ["pointerup", "pointerupoutside", "pointerleave"],
    zoom: "pinch",
    zoomEnd: "pinchend",
    scroll: "pan",
    scrollEnd: "panend",
    trigger: MobileTrigger
  } : null;
}

// node_modules/@visactor/vchart/esm/interaction/zoom/zoomable.js
var delayMap4 = {
  debounce: debounce_default,
  throttle: throttle_default
};
var Zoomable = class {
  constructor() {
    this._isGestureListener = false;
  }
  initZoomable(evt, mode = RenderModeEnum["desktop-browser"]) {
    this._eventObj = evt, this._renderMode = mode, this._gestureController = this._option.getChart().getVGrammarView().renderer._gestureController, this._isGestureListener = isMobileLikeMode(this._renderMode) || isMiniAppLikeMode(this._renderMode), getDefaultTriggerEventByMode(this._renderMode) && (this._clickEnable = true, this._zoomableTrigger = new (this._getZoomTriggerEvent("trigger"))());
  }
  _getZoomTriggerEvent(type) {
    return getDefaultTriggerEventByMode(this._renderMode)[type];
  }
  _zoomEventDispatch(params2, regionOrSeries, callback, allowComponentZoom) {
    if (!this._isGestureListener && !params2.event) return;
    const event = this._isGestureListener ? params2 : params2.event.clone();
    this._zoomableTrigger.parserZoomEvent(event);
    const { zoomDelta, zoomX, zoomY, path } = event;
    if (!allowComponentZoom && !path.some((node) => node.name && node.name.includes("region"))) return;
    if (isNil_default(zoomDelta)) return;
    if (!pointInRect({
      x: zoomX,
      y: zoomY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false)) return;
    this._clearDragEvent(), this._zoomableTrigger.clearScroll();
    let extendParams = {};
    callback && (extendParams = callback({
      zoomDelta,
      zoomX,
      zoomY
    }, event)), this._eventObj.emit("zoom", Object.assign(Object.assign({
      scale: event.zoomDelta,
      scaleCenter: {
        x: event.zoomX,
        y: event.zoomY
      }
    }, extendParams), {
      model: this
    }));
  }
  _getRegionOrSeriesLayout(rs) {
    "region" !== rs.type && (rs = rs.getRegion());
    const { x, y, width, height } = rs.layout.getLayout();
    return {
      x1: x,
      y1: y,
      x2: x + width,
      y2: y + height
    };
  }
  _bindZoomEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, zoomParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoom")] : [this._getZoomTriggerEvent("zoom"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], zoomEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoomEnd")] : [this._getZoomTriggerEvent("zoomEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...zoomEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearZoom();
    }, delayTime)), event.on(...zoomParams, delayMap4[delayType]((params2) => {
      var _a2;
      this._zoomEventDispatch(params2, regionOrSeries, callback, null !== (_a2 = null == option ? void 0 : option.allowComponentZoom) && void 0 !== _a2 && _a2);
    }, delayTime));
  }
  initZoomEventOfSeries(s2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && this._bindZoomEventAsRegion(s2.event, s2, callback, option);
  }
  initZoomEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && this._bindZoomEventAsRegion(s2.event, s2, callback, option);
      }) : this._bindZoomEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _scrollEventDispatch(params2, regionOrSeries, callback) {
    let stopBubble = false;
    if (!this._isGestureListener && (!params2.event || this._option.disableTriggerEvent)) return stopBubble;
    const event = this._isGestureListener ? params2 : params2.event;
    this._zoomableTrigger.parserScrollEvent(event);
    const { scrollX, scrollY, canvasX, canvasY } = event;
    return isNil_default(scrollX) && isNil_default(scrollY) ? stopBubble : pointInRect({
      x: canvasX,
      y: canvasY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false) ? (this._clearDragEvent(), this._zoomableTrigger.clearZoom(), callback && (stopBubble = callback({
      scrollX,
      scrollY
    }, event)), this._eventObj.emit("scroll", {
      scrollX,
      scrollY,
      model: this
    }), stopBubble) : stopBubble;
  }
  _bindScrollEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, scrollParams = this._isGestureListener ? [this._getZoomTriggerEvent("scroll")] : [this._getZoomTriggerEvent("scroll"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], scrollEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("scrollEnd")] : [this._getZoomTriggerEvent("scrollEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...scrollEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearScroll();
    }, delayTime)), event.on(...scrollParams, delayMap4[delayType]((params2) => this._scrollEventDispatch(params2, regionOrSeries, callback), delayTime));
  }
  initScrollEventOfSeries(s2, callback, option) {
    getDefaultTriggerEventByMode(this._renderMode) && this._bindScrollEventAsRegion(s2.event, s2, callback, option);
  }
  initScrollEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && this._bindScrollEventAsRegion(s2.event, s2, callback, option);
      }) : this._bindScrollEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _bindDragEventAsRegion(eventObj, regionOrSeries, callback, option) {
    eventObj.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.chart
    }, (params2) => {
      if (!params2.event) return;
      const { event } = params2;
      pointInRect({
        x: event.canvasX,
        y: event.canvasY
      }, this._getRegionOrSeriesLayout(regionOrSeries), false) && this._handleDrag(params2, callback, option);
    }), eventObj.on("click", {
      level: Event_Bubble_Level.chart
    }, () => !this._clickEnable);
  }
  initDragEventOfSeries(s2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && s2.event.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.model,
      filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
    }, (params2) => {
      this._handleDrag(params2, callback, option);
    });
  }
  initDragEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && (s2.event.on(this._getZoomTriggerEvent("start"), {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
        }, (params2) => {
          this._handleDrag(params2, callback);
        }), s2.event.on("click", {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
        }, () => !this._clickEnable));
      }) : this._bindDragEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _clearDragEvent() {
    const move = this._getZoomTriggerEvent("move"), end = this._getZoomTriggerEvent("end");
    this._handleDragMouseMove && (this._eventObj.off(move, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, this._handleDragMouseMove), this._handleDragMouseMove = void 0), this._handleDragMouseUp && (end.forEach((endEventType) => {
      this._eventObj.off(endEventType, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.chart
      }, this._handleDragMouseUp), this._eventObj.allow(endEventType);
    }), this._handleDragMouseUp = void 0);
  }
  isDragEnable(event) {
    if (this._isGestureListener && this._gestureController) {
      const events = this._gestureController.cachedEvents;
      return !events || events.length < 2;
    }
    return true;
  }
  _handleDrag(params2, callback, option) {
    var _a, _b, _c;
    if (this._clearDragEvent(), this._option.disableTriggerEvent) return;
    if (this._clickEnable = false, !this.isDragEnable(params2.event)) return;
    this._zoomableTrigger.clearZoom(), this._zoomableTrigger.clearScroll();
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, realTime = null === (_c = null == option ? void 0 : option.realTime) || void 0 === _c || _c, move = this._getZoomTriggerEvent("move"), end = this._getZoomTriggerEvent("end"), event = params2.event;
    let moveX = event.canvasX, moveY = event.canvasY, upX = event.canvasX, upY = event.canvasY;
    this._handleDragMouseUp = delayMap4[delayType]((params3) => {
      this._clickEnable = true;
      const event2 = params3.event, delta = [event2.canvasX - upX, event2.canvasY - upY];
      upX = event2.canvasX, upY = event2.canvasY, !realTime && callback && callback(delta, params3.event), this._eventObj.emit("panend", {
        delta,
        model: this
      }), this._clearDragEvent();
    }, delayTime), this._handleDragMouseMove = delayMap4[delayType]((params3) => {
      if (!this.isDragEnable(params3.event)) return;
      this._clickEnable = false, end.forEach((endEventType) => {
        this._eventObj.prevent(endEventType, {
          handler: this._handleDragMouseUp,
          level: Event_Bubble_Level.chart
        });
      });
      const event2 = params3.event, delta = [event2.canvasX - moveX, event2.canvasY - moveY];
      moveX = event2.canvasX, moveY = event2.canvasY, realTime && callback && callback(delta, params3.event), this._eventObj.emit("panmove", {
        delta,
        model: this
      });
    }, delayTime), this._eventObj.on(move, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, this._handleDragMouseMove), end.forEach((endEventType) => {
      this._eventObj.on(endEventType, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.chart
      }, this._handleDragMouseUp);
    });
  }
};

// node_modules/@visactor/vchart/esm/component/geo/geo-coordinate.js
function projectionName(key, id) {
  return `${PREFIX}_${id}_${key}`;
}
var GeoCoordinate = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.geoCoordinate, this.name = ComponentTypeEnum.geoCoordinate, this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Mark, this._projectionSpec = {
      name: projectionName(this.type, this.id),
      type: "mercator"
    }, this._actualScale = 1, this._initialScale = 1, this.effect = {
      scaleUpdate: () => {
        this.coordinateHelper();
      }
    }, this._handleChartZoom = (params2, event) => {
      var _a, _b, _c, _d, _e, _f;
      let scale4 = params2.zoomDelta;
      const _lastActualScale = this._actualScale;
      return this._actualScale *= scale4, this._actualScale < (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.min) ? (this._actualScale = null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min, scale4 = (null === (_c = this._spec.zoomLimit) || void 0 === _c ? void 0 : _c.min) / _lastActualScale) : this._actualScale > (null === (_d = this._spec.zoomLimit) || void 0 === _d ? void 0 : _d.max) && (this._actualScale = null === (_e = this._spec.zoomLimit) || void 0 === _e ? void 0 : _e.max, scale4 = (null === (_f = this._spec.zoomLimit) || void 0 === _f ? void 0 : _f.max) / _lastActualScale), this.zoom(scale4, [params2.zoomX, params2.zoomY]), {
        scale: scale4,
        totalScale: this._actualScale
      };
    }, this.pan = (delta = [0, 0]) => {
      var _a, _b, _c;
      const t = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.translate()) && void 0 !== _b ? _b : [0, 0];
      let t_x = t[0], t_y = t[1];
      t_x += delta[0], t_y += delta[1], null === (_c = this._projection) || void 0 === _c || _c.translate([t_x, t_y]);
    };
  }
  get longitudeField() {
    return this._longitudeField;
  }
  get latitudeField() {
    return this._latitudeField;
  }
  get projectionSpec() {
    return this._projectionSpec;
  }
  setProjection(projectionSpec) {
    this._projectionSpec = Object.assign(Object.assign({}, projectionSpec), {
      name: this._projectionSpec.name
    });
  }
  getZoom() {
    return this._actualScale;
  }
  static getSpecInfo(chartSpec) {
    if (isNil_default(chartSpec)) return null;
    const specInfos = [];
    return chartSpec.region.forEach((r, i) => {
      if ("geo" === r.coordinate) {
        const spec = Object.assign(Object.assign({}, r), {
          padding: 0
        });
        specInfos.push({
          spec,
          regionIndex: i,
          type: ComponentTypeEnum.geoCoordinate,
          specInfoPath: ["component", "geoCoordinate", i]
        });
      }
    }), specInfos;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this._spec.roam && this.initZoomable(this.event, this._option.mode), this._projectionSpec = mergeSpec(this._projectionSpec, this._spec.projection), this._projectionSpec.zoom > (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.max) && (this._projectionSpec.zoom = this._spec.zoomLimit.max), this._projectionSpec.zoom < (null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min) && (this._projectionSpec.zoom = this._spec.zoomLimit.min), this._actualScale = null !== (_c = this._projectionSpec.zoom) && void 0 !== _c ? _c : 1, this._initialScale = this._actualScale, this._longitudeField = this._spec.longitudeField, this._latitudeField = this._spec.latitudeField;
  }
  created() {
    super.created(), this._regions = this._option.getRegionsInIndex([this._option.regionIndex]), this.initProjection(), this.coordinateHelper(), this.initEvent(), this._initCenterCache();
  }
  dispatchZoom(zoomDelta, center2) {
    const scaleCenter = center2 || {
      x: this.getLayoutStartPoint().x + this.getLayoutRect().width / 2,
      y: this.getLayoutStartPoint().y + this.getLayoutRect().height / 2
    }, { scale: scale4, totalScale } = this._handleChartZoom({
      zoomDelta,
      zoomX: scaleCenter.x,
      zoomY: scaleCenter.y
    });
    1 !== scale4 && this.event.emit("zoom", {
      scale: scale4,
      scaleCenter,
      totalScale,
      model: this
    });
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this));
    const { roam } = this._spec;
    roam && (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom), this.initDragEventOfRegions(this._regions, roam.blank ? null : () => true, this.pan), this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        s2.event.on("zoom", (e) => (s2.handleZoom(e), true)), s2.event.on("panmove", (e) => (s2.handlePan(e), true));
      });
    }));
  }
  initProjection() {
    var _a;
    this._projection = new Projection2(this._projectionSpec), null !== this._projection.projection || null === (_a = this._option) || void 0 === _a || _a.onError("unsupported projection type!");
  }
  coordinateHelper() {
    const helper = {
      longitudeField: this._longitudeField,
      latitudeField: this._latitudeField,
      dataToPosition: this.dataToPosition.bind(this),
      dataToLongitude: this.dataToLongitude.bind(this),
      dataToLatitude: this.dataToLatitude.bind(this),
      shape: this.shape.bind(this),
      getCoordinateId: () => this.id
    };
    this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        s2.type === SeriesTypeEnum.map || s2.type === SeriesTypeEnum.pictogram ? s2.setCoordinateHelper(helper) : (s2.setXAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          getFields: () => [this._longitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })), s2.setYAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          getFields: () => [this._latitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })));
      });
    });
  }
  onLayoutEnd(ctx) {
    this.setLayoutRect(this._regions[0].getLayoutRect()), this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint());
    const { width, height } = this.getLayoutRect(), { translate: translate2, scale: scale4, center: center2 } = this.evaluateProjection([0, 0], [width, height]);
    translate2 && this._projection.translate(translate2), scale4 && this._projection.scale(scale4), center2 && this._projection.center(center2), eachSeries(this._regions, (s2) => {
      var _a, _b;
      if (s2.type === SeriesTypeEnum.map || s2.type === SeriesTypeEnum.pictogram) {
        null === (_a = s2.areaPath) || void 0 === _a || _a.clear();
        const pathGroup = null === (_b = s2.getRootMark().getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem();
        pathGroup && pathGroup.attribute.postMatrix && pathGroup.setAttributes({
          postMatrix: new Matrix()
        });
      }
    }), this._actualScale = this._initialScale, super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  collectFeatures() {
    const features = [];
    return this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        var _a, _b;
        s2.type !== SeriesTypeEnum.map && s2.type !== SeriesTypeEnum.pictogram || features.push(...null !== (_b = null === (_a = s2.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []);
      });
    }), features;
  }
  dataToPosition(values = []) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([values[0], values[1]]);
    return {
      x: null == point6 ? void 0 : point6[0],
      y: null == point6 ? void 0 : point6[1]
    };
  }
  dataToLatitude(lat) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([0, lat]);
    return null == point6 ? void 0 : point6[1];
  }
  dataToLongitude(lon) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([lon, 0]);
    return null == point6 ? void 0 : point6[0];
  }
  zoom(p, anchor = [0, 0]) {
    var _a, _b, _c, _d, _e, _f;
    let s2 = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.scale()) && void 0 !== _b ? _b : 0;
    const t = null !== (_d = null === (_c = this._projection) || void 0 === _c ? void 0 : _c.translate()) && void 0 !== _d ? _d : [0, 0];
    let t_x = t[0], t_y = t[1];
    s2 *= p, t_x -= (anchor[0] - t_x) * (p - 1), t_y -= (anchor[1] - t_y) * (p - 1), null === (_e = this._projection) || void 0 === _e || _e.scale(s2), null === (_f = this._projection) || void 0 === _f || _f.translate([t_x, t_y]);
  }
  shape(datum) {
    return this._projection.shape(datum);
  }
  invert(point6) {
    return this._projection.invert(point6);
  }
  evaluateProjection(start, size) {
    var _a;
    const evaluated = this._projection.evaluate(start, size, this.collectFeatures());
    let translate2 = evaluated.translate();
    const scale4 = evaluated.scale() * this._initialScale, center2 = null !== (_a = this._projectionSpec.center) && void 0 !== _a ? _a : evaluated.invert([size[0] / 2, size[1] / 2]);
    return center2 && (translate2 = [size[0] / 2, size[1] / 2]), {
      translate: translate2,
      scale: scale4,
      center: center2
    };
  }
  _initCenterCache() {
    this._centerCache || (this._centerCache = /* @__PURE__ */ new Map()), this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        var _a, _b;
        if ("map" === s2.type) {
          (null !== (_b = null === (_a = s2.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []).forEach((feature = {}) => {
            const key = feature[s2.getDimensionField()[0]] || feature[DEFAULT_MAP_LOOK_UP_KEY], center2 = s2.getDatumCenter(feature);
            key && isValid_default(center2) && this._centerCache.set(key, {
              x: center2[0],
              y: center2[1]
            });
          });
        }
      });
    });
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || (result2.reMake = ["roam", "longitudeField", "latitudeField", "projection", "zoomLimit"].some((k2) => !isEqual(null == prevSpec ? void 0 : prevSpec[k2], spec[k2]))), result2;
  }
  release() {
    super.release(), this._centerCache && this._centerCache.clear(), this._centerCache = null;
  }
};
GeoCoordinate.type = ComponentTypeEnum.geoCoordinate, mixin(GeoCoordinate, Zoomable);
var registerGeoCoordinate = () => {
  Factory2.registerComponent(GeoCoordinate.type, GeoCoordinate);
};

// node_modules/@visactor/vchart/esm/series/map/map-transformer.js
var MapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "area", void 0, void 0, false);
  }
};

// node_modules/@visactor/vchart/esm/series/map/map.js
var MapSeries = class _MapSeries extends GeoSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.map, this.transformerConstructor = MapSeriesSpecTransformer, this._areaCache = /* @__PURE__ */ new Map();
  }
  getNameMap() {
    return this._nameMap;
  }
  get areaPath() {
    return this._areaCache;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.map = this._spec.map, this._nameMap = this._spec.nameMap, this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty), this._spec.centroidProperty && (this._centroidProperty = this._spec.centroidProperty), this.map || null === (_a = this._option) || void 0 === _a || _a.onError(`map type '${this.map}' is not specified !`), geoSourceMap.get(this.map) || null === (_b = this._option) || void 0 === _b || _b.onError(`'${this.map}' data is not registered !`);
  }
  initData() {
    var _a, _b;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView), registerDataSetInstanceTransform(this._dataSet, "map", map3), registerDataSetInstanceTransform(this._dataSet, "lookup", lookup);
    const features = geoSourceMap.get(this.map);
    features || null === (_a = this._option) || void 0 === _a || _a.onError("no valid map data found!");
    const mapData = new DataView(this._dataSet, {
      name: `map_${this.id}_data`
    });
    mapData.parse([features], {
      type: "dataview"
    }).transform({
      type: "copyDataView",
      options: {
        deep: true
      },
      level: TransformLevel.copyDataView
    }).transform({
      type: "map",
      options: {
        nameMap: this._nameMap,
        nameProperty: this._nameProperty
      }
    }).transform({
      type: "lookup",
      options: {
        from: () => {
          var _a2;
          return null === (_a2 = this._data) || void 0 === _a2 ? void 0 : _a2.getLatestData();
        },
        key: DEFAULT_MAP_LOOK_UP_KEY,
        fields: this._nameField,
        set: (feature, datum) => {
          datum && Object.keys(datum).forEach((key) => {
            key in feature || (feature[key] = datum[key]);
          });
        }
      }
    }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", mapData.reRunAllTransform), this._mapViewData = new SeriesData(this._option, mapData);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
  }
  initMark() {
    this._pathMark = this._createMark(_MapSeries.mark.area, {
      groupKey: this.getDimensionField()[0],
      isSeriesMark: true,
      skipBeforeLayouted: true,
      dataView: this._mapViewData.getDataView(),
      dataProductId: this._mapViewData.getProductId()
    }, {
      morph: shouldMarkDoMorph(this._spec, _MapSeries.mark.area.name),
      morphElementKey: this.getDimensionField()[0]
    });
  }
  initMarkStyle() {
    const pathMark = this._pathMark;
    pathMark && (this.setMarkStyle(pathMark, {
      fill: (datum) => {
        var _a, _b, _c, _d;
        return isValid_default(datum[null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD]) ? (null !== (_b = this._option.globalScale.getScale("color")) && void 0 !== _b ? _b : this._getDefaultColorScale()).scale(datum[null !== (_c = this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD]) : null === (_d = this._spec) || void 0 === _d ? void 0 : _d.defaultFillColor;
      },
      path: this.getPath.bind(this)
    }, "normal", AttributeLevel.Series), pathMark.setPostProcess("fill", (result2) => isValid_default(result2) ? result2 : this._spec.defaultFillColor), this.setMarkStyle(pathMark, {
      smoothScale: true
    }, "normal", AttributeLevel.Built_In));
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => this.getDatumName(datum),
      x: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
      },
      y: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
      }
    }));
  }
  initAnimation() {
    var _a;
    this._pathMark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig("area", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new MapSeriesTooltipHelper(this), this._pathMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pathMark);
  }
  getPath(datum) {
    var _a;
    const area2 = this._areaCache.get(datum[DEFAULT_DATA_INDEX]);
    if (area2) return area2.shape;
    const shape = null === (_a = this._coordinateHelper) || void 0 === _a ? void 0 : _a.shape(datum);
    return this._areaCache.set(datum[DEFAULT_DATA_INDEX], {
      shape
    }), shape;
  }
  onEvaluateEnd() {
    this._mapViewData.updateData();
  }
  getDimensionField() {
    return [this.nameField];
  }
  getMeasureField() {
    return [this.valueField];
  }
  release() {
    super.release(), this._areaCache.clear(), this._nameMap = {}, this._mapViewData = null;
  }
  handleZoom(e) {
    var _a, _b, _c;
    const { scale: scale4, scaleCenter } = e;
    if (1 === scale4) return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.scale(scale4, scale4, scaleCenter));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  handlePan(e) {
    var _a, _b, _c;
    const { delta } = e;
    if (0 === delta[0] && 0 === delta[1]) return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.translate(delta[0], delta[1]));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  getDatumCenter(datum) {
    var _a, _b, _c, _d;
    return this._centroidProperty && (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._centroidProperty]) ? null === (_b = datum.properties) || void 0 === _b ? void 0 : _b[this._centroidProperty] : isValidNumber_default(datum.centroidX * datum.centroidY) ? [datum.centroidX, datum.centroidY] : (null === (_c = datum.properties) || void 0 === _c ? void 0 : _c.center) ? datum.properties.center : (null === (_d = datum.properties) || void 0 === _d ? void 0 : _d.centroid) ? datum.properties.centroid : [Number.NaN, Number.NaN];
  }
  getDatumName(datum) {
    var _a;
    if (datum[this.nameField]) return datum[this.nameField];
    const name = null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._nameProperty];
    if (name) {
      if (this._spec.nameMap && this._spec.nameMap[name]) return this._spec.nameMap[name];
      if (this._spec.showDefaultName || !this._spec.nameMap) return name;
    }
    return "";
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  viewDataUpdate(d) {
    var _a, _b, _c;
    super.viewDataUpdate(d), null === (_b = null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._mapViewData) || void 0 === _c || _c.updateData();
  }
  _getDataIdKey() {
    return DEFAULT_DATA_INDEX;
  }
  getActiveMarks() {
    return [this._pathMark];
  }
};
MapSeries.type = SeriesTypeEnum.map, MapSeries.mark = mapSeriesMark, MapSeries.transformerConstructor = MapSeriesSpecTransformer;
var registerMapSeries = () => {
  registerProjection(), registerGeoCoordinate(), registerPathMark(), Factory2.registerSeries(MapSeries.type, MapSeries), Factory2.registerImplement("registerMap", registerMapSource), Factory2.registerImplement("unregisterMap", unregisterMapSource), registerFadeInOutAnimation();
};

// node_modules/@visactor/vchart/esm/constant/waterfall.js
var WaterfallDefaultSeriesField = `${PREFIX}_waterfall_default_seriesField`;

// node_modules/@visactor/vchart/esm/data/transforms/waterfall.js
var waterfall2 = (lastData, op) => {
  if (!lastData || 0 === lastData.length) return lastData;
  const { indexField, total: totalSpec, groupData: groupData2 } = op, totalData = [], { dimensionValues, dimensionData } = groupData2().latestData, indexValues = Array.from(dimensionValues[indexField]);
  let temp2 = {
    start: 0,
    end: 0,
    positive: 0,
    negative: 0,
    lastIndex: null
  };
  return indexValues.forEach((key, index) => {
    const total = {
      start: temp2.end,
      end: temp2.end,
      lastIndex: temp2.lastIndex,
      lastEnd: temp2.end,
      index: key,
      isTotal: false,
      positive: temp2.end,
      negative: temp2.end
    }, indexData = true === op.stackInverse ? dimensionData[key].reverse() : dimensionData[key];
    if (null == indexData || indexData.forEach((d, i) => {
      i === indexData.length - 1 ? d[STACK_FIELD_TOTAL_TOP] = true : delete d[STACK_FIELD_TOTAL_TOP];
    }), indexData.length > 1) {
      const isTotalCheck = (d) => {
        if (totalSpec && "end" !== totalSpec.type) {
          if ("field" === totalSpec.type || "custom" === totalSpec.type) {
            return !!d[totalSpec.tagField];
          }
        } else if (index === indexValues.length - 1) return true;
        return false;
      };
      if (indexData.some((d) => isTotalCheck(d))) return temp2 = computeTotalWithMultipleData(indexData, key, total, totalData, temp2, indexValues, index, op, isTotalCheck), void totalData.push(total);
    }
    temp2 = computeNormalData(indexData, key, total, totalData, temp2, indexValues, index, op), totalData.push(total);
  }), totalData;
};
function computeTotalWithMultipleData(indexData, key, total, totalData, temp2, indexValues, index, op, isTotalCheck) {
  total.isTotal = true;
  const { valueField, startAs, endAs, total: totalSpec } = op, _normalTemp = [], _totalTemp = [];
  if (indexData.forEach((d) => {
    isTotalCheck(d) ? _totalTemp.push(d) : _normalTemp.push(d);
  }), _totalTemp.length === indexData.length) {
    const result2 = computeNormalData([indexData[0]], key, total, totalData, temp2, indexValues, index, op);
    return _totalTemp.forEach((d) => {
      d[startAs] = indexData[0][startAs], d[endAs] = indexData[0][endAs], d[valueField] = indexData[0][valueField];
    }), result2;
  }
  const totalConfigData = _totalTemp[0];
  let { start, end } = getTotalStartEnd(totalConfigData, total, totalData, temp2, totalSpec);
  total.start = start, total.end = end;
  let positive = start, navigate = start, valueTemp = end - start;
  return _normalTemp.forEach((d) => {
    const value = +d[valueField];
    value >= 0 ? (d[startAs] = +positive, positive = precisionAdd(positive, value)) : (d[startAs] = +navigate, navigate = precisionAdd(navigate, value)), d[endAs] = precisionAdd(d[startAs], value), start = precisionAdd(start, value), valueTemp = precisionSub(valueTemp, value);
  }), _totalTemp.forEach((d) => {
    d[startAs] = +start, d[endAs] = precisionAdd(d[startAs], valueTemp), d[valueField] = valueTemp;
  }), Object.assign(Object.assign({}, total), {
    lastIndex: key
  });
}
function computeNormalData(indexData, key, total, totalData, temp2, indexValues, index, op) {
  const { valueField, startAs, endAs, total: totalSpec, seriesField, seriesFieldName } = op;
  return indexData.forEach((d) => {
    let isTotalTag = false;
    if (totalSpec && "end" !== totalSpec.type) {
      if ("field" === totalSpec.type || "custom" === totalSpec.type) {
        if (d[totalSpec.tagField]) {
          isTotalTag = true;
          const { start, end } = getTotalStartEnd(d, total, totalData, temp2, totalSpec);
          d[startAs] = start, d[endAs] = end, d[valueField] = end - start, total.start = start, total.end = end;
        }
      }
    } else index === indexValues.length - 1 && (total.start = 0, d[startAs] = total.start, d[endAs] = total.end, isTotalTag = true);
    if (!isTotalTag) {
      const value = +d[valueField];
      value >= 0 ? (d[startAs] = +total.positive, total.positive = precisionAdd(total.positive, value)) : (d[startAs] = +total.negative, total.negative = precisionAdd(total.negative, value)), d[endAs] = precisionAdd(d[startAs], value), total.end = precisionAdd(total.end, value);
    }
    total.isTotal = isTotalTag, (isNil_default(seriesField) || seriesField === WaterfallDefaultSeriesField) && (d[WaterfallDefaultSeriesField] = isTotalTag ? seriesFieldName.total : +d[valueField] >= 0 ? seriesFieldName.increase : seriesFieldName.decrease);
  }), Object.assign(Object.assign({}, total), {
    lastIndex: key
  });
}
function getTotalStartEnd(d, total, totalData, temp2, totalSpec) {
  return totalSpec && "end" !== totalSpec.type ? "field" === totalSpec.type || "custom" === totalSpec.type ? "custom" === totalSpec.type ? getTotalInCustomType(d, temp2, totalSpec) : totalSpec.collectCountField && !isNil_default(d[totalSpec.collectCountField]) ? getTotalInCollectField(d, totalData, total, totalSpec) : getTotalInField(d, total, totalSpec) : {
    start: 0,
    end: 0
  } : getTotalInEndType(total);
}
function getTotalInEndType(total) {
  return {
    start: 0,
    end: total.end
  };
}
function getTotalInCustomType(d, temp2, totalSpec) {
  return totalSpec.product(d, temp2);
}
function getTotalInCollectField(d, totalData, total, totalSpec) {
  let start = 0, end = total.end;
  const startIndex = totalData.length - +d[totalSpec.collectCountField], endIndex = totalData.length - 1;
  return startIndex < 0 ? warn("total.collectCountField error") : start = totalData[startIndex].start, endIndex < 0 ? warn("total.collectCountField error") : end = totalData[endIndex].end, {
    start,
    end
  };
}
function getTotalInField(d, total, totalSpec) {
  let start = 0, end = total.end;
  return totalSpec.startField && !isNil_default(d[totalSpec.startField]) && (start = +d[totalSpec.startField]), totalSpec.valueField && !isNil_default(d[totalSpec.valueField]) && (end = precisionAdd(start, +d[totalSpec.valueField])), {
    start,
    end
  };
}
var waterfallFillTotal = (data, op) => {
  if (!data) return data;
  const { indexField, valueField, total, seriesField } = op, totalData = {
    [indexField]: (null == total ? void 0 : total.text) || "total",
    [valueField]: data.reduce((pre, cur) => precisionAdd(pre, +cur[valueField]), 0)
  };
  return seriesField && (totalData[seriesField] = "total"), data.push(totalData), data;
};

// node_modules/@visactor/vchart/esm/series/waterfall/animation.js
var Appear_FadeIn3 = {
  type: "fadeIn"
};
var Appear_ScaleIn2 = {
  type: "growCenterIn"
};
function waterfallPresetAnimation(params2, preset) {
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn3;
    case "scaleIn":
      return Appear_ScaleIn2;
    default:
      return barGrowIn(params2, false);
  }
}
var registerWaterfallAnimation = () => {
  Factory2.registerAnimation("waterfall", (params2, preset) => ({
    appear: waterfallPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2, false)
  }));
};

// node_modules/@visactor/vchart/esm/mark/rule.js
var RuleMark = class _RuleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RuleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x1: 0,
      y1: 0
    });
  }
};
RuleMark.type = "rule";
var registerRuleMark = () => {
  Factory2.registerMark(RuleMark.type, RuleMark), registerRuleGraphic();
};

// node_modules/@visactor/vchart/esm/series/waterfall/constant.js
var waterfallSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  leaderLine: {
    name: "leaderLine",
    type: "rule"
  },
  stackLabel: {
    name: "stackLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/data/transforms/dimension-data.js
var dimensionTree = (data, op) => {
  if (!op.fields) return data;
  const dimensionValues = {};
  return {
    dimensionValues,
    dimensionData: groups(data.map((d) => d.latestData).flat(), op.fields, dimensionValues)
  };
};
function groups(data, fields2, dimensionValues) {
  if (0 === fields2.length) return data;
  const first = fields2[0], _rest = fields2.slice(1);
  dimensionValues[first] = /* @__PURE__ */ new Set();
  const grouped = groupBy(data, first, dimensionValues[first]);
  return _rest.length ? mapValues(grouped, (value, key) => groups(value, _rest, dimensionValues)) : grouped;
}
function groupBy(data, field5, set2) {
  const groups2 = {};
  return data.forEach((d) => {
    const key = d[field5];
    groups2[key] || (groups2[key] = [], set2.add(key)), groups2[key].push(d);
  }), groups2;
}
function mapValues(target, fn) {
  return Object.keys(target).reduce((result2, key) => (result2[key] = fn(target[key], key), result2), {});
}

// node_modules/@visactor/vchart/esm/series/base/group.js
var Group2 = class {
  get fields() {
    return this._fields;
  }
  get groupData() {
    return this._groupData;
  }
  constructor(fields2) {
    this._fields = [], this._fields = fields2;
  }
  initData(viewData, dataSet) {
    const dataName = viewData.name, groupData2 = new DataView(dataSet instanceof DataSet ? dataSet : viewData.dataSet);
    groupData2.name = dataName, groupData2.parse([viewData], {
      type: "dataview"
    }), registerDataSetInstanceTransform(dataSet, "dimensionTree", dimensionTree), groupData2.transform({
      type: "dimensionTree",
      options: {
        fields: this._fields
      }
    }, false), groupData2.target.addListener("change", this.groupDataUpdate.bind(this)), this._groupData = groupData2;
  }
  groupDataUpdate() {
  }
  getGroupValueInField(field5) {
    var _a, _b, _c;
    const values = null === (_c = null === (_b = null === (_a = this.groupData) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.dimensionValues) || void 0 === _c ? void 0 : _c[field5];
    return values ? Array.from(values) : [];
  }
};

// node_modules/@visactor/vchart/esm/series/waterfall/waterfall-transformer.js
var WaterfallSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar"), this._addMarkLabelSpec(spec, "bar", "stackLabel", "initStackLabelMarkStyle");
  }
};

// node_modules/@visactor/vchart/esm/component/label/util.js
var labelRuleMap = {
  rect: barLabel,
  symbol: symbolLabel2,
  arc: pieLabel,
  point: pointLabel2,
  "line-data": lineDataLabel2,
  stackLabel,
  line: LineLabel2,
  area: LineLabel2,
  rect3d: barLabel,
  arc3d: pieLabel,
  treemap: treemapLabel,
  venn: vennLabel
};
function defaultLabelConfig(rule, labelInfo) {
  var _a;
  const { labelSpec } = labelInfo;
  labelSpec.overlap && !isObject_default(labelSpec.overlap) && (labelSpec.overlap = {});
  const processor = null !== (_a = labelRuleMap[rule]) && void 0 !== _a ? _a : labelRuleMap.point;
  return labelInfo.series.type === SeriesTypeEnum.sankey ? sankeyLabel(labelInfo) : processor(labelInfo);
}
function textAttribute(labelInfo, datum, formatMethod, formatter) {
  var _a;
  const { labelMark, series: series2 } = labelInfo, textAttribute2 = {
    text: datum[series2.getMeasureField()[0]],
    data: datum,
    textType: null !== (_a = labelInfo.labelSpec.textType) && void 0 !== _a ? _a : "text"
  }, attributes = Object.keys(labelMark.stateStyle.normal);
  for (const key of attributes) {
    const attr = labelMark.getAttribute(key, datum);
    textAttribute2[key] = attr;
  }
  if (series2.type !== SeriesTypeEnum.sankey) {
    const { formatFunc, args } = getFormatFunction(formatMethod, formatter, textAttribute2.text, datum);
    formatFunc && (textAttribute2._originText = textAttribute2.text, textAttribute2.text = formatFunc(...args, {
      series: series2
    }));
  }
  return textAttribute2;
}
function uniformLabelPosition(position) {
  return isFunction_default(position) ? (datum) => position(datum.data) : position;
}
function symbolLabel2(labelInfo) {
  var _a, _b, _c;
  const { series: series2, labelSpec } = labelInfo, defaultPosition = "horizontal" === series2.direction ? "right" : "top", position = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : defaultPosition;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_c = null === (_b = labelSpec.overlap) || void 0 === _b ? void 0 : _b.strategy) && void 0 !== _c ? _c : symbolLabelOverlapStrategy(),
    avoidBaseMark: "center" !== position
  }, {
    position,
    overlap: overlap2
  };
}
function lineDataLabel2(labelInfo) {
  const result2 = symbolLabel2(labelInfo);
  return isBoolean_default(result2.overlap) || (result2.overlap.avoidBaseMark = false), result2;
}
function symbolLabelOverlapStrategy() {
  return [{
    type: "position",
    position: ["top", "bottom", "right", "left", "top-right", "top-left", "bottom-left", "bottom-right"]
  }];
}
function barLabel(labelInfo) {
  var _a, _b, _c, _d, _e, _f;
  const { series: series2, labelSpec = {} } = labelInfo, originPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", direction = null !== (_b = series2.direction) && void 0 !== _b ? _b : "vertical", isInverse = "horizontal" === series2.direction ? null === (_c = series2.getXAxisHelper()) || void 0 === _c ? void 0 : _c.isInverse() : null === (_d = series2.getYAxisHelper()) || void 0 === _d ? void 0 : _d.isInverse();
  let overlap2, position = originPosition;
  position = (datum) => {
    var _a2;
    const { data } = datum, labelPosition = null !== (_a2 = "function" == typeof labelSpec.position ? labelSpec.position(data) : labelSpec.position) && void 0 !== _a2 ? _a2 : "outside";
    if ("outside" === labelPosition) {
      const dataField = series2.getMeasureField()[0], positionMap = {
        vertical: ["top", "bottom"],
        horizontal: ["right", "left"]
      }, index = (null == data ? void 0 : data[dataField]) >= 0 && isInverse || (null == data ? void 0 : data[dataField]) < 0 && !isInverse ? 1 : 0;
      return positionMap[direction][index];
    }
    return labelPosition;
  }, overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_f = null === (_e = labelSpec.overlap) || void 0 === _e ? void 0 : _e.strategy) && void 0 !== _f ? _f : barLabelOverlapStrategy(series2)
  };
  let smartInvert = false;
  return isString_default(originPosition) && originPosition.includes("inside") && (smartInvert = true), {
    position,
    overlap: overlap2,
    smartInvert
  };
}
function barLabelOverlapStrategy(series2) {
  return [{
    type: "position",
    position: (data) => {
      var _a, _b;
      const { data: datum } = data, dataField = series2.getMeasureField()[0];
      return ("horizontal" === series2.direction ? null === (_a = series2.getXAxisHelper()) || void 0 === _a ? void 0 : _a.isInverse() : null === (_b = series2.getYAxisHelper()) || void 0 === _b ? void 0 : _b.isInverse()) ? (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"] : "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"];
    }
  }];
}
function pointLabel2(labelInfo) {
  const { labelSpec } = labelInfo;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    avoidBaseMark: false
  }, {
    position: "center",
    overlap: overlap2
  };
}
function pieLabel(labelInfo) {
  var _a;
  const { labelSpec } = labelInfo, labelPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", position = labelPosition;
  let smartInvert;
  return smartInvert = labelSpec.smartInvert ? labelSpec.smartInvert : isString_default(labelPosition) && labelPosition.includes("inside"), {
    position,
    smartInvert
  };
}
function stackLabelX(datum2, series2, pos, offset) {
  return "horizontal" === series2.direction ? "middle" === pos ? 0.5 * (series2.totalPositionX(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "end" : "start") + offset : "min" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "start" : "end") - offset : series2.totalPositionX(datum2, "end") + (datum2.end >= datum2.start ? offset : -offset) : series2.totalPositionX(datum2, "index", 0.5);
}
function stackLabelY(datum2, series2, pos, offset) {
  return "horizontal" === series2.direction ? series2.totalPositionY(datum2, "index", 0.5) : "middle" === pos ? 0.5 * (series2.totalPositionY(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "end" : "start") - offset : "min" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "start" : "end") + offset : series2.totalPositionY(datum2, "end") + (datum2.end >= datum2.start ? -offset : offset);
}
function stackLabel(labelInfo, datumTransform, attributeTransform) {
  const series2 = labelInfo.series, labelSpec = labelInfo.labelSpec || {}, totalData = series2.getTotalData();
  return {
    customLayoutFunc: (labels) => labels.map((label) => {
      const pos = labelSpec.position || "withChange", offset = labelSpec.offset || 0, datum = datumTransform ? datumTransform(label.data) : label.data, attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);
      return attribute.x = stackLabelX(datum, series2, pos, offset), attribute.y = stackLabelY(datum, series2, pos, offset), "horizontal" === series2.direction ? attribute.textAlign = "middle" === pos ? "center" : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "left" : "right" : attribute.textBaseline = "middle" === pos ? pos : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "bottom" : "top", null == attributeTransform || attributeTransform(label, datum, attribute), createText(Object.assign(Object.assign({}, attribute), {
        id: label.id
      }));
    }),
    dataFilter: (labels) => {
      const result2 = [];
      return totalData.forEach((total) => {
        const label = labels.find((labelItem) => {
          var _a;
          return total.index === (null === (_a = labelItem.data) || void 0 === _a ? void 0 : _a[series2.getDimensionField()[0]]);
        });
        label && (label.data = total, result2.push(label));
      }), result2;
    },
    overlap: {
      strategy: []
    }
  };
}
function treemapLabel(labelInfo) {
  return {
    customLayoutFunc: (labels, text2) => text2,
    overlap: false
  };
}
function vennLabel(labelInfo) {
  return {
    customLayoutFunc: (labels, text2) => text2,
    smartInvert: true
  };
}
function LineLabel2(labelInfo) {
  var _a, _b, _c, _d;
  const { labelSpec, series: series2 } = labelInfo, seriesData = null === (_c = null === (_b = null === (_a = series2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(series2).latestData) || void 0 === _b ? void 0 : _b[series2.getSeriesField()]) || void 0 === _c ? void 0 : _c.values, data = seriesData ? seriesData.map((d, index) => ({
    [series2.getSeriesField()]: d,
    index
  })) : [{
    index: 0,
    [DEFAULT_DATA_SERIES_FIELD]: series2.getSeriesKeys()[0]
  }];
  return {
    position: null !== (_d = labelSpec.position) && void 0 !== _d ? _d : "end",
    data
  };
}
function sankeyLabel(labelInfo) {
  var _a, _b, _c;
  const { series: series2, labelSpec = {} } = labelInfo, originPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", direction = series2.direction;
  let overlap2, position = originPosition;
  return isString_default(originPosition) && ("vertical" === direction ? position = "inside-start" === originPosition ? (datum) => "inside-left" : "inside-middle" === originPosition ? (datum) => "center" : "inside-end" === originPosition ? (datum) => "inside-right" : (datum) => "bottom" : "inside-start" === originPosition ? position = (datum) => "inside-left" : "inside-middle" === originPosition ? position = (datum) => "center" : "inside-end" === originPosition ? position = (datum) => "inside-right" : "outside" === originPosition && (position = (datum) => "right")), overlap2 = false !== labelSpec.overlap && ((!isString_default(originPosition) || !originPosition.includes("inside")) && {
    strategy: null !== (_c = null === (_b = labelSpec.overlap) || void 0 === _b ? void 0 : _b.strategy) && void 0 !== _c ? _c : sankeyLabelOverlapStrategy(series2)
  }), {
    position,
    overlap: overlap2,
    smartInvert: false,
    offset: 0,
    syncState: true
  };
}
function sankeyLabelOverlapStrategy(series2) {
  return [{
    type: "position",
    position: (data) => "horizontal" === series2.direction ? ["right", "left"] : ["bottom", "top"]
  }];
}

// node_modules/@visactor/vchart/esm/series/waterfall/waterfall.js
var WaterfallSeries = class _WaterfallSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.waterfall, this.transformerConstructor = WaterfallSeriesSpecTransformer, this._leaderLineMark = null, this._stackLabelMark = null, this._labelMark = null;
  }
  getTotalData() {
    var _a;
    return null === (_a = this._totalData) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = new Group2(groupFields), this._data && this._groups.initData(this._data.getDataView(), this._dataSet));
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setValueFieldToStack(), this._fieldX = [this._fieldX[0]], this._fieldY = [this._fieldY[0]], isNil_default(this._seriesField) && (this._seriesField = WaterfallDefaultSeriesField);
  }
  getSeriesKeys() {
    return this._seriesField === WaterfallDefaultSeriesField ? [this._theme.seriesFieldName.increase, this._theme.seriesFieldName.decrease, this._theme.seriesFieldName.total] : super.getSeriesKeys();
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "waterfallFillTotal", waterfallFillTotal), registerDataSetInstanceTransform(this._dataSet, "waterfall", waterfall2), (isNil_default(this._spec.total) || "end" === this._spec.total.type) && (null === (_a = this._rawData) || void 0 === _a || _a.transform({
      type: "waterfallFillTotal",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        total: this._spec.total,
        stackInverse: this.getRegion().getStackInverse()
      }
    }, false));
    const totalData = dataViewFromDataView(this.getViewData(), this._dataSet, {
      name: `${PREFIX}_series_${this.id}_totalData`
    });
    this.getViewData().target.removeListener("change", totalData.reRunAllTransform), this._totalData = new SeriesData(this._option, totalData), totalData.transform({
      type: "waterfall",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        startAs: STACK_FIELD_START,
        endAs: STACK_FIELD_END,
        total: this._spec.total,
        groupData: () => this.getGroups().groupData,
        stackInverse: this.getRegion().getStackInverse()
      }
    }, false);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._totalData) || void 0 === _a || _a.compile();
  }
  initAnimation() {
    var _a, _b, _c, _e;
    const waterfallAnimationParams = {
      yField: "horizontal" === this.direction ? this._fieldY[0] : this.getStackValueField(),
      xField: "horizontal" === this.direction ? this.getStackValueField() : this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("waterfall")) || void 0 === _c ? void 0 : _c(waterfallAnimationParams, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._leaderLineMark && this._leaderLineMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("leaderLine", this._spec, this._markAttributeContext)));
  }
  viewDataUpdate(d) {
    this._totalData.getDataView().reRunAllTransform(), this._totalData.updateData(), super.viewDataUpdate(d);
  }
  addViewDataFilter(_option) {
  }
  reFilterViewData() {
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._totalData.updateData();
  }
  initMark() {
    var _a, _b;
    super.initMark();
    const leaderLine = this._createMark(_WaterfallSeries.mark.leaderLine, {
      key: "index",
      stateSort: null === (_a = this._spec.leaderLine) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.leaderLine) || void 0 === _b ? void 0 : _b.customShape
    });
    leaderLine && (this._leaderLineMark = leaderLine, leaderLine.setDataView(this._totalData.getDataView(), this._totalData.getProductId()));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    if (labelMark) return !this._labelMark && (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.visible) ? (super.initLabelMarkStyle(labelMark), void (this._labelMark = labelMark)) : void 0;
  }
  initStackLabelMarkStyle(labelMark) {
    labelMark && (this._stackLabelMark = labelMark, labelMark.skipEncode = true, labelMark.setRule("stackLabel"), labelMark.setDataView(this._totalData.getDataView(), this._totalData.getProductId()), this.setMarkStyle(labelMark, {
      text: (datum) => {
        var _a;
        return "absolute" === (null === (_a = this._spec.stackLabel) || void 0 === _a ? void 0 : _a.valueType) ? datum.end : precisionSub(datum.end, datum.start);
      }
    }));
  }
  initTotalLabelMarkStyle(labelMark) {
    this.setMarkStyle(labelMark, {
      text: (datum) => {
        var _a;
        return "end" in datum ? "absolute" === (null === (_a = this._spec.totalLabel) || void 0 === _a ? void 0 : _a.valueType) ? datum.end : precisionSub(datum.end, datum.start) : "horizontal" === this.direction ? datum[this._fieldX[0]] : datum[this._fieldY[0]];
      }
    });
  }
  getTotalLabelComponentStyle(info) {
    return stackLabel(Object.assign(Object.assign({}, info), {
      series: this,
      labelSpec: this._spec.totalLabel
    }), (d) => {
      const index = "vertical" === this.direction ? d[this._fieldX[0]] : d[this._fieldY[0]];
      return this._totalData.getLatestData().find((_d) => _d.index === index);
    });
  }
  totalPositionX(datum, field5, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._xAxisHelper;
    return "horizontal" === this._direction ? valueInScaleRange(dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    })) : dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("width", datum) * (0.5 - pos);
  }
  totalPositionY(datum, field5, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return "horizontal" === this._direction ? dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("height", datum) * (0.5 - pos) : valueInScaleRange(dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }));
  }
  initMarkStyle() {
    super.initMarkStyle(), this._leaderLineMark && ("horizontal" === this._direction ? this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => this.isVisibleLeaderLine(datum),
      x: (datum) => this.totalPositionX(datum, "lastEnd", 0),
      x1: (datum) => this.totalPositionX(datum, datum.isTotal ? "end" : "start", 0),
      y: (datum) => datum.lastIndex ? this.totalPositionY(datum, "lastIndex", 1) : 0,
      y1: (datum) => this.totalPositionY(datum, "index", 0)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => this.isVisibleLeaderLine(datum),
      x: (datum) => datum.lastIndex ? this.totalPositionX(datum, "lastIndex", 1) : 0,
      x1: (datum) => this.totalPositionX(datum, "index", 0),
      y: (datum) => this.totalPositionY(datum, "lastEnd", 0),
      y1: (datum) => this.totalPositionY(datum, datum.isTotal ? "end" : "start", 0)
    }, "normal", AttributeLevel.Series));
  }
  isVisibleLeaderLine(datum) {
    return !isNil_default(datum.lastIndex) && isValueInScaleDomain([datum.lastEnd, datum[datum.isTotal ? "end" : "start"]], "horizontal" === this.direction ? this._xAxisHelper.getScale(0) : this._yAxisHelper.getScale(0));
  }
};
WaterfallSeries.type = SeriesTypeEnum.waterfall, WaterfallSeries.mark = waterfallSeriesMark, WaterfallSeries.transformerConstructor = WaterfallSeriesSpecTransformer;
var registerWaterfallSeries = () => {
  registerRuleMark(), registerRectMark(), registerWaterfallAnimation(), registerFadeInOutAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(WaterfallSeries.type, WaterfallSeries);
};

// node_modules/@visactor/vchart/esm/constant/box-plot.js
var BOX_PLOT_OUTLIER_VALUE_FIELD = `${PREFIX}_BOX_PLOT_OUTLIER_VALUE`;
var BOX_PLOT_TOOLTIP_KEYS;
!function(BOX_PLOT_TOOLTIP_KEYS2) {
  BOX_PLOT_TOOLTIP_KEYS2.OUTLIER = "outlier", BOX_PLOT_TOOLTIP_KEYS2.MAX = "max", BOX_PLOT_TOOLTIP_KEYS2.MIN = "min", BOX_PLOT_TOOLTIP_KEYS2.MEDIAN = "median", BOX_PLOT_TOOLTIP_KEYS2.Q1 = "q1", BOX_PLOT_TOOLTIP_KEYS2.Q3 = "q3", BOX_PLOT_TOOLTIP_KEYS2.SERIES_FIELD = "seriesField";
}(BOX_PLOT_TOOLTIP_KEYS || (BOX_PLOT_TOOLTIP_KEYS = {}));

// node_modules/@visactor/vchart/esm/data/transforms/box-plot.js
var foldOutlierData = (data, op) => {
  const result2 = [], { outliersField, dimensionField } = op;
  return (data[0].latestData || []).forEach((d) => {
    let outlierValues = d[outliersField];
    isArray_default(outlierValues) || (outlierValues = [outlierValues]), result2.push(...outlierValues.map((v) => {
      const resData = {
        [BOX_PLOT_OUTLIER_VALUE_FIELD]: v
      };
      return dimensionField.forEach((field5) => {
        resData[field5] = d[field5];
      }), resData;
    }));
  }), result2;
};

// node_modules/@visactor/vchart/esm/series/box-plot/tooltip-helper.js
var BoxPlotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.getContentKey = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER) return this.series.getOutliersField();
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return this.series.getSeriesField();
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return this.series.getMinField();
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return this.series.getMaxField();
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return this.series.getMedianField();
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return this.series.getQ1Field();
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return this.series.getQ3Field();
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return this.series.getSeriesField();
      }
      return null;
    }, this.getContentValue = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER) return datum[BOX_PLOT_OUTLIER_VALUE_FIELD];
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return datum[this.series.getSeriesField()];
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return datum[this.series.getMinField()];
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return datum[this.series.getMaxField()];
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return datum[this.series.getMedianField()];
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return datum[this.series.getQ1Field()];
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return datum[this.series.getQ3Field()];
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return datum[this.series.getSeriesField()];
      }
      return null;
    }, this.shapeColorCallback = (datum) => "line" === this.series.getShaftShape() ? this.series.getMarkInName("boxPlot").getAttribute("stroke", datum) : this.series.getMarkInName("boxPlot").getAttribute("fill", datum), this.getOutlierFillColor = (datum) => {
      var _a;
      const outliersStyle = this.series.getOutliersStyle();
      return null !== (_a = null == outliersStyle ? void 0 : outliersStyle.fill) && void 0 !== _a ? _a : this.series.getMarkInName("outlier").getAttribute("fill", datum);
    }, this.isOutlierMark = (datum) => isValid_default(datum[BOX_PLOT_OUTLIER_VALUE_FIELD]);
  }
  getDefaultContentList(activeType) {
    return [{
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
      shapeType: this.shapeTypeCallback,
      shapeColor: this.getOutlierFillColor,
      shapeStroke: this.getOutlierFillColor
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MAX),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MAX)
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q3),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q3)
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MEDIAN),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MEDIAN)
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q1),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q1)
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MIN),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MIN)
    }, {
      key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD),
      value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD)
    }];
  }
};

// node_modules/@visactor/vchart/esm/mark/box-plot.js
var BoxPlotMark = class _BoxPlotMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _BoxPlotMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 2,
      boxWidth: 30,
      shaftWidth: 20,
      shaftShape: "line"
    });
  }
  _initProduct(group) {
    const shaftShape = this.getStyle("shaftShape"), view = this.getVGrammarView(), id = this.getProductId(), glyphType = "bar" === shaftShape ? "barBoxplot" : "boxplot", direction = this.getStyle("direction");
    this._product = view.glyph(glyphType, null != group ? group : view.rootMark).id(id).configureGlyph({
      direction
    }), this._compiledProductId = id;
  }
};
BoxPlotMark.type = "boxPlot";
var registerBoxPlotMark = () => {
  Factory2.registerMark(BoxPlotMark.type, BoxPlotMark), registerBoxplotGlyph(), registerBarBoxplotGlyph();
};

// node_modules/@visactor/vchart/esm/series/box-plot/constant.js
var boxPlotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  boxPlot: {
    name: "boxPlot",
    type: "boxPlot"
  },
  outlier: {
    name: "outlier",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/box-plot/box-plot.js
var BoxPlotSeries = class _BoxPlotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.boxPlot;
  }
  getMinField() {
    return this._minField;
  }
  getMaxField() {
    return this._maxField;
  }
  getQ1Field() {
    return this._q1Field;
  }
  getMedianField() {
    return this._medianField;
  }
  getQ3Field() {
    return this._q3Field;
  }
  getOutliersField() {
    return this._outliersField;
  }
  getShaftShape() {
    return this._shaftShape;
  }
  getBoxFillColor() {
    return this._boxFillColor;
  }
  getStrokeColor() {
    return this._strokeColor;
  }
  getOutliersStyle() {
    return this._outliersStyle;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec();
    const boxPlotStyle = null !== (_b = null === (_a = this._spec.boxPlot) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this._minField = this._spec.minField, this._maxField = this._spec.maxField, this._q1Field = this._spec.q1Field, this._medianField = this._spec.medianField, this._q3Field = this._spec.q3Field, this._outliersField = this._spec.outliersField, this._lineWidth = null !== (_c = boxPlotStyle.lineWidth) && void 0 !== _c ? _c : 2, this._boxWidth = boxPlotStyle.boxWidth, this._shaftShape = null !== (_d = boxPlotStyle.shaftShape) && void 0 !== _d ? _d : "line", this._shaftWidth = boxPlotStyle.shaftWidth, this._boxFillColor = boxPlotStyle.boxFill, this._strokeColor = boxPlotStyle.stroke, this._shaftFillOpacity = "bar" === this._shaftShape ? null !== (_e = boxPlotStyle.shaftFillOpacity) && void 0 !== _e ? _e : 0.5 : void 0, this._outliersStyle = this._spec.outliersStyle;
  }
  initMark() {
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._boxPlotMark = this._createMark(_BoxPlotSeries.mark.boxPlot, {
      groupKey: this._seriesField,
      isSeriesMark: true
    }, progressive), this._outlierMark = this._createMark(_BoxPlotSeries.mark.outlier, {
      key: DEFAULT_DATA_INDEX,
      groupKey: this._seriesField,
      dataView: this._outlierDataView.getDataView(),
      dataProductId: this._outlierDataView.getProductId()
    }, progressive);
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const boxPlotMark = this._boxPlotMark;
    if (boxPlotMark) {
      const commonBoxplotStyles = {
        direction: this._direction,
        lineWidth: this._lineWidth,
        shaftShape: this._shaftShape,
        fill: null !== (_a = this._boxFillColor) && void 0 !== _a ? _a : "line" === this._shaftShape ? "#FFF" : this.getColorAttribute(),
        minMaxFillOpacity: this._shaftFillOpacity,
        stroke: null !== (_b = this._strokeColor) && void 0 !== _b ? _b : "line" === this._shaftShape ? this.getColorAttribute() : "#000"
      }, boxPlotMarkStyles = "horizontal" === this._direction ? Object.assign(Object.assign({
        y: this.dataToPositionY.bind(this)
      }, commonBoxplotStyles), {
        boxHeight: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Height: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      }) : Object.assign(Object.assign({
        x: this.dataToPositionX.bind(this)
      }, commonBoxplotStyles), {
        boxWidth: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Width: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      });
      this.setMarkStyle(boxPlotMark, boxPlotMarkStyles, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    const outlierMark = this._outlierMark;
    outlierMark && this.setMarkStyle(outlierMark, {
      fill: null !== (_d = null === (_c = this._outliersStyle) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : this.getColorAttribute(),
      size: isNumber_default(null === (_e = this._outliersStyle) || void 0 === _e ? void 0 : _e.size) ? this._outliersStyle.size : 10,
      symbolType: "circle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initBoxPlotMarkStyle() {
    var _a, _b;
    const boxPlotMark = this._boxPlotMark, axisHelper = "horizontal" === this._direction ? this._xAxisHelper : this._yAxisHelper;
    if (boxPlotMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_a = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _a ? void 0 : _a.call(axisHelper, 0);
      this.setMarkStyle(boxPlotMark, {
        min: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._minField), {
          bandPosition: this._bandPosition
        }), scale4),
        q1: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q1Field), {
          bandPosition: this._bandPosition
        }), scale4),
        median: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._medianField), {
          bandPosition: this._bandPosition
        }), scale4),
        q3: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q3Field), {
          bandPosition: this._bandPosition
        }), scale4),
        max: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._maxField), {
          bandPosition: this._bandPosition
        }), scale4)
      }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    const outlierMark = this._outlierMark;
    if (outlierMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_b = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _b ? void 0 : _b.call(axisHelper, 0), outlierMarkPositionChannel = "horizontal" === this._direction ? {
        y: this.dataToPositionY.bind(this),
        x: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      } : {
        x: this.dataToPositionX.bind(this),
        y: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      };
      this.setMarkStyle(outlierMark, outlierMarkPositionChannel, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
  }
  initData() {
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "foldOutlierData", foldOutlierData), registerDataSetInstanceTransform(this._dataSet, "addVChartProperty", addVChartProperty);
    const outlierDataView = new DataView(this._dataSet, {
      name: `${this.type}_outlier_${this.id}_data`
    });
    outlierDataView.parse([this.getViewData()], {
      type: "dataview"
    }), outlierDataView.name = `${PREFIX}_series_${this.id}_outlierData`, outlierDataView.transform({
      type: "foldOutlierData",
      options: {
        dimensionField: "horizontal" === this._direction ? this._fieldY : this._fieldX,
        outliersField: this._outliersField
      }
    }), outlierDataView.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false), this._outlierDataView = new SeriesData(this._option, outlierDataView);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._outlierDataView) || void 0 === _a || _a.compile();
  }
  init(option) {
    super.init(option), this.initBoxPlotMarkStyle();
  }
  _getMarkWidth() {
    if (this._autoBoxWidth) return this._autoBoxWidth;
    const bandAxisHelper = "horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper, xField = "horizontal" === this._direction ? this._fieldY : this._fieldX, autoBoxWidth = bandAxisHelper.getBandwidth(xField.length - 1) / xField.length;
    return this._autoBoxWidth = autoBoxWidth, this._autoBoxWidth;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._autoBoxWidth = null;
  }
  _initAnimationSpec(config2 = {}) {
    const newConfig = merge({}, config2);
    return ["appear", "enter", "update", "exit", "disappear"].forEach((state) => {
      newConfig[state] && "scaleIn" === newConfig[state].type ? newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleIn" : "barBoxplotScaleIn" : newConfig[state] && "scaleOut" === newConfig[state].type && (newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleOut" : "barBoxplotScaleOut");
    }), newConfig;
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const animationParams = getGroupAnimationParams(this);
    if (this._boxPlotMark) {
      const newDefaultConfig = this._initAnimationSpec(null === (_a = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a ? void 0 : _a()), newConfig = this._initAnimationSpec(userAnimationConfig("boxPlot", this._spec, this._markAttributeContext));
      this._boxPlotMark.setAnimationConfig(animationConfig(newDefaultConfig, newConfig, animationParams));
    }
    if (this._outlierMark) {
      const outlierMarkUserAnimation = {
        appear: null === (_b = this._spec.animationAppear) || void 0 === _b ? void 0 : _b.symbol,
        disappear: null === (_c = this._spec.animationDisappear) || void 0 === _c ? void 0 : _c.symbol,
        enter: null === (_d = this._spec.animationEnter) || void 0 === _d ? void 0 : _d.symbol,
        exit: null === (_e = this._spec.animationExit) || void 0 === _e ? void 0 : _e.symbol,
        update: null === (_f = this._spec.animationUpdate) || void 0 === _f ? void 0 : _f.symbol
      };
      this._outlierMark.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _g ? void 0 : _g(), outlierMarkUserAnimation, animationParams));
    }
  }
  initTooltip() {
    this._tooltipHelper = new BoxPlotSeriesTooltipHelper(this), this._boxPlotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._boxPlotMark), this._outlierMark && this._tooltipHelper.activeTriggerSet.mark.add(this._outlierMark);
  }
  getStatisticFields() {
    const fields2 = super.getStatisticFields(), outliersField = fields2.find((f) => f.key === this._outliersField);
    return outliersField && (outliersField.operations = ["array-min", "array-max"]), fields2;
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._outlierDataView.updateData();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._boxPlotMark];
  }
};
BoxPlotSeries.type = SeriesTypeEnum.boxPlot, BoxPlotSeries.mark = boxPlotSeriesMark;
var registerBoxplotSeries = () => {
  registerBoxPlotMark(), registerSymbolMark(), registerScaleInOutAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(BoxPlotSeries.type, BoxPlotSeries);
};

// node_modules/@visactor/vchart/esm/mark/text.js
var TextMark = class _TextMark extends BaseMark {
  getTextType() {
    return this._textType;
  }
  constructor(name, option) {
    super(name, option), this.type = _TextMark.type, this._textType = "text";
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      angle: 0,
      textAlign: "center",
      lineWidth: 0,
      textConfig: []
    });
  }
  initStyleWithSpec(spec, key) {
    super.initStyleWithSpec(spec, key), spec.textType && (this._textType = spec.textType);
  }
  compileEncode() {
    super.compileEncode(), "rich" === this._textType && this._product.encodeState("group", {
      textType: this._textType
    });
  }
};
TextMark.type = "text";
var registerTextMark = () => {
  Factory2.registerMark(TextMark.type, TextMark), registerTextGraphic2(), registerRichTextGraphic();
};

// node_modules/@visactor/vchart/esm/series/util/label-mark.js
function setRectLabelPos(component2, labelMark, position, offset, x, x1, y, y1, direction) {
  component2.setMarkStyle(labelMark, {
    textAlign: (datum) => {
      if ("vertical" === direction()) return "center";
      const _x = x(datum), _x1 = x1(datum);
      if ("middle" === position) return "center";
      if (_x >= _x1) {
        if ("start" === position) return "left";
        if ("end" === position) return "right";
        if ("outside" === position) return "left";
      } else {
        if ("start" === position) return "right";
        if ("end" === position) return "left";
        if ("outside" === position) return "right";
      }
      return "center";
    },
    textBaseline: (datum) => {
      if ("horizontal" === direction()) return "middle";
      const _y = y(datum), _y1 = y1(datum);
      if ("middle" === position) return "middle";
      if (_y1 >= _y) {
        if ("start" === position) return "bottom";
        if ("end" === position) return "top";
        if ("outside" === position) return "bottom";
      } else {
        if ("start" === position) return "top";
        if ("end" === position) return "bottom";
        if ("outside" === position) return "top";
      }
      return "middle";
    }
  }), component2.setMarkStyle(labelMark, {
    x: (datum) => {
      const d = direction(), _x = x(datum), _x1 = x1(datum);
      if ("vertical" === d) return (_x + _x1) / 2;
      if ("middle" === position) return (_x + _x1) / 2;
      if (_x >= _x1) {
        if ("start" === position) return _x1 + offset;
        if ("end" === position) return _x - offset;
        if ("outside" === position) return _x + offset;
      } else {
        if ("start" === position) return _x1 - offset;
        if ("end" === position) return _x + offset;
        if ("outside" === position) return _x - offset;
      }
      return (_x + _x1) / 2;
    },
    y: (datum) => {
      const d = direction(), _y = y(datum), _y1 = y1(datum);
      if ("horizontal" === d) return (_y + _y1) / 2;
      if ("middle" === position) return (_y + _y1) / 2;
      if (_y >= _y1) {
        if ("start" === position) return _y1 + offset;
        if ("end" === position) return _y - offset;
        if ("outside" === position) return _y + offset;
      } else {
        if ("start" === position) return _y1 - offset;
        if ("end" === position) return _y + offset;
        if ("outside" === position) return _y - offset;
      }
      return (_y + _y1) / 2;
    }
  }, "normal", AttributeLevel.Series);
}

// node_modules/@visactor/vchart/esm/series/range-column/tooltip-helper.js
var RangeColumnSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getMeasureData = (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]];
  }
};

// node_modules/@visactor/vchart/esm/series/range-column/animation.js
var rangeColumnGrowIn = (params2) => ({
  type: "growCenterIn",
  options: {
    direction: "horizontal" === params2.direction ? "x" : "y"
  }
});
var Appear_FadeIn4 = {
  type: "fadeIn"
};
var rangeColumnGrowOut = (params2) => ({
  type: "growCenterOut",
  options: {
    direction: "horizontal" === params2.direction ? "x" : "y"
  }
});
function rangeColumnPresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn4 : rangeColumnGrowIn(params2);
}
var registerRangeColumnAnimation = () => {
  Factory2.registerAnimation("rangeColumn", (params2, preset) => ({
    appear: rangeColumnPresetAnimation(params2, preset),
    enter: rangeColumnGrowIn(params2),
    exit: rangeColumnGrowOut(params2),
    disappear: rangeColumnGrowOut(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/range-column/constant.js
var rangeColumnSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});
var rangeColumn3dSeriesMark = Object.assign(Object.assign({}, bar3dSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/range-column/range-column-transformer.js
var RangeColumnSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    var _a;
    "bothEnd" !== (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.position) && this._addMarkLabelSpec(spec, "bar");
  }
};

// node_modules/@visactor/vchart/esm/series/range-column/range-column.js
var RangeColumnSeries = class _RangeColumnSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn, this._barMarkType = "rect", this._barName = SeriesTypeEnum.bar, this.transformerConstructor = RangeColumnSeriesSpecTransformer;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this._initBarBackgroundMark();
    const labelPosition = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position;
    this._barMark = this._createMark(_RangeColumnSeries.mark.bar, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.stateSort
    }, {
      setCustomizedShape: null === (_c = this._spec.bar) || void 0 === _c ? void 0 : _c.customShape,
      morph: shouldMarkDoMorph(this._spec, _RangeColumnSeries.mark.bar.name),
      morphElementKey: this.getDimensionField()[0]
    }), false !== (null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.visible) && "bothEnd" === labelPosition && (false !== (null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.minLabel) || void 0 === _f ? void 0 : _f.visible) && (this._minLabelMark = this._createMark(_RangeColumnSeries.mark.minLabel, {
      markSpec: null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.minLabel
    })), false !== (null === (_j = null === (_h = this._spec.label) || void 0 === _h ? void 0 : _h.maxLabel) || void 0 === _j ? void 0 : _j.visible) && (this._maxLabelMark = this._createMark(_RangeColumnSeries.mark.maxLabel, {
      markSpec: null === (_k = this._spec.label) || void 0 === _k ? void 0 : _k.maxLabel
    })));
  }
  initMarkStyle() {
    var _a, _b;
    super.initMarkStyle(), this._initLabelMarkPos(this._minLabelMark, null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.minLabel, 0, "end"), this._initLabelMarkPos(this._maxLabelMark, null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.maxLabel, 1, "start");
  }
  _initLabelMarkPos(labelMark, labelSpec, fieldIndex, defaultPosition) {
    var _a, _b, _c, _d;
    if (labelMark) {
      this.setMarkStyle(labelMark, {
        fill: null !== (_b = null === (_a = null == labelSpec ? void 0 : labelSpec.style) || void 0 === _a ? void 0 : _a.fill) && void 0 !== _b ? _b : this.getColorAttribute(),
        text: (datum) => {
          const val = "horizontal" === this._spec.direction ? datum[this._spec.xField[fieldIndex]] : datum[this._spec.yField[fieldIndex]];
          return (null == labelSpec ? void 0 : labelSpec.formatMethod) ? labelSpec.formatMethod(val, datum) : val;
        }
      });
      const position = null !== (_c = null == labelSpec ? void 0 : labelSpec.position) && void 0 !== _c ? _c : defaultPosition, offset = null !== (_d = null == labelSpec ? void 0 : labelSpec.offset) && void 0 !== _d ? _d : "vertical" === this._direction ? -20 : -25;
      setRectLabelPos(this, labelMark, position, offset, (datum) => this._barMark.getAttribute("x", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum), (datum) => this._barMark.getAttribute("y", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum), () => this._direction);
    }
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this.setMarkStyle(labelMark, {
      text: (datum) => {
        let min3, max3;
        return "horizontal" === this._spec.direction ? (min3 = datum[this._spec.xField[0]], max3 = datum[this._spec.xField[1]]) : (min3 = datum[this._spec.yField[0]], max3 = datum[this._spec.yField[1]]), min3 + "-" + max3;
      },
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), this._labelMark = labelMark);
  }
  _dataToPosX(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosX1(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY1(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
      bandPosition: this._bandPosition
    });
  }
  initAnimation() {
    var _a, _b, _c, _d, _e;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rangeColumn")) || void 0 === _c ? void 0 : _c({
      direction: this.direction
    }, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._minLabelMark && this._minLabelMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams)), this._maxLabelMark && this._maxLabelMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams));
  }
  initTooltip() {
    this._tooltipHelper = new RangeColumnSeriesTooltipHelper(this), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark), this._minLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._minLabelMark), this._maxLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._maxLabelMark), this._labelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._labelMark);
  }
};
RangeColumnSeries.type = SeriesTypeEnum.rangeColumn, RangeColumnSeries.mark = rangeColumnSeriesMark, RangeColumnSeries.transformerConstructor = RangeColumnSeriesSpecTransformer;
var registerRangeColumnSeries = () => {
  registerRectMark(), registerTextMark(), registerRangeColumnAnimation(), registerFadeInOutAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(RangeColumnSeries.type, RangeColumnSeries);
};

// node_modules/@visactor/vchart/esm/series/range-column/3d/range-column-3d.js
var RangeColumn3dSeries = class extends RangeColumnSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn3d, this._barMarkType = "rect3d", this._barName = SeriesTypeEnum.bar3d;
  }
};
RangeColumn3dSeries.type = SeriesTypeEnum.rangeColumn3d, RangeColumn3dSeries.mark = rangeColumn3dSeriesMark;
var registerRangeColumn3dSeries = () => {
  registerRect3dMark(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(RangeColumn3dSeries.type, RangeColumn3dSeries);
};

// node_modules/@visactor/vchart/esm/series/range-area/tooltip-helper.js
var RangeAreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getMeasureData = (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]];
  }
};

// node_modules/@visactor/vchart/esm/series/range-area/constant.js
var rangeAreaSeriesMark = Object.assign({}, areaSeriesMark);

// node_modules/@visactor/vchart/esm/series/range-area/range-area.js
var RangeAreaSeries = class _RangeAreaSeries extends AreaSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeArea;
  }
  initMark() {
    var _a;
    const { customShape, stateSort } = null !== (_a = this._spec.area) && void 0 !== _a ? _a : {};
    this._areaMark = this._createMark(_RangeAreaSeries.mark.area, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort
    }, {
      setCustomizedShape: customShape,
      morphElementKey: this.getDimensionField()[0]
    });
  }
  initMarkStyle() {
    this.initAreaMarkStyle();
  }
  initAreaMarkStyle() {
    const areaMark = this._areaMark;
    areaMark && (super.initAreaMarkStyle(), "horizontal" === this._direction ? this.setMarkStyle(this._areaMark, {
      x1: (datum) => {
        if (!this._xAxisHelper) return Number.NaN;
        const { dataToPosition } = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
          bandPosition: this._bandPosition
        });
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
      y1: (datum) => {
        if (!this._yAxisHelper) return Number.NaN;
        const { dataToPosition } = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
          bandPosition: this._bandPosition
        });
      }
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      stroke: false
    }, "normal", AttributeLevel.Series));
  }
  initTooltip() {
    this._tooltipHelper = new RangeAreaSeriesTooltipHelper(this);
  }
  _isFieldAllValid() {
    const viewStatistics = this.getViewDataStatistics(), fields2 = this.fieldY;
    return !!(viewStatistics && viewStatistics.latestData && fields2.length) && fields2.every((field5) => viewStatistics.latestData[field5] && viewStatistics.latestData[field5].allValid);
  }
};
RangeAreaSeries.type = SeriesTypeEnum.rangeArea, RangeAreaSeries.mark = rangeAreaSeriesMark;
var registerRangeAreaSeries = () => {
  registerAreaMark(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(RangeAreaSeries.type, RangeAreaSeries);
};

// node_modules/@visactor/vchart/esm/series/polar/polar.js
var PolarSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "polar", this._outerRadius = POLAR_DEFAULT_RADIUS, this._innerRadius = 0, this._angleField = [], this._radiusField = [], this._sortDataByAxis = false;
  }
  get outerRadius() {
    return this._outerRadius;
  }
  get innerRadius() {
    return this._innerRadius;
  }
  getAngleField() {
    return this._angleField;
  }
  setAngleField(f) {
    return this._angleField = isValid_default(f) ? array(f) : [], this._angleField;
  }
  getRadiusField() {
    return this._radiusField;
  }
  setRadiusField(f) {
    return this._radiusField = isValid_default(f) ? array(f) : [], this._radiusField;
  }
  get innerRadiusField() {
    return this._innerRadiusField;
  }
  setInnerRadiusField(f) {
    return this._innerRadiusField = array(f), this._innerRadiusField;
  }
  get radiusScale() {
    return this._radiusScale;
  }
  setRadiusScale(s2) {
    return this._radiusScale = s2, s2;
  }
  get angleScale() {
    return this._angleScale;
  }
  setAngleScale(s2) {
    return this._angleScale = s2, s2;
  }
  get angleAxisHelper() {
    return this._angleAxisHelper;
  }
  set angleAxisHelper(h) {
    this._angleAxisHelper = h, this.onAngleAxisHelperUpdate();
  }
  get radiusAxisHelper() {
    return this._radiusAxisHelper;
  }
  set radiusAxisHelper(h) {
    this._radiusAxisHelper = h, this.onRadiusAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this), this._markAttributeContext.getCenter = () => this.angleAxisHelper.center(), this._markAttributeContext.getLayoutRadius = () => this._computeLayoutRadius();
  }
  valueToPosition(angleValue, radiusValue) {
    if (isNil_default(angleValue) || isNil_default(radiusValue) || !this.angleAxisHelper || !this.radiusAxisHelper) return {
      x: Number.NaN,
      y: Number.NaN
    };
    const radius = this.radiusAxisHelper.dataToPosition(array(radiusValue));
    if (radius < 0) {
      if ("break" === this._invalidType || "link" === this._invalidType) return {
        x: Number.NaN,
        y: Number.NaN
      };
      if ("zero" === this._invalidType) return this.angleAxisHelper.center();
    }
    const angle2 = this.angleAxisHelper.dataToPosition(array(angleValue));
    return this.angleAxisHelper.coordToPoint({
      angle: angle2,
      radius
    });
  }
  dataToPosition(datum, checkInViewData) {
    return datum && this.angleAxisHelper && this.radiusAxisHelper ? checkInViewData && !this.isDatumInViewData(datum) ? null : this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getDatumPositionValues(datum, this._radiusField)) : null;
  }
  dataToPositionX(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
  }
  dataToPositionY(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  positionToData(p) {
  }
  radiusToData(r) {
  }
  angleToData(a3) {
  }
  getStatisticFields() {
    var _a, _b;
    const fields2 = [];
    return (null === (_a = this.radiusAxisHelper) || void 0 === _a ? void 0 : _a.getScale) && this._radiusField.forEach((f) => {
      const result2 = {
        key: f,
        operations: []
      };
      isContinuous(this.radiusAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), (null === (_b = this.angleAxisHelper) || void 0 === _b ? void 0 : _b.getScale) && this._angleField.forEach((f) => {
      const result2 = {
        key: f,
        operations: []
      };
      isContinuous(this.angleAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), fields2;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isValid_default(this._spec.outerRadius) && (this._outerRadius = this._spec.outerRadius), isValid_default(this._spec.radius) && (this._outerRadius = this._spec.radius), isValid_default(this._spec.innerRadius) && (this._innerRadius = this._spec.innerRadius), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  onRadiusAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onAngleAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  afterInitMark() {
    super.afterInitMark();
  }
  _computeLayoutRadius() {
    const axisHelper = this._angleAxisHelper || this._radiusAxisHelper;
    if (axisHelper) return axisHelper.layoutRadius();
    const { width, height } = this._region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  initEvent() {
    super.initEvent(), this.sortDataByAxis && this.event.on(ChartEvent.scaleDomainUpdate, {
      filter: (param) => {
        var _a;
        return param.model.id === (null === (_a = this._angleAxisHelper) || void 0 === _a ? void 0 : _a.getAxisId());
      }
    }, () => {
      this._sortDataInAxisDomain();
    });
  }
  _sortDataInAxisDomain() {
    var _a, _b;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && sortDataInAxisHelper(this.angleAxisHelper, this._angleField[0], this.getViewData().latestData);
  }
  getInvalidCheckFields() {
    const fields2 = [];
    return this.angleAxisHelper.isContinuous && this._angleField.forEach((f) => {
      fields2.push(f);
    }), this.radiusAxisHelper.isContinuous && this._radiusField.forEach((f) => {
      fields2.push(f);
    }), fields2;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/pie.js
function transformInvalidValue(value) {
  return couldBeValidNumber(value) ? Number.parseFloat(value) : 0;
}
var pie2 = (originData, op) => {
  const { asStartAngle, asEndAngle, asMiddleAngle, asRadian, asRatio, asQuadrant, asK, showAllZero, supportNegative, showEmptyCircle } = op, angleField = op.angleField(), startAngle = op.startAngle(), endAngle = op.endAngle(), minAngle = op.minAngle(), data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length) return data;
  if (!showAllZero && showEmptyCircle && isDataEmpty(data, angleField, supportNegative)) return [];
  const appendArcInfo = (data2, startAngle2, angle2) => {
    data2[asStartAngle] = startAngle2, data2[asEndAngle] = startAngle2 + angle2, data2[asMiddleAngle] = startAngle2 + angle2 / 2, data2[asRadian] = angle2, data2[asQuadrant] = computeQuadrant(startAngle2 + angle2 / 2);
  };
  let total = 0, max3 = -1 / 0, isAllZero = true;
  for (let index = 0; index < data.length; index++) {
    const angleFieldValue = supportNegative ? Math.abs(transformInvalidValue(data[index][angleField])) : transformInvalidValue(data[index][angleField]);
    total += angleFieldValue, max3 = Math.max(angleFieldValue, max3), isAllZero && 0 !== angleFieldValue && (isAllZero = false), data[index][ARC_TRANSFORM_VALUE] = angleFieldValue;
  }
  const valueList = data.map((d) => Number(d[angleField])), angleRange = endAngle - startAngle;
  let lastAngle = startAngle, restAngle = angleRange, largeThanMinAngleTotal = 0;
  const percents = getPercentValue(valueList);
  if (data.forEach((d, i) => {
    const angleFieldValue = d[ARC_TRANSFORM_VALUE], ratio = total ? angleFieldValue / total : 0;
    let radian = ratio * angleRange;
    radian < minAngle ? (radian = minAngle, restAngle -= minAngle) : largeThanMinAngleTotal += angleFieldValue;
    const dStartAngle = lastAngle, dEndAngle = lastAngle + radian;
    d[asRatio] = ratio, d[asK] = max3 ? angleFieldValue / max3 : 0, d._percent_ = percents[i], appendArcInfo(d, dStartAngle, radian), lastAngle = dEndAngle;
  }), restAngle < angleRange) if (restAngle <= 1e-3) {
    const angle2 = angleRange / data.length;
    data.forEach((d, index) => {
      appendArcInfo(d, startAngle + index * angle2, angle2);
    });
  } else {
    const unitRadian = restAngle / largeThanMinAngleTotal;
    lastAngle = startAngle, data.forEach((d) => {
      const angle2 = d[asRadian] === minAngle ? minAngle : d[ARC_TRANSFORM_VALUE] * unitRadian;
      appendArcInfo(d, lastAngle, angle2), lastAngle += angle2;
    });
  }
  if (0 !== total && (data[data.length - 1][asEndAngle] = endAngle), isAllZero && showAllZero) {
    const angle2 = angleRange / data.length;
    data.forEach((d, index) => {
      appendArcInfo(d, startAngle + index * angle2, angle2);
    });
  }
  return data;
};
var isDataEmpty = (data, angleField, supportNegative) => !!isNil_default(data) || (0 === data.length || (!!data.every((datum) => 0 === transformInvalidValue(datum[angleField])) || !supportNegative && 0 === data.reduce((sum3, datum) => sum3 + transformInvalidValue(datum[angleField]), 0)));

// node_modules/@visactor/vchart/esm/series/pie/animation/animation.js
function pieGrowOption(pieParams, isOverall, state) {
  return (datum, element, params2) => isOverall ? "radius" === pieParams.growField ? {
    overall: 0
  } : {
    overall: pieParams.growFrom(datum, element, state)
  } : {
    overall: false
  };
}
var Appear_Grow2 = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  options: pieGrowOption(params2, true, AnimationStateEnum.appear)
});
var Appear_FadeIn5 = {
  type: "fadeIn"
};
var pieEnter = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.enter)
});
var pieExit = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
var pieDisappear = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
function piePresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn5;
    case "growRadius":
      return Appear_Grow2(Object.assign(Object.assign({}, params2), {
        growField: "radius"
      }));
    default:
      return Appear_Grow2(Object.assign(Object.assign({}, params2), {
        growField: "angle"
      }));
  }
}
var registerPieAnimation = () => {
  Factory2.registerAnimation("pie", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset),
    enter: pieEnter(params2),
    exit: pieExit(params2),
    disappear: pieDisappear(params2)
  }));
};
var registerEmptyCircleAnimation = () => {
  Factory2.registerAnimation("emptyCircle", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset)
  }));
};
var registerPie3dAnimation = () => {
  Factory2.registerAnimation("pie3d", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset),
    enter: pieEnter(params2),
    exit: pieExit(params2),
    disappear: pieDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/pie/animation/centerOffset.js
function centerOffsetConfig(mark, originalConfig) {
  var _a, _b, _c, _d;
  const offset = null !== (_b = null === (_a = originalConfig.options) || void 0 === _a ? void 0 : _a.distance) && void 0 !== _b ? _b : 10, duration = isValidNumber_default(originalConfig.duration) ? originalConfig.duration / 2 : 1e3, easing = null !== (_c = originalConfig.options.easing) && void 0 !== _c ? _c : "cubicOut";
  return {
    oneByOne: originalConfig.oneByOne,
    loop: null !== (_d = originalConfig.loop) && void 0 !== _d && _d,
    timeSlices: [{
      duration,
      effects: {
        easing,
        channel: {
          x: {
            from: (datum) => mark.getAttribute("x", datum),
            to: (datum) => mark.getAttribute("x", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).x
          },
          y: {
            from: (datum) => mark.getAttribute("y", datum),
            to: (datum) => mark.getAttribute("y", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).y
          }
        }
      }
    }, {
      duration,
      effects: {
        easing,
        channel: {
          x: {
            to: (datum) => mark.getAttribute("x", datum),
            from: (datum) => mark.getAttribute("x", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).x
          },
          y: {
            to: (datum) => mark.getAttribute("y", datum),
            from: (datum) => mark.getAttribute("y", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).y
          }
        }
      }
    }]
  };
}

// node_modules/@visactor/vchart/esm/mark/arc.js
var BaseArcMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = ArcMark.type, this._unCompileChannel = {
      centerOffset: true,
      radiusOffset: true
    }, this.computeOuterRadius = (key, datum, states = "normal", opt, superValue) => {
      var _a;
      return superValue + (null !== (_a = this.getAttribute("radiusOffset", datum, states, opt)) && void 0 !== _a ? _a : 0);
    }, this.computeCenter = (key, datum, states = "normal", opt, center2) => polarToCartesian({
      x: 0,
      y: 0
    }, this.getAttribute("centerOffset", datum, states, opt), datum[ARC_MIDDLE_ANGLE])[key] + center2, this._computeExChannel.x = this.computeCenter, this._computeExChannel.y = this.computeCenter, this._computeExChannel.outerRadius = this.computeOuterRadius, this._extensionChannel.centerOffset = ["x", "y"], this._extensionChannel.radiusOffset = ["outerRadius"];
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      startAngle: 0,
      endAngle: 0,
      outerRadius: 0,
      innerRadius: 0,
      cornerRadius: 0,
      lineWidth: 0,
      innerPadding: 0,
      outerPadding: 0
    });
  }
};
var ArcMark = class _ArcMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _ArcMark.type;
  }
};
ArcMark.type = "arc";
var registerArcMark = () => {
  registerArcGraphic2(), registerVGrammarArcAnimation(), Factory2.registerMark(ArcMark.type, ArcMark);
};

// node_modules/@visactor/vchart/esm/series/pie/constant.js
var pieSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie: {
    name: "pie",
    type: "arc"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});
var pie3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie3d: {
    name: "pie3d",
    type: "arc3d"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});

// node_modules/@visactor/vchart/esm/series/pie/pie-transformer.js
var PieSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie");
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec);
      newSpec = mergeSpec({}, this._theme, specFromChart, spec);
      const getMergedLabelSpec = (position, label) => mergeSpec({}, "inside" === position || "inside-center" === position ? this._theme.innerLabel : this._theme.outerLabel, label);
      isArray_default(newSpec.label) ? newSpec.label = newSpec.label.map((label) => getMergedLabelSpec(label.position, label)) : newSpec.label = getMergedLabelSpec(newSpec.label.position, newSpec.label);
    }
    return {
      spec: newSpec,
      theme: theme2
    };
  }
  _getDefaultSpecFromChart(chartSpec) {
    var _a;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, { centerX, centerY } = chartSpec;
    return isValid_default(centerX) && (spec.centerX = centerX), isValid_default(centerY) && (spec.centerY = centerY), Object.keys(spec).length > 0 ? spec : void 0;
  }
};

// node_modules/@visactor/vchart/esm/constant/label.js
var DEFAULT_LABEL_LIMIT = `${PREFIX}_LABEL_LIMIT`;
var DEFAULT_LABEL_ALIGN = `${PREFIX}_LABEL_ALIGN`;
var DEFAULT_LABEL_TEXT = `${PREFIX}_LABEL_TEXT`;
var DEFAULT_LABEL_VISIBLE = `${PREFIX}_LABEL_VISIBLE`;
var DEFAULT_LABEL_X = `${PREFIX}_LABEL_X`;
var DEFAULT_LABEL_Y = `${PREFIX}_LABEL_Y`;

// node_modules/@visactor/vchart/esm/component/axis/polar/util/common.js
var getPolarAxisInfo = (spec, chartSpec) => {
  var _a, _b, _c, _d, _e, _f;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : "angle" === spec.orient ? "band" : "linear", componentName = `${ComponentTypeEnum.polarAxis}-${axisType}`, startAngleFromSpec = null !== (_b = spec.startAngle) && void 0 !== _b ? _b : chartSpec.startAngle, endAngleFromSpec = null !== (_c = spec.endAngle) && void 0 !== _c ? _c : chartSpec.endAngle;
  return {
    axisType,
    componentName,
    startAngle: null != startAngleFromSpec ? startAngleFromSpec : POLAR_START_ANGLE2,
    endAngle: null != endAngleFromSpec ? endAngleFromSpec : isValid_default(startAngleFromSpec) ? startAngleFromSpec + 360 : POLAR_END_ANGLE2,
    center: isValid_default(chartSpec.center) ? chartSpec.center : isValid_default(null == chartSpec ? void 0 : chartSpec.centerX) || isValid_default(null == chartSpec ? void 0 : chartSpec.centerY) ? {
      x: null == chartSpec ? void 0 : chartSpec.centerX,
      y: null == chartSpec ? void 0 : chartSpec.centerY
    } : void 0,
    outerRadius: null !== (_f = null !== (_e = null !== (_d = spec.outerRadius) && void 0 !== _d ? _d : spec.radius) && void 0 !== _e ? _e : chartSpec.outerRadius) && void 0 !== _f ? _f : chartSpec.radius,
    layoutRadius: chartSpec.layoutRadius
  };
};
var computeLayoutRadius = (getLayoutRadius, getLayoutRect, getCenter3, getAngles) => {
  const layoutRadius = getLayoutRadius();
  if (isNumber_default(layoutRadius)) return layoutRadius;
  if (isFunction_default(layoutRadius)) return layoutRadius(getLayoutRect(), getCenter3());
  const rect = getLayoutRect();
  if ("auto" === layoutRadius && rect.width > 0 && rect.height > 0) {
    const { startAngle = 0, endAngle = 2 * Math.PI } = getAngles();
    return calculateMaxRadius(rect, getCenter3(), startAngle, endAngle);
  }
  return Math.min(rect.width / 2, rect.height / 2);
};

// node_modules/@visactor/vchart/esm/series/pie/pie.js
var BasePieSeries = class _BasePieSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.transformerConstructor = PieSeriesSpecTransformer, this._pieMarkName = "pie", this._pieMarkType = "arc", this.getCenter = () => {
      var _a, _b;
      const layoutRect = this._region.getLayoutRect();
      return {
        x: calcLayoutNumber(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerX, layoutRect.width, layoutRect, layoutRect.width / 2),
        y: calcLayoutNumber(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.centerY, layoutRect.height, layoutRect, layoutRect.height / 2)
      };
    }, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._pieMark = null, this._labelMark = null, this._labelLineMark = null, this._emptyArcMark = null, this.dataToCentralPosition = (datum) => {
      const angle2 = datum[ARC_MIDDLE_ANGLE];
      if (isNil_default(angle2)) return null;
      const radius = this.computeDatumRadius(datum), innerRadius = this.computeDatumInnerRadius(datum), center2 = this.computeCenter(datum);
      return polarToCartesian(center2, (radius + innerRadius) / 2, angle2);
    };
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => this.getCenter().x,
      y: () => this.getCenter().y
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f;
    super.setAttrFromSpec(), this._centerOffset = null !== (_a = this._spec.centerOffset) && void 0 !== _a ? _a : 0, this._cornerRadius = null !== (_b = this._spec.cornerRadius) && void 0 !== _b ? _b : 0;
    const normalized = normalizeStartEndAngle(isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : this._startAngle, isValid_default(this._spec.endAngle) ? degreeToRadian(this._spec.endAngle) : this._endAngle);
    this._startAngle = normalized.startAngle, this._endAngle = normalized.endAngle, this._padAngle = isValid_default(this._spec.padAngle) ? degreeToRadian(this._spec.padAngle) : 0, this.setAngleField(this._spec.valueField || this._spec.angleField), this._spec.categoryField && this.setSeriesField(this._spec.categoryField), this._radiusField = [], this._specAngleField = this._angleField.slice(), this._specRadiusField = [], this._showEmptyCircle = null !== (_d = null === (_c = this._spec.emptyPlaceholder) || void 0 === _c ? void 0 : _c.showEmptyCircle) && void 0 !== _d && _d, this._showAllZero = null !== (_e = this._spec.showAllZero) && void 0 !== _e && _e, this._supportNegative = null !== (_f = this._spec.supportNegative) && void 0 !== _f && _f;
  }
  initData() {
    super.initData();
    const viewData = this.getViewData();
    if (!viewData) return;
    registerDataSetInstanceTransform(this._dataSet, "pie", pie2), viewData.transform({
      type: "pie",
      options: {
        angleField: () => this._angleField[0],
        startAngle: () => this._startAngle,
        endAngle: () => this._endAngle,
        minAngle: () => isValid_default(this._spec.minAngle) ? degreeToRadian(this._spec.minAngle) : 0,
        asStartAngle: ARC_START_ANGLE,
        asEndAngle: ARC_END_ANGLE,
        asRatio: ARC_RATIO,
        asMiddleAngle: ARC_MIDDLE_ANGLE,
        asRadian: ARC_RADIAN,
        asQuadrant: ARC_QUADRANT,
        asK: ARC_K,
        showAllZero: this._showAllZero,
        supportNegative: this._supportNegative,
        showEmptyCircle: this._showEmptyCircle
      }
    }, false);
    const viewDataLabel = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataLabel`
    });
    viewDataLabel.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataLabel = new SeriesData(this._option, viewDataLabel);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._viewDataLabel) || void 0 === _a || _a.compile();
  }
  initMark() {
    var _a, _b;
    this._pieMark = this._createMark(Object.assign(Object.assign({}, _BasePieSeries.mark.pie), {
      name: this._pieMarkName,
      type: this._pieMarkType
    }), {
      key: DEFAULT_DATA_KEY,
      groupKey: this._seriesField,
      skipBeforeLayouted: true,
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.pie) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.pie) || void 0 === _b ? void 0 : _b.customShape,
      morph: shouldMarkDoMorph(this._spec, this._pieMarkName),
      morphElementKey: this._seriesField
    }), this._showEmptyCircle && (this._emptyArcMark = this._createMark({
      name: "emptyCircle",
      type: "arc"
    }, {
      dataView: false
    }), this._emptyArcMark.setDepend(this._pieMark));
  }
  startAngleScale(datum) {
    return field2(ARC_START_ANGLE)(datum);
  }
  endAngleScale(datum) {
    return field2(ARC_END_ANGLE)(datum);
  }
  _computeLayoutRadius() {
    return computeLayoutRadius(() => this._spec.layoutRadius, this.getLayoutRect, this.getCenter, () => ({
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }));
  }
  initMarkStyle() {
    const initialStyle = {
      x: () => this.getCenter().x,
      y: () => this.getCenter().y,
      fill: this.getColorAttribute(),
      outerRadius: isSpecValueWithScale(this._outerRadius) ? this._outerRadius : () => this._computeLayoutRadius() * this._outerRadius,
      innerRadius: isSpecValueWithScale(this._innerRadius) ? this._innerRadius : () => this._computeLayoutRadius() * this._innerRadius,
      cornerRadius: () => this._computeLayoutRadius() * this._cornerRadius,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      padAngle: this._padAngle,
      centerOffset: this._centerOffset
    }, pieMark = this._pieMark;
    pieMark && this.setMarkStyle(pieMark, initialStyle, "normal", AttributeLevel.Series);
    const emptyPieMark = this._emptyArcMark;
    emptyPieMark && this.setMarkStyle(emptyPieMark, Object.assign(Object.assign({}, initialStyle), {
      visible: () => {
        const data = this.getViewData().latestData;
        return !data || !data.length;
      }
    }), "normal", AttributeLevel.Series);
  }
  initInteraction() {
    this._parseInteractionConfig(this._pieMark ? [this._pieMark] : []);
  }
  initTooltip() {
    super.initTooltip(), this._pieMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pieMark);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (super.initMarkStyleWithSpec(mark, spec, key), mark.name === this._pieMarkName) {
      const pieSpec = this.getSpec()[mark.name];
      if (pieSpec) for (const state in pieSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(pieSpec.state[state]), state, AttributeLevel.User_Mark);
    }
    "emptyCircle" === mark.name && this.setMarkStyle(mark, this.generateRadiusStyle(spec.style), "normal", AttributeLevel.User_Mark);
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      visible: field2(DEFAULT_LABEL_VISIBLE).bind(this),
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: this.getColorAttribute(),
      z: this.dataToPositionZ.bind(this)
    });
  }
  afterInitMark() {
    super.afterInitMark();
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataLabel.getDataView()) || void 0 === _a || _a.target.addListener("change", this.viewDataLabelUpdate.bind(this));
  }
  initGroups() {
  }
  onLayoutEnd(ctx) {
    this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), super.onLayoutEnd(ctx);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return this._specAngleField;
  }
  viewDataLabelUpdate() {
    this.event.emit(ChartEvent.viewDataLabelUpdate, {
      model: this
    }), this._viewDataLabel.updateData();
  }
  generateRadiusStyle(spec) {
    if (!spec) return;
    const style = {};
    return spec.outerRadius && (style.outerRadius = () => this._computeLayoutRadius() * spec.outerRadius), spec.innerRadius && (style.innerRadius = () => this._computeLayoutRadius() * spec.innerRadius), spec.cornerRadius && (style.cornerRadius = () => this._computeLayoutRadius() * spec.cornerRadius), style;
  }
  computeCenter(datum) {
    return {
      x: this._pieMark.getAttribute("x", datum, "normal"),
      y: this._pieMark.getAttribute("y", datum, "normal")
    };
  }
  getRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.outerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.outerRadius;
    return null != styleRadius ? styleRadius : this._outerRadius;
  }
  getInnerRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.innerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.innerRadius;
    return null != styleRadius ? styleRadius : this._innerRadius;
  }
  computeRadius(r, k2) {
    return this._computeLayoutRadius() * r * (isNil_default(k2) ? 1 : k2) + this._centerOffset;
  }
  computeDatumRadius(datum, state) {
    return this._computeLayoutRadius() * this.getRadius(state) + this._centerOffset;
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
      data: true
    };
    const defaultIgnoreKeys = ["centerX", "centerY", "centerOffset", "radius", "innerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle"];
    defaultIgnoreKeys.forEach((key) => {
      ignoreCheckKeys[key] = true;
    });
    const result2 = super._compareSpec(spec, prevSpec, ignoreCheckKeys);
    return spec = null != spec ? spec : {}, defaultIgnoreKeys.some((key) => spec[key] !== prevSpec[key]) && (result2.reRender = true, result2.change = true), result2;
  }
  computeDatumInnerRadius(datum, state) {
    return this._computeLayoutRadius() * this.getInnerRadius(state) + this._centerOffset;
  }
  dataToPosition(datum, checkInViewData) {
    const angle2 = datum[ARC_MIDDLE_ANGLE];
    if (isNil_default(angle2)) return null;
    if (checkInViewData && !this.isDatumInViewData(datum)) return null;
    const radius = this.computeDatumRadius(datum), center2 = this.computeCenter(datum);
    return polarToCartesian(center2, radius, angle2);
  }
  initAnimation() {
    var _a, _b, _c;
    const animationParams = {
      growFrom: (datum, element, state) => {
        var _a2;
        if (state === AnimationStateEnum.appear) return this._startAngle;
        if (state === AnimationStateEnum.disappear) return this._endAngle;
        const outState = [AnimationStateEnum.disappear, AnimationStateEnum.exit], markElements = element.mark.elements, data = datum, dataIndex = null == data ? void 0 : data[DEFAULT_DATA_INDEX];
        if (void 0 === markElements.find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        })) return this._startAngle;
        if (void 0 === markElements.find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) > dataIndex;
        })) return this._endAngle;
        const prevMarkElement = [...markElements].reverse().find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        });
        return outState.includes(state) ? null === (_a2 = null == prevMarkElement ? void 0 : prevMarkElement.getNextGraphicAttributes()) || void 0 === _a2 ? void 0 : _a2.endAngle : null == prevMarkElement ? void 0 : prevMarkElement.getGraphicAttribute("endAngle", true);
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._pieMark) {
      const pieAnimationConfig = animationConfig(null === (_b = Factory2.getAnimationInKey("pie")) || void 0 === _b ? void 0 : _b(animationParams, appearPreset), userAnimationConfig("pie", this._spec, this._markAttributeContext));
      pieAnimationConfig.normal && pieAnimationConfig.normal.type && (pieAnimationConfig.normal = centerOffsetConfig(this._pieMark, pieAnimationConfig.normal)), this._pieMark.setAnimationConfig(pieAnimationConfig);
    }
    if (this._emptyArcMark) {
      const pieAnimationConfig = animationConfig(null === (_c = Factory2.getAnimationInKey("emptyCircle")) || void 0 === _c ? void 0 : _c(animationParams, null != appearPreset ? appearPreset : "fadeIn"));
      this._emptyArcMark.setAnimationConfig(pieAnimationConfig);
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  getActiveMarks() {
    return [this._pieMark];
  }
};
BasePieSeries.transformerConstructor = PieSeriesSpecTransformer, BasePieSeries.mark = pieSeriesMark;
var PieSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie;
  }
};
PieSeries.type = SeriesTypeEnum.pie;
var registerPieSeries = () => {
  registerArcMark(), registerPieAnimation(), registerEmptyCircleAnimation(), Factory2.registerSeries(PieSeries.type, PieSeries);
};

// node_modules/@visactor/vchart/esm/mark/arc-3d.js
var Arc3dMark = class _Arc3dMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _Arc3dMark.type, this._support3d = true;
  }
};
Arc3dMark.type = "arc3d";
var registerArc3dMark = () => {
  registerVGrammarArcAnimation(), registerArc3dGraphic2(), Factory2.registerMark(Arc3dMark.type, Arc3dMark);
};

// node_modules/@visactor/vchart/esm/series/pie/3d/pie-3d-transformer.js
var Pie3dSeriesSpecTransformer = class extends PieSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie3d");
  }
};

// node_modules/@visactor/vchart/esm/series/pie/3d/pie-3d.js
var Pie3dSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie3d, this._pieMarkName = "pie3d", this._pieMarkType = "arc3d", this.transformerConstructor = Pie3dSeriesSpecTransformer;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._angle3d = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.angle3d) && void 0 !== _b ? _b : -Math.PI / 3;
  }
  initMarkStyle() {
    super.initMarkStyle();
    const pieMark = this._pieMark;
    pieMark && this.setMarkStyle(pieMark, {
      beta: () => this._angle3d
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(textMark, spec = {}) {
    textMark && (super.initLabelMarkStyle(textMark), this.setMarkStyle(textMark, {
      support3d: true
    }, void 0, AttributeLevel.Mark));
  }
};
Pie3dSeries.type = SeriesTypeEnum.pie3d, Pie3dSeries.mark = pie3dSeriesMark, Pie3dSeries.transformerConstructor = Pie3dSeriesSpecTransformer;
var registerPie3dSeries = () => {
  registerPie3dAnimation(), registerArc3dMark(), Factory2.registerSeries(Pie3dSeries.type, Pie3dSeries);
};

// node_modules/@visactor/vchart/esm/series/rose/animation.js
var Appear_Grow3 = (params2) => {
  const from = "angle" === params2.growField ? 0 : params2.innerRadius;
  return "angle" === params2.growField ? {
    type: "angle" === params2.growField ? "growAngleIn" : "growRadiusIn"
  } : {
    channel: {
      innerRadius: {
        from,
        to: (datum, element) => {
          var _a;
          return null === (_a = element.getFinalGraphicAttributes()) || void 0 === _a ? void 0 : _a.innerRadius;
        }
      },
      outerRadius: {
        from,
        to: (datum, element) => {
          var _a;
          return null === (_a = element.getFinalGraphicAttributes()) || void 0 === _a ? void 0 : _a.outerRadius;
        }
      }
    }
  };
};
var Appear_FadeIn6 = {
  type: "fadeIn"
};
var roseEnter = (params2) => ({
  type: "angle" === params2.growField ? "growAngleIn" : "growRadiusIn"
});
var roseExit = (params2) => ({
  type: "angle" === params2.growField ? "growAngleOut" : "growRadiusOut"
});
var roseDisappear = (params2) => ({
  type: "angle" === params2.growField ? "growAngleOut" : "growRadiusOut"
});
function rosePresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn6;
    case "growAngle":
      return Appear_Grow3(Object.assign(Object.assign({}, params2), {
        growField: "angle"
      }));
    default:
      return Appear_Grow3(Object.assign(Object.assign({}, params2), {
        growField: "radius"
      }));
  }
}
var registerRoseAnimation = () => {
  Factory2.registerAnimation("rose", (params2, preset) => ({
    appear: rosePresetAnimation(params2, preset),
    enter: roseEnter(params2),
    exit: roseExit(params2),
    disappear: roseDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/polar/rose-like/rose-like.js
var RoseLikeSeries = class extends PolarSeries {
  getStackGroupFields() {
    return this._angleField;
  }
  getStackValueField() {
    return array(this._spec.valueField)[0] || array(this._spec.radiusField)[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setAngleField(this._spec.categoryField || this._spec.angleField), this.setRadiusField(this._spec.valueField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice(), this.setInnerRadiusField(this._spec.valueField || this._spec.radiusField), this.getStack() && this.setValueFieldToStack(), this.getPercent() && this.setValueFieldToPercent();
  }
  setValueFieldToStack() {
    this.setRadiusField(STACK_FIELD_END), this.setInnerRadiusField(STACK_FIELD_START);
  }
  setValueFieldToPercent() {
    this.setRadiusField(STACK_FIELD_END_PERCENT), this.setInnerRadiusField(STACK_FIELD_START_PERCENT);
  }
  getDimensionField() {
    return this._specAngleField;
  }
  getMeasureField() {
    return this._specRadiusField;
  }
  getDefaultShapeType() {
    return "square";
  }
};

// node_modules/@visactor/vchart/esm/series/rose/constant.js
var roseSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  rose: {
    name: "rose",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/rose/rose-transformer.js
var RoseSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "rose");
  }
};

// node_modules/@visactor/vchart/esm/component/axis/polar/axis.js
var __rest24 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var PolarAxis = class extends AxisComponent {
  get center() {
    return this._center;
  }
  get startAngle() {
    return this._startAngle;
  }
  get endAngle() {
    return this._endAngle;
  }
  getOrient() {
    return this._orient;
  }
  getDefaultInteractive() {
    return "angle" !== this._orient;
  }
  getGroupScales() {
    return this._groupScales;
  }
  static getSpecInfo(chartSpec) {
    if (!chartSpec[this.specKey]) return null;
    const isArraySpec = isArray_default(chartSpec[this.specKey]), axesSpec = isArraySpec ? chartSpec[this.specKey] : [chartSpec[this.specKey]], specInfos = [];
    let angleAxisIndex, radiusAxisIndex;
    const radiusAxisSpecInfos = [], angleAxisSpecInfos = [];
    return axesSpec.forEach((s2, i) => {
      if (!isValidPolarAxis(s2)) return;
      const { axisType, componentName, startAngle, endAngle, center: center2, outerRadius, layoutRadius } = getPolarAxisInfo(s2, chartSpec);
      s2.center = center2, s2.startAngle = startAngle, s2.endAngle = endAngle, s2.outerRadius = outerRadius, s2.type = axisType, s2.layoutRadius = layoutRadius;
      const info = {
        spec: s2,
        specPath: isArraySpec ? [this.specKey, i] : [this.specKey],
        specInfoPath: ["component", this.specKey, i],
        type: componentName
      };
      specInfos.push(info), "radius" === s2.orient ? (radiusAxisSpecInfos.push(info), radiusAxisIndex = i) : (angleAxisSpecInfos.push(info), angleAxisIndex = i);
    }), radiusAxisSpecInfos.forEach((info) => {
      info.angleAxisIndex = angleAxisIndex;
    }), angleAxisSpecInfos.forEach((info) => {
      info.radiusAxisIndex = radiusAxisIndex;
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest24(specInfo, ["spec"]), C = Factory2.getComponentInKey(others.type);
    return C ? new C(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.polarAxis, this.name = ComponentTypeEnum.polarAxis, this._defaultBandPosition = 0, this._defaultBandInnerPadding = 0, this._defaultBandOuterPadding = 0, this.layoutType = "absolute", this.layoutZIndex = LayoutZIndex.Axis, this._tick = void 0, this._center = null, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._orient = "radius", this._groupScales = [], this.effect = {
      scaleUpdate: (param) => {
        this.computeData(null == param ? void 0 : param.value), eachSeries(this._regions, (s2) => {
          "radius" === this.getOrient() ? shouldUpdateAxis(s2.radiusAxisHelper, this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.radiusAxisHelper = this.axisHelper()) : shouldUpdateAxis(s2.angleAxisHelper, this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.angleAxisHelper = this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      var _a;
      const region = null === (_a = this.getRegions()) || void 0 === _a ? void 0 : _a[0];
      return region ? region.getLayoutStartPoint() : pos;
    }, this.getCenter = () => {
      var _a, _b;
      const layoutRect = this.getRefLayoutRect(), { width, height } = layoutRect;
      return {
        x: calcLayoutNumber(null === (_a = this._center) || void 0 === _a ? void 0 : _a.x, width, layoutRect, width / 2),
        y: calcLayoutNumber(null === (_b = this._center) || void 0 === _b ? void 0 : _b.y, height, layoutRect, height / 2)
      };
    }, this.getRefLayoutRect = () => this.getRegions()[0].getLayoutRect(), this._coordinateType = "polar";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.visible && (this._axisStyle = this._getAxisAttributes(), this._gridStyle = this._getGridAttributes()), this._tick = this._spec.tick, this._orient = "angle" === this._spec.orient ? "angle" : "radius", this._center = this._spec.center, this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), this._inverse = this._spec.inverse;
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _tickTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._tickTransformOption()), {
      noDecimal: null === (_a = this._tick) || void 0 === _a ? void 0 : _a.noDecimals,
      startAngle: this.startAngle,
      labelOffset: getAxisLabelOffset(this._spec),
      getRadius: () => this.getOuterRadius(),
      inside: this._spec.inside
    });
  }
  updateScaleRange() {
    const prevRange = this._scale.range();
    let newRange;
    return newRange = "radius" === this.getOrient() ? this._inverse ? [this.computeLayoutOuterRadius(), this.computeLayoutInnerRadius()] : [this.computeLayoutInnerRadius(), this.computeLayoutOuterRadius()] : this._inverse ? [this._endAngle, this._startAngle] : [this._startAngle, this._endAngle], (!prevRange || !newRange || prevRange[0] !== newRange[0] || prevRange[1] !== newRange[1]) && (this._scale.range(newRange), true);
  }
  collectSeriesField(depth, series2) {
    var _a, _b;
    let field5;
    return field5 = depth > 0 ? null === (_b = null === (_a = series2.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : "radius" === this.getOrient() ? series2.getRadiusField() : series2.getAngleField(), field5;
  }
  updateSeriesScale() {
    eachSeries(this._regions, (s2) => {
      "radius" === this.getOrient() ? shouldUpdateAxis(s2.radiusAxisHelper, this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.setRadiusScale(this._scale), s2.radiusAxisHelper = this.axisHelper()) : shouldUpdateAxis(s2.angleAxisHelper, this.axisHelper(), isValid_default(this._seriesUserId) || isValid_default(this._seriesIndex)) && (s2.setAngleScale(this._scale), s2.angleAxisHelper = this.axisHelper());
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getSeriesStatisticsField(s2) {
    const f = "radius" === this.getOrient() ? s2.getRadiusField() : s2.getAngleField();
    return isContinuous(this._scale.type) ? f : [f[0]];
  }
  initGroupScales() {
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      coordToPoint: this.coordToPoint.bind(this),
      pointToCoord: this.pointToCoord.bind(this),
      center: this.getCenter.bind(this),
      layoutRadius: this._computeLayoutRadius.bind(this),
      getScale: (depth = 0) => this._scales[depth],
      getAxisId: () => this.id,
      getSpec: () => this._spec
    };
  }
  positionToData(position) {
    const coord = this.pointToCoord(position);
    return "radius" === this.getOrient() ? this.invert(coord.radius) : this.invert(coord.angle);
  }
  coordToPoint(point6) {
    const center2 = this.getCenter();
    return polarToCartesian(center2, point6.radius, point6.angle);
  }
  pointToCoord(point6) {
    const center2 = this.getCenter(), startAngle = this._startAngle, endAngle = this._endAngle;
    return cartesianToPolar(point6, center2, startAngle, endAngle);
  }
  getOuterRadius() {
    return this.computeLayoutOuterRadius();
  }
  getInnerRadius() {
    return this.computeLayoutInnerRadius();
  }
  updateLayoutAttribute() {
    this._visible && ("radius" === this.getOrient() ? this._layoutRadiusAxis() : this._layoutAngleAxis()), super.updateLayoutAttribute();
  }
  _getNormalizedValue(values, length2) {
    return 0 === length2 ? 0 : (this.dataToPosition(values) - this._getStartValue()) / length2;
  }
  getLabelItems(length2) {
    var _a;
    const tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    return tickLatestData && tickLatestData.length ? [tickLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2)))] : [];
  }
  _getStartValue() {
    return "radius" === this.getOrient() ? this.computeLayoutInnerRadius() : this._startAngle;
  }
  _layoutAngleAxis() {
    var _a, _b, _c;
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), angleRange = this._endAngle - this._startAngle, items = this.getLabelItems(angleRange), commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      inside: this._spec.inside,
      center: center2,
      radius,
      innerRadius,
      startAngle: this._startAngle,
      endAngle: this._endAngle,
      sides: (null === (_c = null === (_b = null === (_a = this._getRelatedAxis(this._option.radiusAxisIndex)) || void 0 === _a ? void 0 : _a.getSpec()) || void 0 === _b ? void 0 : _b.grid) || void 0 === _c ? void 0 : _c.smooth) ? void 0 : this.getScale().domain().length
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      size: this.getRefLayoutRect(),
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items,
      orient: "angle"
    });
    this._spec.grid.visible && (attrs.grid = Object.assign({
      type: "line",
      smoothLink: true,
      items: items[0]
    }, commonAttrs)), this._update(attrs);
  }
  _layoutRadiusAxis() {
    var _a, _b, _c;
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), endPoint = this.coordToPoint({
      angle: this._startAngle,
      radius
    }), startPoint = this.coordToPoint({
      angle: this._startAngle,
      radius: innerRadius
    }), distance2 = PointService.distancePP(startPoint, endPoint), items = this.getLabelItems(distance2), commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      start: startPoint,
      end: endPoint,
      verticalFactor: -1
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items,
      orient: "radius"
    });
    (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) && (attrs.grid = Object.assign({
      items: items[0],
      type: (null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.smooth) ? "circle" : "polygon",
      center: center2,
      closed: true,
      sides: null === (_c = this._getRelatedAxis(this._option.angleAxisIndex)) || void 0 === _c ? void 0 : _c.getScale().domain().length,
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }, commonAttrs)), this._update(attrs);
  }
  _getRelatedAxis(index) {
    if (isValid_default(index)) return this._option.getComponentByIndex(this.specKey, index);
  }
  _computeLayoutRadius() {
    return computeLayoutRadius(() => this._spec.layoutRadius, this.getRefLayoutRect, this.getCenter, () => ({
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }));
  }
  computeLayoutOuterRadius() {
    var _a;
    const radius = null !== (_a = this._spec.outerRadius) && void 0 !== _a ? _a : this._spec.radius, outerRadius = null != radius ? radius : this.getRefSeriesRadius().outerRadius;
    return this._computeLayoutRadius() * outerRadius;
  }
  computeLayoutInnerRadius() {
    var _a;
    const innerRadius = null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : this.getRefSeriesRadius().innerRadius;
    return this._computeLayoutRadius() * innerRadius;
  }
  getRefSeriesRadius() {
    let outerRadius = POLAR_DEFAULT_RADIUS, innerRadius = 0;
    const chartSpec = this.getChart().getSpec();
    return eachSeries(this.getRegions(), (s2) => {
      const series2 = s2;
      if (isPolarAxisSeries(series2.type)) {
        const { outerRadius: seriesRadius = chartSpec.outerRadius, innerRadius: seriesInnerRadius = chartSpec.innerRadius } = series2;
        isValidNumber_default(seriesRadius) && (outerRadius = seriesRadius), isValidNumber_default(seriesInnerRadius) && (innerRadius = seriesInnerRadius);
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), {
      outerRadius,
      innerRadius
    };
  }
  _update(attrs) {
    const { grid: gridAttrs } = attrs, axisAttrs = __rest24(attrs, ["grid"]);
    if (this._axisMark.getProduct().encode(mergeSpec({}, this._axisStyle, axisAttrs)), this._gridMark) {
      this._gridMark.getProduct().encode(mergeSpec({}, this._gridStyle, gridAttrs));
    }
  }
  invert(value) {
    var _a;
    if ("angle" === this.getOrient() && "band" === this._scale.type) {
      const range2 = this._scale.range(), rangeValue = range2[range2.length - 1] - range2[0], offset = 0.5 === (null !== (_a = this.getSpec().bandPosition) && void 0 !== _a ? _a : this._defaultBandPosition) ? 0 : this._scale.bandwidth() / 2;
      if (range2[0] < 0) {
        const transformedAngle = (value + offset + Math.abs(range2[0])) % rangeValue - Math.abs(range2[0]);
        return this._scale.invert(transformedAngle);
      }
      return this._scale.invert((value + offset) % rangeValue);
    }
    return this._scale.invert(value);
  }
};
PolarAxis.type = ComponentTypeEnum.polarAxis, PolarAxis.specKey = "axes";

// node_modules/@visactor/vchart/esm/component/axis/polar/linear-axis.js
var PolarLinearAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarLinearAxis, this._zero = true, this._nice = true, this._extend = {}, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
  }
  initScales() {
    super.initScales(), this.setScaleNice();
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  axisHelper() {
    const helper = super.axisHelper();
    return helper.setExtendDomain = this.setExtendDomain.bind(this), helper;
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), name;
  }
};
PolarLinearAxis.type = ComponentTypeEnum.polarLinearAxis, PolarLinearAxis.specKey = "axes", mixin(PolarLinearAxis, LinearAxisMixin);
var registerPolarLinearAxis = () => {
  registerLineAxis(), registerLineGrid(), registerCircleAxis(), registerCircleGrid(), registerAxis2(), Factory2.registerComponent(PolarLinearAxis.type, PolarLinearAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/polar/band-axis.js
var PolarBandAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  axisHelper() {
    const helper = super.axisHelper();
    return Object.assign(Object.assign({}, helper), {
      getBandwidth: (depth) => helper.getScale(depth).bandwidth()
    });
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  registerTicksTransform() {
    const name = `${this.type}-ticks`;
    return registerDataSetInstanceTransform(this._option.dataSet, name, polarAngleAxisDiscreteTicks), name;
  }
  transformScaleDomain() {
  }
};
PolarBandAxis.type = ComponentTypeEnum.polarBandAxis, PolarBandAxis.specKey = "axes", mixin(PolarBandAxis, BandAxisMixin);
var registerPolarBandAxis = () => {
  registerLineAxis(), registerLineGrid(), registerCircleAxis(), registerCircleGrid(), registerAxis2(), Factory2.registerComponent(PolarBandAxis.type, PolarBandAxis);
};

// node_modules/@visactor/vchart/esm/series/rose/rose.js
var RoseSeries = class _RoseSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rose, this.transformerConstructor = RoseSeriesSpecTransformer, this._roseMark = null, this._labelMark = null;
  }
  initMark() {
    this.initRoseMark();
  }
  initMarkStyle() {
    this.initRoseMarkStyle();
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  initRoseMark() {
    var _a, _b;
    this._roseMark = this._createMark(_RoseSeries.mark.rose, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.rose) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.rose) || void 0 === _b ? void 0 : _b.customShape,
      morph: shouldMarkDoMorph(this._spec, _RoseSeries.mark.rose.name),
      morphElementKey: this.getDimensionField()[0]
    });
  }
  getRoseAngle() {
    var _a, _b, _c;
    return null !== (_c = null === (_b = (_a = this.angleAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _c ? _c : 0.5;
  }
  startAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  endAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + this.getRoseAngle() - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  initRoseMarkStyle() {
    const roseMark = this._roseMark;
    roseMark && this.setMarkStyle(roseMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      fill: this.getColorAttribute(),
      outerRadius: (datum) => valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]), this.radiusAxisHelper.getScale(0)),
      innerRadius: (datum) => {
        var _a;
        if (!this.getStack()) return 0;
        const stackStart = valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._innerRadiusField[0]]]), this.radiusAxisHelper.getScale(0));
        return stackStart <= Number.MIN_VALUE ? this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0) : stackStart;
      }
    });
  }
  initTooltip() {
    super.initTooltip(), this._roseMark && this._tooltipHelper.activeTriggerSet.mark.add(this._roseMark);
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: this.getColorAttribute(),
      z: 0
    });
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._roseMark) {
      const animationParams = {
        innerRadius: () => {
          var _a2;
          return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
        }
      };
      this._roseMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rose")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("rose", this._spec, this._markAttributeContext)));
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._roseMark];
  }
};
RoseSeries.type = SeriesTypeEnum.rose, RoseSeries.mark = roseSeriesMark, RoseSeries.transformerConstructor = RoseSeriesSpecTransformer;
var registerRoseSeries = () => {
  Factory2.registerSeries(RoseSeries.type, RoseSeries), registerArcMark(), registerRoseAnimation(), registerPolarBandAxis(), registerPolarLinearAxis();
};

// node_modules/@visactor/vchart/esm/series/polar/animation.js
var PolarPointUpdate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this._center = to.center, this._prevCenter = from.center, this._center && this._prevCenter || (this.valid = false);
  }
  getEndProps() {
    return false === this.valid ? {} : polarToCartesian(this._center, this._toRadius, this._toAngle);
  }
  onBind() {
    const { angle: fromAngle, radius: fromRadius } = cartesianToPolar(this.from, this._prevCenter), { angle: toAngle, radius: toRadius } = cartesianToPolar(this.to, this._center);
    isValidNumber_default(toAngle * toRadius) || (this.valid = false), this._fromAngle = isValidNumber_default(fromAngle) ? fromAngle : toAngle, this._fromRadius = isValidNumber_default(fromRadius) ? fromRadius : toRadius, this._toAngle = toAngle, this._toRadius = toRadius, isClose(this._fromAngle, this._toAngle) && isClose(this._fromRadius, this._toRadius) && (this.valid = false);
  }
  onUpdate(end, ratio, out) {
    if (false === this.valid) return out.x = this.to.x, void (out.y = this.to.y);
    if (end) {
      const { x, y } = this.getEndProps();
      out.x = x, out.y = y, out.center = this._center;
    } else {
      const { x, y } = polarToCartesian({
        x: this._prevCenter.x + (this._center.x - this._prevCenter.x) * ratio,
        y: this._prevCenter.y + (this._center.y - this._prevCenter.y) * ratio
      }, this._fromRadius + (this._toRadius - this._fromRadius) * ratio, this._fromAngle + (this._toAngle - this._fromAngle) * ratio);
      out.x = x, out.y = y;
    }
  }
};
var PolarTagPointsUpdate = class extends TagPointsUpdate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this._center = to.center, this._prevCenter = from.center;
  }
  onUpdate(end, ratio, out) {
    this.points = this.points.map((point6, index) => {
      const newPoint = this.polarPointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return end && (out.center = this._center), newPoint.context = point6.context, newPoint;
    }), out.points = this.points;
  }
  _interpolationSinglePoint(pointA, pointB, ratio) {
    if (!isValidPoint(pointA) && !isValidPoint(pointB)) return pointB;
    const polarPointA = cartesianToPolar(pointA, this._prevCenter), polarPointB = cartesianToPolar(pointB, this._center);
    let angleA = normalizeAngle(polarPointA.angle), angleB = normalizeAngle(polarPointB.angle);
    !isValidNumber_default(angleA) && isValidNumber_default(angleB) && (angleA = angleB), isValidNumber_default(angleA) && !isValidNumber_default(angleB) && (angleB = angleA);
    const angle2 = angleA + (angleB - angleA) * ratio, radius = polarPointA.radius + (polarPointB.radius - polarPointA.radius) * ratio;
    return polarToCartesian({
      x: this._prevCenter.x + (this._center.x - this._prevCenter.x) * ratio,
      y: this._prevCenter.y + (this._center.y - this._prevCenter.y) * ratio
    }, radius, angle2);
  }
  polarPointInterpolation(pointA, pointB, ratio) {
    const { x, y } = this._interpolationSinglePoint(pointA, pointB, ratio), { x: x1, y: y1 } = this._interpolationSinglePoint({
      x: pointA.x1,
      y: pointA.y1
    }, {
      x: pointB.x1,
      y: pointB.y1
    }, ratio), point6 = new Point(x, y, x1, y1);
    return point6.defined = pointB.defined, point6;
  }
};

// node_modules/@visactor/vchart/esm/series/radar/animation.js
var radarFadeAnimation = (animationType) => ({
  type: "in" === animationType ? "fadeIn" : "fadeOut"
});
var radarGrowAnimation = (params2, animationType) => ({
  type: "in" === animationType ? "growPointsIn" : "growPointsOut",
  options: () => ({
    center: params2.center()
  })
});
function radarPresetAnimation(params2, preset, animationType) {
  return "fadeIn" === preset ? radarFadeAnimation(animationType) : radarGrowAnimation(params2, animationType);
}
var radarSymbolMoveAnimation = (params2, animationType) => {
  const xFrom = () => {
    var _a;
    return null === (_a = params2.center()) || void 0 === _a ? void 0 : _a.x;
  }, xTo = (datum, element) => element.getGraphicAttribute("x"), yFrom = () => {
    var _a;
    return null === (_a = params2.center()) || void 0 === _a ? void 0 : _a.y;
  }, yTo = (datum, element) => element.getGraphicAttribute("y");
  return "in" === animationType ? {
    channel: {
      x: {
        from: xFrom,
        to: xTo
      },
      y: {
        from: yFrom,
        to: yTo
      }
    }
  } : {
    channel: {
      x: {
        from: xTo,
        to: xFrom
      },
      y: {
        from: yTo,
        to: yFrom
      }
    }
  };
};
function radarSymbolPresetAnimation(params2, preset, animationType) {
  return "fadeIn" === preset ? radarFadeAnimation(animationType) : radarSymbolMoveAnimation(params2, animationType);
}
var radarGroupClipAnimation = (params2, animationType) => ({
  custom: ClipAngleAnimate,
  customParameters: (datum, element) => {
    var _a;
    return {
      group: element.getGraphicItem(),
      startAngle: null !== (_a = params2.startAngle) && void 0 !== _a ? _a : Math.PI / 2,
      orient: "clockwise",
      center: params2.center(),
      radius: params2.radius(),
      animationType
    };
  }
});
var registerRadarAnimation = () => {
  Factory2.registerAnimation("radar", (params2, preset) => ({
    appear: "clipIn" === preset ? void 0 : radarPresetAnimation(params2, preset, "in"),
    enter: radarPresetAnimation(params2, preset, "in"),
    exit: radarPresetAnimation(params2, preset, "out"),
    disappear: "clipIn" === preset ? void 0 : radarPresetAnimation(params2, preset, "out"),
    update: [{
      options: {
        excludeChannels: ["points", "defined", "center"]
      }
    }, {
      channel: ["points", "center"],
      custom: PolarTagPointsUpdate,
      customParameters: params2,
      duration: DEFAULT_ANIMATION_CONFIG.update.duration,
      easing: DEFAULT_ANIMATION_CONFIG.update.easing
    }]
  })), Factory2.registerAnimation("radarSymbol", (params2, preset) => ({
    appear: "clipIn" === preset ? void 0 : radarSymbolPresetAnimation(params2, preset, "in"),
    enter: {
      type: "scaleIn"
    },
    exit: {
      type: "scaleOut"
    },
    disappear: "clipIn" === preset ? void 0 : radarSymbolPresetAnimation(params2, preset, "out"),
    update: [{
      options: {
        excludeChannels: ["x", "y", "center"]
      }
    }, {
      channel: ["x", "y", "center"],
      custom: PolarPointUpdate,
      customParameters: params2,
      duration: DEFAULT_ANIMATION_CONFIG.update.duration,
      easing: DEFAULT_ANIMATION_CONFIG.update.easing
    }]
  })), Factory2.registerAnimation("radarGroup", (params2, preset) => ({
    appear: radarGroupClipAnimation(params2, "in"),
    disappear: radarGroupClipAnimation(params2, "out")
  })), registerArc();
};

// node_modules/@visactor/vchart/esm/series/radar/constant.js
var radarSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// node_modules/@visactor/vchart/esm/series/radar/radar.js
var RadarSeries = class _RadarSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.radar, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  initGroups() {
  }
  compile() {
    super.compile(), this.addOverlapCompile();
  }
  initMark() {
    var _a, _b, _c, _d;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, isAreaVisible = false !== (null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible), seriesMark = null !== (_d = this._spec.seriesMark) && void 0 !== _d ? _d : "area";
    this.initAreaMark(progressive, isAreaVisible && "area" === seriesMark), this.initLineMark(progressive, "line" === seriesMark || "area" === seriesMark && !isAreaVisible), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    this.initAreaMarkStyle(), this.initLineMarkStyle(), this.initSymbolMarkStyle(), [this._lineMark, this._symbolMark, this._areaMark].forEach((mark) => {
      mark && this.setMarkStyle(mark, {
        center: () => {
          var _a;
          return null === (_a = this.angleAxisHelper) || void 0 === _a ? void 0 : _a.center();
        }
      });
    });
  }
  initAreaMark(progressive, isSeriesMark) {
    var _a, _b;
    this._areaMark = this._createMark(_RadarSeries.mark.area, {
      groupKey: this._seriesField,
      isSeriesMark,
      stateSort: null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      setCustomizedShape: null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.customShape
    }));
  }
  initAreaMarkStyle() {
    const areaMark = this._areaMark;
    areaMark && (this.setMarkStyle(areaMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: (datum) => datum && this.angleAxisHelper && this.radiusAxisHelper ? this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getStack() ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).x : Number.NaN,
      y1: (datum) => {
        if (!datum || !this.angleAxisHelper || !this.radiusAxisHelper) return Number.NaN;
        return this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getStack() ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).y;
      },
      fill: this.getColorAttribute(),
      curveType: DEFAULT_LINEAR_INTERPOLATE,
      closePath: true
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined.bind(this),
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(areaMark, "defined");
    }));
  }
  initTooltip() {
    super.initTooltip();
    const { group, mark } = this._tooltipHelper.activeTriggerSet;
    this._lineMark && group.add(this._lineMark), this._areaMark && group.add(this._areaMark), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      center: () => {
        var _a2;
        return null === (_a2 = this.angleAxisHelper) || void 0 === _a2 ? void 0 : _a2.center();
      },
      radius: () => {
        const rect = this.getLayoutRect();
        return Math.min(rect.width, rect.height);
      },
      startAngle: isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : POLAR_START_RADIAN
    }, appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("radarGroup")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext)));
    [[this._areaMark, "radar"], [this._lineMark, "radar"], [this._symbolMark, "radarSymbol"]].forEach(([mark, animation]) => {
      if (isValid_default(mark)) {
        const getAnimation = Factory2.getAnimationInKey(animation);
        mark.setAnimationConfig(animationConfig(null == getAnimation ? void 0 : getAnimation(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
      }
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d;
      let result2 = null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
      return "fill" !== attribute || result2 || (attribute = "stroke", result2 = null !== (_d = null === (_c = this._seriesMark) || void 0 === _c ? void 0 : _c.getAttribute(attribute, datum)) && void 0 !== _d ? _d : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
RadarSeries.type = SeriesTypeEnum.radar, RadarSeries.mark = radarSeriesMark, RadarSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(RadarSeries, LineLikeSeriesMixin);
var registerRadarSeries = () => {
  Factory2.registerSeries(RadarSeries.type, RadarSeries), registerAreaMark(), registerLineMark(), registerSymbolMark(), registerRadarAnimation(), registerPolarBandAxis(), registerPolarLinearAxis();
};

// node_modules/@visactor/vchart/esm/series/dot/tooltip-helper.js
var DotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.shapeTypeCallback = () => "square";
  }
  enableByType(activeType) {
    return "mark" === activeType;
  }
  getDefaultTitlePattern(activeType) {
    return {
      key: "event info",
      value: "event info"
    };
  }
  getDefaultContentList() {
    return [{
      key: (datum) => datum.type,
      value: (datum) => datum.id
    }, {
      key: "event_time",
      value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d", datum.event_time)
    }, {
      key: "action_type",
      value: (datum) => datum.action_type
    }, {
      key: "children",
      value: (datum) => datum.children
    }];
  }
  getTooltipData(activeType, chartTooltipSpec, data, datum, params2) {
    var _a, _b, _c, _d;
    const res = super.getTooltipData(activeType, chartTooltipSpec, data, datum, params2), userUpdateContent = null !== (_c = null === (_b = null === (_a = this.spec) || void 0 === _a ? void 0 : _a[activeType]) || void 0 === _b ? void 0 : _b.updateContent) && void 0 !== _c ? _c : null === (_d = null == chartTooltipSpec ? void 0 : chartTooltipSpec[activeType]) || void 0 === _d ? void 0 : _d.updateContent;
    return res && !userUpdateContent && (res.updateContent = (prev, datum2, params3) => {
      const childrenContent = [], childrenPrev = prev.filter((p) => "children" === p.key);
      return childrenPrev.length > 0 && childrenPrev[0].value.forEach((element) => {
        let flag = true;
        for (const key in element) childrenContent.push(Object.assign(Object.assign({}, childrenPrev[0]), {
          shapeType: "circle",
          hasShape: flag,
          key,
          value: element[key] + ""
        })), flag = false;
      }), prev.concat(childrenContent);
    }), res;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/obj-flat.js
var objFlat = (data, op) => {
  var _a;
  const dataCollect = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data || [], result2 = [];
  return dataCollect.forEach((datum) => {
    const dataKey = {};
    for (const key in datum) key !== op && (dataKey[key] = datum[key]);
    const dataOp = datum[op];
    null == dataOp || dataOp.forEach((d) => {
      result2.push(Object.assign({}, dataKey, d));
    });
  }), result2;
};

// node_modules/@visactor/vchart/esm/series/dot/config.js
var DEFAULT_GRID_BACKGROUND = {
  fill: "#bbb",
  fillOpacity: 0.2
};

// node_modules/@visactor/vchart/esm/series/dot/constant.js
var dotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  grid: {
    name: "grid",
    type: "rule"
  },
  gridBackground: {
    name: "gridBackground",
    type: "rect"
  },
  dot: {
    name: "dot",
    type: "symbol"
  },
  title: {
    name: "title",
    type: "text"
  },
  subTitle: {
    name: "subTitle",
    type: "text"
  },
  symbol: {
    name: "symbol",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/dot/dot.js
var DotSeries = class _DotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.dot;
  }
  getSeriesGroupField() {
    return this._seriesField;
  }
  setSeriesGroupField(field5) {
    isValid_default(field5) && (this._seriesGroupField = field5);
  }
  getTitleField() {
    return this._titleField;
  }
  setTitleField(field5) {
    isValid_default(field5) && (this._titleField = field5);
  }
  getSubTitleField() {
    return this._subTitleField;
  }
  setSubTitleField(field5) {
    isValid_default(field5) && (this._subTitleField = field5);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field5) {
    isValid_default(field5) && (this._dotTypeField = field5);
  }
  getHighLightSeriesGroup() {
    return this._highLightSeriesGroup;
  }
  setHighLightSeriesGroup(field5) {
    isValid_default(field5) && (this._highLightSeriesGroup = field5);
  }
  setGridBackground(gridBackground) {
    isValid_default(gridBackground) && (this._gridBackground = gridBackground);
  }
  initData() {
    var _a;
    super.initData(), this._xDimensionStatisticsDomain = this.getRawData().latestData.map((d) => d[this._fieldY[0]]), registerDataSetInstanceTransform(this._option.dataSet, "objFlat", objFlat), registerDataSetInstanceTransform(this._option.dataSet, "copyDataView", copyDataView), registerDataSetInstanceParser(this._option.dataSet, "dataview", dataViewParser), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "objFlat",
      options: "dots",
      level: TransformLevel.dotObjFlat
    }, false);
  }
  getStatisticFields() {
    return [{
      key: this._fieldY[0],
      operations: ["values"],
      customize: this._xDimensionStatisticsDomain
    }];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setSeriesGroupField(this._spec.seriesGroupField), this.setTitleField(this._spec.titleField), this.setSubTitleField(this._spec.subTitleField), this.setDotTypeField(this._spec.dotTypeField), this.setHighLightSeriesGroup(this._spec.highLightSeriesGroup), this.setGridBackground(mergeSpec(DEFAULT_GRID_BACKGROUND, (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.background) || {}));
  }
  initMark() {
    this._clipMark = this._createMark(_DotSeries.mark.group), this._containerMark = this._createMark(_DotSeries.mark.group, {
      parent: this._clipMark,
      dataView: this.getRawData()
    }), this._gridBackgroundMark = this._createMark(_DotSeries.mark.gridBackground, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._gridMark = this._createMark(_DotSeries.mark.grid, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._dotMark = this._createMark(_DotSeries.mark.dot, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    }), this._titleMark = this._createMark(_DotSeries.mark.title, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._subTitleMark = this._createMark(_DotSeries.mark.subTitle, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._symbolMark = this._createMark(_DotSeries.mark.symbol, {
      parent: this._containerMark,
      dataView: this.getRawData()
    });
  }
  initMarkStyle() {
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight
    }, "normal", AttributeLevel.Series), clipMark.setMarkConfig({
      interactive: false,
      clip: true
    }));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding
    }, "normal", AttributeLevel.Series), containerMark.setMarkConfig({
      interactive: false
    }));
    const gridBackgroundMark = this._gridBackgroundMark;
    gridBackgroundMark && this.setMarkStyle(gridBackgroundMark, {
      x: this.getRegionRectLeft.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y: this.dataToGridBackgroundPositionY.bind(this),
      y1: this.dataToGridBackgroundPositionY1.bind(this),
      fill: this._gridBackground.fill,
      fillOpacity: this.dataToGridBackgroundOpacity.bind(this)
    }, "normal", AttributeLevel.Series);
    const gridMark = this._gridMark;
    gridMark && this.setMarkStyle(gridMark, {
      stroke: this.getColorAttribute(),
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y1: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series);
    const dotMark = this._dotMark;
    dotMark && this.setMarkStyle(dotMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getDotColorAttribute(),
      fillOpacity: this.dataToOpacity.bind(this)
    }, "normal", AttributeLevel.Series);
    const titleMark = this._titleMark;
    titleMark && this.setMarkStyle(titleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series);
    const subTitleMark = this._subTitleMark;
    subTitleMark && this.setMarkStyle(subTitleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getSubTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series);
    const symbolMark = this._symbolMark;
    symbolMark && this.setMarkStyle(symbolMark, {
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
  }
  dataToGridBackgroundPositionY(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) - getBandwidth(0) / 2;
  }
  dataToGridBackgroundPositionY1(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) + getBandwidth(0) / 2;
  }
  dataToOpacity(datum) {
    var _a, _b, _c, _d;
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1] ? 0 : null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.dot) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.fillOpacity) && void 0 !== _d ? _d : 1;
  }
  dataToGridBackgroundOpacity(datum) {
    return datum[this._seriesGroupField] === this._highLightSeriesGroup ? this._gridBackground.fillOpacity : 0;
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    super.onLayoutEnd(ctx);
    const layoutOffsetX = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.leftAppendPadding) && void 0 !== _b ? _b : 0;
    this.setMarkStyle(this._clipMark, {
      width: this.getLayoutRect().width + layoutOffsetX
    }, "normal", AttributeLevel.Series);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesGroupField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesGroupField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._seriesGroupField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
    };
  }
  getDotColorScale() {
    var _a, _b, _c;
    const colorDomain = this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesGroupField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesGroupField].values : this._seriesField ? null === (_c = this.getViewDataStatistics()) || void 0 === _c ? void 0 : _c.latestData[this._seriesField].values : [], colorRange = this._getDataScheme();
    return new ColorOrdinalScale().domain(colorDomain).range(colorRange);
  }
  getDotColorAttribute() {
    var _a, _b, _c, _d;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this.getDotColorScale(),
      field: null !== (_d = null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesGroupField) && void 0 !== _c ? _c : this._seriesField) && void 0 !== _d ? _d : DEFAULT_DATA_SERIES_FIELD
    };
  }
  initTooltip() {
    this._tooltipHelper = new DotSeriesTooltipHelper(this), this._dotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._dotMark);
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m4) => {
      "group" === m4.type ? this.onMarkTreePositionUpdate(m4.getMarks()) : m4.updateLayoutState();
    });
  }
  getDotData() {
    var _a;
    return null === (_a = this._dotMark) || void 0 === _a ? void 0 : _a.getData();
  }
  _getDataIdKey() {
  }
  getStackValueField() {
    return null;
  }
  getActiveMarks() {
    return [this._dotMark];
  }
};
DotSeries.type = SeriesTypeEnum.dot, DotSeries.mark = dotSeriesMark;
var registerDotSeries = () => {
  registerSymbolMark(), registerRuleMark(), registerRectMark(), registerTextMark(), Factory2.registerSeries(DotSeries.type, DotSeries);
};

// node_modules/@visactor/vchart/esm/series/link/tooltip-helper.js
var LinkSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.shapeTypeCallback = () => "square";
  }
  enableByType(activeType) {
    return "mark" === activeType;
  }
  getDefaultTitlePattern(activeType) {
    return {
      key: "link info",
      value: "link info"
    };
  }
  getDefaultContentList() {
    return [{
      key: "time",
      value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d %H:%M", datum.from.split("_")[1])
    }, {
      key: "type",
      value: (datum) => datum.action_type
    }, {
      key: "from",
      value: (datum) => datum.from
    }, {
      key: "to",
      value: (datum) => datum.to
    }];
  }
};

// node_modules/@visactor/vchart/esm/series/link/constant.js
var linkSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  link: {
    name: "link",
    type: "rule"
  },
  arrow: {
    name: "arrow",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/data/transforms/link-dot-info.js
var linkDotInfo = (data, op) => {
  const { infoKey, fields: fields2, linkData, dotData } = op, { fromField, toField, xField, yField } = fields2(), dataLinkObj = linkData(), dataDotObj = dotData(), dataLinkDotHash = {};
  return dataDotObj.forEach((datum) => {
    const dataCopy = {};
    for (const key in datum) key !== infoKey && (dataCopy[key] = datum[key]);
    const dataOp = datum[infoKey];
    null == dataOp || dataOp.forEach((d) => {
      dataLinkDotHash[d.node_name] = Object.assign({}, dataCopy, d);
    });
  }), dataLinkObj.forEach((datum) => {
    var _a, _b, _c, _d;
    datum[fromField + "_xField"] = null === (_a = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _a ? void 0 : _a[xField], datum[fromField + "_yField"] = null === (_b = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _b ? void 0 : _b[yField], datum[toField + "_xField"] = null === (_c = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _c ? void 0 : _c[xField], datum[toField + "_yField"] = null === (_d = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _d ? void 0 : _d[yField];
  }), dataLinkObj;
};

// node_modules/@visactor/vchart/esm/series/link/link.js
var LinkSeries = class _LinkSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.link;
  }
  getFromField() {
    return this._fromField;
  }
  setFromField(field5) {
    isValid_default(field5) && (this._fromField = field5);
  }
  getToField() {
    return this._toField;
  }
  setToField(field5) {
    isValid_default(field5) && (this._toField = field5);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field5) {
    isValid_default(field5) && (this._dotTypeField = field5);
  }
  getDotSeriesSpec() {
    return this._dotSeriesSpec;
  }
  setDotSeriesSpec(spec) {
    isValid_default(spec) && (this._dotSeriesSpec = spec);
  }
  _getDotData() {
    const dotSeries = this._option.getChart().getSeriesInIndex([this._spec.dotSeriesIndex])[0];
    return dotSeries ? dotSeries.getRawData().latestData : [];
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._option.dataSet, "linkDotInfo", linkDotInfo), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "linkDotInfo",
      options: {
        infoKey: "dots",
        fields: () => ({
          fromField: this._fromField,
          toField: this._toField,
          xField: this._dotSeriesSpec.xField,
          yField: this._dotSeriesSpec.yField
        }),
        linkData: () => this._rawData.latestData,
        dotData: () => this._getDotData()
      },
      level: TransformLevel.linkDotInfo
    }, false);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFromField(this._spec.fromField), this.setToField(this._spec.toField), this.setDotTypeField(this._spec.dotTypeField), this.setDotSeriesSpec(this._spec.dotSeriesSpec);
  }
  initMark() {
    this._clipMark = this._createMark(_LinkSeries.mark.group), this._containerMark = this._createMark(_LinkSeries.mark.group, {
      parent: this._clipMark
    }), this._linkMark = this._createMark(_LinkSeries.mark.link, {
      skipBeforeLayouted: false,
      parent: this._containerMark
    }), this._arrowMark = this._createMark(_LinkSeries.mark.arrow, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d;
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight
    }, "normal", AttributeLevel.Series), clipMark.setMarkConfig({
      interactive: false,
      clip: true
    }));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding,
      width: this.getLayoutRect().width
    }, "normal", AttributeLevel.Series), containerMark.setMarkConfig({
      interactive: false
    }));
    const linkMark = this._linkMark;
    linkMark && this.setMarkStyle(linkMark, {
      stroke: this.getColorAttribute(),
      strokeOpacity: this.dataToOpacity.bind(this),
      x: this.dataToPositionXFrom.bind(this),
      y: this.dataToPositionYFrom.bind(this),
      x1: this.dataToPositionXTo.bind(this),
      y1: this.dataToPositionYTo.bind(this)
    }, "normal", AttributeLevel.Series);
    const arrowMark = this._arrowMark;
    if (arrowMark) {
      const arrowSize = null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.arrow) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
      this.setMarkStyle(arrowMark, {
        x: this.dataToPositionXTo.bind(this),
        y: (datum) => this.dataToPositionArrowYTo(datum, arrowSize),
        fill: this.getColorAttribute(),
        fillOpacity: this.dataToOpacity.bind(this),
        size: arrowSize,
        symbolType: (datum) => this.isPositionYFromHigher(datum) ? "triangleDown" : "triangleUp"
      }, "normal", AttributeLevel.Series);
    }
  }
  afterInitMark() {
    super.afterInitMark();
  }
  dataToPositionXFrom(datum) {
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYFrom(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_yField"));
  }
  dataToPositionXTo(datum) {
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYTo(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionArrowYTo(datum, arrowSize) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper, offset = this.isPositionYFromHigher(datum) ? -arrowSize / 2 : arrowSize / 2;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    }) + offset;
  }
  dataToOpacity(datum) {
    return this.isPositionXOuterRange(datum, this._fromField + "_xField") || this.isPositionXOuterRange(datum, this._toField + "_xField") || datum[this._fromField] === datum[this._toField] ? 0 : 1;
  }
  isPositionYFromHigher(datum) {
    return this.dataToPositionYFrom(datum) < this.dataToPositionYTo(datum);
  }
  isPositionXOuterRange(datum, field5) {
    if (!this._xAxisHelper) return false;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, field5), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, field5), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1];
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
    };
  }
  initInteraction() {
    const marks = [];
    this._linkMark && marks.push(this._linkMark), this._arrowMark && marks.push(this._arrowMark), this._parseInteractionConfig(marks);
  }
  initTooltip() {
    this._tooltipHelper = new LinkSeriesTooltipHelper(this), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), this._arrowMark && this._tooltipHelper.activeTriggerSet.mark.add(this._arrowMark);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m4) => {
      "group" === m4.type ? this.onMarkTreePositionUpdate(m4.getMarks()) : m4.updateLayoutState();
    });
  }
  getDotInfoData() {
    var _a, _b;
    return null === (_b = null !== (_a = this._linkMark) && void 0 !== _a ? _a : this._arrowMark) || void 0 === _b ? void 0 : _b.getData();
  }
  getActiveMarks() {
    return [this._linkMark, this._arrowMark];
  }
};
LinkSeries.type = SeriesTypeEnum.link, LinkSeries.mark = linkSeriesMark;
var registerLinkSeries = () => {
  registerRuleMark(), registerSymbolMark(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(LinkSeries.type, LinkSeries);
};

// node_modules/@visactor/vchart/esm/series/polar/progress-like/constant.js
var progressLikeSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/series/polar/progress-like/progress-like.js
var ProgressLikeSeries = class _ProgressLikeSeries extends PolarSeries {
  constructor() {
    super(...arguments), this._arcGroupMark = null, this._getAngleValueStart = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this.getStack() ? STACK_FIELD_START : SEGMENT_FIELD_START], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle);
        let pos;
        if (isValid_default(originValue)) {
          const index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = index >= subTickData.length || originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
          void 0 !== targetIndex && (pos = this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value - step / 2]));
        }
        return isNil_default(pos) && (pos = this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2])), pos + offsetAngle;
      }
      return this._getAngleValueStartWithoutMask(datum);
    }, this._getAngleValueEnd = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this.getStack() ? STACK_FIELD_END : this._angleField[0]], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle), index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = index >= subTickData.length || originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
        let pos;
        return pos = void 0 !== targetIndex ? this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value + step / 2]) : this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2]), pos + offsetAngle;
      }
      return this._getAngleValueEndWithoutMask(datum);
    };
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec();
    const chartSpec = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getSpec(), startAngle = null !== (_b = this._spec.startAngle) && void 0 !== _b ? _b : null == chartSpec ? void 0 : chartSpec.startAngle;
    this._startAngle = isValid_default(startAngle) ? degreeToRadian(startAngle) : POLAR_START_RADIAN;
    const endAngle = null !== (_c = this._spec.endAngle) && void 0 !== _c ? _c : null == chartSpec ? void 0 : chartSpec.endAngle;
    this._endAngle = isValid_default(endAngle) ? degreeToRadian(endAngle) : POLAR_END_RADIAN, this.setAngleField(this._spec.valueField || this._spec.angleField), this.setRadiusField(this._spec.categoryField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice();
  }
  getStackGroupFields() {
    return this._radiusField;
  }
  getStackValueField() {
    var _a;
    return null === (_a = this._angleField) || void 0 === _a ? void 0 : _a[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  _convertMarkStyle(style) {
    const newStyle = super._convertMarkStyle(style);
    if (newStyle.fill) {
      const value = style.fill;
      "conical" !== (null == value ? void 0 : value.gradient) || isValid_default(null == value ? void 0 : value.startAngle) || isValid_default(null == value ? void 0 : value.endAngle) || (newStyle.fill = Object.assign(Object.assign({}, value), {
        startAngle: this._startAngle,
        endAngle: this._endAngle
      }));
    }
    return newStyle;
  }
  _getAngleValueStartWithoutMask(datum) {
    if (this.getStack()) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_START]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value)) return value;
    }
    return this._startAngle;
  }
  _getAngleValueEndWithoutMask(datum) {
    if (this.getStack()) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_END]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value)) return value;
    }
    const angle2 = this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]]);
    return this._spec.clamp ? valueInScaleRange(angle2, this.angleAxisHelper.getScale(0)) : angle2;
  }
  getDimensionField() {
    return this._specRadiusField;
  }
  getMeasureField() {
    return this._specAngleField;
  }
  initMark() {
    this._initArcGroupMark();
  }
  initMarkStyle() {
    this._initArcGroupMarkStyle();
  }
  _initArcGroupMark() {
    return this._arcGroupMark = this._createMark(_ProgressLikeSeries.mark.group, {
      skipBeforeLayouted: false
    }), this._arcGroupMark;
  }
  _initArcGroupMarkStyle() {
    const groupMark = this._arcGroupMark;
    groupMark.created(), this.setMarkStyle(groupMark, {
      x: 0,
      y: 0
    }, "normal", AttributeLevel.Series), this._arcGroupMark.setMarkConfig({
      interactive: false,
      zIndex: this.layoutZIndex,
      clip: true,
      clipPath: () => {
        const axis2 = this._getAngleAxis(), { x, y } = this.angleAxisHelper.center(), radius = this._computeLayoutRadius();
        if (this._isTickMaskVisible(axis2)) {
          const { tickMask } = this._spec, { angle: angle2, offsetAngle, style = {} } = tickMask, subTickData = this._getAngleAxisSubTickData(axis2), markStyle = style;
          return subTickData.map(({ value }) => {
            const pos = this.angleAxisHelper.dataToPosition([value]) + degreeToRadian(offsetAngle), angleUnit = degreeToRadian(angle2) / 2;
            return createArc(Object.assign(Object.assign({}, markStyle), {
              x,
              y,
              startAngle: pos - angleUnit,
              endAngle: pos + angleUnit,
              innerRadius: radius * this._innerRadius,
              outerRadius: radius * this._outerRadius,
              fill: true
            }));
          });
        }
        const { width, height } = this.getLayoutRect();
        return [createRect({
          width,
          height,
          fill: true
        })];
      }
    });
  }
  _getAngleAxis() {
    if (!this.angleAxisHelper) return;
    const angleAxisId = this.angleAxisHelper.getAxisId();
    return this._option.getChart().getAllComponents().find((component2) => component2.id === angleAxisId);
  }
  _getAngleAxisTickData(angleAxis) {
    var _a;
    return null === (_a = null == angleAxis ? void 0 : angleAxis.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  _isTickMaskVisible(angleAxis) {
    const tickData = this._getAngleAxisTickData(angleAxis), { tickMask } = this._spec;
    return tickMask && false !== tickMask.visible && (null == tickData ? void 0 : tickData.length) > 1;
  }
  _getAngleAxisSubTickData(angleAxis) {
    var _a;
    const tickData = this._getAngleAxisTickData(angleAxis), subTickData = [], { subTick = {}, tick = {} } = null !== (_a = null == angleAxis ? void 0 : angleAxis.getSpec()) && void 0 !== _a ? _a : {}, { tickCount: subTickCount = 4 } = subTick, { alignWithLabel } = tick;
    if ((null == tickData ? void 0 : tickData.length) >= 2) {
      const tickSegment = tickData[1].value - tickData[0].value;
      for (let i = 0; i < tickData.length - 1; i++) {
        const pre = tickData[i], next = tickData[i + 1];
        subTickData.push(pre);
        for (let j = 0; j < subTickCount; j++) {
          const percent = (j + 1) / (subTickCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment);
          subTickData.push({
            value
          });
        }
      }
      return subTickData.push(tickData[tickData.length - 1]), subTickData;
    }
    return tickData;
  }
};
ProgressLikeSeries.mark = progressLikeSeriesMark;

// node_modules/@visactor/vchart/esm/series/progress/circular/constant.js
var circularProgressSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  track: {
    name: "track",
    type: "arc"
  },
  progress: {
    name: "progress",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/polar/progress-like/animation.js
var Appear_Grow4 = (params2) => ({
  type: "growAngleIn",
  options: {
    overall: params2.startAngle
  }
});
var Appear_FadeIn7 = {
  type: "fadeIn"
};
function progressLikePresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn7 : Appear_Grow4(params2);
}
var registerProgressLikeAnimation = () => {
  Factory2.registerAnimation("circularProgress", (params2, preset) => ({
    appear: progressLikePresetAnimation(params2, preset),
    enter: {
      type: "growAngleIn"
    },
    disappear: {
      type: "growAngleOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/progress/circular/circular-transformer.js
var CircularProgressSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
};

// node_modules/@visactor/vchart/esm/series/progress/circular/circular.js
var CircularProgressSeries = class _CircularProgressSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circularProgress, this.transformerConstructor = CircularProgressSeriesSpecTransformer, this._progressMark = null, this._trackMark = null, this._getRadiusValueStart = (datum) => {
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields()));
        if (isValidNumber_default(value)) return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]);
    }, this._getRadiusValueEnd = (datum) => {
      var _a, _b;
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + (null === (_b = (_a = this.radiusAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0));
        if (isValidNumber_default(value)) return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]) + this.radiusAxisHelper.getScale(0).step();
    };
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getGroupFields() {
    return this._radiusField;
  }
  initMark() {
    super.initMark(), this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    super.initMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a, _b;
    return this._progressMark = this._createMark(_CircularProgressSeries.mark.progress, {
      parent: this._arcGroupMark,
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      morph: shouldMarkDoMorph(this._spec, "progress"),
      setCustomizedShape: null === (_b = this._spec.progress) || void 0 === _b ? void 0 : _b.customShape
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a;
    const progressMark = this._progressMark;
    progressMark && this.setMarkStyle(progressMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart,
      endAngle: this._getAngleValueEnd,
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    }, "normal", AttributeLevel.Series);
  }
  initInteraction() {
    const marks = [];
    this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), this._parseInteractionConfig(marks);
  }
  initTooltip() {
    super.initTooltip(), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark);
  }
  _initTrackMark() {
    var _a, _b;
    return this._trackMark = this._createMark(_CircularProgressSeries.mark.track, {
      parent: this._arcGroupMark,
      stateSort: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.track) || void 0 === _b ? void 0 : _b.customShape
    }), this._trackMark.setMarkConfig({
      morph: false,
      morphKey: null,
      morphElementKey: null
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && this.setMarkStyle(trackMark, {
      visible: (datum) => {
        const range2 = this.angleAxisHelper.getScale(0).range(), min3 = Math.min(range2[0], range2[range2.length - 1]), startValue = this._getAngleValueStartWithoutMask(datum);
        return Math.abs(startValue - min3) <= 1e-14;
      },
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: () => {
        const fieldName = this.getStack() ? STACK_FIELD_START : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueStart({
          [fieldName]: domain[0]
        });
      },
      endAngle: () => {
        const fieldName = this.getStack() ? STACK_FIELD_END : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueEnd({
          [fieldName]: domain[domain.length - 1]
        });
      },
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 100
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
CircularProgressSeries.type = SeriesTypeEnum.circularProgress, CircularProgressSeries.mark = circularProgressSeriesMark, CircularProgressSeries.transformerConstructor = CircularProgressSeriesSpecTransformer;
var registerCircularProgressSeries = () => {
  Factory2.registerSeries(CircularProgressSeries.type, CircularProgressSeries), registerArcMark(), registerProgressLikeAnimation(), registerFadeInOutAnimation(), registerPolarBandAxis(), registerPolarLinearAxis();
};

// node_modules/@visactor/vchart/esm/series/progress/linear/animation.js
function LinearProgressGrowOption(params2) {
  return () => "vertical" === params2.direction ? {
    orient: "negative"
  } : {
    orient: "positive"
  };
}
var Appear_Grow5 = (params2) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: LinearProgressGrowOption(params2)
});
var linearProgressDisappear = (params2) => ({
  type: "horizontal" === params2.direction ? "growWidthOut" : "growHeightOut",
  options: LinearProgressGrowOption(params2)
});
var Appear_FadeIn8 = {
  type: "fadeIn"
};
function linearProgressPresetAnimation(params2, preset) {
  return false === preset ? {} : "fadeIn" === preset ? Appear_FadeIn8 : Appear_Grow5(params2);
}
var registerLinearProgressAnimation = () => {
  Factory2.registerAnimation("linearProgress", (params2, preset) => ({
    appear: linearProgressPresetAnimation(params2, preset),
    enter: {
      type: "grow"
    },
    disappear: linearProgressDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/progress/linear/tooltip-helper.js
var LinearProgressSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  enableByType(activeType) {
    return "dimension" !== activeType;
  }
};

// node_modules/@visactor/vchart/esm/series/progress/linear/constant.js
var linearProgressSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  track: {
    name: "track",
    type: "rect"
  },
  progress: {
    name: "progress",
    type: "rect"
  },
  group: {
    name: "group",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/series/progress/linear/linear.js
var LinearProgressSeries = class _LinearProgressSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.linearProgress, this._progressMark = null, this._trackMark = null, this._defaultProgressCustomShape = (datum, attrs, path) => {
      var _a, _b;
      const cornerRadius = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.cornerRadius, width = isValid_default(attrs.width) ? attrs.width : attrs.x1 - attrs.x, height = isValid_default(attrs.height) ? attrs.height : attrs.y1 - attrs.y, x0 = Math.min(0, width), x1 = Math.max(0, width), y0 = Math.min(0, height), y1 = Math.max(0, height);
      if (cornerRadius > 0) {
        let realCornerRadius = cornerRadius;
        if ("vertical" === (null === (_b = this._spec) || void 0 === _b ? void 0 : _b.direction)) {
          if (realCornerRadius = Math.min(Math.abs(width / 2), cornerRadius), 2 * realCornerRadius > Math.abs(height)) {
            const angle2 = Math.acos((realCornerRadius - Math.abs(height) / 2) / realCornerRadius);
            return path.moveTo(x0 + realCornerRadius, y0), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, 1.5 * Math.PI, 1.5 * Math.PI - angle2, true), path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, angle2 + Math.PI / 2, Math.PI / 2, true), path.lineTo(x1 - cornerRadius, y1), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI / 2, Math.PI / 2 - angle2, true), path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -Math.PI / 2 + angle2, -Math.PI / 2, true), path.lineTo(x0 + realCornerRadius, y0), path.closePath(), path;
          }
        } else if (realCornerRadius = Math.min(Math.abs(height / 2), cornerRadius), 2 * realCornerRadius > Math.abs(width)) {
          const angle2 = Math.acos((realCornerRadius - Math.abs(width) / 2) / realCornerRadius);
          return path.moveTo(x0, y0 + realCornerRadius), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, Math.PI, Math.PI + angle2), path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -angle2, 0), path.lineTo(x1, y1 - realCornerRadius), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, 0, angle2), path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI - angle2, Math.PI), path.closePath(), path;
        }
        path.moveTo(x0, y0 + realCornerRadius), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, Math.PI, 1.5 * Math.PI), path.lineTo(x1 - realCornerRadius, y0), path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -Math.PI / 2, 0), path.lineTo(x1, y1 - realCornerRadius), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, 0, Math.PI / 2), path.lineTo(x0 + realCornerRadius, y1), path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI / 2, Math.PI), path.closePath();
      } else path.moveTo(x0, y0), path.lineTo(x1, y0), path.lineTo(x1, y1), path.lineTo(x0, y1), path.closePath();
      return path;
    };
  }
  initMark() {
    this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a, _b, _c;
    return this._progressMark = this._createMark(_LinearProgressSeries.mark.progress, {
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null !== (_c = null === (_b = this._spec.progress) || void 0 === _b ? void 0 : _b.customShape) && void 0 !== _c ? _c : this._defaultProgressCustomShape
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a, _b, _c, _d;
    const progressMark = this._progressMark;
    if (progressMark) if ("vertical" === this._spec.direction) {
      const progress = this._spec.progress || {}, leftPadding = null !== (_a = progress.leftPadding) && void 0 !== _a ? _a : 0, rightPadding = null !== (_b = progress.rightPadding) && void 0 !== _b ? _b : 0;
      this.setMarkStyle(progressMark, {
        x: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0), true) - this._spec.bandWidth / 2 + leftPadding;
        },
        y1: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
        },
        y: () => {
          var _a2, _b2, _c2;
          const value = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([0], {
            bandPosition: this._bandPosition
          });
          return this._spec.clamp ? valueInScaleRange(value, null === (_c2 = null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale) || void 0 === _c2 ? void 0 : _c2.call(_b2, 0)) : value;
        },
        width: this._spec.bandWidth - leftPadding - rightPadding,
        cornerRadius: this._spec.cornerRadius,
        fill: this.getColorAttribute()
      }, "normal", AttributeLevel.Series);
    } else {
      const progress = this._spec.progress || {}, topPadding = null !== (_c = progress.topPadding) && void 0 !== _c ? _c : 0, bottomPadding = null !== (_d = progress.bottomPadding) && void 0 !== _d ? _d : 0;
      this.setMarkStyle(progressMark, {
        x1: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
        },
        y: (datum) => {
          var _a2, _b2;
          return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0), true) - this._spec.bandWidth / 2 + topPadding;
        },
        height: this._spec.bandWidth - topPadding - bottomPadding,
        x: () => {
          var _a2, _b2, _c2;
          const value = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([0], {
            bandPosition: this._bandPosition
          });
          return this._spec.clamp ? valueInScaleRange(value, null === (_c2 = null === (_b2 = this._xAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale) || void 0 === _c2 ? void 0 : _c2.call(_b2, 0)) : value;
        },
        cornerRadius: this._spec.cornerRadius,
        fill: this.getColorAttribute()
      }, "normal", AttributeLevel.Series);
    }
  }
  _initTrackMark() {
    var _a, _b;
    return this._trackMark = this._createMark(_LinearProgressSeries.mark.track, {
      stateSort: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.track) || void 0 === _b ? void 0 : _b.customShape
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && ("vertical" === this._spec.direction ? this.setMarkStyle(trackMark, {
      x: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), true) - this._spec.bandWidth / 2;
      },
      y: 0,
      width: this._spec.bandWidth,
      height: () => this._scaleY.range()[0],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(trackMark, {
      x: 0,
      y: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), true) - this._spec.bandWidth / 2;
      },
      height: this._spec.bandWidth,
      width: () => this._scaleX.range()[1],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series));
  }
  initInteraction() {
    const marks = [];
    this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), this._parseInteractionConfig(marks);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("linearProgress")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new LinearProgressSeriesTooltipHelper(this), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark), this._trackMark && this._tooltipHelper.activeTriggerSet.mark.add(this._trackMark);
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
LinearProgressSeries.type = SeriesTypeEnum.linearProgress, LinearProgressSeries.mark = linearProgressSeriesMark;
var registerLinearProgressSeries = () => {
  registerRectMark(), registerLinearProgressAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(LinearProgressSeries.type, LinearProgressSeries);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/config.js
var DEFAULT_ROTATE_ANGLES = [0];
var DEFAULT_DRAW_OUT_OF_BOUND = "hidden";
var DEFAULT_MIN_FONT_SIZE = 20;
var DEFAULT_FONTSIZE_RANGE = [20, 40];
var DEFAULT_FONT_WEIGHT_RANGE = [200, 500];
var DEFAULT_MASK_SHAPE = "circle";
var DEFAULT_ZOOM_TO_FIT = {
  shrink: false,
  enlarge: false,
  fontSizeLimitMin: 0
};
var DEFAULT_RANDOM = true;
var DEFAULT_FONT_PADDING = 1;
var SHAPE_TYPE = ["triangleForward", "triangle", "diamond", "square", "star", "cardioid", "circle", "pentagon", "rect"];

// node_modules/@visactor/vchart/esm/constant/word-cloud.js
var WORD_CLOUD_ANGLE = `${PREFIX}_WORD_CLOUD_ANGLE`;
var WORD_CLOUD_FILLING_ANGLE = `${PREFIX}_WORD_CLOUD_FILLING_ANGLE`;
var WORD_CLOUD_WEIGHT = `${PREFIX}_WORD_CLOUD_WEIGHT`;
var WORDCLOUD_COLOR = `${PREFIX}_WORDCLOUD_COLOR`;
var WORDCLOUD_DATA_TOTAL = `${PREFIX}_WORDCLOUD_DATA_TOTAL`;
var WORD_CLOUD_TEXT = `${PREFIX}_WORD_CLOUD_TEXT`;
var WORDCLOUD_SHAPE_DATA_TOTAL = `${PREFIX}_WORDCLOUD_SHAPE_DATA_TOTAL`;

// node_modules/@visactor/vchart/esm/series/word-cloud/constant.js
var wordCloudSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  word: {
    name: "word",
    type: "text"
  },
  fillingWord: {
    name: "fillingWord",
    type: "text"
  },
  wordMask: {
    name: "wordMask",
    type: "rect"
  }
});

// node_modules/@visactor/vchart/esm/series/word-cloud/base.js
var BaseWordCloudSeries = class _BaseWordCloudSeries extends BaseSeries {
  constructor() {
    super(...arguments), this._fontSizeRange = [DEFAULT_MIN_FONT_SIZE, DEFAULT_MIN_FONT_SIZE], this._isWordCloudShape = false, this._dataChange = true, this.handleMaskCanvasUpdate = (canvas, imageUrl) => {
      this._maskCanvas = canvas;
    }, this.getWordColor = (datum) => datum.isFillingWord ? (this._fillingColorCallback && !this._dataChange || (this._fillingColorCallback = this._wordCloudShapeConfig.fillingColorHexField ? (datum2) => datum2[this._wordCloudShapeConfig.fillingColorHexField] : this.initColorCallback(this._wordCloudShapeConfig.fillingSeriesField, true)), this._fillingColorCallback(datum)) : (this._keyWordColorCallback && !this._dataChange || (this._keyWordColorCallback = this._spec.colorHexField ? (datum2) => datum2[this._spec.colorHexField] : this.initColorCallback(this._seriesField, false)), this._keyWordColorCallback(datum)), this._calculateFontWeight = (datum) => {
      const stats = this.getRawDataStatisticsByField(this._valueField, true);
      return stats.min === stats.max ? this._fontWeightRange[0] : this._fontWeightRange[0] + (this._fontWeightRange[this._fontWeightRange.length - 1] - this._fontWeightRange[0]) * (datum[this._valueField] - stats.min) / (stats.max - stats.min);
    };
  }
  setValueField(field5) {
    isValid_default(field5) && (this._valueField = field5);
  }
  setFontSizeRange(fontSizeRange) {
    isValid_default(fontSizeRange) ? this._fontSizeRange = fontSizeRange : this._fontSizeRange = DEFAULT_FONTSIZE_RANGE;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec(), this._padding = this._option.getChart().padding, this._nameField = this._spec.nameField, this._colorMode = null !== (_a = this._spec.colorMode) && void 0 !== _a ? _a : "ordinal", this._colorList = this._spec.colorList, this.setValueField(this._spec.valueField), this._fontWeightRange = null !== (_b = this._spec.fontWeightRange) && void 0 !== _b ? _b : DEFAULT_FONT_WEIGHT_RANGE, this._rotateAngles = null !== (_c = this._spec.rotateAngles) && void 0 !== _c ? _c : DEFAULT_ROTATE_ANGLES, this.setFontSizeRange(this._spec.fontSizeRange), this._maskShape = null !== (_d = this._spec.maskShape) && void 0 !== _d ? _d : DEFAULT_MASK_SHAPE, this._textField = (null === (_e = this._spec.word) || void 0 === _e ? void 0 : _e.formatMethod) ? WORD_CLOUD_TEXT : this._nameField;
    const wordCloudConfig = this._spec.wordCloudConfig;
    this._wordCloudConfig = Object.assign({
      drawOutOfBound: DEFAULT_DRAW_OUT_OF_BOUND,
      layoutMode: "default",
      zoomToFit: DEFAULT_ZOOM_TO_FIT
    }, this._spec.wordCloudConfig), wordCloudConfig && !isNil_default(wordCloudConfig.layoutMode) || isTrueBrowser(this._option.mode) || (this._wordCloudConfig.layoutMode = "fast"), this._wordCloudShapeConfig = Object.assign({
      fillingSeriesField: this.getSeriesField(),
      fillingRotateAngles: DEFAULT_ROTATE_ANGLES,
      layoutMode: "default"
    }, this._spec.wordCloudShapeConfig), this._isWordCloudShape = !SHAPE_TYPE.includes(this._maskShape) && !["fast", "grid", "cloud"].includes(this._wordCloudConfig.layoutMode), this._defaultFontFamily = this._option.getTheme().fontFamily;
  }
  initData() {
    var _a, _b;
    super.initData(), null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.target) || void 0 === _b || _b.addListener("change", () => {
      this._dataChange = true, this.compile();
    });
  }
  initMark() {
    var _a;
    (null === (_a = this._spec.wordMask) || void 0 === _a ? void 0 : _a.visible) && (this._maskMark = this._createMark(_BaseWordCloudSeries.mark.wordMask, {
      dataView: false
    })), this._wordMark = this._createMark(_BaseWordCloudSeries.mark.word, {
      key: DEFAULT_DATA_KEY,
      groupKey: this._seriesField,
      isSeriesMark: true
    }, {
      morphElementKey: this._seriesField
    });
  }
  initMarkStyle() {
    this.initMarkStyleOfWord(this._wordMark, this._spec.word, this._spec.colorHexField, this._seriesField), this._maskMark && this.setMarkStyle(this._maskMark, {
      width: () => this._region.getLayoutRect().width,
      height: () => this._region.getLayoutRect().height,
      background: () => this._maskCanvas
    }, "normal", AttributeLevel.Series);
  }
  initMarkStyleOfWord(wordMark, wordSpec, colorHexField, seriesField, isFillingWord) {
    var _a, _b;
    wordMark && (this.setMarkStyle(wordMark, {
      text: (null == wordSpec ? void 0 : wordSpec.formatMethod) ? (datum) => wordSpec.formatMethod(datum) : (datum) => datum[this._textField],
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      fontSize: (datum) => datum.fontSize,
      fontStyle: (datum) => datum.fontStyle,
      angle: (datum) => datum.angle,
      visible: (datum) => datum.visible
    }, "normal", AttributeLevel.Series), this.setMarkStyle(wordMark, {
      fill: null !== (_b = null === (_a = null == wordSpec ? void 0 : wordSpec.style) || void 0 === _a ? void 0 : _a.fill) && void 0 !== _b ? _b : this.getWordColor,
      fontWeight: (datum) => datum.fontWeight,
      fontFamily: (datum) => datum.fontFamily
    }, "normal", AttributeLevel.User_Mark));
  }
  initTooltip() {
    super.initTooltip(), this._wordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._wordMark);
  }
  initAnimation() {
    [this._wordMark].forEach((mark) => {
      var _a, _b;
      if (mark) {
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params2 = {
          animationConfig: () => {
            var _a2, _b2;
            return null === (_b2 = null === (_a2 = mark.getAnimationConfig()) || void 0 === _a2 ? void 0 : _a2.appear) || void 0 === _b2 ? void 0 : _b2[0];
          }
        };
        mark.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("wordCloud")(params2, appearPreset), userAnimationConfig("word", this._spec, this._markAttributeContext)));
      }
    });
  }
  getWordOrdinalColorScale(field5, isFillingWord) {
    var _a, _b, _c, _d, _e;
    const colorList = isFillingWord ? this._wordCloudShapeConfig.fillingColorList : this._colorList, colorDomain = field5 ? null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum) => datum[field5]) : [], colorRange = null !== (_c = null != colorList ? colorList : null === (_b = this._option.globalScale.getScale("color")) || void 0 === _b ? void 0 : _b.range()) && void 0 !== _c ? _c : this._getDataScheme();
    return null === (_e = (_d = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _e ? void 0 : _e.call(_d, colorRange);
  }
  initColorCallback(field5, isFillingWord) {
    var _a, _b, _c, _d;
    if ("ordinal" === this._colorMode) {
      const scale5 = this.getWordOrdinalColorScale(field5, isFillingWord);
      return (datum) => scale5.scale(datum[null != field5 ? field5 : DEFAULT_DATA_SERIES_FIELD]);
    }
    const colorList = null !== (_a = isFillingWord ? this._colorList : this._wordCloudShapeConfig.fillingColorList) && void 0 !== _a ? _a : this._option.globalScale.getScale("color").range();
    if (1 === colorList.length) return (datum) => colorList[0];
    if (this._valueField) {
      const stats = this.getRawDataStatisticsByField(this._valueField, true);
      if (stats.min === stats.max) return colorList[0];
      const scale5 = new LinearScale().domain([stats.min, stats.max]).range(colorList);
      return (datum) => scale5.scale(datum[this._valueField]);
    }
    const scale4 = new LinearScale().domain([0, null !== (_d = null === (_c = null === (_b = this.getViewData()) || void 0 === _b ? void 0 : _b.latestData) || void 0 === _c ? void 0 : _c.length) && void 0 !== _d ? _d : 1]).range(colorList);
    return (datum) => scale4.scale(datum[DEFAULT_DATA_INDEX]);
  }
  compile() {
    super.compile();
    const { width, height } = this._region.getLayoutRect();
    if (!isValidNumber_default(width) || !isValidNumber_default(height) || !(height > 0 && width > 0)) return;
    const product = this._wordMark.getProduct();
    if (product) {
      const wordCloudTransforms = [];
      this._isWordCloudShape ? wordCloudTransforms.push(Object.assign({
        type: "wordcloudShape"
      }, this._wordCloudShapeTransformOption())) : wordCloudTransforms.push(Object.assign({
        type: "wordcloud"
      }, this._wordCloudTransformOption())), product.transform(wordCloudTransforms);
    }
  }
  _getCommonTransformOptions() {
    var _a, _b, _c, _d, _e, _f;
    const { width, height } = this._region.getLayoutRect(), wordSpec = null !== (_a = this._spec.word) && void 0 !== _a ? _a : {}, wordStyleSpec = null !== (_b = wordSpec.style) && void 0 !== _b ? _b : {};
    return {
      size: [width, height],
      shape: isObject_default(this._maskShape) && "text" === this._maskShape.type && isNil_default(this._maskShape.fontFamily) ? Object.assign({
        fontFamily: null === (_c = this._option.getTheme()) || void 0 === _c ? void 0 : _c.fontFamily
      }, this._maskShape) : this._maskShape,
      onUpdateMaskCanvas: this.handleMaskCanvasUpdate,
      dataIndexKey: DEFAULT_DATA_KEY,
      text: wordSpec.formatMethod ? (datum) => wordSpec.formatMethod(datum) : {
        field: this._textField
      },
      fontSize: this._valueField ? {
        field: this._valueField
      } : this._fontSizeRange[0],
      fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
      padding: null !== (_e = null === (_d = this._spec.word) || void 0 === _d ? void 0 : _d.padding) && void 0 !== _e ? _e : DEFAULT_FONT_PADDING,
      fontFamily: isValid_default(this._spec.fontFamilyField) ? {
        field: this._spec.fontFamilyField
      } : null !== (_f = wordStyleSpec.fontFamily) && void 0 !== _f ? _f : this._defaultFontFamily,
      fontWeight: isValid_default(this._spec.fontWeightField) ? {
        field: this._spec.fontWeightField
      } : isValid_default(wordStyleSpec.fontWeight) ? wordStyleSpec.fontWeight : isValid_default(this._valueField) ? this._calculateFontWeight : "normal",
      fontStyle: isValid_default(this._spec.fontStyleField) ? {
        field: this._spec.fontStyleField
      } : wordStyleSpec.fontStyle
    };
  }
  _wordCloudTransformOption() {
    var _a, _b;
    const wordCloudConfig = null !== (_a = this._wordCloudConfig) && void 0 !== _a ? _a : {};
    return Object.assign(Object.assign(Object.assign({}, wordCloudConfig), this._getCommonTransformOptions()), {
      layoutType: this._wordCloudConfig.layoutMode,
      rotate: this._rotateAngles,
      randomVisible: null !== (_b = this._spec.random) && void 0 !== _b ? _b : DEFAULT_RANDOM,
      clip: "clip" === this._wordCloudConfig.drawOutOfBound,
      shrink: this._wordCloudConfig.zoomToFit.shrink,
      enlarge: this._wordCloudConfig.zoomToFit.enlarge,
      minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
      progressiveTime: this._wordCloudConfig.progressiveTime,
      progressiveStep: this._wordCloudConfig.progressiveStep,
      repeatFill: this._wordCloudConfig.zoomToFit.repeat
    });
  }
  _wordCloudShapeTransformOption() {
    var _a, _b, _c, _d, _e, _f;
    const fillingWordStyleSpec = null !== (_b = null === (_a = this._spec.fillingWord) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {}, wordCloudShapeConfig = null !== (_c = this._wordCloudShapeConfig) && void 0 !== _c ? _c : {};
    return Object.assign(Object.assign(Object.assign({}, wordCloudShapeConfig), this._getCommonTransformOptions()), {
      rotateList: this._rotateAngles,
      fillingRotateList: wordCloudShapeConfig.fillingRotateAngles,
      fillingFontFamily: isValid_default(wordCloudShapeConfig.fillingFontFamilyField) ? {
        field: wordCloudShapeConfig.fillingFontFamilyField
      } : null !== (_d = fillingWordStyleSpec.fontFamily) && void 0 !== _d ? _d : this._defaultFontFamily,
      fillingPadding: null !== (_f = null === (_e = this._spec.fillingWord) || void 0 === _e ? void 0 : _e.padding) && void 0 !== _f ? _f : DEFAULT_FONT_PADDING,
      fillingFontStyle: isValid_default(wordCloudShapeConfig.fillingFontStyleField) ? {
        field: wordCloudShapeConfig.fillingFontStyleField
      } : fillingWordStyleSpec.fontStyle,
      fillingFontWeight: isValid_default(wordCloudShapeConfig.fillingFontWeightField) ? {
        field: wordCloudShapeConfig.fillingFontWeightField
      } : fillingWordStyleSpec.fontWeight
    });
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  dataToPosition(data) {
    return null;
  }
  dataToPositionX(data) {
    return null;
  }
  dataToPositionY(data) {
    return null;
  }
  dataToPositionZ(data) {
    return null;
  }
  valueToPosition(value1, value2) {
    return null;
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.compile(), this._dataChange = false;
  }
  getActiveMarks() {
    return [this._wordMark];
  }
  reInit() {
    super.reInit(), this._keyWordColorCallback && (this._keyWordColorCallback = null), this._fillingColorCallback && (this._fillingColorCallback = null);
  }
};
BaseWordCloudSeries.mark = wordCloudSeriesMark;

// node_modules/@visactor/vchart/esm/series/word-cloud/animation.js
var WordCloud3dAnimation = (params2) => ({
  custom: RotateBySphereAnimate,
  customParameters: (datum, element) => params2,
  easing: "linear",
  loop: 1 / 0,
  duration: 6e3
});
function computeWordDelay(duration, totalTime, wordCount) {
  return duration * wordCount < totalTime ? duration + (totalTime - wordCount * duration) / (wordCount - 1) : (totalTime - duration) / (wordCount - 1);
}
var WordCloudScaleInAnimation = (params2) => ({
  channel: {
    fontSize: {
      from: 0
    }
  },
  duration: 200,
  delay: (datum, element, vgrammarParams) => {
    const animationConfig2 = params2.animationConfig(), duration = (null == animationConfig2 ? void 0 : animationConfig2.duration) || 200, totalTime = (null == animationConfig2 ? void 0 : animationConfig2.totalTime) || DEFAULT_ANIMATION_CONFIG.appear.duration, count = vgrammarParams.VGRAMMAR_ANIMATION_PARAMETERS.elementCount;
    return vgrammarParams.VGRAMMAR_ANIMATION_PARAMETERS.elementIndex * computeWordDelay(duration, totalTime, count);
  }
});
function wordcloudPresetAnimation(params2, preset) {
  return false === preset ? {} : "fadeIn" === preset ? {
    type: "fadeIn"
  } : WordCloudScaleInAnimation(params2);
}
var registerWordCloudAnimation = () => {
  Factory2.registerAnimation("wordCloud", (params2, preset) => ({
    appear: wordcloudPresetAnimation(params2, preset),
    enter: {
      type: "fadeIn"
    },
    exit: {
      type: "fadeOut"
    },
    disappear: {
      type: "fadeOut"
    }
  }));
};
var registerWordCloud3dAnimation = () => {
  Factory2.registerAnimation("wordCloud3d", (params2) => ({
    enter: WordCloud3dAnimation(params2)
  }));
};

// node_modules/@visactor/vgrammar-wordcloud/es/util.js
var randomHslColor = (min3, max3) => "hsl(" + (360 * Math.random()).toFixed() + "," + (30 * Math.random() + 70).toFixed() + "%," + (Math.random() * (max3 - min3) + min3).toFixed() + "%)";
function functor(d) {
  return isFunction_default(d) ? d : function() {
    return d;
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/base.js
var BaseLayout = class _BaseLayout {
  constructor(options) {
    var _a, _b;
    switch (this.options = merge({}, _BaseLayout.defaultOptions, options), isFunction_default(this.options.shape) ? this.shape = this.options.shape : this.shape = getShapeFunction(this.options.shape), this.getText = null !== (_a = functor(this.options.text)) && void 0 !== _a ? _a : (d) => d, this.getTextFontWeight = functor(this.options.fontWeight), this.getTextFontSize = functor(this.options.fontSize), this.getTextFontStyle = functor(this.options.fontStyle), this.getTextFontFamily = functor(this.options.fontFamily), this.outputCallback = null !== (_b = this.options.outputCallback) && void 0 !== _b ? _b : (res) => res, this.options.color) {
      case "random-dark":
        this.getTextColor = () => randomHslColor(10, 50);
        break;
      case "random-light":
        this.getTextColor = () => randomHslColor(50, 90);
        break;
      default:
        this.getTextColor = functor(this.options.color);
    }
    if (isNil_default(this.options.rotate)) if (this.options.useRandomRotate) {
      const rotationRange = Math.abs(this.options.maxRotation - this.options.minRotation), rotationSteps = Math.abs(Math.floor(this.options.rotationSteps)), minRotation = Math.min(this.options.maxRotation, this.options.minRotation);
      this.getTextRotate = () => 0 === this.options.rotateRatio || Math.random() > this.options.rotateRatio ? 0 : 0 === rotationRange ? minRotation : rotationSteps > 0 ? minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1) : minRotation + Math.random() * rotationRange;
    } else this.getTextRotate = () => 0;
    else this.getTextRotate = isFunction_default(this.options.rotate) ? (d) => {
      var _a2;
      return degreeToRadian(null !== (_a2 = this.options.rotate(d)) && void 0 !== _a2 ? _a2 : 0);
    } : (d, i) => {
      const rotates = array(this.options.rotate), random2 = this.options.random ? Math.random() : seedRandom(i);
      return degreeToRadian(rotates[Math.floor(random2 * rotates.length)]);
    };
  }
  canRepeat() {
    return false;
  }
  exceedTime() {
    var _a;
    return this.options.progressiveStep > 0 ? this.progressiveIndex >= ((null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : -1) + 1) * this.options.progressiveStep : this.options.progressiveTime > 0 && (/* @__PURE__ */ new Date()).getTime() - this.escapeTime > this.options.progressiveTime;
  }
  progressiveRun() {
    var _a;
    if (this.options.progressiveStep > 0 ? this.currentStepIndex = (null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : -1) + 1 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), this.data && this.progressiveIndex < this.data.length) {
      this.progressiveResult = [];
      let i = this.progressiveIndex, curWordTryCount = 0;
      const maxSingleWordTryCount = this.options.maxSingleWordTryCount, maxFailCount = Math.min(this.options.maxFailCount, this.originalData.length);
      for (; i < this.data.length && this.failCount < maxFailCount; ) {
        const drawn = this.layoutWord(i);
        if (curWordTryCount++, (drawn || curWordTryCount > maxSingleWordTryCount) && (i++, curWordTryCount = 0, this.failCount = drawn ? 0 : this.failCount + 1), this.progressiveIndex = i, this.exceedTime()) break;
        i === this.data.length && this.failCount < maxFailCount && this.options.repeatFill && this.canRepeat() && (this.data = [...this.data, ...this.originalData.map((entry) => Object.assign(Object.assign({}, entry), {
          isFill: true
        }))], this.isTryRepeatFill = true);
      }
      return this.progressiveResult;
    }
    return this.result;
  }
  initProgressive() {
    this.failCount = 0, this.progressiveIndex = 0, this.options.progressiveStep > 0 ? this.currentStepIndex = -1 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), this.progressiveResult = [];
  }
  output() {
    return this.result ? this.outputCallback(this.result) : null;
  }
  progressiveOutput() {
    return this.progressiveResult ? this.outputCallback(this.progressiveResult) : null;
  }
  unfinished() {
    return this.data && this.data.length && !isNil_default(this.progressiveIndex) && this.progressiveIndex < this.data.length;
  }
  release() {
    this.data = null, this.result = null, this.progressiveIndex = null, this.progressiveResult = null;
  }
};
BaseLayout.defaultOptions = {
  fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", "Arial Unicode MS", "Droid Fallback Sans", sans-serif',
  fontWeight: "normal",
  color: "random-dark",
  fontStyle: "normal",
  minFontSize: 12,
  drawOutOfBound: false,
  shrink: false,
  minRotation: -Math.PI / 2,
  maxRotation: Math.PI / 2,
  rotationSteps: 0,
  rotateRatio: 0.1,
  random: false,
  shape: "circle",
  progressiveTime: 0,
  progressiveStep: 0,
  repeatFill: false,
  fillTextFontSize: 12,
  maxFailCount: 20
};

// node_modules/@visactor/vgrammar-wordcloud/es/spirals.js
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function archimedeanSpiral(size) {
  const e = size[0] / size[1];
  return (t) => [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
}
function rectangularSpiral(size) {
  const dx = 4 * size[0] / size[1];
  let x = 0, y = 0;
  return (t) => {
    const sign2 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t) - sign2 & 3) {
      case 0:
        x += dx;
        break;
      case 1:
        y += 4;
        break;
      case 2:
        x -= dx;
        break;
      default:
        y -= 4;
    }
    return [x, y];
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/cloud-layout.js
var CloudLayout = class _CloudLayout extends BaseLayout {
  constructor(options) {
    var _a;
    super(merge({}, _CloudLayout.defaultOptions, options)), this.cw = 64, this.ch = 2048, this._size = [256, 256], this._isBoardExpandCompleted = false, this._placeStatus = 0, this._tTemp = null, this._dtTemp = null, this._dy = 0, this.cacheMap = /* @__PURE__ */ new Map(), this.options.minFontSize <= _CloudLayout.defaultOptions.minFontSize && (this.options.minFontSize = _CloudLayout.defaultOptions.minFontSize), this.spiral = isString_default(this.options.spiral) ? null !== (_a = spirals[this.options.spiral]) && void 0 !== _a ? _a : spirals.archimedean : this.options.spiral, this.random = this.options.random ? Math.random : () => 1, this.getTextPadding = functor(this.options.padding);
  }
  zoomRatio() {
    return this._originSize[0] / this._size[0];
  }
  dy() {
    return this._dy;
  }
  layoutWord(index) {
    const d = this.data[index];
    if ("" === ("" + d.text).trim()) return true;
    const { maxRadius, center: center2 } = getMaxRadiusAndCenter(this.options.shape, this._size);
    if (d.x = center2[0], d.y = center2[1], cloudSprite(this.contextAndRatio, d, this.data, index, this.cw, this.ch), this._placeStatus = 0, d.hasText && this.place(this._board, d, this._bounds, maxRadius)) return this.result.push(d), this._bounds ? cloudBounds(this._bounds, d) : this._bounds = [{
      x: d.x + d.x0,
      y: d.y + d.y0
    }, {
      x: d.x + d.x1,
      y: d.y + d.y1
    }], d.x -= this._size[0] >> 1, d.y -= this._size[1] >> 1, this._tTemp = null, this._dtTemp = null, true;
    if (this.updateBoardExpandStatus(d.fontSize), d.hasText && this.shouldShrinkContinue()) {
      if (1 === this._placeStatus) {
        const maxSize0 = d.fontSize * this._originSize[0] / this.options.minFontSize, distSize0 = Math.max(d.width, d.height);
        if (distSize0 <= maxSize0) this.expandBoard(this._board, this._bounds, distSize0 / this._size[0]);
        else {
          if (!this.options.clip) return true;
          this.expandBoard(this._board, this._bounds, maxSize0 / this._size[0]);
        }
      } else this._placeStatus, this.expandBoard(this._board, this._bounds);
      return this.updateBoardExpandStatus(d.fontSize), false;
    }
    return this._tTemp = null, this._dtTemp = null, true;
  }
  layout(words, config2) {
    this.initProgressive(), this.result = [], this._size = [config2.width, config2.height], this.clearCache(), this._originSize = [...this._size];
    const contextAndRatio = this.getContext(vglobal.createCanvas({
      width: 1,
      height: 1
    }));
    this.contextAndRatio = contextAndRatio, this._board = new Array((this._size[0] >> 5) * this._size[1]).fill(0), this._bounds = null;
    words.length;
    this.result = [];
    const data = words.map((d, i) => ({
      text: this.getText(d),
      fontFamily: this.getTextFontFamily(d),
      fontStyle: this.getTextFontStyle(d),
      fontWeight: this.getTextFontWeight(d),
      angle: this.getTextRotate(d, i),
      fontSize: ~~this.getTextFontSize(d),
      padding: this.getTextPadding(d),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    })).sort(function(a3, b) {
      return b.fontSize - a3.fontSize;
    });
    if (this.originalData = data, this.data = data, this.progressiveRun(), !this.options.clip && this.options.enlarge && this._bounds && this.shrinkBoard(this._bounds), this._bounds && ["cardioid", "triangle", "triangle-upright"].includes(this.options.shape)) {
      const currentCenterY = (this._bounds[0].y + this._bounds[1].y) / 2;
      this._dy = -(currentCenterY - this._originSize[1] / 2);
    }
    return this.result;
  }
  formatTagItem(words) {
    const size = this._size, zoomRatio = this.zoomRatio(), globalDy = this.dy(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length, result2 = [];
    let w, t;
    for (let i = 0; i < n; ++i) w = words[i], t = {}, t.datum = w.datum, t.x = (w.x + dx) * zoomRatio, t.y = (w.y + dy + globalDy) * zoomRatio, t.fontFamily = w.fontFamily, t.fontSize = w.fontSize * zoomRatio, t.fontStyle = w.fontStyle, t.fontWeight = w.fontWeight, t.angle = w.angle, result2.push(t);
    return result2;
  }
  output() {
    return this.outputCallback ? this.outputCallback(this.formatTagItem(this.result)) : this.formatTagItem(this.result);
  }
  progressiveOutput() {
    return this.outputCallback ? this.outputCallback(this.formatTagItem(this.progressiveResult)) : this.formatTagItem(this.progressiveResult);
  }
  updateBoardExpandStatus(fontSize) {
    this._isBoardExpandCompleted = fontSize * (this._originSize[0] / this._size[0]) < this.options.minFontSize;
  }
  shouldShrinkContinue() {
    return !this.options.clip && this.options.shrink && !this._isBoardExpandCompleted;
  }
  shrinkBoard(bounds) {
    const leftTopPoint = bounds[0], rightBottomPoint = bounds[1];
    if (rightBottomPoint.x >= this._size[0] || rightBottomPoint.y >= this._size[1]) return;
    const minXValue = Math.min(leftTopPoint.x, this._size[0] - rightBottomPoint.x), minYValue = Math.min(leftTopPoint.y, this._size[1] - rightBottomPoint.y), minRatio = 2 * Math.min(minXValue / this._size[0], minYValue / this._size[1]);
    this._size = this._size.map((v) => v * (1 - minRatio));
  }
  expandBoard(board, bounds, factor) {
    const expandedLeftWidth = this._size[0] * (factor || 1.1) - this._size[0] >> 5;
    let diffWidth = 2 * expandedLeftWidth > 2 ? expandedLeftWidth : 2;
    diffWidth % 2 != 0 && diffWidth++;
    let diffHeight = Math.ceil(this._size[1] * (diffWidth << 5) / this._size[0]);
    diffHeight % 2 != 0 && diffHeight++;
    const w = this._size[0], h = this._size[1], widthArr = new Array(diffWidth).fill(0), heightArr = new Array(diffHeight / 2 * (diffWidth + (w >> 5))).fill(0);
    this.insertZerosToArray(board, h * (w >> 5), heightArr.length + diffWidth / 2);
    for (let i = h - 1; i > 0; i--) this.insertZerosToArray(board, i * (w >> 5), widthArr.length);
    this.insertZerosToArray(board, 0, heightArr.length + diffWidth / 2), this._size = [w + (diffWidth << 5), h + diffHeight], bounds && (bounds[0].x += (diffWidth << 5) / 2, bounds[0].y += diffHeight / 2, bounds[1].x += (diffWidth << 5) / 2, bounds[1].y += diffHeight / 2);
  }
  insertZerosToArray(array2, index, length2) {
    if (this.options.customInsertZerosToArray) return this.options.customInsertZerosToArray(array2, index, length2);
    const len = Math.floor(length2 / 6e4), restLen = length2 % 6e4;
    for (let i = 0; i < len; i++) array2.splice(index + 6e4 * i, 0, ...new Array(6e4).fill(0));
    array2.splice(index + 6e4 * len, 0, ...new Array(restLen).fill(0));
  }
  getContext(canvas) {
    canvas.width = 1, canvas.height = 1;
    const imageData = canvas.getContext("2d", {
      willReadFrequently: true
    }).getImageData(0, 0, 1, 1), ratio = Math.sqrt(imageData.data.length >> 2);
    canvas.width = (this.cw << 5) / ratio, canvas.height = this.ch / ratio;
    const context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    return context.fillStyle = context.strokeStyle = "red", context.textAlign = "center", {
      context,
      ratio,
      canvas
    };
  }
  place(board, tag, bounds, maxRadius) {
    let isCollide = false;
    if (this.shouldShrinkContinue() && (tag.width > this._size[0] || tag.height > this._size[1])) return this._placeStatus = 1, false;
    const dt = this.random() < 0.5 ? 1 : -1;
    if (!this.shouldShrinkContinue() && this.isSizeLargerThanMax(tag, dt)) return null;
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(this._size[0] * this._size[0] + this._size[1] * this._size[1]), s2 = this.spiral(this._size);
    let dxdy, dx, dy, _tag, t = -dt;
    for (this._tTemp = null, this._dtTemp = null; dxdy = s2(t += dt); ) {
      dx = dxdy[0], dy = dxdy[1];
      const radius = Math.sqrt(dx ** 2 + dy ** 2);
      let rad = Math.atan(dy / dx);
      dx < 0 ? rad += Math.PI : dy < 0 && (rad = 2 * Math.PI + rad);
      const rx = this.shape(rad);
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      if (radius >= maxRadius) isCollide && null === this._tTemp && (this._tTemp = t, this._dtTemp = dt);
      else {
        if (tag.x = startX + ~~(radius * rx * Math.cos(-rad)), tag.y = startY + ~~(radius * rx * Math.sin(-rad)), _tag = tag, this.options.clip) if (this.shouldShrinkContinue()) {
          if (isPartOutside(_tag, this._size)) {
            isCollide && null === this._tTemp && (this._tTemp = t, this._dtTemp = dt);
            continue;
          }
        } else {
          if (isFullOutside(_tag, this._size)) {
            isCollide && null === this._tTemp && (this._tTemp = t, this._dtTemp = dt);
            continue;
          }
          isPartOutside(_tag, this._size) && (_tag = clipInnerTag(_tag, this._size));
        }
        else if (isPartOutside(_tag, this._size)) {
          isCollide && null === this._tTemp && (this._tTemp = t, this._dtTemp = dt);
          continue;
        }
        if (isCollide = true, (!bounds || collideRects(_tag, bounds)) && (!bounds || !cloudCollide(_tag, board, this._size))) {
          const sprite = _tag.sprite, w = _tag.width >> 5, sw = this._size[0] >> 5, lx = _tag.x - (w << 4), sx = 127 & lx, msx = 32 - sx, h = _tag.y1 - _tag.y0;
          let last2, x = (_tag.y + _tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h; j++) {
            last2 = 0;
            for (let i = 0; i <= w; i++) board[x + i] |= last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0);
            x += sw;
          }
          return tag.sprite = null, _tag.sprite = null, true;
        }
      }
    }
    return null !== this._tTemp && (this._placeStatus = 3), !this.shouldShrinkContinue() && this.setCache(_tag, dt), false;
  }
  clearCache() {
    this.cacheMap.clear();
  }
  setCache(tag, dt) {
    const cacheKey = `${tag.angle}-${dt}`, w = tag.x1 - tag.x0, h = tag.y1 - tag.y0;
    if (!this.cacheMap.has(cacheKey)) return void this.cacheMap.set(cacheKey, {
      width: w,
      height: h
    });
    const { width, height } = this.cacheMap.get(cacheKey);
    (w < width && h < height || w <= width && h < height) && this.cacheMap.set(cacheKey, {
      width: w,
      height: h
    });
  }
  isSizeLargerThanMax(tag, dt) {
    const cacheKey = `${tag.angle}-${dt}`;
    if (!this.cacheMap.has(cacheKey)) return false;
    const { width, height } = this.cacheMap.get(cacheKey), w = tag.x1 - tag.x0, h = tag.y1 - tag.y0;
    return w >= width && h >= height;
  }
};
function cloudSprite(contextAndRatio, d, data, di, cw, ch) {
  if (d.sprite) return;
  const c3 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c3.setTransform(ratio, 0, 0, ratio, 0, 0), c3.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x = 0, y = 0, maxh = 0;
  const n = data.length;
  let w, w32, h, i, j;
  for (--di; ++di < n; ) {
    if (d = data[di], c3.save(), c3.font = d.fontStyle + " " + d.fontWeight + " " + ~~((d.fontSize + 1) / ratio) + "px " + d.fontFamily, w = c3.measureText(d.text + "m").width * ratio, h = d.fontSize << 1, d.angle) {
      const sr = Math.sin(d.angle), cr = Math.cos(d.angle), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5, h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else w = w + 31 >> 5 << 5;
    if (h > maxh && (maxh = h), x + w >= cw << 5 && (x = 0, y += maxh, maxh = 0), y + h >= ch) break;
    c3.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio), d.angle && c3.rotate(d.angle), c3.fillText(d.text, 0, 0), d.padding && (c3.lineWidth = 2 * d.padding, c3.strokeText(d.text, 0, 0)), c3.restore(), d.width = w, d.height = h, d.xoff = x, d.yoff = y, d.x1 = w >> 1, d.y1 = h >> 1, d.x0 = -d.x1, d.y0 = -d.y1, d.hasText = true, x += w;
  }
  const pixels = c3.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  for (; --di >= 0; ) {
    if (!(d = data[di]).hasText) continue;
    for (w = d.width, w32 = w >> 5, h = d.y1 - d.y0, i = 0; i < h * w32; i++) sprite[i] = 0;
    if (x = d.xoff, null == x) return;
    y = d.yoff;
    let seen = 0, seenRow = -1;
    for (j = 0; j < h; j++) {
      for (i = 0; i < w; i++) {
        const k2 = w32 * j + (i >> 5), m4 = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m4, seen |= m4;
      }
      seen ? seenRow = j : (d.y0++, h--, j--, y++);
    }
    d.y1 = d.y0 + seenRow, d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, size) {
  const sw = size[0] >> 5, sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = 127 & lx, msx = 32 - sx, h = tag.y1 - tag.y0;
  let last2, x = (tag.y + tag.y0) * sw + (lx >> 5);
  for (let j = 0; j < h; j++) {
    last2 = 0;
    for (let i = 0; i <= w; i++) if ((last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    x += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  const b0 = bounds[0], b1 = bounds[1];
  d.x + d.x0 < b0.x && (b0.x = d.x + d.x0), d.y + d.y0 < b0.y && (b0.y = d.y + d.y0), d.x + d.x1 > b1.x && (b1.x = d.x + d.x1), d.y + d.y1 > b1.y && (b1.y = d.y + d.y1);
}
function collideRects(a3, b) {
  return a3.x + a3.x1 > b[0].x && a3.x + a3.x0 < b[1].x && a3.y + a3.y1 > b[0].y && a3.y + a3.y0 < b[1].y;
}
CloudLayout.defaultOptions = {
  enlarge: false,
  minFontSize: 2,
  maxSingleWordTryCount: 2
};
var isFullOutside = (tag, size) => tag.x + tag.x0 > size[0] || tag.y + tag.y0 > size[0] || tag.x + tag.x1 < 0 || tag.y + tag.y1 < 0;
var isPartOutside = (tag, size) => tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1];
function clipInnerTag(tag, size) {
  const sprite = tag.sprite, h = tag.y1 - tag.y0, w = tag.width >> 5;
  let x = 0;
  const _sprite = [], js = Math.max(-(tag.y0 + tag.y), 0), je = Math.min(h + (size[1] - (tag.y1 + tag.y)), h), is = Math.max(-(tag.x0 + tag.x), 0) >> 5, ie = Math.min(w + (size[0] - (tag.x1 + tag.x) >> 5) + 1, w);
  for (let j = 0; j < h; j++) {
    for (let i = 0; i < w; i++) j < js || je <= j || i < is || ie <= i || _sprite.push(sprite[x + i]);
    x += w;
  }
  const xl = is << 5, xr = w - ie << 5, yb = js, yt = h - je;
  return Object.assign(Object.assign({}, tag), {
    width: tag.width - xl - xr,
    height: tag.height - yb - yt,
    x0: tag.x0 + xl,
    x1: tag.x1 - xr,
    y0: tag.y0 + yb,
    y1: tag.y1 - yt,
    x: tag.x + xl / 2 - xr / 2,
    sprite: _sprite
  });
}

// node_modules/@visactor/vgrammar-wordcloud/es/grid-layout.js
var GridLayout = class _GridLayout extends BaseLayout {
  constructor(options) {
    super(merge({}, _GridLayout.defaultOptions, options)), this.fillGridAt = (x, y) => {
      x >= this.ngx || y >= this.ngy || x < 0 || y < 0 || (this.grid[x][y] = false);
    }, this.updateGrid = (gx, gy, gw, gh, info) => {
      const occupied = info.occupied;
      let i = occupied.length;
      for (; i--; ) {
        const px = gx + occupied[i][0], py = gy + occupied[i][1];
        px >= this.ngx || py >= this.ngy || px < 0 || py < 0 || this.fillGridAt(px, py);
      }
    }, this.gridSize = Math.max(Math.floor(this.options.gridSize), 4);
  }
  getPointsAtRadius(radius) {
    if (this.pointsAtRadius[radius]) return this.pointsAtRadius[radius];
    const T = 8 * radius;
    let t = T;
    const points = [];
    for (0 === radius && points.push([this.center[0], this.center[1], 0]); t--; ) {
      const rx = this.shape(t / T * 2 * Math.PI);
      points.push([this.center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), this.center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * this.options.ellipticity, t / T * 2 * Math.PI]);
    }
    return this.pointsAtRadius[radius] = points, points;
  }
  getTextInfo(item, shrinkRatio = 1, index) {
    var _a;
    const sizeShrinkRatio = this.options.clip ? 1 : shrinkRatio, fontSize = Math.max(Math.floor((this.isTryRepeatFill ? this.options.fillTextFontSize : this.getTextFontSize(item)) * sizeShrinkRatio), this.options.minFontSize);
    let word = this.getText(item) + "";
    if (this.options.clip && (word = word.slice(0, Math.ceil(word.length * shrinkRatio))), !word) return null;
    const fontWeight = this.getTextFontWeight(item), fontStyle = this.getTextFontStyle(item), angle2 = this.getTextRotate && null !== (_a = this.getTextRotate(item, index)) && void 0 !== _a ? _a : 0, fontFamily = this.getTextFontFamily(item), fcanvas = document.createElement("canvas"), fctx = fcanvas.getContext("2d", {
      willReadFrequently: true
    });
    fctx.font = fontStyle + " " + fontWeight + " " + fontSize.toString(10) + "px " + fontFamily;
    const fw = fctx.measureText(word).width, fh = Math.max(fontSize, fctx.measureText("m").width, fctx.measureText("Ｗ").width);
    let boxWidth = fw + 2 * fh, boxHeight = 3 * fh;
    const fgw = Math.ceil(boxWidth / this.gridSize), fgh = Math.ceil(boxHeight / this.gridSize);
    boxWidth = fgw * this.gridSize, boxHeight = fgh * this.gridSize;
    const fillTextOffsetX = -fw / 2, fillTextOffsetY = 0.4 * -fh, cgh = Math.ceil((boxWidth * Math.abs(Math.sin(angle2)) + boxHeight * Math.abs(Math.cos(angle2))) / this.gridSize), cgw = Math.ceil((boxWidth * Math.abs(Math.cos(angle2)) + boxHeight * Math.abs(Math.sin(angle2))) / this.gridSize), width = cgw * this.gridSize, height = cgh * this.gridSize;
    fcanvas.setAttribute("width", "" + width), fcanvas.setAttribute("height", "" + height), fctx.scale(1, 1), fctx.translate(width / 2, height / 2), fctx.rotate(-angle2), fctx.font = fontStyle + " " + fontWeight + " " + fontSize.toString(10) + "px " + fontFamily, fctx.fillStyle = "#000", fctx.textBaseline = "middle", fctx.fillText(word, fillTextOffsetX, fillTextOffsetY);
    const imageData = fctx.getImageData(0, 0, width, height).data;
    if (this.exceedTime()) return null;
    const occupied = [];
    let gy, gx = cgw;
    const bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2], singleGridLoop = (gx2, gy2, out) => {
      let y = this.gridSize;
      for (; y--; ) {
        let x = this.gridSize;
        for (; x--; ) if (imageData[4 * ((gy2 * this.gridSize + y) * width + (gx2 * this.gridSize + x)) + 3]) return out.push([gx2, gy2]), gx2 < bounds[3] && (bounds[3] = gx2), gx2 > bounds[1] && (bounds[1] = gx2), gy2 < bounds[0] && (bounds[0] = gy2), void (gy2 > bounds[2] && (bounds[2] = gy2));
      }
    };
    for (; gx--; ) for (gy = cgh; gy--; ) singleGridLoop(gx, gy, occupied);
    return {
      datum: item,
      occupied,
      bounds,
      gw: cgw,
      gh: cgh,
      fillTextOffsetX,
      fillTextOffsetY,
      fillTextWidth: fw,
      fillTextHeight: fh,
      fontSize,
      fontStyle,
      fontWeight,
      fontFamily,
      angle: angle2,
      text: word
    };
  }
  calculateEmptyRate() {
    const totalCount = this.ngx * this.ngy;
    let emptyCount = 0;
    for (let gx = 0; gx < this.ngx; gx++) for (let gy = 0; gy < this.ngy; gy++) this.grid[gx][gy] && emptyCount++;
    return emptyCount / totalCount;
  }
  canFitText(gx, gy, gw, gh, occupied) {
    let i = occupied.length;
    for (; i--; ) {
      const px = gx + occupied[i][0], py = gy + occupied[i][1];
      if (px >= this.ngx || py >= this.ngy || px < 0 || py < 0) {
        if (!this.options.drawOutOfBound) return false;
      } else if (!this.grid[px][py]) return false;
    }
    return true;
  }
  layoutWord(index, shrinkRatio = 1) {
    const item = this.data[index], info = this.getTextInfo(item, shrinkRatio, index);
    if (!info) return false;
    if (this.exceedTime()) return false;
    if (!this.options.drawOutOfBound && (!this.options.shrink || info.fontSize <= this.options.minFontSize) && !this.options.clip) {
      const bounds = info.bounds;
      if (bounds[1] - bounds[3] + 1 > this.ngx || bounds[2] - bounds[0] + 1 > this.ngy) return false;
    }
    let r = this.maxRadius + 1;
    const tryToPutWordAtPoint = (gxy) => {
      const gx = Math.floor(gxy[0] - info.gw / 2), gy = Math.floor(gxy[1] - info.gh / 2), gw = info.gw, gh = info.gh;
      return !!this.canFitText(gx, gy, gw, gh, info.occupied) && (info.distance = this.maxRadius - r, info.theta = gxy[2], this.outputText(gx, gy, info), this.updateGrid(gx, gy, gw, gh, info), true);
    };
    for (; r--; ) {
      let points = this.getPointsAtRadius(this.maxRadius - r);
      this.options.random && (points = [].concat(points), shuffleArray(points));
      if (points.some(tryToPutWordAtPoint)) return true;
    }
    return (this.options.clip || !!(this.options.shrink && info.fontSize > this.options.minFontSize)) && this.layoutWord(index, 0.75 * shrinkRatio);
  }
  outputText(gx, gy, info) {
    const color = this.getTextColor(info), output = {
      text: info.text,
      datum: info.datum,
      color,
      fontStyle: info.fontStyle,
      fontWeight: info.fontWeight,
      fontFamily: info.fontFamily,
      angle: info.angle,
      width: info.fillTextWidth,
      height: info.fillTextHeight,
      x: (gx + info.gw / 2) * this.gridSize,
      y: (gy + info.gh / 2) * this.gridSize + info.fillTextOffsetY + 0.5 * info.fontSize,
      fontSize: info.fontSize
    };
    this.result.push(output), this.progressiveResult && this.progressiveResult.push(output);
  }
  initGrid(config2) {
    this.grid = [];
    const shape = this.options.shape;
    if (isObject_default(shape)) {
      const canvas = generateMaskCanvas(shape, config2.width, config2.height);
      let imageData = canvas.getContext("2d").getImageData(0, 0, this.ngx * this.gridSize, this.ngy * this.gridSize);
      this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(canvas);
      let i, isEmptyPixel = generateIsEmptyPixel(shape.backgroundColor);
      const singleGridLoop = (gx2, gy) => {
        let y = this.gridSize;
        for (; y--; ) {
          let x = this.gridSize;
          for (; x--; ) if (i = 4, !isEmptyPixel(imageData, gy * this.gridSize + y, gx2 * this.gridSize + x)) return void (this.grid[gx2][gy] = true);
        }
        this.grid[gx2][gy] = false;
      };
      let gx = this.ngx;
      for (; gx--; ) {
        this.grid[gx] = [];
        let gy = this.ngy;
        for (; gy--; ) singleGridLoop(gx, gy), false !== this.grid[gx][gy] && (this.grid[gx][gy] = true);
      }
      imageData = isEmptyPixel = void 0;
    } else {
      let gx = this.ngx;
      for (; gx--; ) {
        this.grid[gx] = [];
        let gy = this.ngy;
        for (; gy--; ) this.grid[gx][gy] = true;
      }
    }
  }
  canRepeat() {
    return this.calculateEmptyRate() > 1e-3;
  }
  layout(data, config2) {
    this.initProgressive(), this.drawnCount = 0, this.isTryRepeatFill = false, this.originalData = data, this.data = data, this.pointsAtRadius = [], this.ngx = Math.floor(config2.width / this.gridSize), this.ngy = Math.floor(config2.height / this.gridSize);
    const { center: center2, maxRadius } = getMaxRadiusAndCenter(this.options.shape, [config2.width, config2.height]);
    return this.center = config2.origin ? [config2.origin[0] / this.gridSize, config2.origin[1] / this.gridSize] : [center2[0] / this.gridSize, center2[1] / this.gridSize], this.maxRadius = Math.floor(maxRadius / this.gridSize), this.initGrid(config2), this.result = [], this.progressiveRun();
  }
};
GridLayout.defaultOptions = {
  gridSize: 8,
  ellipticity: 1,
  maxSingleWordTryCount: 1
};

// node_modules/@visactor/vgrammar-wordcloud/es/fast-layout.js
var FastLayout = class _FastLayout extends BaseLayout {
  constructor(options) {
    super(merge({}, _FastLayout.defaultOptions, options)), this.random = this.options.random ? Math.random : () => 0, this.aspectRatio = 1;
  }
  fit(word) {
    for (let i = 0, len = this.result.length; i < len; i++) if (isOverlap(word, this.result[i])) return false;
    return true;
  }
  getTextInfo(datum, index) {
    const info = {
      datum,
      fontSize: this.getTextFontSize(datum),
      fontWeight: this.getTextFontWeight(datum),
      fontStyle: this.getTextFontStyle(datum),
      fontFamily: this.getTextFontFamily(datum),
      angle: this.getTextRotate(datum, index),
      text: this.getText(datum) + "",
      x: this.center[0],
      y: this.center[1]
    }, bounds = getTextBounds(info);
    return info.width = bounds.width(), info.height = bounds.height(), info.top = this.center[1] - info.height + 0.21 * info.height, info.left = this.center[0] - info.width / 2, info;
  }
  layoutWord(index) {
    const info = this.getTextInfo(this.data[index], index);
    let angle2 = 2 * Math.PI, radius = 0, left2 = info.left, top = info.top;
    const width = info.width, height = info.height;
    let rx = 1, isFit = this.fit(info);
    for (; !isFit && radius < this.maxRadius; ) radius += 0.5, rx = this.shape(radius / this.maxRadius * 2 * Math.PI), angle2 += 0.5 * (this.options.random ? this.random() > 0.5 ? 1 : -1 : index % 2 == 0 ? 1 : -1), left2 = this.center[0] - width / 2 + radius * rx * Math.cos(angle2) * this.aspectRatio, top = this.center[1] - height / 2 + radius * rx * Math.sin(angle2), info.left = left2, info.top = top, info.x = left2 + width / 2, info.y = top + height / 2, isFit = this.fit(info);
    return !!isFit && (!!(this.options.clip || info.left >= 0 && info.left + info.width <= this.width && info.top >= 0 && info.top + info.height <= this.height) && (this.result.push(info), true));
  }
  layout(data, config2) {
    if (!(null == data ? void 0 : data.length)) return [];
    this.initProgressive(), this.result = [], this.maxRadius = Math.sqrt(config2.width * config2.width + config2.height * config2.height) / 2, this.center = [config2.width / 2, config2.height / 2], this.width = config2.width, this.height = config2.height, this.data = data.sort((a3, b) => this.getTextFontSize(b) - this.getTextFontSize(a3));
    let i = 0;
    for (; i < data.length; ) {
      this.layoutWord(i);
      if (i++, this.progressiveIndex = i, this.exceedTime()) break;
    }
    return this.result;
  }
};
function isOverlap(a3, b) {
  return !(a3.left + a3.width < b.left || a3.top + a3.height < b.top || a3.left > b.left + b.width || a3.top > b.top + b.height);
}
FastLayout.defaultOptions = {
  enlarge: false
};

// node_modules/@visactor/vgrammar-wordcloud/es/wordcloud.js
var OUTPUT = {
  x: "x",
  y: "y",
  z: "z",
  fontFamily: "fontFamily",
  fontSize: "fontSize",
  fontStyle: "fontStyle",
  fontWeight: "fontWeight",
  angle: "angle"
};
var transform22 = (options, upstreamData) => {
  var _a, _b, _c, _d, _e, _f;
  if (options.size && (options.size[0] <= 0 || options.size[1] <= 0)) {
    return Logger.getInstance().info("Wordcloud size dimensions must be greater than 0"), [];
  }
  const data = upstreamData, canvasSize = (null !== (_a = options.size) && void 0 !== _a ? _a : [500, 500]).slice();
  canvasSize[0] = Math.floor(canvasSize[0]), canvasSize[1] = Math.floor(canvasSize[1]);
  const fontFamily = options.fontFamily ? field3(options.fontFamily) : "sans-serif", fontStyle = options.fontStyle ? field3(options.fontStyle) : "normal", fontWeight = options.fontWeight ? field3(options.fontWeight) : "normal", rotate = options.rotate ? field3(options.rotate) : 0, text2 = field3(options.text), spiral = null !== (_b = options.spiral) && void 0 !== _b ? _b : "archimedean", padding = options.padding ? field3(options.padding) : 1, shape = null !== (_c = options.shape) && void 0 !== _c ? _c : "square", shrink = null !== (_d = options.shrink) && void 0 !== _d && _d, enlarge = null !== (_e = options.enlarge) && void 0 !== _e && _e, clip = null !== (_f = options.clip) && void 0 !== _f && _f, minFontSize = options.minFontSize, randomVisible = options.randomVisible, as = options.as ? Object.assign(Object.assign({}, OUTPUT), options.as) : OUTPUT, depth_3d = options.depth_3d, postProjection = options.postProjection;
  let fontSize = options.fontSize ? field3(options.fontSize) : 14;
  const fontSizeRange = options.fontSizeRange;
  if (fontSizeRange && !isNumber_default(fontSize)) {
    const fsize = fontSize, fontSizeSqrtScale = generateScale(extent2(fsize, data), fontSizeRange);
    fontSize = (datum) => fontSizeSqrtScale(fsize(datum));
  }
  let Layout3 = CloudLayout;
  "fast" === options.layoutType ? Layout3 = FastLayout : "grid" === options.layoutType && (Layout3 = GridLayout);
  const layout2 = new Layout3(Object.assign(Object.assign({}, options), {
    text: text2,
    padding,
    spiral,
    shape,
    rotate,
    fontFamily,
    fontStyle,
    fontWeight,
    fontSize,
    shrink,
    clip,
    enlarge,
    minFontSize,
    random: randomVisible,
    outputCallback: (words) => {
      const res = [];
      let t, w;
      for (let i = 0, len = words.length; i < len; i++) w = words[i], t = w.datum, t[as.x] = w.x, t[as.y] = w.y, t[as.fontFamily] = w.fontFamily, t[as.fontSize] = w.fontSize, t[as.fontStyle] = w.fontStyle, t[as.fontWeight] = w.fontWeight, t[as.angle] = w.angle, "StereographicProjection" === postProjection && stereographicProjection(canvasSize, w, t, as, depth_3d), options.dataIndexKey && (t[options.dataIndexKey] = `${i}`), res.push(t);
      return res;
    }
  }));
  return layout2.layout(data, {
    width: canvasSize[0],
    height: canvasSize[1]
  }), options.progressiveStep > 0 || options.progressiveTime > 0 ? {
    progressive: layout2
  } : layout2.output();
};
var field3 = (option) => isString_default(option) || isNumber_default(option) || isFunction_default(option) || isArray_default(option) ? option : (datum) => datum[option.field];
var sqrt4 = (x) => x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
var generateScale = (domain, range2, type) => {
  if (domain[0] === domain[1]) return (datum) => range2[0];
  const s0 = sqrt4(domain[0]), s1 = sqrt4(domain[1]), min3 = Math.min(s0, s1), max3 = Math.max(s0, s1);
  return (datum) => (sqrt4(datum) - min3) / (max3 - min3) * (range2[1] - range2[0]) + range2[0];
};
var extent2 = (field5, data) => {
  let min3 = 1 / 0, max3 = -1 / 0;
  const n = data.length;
  let v;
  for (let i = 0; i < n; ++i) v = toNumber(field5(data[i])), v < min3 && (min3 = v), v > max3 && (max3 = v);
  return 1 === data.length && min3 === max3 && (min3 -= 1e4), [min3, max3];
};
function stereographicProjection(canvasSize, w, t, as, depth_3d) {
  const r = Math.max(canvasSize[0], canvasSize[1]) / 2, out = _StereographicProjection(canvasSize[0], canvasSize[1], r, {
    x: r,
    y: r,
    z: null != depth_3d ? depth_3d : r
  }, w);
  t[as.x] = out.x, t[as.y] = out.y, t[as.z] = out.z;
}
function _StereographicProjection(w, h, r, center2, word) {
  const { x, y } = word, theta = x / w * Math.PI * 2;
  let phi = Math.PI - y / h * Math.PI;
  phi += (phi < Math.PI / 2 ? 1 : -1) * Math.pow(Math.min(phi - Math.PI / 2, 1), 2) / 5;
  return {
    x: r * Math.sin(phi) * Math.cos(theta) + center2.x,
    y: r * Math.cos(phi) + center2.y,
    z: r * Math.sin(phi) * Math.sin(theta) + center2.z
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/index.js
var registerWordCloudTransforms = () => {
  Factory3.registerTransform("wordcloud", {
    transform: transform22,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js
var WORDCLOUD_SHAPE_HOOK_EVENT;
!function(WORDCLOUD_SHAPE_HOOK_EVENT2) {
  WORDCLOUD_SHAPE_HOOK_EVENT2.BEFORE_WORDCLOUD_SHAPE_LAYOUT = "beforeWordcloudShapeLayout", WORDCLOUD_SHAPE_HOOK_EVENT2.AFTER_WORDCLOUD_SHAPE_LAYOUT = "afterWordcloudShapeLayout", WORDCLOUD_SHAPE_HOOK_EVENT2.AFTER_WORDCLOUD_SHAPE_DRAW = "afterWordcloudShapeDraw";
}(WORDCLOUD_SHAPE_HOOK_EVENT || (WORDCLOUD_SHAPE_HOOK_EVENT = {}));
var colorListEqual = (arr0, arr1) => {
  if (1 === arr1.length && "#537EF5" === arr1[0]) return true;
  if (!Array.isArray(arr0) || !Array.isArray(arr1) || arr0.length !== arr1.length) return false;
  for (let i = 0; i < arr0.length; i++) if (arr0[i] !== arr1[i]) return false;
  return true;
};
var fakeRandom = () => {
  let i = -1;
  const arr = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
  return () => (i = (i + 1) % arr.length, arr[i]);
};
var isChinese = (text2) => /^[\u4e00-\u9fa5]+$/.test(text2);
var calTextLength = (text2, textLengthLimit) => {
  if (isNil_default(text2)) return 0;
  let length2 = 0;
  for (const char of text2) isChinese(char) ? length2 += 1 : length2 += 0.53;
  return length2;
};
function loadImage(url) {
  return url && (isValidUrl_default(url) || isBase64_default(url) || url.startsWith("<svg")) ? new Promise((resolve, reject) => {
    var _a;
    const imageMark = createImage({
      image: url
    }), imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);
    imgData && "success" === imgData.state && imgData.data ? resolve(imgData.data) : (imageMark.successCallback = () => {
      var _a2;
      if (imageMark) {
        const imgData2 = null === (_a2 = imageMark.resources) || void 0 === _a2 ? void 0 : _a2.get(url);
        imgData2 && "success" === imgData2.state && imgData2.data ? resolve(imgData2.data) : reject(new Error("image load failed" + url));
      } else reject(new Error("image load failed" + url));
    }, imageMark.failCallback = () => {
      Logger.getInstance().error("image 加载失败！", url);
    });
  }) : null;
}
function functor2(d) {
  return "function" == typeof d ? d : function() {
    return d;
  };
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js
function segmentation(segmentationInput) {
  const { size, maskCanvas } = segmentationInput, imageData = maskCanvas.getContext("2d", {
    willReadFrequently: true
  }).getImageData(0, 0, maskCanvas.width, maskCanvas.height), labels = new Array(size[0] * size[1]).fill(0);
  let curLabel = 1;
  const offset = [[0, 1], [1, 0], [-1, 0], [0, -1]];
  let queue = [];
  for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) if (0 === labels[i * size[0] + j] && !segmentationInput.isEmptyPixel(imageData, i, j)) {
    labels[i * size[0] + j] = curLabel, queue.push([i, j]);
    for (let k2 = 0; k2 < queue.length; k2++) for (let m4 = 0; m4 < 4; m4++) {
      let row = queue[k2][0] + offset[m4][0], col = queue[k2][1] + offset[m4][1];
      row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 !== labels[row * size[0] + col] || segmentationInput.isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, queue.push([row, col]));
    }
    curLabel++, queue = [];
  }
  const boundaries = {}, areas = {}, centers = {}, maxPoints = {}, maxR = {}, ratios = {}, shapeBounds = {
    x1: 1 / 0,
    x2: -1 / 0,
    y1: 1 / 0,
    y2: -1 / 0,
    width: 0,
    height: 0
  };
  for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {
    const label = labels[i * size[0] + j];
    0 !== label && (isBoundaryPixel(i, j) && (boundaries[label] = boundaries[label] || [], boundaries[label].push([j, i]), maxPoints[label] || (maxPoints[label] = [1 / 0, -1 / 0, 1 / 0, -1 / 0]), i < maxPoints[label][0] && (maxPoints[label][0] = i), i > maxPoints[label][1] && (maxPoints[label][1] = i), j < maxPoints[label][2] && (maxPoints[label][2] = j), j > maxPoints[label][3] && (maxPoints[label][3] = j), j < shapeBounds.x1 && (shapeBounds.x1 = j), j > shapeBounds.x2 && (shapeBounds.x2 = j), i < shapeBounds.y1 && (shapeBounds.y1 = i), i > shapeBounds.y2 && (shapeBounds.y2 = i)), areas[label] = areas[label] || 0, areas[label]++);
  }
  const allBoundaries = [];
  for (const label in boundaries) {
    const boundary = boundaries[label], x2 = ~~(boundary.reduce((acc, cur) => acc + cur[0], 0) / boundary.length), y2 = ~~(boundary.reduce((acc, cur) => acc + cur[1], 0) / boundary.length);
    centers[label] = [x2, y2], allBoundaries.push(...boundary);
    const [yMin, yMax, xMin, xMax] = maxPoints[label];
    maxR[label] = ~~Math.max(Math.sqrt((x2 - xMin) ** 2 + (y2 - yMin) ** 2), Math.sqrt((x2 - xMax) ** 2 + (y2 - yMax) ** 2), Math.sqrt((x2 - xMin) ** 2 + (y2 - yMax) ** 2), Math.sqrt((x2 - xMax) ** 2 + (y2 - yMin) ** 2)), ratios[label] = (xMax - xMin) / (yMax - yMin);
  }
  const regions = Object.keys(centers).map((key) => ({
    label: key - 1,
    boundary: boundaries[key],
    area: areas[key],
    center: centers[key],
    maxPoint: maxPoints[key],
    maxR: maxR[key],
    ratio: ratios[key]
  }));
  shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;
  const x = ~~(allBoundaries.reduce((acc, cur) => acc + cur[0], 0) / allBoundaries.length), y = ~~(allBoundaries.reduce((acc, cur) => acc + cur[1], 0) / allBoundaries.length), shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2)), shapeRatio = shapeBounds.width / shapeBounds.height, shapeArea = Object.keys(areas).reduce((acc, key) => acc + areas[key], 0), segmentation2 = {
    regions,
    labels,
    labelNumber: curLabel - 1
  };
  return Object.assign(segmentationInput, {
    segmentation: segmentation2,
    shapeBounds,
    shapeMaxR,
    shapeRatio,
    shapeCenter: [x, y],
    shapeArea
  });
  function isBoundaryPixel(i, j) {
    const offset2 = [[0, 1], [1, 0], [-1, 0], [0, -1]];
    if (0 === i || 0 === j || i === size[1] - 1 || j === size[0] - 1) return true;
    for (let k2 = 0; k2 < 4; k2++) {
      let row = i + offset2[k2][0], col = j + offset2[k2][1];
      if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 === labels[row * size[0] + col]) return true;
    }
    return false;
  }
}
function removeBorder(image, canvas, isEmptyPixel) {
  canvas.width = image.width, canvas.height = image.height;
  const ctx = canvas.getContext("2d", {
    willReadFrequently: true
  });
  ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);
  const width = canvas.width, imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let top = 0, bottom = imageData.height, left2 = 0, right2 = imageData.width;
  const rowBlank = (width2, y) => {
    for (let x = 0; x < width2; ++x) if (!isEmptyPixel(imageData, y, x)) return false;
    return true;
  }, columnBlank = (x, y0, y1) => {
    for (let y = y0; y < y1; ++y) if (!isEmptyPixel(imageData, y, x)) return false;
    return true;
  };
  for (; top < bottom && rowBlank(width, top); ) ++top;
  for (; bottom - 1 > top && rowBlank(width, bottom - 1); ) --bottom;
  for (; left2 < right2 && columnBlank(left2, top, bottom); ) ++left2;
  for (; right2 - 1 > left2 && columnBlank(right2 - 1, top, bottom); ) --right2;
  const trimmed = ctx.getImageData(left2, top, right2 - left2, bottom - top);
  return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.putImageData(trimmed, 0, 0), canvas;
}
function scaleAndMiddleShape(image, size) {
  const width = image.width, height = image.height;
  let scale4 = size[0] / width;
  height * scale4 > size[1] && (scale4 = size[1] / height);
  const newWidth = Math.floor(scale4 * width), newHeight = Math.floor(scale4 * height);
  return {
    x: (size[0] - newWidth) / 2,
    y: (size[1] - newHeight) / 2,
    width: newWidth,
    height: newHeight,
    scale: scale4
  };
}
function allocateWords(words, segmentationOutput) {
  const { segmentation: { regions } } = segmentationOutput;
  let areaMax = -1 / 0, totalArea = 0, areaMaxIndex = 0;
  regions.forEach((region, index) => {
    const area2 = region.area;
    area2 > areaMax && (areaMax = area2, areaMaxIndex = index), totalArea += area2;
  });
  let wordsSum = 0;
  regions.forEach((region) => {
    const area2 = region.area, regionNum = Math.ceil(area2 / totalArea * words.length), regionWeight = area2 / areaMax;
    region.words = [], region.regionNum = regionNum, region.regionWeight = regionWeight, wordsSum += regionNum;
  }), wordsSum < words.length && (regions[areaMaxIndex].wordsNum += words.length - wordsSum);
  let currIndex = areaMaxIndex;
  const regionNums = regions.map((region) => region.regionNum);
  words.forEach((word) => {
    let failCounter = 0, updateCounter = 0;
    word.regionIndex = -1;
    do {
      if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {
        word.regionIndex = currIndex, regions[currIndex].words.push(word), regionNums[currIndex]--, currIndex = (currIndex + 1) % regions.length;
        break;
      }
      currIndex = (currIndex + 1) % regions.length, failCounter++, updateCounter++, updateCounter > regions.length + 1 && (regions.forEach((region) => {
        region.regionWeight += 0.15;
      }), updateCounter = 0);
    } while (-1 === word.regionIndex && failCounter < 3 * regions.length);
    -1 === word.regionIndex && (word.regionIndex = areaMaxIndex, regions[areaMaxIndex].words.push(word), regionNums[areaMaxIndex]--);
  }), regions.forEach((region) => {
    region.words.sort((a3, b) => b.weight - a3.weight);
  });
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js
function layout(words, layoutConfig, segmentationOutput) {
  const { size, stepFactor } = layoutConfig, { segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, board = initBoardWithShape(segmentationOutput), ctx = canvas.getContext("2d", {
    willReadFrequently: true
  });
  for (const region of regions) {
    const { words: regionWords, center: center2, maxR, ratio } = region;
    for (let i = 0; i < regionWords.length; i++) {
      measureSprite(canvas, ctx, words, i);
      const word = regionWords[i];
      word.x = center2[0], word.y = center2[1], word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i = 0; i < failedWords.length; i++) {
      const word = failedWords[i];
      measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function layoutGlobalShrink(words, layoutConfig, segmentationOutput) {
  const { stepFactor, importantWordCount, globalShinkLimit } = layoutConfig, { size, segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, ctx = canvas.getContext("2d", {
    willReadFrequently: true
  }), boardOrigin = initBoardWithShape(segmentationOutput);
  let board = boardOrigin.slice(0);
  const fontFactor = layoutConfig.fontSizeShrinkFactor;
  let id = null, idIntialFactor = 1, globalShinkFactor = 1;
  const importantCount = importantWordCount;
  let weightStd = 0;
  if (words.length > importantCount) {
    weightStd = words.sort((word0, word1) => word1.weight - word0.weight)[importantCount].weight;
  }
  for (let k2 = 0; k2 < regions.length; k2++) {
    const region = regions[k2], { words: regionWords, center: center2, maxR, ratio } = region;
    let restartTag = false;
    for (let i = 0; i < regionWords.length; i++) {
      measureSprite(canvas, ctx, words, i);
      const word = regionWords[i];
      if (word.x = center2[0], word.y = center2[1], !word.skip && word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = true;
      else {
        if (!word.skip && word.weight > weightStd && globalShinkFactor > globalShinkLimit) {
          const wordId = word.datum[Symbol.for("vGrammar_id")];
          wordId !== id && (id = wordId, idIntialFactor = globalShinkFactor), globalShinkFactor *= fontFactor, words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize * fontFactor;
          }), board = boardOrigin.slice(0), restartTag = true;
          break;
        }
        if (!word.skip && word.datum[Symbol.for("vGrammar_id")] === id) {
          words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize / globalShinkFactor;
          }), word.skip = true, globalShinkFactor = idIntialFactor, id = null, board = boardOrigin.slice(0), restartTag = true;
          break;
        }
      }
    }
    restartTag && (k2 = -1);
  }
  for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i = 0; i < failedWords.length; i++) {
      const word = failedWords[i];
      measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function layoutSelfEnlarge(words, layoutConfig, segmentationOutput) {
  const { size, stepFactor, importantWordCount } = layoutConfig, { segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, ctx = canvas.getContext("2d", {
    willReadFrequently: true
  }), boardOrigin = initBoardWithShape(segmentationOutput);
  let board = boardOrigin.slice(0);
  const fontFactor = layoutConfig.fontSizeEnlargeFactor, importantCount = Math.min(importantWordCount, words.length);
  let weightStd = 0;
  if (words.length > importantCount) {
    weightStd = words.sort((word0, word1) => word1.weight - word0.weight)[importantCount - 1].weight;
  }
  let importantWordSuccessedNum = 0, globalEnlargeFactor = 1, layoutFinish = false;
  for (let k2 = 0; k2 < regions.length; k2++) {
    const region = regions[k2], { words: regionWords, center: center2, maxR, ratio } = region;
    let restartTag = false;
    for (let i = 0; i < regionWords.length; i++) {
      measureSprite(canvas, ctx, words, i);
      const word = regionWords[i];
      if (word.x = center2[0], word.y = center2[1], word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor)) {
        if (word.hasPlaced = true, word.weight >= weightStd && importantWordSuccessedNum++, importantWordSuccessedNum >= importantCount && !layoutFinish) {
          globalEnlargeFactor *= fontFactor, words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize * fontFactor;
          }), board = boardOrigin.slice(0), restartTag = true, importantWordSuccessedNum = 0;
          break;
        }
      } else {
        if (word.weight >= weightStd && globalEnlargeFactor > 1) {
          words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize / fontFactor;
          }), globalEnlargeFactor /= fontFactor, layoutFinish = true, board = boardOrigin.slice(0), restartTag = true;
          break;
        }
        if (word.weight >= weightStd) return layoutGlobalShrink(words, layoutConfig, segmentationOutput);
      }
    }
    restartTag && (k2 = -1);
  }
  for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i = 0; i < failedWords.length; i++) {
      const word = failedWords[i];
      measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function place2(board, word, maxR, ratio, size, boardSize, stepFactor) {
  const startX = word.x, startY = word.y, spiral = archimedeanSpiral2(ratio), dt = 1 * stepFactor;
  let dxdy, dx, dy, t = -dt;
  for (; dxdy = spiral(t += dt); ) {
    const { wordSize, bounds: { dTop, dBottom, dLeft, dRight } } = word;
    if (dx = dxdy[0], dy = dxdy[1], Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) break;
    if (word.x = ~~(startX + dx), word.y = ~~(startY + dy), !(word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || isCollideWithBoard(word, board, boardSize))) return placeWordOnBoard(word, board, boardSize), true;
  }
  return false;
}
function placeWordOnBoard(word, board, boardSize) {
  const { wordSize } = word, sprite = word.sprite, w = wordSize[0] >> 5, sw = boardSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];
  let last2, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
  if (0 === sx) for (let j = 0; j < h; j++) {
    for (let i = 0; i < w; i++) board[x + i] |= sprite[j * w + i];
    x += sw;
  }
  else for (let j = 0; j < h; j++) {
    last2 = 0;
    for (let i = 0; i <= w; i++) board[x + i] |= last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0);
    x += sw;
  }
}
function isCollideWithBoard(word, board, boardSize) {
  const { sprite, wordSize } = word, sw = boardSize[0] >> 5, w = wordSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];
  let last2, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
  if (0 === sx) for (let j = 0; j < h; j++) {
    for (let i = 0; i < w; i++) if (board[x + i] & sprite[j * w + i]) return true;
    x += sw;
  }
  else for (let j = 0; j < h; j++) {
    last2 = 0;
    for (let i = 0; i <= w; i++) if ((last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    x += sw;
  }
  return false;
}
function archimedeanSpiral2(ratio) {
  return function(t) {
    return [ratio * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function measureSprite(canvas, ctx, words, wi) {
  if (words[wi].sprite || 0 === words[wi].fontSize) return;
  const cw = 2048, radians = Math.PI / 180, n = words.length;
  canvas.width = cw, canvas.height = 2048, ctx.clearRect(0, 0, cw, 2048), ctx.textAlign = "center";
  let wordW, wordH, x = 0, y = 0, maxHeight = 0, yMax = 0;
  const wiDist = wi;
  for (--wi; ++wi < n; ) {
    const word = words[wi], fontSize = Math.max(word.fontSize, 2);
    if (ctx.save(), ctx.font = word.fontStyle + " " + word.fontWeight + " " + fontSize + "px " + word.fontFamily, wordW = ctx.measureText(word.text + "m").width + 2 * word.padding, wordH = 2 * fontSize + 2 * word.padding, 0 !== word.rotate) {
      const sr = Math.sin(word.rotate * radians), cr = Math.cos(word.rotate * radians), wcr = wordW * cr, wsr = wordW * sr, hcr = wordH * cr, hsr = wordH * sr;
      wordW = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)), wordH = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    }
    if (wordW = wordW + 31 >> 5 << 5, wordH = Math.ceil(wordH), wordH > maxHeight && (maxHeight = wordH), x + wordW >= cw && (x = 0, y += maxHeight, maxHeight = wordH), y + wordH >= 2048) {
      if (0 === y) {
        word.hasText = false;
        continue;
      }
      break;
    }
    y + wordH >= yMax && (yMax = y + wordH), ctx.translate(x + (wordW >> 1), y + (wordH >> 1)), 0 !== word.rotate && ctx.rotate(word.rotate * radians), ctx.fillText(word.text, 0, 0), word.padding && (ctx.lineWidth = 2 * word.padding, ctx.strokeText(word.text, 0, 0)), ctx.restore(), word.LT = [x, y], word.wordSize = [wordW, wordH], word.hasText = true, x += wordW;
  }
  if (0 === yMax) return;
  const pixels = ctx.getImageData(0, 0, cw, yMax).data;
  let i, j;
  for (; --wi >= wiDist; ) {
    const word = words[wi];
    if (!word.hasText) {
      word.bounds = {
        dTop: 1 / 0,
        dBottom: -1 / 0,
        dLeft: 1 / 0,
        dRight: -1 / 0
      };
      break;
    }
    const { LT = [0, 0], wordSize } = word;
    [x, y] = LT;
    const w32 = wordSize[0] >> 5, sprite = new Array(w32 * wordSize[1]).fill(0);
    let [dTop, dBottom, dLeft, dRight] = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
    for (j = 0; j < wordSize[1]; j++) {
      let seen;
      for (i = 0; i < wordSize[0]; i++) if (pixels[4 * ((y + j) * cw + (x + i)) + 3] > 0) {
        const m4 = 1 << 31 - i % 32;
        sprite[w32 * j + (i >> 5)] |= m4, i < dLeft && (dLeft = i), i > dRight && (dRight = i), seen |= m4;
      }
      seen && (j < dTop && (dTop = j), j > dBottom && (dBottom = j));
    }
    word.bounds = {
      dTop: (wordSize[1] >> 1) - dTop,
      dBottom: dBottom - (wordSize[1] >> 1),
      dLeft: (wordSize[0] >> 1) - dLeft,
      dRight: dRight - (wordSize[0] >> 1)
    }, word.sprite = sprite, delete word.LT;
  }
}
function initBoardWithShape(segmentationOutput) {
  const { segmentation: { labels }, boardSize, size } = segmentationOutput, w32 = boardSize[0] >> 5, board = new Array(w32 * size[1]).fill(0);
  for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {
    if (0 === labels[i * size[0] + j]) {
      const m4 = 1 << 31 - j % 32;
      board[w32 * i + (j >> 5)] |= m4;
    }
  }
  if (boardSize[0] > size[0]) {
    const m4 = (1 << boardSize[0] - size[0]) - 1;
    for (let y = 0; y < size[1]; y++) {
      board[w32 * y + w32 - 1] |= m4;
    }
  }
  return board;
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js
function filling(words, layoutConfig, segmentationOutput) {
  const { size, fillingTimes, fillingXStep, fillingYStep, getFillingFontStyle, getFillingFontWeight, getFillingFontFamily, fillingInitialFontSize, fillingDeltaFontSize, fillingInitialOpacity, fillingDeltaOpacity, fillingRotateList, getFillingPadding, random: random2, board, minFillFontSize } = layoutConfig, { boardSize, shapeBounds, tempCanvas: canvas, randomGenerator } = segmentationOutput, ctx = canvas.getContext("2d", {
    willReadFrequently: true
  });
  let fontSize = fillingInitialFontSize, opacity = fillingInitialOpacity;
  const placedFillingWords = [];
  for (let i = 0; i < fillingTimes; i++) filling1Time(fontSize, opacity), fontSize = Math.max(fontSize > fillingDeltaFontSize ? fontSize - fillingDeltaFontSize : fillingDeltaFontSize, minFillFontSize), opacity = opacity > fillingDeltaOpacity ? opacity - fillingDeltaOpacity : fillingDeltaOpacity;
  return placedFillingWords;
  function filling1Time(fontSize2, opacity2) {
    const fillingWords = words.map((word) => {
      const { text: text2, color, fillingColor, hasPlaced, datum } = word;
      return {
        x: 0,
        y: 0,
        weight: 0,
        text: text2,
        fontFamily: getFillingFontFamily(datum),
        fontStyle: getFillingFontStyle(datum),
        fontWeight: getFillingFontWeight(datum),
        fontSize: fontSize2,
        rotate: fillingRotateList[~~(randomGenerator() * fillingRotateList.length)],
        padding: getFillingPadding(datum),
        opacity: opacity2,
        visible: true,
        color,
        fillingColor,
        hasPlaced,
        datum
      };
    });
    randomArray(fillingWords);
    let wi = 0;
    const { x1, y1, x2, y2 } = shapeBounds, [startX, startY] = [x1 + ~~(randomGenerator() * fillingXStep * 2), y1 + ~~(randomGenerator() * fillingYStep * 2)];
    for (let y = startY; y <= y2; y += fillingYStep) for (let x = startX; x <= x2; x += fillingXStep) {
      measureSprite(canvas, ctx, fillingWords, wi);
      const word = fillingWords[wi];
      word.x = x, word.y = y;
      const { wordSize, bounds, hasPlaced } = word;
      if (!hasPlaced || !bounds) {
        ++wi === fillingWords.length && (wi = 0, random2 && randomArray(fillingWords));
        continue;
      }
      const { dTop, dBottom, dLeft, dRight } = bounds;
      word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || word.hasText && word.sprite && !isCollideWithBoard(word, board, boardSize) && (placeWordOnBoard(word, board, boardSize), placedFillingWords.push(Object.assign({}, word)), ++wi === fillingWords.length && (wi = 0, random2 && randomArray(fillingWords)));
    }
  }
  function randomArray(words2) {
    return words2.sort(() => randomGenerator() - 0.5);
  }
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js
function cloud_shape_layout_default(words, layoutConfig, segmentationOutput) {
  allocateWords(words, segmentationOutput), "ensureMapping" === layoutConfig.layoutMode ? layoutGlobalShrink(words, layoutConfig, segmentationOutput) : "ensureMappingEnlarge" === layoutConfig.layoutMode ? layoutSelfEnlarge(words, layoutConfig, segmentationOutput) : layout(words, layoutConfig, segmentationOutput);
  const fillingWords = filling(words, layoutConfig, segmentationOutput), failedWords = [], successedWords = [];
  for (let i = 0; i < words.length; i++) words[i].hasPlaced ? successedWords.push(words[i]) : failedWords.push(words[i]);
  return failedWords.forEach((word) => word.visible = false), {
    fillingWords,
    successedWords,
    failedWords
  };
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js
var OUTPUT2 = {
  x: "x",
  y: "y",
  fontFamily: "fontFamily",
  fontSize: "fontSize",
  fontStyle: "fontStyle",
  fontWeight: "fontWeight",
  angle: "angle",
  opacity: "opacity",
  visible: "visible",
  isFillingWord: "isFillingWord",
  color: "color"
};
var Layout2 = class {
  constructor(options, view) {
    this.progressiveResult = [], this.options = options, this.view = view;
  }
  layout(data) {
    this.data = data;
    const options = this.options, segmentationInput = {
      shapeUrl: options.shape,
      size: options.size,
      ratio: options.ratio || 0.8,
      tempCanvas: void 0,
      boardSize: [0, 0],
      random: false,
      randomGenerator: void 0
    }, tempCanvas = vglobal.createCanvas({
      width: options.size[0],
      height: options.size[1]
    }), tempCtx = tempCanvas.getContext("2d", {
      willReadFrequently: true
    });
    tempCtx.textAlign = "center", tempCtx.textBaseline = "middle", segmentationInput.tempCanvas = tempCanvas;
    const boardW = options.size[0] + 31 >> 5 << 5;
    if (segmentationInput.boardSize = [boardW, options.size[1]], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = fakeRandom(), this.segmentationInput = segmentationInput, isString_default(segmentationInput.shapeUrl)) {
      segmentationInput.isEmptyPixel = generateIsEmptyPixel();
      const imagePromise = loadImage(segmentationInput.shapeUrl);
      imagePromise ? (this.isImageFinished = false, this.isLayoutFinished = false, imagePromise.then((shapeImage) => {
        this.isImageFinished = true;
        const maskCanvas = vglobal.createCanvas({
          width: options.size[0],
          height: options.size[1],
          dpr: 1
        });
        segmentationInput.maskCanvas = maskCanvas;
        const ctx = maskCanvas.getContext("2d");
        options.removeWhiteBorder && removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);
        const shapeConfig = scaleAndMiddleShape(shapeImage, options.size);
        ctx.clearRect(0, 0, options.size[0], options.size[1]), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height), this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(segmentationInput.maskCanvas);
      }).catch((error3) => {
        this.isImageFinished = true;
      })) : (this.isImageFinished = true, this.isLayoutFinished = true);
    } else if (segmentationInput.shapeUrl && ("text" === segmentationInput.shapeUrl.type || "geometric" === segmentationInput.shapeUrl.type)) {
      segmentationInput.isEmptyPixel = generateIsEmptyPixel(segmentationInput.shapeUrl.backgroundColor);
      const maskCanvas = generateMaskCanvas(segmentationInput.shapeUrl, options.size[0], options.size[1]);
      segmentationInput.maskCanvas = maskCanvas, this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas), this.doLayout(), this.isImageFinished = true, this.isLayoutFinished = true;
    }
  }
  canAnimate() {
    return true;
  }
  unfinished() {
    return !this.isLayoutFinished;
  }
  output() {
    return this.progressiveResult;
  }
  progressiveRun() {
    this.isImageFinished && !this.isLayoutFinished && (this.segmentationInput.maskCanvas && this.doLayout(), this.isLayoutFinished = true);
  }
  progressiveOutput() {
    return this.progressiveResult;
  }
  doLayout() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const segmentationInput = this.segmentationInput, segmentationOutput = segmentation(segmentationInput);
    if (!segmentationOutput.segmentation.regions.length) return;
    const options = this.options, data = this.data, colorMode = options.colorMode || "ordinal", wordsConfig = {
      getText: field4(options.text),
      getFontSize: field4(options.fontSize),
      fontSizeRange: options.fontSizeRange,
      colorMode,
      getColor: options.colorField ? field4(options.colorField) : field4(options.text),
      getFillingColor: field4(options.fillingColorField),
      colorList: options.colorList || ("ordinal" === colorMode ? ["#2E62F1"] : ["#537EF5", "#2E62F1", "#2358D8", "#184FBF", "#0C45A6", "#013B8E"]),
      getColorHex: field4(options.colorHexField),
      getFontFamily: field4(options.fontFamily || "sans-serif"),
      rotateList: options.rotateList || [0],
      getPadding: field4(options.padding || 1),
      getFontStyle: field4(options.fontStyle || "normal"),
      getFontWeight: field4(options.fontWeight || "normal"),
      getFontOpacity: options.fontOpacity ? field4(options.fontOpacity) : () => 1
    };
    initFontSizeScale(data, wordsConfig, segmentationOutput);
    const layoutConfig = {
      size: options.size,
      ratio: options.ratio || 0.8,
      shapeUrl: options.shape,
      random: void 0 === options.random || options.random,
      textLayoutTimes: null !== (_a = options.textLayoutTimes) && void 0 !== _a ? _a : 3,
      removeWhiteBorder: options.removeWhiteBorder,
      layoutMode: null !== (_b = options.layoutMode) && void 0 !== _b ? _b : "default",
      fontSizeShrinkFactor: null !== (_c = options.fontSizeShrinkFactor) && void 0 !== _c ? _c : 0.8,
      stepFactor: null !== (_d = options.stepFactor) && void 0 !== _d ? _d : 1,
      importantWordCount: null !== (_e = options.importantWordCount) && void 0 !== _e ? _e : 10,
      globalShinkLimit: options.globalShinkLimit || 0.2,
      fontSizeEnlargeFactor: null !== (_f = options.fontSizeEnlargeFactor) && void 0 !== _f ? _f : 1.5,
      fillingRatio: null !== (_g = options.fillingRatio) && void 0 !== _g ? _g : 0.7,
      fillingTimes: null !== (_h = options.fillingTimes) && void 0 !== _h ? _h : 4,
      fillingXStep: options.fillingXRatioStep ? Math.max(Math.floor(options.size[0] * options.fillingXRatioStep), 1) : null !== (_j = options.fillingXStep) && void 0 !== _j ? _j : 4,
      fillingYStep: options.fillingYRatioStep ? Math.max(Math.floor(options.size[1] * options.fillingYRatioStep), 1) : null !== (_k = options.fillingYStep) && void 0 !== _k ? _k : 4,
      fillingInitialFontSize: options.fillingInitialFontSize,
      fillingDeltaFontSize: options.fillingDeltaFontSize,
      fillingInitialOpacity: null !== (_l = options.fillingInitialOpacity) && void 0 !== _l ? _l : 0.8,
      fillingDeltaOpacity: null !== (_m = options.fillingDeltaOpacity) && void 0 !== _m ? _m : 0.05,
      getFillingFontFamily: field4(options.fillingFontFamily || "sans-serif"),
      getFillingFontStyle: field4(options.fillingFontStyle || "normal"),
      getFillingFontWeight: field4(options.fillingFontWeight || "normal"),
      getFillingPadding: field4(null !== (_o = options.fillingPadding) && void 0 !== _o ? _o : 0.4),
      fillingRotateList: null !== (_p = options.fillingRotateList) && void 0 !== _p ? _p : [0, 90],
      fillingDeltaFontSizeFactor: null !== (_q = options.fillingDeltaFontSizeFactor) && void 0 !== _q ? _q : 0.2,
      fillingColorList: options.fillingColorList || ["#537EF5"],
      sameColorList: false,
      minInitFontSize: null !== (_r = options.minInitFontSize) && void 0 !== _r ? _r : 10,
      minFontSize: null !== (_s = options.minFontSize) && void 0 !== _s ? _s : 4,
      minFillFontSize: null !== (_t = options.minFillFontSize) && void 0 !== _t ? _t : 2
    }, sameColorList = colorListEqual(wordsConfig.colorList, layoutConfig.fillingColorList);
    layoutConfig.sameColorList = sameColorList, initColorScale(data, wordsConfig, layoutConfig, options), initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput);
    const { getText, getFontFamily, getFontStyle, getFontWeight, getPadding, getColor, getFillingColor, getColorHex, fontSizeScale, colorScale, fillingColorScale, getFontOpacity, rotateList } = wordsConfig, words = data.map((datum) => {
      var _a2, _b2;
      return {
        x: 0,
        y: 0,
        weight: 0,
        text: getText(datum),
        fontFamily: getFontFamily(datum),
        fontWeight: getFontWeight(datum),
        fontStyle: getFontStyle(datum),
        rotate: rotateList[~~(segmentationInput.randomGenerator() * rotateList.length)],
        fontSize: Math.max(layoutConfig.minInitFontSize, ~~fontSizeScale(datum)),
        opacity: getFontOpacity(datum),
        padding: getPadding(datum),
        color: getColorHex && getColorHex(datum) || colorScale && colorScale(getColor(datum)) || "black",
        fillingColor: !getFillingColor || (null === (_a2 = options.colorField) || void 0 === _a2 ? void 0 : _a2.field) === (null === (_b2 = options.fillingColorField) || void 0 === _b2 ? void 0 : _b2.field) && sameColorList ? void 0 : getColorHex && getColorHex(datum) || fillingColorScale && fillingColorScale(getFillingColor(datum)) || "black",
        datum,
        visible: true,
        hasPlaced: false
      };
    }), wordsMaxFontSize = maxInArray(words.map((word) => word.fontSize));
    words.forEach((word) => word.weight = word.fontSize / wordsMaxFontSize), words.sort((a3, b) => b.weight - a3.weight);
    const { fillingWords, successedWords, failedWords } = cloud_shape_layout_default(words, layoutConfig, segmentationOutput), textKey = null !== (_v = null === (_u = options.text) || void 0 === _u ? void 0 : _u.field) && void 0 !== _v ? _v : "textKey", dataIndexKey = null !== (_w = options.dataIndexKey) && void 0 !== _w ? _w : "defaultDataIndexKey", as = options.as ? Object.assign(Object.assign({}, OUTPUT2), options.as) : OUTPUT2;
    let w, t;
    const modKeywords = [];
    for (let i = 0; i < words.length; ++i) w = words[i], t = w.datum, t[as.x] = w.x, t[as.y] = w.y, t[as.fontFamily] = w.fontFamily, t[as.fontSize] = w.fontSize, t[as.fontStyle] = w.fontStyle, t[as.fontWeight] = w.fontWeight, t[as.angle] = degreeToRadian(w.rotate), t[as.opacity] = w.opacity, t[as.visible] = w.visible, t[as.isFillingWord] = false, t[as.color] = w.color, t[dataIndexKey] = `${w.text}_${i}_keyword`, modKeywords.push(t);
    const fillingWordsData = [];
    if (fillingWords.forEach((word, index) => {
      var _a2, _b2;
      const t2 = Object.assign({}, word.datum);
      t2[as.x] = word.x, t2[as.y] = word.y, t2[as.fontFamily] = word.fontFamily, t2[as.fontSize] = word.fontSize, t2[as.fontStyle] = word.fontStyle, t2[as.fontWeight] = word.fontWeight, t2[as.angle] = degreeToRadian(word.rotate), t2[as.opacity] = word.opacity, t2[as.visible] = word.visible, t2[as.isFillingWord] = true, t2[as.color] = getFillingColor ? (null === (_a2 = options.colorField) || void 0 === _a2 ? void 0 : _a2.field) === (null === (_b2 = options.fillingColorField) || void 0 === _b2 ? void 0 : _b2.field) && sameColorList ? word.color : word.fillingColor : layoutConfig.fillingColorList[~~(segmentationInput.randomGenerator() * layoutConfig.fillingColorList.length)], t2[textKey] = word.text, t2[dataIndexKey] = `${word.text}_${index}_fillingWords`, fillingWordsData.push(t2);
    }), this.view && this.view.emit) {
      this.view.emit(WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT, {
        successedWords,
        failedWords
      });
      const stage = null === (_x = this.view.renderer) || void 0 === _x ? void 0 : _x.stage();
      stage && stage.hooks.afterRender.tap(WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, () => {
        this.view.emit(WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, {
          successedWords,
          failedWords
        }), stage.hooks.afterRender.unTap(WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW);
      });
    }
    this.progressiveResult = modKeywords.concat(fillingWordsData);
  }
  release() {
    this.segmentationInput = null, this.data = null, this.progressiveResult = null, this.options = null;
  }
};
var initColorScale = (data, wordsConfig, layoutConfig, options) => {
  var _a, _b, _c, _d;
  const { colorMode, getColor, getFillingColor } = wordsConfig, { sameColorList } = layoutConfig;
  let colorScale, fillingColorScale, colorList = wordsConfig.colorList, fillingColorList = layoutConfig.fillingColorList;
  if ("ordinal" === colorMode) {
    const uniqueColorField = data.map((word) => getColor(word));
    if (colorScale = (datum) => new OrdinalScale().domain(uniqueColorField).range(colorList).scale(datum), getFillingColor && ((null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) !== (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) || !sameColorList)) {
      const uniquefillingColorField = data.map((datum) => getFillingColor(datum));
      fillingColorScale = (datum) => new OrdinalScale().domain(uniquefillingColorField).range(fillingColorList).scale(datum);
    }
  } else {
    1 === colorList.length && (colorList = [colorList[0], colorList[0]]);
    const valueScale = new LinearScale().domain(extent3(getColor, data)).range(colorList);
    if (colorScale = (i) => valueScale.scale(i), getFillingColor && ((null === (_c = options.colorField) || void 0 === _c ? void 0 : _c.field) !== (null === (_d = options.fillingColorField) || void 0 === _d ? void 0 : _d.field) || !sameColorList)) {
      1 === fillingColorList.length && (fillingColorList = [fillingColorList[0], fillingColorList[0]]);
      const fillingValueScale = new LinearScale().domain(extent3(getFillingColor, data)).range(fillingColorList);
      fillingColorScale = (i) => fillingValueScale.scale(i);
    }
  }
  Object.assign(wordsConfig, {
    colorScale,
    fillingColorScale
  });
};
var initFontSizeScale = (data, wordsConfig, segmentationOutput) => {
  let { fontSizeRange: range2 } = wordsConfig;
  const { getFontSize, getText } = wordsConfig;
  let fontSizeScale;
  if (getFontSize) {
    if (getFontSize && range2) {
      const sizeScale = new SqrtScale().domain(extent3(getFontSize, data)).range(range2);
      fontSizeScale = (datum) => sizeScale.scale(getFontSize(datum));
    } else if (getFontSize && isFunction_default(getFontSize) && !range2) {
      const a3 = 0.5, [min3, max3] = extent3(getFontSize, data), words = data.map((datum) => ({
        text: getText(datum),
        value: getFontSize(datum),
        weight: max3 === min3 ? 1 : (getFontSize(datum) - min3) / (max3 - min3)
      })), x = getInitialFontSize(words, segmentationOutput, true);
      range2 = [~~(a3 * x), ~~x];
      const sizeScale = new SqrtScale().domain(extent3(getFontSize, data)).range(range2);
      fontSizeScale = (datum) => sizeScale.scale(getFontSize(datum));
    }
  } else {
    const words = data.map((word) => ({
      text: getText(word)
    })), x = getInitialFontSize(words, segmentationOutput, false);
    fontSizeScale = functor2(x);
  }
  Object.assign(wordsConfig, {
    getFontSize,
    fontSizeRange: range2,
    fontSizeScale
  });
};
var getInitialFontSize = (words, segmentationOutput, weight) => {
  const shapeArea = segmentationOutput.shapeArea, ratio = segmentationOutput.ratio, regions = segmentationOutput.segmentation.regions, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(shapeArea) / 12), wordArea = words.reduce((acc, word) => {
    const textLength = calTextLength(word.text);
    return textLength < shapeSizeLimitTextLength ? acc + textLength * (weight ? (0.5 + 0.5 * word.weight) ** 2 : 1) : acc;
  }, 0);
  if (0 === wordArea) return 12;
  let x = 20;
  if (1 === regions.length) x = Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));
  else {
    const xArr = [];
    for (let i = 0; i < regions.length; i++) {
      const regionArea = regions[i].area, regionAspect = regions[i].ratio, regionRatio = regionArea / shapeArea;
      if (regionRatio < 0.1) continue;
      const regionWordArea = regionRatio * (wordArea * (regionAspect < 1 ? 2.7 - regionAspect : 1.7)), x2 = Math.sqrt(ratio * (regionArea / regionWordArea));
      xArr.push(x2);
    }
    x = xArr.length ? Math.min(...xArr) : Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));
  }
  return x;
};
function initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput) {
  const { getText } = wordsConfig;
  let { fillingInitialFontSize, fillingDeltaFontSize } = layoutConfig;
  const { fillingRatio } = layoutConfig, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(segmentationOutput.shapeArea) / 4);
  if (!fillingInitialFontSize || !fillingDeltaFontSize) {
    const a3 = fillingRatio / 100, averageLength = data.reduce((acc, word) => {
      const length2 = calTextLength(getText(word));
      return length2 > shapeSizeLimitTextLength ? acc : acc + length2;
    }, 0) / data.length;
    let fontSize;
    if (0 === averageLength) fontSize = 8;
    else {
      const area2 = 0.2 * segmentationOutput.shapeArea;
      fontSize = Math.sqrt(a3 * (area2 / averageLength));
    }
    fillingInitialFontSize = ~~fontSize, fillingDeltaFontSize = fontSize * layoutConfig.fillingDeltaFontSizeFactor, Object.assign(layoutConfig, {
      fillingInitialFontSize,
      fillingDeltaFontSize
    });
  }
}
var extent3 = (field5, data) => {
  let min3 = 1 / 0, max3 = -1 / 0;
  const n = data.length;
  let v;
  for (let i = 0; i < n; ++i) v = toNumber(field5(data[i])), v < min3 && (min3 = v), v > max3 && (max3 = v);
  return 1 === data.length && min3 === max3 && (min3 -= 1e4), [min3, max3];
};
var field4 = (option) => option ? "string" == typeof option || "number" == typeof option ? () => option : isFunction_default(option) ? option : (datum) => datum[option.field] : null;

// node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js
var transform23 = (options, upstreamData, parameters, view) => {
  if (!options.size || isNil_default(options.size[0]) || isNil_default(options.size[1]) || options.size[0] <= 0 || options.size[1] <= 0) {
    return Logger.getInstance().info("Wordcloud size dimensions must be greater than 0"), [];
  }
  if (options.size = [Math.ceil(options.size[0]), Math.ceil(options.size[1])], options.shape || error2("WordcloudShape shape must be specified."), options.text || error2("WordcloudShape text must be specified."), (null == view ? void 0 : view.emit) && view.emit(WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT), !upstreamData || 0 === upstreamData.length) return [];
  const layout2 = new Layout2(options, view);
  return layout2.layout(upstreamData), layout2.unfinished() ? {
    progressive: layout2
  } : layout2.output();
};

// node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js
var registerWordCloudShapeTransforms = () => {
  Factory3.registerTransform("wordcloudShape", {
    transform: transform23,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/word-cloud.js
var WordCloudSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud;
  }
};
WordCloudSeries.type = SeriesTypeEnum.wordCloud;
var registerWordCloudSeries = () => {
  registerWordCloudTransforms(), registerTextMark(), registerWordCloudAnimation(), Factory2.registerSeries(WordCloudSeries.type, WordCloudSeries);
};
var registerWordCloudShapeSeries = () => {
  registerWordCloudShapeTransforms(), registerWordCloudTransforms(), registerTextMark(), registerWordCloudAnimation(), Factory2.registerSeries(WordCloudSeries.type, WordCloudSeries);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/word-cloud-3d.js
var WordCloud3dSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud3d;
  }
  _wordCloudTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  _wordCloudShapeTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudShapeTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  initMark() {
    this._wordMark = this._createMark(BaseWordCloudSeries.mark.word, {
      groupKey: this._seriesField,
      isSeriesMark: true
    }, {
      support3d: true
    });
  }
  initMarkStyle() {
    super.initMarkStyle();
    const wordMark = this._wordMark;
    wordMark && this.setMarkStyle(wordMark, {
      z: (datum) => {
        var _a;
        return null !== (_a = datum.z) && void 0 !== _a ? _a : 0;
      }
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const padding = null !== (_a = this._padding) && void 0 !== _a ? _a : {};
    this._wordMark && this._wordMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("wordCloud3d")) || void 0 === _b ? void 0 : _b(() => {
      var _a2;
      const srView = this.getCompiler().getVGrammarView(), width = srView.width() - padding.left || 0 - padding.right || 0, height = srView.height() - padding.top || 0 - padding.bottom || 0, r = Math.max(width, height) / 2;
      return {
        center: {
          x: r,
          y: r,
          z: null !== (_a2 = this._spec.depth_3d) && void 0 !== _a2 ? _a2 : r
        },
        r
      };
    }), userAnimationConfig("word", this._spec, this._markAttributeContext)));
  }
};
WordCloud3dSeries.type = SeriesTypeEnum.wordCloud3d;
var registerWordCloud3dSeries = () => {
  registerWordCloudTransforms(), registerTextMark(), registerWordCloud3dAnimation(), Factory2.registerSeries(WordCloud3dSeries.type, WordCloud3dSeries);
};
var registerWordCloudShape3dSeries = () => {
  registerWordCloudShapeTransforms(), registerWordCloudTransforms(), registerTextMark(), registerWordCloud3dAnimation(), Factory2.registerSeries(WordCloud3dSeries.type, WordCloud3dSeries);
};

// node_modules/@visactor/vchart/esm/data/transforms/funnel.js
var funnel2 = (originData, op) => {
  var _a, _b;
  const data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length) return data;
  const { valueField, asTransformRatio, asReachRatio, asHeightRatio, asValueRatio, asNextValueRatio, asLastValueRatio, asLastValue, asCurrentValue, asNextValue, heightVisual = false, isCone = true, range: range2 } = op, max3 = data.reduce((m4, d) => Math.max(m4, Number.parseFloat(d[valueField]) || -1 / 0), -1 / 0), min3 = data.reduce((m4, d) => Math.min(m4, Number.parseFloat(d[valueField]) || 1 / 0), 1 / 0), rangeArr = [null !== (_a = null == range2 ? void 0 : range2.min) && void 0 !== _a ? _a : min3, null !== (_b = null == range2 ? void 0 : range2.max) && void 0 !== _b ? _b : max3];
  return data.forEach((d, i) => {
    var _a2, _b2;
    const currentValue = Number.parseFloat(d[valueField]), lastValue = Number.parseFloat(null === (_a2 = data[i - 1]) || void 0 === _a2 ? void 0 : _a2[valueField]), nextValue = Number.parseFloat(null === (_b2 = data[i + 1]) || void 0 === _b2 ? void 0 : _b2[valueField]), transformRatio = isValidNumber_default(nextValue * currentValue) && 0 !== currentValue ? nextValue / currentValue : 0, reachRatio = isValidNumber_default(currentValue * lastValue) && 0 !== lastValue ? currentValue / lastValue : 0;
    asLastValue && (d[asLastValue] = lastValue), asNextValue && (d[asNextValue] = nextValue), asTransformRatio && (d[asTransformRatio] = transformRatio), asReachRatio && (d[asReachRatio] = 0 === i ? 1 : reachRatio), asHeightRatio && (d[asHeightRatio] = true === heightVisual ? transformRatio : 1 / data.length), asValueRatio && (d[asValueRatio] = currentValue / rangeArr[1]), asNextValueRatio && (d[asNextValueRatio] = i === data.length - 1 ? isCone ? 0 : d[asValueRatio] : nextValue / rangeArr[1]), asLastValueRatio && (d[asLastValueRatio] = 0 === i ? 1 : lastValue / rangeArr[1]), asCurrentValue && (d[asCurrentValue] = currentValue);
  }), data;
};
var funnelTransform = (originData, op) => {
  var _a, _b;
  const data = null === (_b = null === (_a = originData[0]) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.map((datum) => Object.assign({}, datum));
  return data && 0 !== data.length ? (data.shift(), data.forEach((d) => {
    d[op.asIsTransformLevel] = true;
  }), data) : data;
};

// node_modules/@visactor/vchart/esm/constant/funnel.js
var FUNNEL_TRANSFORM_RATIO = `${PREFIX}_FUNNEL_TRANSFORM_RATIO`;
var FUNNEL_REACH_RATIO = `${PREFIX}_FUNNEL_REACH_RATIO`;
var FUNNEL_HEIGHT_RATIO = `${PREFIX}_FUNNEL_HEIGHT_RATIO`;
var FUNNEL_VALUE_RATIO = `${PREFIX}_FUNNEL_VALUE_RATIO`;
var FUNNEL_LAST_VALUE_RATIO = `${PREFIX}_FUNNEL_LAST_VALUE_RATIO`;
var FUNNEL_NEXT_VALUE_RATIO = `${PREFIX}_FUNNEL_NEXT_VALUE_RATIO`;
var FUNNEL_LAST_VALUE = `${PREFIX}_FUNNEL_LAST_VALUE`;
var FUNNEL_CURRENT_VALUE = `${PREFIX}_FUNNEL_CURRENT_VALUE`;
var FUNNEL_NEXT_VALUE = `${PREFIX}_FUNNEL_NEXT_VALUE`;
var FUNNEL_TRANSFORM_LEVEL = `${PREFIX}_FUNNEL_TRANSFORM_LEVEL`;
var FUNNEL_LABEL_LINE_LENGTH = 20;
var FUNNEL_LABEL_SPACE_WIDTH = 5;
var FUNNEL_MAX_SIZE = "80%";
var FUNNEL_MIN_SIZE = 0;

// node_modules/@visactor/vchart/esm/series/funnel/tooltip-helper.js
var FunnelSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor(series2) {
    var _a, _b;
    super(series2), this.dimensionTooltipTitleCallback = (datum, params2) => {
      var _a2, _b2, _c;
      const series3 = this.series;
      return "transform" === (null === (_a2 = null == params2 ? void 0 : params2.mark) || void 0 === _a2 ? void 0 : _a2.name) ? this._transformRatioText : null !== (_b2 = this._getDimensionData(datum)) && void 0 !== _b2 ? _b2 : null === (_c = datum.properties) || void 0 === _c ? void 0 : _c[`${series3.getCategoryField()}`];
    }, this.markTooltipValueCallback = (datum, params2) => {
      var _a2;
      if ("transform" === (null === (_a2 = null == params2 ? void 0 : params2.mark) || void 0 === _a2 ? void 0 : _a2.name)) {
        return `${(100 * (null == datum ? void 0 : datum[FUNNEL_REACH_RATIO])).toFixed(1)}%`;
      }
      return this._getMeasureData(datum);
    }, this.markTooltipKeyCallback = (datum, params2) => {
      var _a2;
      if ("transform" === (null === (_a2 = null == params2 ? void 0 : params2.mark) || void 0 === _a2 ? void 0 : _a2.name)) return this._transformRatioText;
      const { dimensionFields, seriesFields } = this._seriesCacheInfo, subDimensionField = dimensionFields[dimensionFields.length - 1];
      return isValid_default(seriesFields[0]) ? null == datum ? void 0 : datum[seriesFields[0]] : null == datum ? void 0 : datum[subDimensionField];
    }, this._transformRatioText = null !== (_b = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.transformRatioText) && void 0 !== _b ? _b : "转化率";
  }
};

// node_modules/@visactor/vchart/esm/mark/polygon/base-polygon.js
var BasePolygonMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      points: []
    });
  }
};

// node_modules/@visactor/vchart/esm/mark/polygon/polygon.js
var PolygonMark = class _PolygonMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _PolygonMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
};
PolygonMark.type = "polygon";
var registerPolygonMark = () => {
  Factory2.registerMark(PolygonMark.type, PolygonMark), registerPolygonGraphic2(), registerVGrammarPolygonAnimation();
};

// node_modules/@visactor/vchart/esm/series/funnel/constant.js
var funnelSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel: {
    name: "funnel",
    type: "polygon"
  },
  transform: {
    name: "transform",
    type: "polygon"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});
var funnel3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel3d: {
    name: "funnel3d",
    type: "pyramid3d"
  },
  transform3d: {
    name: "transform3d",
    type: "pyramid3d"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});

// node_modules/@visactor/vchart/esm/series/funnel/funnel-transformer.js
var FunnelSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel"), spec.isTransform && this._addMarkLabelSpec(spec, "transform", "transformLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/funnel/funnel.js
var FunnelSeries = class _FunnelSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel, this._funnelMarkName = "funnel", this._funnelMarkType = "polygon", this._transformMarkName = "transform", this._transformMarkType = "polygon", this.transformerConstructor = FunnelSeriesSpecTransformer, this._funnelMark = null, this._funnelTransformMark = null, this._labelMark = null, this._transformLabelMark = null, this._funnelOuterLabelMark = {};
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this._funnelOrient = null !== (_a = this._spec.funnelOrient) && void 0 !== _a ? _a : "top", this._shape = null !== (_b = this._spec.shape) && void 0 !== _b ? _b : "trapezoid", this._minLabelLineWidth = null !== (_e = null === (_d = null === (_c = this._spec.outerLabel) || void 0 === _c ? void 0 : _c.line) || void 0 === _d ? void 0 : _d.minLength) && void 0 !== _e ? _e : FUNNEL_LABEL_LINE_LENGTH, this._isHorizontal() ? this._funnelAlign = ["top", "bottom"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center" : this._funnelAlign = ["left", "right"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center", !this._seriesField && this._spec.categoryField && this.setSeriesField(this._spec.categoryField);
  }
  initData() {
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "funnel", funnel2), registerDataSetInstanceTransform(this._dataSet, "funnelTransform", funnelTransform);
    const viewDataTransform = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataTransform`
    });
    viewDataTransform.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataTransform = new SeriesData(this._option, viewDataTransform);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._viewDataTransform) || void 0 === _a || _a.compile();
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._categoryField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  _statisticViewData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    super._statisticViewData(), this._data.getDataView().transform({
      type: "funnel",
      options: {
        valueField: this.getValueField(),
        isCone: this._spec.isCone,
        asCurrentValue: FUNNEL_CURRENT_VALUE,
        asTransformRatio: FUNNEL_TRANSFORM_RATIO,
        asReachRatio: FUNNEL_REACH_RATIO,
        asHeightRatio: FUNNEL_HEIGHT_RATIO,
        asValueRatio: FUNNEL_VALUE_RATIO,
        asNextValueRatio: FUNNEL_NEXT_VALUE_RATIO,
        asLastValueRatio: FUNNEL_LAST_VALUE_RATIO,
        asLastValue: FUNNEL_LAST_VALUE,
        asNextValue: FUNNEL_NEXT_VALUE,
        range: {
          min: null !== (_b = null === (_a = this._spec.range) || void 0 === _a ? void 0 : _a.min) && void 0 !== _b ? _b : null === (_d = null === (_c = this.getViewDataStatistics().latestData) || void 0 === _c ? void 0 : _c[this.getValueField()]) || void 0 === _d ? void 0 : _d.min,
          max: null !== (_f = null === (_e = this._spec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null === (_h = null === (_g = this.getViewDataStatistics().latestData) || void 0 === _g ? void 0 : _g[this.getValueField()]) || void 0 === _h ? void 0 : _h.max
        }
      }
    }), null === (_j = this._viewDataTransform.getDataView()) || void 0 === _j || _j.transform({
      type: "funnelTransform",
      options: {
        asIsTransformLevel: FUNNEL_TRANSFORM_LEVEL
      }
    });
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.funnel), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel,
      groupKey: this._seriesField,
      isSeriesMark: true,
      stateSort: null === (_b = this._spec.funnel) || void 0 === _b ? void 0 : _b.stateSort,
      noSeparateStyle: true
    }, {
      setCustomizedShape: null === (_c = this._spec.funnel) || void 0 === _c ? void 0 : _c.customShape,
      morph: shouldMarkDoMorph(this._spec, this._funnelMarkName),
      morphElementKey: this._seriesField
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.transform), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_d = this._theme) || void 0 === _d ? void 0 : _d.transform,
      skipBeforeLayouted: true,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId(),
      stateSort: null === (_e = this._spec.transform) || void 0 === _e ? void 0 : _e.stateSort,
      noSeparateStyle: true
    }, {
      setCustomizedShape: null === (_f = this._spec.transform) || void 0 === _f ? void 0 : _f.customShape
    })), null === (_h = null === (_g = this._spec) || void 0 === _g ? void 0 : _g.outerLabel) || void 0 === _h ? void 0 : _h.visible) {
      const { line: line2 } = null !== (_j = this._spec.outerLabel) && void 0 !== _j ? _j : {}, { line: lineTheme } = null !== (_l = null === (_k = this._theme) || void 0 === _k ? void 0 : _k.outerLabel) && void 0 !== _l ? _l : {};
      this._funnelOuterLabelMark.label = this._createMark(_FunnelSeries.mark.outerLabel, {
        themeSpec: null === (_m = this._theme) || void 0 === _m ? void 0 : _m.outerLabel,
        markSpec: this._spec.outerLabel,
        skipBeforeLayouted: true,
        noSeparateStyle: true
      }), this._funnelOuterLabelMark.line = this._createMark(_FunnelSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label],
        noSeparateStyle: true
      });
    }
  }
  initTooltip() {
    this._tooltipHelper = new FunnelSeriesTooltipHelper(this), this._funnelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelMark), this._funnelTransformMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelTransformMark);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getGroupFields() {
    return null;
  }
  initMarkStyle() {
    const funnelMark = this._funnelMark;
    funnelMark && this.setMarkStyle(funnelMark, {
      points: (datum) => this.getPoints(datum),
      visible: (datum) => isValid_default(datum[this._valueField]),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
    const funnelTransformMark = this._funnelTransformMark;
    funnelTransformMark && this.setMarkStyle(funnelTransformMark, {
      points: (datum) => this.getPoints(datum)
    }, "normal", AttributeLevel.Series);
    const outerLabelMark = this._funnelOuterLabelMark.label;
    outerLabelMark && (this.setMarkStyle(outerLabelMark, {
      text: (datum) => `${datum[this.getCategoryField()]}`,
      x: (datum) => this._computeOuterLabelPosition(datum).x,
      y: (datum) => this._computeOuterLabelPosition(datum).y,
      textAlign: (datum) => this._computeOuterLabelPosition(datum).align,
      textBaseline: (datum) => this._computeOuterLabelPosition(datum).textBaseline,
      maxLineWidth: (datum) => this._computeOuterLabelLimit(datum),
      width: 0,
      height: 0
    }, "normal", AttributeLevel.Series), isFunction_default(this._spec.outerLabel.formatMethod) && this.setMarkStyle(outerLabelMark, {
      text: (datum) => this._spec.outerLabel.formatMethod(`${datum[this.getCategoryField()]}`, datum)
    }, "normal", AttributeLevel.User_Mark));
    const outerLabelLineMark = this._funnelOuterLabelMark.line;
    outerLabelLineMark && outerLabelMark && this.setMarkStyle(outerLabelLineMark, {
      x: (datum) => this._computeOuterLabelLinePosition(datum).x1,
      y: (datum) => this._computeOuterLabelLinePosition(datum).y1,
      x1: (datum) => this._computeOuterLabelLinePosition(datum).x2,
      y1: (datum) => this._computeOuterLabelLinePosition(datum).y2
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    if (!labelMark) return;
    const target = labelMark.getTarget(), component2 = labelMark.getComponent();
    target === this._funnelMark ? (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${datum[this.getCategoryField()]} ${datum[this.getValueField()]}`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.label),
      stroke: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(component2), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend())) : this._funnelTransformMark && target === this._funnelTransformMark && (this._transformLabelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${(100 * field2(FUNNEL_REACH_RATIO).bind(this)(datum)).toFixed(1)}%`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.transformLabel)
    }, "normal", AttributeLevel.Series));
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("cartesianGroupClip")) || void 0 === _d ? void 0 : _d({
      direction: () => this._isHorizontal() ? "x" : "y",
      width: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { x1, x2 } = rootMark.getBounds();
          return Math.max(x1, x2);
        }
        return this.getLayoutRect().width;
      },
      height: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { y1, y2 } = rootMark.getBounds();
          return Math.max(y1, y2);
        }
        return this.getLayoutRect().height;
      },
      orient: () => this._isReverse() ? "negative" : "positive"
    }, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext))), [null === (_e = this._funnelOuterLabelMark) || void 0 === _e ? void 0 : _e.label].forEach((m4) => {
      m4 && m4.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("fadeInOut")(), userAnimationConfig(m4.name, this._spec, this._markAttributeContext)));
    }), [this._funnelMark, this._funnelTransformMark].forEach((m4) => {
      m4 && m4.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("funnel")({}, appearPreset), userAnimationConfig(m4.name, this._spec, this._markAttributeContext)));
    }), (null === (_f = this._funnelOuterLabelMark) || void 0 === _f ? void 0 : _f.line) && this._funnelOuterLabelMark.line.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _g ? void 0 : _g(), userAnimationConfig("outerLabelLine", this._spec, this._markAttributeContext)));
  }
  initGroups() {
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return null;
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataTransform.getDataView()) || void 0 === _a || _a.target.addListener("change", (d) => {
      this._viewDataTransform.updateData();
    });
  }
  getPoints(datum) {
    const isTransformLevel = this.isTransformLevel(datum), heightHalf = this._getMainAxisLength(isTransformLevel) / 2;
    let upperLeft, lowerLeft;
    isTransformLevel ? (upperLeft = "rect" === this._shape ? this._getSecondaryAxisLength(datum[FUNNEL_LAST_VALUE_RATIO]) / 2 : this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2) : (upperLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = "rect" === this._shape ? upperLeft : this._getSecondaryAxisLength(datum[FUNNEL_NEXT_VALUE_RATIO]) / 2);
    const { x, y } = this._getPositionByData(datum), points = this._getPolygonPoints([x, y], upperLeft, lowerLeft, upperLeft, lowerLeft, heightHalf);
    return "center" !== this._funnelAlign && this._adjustPoints(points), points;
  }
  isTransformLevel(datum) {
    return !!(null == datum ? void 0 : datum[FUNNEL_TRANSFORM_LEVEL]);
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this), this._markAttributeContext.getPoints = this.getPoints.bind(this), this._markAttributeContext.isTransformLevel = this.isTransformLevel.bind(this);
  }
  valueToPosition(category) {
    var _a, _b, _c;
    const innerDatum = null === (_c = null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.find) || void 0 === _c ? void 0 : _c.call(_b, (d) => d[this._categoryField] === category);
    return isValid_default(innerDatum) ? this._getPolygonCenter(this.getPoints(innerDatum)) : null;
  }
  dataToPosition(datum, checkInViewData) {
    return checkInViewData && !this.isDatumInViewData(datum) ? null : this.valueToPosition(datum[this._categoryField]);
  }
  dataToPositionX(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
  }
  dataToPositionY(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  _getMainAxisLength(isTransform = false) {
    var _a;
    const funnelCount = this.getViewData().latestData.length, viewHeight = this._isHorizontal() ? this.getLayoutRect().width : this.getLayoutRect().height, hasTransform = !!this._spec.isTransform, gap = hasTransform ? 0 : null !== (_a = this._spec.gap) && void 0 !== _a ? _a : 0, transformCount = hasTransform ? Math.max(0, funnelCount - 1) : 0, heightRatio = this._spec.heightRatio || 0.5, funnelHeight = (viewHeight - gap * Math.max(0, funnelCount - 1)) / (funnelCount + heightRatio * transformCount);
    return isTransform ? hasTransform ? funnelHeight * heightRatio : 0 : funnelHeight;
  }
  _getSecondaryAxisLength(ratio) {
    const validRatio = Number.isNaN(ratio) || !Number.isFinite(ratio) ? 0 : ratio, maxSize = this._computeMaxSize(), minSize = this._computeMinSize();
    return minSize + (maxSize - minSize) * validRatio;
  }
  _getPositionByData(datum) {
    var _a;
    const index = null === (_a = this.getViewData().latestData) || void 0 === _a ? void 0 : _a.findIndex((d) => d[this._categoryField] === datum[this._categoryField] && d[DEFAULT_DATA_KEY] === datum[DEFAULT_DATA_KEY]);
    if (!isValid_default(index) || index < 0) return {};
    const isTransform = this.isTransformLevel(datum), isHorizontal4 = this._isHorizontal(), viewWidth = isHorizontal4 ? this.getLayoutRect().height : this.getLayoutRect().width, viewHeight = isHorizontal4 ? this.getLayoutRect().width : this.getLayoutRect().height, centerX = viewWidth / 2;
    let centerY = 0;
    const funnelHeight = this._getMainAxisLength(), transformHeight = this._getMainAxisLength(true);
    return centerY += index * (funnelHeight + transformHeight), centerY += isTransform ? -transformHeight / 2 : funnelHeight / 2, !this._spec.isTransform && this._spec.gap && (centerY += this._spec.gap * index), this._isReverse() && (centerY = viewHeight - centerY), this._isHorizontal() ? {
      x: centerY,
      y: centerX
    } : {
      x: centerX,
      y: centerY
    };
  }
  _getPolygonPoints(center2, upperLeft, lowerLeft, upperRight, lowerRight, heightHalf) {
    const x = center2[0], y = center2[1];
    switch (this._funnelOrient) {
      case "left":
        return [{
          x: x - heightHalf,
          y: y + upperLeft
        }, {
          x: x - heightHalf,
          y: y - upperRight
        }, {
          x: x + heightHalf,
          y: y - lowerRight
        }, {
          x: x + heightHalf,
          y: y + lowerLeft
        }];
      case "right":
        return [{
          x: x + heightHalf,
          y: y - upperRight
        }, {
          x: x + heightHalf,
          y: y + upperRight
        }, {
          x: x - heightHalf,
          y: y + lowerLeft
        }, {
          x: x - heightHalf,
          y: y - lowerLeft
        }];
      case "bottom":
        return [{
          x: x + upperLeft,
          y: y + heightHalf
        }, {
          x: x - upperRight,
          y: y + heightHalf
        }, {
          x: x - lowerRight,
          y: y - heightHalf
        }, {
          x: x + lowerLeft,
          y: y - heightHalf
        }];
      default:
        return [{
          x: x - upperLeft,
          y: y - heightHalf
        }, {
          x: x + upperRight,
          y: y - heightHalf
        }, {
          x: x + lowerRight,
          y: y + heightHalf
        }, {
          x: x - lowerLeft,
          y: y + heightHalf
        }];
    }
  }
  _getPolygonCenter(points) {
    if (this._isHorizontal()) {
      const p0_x2 = (points[0].x + points[3].x) / 2, p0_y2 = (points[0].y + points[3].y) / 2;
      return {
        x: (p0_x2 + (points[1].x + points[2].x) / 2) / 2,
        y: (p0_y2 + (points[1].y + points[2].y) / 2) / 2
      };
    }
    const p0_x = (points[0].x + points[3].x) / 2, p0_y = (points[0].y + points[3].y) / 2;
    return {
      x: (p0_x + (points[1].x + points[2].x) / 2) / 2,
      y: (p0_y + (points[1].y + points[2].y) / 2) / 2
    };
  }
  _adjustPoints(points) {
    let upperOffset, lowerOffset, dirKey;
    return this._isHorizontal() ? (dirKey = "y", "left" === this._funnelOrient ? (upperOffset = "bottom" === this._funnelAlign ? -points[1].y : points[1].y, lowerOffset = "bottom" === this._funnelAlign ? -points[2].y : points[2].y) : (upperOffset = "bottom" === this._funnelAlign ? -points[0].y : points[0].y, lowerOffset = "bottom" === this._funnelAlign ? -points[3].y : points[3].y)) : (dirKey = "x", "top" === this._funnelOrient ? (upperOffset = "left" === this._funnelAlign ? points[0].x : -points[0].x, lowerOffset = "left" === this._funnelAlign ? points[3].x : -points[3].x) : (upperOffset = "left" === this._funnelAlign ? points[1].x : -points[1].x, lowerOffset = "left" === this._funnelAlign ? points[2].x : -points[2].x)), points[0][dirKey] -= upperOffset, points[1][dirKey] -= upperOffset, points[2][dirKey] -= lowerOffset, points[3][dirKey] -= lowerOffset, points;
  }
  _computeLabelPosition(datum) {
    const points = this.getPoints(datum);
    return this._getPolygonCenter(points);
  }
  _computeLabelLimit(datum, labelSpec) {
    const limit = null == labelSpec ? void 0 : labelSpec.limit;
    if (isNumber_default(limit)) return limit;
    const points = this.getPoints(datum);
    return "shapeSize" === limit ? this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2 : this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : void 0;
  }
  _computeOuterLabelPosition(datum) {
    var _a, _b;
    let x, y, position = null === (_a = this._spec.outerLabel) || void 0 === _a ? void 0 : _a.position, textAlign = "center", textBaseline = "middle";
    if (position = this._isHorizontal() ? ["top", "bottom"].includes(position) ? position : "bottom" === this._funnelAlign ? "top" : "bottom" : ["left", "right"].includes(position) ? position : "left" === this._funnelAlign ? "right" : "left", false !== (null === (_b = this._spec.outerLabel) || void 0 === _b ? void 0 : _b.alignLabel)) ({ x, y } = this._getPositionByData(datum)), "left" === position ? (x = 0, textAlign = "left") : "right" === position ? (x = this.getLayoutRect().width, textAlign = "right") : "top" === position ? (y = 0, textBaseline = "top") : "bottom" === position && (y = this.getLayoutRect().height, textBaseline = "bottom");
    else {
      const { x2, y2 } = this._computeOuterLabelLinePosition(datum);
      x = x2, y = y2, "left" === position ? (x -= FUNNEL_LABEL_SPACE_WIDTH, textAlign = "right") : "right" === position ? (x += FUNNEL_LABEL_SPACE_WIDTH, textAlign = "left") : "top" === position ? (y -= FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "bottom") : "bottom" === position && (y += FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "top");
    }
    return {
      x,
      y,
      align: textAlign,
      textBaseline
    };
  }
  _computeOuterLabelLimit(datum) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this._isHorizontal()) return this._getMainAxisLength(this.isTransformLevel(datum));
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, categoryField = this.getCategoryField(), funnelLabelBounds = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct()) || void 0 === _c ? void 0 : _c.getGroupGraphicItem()) || void 0 === _d ? void 0 : _d.find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _e ? void 0 : _e.AABBBounds, funnelLabelWidth = funnelLabelBounds ? funnelLabelBounds.x2 - funnelLabelBounds.x1 : 0, outerLineSpace = this._funnelOuterLabelMark.line ? this._minLabelLineWidth : 0;
    let space = this.getLayoutRect().width - Math.max(shapeMiddleWidth, funnelLabelWidth);
    return "center" === this._funnelAlign && (space /= 2), space - outerLineSpace - (null !== (_g = null === (_f = this._spec.outerLabel) || void 0 === _f ? void 0 : _f.spaceWidth) && void 0 !== _g ? _g : FUNNEL_LABEL_SPACE_WIDTH);
  }
  _computeOuterLabelLinePosition(datum) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const categoryField = this.getCategoryField(), outerLabelMarkBounds = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.getProduct()) || void 0 === _c ? void 0 : _c.elements) || void 0 === _d ? void 0 : _d.find((el) => {
      var _a2;
      return (null === (_a2 = el.data[0]) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    })) || void 0 === _e ? void 0 : _e.getBounds(), labelMarkBounds = null === (_k = null === (_j = null === (_h = null === (_g = null === (_f = this._labelMark) || void 0 === _f ? void 0 : _f.getComponent()) || void 0 === _g ? void 0 : _g.getProduct()) || void 0 === _h ? void 0 : _h.getGroupGraphicItem()) || void 0 === _j ? void 0 : _j.find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _k ? void 0 : _k.AABBBounds, outerLabelSpec = null !== (_l = this._spec.outerLabel) && void 0 !== _l ? _l : {};
    let x1, x2, y1, y2;
    if (this._isHorizontal()) {
      const spaceWidth2 = null !== (_m = outerLabelSpec.spaceWidth) && void 0 !== _m ? _m : FUNNEL_LABEL_SPACE_WIDTH, points2 = this.getPoints(datum), shapeMiddleHeight = (Math.abs(points2[0].y - points2[1].y) + Math.abs(points2[2].y - points2[3].y)) / 2;
      return "top" === this._spec.outerLabel.position || "bottom" === this._funnelAlign ? (y1 = this._getPolygonCenter(points2).y - shapeMiddleHeight / 2 - spaceWidth2, y2 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y2) + spaceWidth2 : y1 - spaceWidth2, x1 = this._getPolygonCenter(points2).x, y1 - y2 < this._minLabelLineWidth && (y2 = y1 - this._minLabelLineWidth), x2 = x1) : (y1 = this._getPolygonCenter(points2).y + shapeMiddleHeight / 2 + spaceWidth2, y2 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y1) - spaceWidth2 : y1 + spaceWidth2, x1 = this._getPolygonCenter(points2).x, y2 - y1 < this._minLabelLineWidth && (y2 = y1 + this._minLabelLineWidth), x2 = x1), {
        x1,
        x2,
        y1,
        y2
      };
    }
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, labelWidth = (null == labelMarkBounds ? void 0 : labelMarkBounds.x2) - (null == labelMarkBounds ? void 0 : labelMarkBounds.x1) || 0, spaceWidth = null !== (_o = outerLabelSpec.spaceWidth) && void 0 !== _o ? _o : FUNNEL_LABEL_SPACE_WIDTH;
    return "right" === this._spec.outerLabel.position || "left" === this._funnelAlign ? (x1 = this._getPolygonCenter(points).x + Math.max(labelWidth / 2, shapeMiddleWidth / 2) + spaceWidth, x2 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x1) - spaceWidth : x1 + spaceWidth, y1 = this._getPolygonCenter(points).y, x2 - x1 < this._minLabelLineWidth && (x2 = x1 + this._minLabelLineWidth), y2 = y1) : (x1 = this._getPolygonCenter(points).x - Math.max(labelWidth / 2, shapeMiddleWidth / 2) - spaceWidth, x2 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x2) + spaceWidth : x1 - spaceWidth, y1 = this._getPolygonCenter(points).y, x1 - x2 < this._minLabelLineWidth && (x2 = x1 - this._minLabelLineWidth), y2 = y1), {
      x1,
      x2,
      y1,
      y2
    };
  }
  _computeMaxSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, maxSize = null !== (_a = this._spec.maxSize) && void 0 !== _a ? _a : FUNNEL_MAX_SIZE;
    return calcLayoutNumber(maxSize, size);
  }
  _computeMinSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, minSize = null !== (_a = this._spec.minSize) && void 0 !== _a ? _a : FUNNEL_MIN_SIZE;
    return calcLayoutNumber(minSize, size);
  }
  _isHorizontal() {
    return "left" === this._funnelOrient || "right" === this._funnelOrient;
  }
  _isReverse() {
    return "bottom" === this._funnelOrient || "right" === this._funnelOrient;
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._funnelMark];
  }
};
FunnelSeries.type = SeriesTypeEnum.funnel, FunnelSeries.mark = funnelSeriesMark, FunnelSeries.transformerConstructor = FunnelSeriesSpecTransformer;
var registerFunnelSeries = () => {
  registerPolygonMark(), registerTextMark(), registerRuleMark(), Factory2.registerSeries(FunnelSeries.type, FunnelSeries), Factory2.registerAnimation("funnel", (params2, preset) => Object.assign({
    appear: "clipIn" === preset ? void 0 : {
      type: "fadeIn"
    }
  }, FadeInOutAnimation)), registerCartesianGroupClipAnimation(), registerFadeInOutAnimation();
};

// node_modules/@visactor/vchart/esm/mark/polygon/pyramid-3d.js
var Pyramid3dMark = class _Pyramid3dMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _Pyramid3dMark.type;
  }
};
Pyramid3dMark.type = "pyramid3d";
var registerPyramid3dMark = () => {
  Factory2.registerMark(Pyramid3dMark.type, Pyramid3dMark), registerPyramid3dGraphic2(), registerVGrammarPolygonAnimation();
};

// node_modules/@visactor/vchart/esm/series/funnel/3d/funnel-3d-transformer.js
var Funnel3dSeriesSpecTransformer = class extends FunnelSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel3d"), spec.isTransform && this._addMarkLabelSpec(spec, "transform3d", "transformLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/funnel/3d/funnel-3d.js
var Funnel3dSeries = class _Funnel3dSeries extends FunnelSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel3d, this._funnelMarkName = "funnel3d", this._funnelMarkType = "pyramid3d", this._transformMarkName = "transform3d", this._transformMarkType = "pyramid3d", this.transformerConstructor = Funnel3dSeriesSpecTransformer;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.funnel3d), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel3d,
      key: this._seriesField,
      isSeriesMark: true
    }, {
      support3d: true
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.transform3d), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_b = this._theme) || void 0 === _b ? void 0 : _b.transform3d,
      key: this._seriesField,
      skipBeforeLayouted: false,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId()
    })), null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.outerLabel) || void 0 === _d ? void 0 : _d.visible) {
      const { line: line2 } = null !== (_e = this._spec.outerLabel) && void 0 !== _e ? _e : {}, { line: lineTheme } = null !== (_g = null === (_f = this._theme) || void 0 === _f ? void 0 : _f.outerLabel) && void 0 !== _g ? _g : {};
      this._funnelOuterLabelMark.label = this._createMark(_Funnel3dSeries.mark.outerLabel, {
        themeSpec: null === (_h = this._theme) || void 0 === _h ? void 0 : _h.outerLabel,
        key: this._seriesField,
        markSpec: this._spec.outerLabel
      }), this._funnelOuterLabelMark.line = this._createMark(_Funnel3dSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        key: this._seriesField,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label]
      });
    }
  }
  initMarkStyle() {
    super.initMarkStyle();
    const funnelMark = this._funnelMark;
    funnelMark && this.setMarkStyle(funnelMark, {
      z: (_) => {
        if (this._isHorizontal()) return 0;
        const points = this.getPoints(_), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    super.initLabelMarkStyle(labelMark), this.setMarkStyle(labelMark, {
      z: (_) => {
        if (this._isHorizontal()) return 0;
        const points = this.getPoints(_), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series), this._labelMark = labelMark, (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(labelMark.getComponent()), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend());
  }
};
Funnel3dSeries.type = SeriesTypeEnum.funnel3d, Funnel3dSeries.mark = funnel3dSeriesMark, Funnel3dSeries.transformerConstructor = Funnel3dSeriesSpecTransformer;
var registerFunnel3dSeries = () => {
  registerPyramid3dMark(), registerTextMark(), registerRuleMark(), Factory2.registerSeries(Funnel3dSeries.type, Funnel3dSeries);
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/utils.js
var computeRatio = (angle2, range2) => {
  const ratio = (angle2 - range2[0]) / (range2[1] - range2[0] || 1);
  return Math.max(0, Math.min(1, ratio));
};
var getInnerMostElements = (element) => {
  const updateElements = element.mark.elements.filter((e) => e.diffState === DiffState.update), minDepth = minInArray(updateElements.map((e) => {
    var _a;
    return null === (_a = null == e ? void 0 : e.data) || void 0 === _a ? void 0 : _a[0].depth;
  }));
  return updateElements.filter((e) => {
    var _a;
    return (null === (_a = null == e ? void 0 : e.data) || void 0 === _a ? void 0 : _a[0].depth) === minDepth;
  });
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/enter.js
var computeInnerAngleRange = (elements, startAngle, endAngle) => {
  if (isEmpty_default(elements)) return [startAngle, endAngle];
  return [minInArray(elements.map((m4) => 1 * m4.getGraphicAttribute("startAngle", false))), maxInArray(elements.map((m4) => 1 * m4.getGraphicAttribute("endAngle", false)))];
};
var sunburstEnter = (params2) => ({
  channel: {
    startAngle: {
      from: (d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
        return computeRatio(d.startAngle, angleRange) * (endAngle - startAngle) + startAngle;
      },
      to: (d) => d.startAngle
    },
    endAngle: {
      from: (d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
        return computeRatio(d.endAngle, angleRange) * (endAngle - startAngle) + startAngle;
      },
      to: (d) => d.endAngle
    },
    outerRadius: {
      from: (d) => d.innerRadius,
      to: (d) => d.outerRadius
    },
    innerRadius: {
      from: (d) => d.innerRadius,
      to: (d) => d.innerRadius
    }
  }
});

// node_modules/@visactor/vchart/esm/series/sunburst/animation/exit.js
var computeInnerAngleRange2 = (elements) => [minInArray(elements.map((m4) => 1 * m4.getGraphicAttribute("startAngle", false))), maxInArray(elements.map((m4) => 1 * m4.getGraphicAttribute("endAngle", false)))];
var sunburstExit = (params2) => ({
  channel: {
    startAngle: {
      from: (_d, element) => element.getGraphicAttribute("startAngle", false),
      to: (_d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), range2 = computeInnerAngleRange2(innerElements);
        return computeRatio(element.getGraphicAttribute("startAngle", false), range2) * (endAngle - startAngle) + startAngle;
      }
    },
    endAngle: {
      from: (_d, element) => element.getGraphicAttribute("endAngle", false),
      to: (_d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), range2 = computeInnerAngleRange2(innerElements);
        return computeRatio(element.getGraphicAttribute("endAngle", false), range2) * (endAngle - startAngle) + startAngle;
      }
    },
    outerRadius: {
      from: (_d, element) => element.getGraphicAttribute("outerRadius", false),
      to: () => params2.animationInfo().innerRadius
    },
    innerRadius: {
      from: (_d, element) => element.getGraphicAttribute("innerRadius", false),
      to: () => params2.animationInfo().innerRadius
    }
  }
});

// node_modules/@visactor/vchart/esm/series/sunburst/animation/preset.js
var sunburstPresetAnimation = (_params, preset) => {
  switch (preset) {
    case "fadeIn":
      return {
        type: "fadeIn"
      };
    case "growAngle":
      return {
        type: "growAngleIn"
      };
    default:
      return {
        type: "growRadiusIn"
      };
  }
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/index.js
var registerSunburstAnimation = () => {
  Factory2.registerAnimation("sunburst", (params2, preset) => ({
    appear: sunburstPresetAnimation(params2, preset),
    enter: sunburstEnter(params2),
    exit: sunburstExit(params2),
    disappear: sunburstExit(params2)
  }));
};

// node_modules/@visactor/vgrammar-hierarchy/es/format.js
var flattenNodes = (nodes, output = [], options) => {
  const hasMaxDepth = (null == options ? void 0 : options.maxDepth) >= 0;
  return nodes.forEach((node) => {
    (!hasMaxDepth || node.depth <= options.maxDepth) && (output.push((null == options ? void 0 : options.callback) ? options.callback(node) : node), node.children && (hasMaxDepth && node.depth === options.maxDepth ? (node.children = null, node.isLeaf = true) : flattenNodes(node.children, output, options)));
  }), output;
};

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/binary.js
function binary_default(parent, x0, y0, x1, y1) {
  const nodes = parent.children, n = nodes.length;
  let sum3 = 0;
  const sums = new Array(n + 1);
  sums[0] = 0;
  for (let i = 0; i < n; ++i) sum3 += nodes[i].value, sums[i + 1] = sum3;
  const partition = (i, j, value, x02, y02, x12, y12) => {
    if (i >= j - 1) {
      const node = nodes[i];
      return node.x0 = x02, node.y0 = y02, node.x1 = x12, void (node.y1 = y12);
    }
    const valueOffset = sums[i], valueTarget = value / 2 + valueOffset;
    let k2 = i + 1, hi = j - 1;
    for (; k2 < hi; ) {
      const mid = k2 + hi >>> 1;
      sums[mid] < valueTarget ? k2 = mid + 1 : hi = mid;
    }
    valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i + 1 < k2 && --k2;
    const valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
    if (x12 - x02 > y12 - y02) {
      const xk = value ? (x02 * valueRight + x12 * valueLeft) / value : x12;
      partition(i, k2, valueLeft, x02, y02, xk, y12), partition(k2, j, valueRight, xk, y02, x12, y12);
    } else {
      const yk = value ? (y02 * valueRight + y12 * valueLeft) / value : y12;
      partition(i, k2, valueLeft, x02, y02, x12, yk), partition(k2, j, valueRight, x02, yk, x12, y12);
    }
  };
  partition(0, n, parent.value, x0, y0, x1, y1);
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1, keyMap2 = {
  x0: "x0",
  x1: "x1",
  y0: "y0",
  y1: "y1"
}) {
  const nodes = parent.children;
  let node, i = -1;
  const n = nodes.length, k2 = parent.value && (x1 - x0) / parent.value;
  for (; ++i < n; ) node = nodes[i], node[keyMap2.y0] = y0, node[keyMap2.y1] = y1, node[keyMap2.x0] = x0, node[keyMap2.x1] = x0 += node.value * k2;
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  const nodes = parent.children;
  let node, i = -1;
  const n = nodes.length, k2 = parent.value && (y1 - y0) / parent.value;
  for (; ++i < n; ) node = nodes[i], node.x0 = x0, node.x1 = x1, node.y0 = y0, y0 += node.value * k2, node.y1 = y0;
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/sliceDice.js
function sliceDice_default(parent, x0, y0, x1, y1) {
  (parent.depth % 2 == 1 ? slice_default : dice_default)(parent, x0, y0, x1, y1);
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/squarify.js
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  const rows = [], nodes = parent.children;
  let row, nodeValue, i0 = 0, i1 = 0;
  const n = nodes.length;
  let dx, dy, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta, value = parent.value;
  for (; i0 < n; ) {
    dx = x1 - x0, dy = y1 - y0;
    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n);
    for (minValue = sumValue, maxValue = sumValue, alpha = Math.max(dy / dx, dx / dy) / (value * ratio), beta = sumValue * sumValue * alpha, minRatio = Math.max(maxValue / beta, beta / minValue); i1 < n; ++i1) {
      if (nodeValue = nodes[i1].value, sumValue += nodeValue, nodeValue < minValue && (minValue = nodeValue), nodeValue > maxValue && (maxValue = nodeValue), beta = sumValue * sumValue * alpha, newRatio = Math.max(maxValue / beta, beta / minValue), newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    row = Object.assign({}, parent, {
      value: sumValue,
      children: nodes.slice(i0, i1)
    }), rows.push(row), dx < dy ? dice_default(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1) : slice_default(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1), value -= sumValue, i0 = i1;
  }
  return rows;
}
var generateSquarify = (ratio) => (parent, x0, y0, x1, y1) => {
  squarifyRatio(ratio, parent, x0, y0, x1, y1);
};

// node_modules/@visactor/vgrammar-hierarchy/es/utils.js
var calculateNodeValue = (subTree, output, depth = 0, flattenIndex = -1, parent, getNodeKey, valueField = "value") => {
  let sum3 = 0, prevFlattenIndex = null != flattenIndex ? flattenIndex : -1, maxDepth = depth;
  return subTree.forEach((datum, index) => {
    var _a, _b;
    const node = {
      flattenIndex: ++prevFlattenIndex,
      key: getNodeKey ? getNodeKey(datum) : `${null !== (_a = null == parent ? void 0 : parent.key) && void 0 !== _a ? _a : ""}-${index}`,
      maxDepth: -1,
      depth,
      index,
      value: datum[valueField],
      isLeaf: true,
      datum: parent ? parent.datum.concat(datum) : [datum],
      parentKey: null == parent ? void 0 : parent.key
    };
    if (null === (_b = datum.children) || void 0 === _b ? void 0 : _b.length) {
      node.children = [], node.isLeaf = false;
      const res = calculateNodeValue(datum.children, node.children, depth + 1, prevFlattenIndex, node, getNodeKey, valueField);
      node.value = isNil_default(datum[valueField]) ? res.sum : Math.max(res.sum, toValidNumber(datum[valueField])), prevFlattenIndex = res.flattenIndex, maxDepth = Math.max(res.maxDepth, maxDepth);
    } else node.isLeaf = true, node.value = toValidNumber(datum[valueField]);
    sum3 += Math.abs(node.value), output.push(node);
  }), {
    sum: sum3,
    maxDepth,
    flattenIndex: prevFlattenIndex
  };
};
var eachBefore = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    ctxRes = callback(node, index, parent, ctxRes), (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachBefore(node.children, callback, node, ctxRes));
  }), ctx;
};
var eachAfter = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachAfter(node.children, callback, node, ctxRes)), ctxRes = callback(node, index, parent, ctxRes);
  }), ctxRes;
};

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/layout.js
var algorithms = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  sliceDice: sliceDice_default
};
var TreemapLayout = class _TreemapLayout {
  constructor(options) {
    var _a;
    this._filterByArea = (node, ratio) => {
      var _a2;
      const minArea = this._getMinAreaByDepth(node.depth);
      if (minArea > 0 && node.value * ratio < minArea) return false;
      if (null === (_a2 = node.children) || void 0 === _a2 ? void 0 : _a2.length) {
        const newChildren = node.children.filter((child) => this._filterByArea(child, ratio));
        newChildren.length ? newChildren.length !== node.children.length && (node.children = newChildren) : (node.isLeaf = true, node.children = null);
      }
      return true;
    }, this._getMinAreaByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.minVisibleArea) ? this.options.minVisibleArea[depth] : this.options.minVisibleArea) && void 0 !== _a2 ? _a2 : 0;
    }, this._getGapWidthByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.gapWidth) ? this.options.gapWidth[depth] : this.options.gapWidth) && void 0 !== _a2 ? _a2 : 0;
    }, this._getPaddingByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.padding) ? this.options.padding[depth] : this.options.padding) && void 0 !== _a2 ? _a2 : 0;
    }, this._getLabelPaddingByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.labelPadding) ? this.options.labelPadding[depth] : this.options.labelPadding) && void 0 !== _a2 ? _a2 : 0;
    }, this._layoutNode = (parent) => {
      const gapWidth = this._getGapWidthByDepth(parent.depth);
      let x0 = parent.x0, y0 = parent.y0, x1 = parent.x1, y1 = parent.y1;
      if (parent.maxDepth = this._maxDepth, gapWidth > 0 && (x0 += gapWidth / 2, x1 -= gapWidth / 2, y0 += gapWidth / 2, y1 -= gapWidth / 2, x0 > x1 && (x0 = (x0 + x1) / 2, x1 = x0), y0 > y1 && (y0 = (y0 + y1) / 2, y1 = y0), parent.x0 = x0, parent.x1 = x1, parent.y0 = y0, parent.y1 = y1), parent.children) {
        const labelPadding = this._getLabelPaddingByDepth(parent.depth), padding = this._getPaddingByDepth(parent.depth);
        padding > 0 && padding < Math.min(x1 - x0, y1 - y0) / 2 && (y0 += padding, y1 -= padding, x0 += padding, x1 -= padding), labelPadding > 0 && ("top" === this.options.labelPosition && y0 + labelPadding < y1 ? (parent.labelRect = {
          x0,
          y0,
          x1,
          y1: y0 + labelPadding
        }, y0 += labelPadding) : "bottom" === this.options.labelPosition && y1 - labelPadding > y0 ? (parent.labelRect = {
          x0,
          y0: y1 - labelPadding,
          x1,
          y1
        }, y1 -= labelPadding) : "left" === this.options.labelPosition && x0 + labelPadding < x1 ? (parent.labelRect = {
          x0,
          y0,
          x1: x0 + labelPadding,
          y1
        }, x0 += labelPadding) : "right" === this.options.labelPosition && x1 - labelPadding > x0 && (parent.labelRect = {
          x0: x1 - labelPadding,
          y0,
          x1,
          y1
        }, x1 -= labelPadding));
        const childGapWidth = this._getGapWidthByDepth(parent.depth + 1);
        childGapWidth > 0 && (x0 -= childGapWidth / 2, x1 += childGapWidth / 2, y0 -= childGapWidth / 2, y1 += childGapWidth / 2), this._splitNode(parent, x0, y0, x1, y1);
      }
    }, this.options = Object.assign({}, _TreemapLayout.defaultOpionts, options);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._splitNode = "squarify" === this.options.splitType ? generateSquarify(this.options.aspectRatio) : null !== (_a = algorithms[this.options.splitType]) && void 0 !== _a ? _a : algorithms.binary, this._maxDepth = -1;
  }
  layout(data, config2) {
    var _a;
    if (!data || !data.length) return [];
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    }, nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey, this.options.valueField);
    if (this._maxDepth = res.maxDepth, res.sum <= 0) return [];
    const root = {
      flattenIndex: -1,
      maxDepth: -1,
      key: "-1",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      x0: viewBox.x0,
      x1: viewBox.x1,
      y0: viewBox.y0,
      y1: viewBox.y1,
      children: nodes
    }, areaRatio = viewBox.width * viewBox.height / res.sum;
    return this._filterByArea(root, areaRatio), this._layout(root), null !== (_a = root.children) && void 0 !== _a ? _a : [];
  }
  _filterChildren(node) {
    const maxDepth = this.options.maxDepth;
    if (isNumber_default(maxDepth) && maxDepth >= 0 && node.depth >= maxDepth) return false;
    const minChildrenVisibleArea = this.options.minChildrenVisibleArea;
    if (isNumber_default(minChildrenVisibleArea) && Math.abs((node.x1 - node.x0) * (node.y1 - node.y0)) < minChildrenVisibleArea) return false;
    const minChildrenVisibleSize = this.options.minChildrenVisibleSize;
    return !isNumber_default(minChildrenVisibleSize) || !(Math.abs(node.x1 - node.x0) < minChildrenVisibleSize || Math.abs(node.y1 - node.y0) < minChildrenVisibleSize);
  }
  _layout(parent) {
    var _a;
    this._filterChildren(parent) || (parent.children = null, parent.isLeaf = true), this._layoutNode(parent), (null === (_a = parent.children) || void 0 === _a ? void 0 : _a.length) && parent.children.forEach((child) => {
      var _a2;
      (null === (_a2 = null == child ? void 0 : child.children) || void 0 === _a2 ? void 0 : _a2.length) ? this._layout(child) : this._layoutNode(child);
    });
  }
};
TreemapLayout.defaultOpionts = {
  aspectRatio: (1 + Math.sqrt(5)) / 2,
  gapWidth: 0,
  labelPadding: 0,
  labelPosition: "top",
  splitType: "binary",
  minVisibleArea: 10
};

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/transform.js
var transform24 = (options, upstreamData) => {
  const res = new TreemapLayout(options).layout(upstreamData, "width" in options ? {
    width: options.width,
    height: options.height
  } : {
    x0: options.x0,
    x1: options.x1,
    y0: options.y0,
    y1: options.y1
  });
  if (options.flatten) {
    const nodes = [];
    return flattenNodes(res, nodes, {
      maxDepth: null == options ? void 0 : options.maxDepth
    }), nodes;
  }
  return res;
};

// node_modules/@visactor/vgrammar-hierarchy/es/sunburst/layout.js
var keyMap = {
  x0: "startAngle",
  x1: "endAngle",
  y0: "innerRadius",
  y1: "outerRadius"
};
var SunburstLayout = class _SunburstLayout {
  constructor(options) {
    this._layoutNode = (parent) => {
      if (parent.maxDepth = this._maxDepth, parent.children) {
        const ir = this._parsedInnerRadius[parent.depth + 1], or = this._parsedOutterRadius[parent.depth + 1];
        dice_default(parent, parent.startAngle, Math.min(ir, or), parent.endAngle, Math.max(ir, or), keyMap);
        const labelOption = isArray_default(this.options.label) ? this.options.label[parent.depth + 1] : this.options.label;
        parent.children.forEach((child) => {
          if (child.x = this._parsedCenter[0], child.y = this._parsedCenter[1], labelOption) return this._layoutLabel(child, isBoolean_default(labelOption) ? {
            align: "center",
            rotate: "radial"
          } : labelOption);
        });
      }
    }, this.options = options ? Object.assign({}, _SunburstLayout.defaultOpionts, options) : Object.assign({}, _SunburstLayout.defaultOpionts);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._maxDepth = -1;
  }
  _parseRadius(viewBox, maxDepth) {
    const cx = viewBox.x0 + toPercent(this.options.center[0], viewBox.width), cy = viewBox.y0 + toPercent(this.options.center[1], viewBox.height), maxRadius = Math.min(viewBox.width / 2, viewBox.height / 2), innerRadius = this.options.innerRadius, outerRadius = this.options.outerRadius, isInnerArray = isArray_default(innerRadius), parsedInnerRadius = isInnerArray ? innerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(innerRadius, maxRadius), isOuterArray = isArray_default(outerRadius), gapRadius = this.options.gapRadius, parsedOuterRadius = isOuterArray ? outerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(outerRadius, maxRadius), rangeArr = range(0, maxDepth + 1);
    if (isInnerArray) this._parsedInnerRadius = rangeArr.map((entry, index) => {
      const ir = parsedInnerRadius[index];
      return isNil_default(ir) ? maxRadius : ir;
    }), this._parsedOutterRadius = rangeArr.map((entry, index) => {
      var _a, _b;
      return isOuterArray ? null !== (_a = parsedOuterRadius[index]) && void 0 !== _a ? _a : maxRadius : index < maxDepth ? this._parsedInnerRadius[index + 1] - (isArray_default(gapRadius) ? null !== (_b = gapRadius[index]) && void 0 !== _b ? _b : 0 : gapRadius) : parsedOuterRadius;
    });
    else if (isOuterArray) this._parsedOutterRadius = rangeArr.map((entry, index) => isNil_default(parsedOuterRadius[index]) ? maxRadius : parsedOuterRadius[index]), this._parsedInnerRadius = rangeArr.map((entry, index) => {
      var _a;
      return 0 === index ? parsedInnerRadius : this._parsedOutterRadius[index - 1] - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
    });
    else {
      const ir = toPercent(innerRadius, maxRadius), step = (parsedOuterRadius - ir) / (maxDepth + 1);
      this._parsedInnerRadius = rangeArr.map((entry, index) => ir + index * step), this._parsedOutterRadius = rangeArr.map((entry, index) => {
        var _a;
        return this._parsedInnerRadius[index] + step - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
      });
    }
    this._parsedCenter = [cx, cy], this._maxRadius = maxRadius;
  }
  layout(data, config2) {
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length) return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    return this._parseRadius(viewBox, res.maxDepth), this._maxDepth = res.maxDepth, this._layout(nodes, {
      flattenIndex: -1,
      maxDepth: -1,
      key: "-1",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      startAngle: this.options.startAngle,
      endAngle: this.options.endAngle
    }), nodes;
  }
  _layout(nodes, parent) {
    this._layoutNode(parent), nodes.forEach((node) => {
      var _a;
      (null === (_a = null == node ? void 0 : node.children) || void 0 === _a ? void 0 : _a.length) ? this._layout(node.children, node) : this._layoutNode(node);
    });
  }
  _layoutLabel(child, labelOption) {
    var _a;
    const angle2 = (child.startAngle + child.endAngle) / 2, r = ("start" === labelOption.align ? child.innerRadius : "end" === labelOption.align ? child.outerRadius : (child.innerRadius + child.outerRadius) / 2) + (null !== (_a = labelOption.offset) && void 0 !== _a ? _a : 0), pos = polarToCartesian({
      x: this._parsedCenter[0],
      y: this._parsedCenter[1]
    }, r, angle2);
    if (child.label = {
      x: pos.x,
      y: pos.y,
      textBaseline: "middle"
    }, "tangential" === labelOption.rotate) child.label.angle = angle2 - Math.PI / 2, child.label.textAlign = "center", child.label.maxLineWidth = Math.abs(child.endAngle - child.startAngle) * r;
    else {
      const uniformAngle = angle2 % (2 * Math.PI), formatAngle = uniformAngle < 0 ? uniformAngle + 2 * Math.PI : uniformAngle;
      formatAngle > Math.PI / 2 && formatAngle < 1.5 * Math.PI ? (child.label.angle = formatAngle + Math.PI, child.label.textAlign = "start" === labelOption.align ? "end" : "end" === labelOption.align ? "start" : "center") : (child.label.angle = formatAngle, child.label.textAlign = labelOption.align), child.label.maxLineWidth = child.isLeaf ? void 0 : Math.abs(child.outerRadius - child.innerRadius);
    }
  }
};
SunburstLayout.defaultOpionts = {
  startAngle: Math.PI / 2,
  endAngle: -3 * Math.PI / 2,
  center: ["50%", "50%"],
  gapRadius: 0,
  innerRadius: 0,
  outerRadius: "70%"
};

// node_modules/@visactor/vgrammar-hierarchy/es/lcg.js
var a2 = 1664525;
var c2 = 1013904223;
var m3 = 4294967296;
function randomLCG(initS = 1) {
  let s2 = initS;
  return () => (s2 = (a2 * s2 + c2) % m3) / m3;
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/enclose.js
function packEncloseRandom(circles, random2) {
  let i = 0;
  const sCircles = shuffleArray(Array.from(circles), random2), n = sCircles.length;
  let p, e, B = [];
  for (; i < n; ) p = sCircles[i], e && enclosesWeak(e, p) ? ++i : (B = extendBasis(B, p), e = encloseBasis(B), i = 0);
  return e;
}
function extendBasis(B, p) {
  let i, j;
  if (enclosesWeakAll(p, B)) return [p];
  for (i = 0; i < B.length; ++i) if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) return [B[i], p];
  for (i = 0; i < B.length - 1; ++i) for (j = i + 1; j < B.length; ++j) if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) return [B[i], B[j], p];
  Logger.getInstance().error("error when packEncloseRandom");
}
function enclosesNot(a3, b) {
  const dr = a3.radius - b.radius, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b) {
  const dr = a3.radius - b.radius + 1e-9 * Math.max(a3.radius, b.radius, 1), dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B) {
  for (let i = 0; i < B.length; ++i) if (!enclosesWeak(a3, B[i])) return false;
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    radius: a3.radius
  };
}
function encloseBasis2(a3, b) {
  const x1 = a3.x, y1 = a3.y, r1 = a3.radius, x2 = b.x, y2 = b.y, r2 = b.radius, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    radius: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b, c3) {
  const x1 = a3.x, y1 = a3.y, r1 = a3.radius, x2 = b.x, y2 = b.y, r2 = b.radius, x3 = c3.x, y3 = c3.y, r3 = c3.radius, a22 = x1 - x2, a32 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (2 * ab) - x1, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (2 * ab) - y1, yb = (a22 * c32 - a32 * c22) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    radius: r
  };
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/siblings.js
function place3(b, a3, c3) {
  const dx = b.x - a3.x;
  let x, a22;
  const dy = b.y - a3.y;
  let y, b2;
  const d2 = dx * dx + dy * dy;
  d2 ? (a22 = a3.radius + c3.radius, a22 *= a22, b2 = b.radius + c3.radius, b2 *= b2, a22 > b2 ? (x = (d2 + b2 - a22) / (2 * d2), y = Math.sqrt(Math.max(0, b2 / d2 - x * x)), c3.x = b.x - x * dx - y * dy, c3.y = b.y - x * dy + y * dx) : (x = (d2 + a22 - b2) / (2 * d2), y = Math.sqrt(Math.max(0, a22 / d2 - x * x)), c3.x = a3.x + x * dx - y * dy, c3.y = a3.y + x * dy + y * dx)) : (c3.x = a3.x + c3.radius, c3.y = a3.y);
}
function intersects(a3, b) {
  const dr = a3.radius + b.radius - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  const a3 = node._, b = node.next._, ab = a3.radius + b.radius, dx = (a3.x * b.radius + b.x * a3.radius) / ab, dy = (a3.y * b.radius + b.y * a3.radius) / ab;
  return dx * dx + dy * dy;
}
function getCicleNode(circle3) {
  return {
    _: circle3,
    next: null,
    prev: null
  };
}
function packSiblingsRandom(circles, random2) {
  const n = (circles = array(circles)).length;
  if (!n) return 0;
  let a3 = circles[0];
  if (a3.x = 0, a3.y = 0, 1 === n) return a3.radius;
  const b = circles[1];
  if (a3.x = -b.radius, b.x = a3.radius, b.y = 0, 2 === n) return a3.radius + b.radius;
  let c3 = circles[2];
  place3(b, a3, c3);
  let j, k2, sj, sk, aa, ca, isContinue, aNode = getCicleNode(a3), bNode = getCicleNode(b), cNode = getCicleNode(c3);
  aNode.next = bNode, cNode.prev = bNode, bNode.next = cNode, aNode.prev = cNode, cNode.next = aNode, bNode.prev = aNode;
  for (let i = 3; i < n; ++i) {
    isContinue = false, c3 = circles[i], place3(aNode._, bNode._, c3), cNode = getCicleNode(c3), j = bNode.next, k2 = aNode.prev, sj = bNode._.radius, sk = aNode._.radius;
    do {
      if (sj <= sk) {
        if (intersects(j._, cNode._)) {
          bNode = j, aNode.next = bNode, bNode.prev = aNode, --i, isContinue = true;
          break;
        }
        sj += j._.radius, j = j.next;
      } else {
        if (intersects(k2._, cNode._)) {
          aNode = k2, aNode.next = bNode, bNode.prev = aNode, --i, isContinue = true;
          break;
        }
        sk += k2._.radius, k2 = k2.prev;
      }
    } while (j !== k2.next);
    if (!isContinue) {
      for (cNode.prev = aNode, cNode.next = bNode, aNode.next = bNode.prev = bNode = cNode, aa = score(aNode), cNode = cNode.next; cNode !== bNode; ) ca = score(cNode), ca < aa && (aNode = cNode, aa = ca), cNode = cNode.next;
      bNode = aNode.next;
    }
  }
  const aCircles = [bNode._];
  for (cNode = bNode.next; cNode !== bNode; ) aCircles.push(cNode._), cNode = cNode.next;
  c3 = packEncloseRandom(aCircles, random2);
  for (let i = 0; i < n; ++i) a3 = circles[i], a3.x -= c3.x, a3.y -= c3.y;
  return c3.radius;
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/layout.js
function radiusLeaf(radius) {
  return function(node) {
    node.children || (node.radius = Math.max(0, +radius(node) || 0));
  };
}
function packChildrenRandom(padding, k2, random2) {
  return function(node) {
    const children = null == node ? void 0 : node.children;
    if (children) {
      let i;
      const n = children.length, r = padding(node) * k2 || 0;
      if (r) for (i = 0; i < n; ++i) children[i].radius += r;
      const e = packSiblingsRandom(children, random2);
      if (r) for (i = 0; i < n; ++i) children[i].radius -= r;
      node.radius = e + r;
    }
  };
}
function translateChild(k2, maxDepth) {
  return function(node, index, parent) {
    node.radius *= k2, node.maxDepth = maxDepth, parent && (node.x = parent.x + k2 * node.x, node.y = parent.y + k2 * node.y);
  };
}
var CirclePackingLayout = class _CirclePackingLayout {
  constructor(options) {
    this.options = options;
    const keyOption = null == options ? void 0 : options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._getPadding = isNumber_default(null == options ? void 0 : options.padding) ? (node) => options.padding : isArray_default(null == options ? void 0 : options.padding) ? (node) => {
      var _a;
      return null !== (_a = options.padding[node.depth + 1]) && void 0 !== _a ? _a : 0;
    } : () => 0, this._maxDepth = -1;
  }
  layout(data, config2) {
    var _a;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length) return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    this._maxDepth = res.maxDepth;
    const random2 = randomLCG(), root = {
      flattenIndex: -1,
      maxDepth: -1,
      key: "root",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      x: viewBox.x0 + viewBox.width / 2,
      y: viewBox.y0 + viewBox.height / 2
    }, { nodeSort, setRadius, padding, includeRoot } = null !== (_a = this.options) && void 0 !== _a ? _a : {};
    if (false !== nodeSort) {
      const sort = isFunction_default(nodeSort) ? this.options.nodeKey : _CirclePackingLayout.defaultOpionts.nodeSort;
      eachBefore([root], (node) => {
        node.children && node.children.length && node.children.sort(sort);
      });
    }
    if (setRadius) eachBefore([root], radiusLeaf(setRadius)), eachAfter([root], packChildrenRandom(this._getPadding, 0.5, random2)), eachBefore([root], translateChild(1, this._maxDepth));
    else {
      const size = Math.min(viewBox.width, viewBox.height);
      eachBefore([root], radiusLeaf(_CirclePackingLayout.defaultOpionts.setRadius)), eachAfter([root], packChildrenRandom(zero, 1, random2)), padding && eachAfter([root], packChildrenRandom(this._getPadding, root.radius / size, random2)), eachBefore([root], translateChild(size / (2 * root.radius), this._maxDepth));
    }
    return includeRoot ? [root] : nodes;
  }
};
CirclePackingLayout.defaultOpionts = {
  setRadius: (node) => Math.sqrt(node.value),
  padding: 0,
  nodeSort: (a3, b) => b.value - a3.value
};

// node_modules/@visactor/vgrammar-hierarchy/es/tree/cluster.js
function defaultSeparation(a3, b) {
  return a3.parentKey === b.parentKey ? 1 : 2;
}
function meanX(children) {
  return children.reduce((x, c3) => x + c3.x, 0) / children.length;
}
function maxY(children) {
  return 1 + children.reduce((y, c3) => Math.max(y, c3.y), 0);
}
function leafLeft(node) {
  let children = node.children;
  for (; children; ) children = (node = children[0]).children;
  return node;
}
function leafRight(node) {
  let children = node.children;
  for (; children; ) children = (node = children[children.length - 1]).children;
  return node;
}
function clusterTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation) {
  let previousNode, x = 0;
  if (eachAfter([root], (node) => {
    const children = node.children;
    children ? (node.x = meanX(children), node.y = maxY(children)) : (node.x = previousNode ? x += separation(node, previousNode) : 0, node.y = 0, previousNode = node);
  }), isNumber_default(minNodeGap) && isNumber_default(linkWidth)) eachAfter([root], (node) => {
    node.x = viewBox.x0 + (node.x - root.x) * minNodeGap, node.y = viewBox.y0 + (root.y - node.y) * linkWidth;
  });
  else {
    const left2 = leafLeft(root), right2 = leafRight(root), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2, kx2 = isNumber_default(minNodeGap) ? minNodeGap : viewBox.width / (x1 - x0);
    eachAfter([root], (node) => {
      node.x = viewBox.x0 + (node.x - x0) * kx2, node.y = viewBox.y0 + (1 - (root.y ? node.y / root.y : 1)) * viewBox.height;
    });
  }
  return root;
}

// node_modules/@visactor/vgrammar-hierarchy/es/tree/tree.js
function defaultSeparation2(a3, b) {
  return a3.parentKey === b.parentKey ? 1 : 2;
}
function nextLeft(v) {
  const children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  const children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  const change = shift / (wp.i - wm.i);
  wp.c -= change, wp.s += shift, wm.c += change, wp.z += shift, wp.m += shift;
}
function executeShifts(v) {
  let shift = 0, change = 0;
  const children = v.children;
  let w, i = children.length;
  for (; --i >= 0; ) w = children[i], w.z += shift, w.m += shift, shift += w.s + (change += w.c);
}
function nextAncestor(vim, v, ancestor) {
  var _a;
  const vimAncestor = null !== (_a = vim.a) && void 0 !== _a ? _a : vim;
  return vimAncestor.parent === v.parent ? vimAncestor : ancestor;
}
function createTreeNode(node, i) {
  return {
    _: node,
    i,
    parent: null,
    A: null,
    a: null,
    z: 0,
    m: 0,
    c: 0,
    s: 0,
    t: null
  };
}
function treeRoot(root) {
  const tree = createTreeNode(root, 0), nodes = [tree];
  let child, children, i, n, node = nodes.pop();
  for (; node; ) {
    if (children = node._.children, children) for (n = children.length, node.children = new Array(n), i = n - 1; i >= 0; --i) child = createTreeNode(children[i], i), node.children[i] = child, nodes.push(child), child.parent = node;
    node = nodes.pop();
  }
  return tree.parent = createTreeNode(null, 0), tree.parent.children = [tree], tree;
}
function tidyTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation2) {
  const apportion = (v, w, ancestor) => {
    if (w) {
      let shift, vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m;
      for (vim = nextRight(vim), vip = nextLeft(vip); vim && vip; ) vom = nextLeft(vom), vop = nextRight(vop), vop.a = v, shift = vim.z + sim - vip.z - sip + separation(vim._, vip._), shift > 0 && (moveSubtree(nextAncestor(vim, v, ancestor), v, shift), sip += shift, sop += shift), sim += vim.m, sip += vip.m, som += vom.m, sop += vop.m, vim = nextRight(vim), vip = nextLeft(vip);
      vim && !nextRight(vop) && (vop.t = vim, vop.m += sim - sop), vip && !nextLeft(vom) && (vom.t = vip, vom.m += sip - som, ancestor = v);
    }
    return ancestor;
  }, t = treeRoot(root);
  let getY;
  if (eachAfter([t], (v) => {
    const children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      const midpoint = (children[0].z + children[children.length - 1].z) / 2;
      w ? (v.z = w.z + separation(v._, w._), v.m = v.z - midpoint) : v.z = midpoint;
    } else w && (v.z = w.z + separation(v._, w._));
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }), t.parent.m = -t.z, eachBefore([t], (v) => {
    v._.x = v.z + v.parent.m, v.m += v.parent.m;
  }), isNumber_default(linkWidth)) getY = (node) => node.depth * linkWidth;
  else if (isArray_default(linkWidth) && linkWidth.length) {
    const sumed = linkWidth.reduce((res, entry, index) => (res[index] = 0 === index ? entry : res[index - 1] + entry, res), []);
    getY = (node) => {
      var _a;
      return null !== (_a = sumed[node.depth]) && void 0 !== _a ? _a : sumed[sumed.length - 1];
    };
  }
  if (isNumber_default(minNodeGap) && getY) {
    eachBefore([root], (node) => {
      node.x = viewBox.x0 + viewBox.width / 2 + node.x * minNodeGap, node.y = viewBox.y0 + getY(node);
    });
  } else {
    let left2 = root, right2 = root, bottom = root;
    eachBefore([root], (node) => {
      node.x < left2.x && (left2 = node), node.x > right2.x && (right2 = node), node.depth > bottom.depth && (bottom = node);
    });
    const s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = isNumber_default(minNodeGap) ? minNodeGap : viewBox.width / (right2.x + s2 + tx), ky2 = viewBox.height / (bottom.depth || 1);
    eachBefore([root], (node) => {
      node.x = viewBox.x0 + (node.x + tx) * kx2, node.y = viewBox.y0 + (getY ? getY(node) : node.depth * ky2);
    });
  }
  return root;
}

// node_modules/@visactor/vgrammar-hierarchy/es/tree/layout.js
var TreeLayout = class _TreeLayout {
  constructor(options) {
    this.options = Object.assign({}, _TreeLayout.defaultOpionts, options);
    const keyOption = null == options ? void 0 : options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._maxDepth = -1;
  }
  layout(data, config2) {
    const formattedData = array(data);
    if (!formattedData.length) return [];
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    }, nodes = [], res = calculateNodeValue(formattedData, nodes, 0, -1, null, this._getNodeKey);
    this._maxDepth = res.maxDepth;
    const isVertical3 = ["vertical", "TB", "BT"].includes(this.options.direction), vb = "radial" === this.options.layoutType ? {
      x0: 0,
      y0: 0,
      x1: 2 * Math.PI,
      y1: Math.min(viewBox.width, viewBox.height) / 2,
      width: 2 * Math.PI,
      height: Math.min(viewBox.width, viewBox.height) / 2
    } : isVertical3 ? viewBox : {
      x0: viewBox.y0,
      y0: viewBox.x0,
      x1: viewBox.y1,
      y1: viewBox.x1,
      width: viewBox.height,
      height: viewBox.width
    };
    if ("leaf" === this.options.alignType ? clusterTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth) : tidyTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth), "radial" === this.options.layoutType) {
      const center2 = {
        x: (viewBox.x0 + viewBox.x1) / 2,
        y: (viewBox.y0 + viewBox.y1) / 2
      };
      eachBefore(nodes, (node) => {
        const angle2 = node.x, radius = node.y, res2 = polarToCartesian(center2, radius, angle2);
        node.x = res2.x, node.y = res2.y, node.maxDepth = this._maxDepth;
      });
    } else ["BT", "RL"].includes(this.options.direction) ? eachBefore(nodes, (node) => {
      node.y = vb.y0 + vb.y1 - node.y, node.maxDepth = this._maxDepth;
    }) : eachBefore(nodes, (node) => {
      node.maxDepth = this._maxDepth;
    }), isVertical3 || eachBefore(nodes, (node) => {
      [node.x, node.y] = [node.y, node.x];
    });
    return nodes;
  }
};
TreeLayout.defaultOpionts = {
  direction: "horizontal",
  alignType: "depth",
  layoutType: "orthogonal"
};

// node_modules/@visactor/vgrammar-hierarchy/es/index.js
var registerTreemapTransforms = () => {
  Factory3.registerTransform("treemap", {
    transform: transform24,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/data/transforms/flatten.js
var flatten = (data, op = {}) => {
  if (!data) return [];
  const result2 = [];
  return flattenNodes(data, result2, op), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/sunburst.js
var sunburstLayout = (data, op) => {
  if (!data) return data;
  const options = op(), { width, height } = options;
  return new SunburstLayout(options).layout(data, {
    width,
    height
  });
};

// node_modules/@visactor/vchart/esm/constant/sunburst.js
var SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD = 10;

// node_modules/@visactor/vchart/esm/series/sunburst/tooltip-helper.js
var SunburstTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/drill.js
var DrillEnum;
!function(DrillEnum2) {
  DrillEnum2.DrillDown = "drillDown", DrillEnum2.DrillUp = "drillUp";
}(DrillEnum || (DrillEnum = {}));
var drillFilter = (data, op) => {
  const info = op.info(), keyField = op.keyField(), dataKey = null == info ? void 0 : info.key;
  if (isNil_default(dataKey)) return data;
  if (info.type === DrillEnum.DrillDown) {
    const targetNode = findHierarchyNode(data, dataKey, keyField, "children");
    return array(targetNode);
  }
  if (info.type === DrillEnum.DrillUp) {
    const targetNode = findHierarchyNodeParent(data, dataKey, keyField, "children");
    if (targetNode) return array(targetNode);
  }
  return data;
};

// node_modules/@visactor/vchart/esm/interaction/drill/drillable.js
var Drillable = class {
  _getDrillTriggerEvent(type) {
    var _a;
    const { mode } = this._drillParams;
    return null === (_a = getDefaultTriggerEventByMode(mode)) || void 0 === _a ? void 0 : _a[type];
  }
  _hideTooltip() {
    const tooltip3 = this.getChart().getComponentsByType(ComponentTypeEnum.tooltip)[0];
    tooltip3 && tooltip3.hideTooltip();
  }
  initDrillable(params2) {
    this._drillParams = params2;
  }
  initDrillableData(dataSet) {
    const { getRawData } = this._drillParams;
    registerDataSetInstanceTransform(dataSet, "drillFilter", drillFilter), getRawData().transform({
      type: "drillFilter",
      options: {
        info: () => this._drillInfo,
        keyField: () => this._drillParams.drillField()
      }
    });
  }
  bindDrillEvent() {
    const { event, getRawData, drillField } = this._drillParams, keyField = drillField();
    this._getDrillTriggerEvent("start") && event.on(this._getDrillTriggerEvent("start"), (e) => {
      var _a, _b, _c;
      if (isNil_default(e.datum) || isNil_default(null === (_a = e.datum) || void 0 === _a ? void 0 : _a[keyField])) return void this.drillUp();
      this._hideTooltip();
      const dataKey = e.datum[keyField], selectPath = null !== (_c = null === (_b = this._drillInfo) || void 0 === _b ? void 0 : _b.path) && void 0 !== _c ? _c : [], clickedPath = findHierarchyPath(getRawData().rawData, dataKey, keyField, "children");
      selectPath[selectPath.length - 1] === clickedPath[clickedPath.length - 1] ? this.drillUp() : this.drillDown(clickedPath);
    });
  }
  drillDown(drillPath = []) {
    const { getRawData, event } = this._drillParams;
    if (!isArray_default(drillPath) || isEmpty_default(drillPath)) return drillPath;
    const dataKey = drillPath[drillPath.length - 1];
    return this._drillInfo = {
      key: dataKey,
      path: drillPath,
      type: DrillEnum.DrillDown
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path: drillPath,
        type: DrillEnum.DrillDown
      },
      model: this
    }), drillPath;
  }
  drillUp() {
    var _a, _b;
    const { getRawData, event } = this._drillParams, path = null !== (_b = null === (_a = this._drillInfo) || void 0 === _a ? void 0 : _a.path) && void 0 !== _b ? _b : [];
    if (!isArray_default(path) || isEmpty_default(path)) return path;
    const dataKey = path.pop();
    return this._drillInfo = {
      key: dataKey,
      path,
      type: DrillEnum.DrillUp
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path,
        type: DrillEnum.DrillUp
      },
      model: this
    }), path;
  }
};

// node_modules/@visactor/vchart/esm/series/sunburst/constant.js
var sunburstSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  sunburst: {
    name: "sunburst",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/util/hierarchy.js
var appendHierarchyFields = (fields2, catField, valueField) => (fields2.push({
  key: catField,
  operations: ["values"]
}), fields2.push({
  key: valueField,
  operations: ["max", "min"]
}), fields2.push({
  key: DEFAULT_HIERARCHY_DEPTH,
  operations: ["max", "min", "values"]
}), fields2.push({
  key: DEFAULT_HIERARCHY_ROOT,
  operations: ["values"]
}), fields2);

// node_modules/@visactor/vchart/esm/series/sunburst/sunburst.js
var SunburstSeries = class _SunburstSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sunburst;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), this._centerX = this._spec.centerX, this._centerY = this._spec.centerY, this._offsetX = this._spec.offsetX, this._offsetY = this._spec.offsetY, this.__innerRadius = this._spec.innerRadius, this.__outerRadius = this._spec.outerRadius, this._gap = this._spec.gap, this._labelLayout = this._spec.labelLayout, this._sunburst = this._spec.sunburst, this._label = this._spec.label, this._labelAutoVisible = this._spec.labelAutoVisible;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    rawData && (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "sunburstLayout", sunburstLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
      type: "sunburstLayout",
      options: () => {
        const { innerRadius, outerRadius, gap, label } = this._computeLevel();
        return {
          nodeKey: this._categoryField,
          width: this.getLayoutRect().width,
          height: this.getLayoutRect().height,
          center: [isValid_default(this._centerX) ? this._centerX : this.getLayoutRect().width / 2, isValid_default(this._centerY) ? this._centerY : this.getLayoutRect().height / 2],
          startAngle: this._startAngle,
          endAngle: this._endAngle,
          innerRadius,
          outerRadius,
          gapRadius: gap,
          label
        };
      }
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  getStatisticFields() {
    return appendHierarchyFields(super.getStatisticFields(), this._categoryField, this._valueField);
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initArcMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initArcMarkStyle(), this._initLabelMarkStyle();
  }
  _initArcMark() {
    var _a, _b;
    if (false === this._sunburst.visible) return;
    const sunburstMark = this._createMark(_SunburstSeries.mark.sunburst, {
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.sunburst) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.sunburst) || void 0 === _b ? void 0 : _b.customShape
    });
    this._sunburstMark = sunburstMark;
  }
  _initArcMarkStyle() {
    isNil_default(this._sunburstMark) || this.setMarkStyle(this._sunburstMark, {
      x: (d) => d.x + (isValid_default(this._offsetX) ? this._offsetX : 0),
      y: (d) => d.y + (isValid_default(this._offsetY) ? this._offsetY : 0),
      outerRadius: (d) => d.outerRadius,
      innerRadius: (d) => d.innerRadius,
      startAngle: (d) => d.startAngle,
      endAngle: (d) => d.endAngle,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    if (true !== this._label.visible) return;
    const labelMark = this._createMark(_SunburstSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark;
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      visible: (d) => {
        var _a;
        const labelAutoVisible = this._labelAutoVisible;
        return isObject_default(labelAutoVisible) && true === labelAutoVisible.enable ? (d.endAngle - d.startAngle) * (d.outerRadius - d.innerRadius) > (null !== (_a = null == labelAutoVisible ? void 0 : labelAutoVisible.circumference) && void 0 !== _a ? _a : SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD) : this._spec.label.visible;
      },
      x: (d) => {
        var _a;
        return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.x) + (isValid_default(this._offsetX) ? this._offsetX : 0);
      },
      y: (d) => {
        var _a;
        return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.y) + (isValid_default(this._offsetY) ? this._offsetY : 0);
      },
      textBaseline: (d) => {
        var _a;
        return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textBaseline;
      },
      textAlign: (d) => {
        var _a;
        return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textAlign;
      },
      angle: (d) => {
        var _a, _b;
        return null !== (_b = null === (_a = d.label) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
      },
      fontSize: 10,
      text: (d) => d.name
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initTooltip() {
    this._tooltipHelper = new SunburstTooltipHelper(this), this._sunburstMark && this._tooltipHelper.activeTriggerSet.mark.add(this._sunburstMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a, _b;
    const animationParams = {
      animationInfo: () => ({
        innerRadius: this._computeRadius(array(this.__innerRadius))[0],
        outerRadius: this._computeRadius(array(this.__outerRadius))[0],
        startAngle: array(this._startAngle)[0],
        endAngle: array(this._endAngle)[0]
      })
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("sunburst")) || void 0 === _a2 ? void 0 : _a2(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _computeRadius(radius) {
    return isArray_default(radius) ? radius.map((r) => this._computeLayoutRadius() * r) : this._computeLayoutRadius() * radius;
  }
  _computeLevel() {
    return {
      innerRadius: this._computeRadius(this.__innerRadius),
      outerRadius: this._computeRadius(this.__outerRadius),
      gap: this._gap,
      label: this._labelLayout
    };
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._sunburstMark];
  }
  getMarkData(datum) {
    return (null == datum ? void 0 : datum.datum) ? datum.datum[datum.datum.length - 1] : datum;
  }
};
SunburstSeries.type = SeriesTypeEnum.sunburst, SunburstSeries.mark = sunburstSeriesMark, mixin(SunburstSeries, Drillable);
var registerSunBurstSeries = () => {
  Factory2.registerSeries(SunburstSeries.type, SunburstSeries), registerArcMark(), registerTextMark(), registerFadeInOutAnimation(), registerSunburstAnimation();
};

// node_modules/@visactor/vchart/esm/data/transforms/circle-packing.js
var circlePackingLayout = (data, op) => {
  if (!data) return data;
  const options = op(), { width, height } = options;
  if (0 === width || 0 === height) return data;
  return new CirclePackingLayout(options).layout(data, {
    width,
    height
  });
};

// node_modules/@visactor/vchart/esm/series/circle-packing/tooltip-helper.js
var CirclePackingTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// node_modules/@visactor/vchart/esm/series/circle-packing/animation.js
var circlePackingPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "growRadiusIn"
};
var registerCirclePackingAnimation = () => {
  Factory2.registerAnimation("circlePacking", (parmas, preset) => ({
    appear: circlePackingPresetAnimation(preset),
    enter: {
      type: "growRadiusIn"
    },
    exit: {
      type: "growRadiusOut"
    },
    disappear: {
      type: "growRadiusOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/circle-packing/constant.js
var circlePackingSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  circlePacking: {
    name: "circlePacking",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/circle-packing/circle-packing.js
var CirclePackingSeries = class _CirclePackingSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circlePacking;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._circlePacking = this._spec.circlePacking, this._label = this._spec.label, this._layoutPadding = this._spec.layoutPadding;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    isNil_default(rawData) || (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "circlePackingLayout", circlePackingLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
      type: "circlePackingLayout",
      options: () => ({
        nodeKey: this._categoryField,
        padding: this._layoutPadding,
        includeRoot: false,
        width: this.getLayoutRect().width || 1,
        height: this.getLayoutRect().height || 1
      })
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initCirclePackingMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
  }
  _initCirclePackingMark() {
    var _a, _b;
    if (false === (null === (_a = this._circlePacking) || void 0 === _a ? void 0 : _a.visible)) return;
    const circlePacking2 = this._createMark(_CirclePackingSeries.mark.circlePacking, {
      isSeriesMark: true
    }, {
      setCustomizedShape: null === (_b = this._spec.circlePacking) || void 0 === _b ? void 0 : _b.customShape
    });
    this._circlePackingMark = circlePacking2;
  }
  _initCirclePackingMarkStyle() {
    isNil_default(this._circlePackingMark) || this.setMarkStyle(this._circlePackingMark, {
      x: (d) => d.x,
      y: (d) => d.y,
      outerRadius: (d) => d.radius,
      innerRadius: 0,
      startAngle: 0,
      endAngle: 2 * Math.PI,
      fill: this.getColorAttribute(),
      zIndex: (d) => d.depth
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    var _a;
    if (false === (null === (_a = this._label) || void 0 === _a ? void 0 : _a.visible)) return;
    const labelMark = this._createMark(_CirclePackingSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark;
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      x: (d) => d.x,
      y: (d) => d.y,
      text: (d) => d.key,
      cursor: "pointer"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  getStatisticFields() {
    return appendHierarchyFields(super.getStatisticFields(), this._categoryField, this._valueField);
  }
  initTooltip() {
    this._tooltipHelper = new CirclePackingTooltipHelper(this), this._circlePackingMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circlePackingMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("circlePacking")) || void 0 === _a2 ? void 0 : _a2(void 0, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._circlePackingMark];
  }
  getMarkData(datum) {
    return (null == datum ? void 0 : datum.datum) ? datum.datum[datum.datum.length - 1] : datum;
  }
};
CirclePackingSeries.type = SeriesTypeEnum.circlePacking, CirclePackingSeries.mark = circlePackingSeriesMark, mixin(CirclePackingSeries, Drillable);
var registerCirclePackingSeries = () => {
  Factory2.registerSeries(CirclePackingSeries.type, CirclePackingSeries), registerArcMark(), registerTextMark(), registerScaleInOutAnimation(), registerCirclePackingAnimation();
};

// node_modules/@visactor/vgrammar-sankey/es/hierarchy.js
var calculateNodeValue2 = (subTree) => {
  let sum3 = 0;
  return subTree.forEach((node, index) => {
    var _a;
    isNil_default(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = calculateNodeValue2(node.children) : node.value = 0), sum3 += Math.abs(node.value);
  }), sum3;
};

// node_modules/@visactor/vgrammar-sankey/es/layout.js
function left(node) {
  return node.depth;
}
function right(node, maxDepth) {
  return maxDepth - 1 - node.endDepth;
}
function justify(node, maxDepth) {
  return node.sourceLinks.length ? node.depth : maxDepth - 1;
}
function center(node, maxDepth, nodeMap) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minInArray(node.sourceLinks.map((link2) => nodeMap[link2.target].depth)) - 1 : 0;
}
var ascendingNodeBreadth = (a3, b) => (null == a3 ? void 0 : a3.y0) - (null == b ? void 0 : b.y0);
var calcDivideValue = (node, isTarget) => {
  if (isNil_default(node.value)) return null;
  const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce((res2, sLink) => (isNil_default(sLink.value) ? res2.count += 1 : res2.sum += sLink.value, res2), {
    sum: 0,
    count: 0
  });
  return res.count > 0 ? (node.value - res.sum) / res.count : null;
};
var alignFunctions = {
  left,
  right,
  justify,
  center,
  start: left,
  end: right
};
var linkClampe = clamper(0, 1);
var SankeyLayout = class _SankeyLayout {
  constructor(options) {
    this._ascendingSourceBreadth = (a3, b) => ascendingNodeBreadth(this._nodeMap[a3.source], this._nodeMap[b.source]) || a3.index - b.index, this._ascendingTargetBreadth = (a3, b) => ascendingNodeBreadth(this._nodeMap[a3.target], this._nodeMap[b.target]) || a3.index - b.index, this.options = Object.assign({}, _SankeyLayout.defaultOptions, options);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._logger = Logger.getInstance(), this._alignFunc = isFunction_default(this.options.setNodeLayer) ? (node) => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];
  }
  layout(data, config2) {
    if (!data) return null;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    isVertical(this.options.direction) ? this._viewBox = {
      x0: viewBox.y0,
      x1: viewBox.y1,
      y0: viewBox.x0,
      y1: viewBox.x1,
      width: viewBox.height,
      height: viewBox.width
    } : this._viewBox = viewBox;
    const result2 = this.computeNodeLinks(data), nodes = result2.nodes;
    let links = result2.links;
    if (this._nodeMap = result2.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), ["right", "end", "justify"].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), this._maxDepth <= 0) return null;
    const columns = this.computeNodeBreadths(nodes);
    if (this.computeLinkBreadths(nodes), nodes.forEach((node) => {
      node.sourceLinks = node.sourceLinks.filter((link2) => !isNil_default(link2.source) && !isNil_default(link2.target)), node.targetLinks = node.targetLinks.filter((link2) => !isNil_default(link2.source) && !isNil_default(link2.target));
    }), links = links.filter((link2) => !isNil_default(link2.source) && !isNil_default(link2.target)), isVertical(this.options.direction)) if (this.options.inverse) {
      const viewY1 = this._viewBox.x1;
      nodes.forEach((node) => {
        const { y0, y1, x0, x1 } = node;
        node.y0 = viewY1 - x1, node.y1 = viewY1 - x0, node.x0 = y0, node.x1 = y1;
      }), links.forEach((link2) => {
        link2.vertical = true;
        const { x0, x1, y0, y1 } = link2;
        link2.x0 = y0, link2.x1 = y1, link2.y0 = viewY1 - x0, link2.y1 = viewY1 - x1;
      });
    } else nodes.forEach((node) => {
      const { y0, y1 } = node;
      node.y0 = node.x0, node.y1 = node.x1, node.x0 = y0, node.x1 = y1;
    }), links.forEach((link2) => {
      link2.vertical = true;
      const x0 = link2.x0, x1 = link2.x1;
      link2.x0 = link2.y0, link2.x1 = link2.y1, link2.y0 = x0, link2.y1 = x1;
    });
    else this.options.inverse && (nodes.forEach((node) => {
      const { x0, x1 } = node;
      node.x0 = viewBox.x1 - x1, node.x1 = viewBox.x1 - x0;
    }), links.forEach((link2) => {
      link2.x0 = viewBox.x1 - link2.x0, link2.x1 = viewBox.x1 - link2.x1;
    }));
    return links.forEach((link2) => {
      const sourceNode = this._nodeMap[link2.source], targetNode = this._nodeMap[link2.target];
      link2.sourceRect = {
        x0: sourceNode.x0,
        x1: sourceNode.x1,
        y0: sourceNode.y0,
        y1: sourceNode.y1
      }, link2.targetRect = {
        x0: targetNode.x0,
        x1: targetNode.x1,
        y1: targetNode.y1,
        y0: targetNode.y0
      };
    }), {
      nodes,
      links,
      columns
    };
  }
  computeHierarchicNodeLinks(originalNodes) {
    const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
    calculateNodeValue2(originalNodes);
    const doSubTree = (subTree, depth, parents) => {
      subTree.forEach((node, index) => {
        const nodeKey = this._getNodeKey ? this._getNodeKey(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`, nodeValue = isNil_default(node.value) ? 0 : toValidNumber(node.value);
        if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0;
        else {
          const nodeElement = {
            depth,
            datum: node,
            index,
            key: nodeKey,
            value: nodeValue,
            sourceLinks: [],
            targetLinks: []
          };
          nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
        }
        parents && originalLinks.push({
          source: parents[parents.length - 1].key,
          target: nodeKey,
          value: nodeValue,
          parents
        }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([nodeMap[nodeKey]]) : [nodeMap[nodeKey]]);
      });
    };
    return doSubTree(originalNodes, 0, null), originalLinks.forEach((link2, index) => {
      const key = `${link2.source}-${link2.target}`, linkDatum = pickWithout(link2, ["parents"]);
      if (linkDatum.parents = link2.parents.map((node) => pickWithout(node, ["sourceLinks", "targetLinks"])), linkMap[key]) return linkMap[key].value += toValidNumber(link2.value), void linkMap[key].datum.push(linkDatum);
      const linkElement = {
        index,
        key: `${link2.source}-${link2.target}`,
        source: link2.source,
        target: link2.target,
        datum: [linkDatum],
        value: link2.value,
        parents: link2.parents.map((parent) => parent.key)
      };
      links.push(linkElement), nodeMap[link2.source].sourceLinks.push(linkElement), nodeMap[link2.target].targetLinks.push(linkElement), linkMap[key] = linkElement;
    }), {
      nodes,
      links,
      nodeMap
    };
  }
  computeSourceTargetNodeLinks(data) {
    const nodes = [], links = [], nodeMap = {};
    data.nodes && data.nodes.forEach((node, index) => {
      const nodeElement = {
        depth: -1,
        datum: node,
        index,
        key: this._getNodeKey ? this._getNodeKey(node) : index,
        value: node.value,
        sourceLinks: [],
        targetLinks: []
      };
      nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);
    });
    const invalidLinks = [];
    return data.links.forEach((link2, index) => {
      const hasSource = !isNil_default(link2.source), hasTarget = !isNil_default(link2.target);
      if (data.nodes && (!nodeMap[link2.source] || !nodeMap[link2.target])) return;
      data.nodes || !hasSource || nodeMap[link2.source] || (nodeMap[link2.source] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link2.source,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link2.source])), data.nodes || !hasTarget || nodeMap[link2.target] || (nodeMap[link2.target] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link2.target,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link2.target]));
      const linkElement = {
        index,
        source: link2.source,
        target: link2.target,
        datum: link2,
        value: link2.value
      };
      this.options.divideNodeValueToLink && isNil_default(link2.value) && invalidLinks.push(linkElement), links.push(linkElement), hasSource && nodeMap[link2.source].sourceLinks.push(linkElement), hasTarget && nodeMap[link2.target].targetLinks.push(linkElement);
    }), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link2) => {
      const values = [calcDivideValue(nodeMap[link2.source]), calcDivideValue(nodeMap[link2.target], true)].filter((entry) => !isNil_default(entry));
      values.length && (link2.value = minInArray(values));
    }), {
      nodeMap,
      nodes,
      links
    };
  }
  computeNodeLinks(data) {
    let res;
    "links" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = true, res = this.computeHierarchicNodeLinks(data.nodes));
    let nodes = res.nodes;
    const links = res.links;
    if (this.options.linkSortBy) for (let i = 0, len = nodes.length; i < len; i++) nodes[i].sourceLinks.sort(this.options.linkSortBy), nodes[i].targetLinks.sort(this.options.linkSortBy);
    return this.options.dropIsolatedNode && (nodes = nodes.filter((node) => node.targetLinks.length || node.sourceLinks.length)), {
      nodes,
      links,
      nodeMap: res.nodeMap
    };
  }
  computeNodeValues(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      node.value = Math.max(isNil_default(node.value) ? 0 : toValidNumber(node.value), node.sourceLinks.reduce((sum3, link2) => {
        var _a;
        return sum3 + (null !== (_a = toValidNumber(link2.value)) && void 0 !== _a ? _a : 0);
      }, 0), node.targetLinks.reduce((sum3, link2) => {
        var _a;
        return sum3 + (null !== (_a = toValidNumber(link2.value)) && void 0 !== _a ? _a : 0);
      }, 0));
    }
  }
  computeNodeDepths(nodes) {
    var _a;
    const n = nodes.length;
    let next, nextMap, current = nodes, depth = 0, maxDepth = -1;
    const setNodeLayer = isFunction_default(this.options.setNodeLayer) ? this.options.setNodeLayer : null;
    for (; current.length && depth < n; ) {
      next = [], nextMap = {};
      for (let i = 0, curLen = current.length; i < curLen; i++) {
        const node = current[i];
        if (node && (node.depth = setNodeLayer && null !== (_a = setNodeLayer(node.datum)) && void 0 !== _a ? _a : depth, setNodeLayer && (maxDepth = Math.max(node.depth, maxDepth)), node.sourceLinks && node.sourceLinks.length)) for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
          const link2 = node.sourceLinks[j];
          nextMap[link2.target] || (next.push(this._nodeMap[link2.target]), nextMap[link2.target] = true);
        }
      }
      current = next, depth += 1;
    }
    depth > n && this._logger.warn("Error: there is a circular link"), this._maxDepth = setNodeLayer ? maxDepth + 1 : depth;
  }
  computeNodeEndDepths(nodes) {
    const n = nodes.length;
    let next, nextMap, current = nodes, depth = 0;
    for (; current.length && depth < n; ) {
      next = [], nextMap = {};
      for (let i = 0, curLen = current.length; i < curLen; i++) {
        const node = current[i];
        if (node) {
          node.endDepth = depth;
          for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
            const link2 = node.targetLinks[j];
            nextMap[link2.source] || (next.push(this._nodeMap[link2.source]), nextMap[link2.source] = true);
          }
        }
      }
      current = next, depth += 1;
    }
    depth > n && this._logger.warn("Error: there is a circular link");
  }
  computeNodeLayers(nodes) {
    const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;
    let nodeWidth = null, linkWidth = null, isEvenWidth = false;
    if (isString_default(nodeWidthOption)) {
      const ratio = clamp_default(parseFloat(nodeWidthOption.replace("%", "")) / 100, 0, 1);
      let stepWidth = width / (this._maxDepth - 1 + ratio);
      minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, linkWidth = stepWidth * (1 - ratio), isEvenWidth = true;
    } else if (isNumber_default(nodeWidthOption)) {
      if (nodeWidth = nodeWidthOption, isNumber_default(linkWidthOption)) linkWidth = linkWidthOption;
      else if (isNil_default(linkWidthOption)) {
        let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
        minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;
      }
      isEvenWidth = true;
    } else isFunction_default(nodeWidthOption) && isNumber_default(linkWidthOption) && (linkWidth = linkWidthOption);
    const columns = [];
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      node.layer = this._isHierarchic ? node.depth : clamp_default(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
      const layer = node.layer;
      layer === this._maxDepth - 1 && (node.isLastLayer = true), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [node];
    }
    if (this.options.nodeSortBy) for (let j = 0, colLen = columns.length; j < colLen; j++) columns[j].sort(this.options.nodeSortBy);
    if (!isEvenWidth && isFunction_default(nodeWidthOption)) {
      let curLayerX = this._viewBox.x0;
      for (let i = 0; i < this._maxDepth; i++) {
        const column = columns[i];
        let maxNodeWidth = 0, maxLinkWidth = 0;
        for (let j = 0, colLen = column && column.length; j < colLen; j++) {
          const node = column[j], curNodeWidth = nodeWidthOption(node);
          node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
          const sourceLinks = node.sourceLinks;
          for (let k2 = 0, linkLen = sourceLinks.length; k2 < linkLen; k2++) {
            const link2 = sourceLinks[k2], curLinkWidth = isFunction_default(linkWidthOption) ? linkWidthOption(link2, this._viewBox) : linkWidth;
            maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
          }
        }
        curLayerX += maxNodeWidth + maxLinkWidth;
      }
    }
    return columns;
  }
  initializeNodeBreadths(columns) {
    var _a, _b, _c;
    const minLinkHeight = null !== (_a = this.options.minLinkHeight) && void 0 !== _a ? _a : 0;
    let minNodeHeight = null !== (_b = this.options.minNodeHeight) && void 0 !== _b ? _b : 0;
    const maxNodeHeight = null !== (_c = this.options.maxNodeHeight) && void 0 !== _c ? _c : 1 / 0;
    let maxLinkHeight = this.options.maxLinkHeight;
    (isNil_default(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight), (isNil_default(maxLinkHeight) || maxLinkHeight > maxNodeHeight) && (maxLinkHeight = maxNodeHeight);
    let ky2 = 0, getGapY = null, forceNodeHeight = null;
    if (isFunction_default(this.options.nodeGap)) getGapY = this.options.nodeGap, ky2 = columns.reduce((val, column) => {
      const sumValue = column.reduce((sum3, node) => sum3 + node.value, 0), sumGapY = column.reduce((sum3, node) => sum3 + this.options.nodeGap(node), 0);
      return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
    }, 1 / 0);
    else {
      const maxRowCount = columns.reduce((cnt, column) => Math.max(cnt, column.length), 0), maxStepHeight = this._viewBox.height / maxRowCount;
      let gapY = Math.min(this.options.nodeGap, maxStepHeight);
      if (minNodeHeight + gapY > maxStepHeight && (gapY = minNodeHeight >= maxStepHeight ? maxStepHeight / 2 : (maxStepHeight - minNodeHeight) / 2, minNodeHeight = Math.min(maxStepHeight - gapY, minNodeHeight)), getGapY = () => gapY, this._gapY = gapY, this.options.equalNodeHeight) forceNodeHeight = this._viewBox.height / maxRowCount - gapY;
      else {
        const calGapY = minNodeHeight > 0 ? Math.max(gapY, minNodeHeight) : gapY;
        ky2 = columns.reduce((val, column) => {
          const sumValue = column.reduce((sum3, node) => sum3 + node.value, 0);
          return Math.min(val, (this._viewBox.height - ((column.length - 1) * calGapY + minNodeHeight)) / sumValue);
        }, 1 / 0);
      }
    }
    const isStartGap = "start" === this.options.gapPosition, isMiddleGap = !isStartGap && "end" !== this.options.gapPosition, getNodeHeight = isNumber_default(this.options.nodeHeight) ? (node) => this.options.nodeHeight : isFunction_default(this.options.nodeHeight) ? this.options.nodeHeight : forceNodeHeight > 0 ? (node) => forceNodeHeight : (node) => Math.max(node.value * ky2, 0), getLinkHeight = isNumber_default(this.options.linkHeight) ? () => this.options.linkHeight : isFunction_default(this.options.linkHeight) ? this.options.linkHeight : (link2, sourceNode, sourceNodeHeight) => Math.min(Math.max(sourceNode.value ? sourceNodeHeight * linkClampe(link2.value / sourceNode.value) : 0, minLinkHeight, 0), maxLinkHeight);
    for (let i = 0, columnCount = columns.length; i < columnCount; i++) {
      const nodes = columns[i];
      if (!nodes || !nodes.length) continue;
      let y = this._viewBox.y0, gapY = 0, nodeHeight = 0, calculatedNodeHeight = 0;
      for (let j = 0, len = nodes.length; j < len; j++) {
        const node = nodes[j];
        gapY = getGapY(node), isStartGap && (y += gapY), calculatedNodeHeight = getNodeHeight(node), nodeHeight = Math.min(Math.max(calculatedNodeHeight, minNodeHeight), maxNodeHeight), node.y0 = y, node.y1 = y + nodeHeight, y = isStartGap ? node.y1 : node.y1 + gapY;
        for (let k2 = 0, linkLen = node.sourceLinks.length; k2 < linkLen; k2++) {
          const link2 = node.sourceLinks[k2];
          link2.thickness = getLinkHeight(link2, node, calculatedNodeHeight);
        }
      }
      let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);
      if (deltaY > 0) if ("start" === this.options.crossNodeAlign) ;
      else if ("end" === this.options.crossNodeAlign) for (let j = 0, len = nodes.length; j < len; ++j) {
        const node = nodes[j];
        node.y0 += deltaY, node.y1 += deltaY;
      }
      else if ("parent" === this.options.crossNodeAlign) {
        const sourceNodes = nodes.reduce((res, node) => (node.targetLinks && node.targetLinks.length && node.targetLinks.forEach((link2) => {
          res[link2.source] = true;
        }), res), {});
        if (Object.keys(sourceNodes).length && columns[i - 1] && columns[i - 1].length) {
          const prevSourceNodes = columns[i - 1].filter((node) => sourceNodes[node.key]);
          if (prevSourceNodes && prevSourceNodes.length && prevSourceNodes[0].y0 !== nodes[0].y0) {
            const newDeltaY = prevSourceNodes[0].y0 - nodes[0].y0;
            for (let j = 0, len = nodes.length; j < len; ++j) {
              const node = nodes[j];
              node.y0 += newDeltaY, node.y1 += newDeltaY;
            }
          }
        }
      } else {
        deltaY /= nodes.length + 1;
        for (let j = 0, len = nodes.length; j < len; ++j) {
          const node = nodes[j];
          node.y0 += deltaY * (j + 1), node.y1 += deltaY * (j + 1);
        }
      }
      else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY >= 0)) {
        gapY += deltaY, this._gapY = Math.min(gapY);
        for (let j = 1, len = nodes.length; j < len; ++j) {
          const node = nodes[j];
          node.y0 += deltaY * j, node.y1 += deltaY * j;
        }
      }
      this.reorderLinks(nodes);
    }
  }
  computeNodeBreadths(nodes) {
    const columns = this.computeNodeLayers(nodes);
    this.initializeNodeBreadths(columns);
    const iterations = this.options.iterations;
    if (!this._isHierarchic && !isFunction_default(this.options.setNodeLayer) && !isFunction_default(this.options.nodeGap)) for (let i = 0; i < iterations; ++i) {
      const alpha = Math.pow(0.99, i), beta = Math.max(1 - alpha, (i + 1) / iterations);
      this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);
    }
    return columns;
  }
  relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (let j = 0, colLen = column.length; j < colLen; j++) {
        const target = column[j];
        let y = 0, w = 0;
        for (let k2 = 0, linkLen = target.targetLinks.length; k2 < linkLen; k2++) {
          const link2 = target.targetLinks[k2], v = link2.value * (target.layer - this._nodeMap[link2.source].layer);
          y += this.targetTop(this._nodeMap[link2.source], target) * v, w += v;
        }
        if (!(w > 0)) continue;
        const dy = (y / w - target.y0) * alpha;
        target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);
      }
      isNil_default(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  relaxRightToLeft(columns, alpha, beta) {
    for (let i = columns.length - 2; i >= 0; --i) {
      const column = columns[i];
      for (let j = 0, colLen = column.length; j < colLen; j++) {
        const source = column[j];
        let y = 0, w = 0;
        for (let k2 = 0, linkLen = source.sourceLinks.length; k2 < linkLen; k2++) {
          const link2 = source.sourceLinks[k2], v = link2.value * (this._nodeMap[link2.target].layer - source.layer);
          y += this.sourceTop(source, this._nodeMap[link2.target]) * v, w += v;
        }
        if (!(w > 0)) continue;
        const dy = (y / w - source.y0) * alpha;
        source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);
      }
      void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  resolveCollisions(nodes, alpha) {
    const i = nodes.length >> 1, subject = nodes[i];
    this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha), this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha), this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
  }
  resolveCollisionsTopToBottom(nodes, y, i, alpha) {
    for (; i < nodes.length; ++i) {
      const node = nodes[i], dy = (y - node.y0) * alpha;
      dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y = node.y1 + this._gapY;
    }
  }
  resolveCollisionsBottomToTop(nodes, y, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes[i], dy = (node.y1 - y) * alpha;
      dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y = node.y0 - this._gapY;
    }
  }
  targetTop(source, target) {
    let i, len, link2, y = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;
    for (i = 0, len = source.sourceLinks.length; i < len && (link2 = source.sourceLinks[i], link2.target !== target.key); i++) y += link2.thickness + this._gapY;
    for (i = 0, len = target.targetLinks.length; i < len && (link2 = target.targetLinks[i], link2.source !== source.key); i++) y -= link2.thickness;
    return y;
  }
  sourceTop(source, target) {
    let i, len, link2, y = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;
    for (i = 0, len = target.targetLinks.length; i < len && (link2 = target.targetLinks[i], link2.source !== source.key); i++) y += link2.thickness + this._gapY;
    for (i = 0, len = source.sourceLinks.length; i < len && (link2 = source.sourceLinks[i], link2.target !== target.key); i++) y -= link2.thickness;
    return y;
  }
  computeLinkBreadthsNoOverlap(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      let y0 = node.y0, reachBottom = false;
      for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
        const link2 = node.sourceLinks[j];
        reachBottom || (link2.y0 = y0 + link2.thickness / 2), link2.x0 = node.x1, y0 + link2.thickness > node.y1 || reachBottom ? (link2.y0 = node.y1 - link2.thickness / 2, reachBottom = true) : y0 += link2.thickness;
      }
      let y1 = node.y0;
      reachBottom = false;
      for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
        const link2 = node.targetLinks[j];
        reachBottom || (link2.y1 = y1 + link2.thickness / 2), link2.x1 = node.x0, y1 + link2.thickness > node.y1 || reachBottom ? (link2.y1 = node.y1 - link2.thickness / 2, reachBottom = true) : y1 += link2.thickness;
      }
    }
  }
  computeLinkBreadthsOverlap(nodes) {
    const linkOverlap = this.options.linkOverlap;
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i], pos = "start" === linkOverlap ? node.y0 : "end" === linkOverlap ? node.y1 : (node.y0 + node.y1) / 2, sign2 = "start" === linkOverlap ? 0.5 : "end" === linkOverlap ? -0.5 : 0;
      for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
        const link2 = node.sourceLinks[j];
        link2.y0 = pos + sign2 * link2.thickness, link2.x0 = node.x1;
      }
      for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
        const link2 = node.targetLinks[j];
        link2.y1 = pos + sign2 * link2.thickness, link2.x1 = node.x0;
      }
    }
  }
  computeLinkBreadths(nodes) {
    this.options.linkOverlap ? this.computeLinkBreadthsOverlap(nodes) : this.computeLinkBreadthsNoOverlap(nodes);
  }
  reorderNodeLinks(node) {
    if (isNil_default(this.options.linkSortBy)) {
      const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;
      for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {
        const link2 = targetLinks[j];
        this._nodeMap[link2.source].sourceLinks.sort(this._ascendingTargetBreadth);
      }
      for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {
        const link2 = sourceLinks[j];
        this._nodeMap[link2.target].targetLinks.sort(this._ascendingSourceBreadth);
      }
    }
  }
  reorderLinks(nodes) {
    if (isNil_default(this.options.linkSortBy)) for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);
    }
  }
};
SankeyLayout.defaultOptions = {
  iterations: 6,
  nodeAlign: "justify",
  direction: "horizontal",
  nodeWidth: 24,
  nodeGap: 8,
  crossNodeAlign: "middle",
  dropIsolatedNode: true
};

// node_modules/@visactor/vgrammar-sankey/es/transform.js
var transform28 = (options, upstreamData) => {
  const res = new SankeyLayout(options).layout(Array.isArray(upstreamData) ? upstreamData[0] : upstreamData, "width" in options ? {
    width: options.width,
    height: options.height
  } : {
    x0: options.x0,
    x1: options.x1,
    y0: options.y0,
    y1: options.y1
  });
  return res ? [res] : [];
};

// node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js
var SankeyHighlight = class _SankeyHighlight extends BaseInteraction {
  constructor(view, options) {
    var _a, _b;
    super(view, options), this.type = _SankeyHighlight.type, this.highlightAdjacentElement = (element, isNode) => {
      var _a2, _b2;
      const datum = element.getDatum(), allLinkElements = null !== (_b2 = null === (_a2 = this._linkMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = isNode ? [datum.key] : [datum.source, datum.target], getIsHighlight = isNode ? (linkDatum) => linkDatum.target === datum.key || linkDatum.source === datum.key : (linkDatum) => linkDatum.source === datum.source && linkDatum.target === datum.target;
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum();
        getIsHighlight(linkDatum) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {
          ratio: 1
        }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState));
      }), highlightNodes;
    }, this.highlightRelatedBySourceTarget = (element, isNode) => {
      var _a2, _b2, _c, _d, _e, _f;
      if (!isNode) return this.highlightAdjacentElement(element, isNode);
      const datum = element.getDatum(), allNodeElements = null !== (_b2 = null === (_a2 = this._nodeMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = [], allLinkElements = null !== (_d = null === (_c = this._linkMark) || void 0 === _c ? void 0 : _c.elements) && void 0 !== _d ? _d : [], highlightLinks = [], allNodes = allNodeElements.reduce((res, nodeEl) => {
        const nodeDatum = nodeEl.getDatum();
        return res[null == nodeDatum ? void 0 : nodeDatum.key] = {
          datum: nodeDatum,
          el: nodeEl
        }, res;
      }, {}), downNodes = [datum], upNodes = [datum];
      for (; downNodes.length; ) {
        const first = downNodes.pop();
        (null === (_e = null == first ? void 0 : first.sourceLinks) || void 0 === _e ? void 0 : _e.length) && first.sourceLinks.forEach((link2) => {
          highlightLinks.push(link2), allNodes[link2.target] && downNodes.push(allNodes[link2.target].datum);
        });
      }
      for (; upNodes.length; ) {
        const first = upNodes.pop();
        (null === (_f = null == first ? void 0 : first.targetLinks) || void 0 === _f ? void 0 : _f.length) && first.targetLinks.forEach((link2) => {
          highlightLinks.push(link2), allNodes[link2.source] && upNodes.push(allNodes[link2.source].datum);
        });
      }
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum();
        highlightLinks.some((link2) => link2.source === linkDatum.source && link2.target === linkDatum.target) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {
          ratio: 1
        }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState));
      }), highlightNodes;
    }, this.highlightRelatedElement = (element, isNode) => {
      var _a2, _b2, _c, _d, _e;
      const allLinkElements = null !== (_b2 = null === (_a2 = this._linkMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [];
      if (!!!(null === (_e = null === (_d = null === (_c = allLinkElements[0]) || void 0 === _c ? void 0 : _c.getDatum) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.parents)) return this.highlightRelatedBySourceTarget(element, isNode);
      const datum = element.getDatum(), highlightNodes = isNode ? [datum.key] : [datum.source, datum.target], upstreamLinks = this.parseUpstreamLinks(element, isNode);
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum(), originalDatum = array(linkDatum.datum);
        if (!isNode && linkDatum.source === datum.source && linkDatum.target === datum.target) return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
          ratio: 1
        });
        const selectedDatum = isNode ? originalDatum.filter((entry) => {
          var _a3;
          return (null !== (_a3 = entry.parents) && void 0 !== _a3 ? _a3 : []).some((par) => par.key === datum.key);
        }) : originalDatum.filter((entry) => {
          var _a3;
          return (null !== (_a3 = entry.parents) && void 0 !== _a3 ? _a3 : []).some((par) => par.key === datum.target);
        });
        if (selectedDatum && selectedDatum.length) {
          highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
          const ratio = selectedDatum.reduce((sum3, d) => sum3 + d.value, 0) / linkDatum.value;
          return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
            ratio
          });
        }
        const upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
        if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
          ratio: upSelectedLink.value / linkDatum.value
        });
        linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState);
      }), highlightNodes;
    }, this.highlightElement = (element, isNode) => {
      var _a2, _b2;
      const allNodeElements = null !== (_b2 = null === (_a2 = this._nodeMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = "related" === this.options.effect ? this.highlightRelatedElement(element, isNode) : this.highlightAdjacentElement(element, isNode);
      allNodeElements.forEach((el) => {
        highlightNodes.includes(el.getDatum().key) ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
      });
    }, this.handleStart = (e) => {
      e.element && (e.element.mark === this._nodeMark ? (this._activeElement = e.element, this.highlightElement(e.element, true)) : e.element.mark === this._linkMark && (this._activeElement = e.element, this.highlightElement(e.element, false)));
    }, this.handleReset = (e) => {
      e.element && e.element === this._activeElement && this.clearPrevElements();
    }, this.options = Object.assign({}, _SankeyHighlight.defaultOptions, options), this._nodeMark = null === (_a = view.getMarksBySelector(this.options.nodeSelector)) || void 0 === _a ? void 0 : _a[0], this._linkMark = null === (_b = view.getMarksBySelector(this.options.linkSelector)) || void 0 === _b ? void 0 : _b[0];
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    [this._linkMark, this._nodeMark].forEach((mark) => {
      mark && mark.elements.forEach((el) => {
        el.hasState(this.options.highlightState) && el.removeState(this.options.highlightState), el.hasState(this.options.blurState) && el.removeState(this.options.blurState);
      });
    });
  }
  parseUpstreamLinks(element, isNode) {
    const datum = element.getDatum();
    return (isNode ? datum.targetLinks : array(datum)).reduce((res, link2) => (array(link2.datum).forEach((dividedLink) => {
      var _a;
      const parents = null !== (_a = dividedLink.parents) && void 0 !== _a ? _a : [{
        key: dividedLink.source
      }], len = isNode ? parents.length : parents.length - 1;
      for (let i = 0; i < len; i++) {
        const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : datum.key, value = dividedLink.value, existingItem = res.find((item) => item.source === source && item.target === target);
        existingItem ? existingItem.value += value : res.push({
          source,
          target,
          value
        });
      }
    }), res), []);
  }
};
SankeyHighlight.type = "sankey-highlight", SankeyHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout",
  effect: "related"
};

// node_modules/@visactor/vgrammar-sankey/es/index.js
var registerSankeyTransforms = () => {
  Factory3.registerTransform("sankey", {
    transform: transform28,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey.js
var collectHierarchyField = (set2, data, field5) => {
  data.forEach((obj) => {
    isNil_default(obj[field5]) || set2.add(obj[field5]), obj.children && obj.children.length > 0 && collectHierarchyField(set2, obj.children, field5);
  });
};
var sankeyFormat = (data) => {
  var _a;
  if (!data || !isArray_default(data)) return [];
  if (data.length > 1) {
    const updateData = {
      links: [],
      nodes: []
    };
    return data.forEach((datum) => {
      "links" !== datum.id && "nodes" !== datum.id || (updateData[datum.id] = datum.values);
    }), [updateData];
  }
  return (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data;
};
var sankeyLayout = (data, op) => {
  if (!data || !(null == op ? void 0 : op.view) || !data.length) return [];
  const view = op.view();
  if (view.x1 - view.x0 == 0 || view.y1 - view.y0 == 0 || view.x1 - view.x0 == -1 / 0 || view.x1 - view.x0 == 1 / 0 || view.y1 - view.y0 == -1 / 0 || view.y1 - view.y0 == 1 / 0) return [];
  const originalData = data[0];
  if (("source" !== op.sourceField || "target" !== op.targetField || "value" !== op.valueField) && originalData.links) {
    const updatedData = [];
    originalData.links.forEach((datum) => {
      const updatedDatum = {};
      for (const key in datum) key === op.sourceField ? updatedDatum.source = datum[op.sourceField] : key === op.targetField ? updatedDatum.target = datum[op.targetField] : key === op.valueField ? updatedDatum.value = datum[op.valueField] : updatedDatum[key] = datum[key];
      updatedData.push(updatedDatum);
    }), originalData.links = updatedData;
  }
  const layout2 = new SankeyLayout(op), result2 = [];
  return result2.push(layout2.layout(originalData, view)), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey-nodes.js
var sankeyNodes = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].nodes) && void 0 !== _b ? _b : [];
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey-links.js
var sankeyLinks = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].links) && void 0 !== _b ? _b : [];
};

// node_modules/@visactor/vchart/esm/series/sankey/tooltip-helper.js
var SankeySeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getDimensionData = (datum) => {
      if (datum.source) {
        if (isNumber_default(datum.source)) {
          const seriesKeys = this.series.getSeriesKeys();
          return seriesKeys[datum.source] + " => " + seriesKeys[datum.target];
        }
        return datum.source + " => " + datum.target;
      }
      return datum.datum ? datum.datum[this.series.getSpec().categoryField] : datum.key;
    }, this.markTooltipValueCallback = (datum) => datum.value;
  }
};

// node_modules/@visactor/vchart/esm/series/sankey/animation.js
var sankeyGrowIn = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: {
    overall: isOverall ? params2.growFrom() : isOverall,
    orient: "positive"
  }
});
var sankeyNodePresetAnimation = (params2, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : sankeyGrowIn(params2);
var sankeyLinkPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "linkPathGrowIn"
};
var registerSankeyAnimation = () => {
  Factory2.registerAnimation("sankeyNode", (params2, preset) => Object.assign({
    appear: sankeyNodePresetAnimation(params2, preset)
  }, FadeInOutAnimation)), Factory2.registerAnimation("sankeyLinkPath", (params2, preset) => ({
    appear: sankeyLinkPresetAnimation(preset),
    enter: {
      type: "linkPathGrowIn"
    },
    exit: {
      type: "linkPathGrowOut"
    },
    disappear: {
      type: "linkPathGrowOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/mark/link-path.js
var LinkPathMark = class _LinkPathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _LinkPathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      x0: 0,
      y0: 0,
      x1: 100,
      y1: 100,
      thickness: 1,
      round: true
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id = this.getProductId(), direction = this.getStyle("direction");
    this._product = view.glyph("linkPath", null != group ? group : view.rootMark).id(id).configureGlyph({
      direction
    }), this._compiledProductId = id;
  }
};
LinkPathMark.type = "linkPath";
var registerLinkPathMark = () => {
  registerLinkPathGlyph(), Factory2.registerMark(LinkPathMark.type, LinkPathMark);
};

// node_modules/@visactor/vchart/esm/series/sankey/constant.js
var sankeySeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  node: {
    name: "node",
    type: "rect"
  },
  link: {
    name: "link",
    type: "linkPath"
  }
});

// node_modules/@visactor/vchart/esm/series/sankey/sankey-transformer.js
var SankeySeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "node");
  }
};

// node_modules/@visactor/vchart/esm/series/sankey/sankey.js
var SankeySeries = class _SankeySeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sankey, this.transformerConstructor = SankeySeriesSpecTransformer, this._nodeLayoutZIndex = LayoutZIndex.Node, this._labelLayoutZIndex = LayoutZIndex.Label, this._viewBox = new Bounds(), this._fillByNode = (datum) => {
      var _a, _b, _c, _d, _e;
      if (datum && datum.sourceRect && datum.targetRect) return this._fillByLink(datum);
      const fill = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill;
      if (isValid_default(fill)) return fill;
      if (isValid_default(this._spec.seriesField)) {
        const colorScale = null === (_d = null === (_c = this._option) || void 0 === _c ? void 0 : _c.globalScale) || void 0 === _d ? void 0 : _d.getScale("color"), nodeDatum = (null == datum ? void 0 : datum.datum) ? datum.datum : datum;
        return null == colorScale ? void 0 : colorScale.scale(null == nodeDatum ? void 0 : nodeDatum[this._spec.seriesField]);
      }
      return null === (_e = this._colorScale) || void 0 === _e ? void 0 : _e.scale(this._getNodeNameFromData(datum));
    }, this._fillByLink = (datum) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const fill = null === (_b = null === (_a = this._spec.link) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill;
      if (fill) return fill;
      if (isValid_default(this._spec.seriesField)) {
        const sourceNode = null === (_d = null === (_c = this._nodesSeriesData) || void 0 === _c ? void 0 : _c.getLatestData()) || void 0 === _d ? void 0 : _d.find((entry) => datum.source === entry.key), nodeDatum = null == sourceNode ? void 0 : sourceNode.datum, colorScale = null === (_f = null === (_e = this._option) || void 0 === _e ? void 0 : _e.globalScale) || void 0 === _f ? void 0 : _f.getScale("color");
        return null == colorScale ? void 0 : colorScale.scale(null == nodeDatum ? void 0 : nodeDatum[this._spec.seriesField]);
      }
      const sourceName = isNumber_default(datum.source) ? this.getNodeList()[datum.source] : datum.source;
      return null === (_g = this._colorScale) || void 0 === _g ? void 0 : _g.scale(sourceName);
    }, this._handleEmphasisElement = (params2) => {
      var _a, _b, _c, _d, _e;
      const emphasisSpec = null !== (_a = this._spec.emphasis) && void 0 !== _a ? _a : {}, element = params2.item;
      "adjacency" === emphasisSpec.effect ? element && element.mark === (null === (_b = this._nodeMark) || void 0 === _b ? void 0 : _b.getProduct()) ? this._handleNodeAdjacencyClick(element) : element && element.mark === (null === (_c = this._linkMark) || void 0 === _c ? void 0 : _c.getProduct()) ? this._handleLinkAdjacencyClick(element) : this._handleClearEmpty() : "related" === emphasisSpec.effect && (element && element.mark === (null === (_d = this._nodeMark) || void 0 === _d ? void 0 : _d.getProduct()) ? this._handleNodeRelatedClick(element) : element && element.mark === (null === (_e = this._linkMark) || void 0 === _e ? void 0 : _e.getProduct()) ? this._handleLinkRelatedClick(element) : this._handleClearEmpty());
    }, this._handleClearEmpty = () => {
      var _a, _b;
      if (!this._needClear) return;
      const allNodeElements = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.getProductElements();
      if (!allNodeElements || !allNodeElements.length) return;
      const allLinkElements = null === (_b = this._linkMark) || void 0 === _b ? void 0 : _b.getProductElements();
      if (!allLinkElements || !allLinkElements.length) return;
      const states = [STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE];
      allNodeElements.forEach((el) => {
        el.removeState(states);
      }), allLinkElements.forEach((el) => {
        el.removeState(states);
      }), this._needClear = false;
    }, this._handleNodeAdjacencyClick = (element) => {
      const nodeDatum = element.getDatum(), highlightNodes = [nodeDatum.key];
      if (this._linkMark) {
        const allLinkElements = this._linkMark.getProductElements();
        if (!allLinkElements || !allLinkElements.length) return;
        allLinkElements.forEach((linkEl, i) => {
          const linkDatum = linkEl.getDatum();
          linkDatum.source === nodeDatum.key ? (highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS)) : linkDatum.target === nodeDatum.key ? (highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS)) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
        });
      }
      this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._needClear = true;
    }, this._handleLinkAdjacencyClick = (element) => {
      const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target];
      if (this._linkMark) {
        const allLinkElements = this._linkMark.getProductElements();
        if (!allLinkElements || !allLinkElements.length) return;
        allLinkElements.forEach((linkEl) => {
          linkEl === element ? (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
            ratio: 1
          })) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
        });
      }
      this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._needClear = true;
    }, this._handleNodeRelatedClick = (element) => {
      var _a;
      const nodeDatum = element.getDatum(), allNodeElements = this._nodeMark.getProductElements();
      if (!allNodeElements || !allNodeElements.length) return;
      const allLinkElements = this._linkMark.getProductElements();
      if (!allLinkElements || !allLinkElements.length) return;
      const father = (null === (_a = allLinkElements[0].getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source";
      if ("source" === father) {
        const highlightNodes = [nodeDatum.key], highlightLinks = [];
        if (allLinkElements.forEach((linkEl, i) => {
          var _a2, _b, _c, _d;
          const linkDatum = linkEl.getDatum(), father2 = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
          if (array(linkDatum[father2]).includes(nodeDatum.key)) {
            if (highlightLinks.includes(null !== (_a2 = linkDatum.key) && void 0 !== _a2 ? _a2 : linkDatum.index) || highlightLinks.push(null !== (_b = linkDatum.key) && void 0 !== _b ? _b : linkDatum.index), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), !highlightNodes.includes(linkDatum.target)) {
              highlightNodes.push(linkDatum.target);
              let targetNodeSourceLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.target).data[0].sourceLinks;
              for (; (null == targetNodeSourceLinks ? void 0 : targetNodeSourceLinks.length) > 0; ) {
                const newTargetNodeSourceLinks = [];
                return targetNodeSourceLinks.forEach((targetNodeSourceLinkDatum) => {
                  var _a3, _b2;
                  if (!highlightLinks.includes(null !== (_a3 = targetNodeSourceLinkDatum.key) && void 0 !== _a3 ? _a3 : targetNodeSourceLinkDatum.index) && (highlightLinks.push(null !== (_b2 = targetNodeSourceLinkDatum.key) && void 0 !== _b2 ? _b2 : targetNodeSourceLinkDatum.index), !highlightNodes.includes(targetNodeSourceLinkDatum.target))) {
                    highlightNodes.push(targetNodeSourceLinkDatum.target);
                    const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === targetNodeSourceLinkDatum.target);
                    newTargetNodeSourceLinks.push(sourceNodeTemp.data[0].targetLinks);
                  }
                }), void (targetNodeSourceLinks = newTargetNodeSourceLinks);
              }
            }
          } else if (linkDatum.target === nodeDatum.key && (highlightLinks.includes(null !== (_c = linkDatum.key) && void 0 !== _c ? _c : linkDatum.index) || highlightLinks.push(null !== (_d = linkDatum.key) && void 0 !== _d ? _d : linkDatum.index), !highlightNodes.includes(linkDatum.source))) {
            highlightNodes.push(linkDatum.source);
            let sourceNodeTargetLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.source).data[0].targetLinks;
            for (; (null == sourceNodeTargetLinks ? void 0 : sourceNodeTargetLinks.length) > 0; ) {
              const newSourceNodeTargetLinks = [];
              return sourceNodeTargetLinks.forEach((sourceNodeTargetLinkDatum) => {
                var _a3, _b2;
                if (!highlightLinks.includes(null !== (_a3 = sourceNodeTargetLinkDatum.key) && void 0 !== _a3 ? _a3 : sourceNodeTargetLinkDatum.index) && (highlightLinks.push(null !== (_b2 = sourceNodeTargetLinkDatum.key) && void 0 !== _b2 ? _b2 : sourceNodeTargetLinkDatum.index), !highlightNodes.includes(sourceNodeTargetLinkDatum.source))) {
                  highlightNodes.push(sourceNodeTargetLinkDatum.source);
                  const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === sourceNodeTargetLinkDatum.source);
                  newSourceNodeTargetLinks.push(sourceNodeTemp.data[0].targetLinks);
                }
              }), void (sourceNodeTargetLinks = newSourceNodeTargetLinks);
            }
          }
        }), this._linkMark) {
          const allLinkElements2 = this._linkMark.getProductElements();
          if (!allLinkElements2 || !allLinkElements2.length) return;
          allLinkElements2.forEach((linkEl, i) => {
            var _a2;
            highlightLinks.includes(null !== (_a2 = linkEl.getDatum().key) && void 0 !== _a2 ? _a2 : linkEl.getDatum().index) ? (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS)) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
          });
        }
        this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes);
      } else {
        const highlightNodes = [nodeDatum.key], upstreamLinks = nodeDatum.targetLinks.reduce((res, link2) => (array(link2.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i = 0; i < len; i++) {
            const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : nodeDatum.key, value = dividedLink.value, existingItem = res.find((item) => item.source === source && item.target === target);
            existingItem ? existingItem.value += value : res.push({
              source,
              target,
              value
            });
          }
        }), res), []);
        allLinkElements.forEach((linkEl, i) => {
          const linkDatum = linkEl.getDatum(), originalDatum = linkDatum.datum, selectedDatum = originalDatum ? originalDatum.filter((entry) => entry[father].some((par) => par.key === nodeDatum.key)) : null, upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const ratio = selectedDatum.reduce((sum3, d) => sum3 + d.value, 0) / linkDatum.value;
            return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio
            });
          }
          if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
            ratio: upSelectedLink.value / linkDatum.value
          });
          linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
        }), this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes);
      }
      this._needClear = true;
    }, this._handleLinkRelatedClick = (element) => {
      var _a;
      const allNodeElements = this._nodeMark.getProductElements();
      if (!allNodeElements || !allNodeElements.length) return;
      const allLinkElements = this._linkMark.getProductElements();
      if (!allLinkElements || !allLinkElements.length) return;
      if ("source" === ((null === (_a = element.getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
        const states = [STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE];
        this._linkMark && allLinkElements.forEach((linkEl) => {
          linkEl.removeState(states);
        }), this._nodeMark && allNodeElements.forEach((el) => {
          el.removeState(states);
        });
      } else {
        const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target], upstreamLinks = [];
        array(curLinkDatum.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i = 0; i < len - 1; i++) {
            const source = parents[i].key, target = parents[i + 1].key, value = dividedLink.value, existingItem = upstreamLinks.find((item) => item.source === source && item.target === target);
            upstreamLinks.push({
              source: parents[i].key,
              target: parents[i + 1].key,
              value: dividedLink.value
            }), existingItem ? existingItem.value += value : upstreamLinks.push({
              source,
              target,
              value
            });
          }
        }), allLinkElements.forEach((linkEl) => {
          const linkDatum = linkEl.getDatum(), originalDatum = linkDatum.datum;
          if (linkDatum.source === curLinkDatum.source && linkDatum.target === curLinkDatum.target) return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
            ratio: 1
          });
          const selectedDatum = originalDatum ? originalDatum.filter((entry) => {
            const parentKeysList = entry.parents.map((item) => item.key);
            return parentKeysList.includes(curLinkDatum.source) && parentKeysList.includes(curLinkDatum.target);
          }) : null;
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const val = selectedDatum.filter((entry) => entry.parents.some((par, index) => {
              var _a2;
              return par.key === curLinkDatum.source && (null === (_a2 = entry.parents[index + 1]) || void 0 === _a2 ? void 0 : _a2.key) === curLinkDatum.target;
            })).reduce((sum3, d) => sum3 + d.value, 0), ratio = val / linkDatum.value;
            return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio
            });
          }
          const upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
            ratio: upSelectedLink.value / linkDatum.value
          });
          linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
        }), this._highLightElements(allNodeElements, highlightNodes);
      }
      this._needClear = true;
    };
  }
  get direction() {
    var _a;
    return null !== (_a = this._spec.direction) && void 0 !== _a ? _a : "horizontal";
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : this._spec.categoryField);
  }
  initData() {
    var _a, _b, _c, _d;
    super.initData();
    const viewData = this.getViewData(), rawData = this.getRawData();
    if (rawData && viewData) {
      registerDataSetInstanceTransform(this._dataSet, "sankeyLayout", sankeyLayout), registerDataSetInstanceTransform(this._dataSet, "sankeyFormat", sankeyFormat), rawData.transform({
        type: "sankeyFormat"
      }, false), viewData.transform({
        type: "sankeyLayout",
        options: {
          view: () => ({
            x0: this._viewBox.x1,
            x1: this._viewBox.x2,
            y0: this._viewBox.y1,
            y1: this._viewBox.y2
          }),
          sourceField: this._spec.sourceField,
          targetField: this._spec.targetField,
          valueField: this._spec.valueField,
          direction: this.direction,
          crossNodeAlign: this._spec.crossNodeAlign,
          nodeAlign: null !== (_a = this._spec.nodeAlign) && void 0 !== _a ? _a : "justify",
          nodeGap: null !== (_b = this._spec.nodeGap) && void 0 !== _b ? _b : 8,
          nodeWidth: null !== (_c = this._spec.nodeWidth) && void 0 !== _c ? _c : 10,
          linkWidth: this._spec.linkWidth,
          minStepWidth: this._spec.minStepWidth,
          minNodeHeight: null !== (_d = this._spec.minNodeHeight) && void 0 !== _d ? _d : 4,
          maxNodeHeight: this._spec.maxNodeHeight,
          minLinkHeight: this._spec.minLinkHeight,
          maxLinkHeight: this._spec.maxLinkHeight,
          iterations: this._spec.iterations,
          nodeKey: this._spec.nodeKey,
          linkSortBy: this._spec.linkSortBy,
          nodeSortBy: this._spec.nodeSortBy,
          setNodeLayer: this._spec.setNodeLayer,
          dropIsolatedNode: this._spec.dropIsolatedNode,
          nodeHeight: this._spec.nodeHeight,
          linkHeight: this._spec.linkHeight,
          equalNodeHeight: this._spec.equalNodeHeight,
          linkOverlap: this._spec.linkOverlap,
          inverse: this._spec.inverse
        },
        level: TransformLevel.sankeyLayout
      });
      const { dataSet } = this._option;
      registerDataSetInstanceTransform(dataSet, "sankeyNodes", sankeyNodes), registerDataSetInstanceTransform(dataSet, "flatten", flatten);
      const nodesDataView = new DataView(dataSet, {
        name: `sankey-node-${this.id}-data`
      });
      nodesDataView.parse([this.getViewData()], {
        type: "dataview"
      }), nodesDataView.transform({
        type: "sankeyNodes"
      }), nodesDataView.transform({
        type: "flatten",
        options: {
          callback: (node) => {
            if (node.datum) {
              const nodeData = node.datum[node.depth];
              return Object.assign(Object.assign({}, node), nodeData);
            }
            return node;
          }
        }
      }, false), nodesDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._nodesSeriesData = new SeriesData(this._option, nodesDataView), registerDataSetInstanceTransform(dataSet, "sankeyLinks", sankeyLinks);
      const linksDataView = new DataView(dataSet, {
        name: `sankey-link-${this.id}-data`
      });
      linksDataView.parse([this.getViewData()], {
        type: "dataview"
      }), linksDataView.transform({
        type: "sankeyLinks"
      }), linksDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._linksSeriesData = new SeriesData(this._option, linksDataView);
    }
  }
  compileData() {
    var _a, _b;
    super.compileData(), null === (_a = this._linksSeriesData) || void 0 === _a || _a.compile(), null === (_b = this._nodesSeriesData) || void 0 === _b || _b.compile();
  }
  initMark() {
    var _a, _b, _c, _d;
    this._rootMark.setMarkConfig({
      overflow: this._spec.overflow,
      interactive: !!this._spec.overflow
    });
    const nodeMark = this._createMark(_SankeySeries.mark.node, {
      isSeriesMark: true,
      dataView: this._nodesSeriesData.getDataView(),
      dataProductId: this._nodesSeriesData.getProductId(),
      stateSort: null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.node) || void 0 === _b ? void 0 : _b.customShape
    });
    nodeMark && (nodeMark.setMarkConfig({
      zIndex: this._nodeLayoutZIndex
    }), this._nodeMark = nodeMark);
    const linkMark = this._createMark(_SankeySeries.mark.link, {
      dataView: this._linksSeriesData.getDataView(),
      dataProductId: this._linksSeriesData.getProductId(),
      stateSort: null === (_c = this._spec.link) || void 0 === _c ? void 0 : _c.stateSort
    }, {
      setCustomizedShape: null === (_d = this._spec.link) || void 0 === _d ? void 0 : _d.customShape
    });
    linkMark && (this._linkMark = linkMark);
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToNode = this.valueToNode.bind(this), this._markAttributeContext.valueToLink = this.valueToLink.bind(this);
  }
  valueToNode(value) {
    const nodes = this._nodesSeriesData.getLatestData(), specifyValue = array(value)[0];
    return nodes && nodes.find((node) => node.key === specifyValue);
  }
  valueToLink(value) {
    const links = this._linksSeriesData.getLatestData(), specifyValue = array(value);
    return links && links.find((link2) => link2 && link2.source === specifyValue[0] && link2.target === specifyValue[1]);
  }
  valueToPositionX(value) {
    const node = this.valueToNode(value);
    return null == node ? void 0 : node.x0;
  }
  valueToPositionY(value) {
    const node = this.valueToNode(value);
    return null == node ? void 0 : node.y0;
  }
  initMarkStyle() {
    this._initNodeMarkStyle(), this._initLinkMarkStyle();
  }
  _initNodeMarkStyle() {
    var _a, _b;
    const nodeMark = this._nodeMark;
    nodeMark && (this.setMarkStyle(nodeMark, {
      x: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y: (datum) => datum.y0,
      y1: (datum) => datum.y1
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Mark), this.setMarkStyle(nodeMark, {
      fill: null !== (_b = null === (_a = this._spec.node.style) || void 0 === _a ? void 0 : _a.fill) && void 0 !== _b ? _b : this._fillByNode
    }, "normal", AttributeLevel.User_Mark));
  }
  _initLinkMarkStyle() {
    var _a, _b;
    const linkMark = this._linkMark;
    linkMark && (this.setMarkStyle(linkMark, {
      x0: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y0: (datum) => datum.y0,
      y1: (datum) => datum.y1,
      thickness: (datum) => datum.thickness,
      direction: this.direction
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this.setMarkStyle(linkMark, {
      fill: null !== (_b = null === (_a = this._spec.link.style) || void 0 === _a ? void 0 : _a.fill) && void 0 !== _b ? _b : this._fillByLink
    }, "normal", AttributeLevel.User_Mark));
  }
  initLabelMarkStyle(labelMark, labelSpec) {
    if (!labelMark) return;
    const position = labelSpec.position;
    position && position.includes("inside") ? this.setMarkStyle(labelMark, {
      fill: "#ffffff",
      text: (datum) => this._createText(datum, labelSpec),
      maxLineWidth: (datum) => {
        var _a;
        return null !== (_a = labelSpec.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      }
    }) : this.setMarkStyle(labelMark, {
      fill: this._fillByNode,
      text: (datum) => this._createText(datum, labelSpec),
      maxLineWidth: labelSpec.limit
    }), labelMark.setMarkConfig({
      zIndex: this._labelLayoutZIndex
    });
  }
  _createText(datum, labelSpec) {
    if (isNil_default(datum) || isNil_default(datum.datum)) return "";
    let text2 = datum.datum[this._spec.categoryField] || "";
    const { formatMethod, formatter } = labelSpec || {}, { formatFunc, args } = getFormatFunction(formatMethod, formatter, text2, datum.datum);
    return formatFunc && (text2 = formatFunc(...args, {
      series: this
    })), text2;
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._nodeMark && this._nodeMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("sankeyNode")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("node", this._spec, this._markAttributeContext))), this._linkMark && this._linkMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("sankeyLinkPath")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("link", this._spec, this._markAttributeContext)));
  }
  initEvent() {
    var _a, _b, _c;
    super.initEvent(), null === (_a = this._nodesSeriesData.getDataView()) || void 0 === _a || _a.target.addListener("change", this.nodesSeriesDataUpdate.bind(this)), null === (_b = this._linksSeriesData.getDataView()) || void 0 === _b || _b.target.addListener("change", this.linksSeriesDataUpdate.bind(this));
    const emphasisSpec = null !== (_c = this._spec.emphasis) && void 0 !== _c ? _c : {};
    if (true !== this._option.disableTriggerEvent && emphasisSpec.enable && ("adjacency" === emphasisSpec.effect || "related" === emphasisSpec.effect)) {
      const event = "hover" === emphasisSpec.trigger ? "pointerover" : "pointerdown";
      this.event.on(event, {
        level: Event_Bubble_Level.chart
      }, this._handleEmphasisElement);
    }
  }
  nodesSeriesDataUpdate() {
    this._nodesSeriesData.updateData(), this._nodeList = null, this._setNodeOrdinalColorScale();
  }
  linksSeriesDataUpdate() {
    this._linksSeriesData.updateData();
  }
  _highLightElements(vGrammarElements, highlightNodes) {
    vGrammarElements && vGrammarElements.length && vGrammarElements.forEach((el) => {
      el.removeState([STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS]), highlightNodes.includes(el.getDatum().key) ? el.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS) : el.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
    });
  }
  initTooltip() {
    this._tooltipHelper = new SankeySeriesTooltipHelper(this), this._nodeMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodeMark), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark);
  }
  _setNodeOrdinalColorScale() {
    var _a, _b, _c, _d, _e;
    const colorScale = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalScale) || void 0 === _b ? void 0 : _b.getScale("color");
    if (null == colorScale ? void 0 : colorScale._specified) return void (this._colorScale = colorScale);
    let colorDomain, colorRange;
    colorScale && (colorDomain = colorScale.domain(), colorRange = colorScale.range()), colorRange || (colorRange = this._getDataScheme()), colorDomain && !isNil_default(colorDomain[0]) || (colorDomain = this.getNodeList(), colorDomain.length > 10 && (colorRange = null === (_c = this._getDataScheme()[1]) || void 0 === _c ? void 0 : _c.scheme));
    const ordinalScale = new ColorOrdinalScale();
    null === (_e = (_d = ordinalScale.domain(colorDomain)).range) || void 0 === _e || _e.call(_d, colorRange), this._colorScale = ordinalScale;
  }
  getNodeList() {
    var _a, _b;
    if (this._nodeList) return this._nodeList;
    const data = this._rawData.latestData[0], nodeList = (null == data ? void 0 : data.nodes) ? (null === (_a = data.nodes[0]) || void 0 === _a ? void 0 : _a.children) ? Array.from(this.extractNamesFromTree(data.nodes, this._spec.categoryField)) : data.nodes.map((datum, index) => datum[this._spec.categoryField]) : (null == data ? void 0 : data.links) ? Array.from(this.extractNamesFromLink(data.links)) : null === (_b = null == data ? void 0 : data.values) || void 0 === _b ? void 0 : _b.map((datum, index) => datum[this._spec.categoryField]);
    return this._nodeList = nodeList, nodeList;
  }
  _getNodeNameFromData(datum) {
    var _a;
    return (null == datum ? void 0 : datum.datum) ? datum.datum[this._spec.categoryField] : null !== (_a = datum.key) && void 0 !== _a ? _a : datum[this._spec.categoryField];
  }
  extractNamesFromTree(tree, categoryName) {
    const uniqueNames = /* @__PURE__ */ new Set();
    return tree.forEach((node) => {
      if (uniqueNames.add(node[categoryName]), node.children) {
        this.extractNamesFromTree(node.children, categoryName).forEach((name) => uniqueNames.add(name));
      }
    }), uniqueNames;
  }
  extractNamesFromLink(links) {
    const uniqueNames = /* @__PURE__ */ new Set(), { sourceField, targetField } = this._spec;
    return links.forEach((link2) => {
      isValid_default(link2[sourceField]) && uniqueNames.add(link2[sourceField]), isValid_default(link2[targetField]) && uniqueNames.add(link2[targetField]);
    }), uniqueNames;
  }
  getDimensionField() {
    return [this._spec.categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getRawDataStatisticsByField(field5, isNumeric) {
    var _a;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field5]) {
      this._viewDataStatistics && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field5]) ? this._rawStatisticsCache[field5] = this._viewDataStatistics.latestData[field5] : this._rawData && (this._rawStatisticsCache[field5] = {
        values: this._collectByField(field5)
      });
    }
    return this._rawStatisticsCache[field5];
  }
  _collectByField(field5) {
    var _a, _b, _c;
    const keyArray = [], rawData = null === (_b = null === (_a = this.getRawData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[0];
    if (!rawData) return [];
    if (rawData.links) (null === (_c = rawData.nodes) || void 0 === _c ? void 0 : _c.length) && rawData.nodes.forEach((node) => {
      node[this._seriesField] && keyArray.push(node[this._seriesField]);
    });
    else if (rawData.nodes) {
      const set2 = /* @__PURE__ */ new Set();
      return collectHierarchyField(set2, rawData.nodes, this._seriesField), Array.from(set2);
    }
    return keyArray;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this.getViewData().reRunAllTransform();
  }
  getDefaultShapeType() {
    return "square";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._nodeMark, this._linkMark];
  }
  getMarkData(datum) {
    return datum.datum ? isArray_default(datum.datum) ? datum.datum[datum.datum.length - 1] : datum.datum : datum;
  }
};
SankeySeries.type = SeriesTypeEnum.sankey, SankeySeries.transformerConstructor = SankeySeriesSpecTransformer, SankeySeries.mark = sankeySeriesMark;
var registerSankeySeries = () => {
  registerSankeyTransforms(), registerRectMark(), registerLinkPathMark(), registerTextMark(), registerSankeyAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(SankeySeries.type, SankeySeries);
};

// node_modules/@visactor/vchart/esm/data/transforms/hierarchy-dimension-statistics.js
var hierarchyDimensionStatistics = (data, op) => {
  let result2 = {}, fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length)) return result2;
  if (!data[0].latestData) return result2;
  const hierarchyData = data[0].latestData, flatData = flatten(hierarchyData);
  return result2 = dimensionStatistics([{
    latestData: flatData
  }], op), result2;
};

// node_modules/@visactor/vchart/esm/series/treemap/tooltip-helper.js
var TreemapTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => {
      var _a, _b;
      return null === (_b = null === (_a = this.series) || void 0 === _a ? void 0 : _a.getMarkData(datum)) || void 0 === _b ? void 0 : _b[this.series.getDimensionField()[0]];
    }, this.markTooltipValueCallback = (datum) => {
      var _a, _b;
      const { measureFields } = this._seriesCacheInfo, data = null === (_a = this.series) || void 0 === _a ? void 0 : _a.getMarkData(datum);
      if (measureFields[0] && data) return null !== (_b = data[measureFields[0]]) && void 0 !== _b ? _b : datum.value;
    }, this.dimensionTooltipTitleCallback = (datum) => {
      var _a;
      const { dimensionFields } = this._seriesCacheInfo, data = null === (_a = this.series) || void 0 === _a ? void 0 : _a.getMarkData(datum);
      if (dimensionFields[0] && data) return data[dimensionFields[0]];
    };
  }
  get defaultShapeType() {
    return "square";
  }
};

// node_modules/@visactor/vchart/esm/series/treemap/constant.js
var treemapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nonLeaf: {
    name: "nonLeaf",
    type: "rect"
  },
  leaf: {
    name: "leaf",
    type: "rect"
  },
  nonLeafLabel: {
    name: "nonLeafLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/treemap/animation.js
var treemapPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "growCenterIn"
};
var registerTreemapAnimation = () => {
  Factory2.registerAnimation("treemap", (params2, preset) => ({
    appear: treemapPresetAnimation(preset),
    enter: {
      type: "growCenterIn"
    },
    exit: {
      type: "growCenterOut"
    },
    disappear: {
      type: "growCenterOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/treemap/treemap-transform.js
var TreemapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nonLeaf", "nonLeafLabel", "initNonLeafLabelMarkStyle"), this._addMarkLabelSpec(spec, "leaf");
  }
};

// node_modules/@visactor/vchart/esm/series/treemap/treemap.js
var TreemapSeries = class _TreemapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.treemap, this.transformerConstructor = TreemapSeriesSpecTransformer, this._categoryField = "name", this._valueField = "value", this._viewBox = new Bounds(), this._enableAnimationHook = this.enableMarkAnimation.bind(this), this.isHierarchyData = () => true;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.roam && (this.initZoomable(this.event, this._option.mode), this._matrix = new Matrix()), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2, _b;
        return null !== (_b = null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : this._categoryField) && void 0 !== _b ? _b : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), isValidNumber_default(this._spec.maxDepth) && (this._maxDepth = this._spec.maxDepth - 1);
  }
  initData() {
    super.initData(), this.getViewData() && this._spec.drill && this.initDrillableData(this._dataSet);
  }
  compile() {
    super.compile(), this._runTreemapTransform();
  }
  _runTreemapTransform(render = false) {
    var _a, _b, _c, _d;
    const viewDataProduct = this._data.getProduct();
    viewDataProduct && viewDataProduct.transform([{
      type: "treemap",
      nameField: this._categoryField,
      valueField: this._valueField,
      x0: this._viewBox.x1,
      x1: this._viewBox.x2,
      y0: this._viewBox.y1,
      y1: this._viewBox.y2,
      maxDepth: this._maxDepth,
      gapWidth: this._spec.gapWidth,
      padding: this._spec.nodePadding,
      splitType: this._spec.splitType,
      aspectRatio: this._spec.aspectRatio,
      labelPadding: (null === (_a = this._spec.nonLeafLabel) || void 0 === _a ? void 0 : _a.visible) ? null === (_b = this._spec.nonLeafLabel) || void 0 === _b ? void 0 : _b.padding : 0,
      labelPosition: null === (_c = this._spec.nonLeafLabel) || void 0 === _c ? void 0 : _c.position,
      minVisibleArea: null !== (_d = this._spec.minVisibleArea) && void 0 !== _d ? _d : 10,
      minChildrenVisibleArea: this._spec.minChildrenVisibleArea,
      minChildrenVisibleSize: this._spec.minChildrenVisibleSize,
      flatten: true
    }, {
      type: "map",
      callback: (datum) => (datum && [DEFAULT_HIERARCHY_ROOT, "name"].forEach((key) => {
        datum[key] = datum.datum[datum.depth][this._categoryField];
      }), datum)
    }]), render && this.getCompiler().renderNextTick();
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  getRawDataStatisticsByField(field5, isNumeric) {
    var _a;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field5] && this._rawData) {
      const result2 = hierarchyDimensionStatistics([this._rawData], {
        fields: [{
          key: field5,
          operations: isNumeric ? ["min", "max"] : ["values"]
        }]
      })[field5];
      this._rawStatisticsCache[field5] = merge(null !== (_a = this._rawStatisticsCache[field5]) && void 0 !== _a ? _a : {}, result2);
    }
    return this._rawStatisticsCache[field5];
  }
  _createHierarchyDataStatistics(dataName, rawData) {
    registerDataSetInstanceTransform(this._dataSet, "hierarchyDimensionStatistics", hierarchyDimensionStatistics), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse(rawData, {
      type: "dataview"
    }), data.transform({
      type: "hierarchyDimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && this._seriesField !== this._categoryField && fields2.push({
            key: this._seriesField,
            operations: ["values"]
          }), fields2;
        }
      }
    }, false), data;
  }
  getStatisticFields() {
    return appendHierarchyFields(super.getStatisticFields(), this._categoryField, this._valueField);
  }
  initMark() {
    var _a, _b, _c, _d;
    const nonLeafMark = this._createMark(_TreemapSeries.mark.nonLeaf, {
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.nonLeaf) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.nonLeaf) || void 0 === _b ? void 0 : _b.customShape
    });
    nonLeafMark && (nonLeafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "nonLeaf")
    }]), this._nonLeafMark = nonLeafMark);
    const leafMark = this._createMark(_TreemapSeries.mark.leaf, {
      isSeriesMark: true,
      stateSort: null === (_c = this._spec.leaf) || void 0 === _c ? void 0 : _c.stateSort
    }, {
      setCustomizedShape: null === (_d = this._spec.leaf) || void 0 === _d ? void 0 : _d.customShape
    });
    leafMark && (leafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "leaf")
    }]), this._leafMark = leafMark);
  }
  initMarkStyle() {
    this._initLeafMarkStyle(), this._initNonLeafMarkStyle();
  }
  _initLeafMarkStyle() {
    this._leafMark && this.setMarkStyle(this._leafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initNonLeafMarkStyle() {
    this._nonLeafMark && this.setMarkStyle(this._nonLeafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initRichStyleOfLabelMark(labelMark) {
    "rich" === labelMark.getTextType() && this.setMarkStyle(labelMark, {
      maxWidth: (datum) => Math.abs(datum.x0 - datum.x1),
      maxHeight: (datum) => Math.abs(datum.y0 - datum.y1),
      ellipsis: true
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._initRichStyleOfLabelMark(labelMark));
  }
  initNonLeafLabelMarkStyle(labelMark) {
    labelMark && (this._nonLeafLabelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelRect ? (datum.labelRect.x0 + datum.labelRect.x1) / 2 : (datum.x0 + datum.x1) / 2,
      y: (datum) => datum.labelRect ? (datum.labelRect.y0 + datum.labelRect.y1) / 2 : (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._initRichStyleOfLabelMark(labelMark));
  }
  initAnimation() {
    this.getMarksInType("rect").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("treemap")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.roam && (this.initDragEventOfSeries(this), this.event.on("panmove", (e) => {
      this.handlePan(e);
    }), this.initZoomEventOfSeries(this), this.event.on("zoom", (e) => {
      this.handleZoom(e);
    })), this._spec.drill && this.bindDrillEvent();
  }
  _getDataIdKey() {
    return "key";
  }
  initTooltip() {
    this._tooltipHelper = new TreemapTooltipHelper(this), this._leafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._leafMark), this._nonLeafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nonLeafMark);
  }
  _shouldFilterElement(datum, nodeType) {
    const isLeaf = datum.isLeaf;
    return "leaf" === nodeType ? !isLeaf : isLeaf;
  }
  handlePan(event) {
    const { delta } = event;
    if (0 === delta[0] && 0 === delta[1]) return;
    this._matrix.reset(), this._matrix.translate(delta[0], delta[1]);
    const { a: a3, b, c: c3, d, e, f } = this._matrix;
    this._matrix.multiply(a3, b, c3, d, e, f), this._viewBox.transformWithMatrix(this._matrix), this._runTreemapTransform(true);
  }
  handleZoom(event) {
    const { scale: scale4, scaleCenter } = event;
    if (1 === scale4) return;
    this._matrix.reset();
    const { x, y } = scaleCenter;
    this._matrix.translate(x, y), this._matrix.scale(scale4, scale4), this._matrix.translate(-x, -y);
    const { a: a3, b, c: c3, d, e, f } = this._matrix;
    this._matrix.multiply(a3, b, c3, d, e, f), this.disableMarkAnimation(), this.event.on(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook), this._viewBox.transformWithMatrix(this._matrix), this._runTreemapTransform(true);
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height), this._runTreemapTransform();
  }
  enableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.enable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m4) => {
      m4 && m4.getComponent() && m4.getComponent().getProduct().getGroupGraphicItem().enableAnimation();
    }), this.event.off(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook);
  }
  disableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.disable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m4) => {
      m4 && m4.getComponent() && m4.getComponent().getProduct().getGroupGraphicItem().disableAnimation();
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._nonLeafMark, this._leafMark];
  }
  getMarkData(datum) {
    return (null == datum ? void 0 : datum.datum) ? datum.datum[datum.datum.length - 1] : datum;
  }
};
TreemapSeries.type = SeriesTypeEnum.treemap, TreemapSeries.mark = treemapSeriesMark, TreemapSeries.transformerConstructor = TreemapSeriesSpecTransformer, mixin(TreemapSeries, Drillable), mixin(TreemapSeries, Zoomable);
var registerTreemapSeries = () => {
  registerFilterTransform(), registerMapTransform(), registerRectMark(), registerTextMark(), registerTreemapAnimation(), registerFadeInOutAnimation(), registerTreemapTransforms(), Factory2.registerSeries(TreemapSeries.type, TreemapSeries);
};

// node_modules/@visactor/vchart/esm/series/gauge/constant.js
var gaugeSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  segment: {
    name: "segment",
    type: "arc"
  },
  track: {
    name: "track",
    type: "arc"
  }
});
var gaugePointerSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pin: {
    name: "pin",
    type: "path"
  },
  pinBackground: {
    name: "pinBackground",
    type: "path"
  },
  pointer: {
    name: "pointer",
    type: ["path", "rect"]
  }
});

// node_modules/@visactor/vchart/esm/series/gauge/animation.js
var Appear_Grow6 = (params2) => ({
  channel: {
    angle: {
      from: params2.startAngle + Math.PI / 2
    }
  }
});
var Appear_FadeIn9 = {
  type: "fadeIn"
};
function gaugePointerPresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn9 : Appear_Grow6(params2);
}
var registerGaugePointerAnimation = () => {
  Factory2.registerAnimation("gaugePointer", (params2, preset) => {
    const animation = gaugePointerPresetAnimation(params2, preset);
    return {
      appear: animation,
      enter: animation,
      disappear: {
        type: "fadeOut"
      }
    };
  });
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge-pointer-transformer.js
var GaugePointerSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
};

// node_modules/@visactor/vchart/esm/series/gauge/pointer-tooltip-helper.js
var GaugePointerTooltipHelper = class extends BaseSeriesTooltipHelper {
  enableByType(activeType) {
    return "dimension" !== activeType;
  }
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge-pointer.js
var GaugePointerSeries = class _GaugePointerSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gaugePointer, this.transformerConstructor = GaugePointerSeriesSpecTransformer, this._pinMark = null, this._pointerMark = null, this._pinBackgroundMark = null;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setRadiusField(this._spec.radiusField), this._pointerType = "rect" === (null === (_a = this._spec.pointer) || void 0 === _a ? void 0 : _a.type) ? "rect" : "path";
  }
  initMark() {
    this._pinBackgroundMark = this._createMark(_GaugePointerSeries.mark.pinBackground), this._pointerMark = this._createMark(Object.assign(Object.assign({}, _GaugePointerSeries.mark.pointer), {
      type: this._pointerType
    }), {
      isSeriesMark: true
    }), this._pinMark = this._createMark(_GaugePointerSeries.mark.pin);
  }
  initMarkStyle() {
    this.initPinBackgroundMarkStyle(), this.initPointerMarkStyle(), this.initPinMarkStyle();
  }
  initGroups() {
  }
  initPointerMarkStyle() {
    const pointerMark = this._pointerMark, pointerSpec = this._spec.pointer;
    pointerMark && (this.setMarkStyle(pointerMark, {
      x: (datum) => {
        var _a, _b;
        const { x } = this._getPointerAnchor(datum, pointerSpec);
        return x - this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0);
      },
      y: (datum) => {
        var _a, _b;
        const { y } = this._getPointerAnchor(datum, pointerSpec);
        return y - this._getPointerHeight(datum) * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[1]) && void 0 !== _b ? _b : 0);
      },
      anchor: (datum) => {
        const { x, y } = this._getPointerAnchor(datum, pointerSpec);
        return [x, y];
      },
      fill: this.getColorAttribute(),
      zIndex: 200
    }), "path" === this._pointerType ? this.setMarkStyle(pointerMark, {
      scaleX: this._getPointerWidth.bind(this),
      scaleY: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) + Math.PI / 2
    }) : this.setMarkStyle(pointerMark, {
      width: this._getPointerWidth.bind(this),
      height: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) - Math.PI / 2
    }));
  }
  initTooltip() {
    this._tooltipHelper = new GaugePointerTooltipHelper(this), this._pointerMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pointerMark);
  }
  _getPointerAnchor(datum, markSpec) {
    var _a;
    return null === (_a = markSpec.isOnCenter) || void 0 === _a || _a ? this.angleAxisHelper.center() : this.radiusAxisHelper.coordToPoint({
      radius: this._innerRadius * this._computeLayoutRadius(),
      angle: this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]])
    });
  }
  _getPointerWidth() {
    return this._spec.pointer.width * this._computeLayoutRadius();
  }
  _getPointerHeight(datum) {
    var _a, _b;
    const pointerSpec = this._spec.pointer, radiusField = this._radiusField[0];
    return isValid_default(this.radiusAxisHelper) && isValid_default(radiusField) ? this.radiusAxisHelper.dataToPosition([datum[radiusField]]) - (null !== (_a = null == pointerSpec ? void 0 : pointerSpec.innerPadding) && void 0 !== _a ? _a : 0) - (null !== (_b = null == pointerSpec ? void 0 : pointerSpec.outerPadding) && void 0 !== _b ? _b : 10) : pointerSpec.height * this._computeLayoutRadius();
  }
  _getPointerAngle(datum) {
    const domain = this.angleAxisHelper.getScale().domain(), max3 = maxInArray(domain), min3 = minInArray(domain), angle2 = clamp_default(datum[this._angleField[0]], min3, max3);
    return this.angleAxisHelper.dataToPosition([angle2]);
  }
  _getRotatedPointerCenterOffset(datum) {
    var _a, _b, _c, _d;
    const pointerSpec = this._spec.pointer, x = this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0), y = -this._getPointerHeight(datum) * (null !== (_d = null === (_c = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _c ? void 0 : _c[1]) && void 0 !== _d ? _d : 0), angle2 = this._getPointerAngle(datum) - Math.PI / 2, cos2 = Math.cos(angle2), sin2 = Math.sin(angle2);
    return {
      x: x * cos2 + y * sin2,
      y: -(y * cos2 - x * sin2)
    };
  }
  initPinBackgroundMarkStyle() {
    const pinBackgroundMark = this._pinBackgroundMark, pinBackgroundSpec = this._spec.pinBackground;
    pinBackgroundMark && this.setMarkStyle(pinBackgroundMark, {
      x: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).y,
      scaleX: () => pinBackgroundSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinBackgroundSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 100
    });
  }
  initPinMarkStyle() {
    const pinMark = this._pinMark, pinSpec = this._spec.pin;
    pinMark && this.setMarkStyle(pinMark, {
      x: (datum) => this._getPointerAnchor(datum, pinSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinSpec).y,
      scaleX: () => pinSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 300
    });
  }
  initInteraction() {
    this._parseInteractionConfig(this._pointerMark ? [this._pointerMark] : []);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._pointerMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("gaugePointer")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("pointer", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugePointerSeries.type = SeriesTypeEnum.gaugePointer, GaugePointerSeries.mark = gaugePointerSeriesMark, GaugePointerSeries.transformerConstructor = GaugePointerSeriesSpecTransformer;
var registerGaugePointerSeries = () => {
  Factory2.registerSeries(GaugePointerSeries.type, GaugePointerSeries), registerPathMark(), registerRectMark(), registerGaugePointerAnimation(), registerPolarBandAxis(), registerPolarLinearAxis();
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge-transformer.js
var GaugeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "segment");
  }
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge.js
var GaugeSeries = class _GaugeSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gauge, this.transformerConstructor = GaugeSeriesSpecTransformer, this._segmentMark = null, this._trackMark = null, this._padAngle = 0;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._padAngle = degreeToRadian(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
  }
  initData() {
    var _a;
    super.initData();
    registerDataSetInstanceTransform(this._option.dataSet, "spiltSegment", (data, op) => {
      const dataCollect = data.slice();
      return dataCollect.sort((a3, b) => a3[this._angleField[0]] - b[this._angleField[0]]), dataCollect.forEach((datum, i) => {
        datum[SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][SEGMENT_FIELD_END] : void 0;
      }), dataCollect;
    }), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "spiltSegment"
    }, false);
  }
  initMark() {
    super.initMark(), this._trackMark = this._createMark(_GaugeSeries.mark.track, {
      parent: this._arcGroupMark,
      dataView: false
    }), this._segmentMark = this._createMark(_GaugeSeries.mark.segment, {
      parent: this._arcGroupMark,
      isSeriesMark: true
    });
  }
  initMarkStyle() {
    super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
  }
  initSegmentMarkStyle() {
    var _a;
    const segmentMark = this._segmentMark;
    segmentMark && this.setMarkStyle(segmentMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart.bind(this),
      endAngle: this._getAngleValueEnd.bind(this),
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    });
  }
  generateRadiusStyle(spec) {
    if (!spec) return;
    const style = {};
    return spec.outerRadius && (style.outerRadius = () => this._computeLayoutRadius() * spec.outerRadius), spec.innerRadius && (style.innerRadius = () => this._computeLayoutRadius() * spec.innerRadius), style;
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (super.initMarkStyleWithSpec(mark, spec, key), mark && "segment" === mark.name) {
      const segmentSpec = this.getSpec().segment;
      if (segmentSpec) for (const state in segmentSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(segmentSpec.state[state]), state, AttributeLevel.User_Mark);
    }
  }
  initTooltip() {
    super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
  }
  initTrackMarkStyle() {
    var _a;
    const trackMark = this._trackMark;
    trackMark && this.setMarkStyle(trackMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._startAngle,
      endAngle: this._endAngle,
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      zIndex: 100
    });
  }
  _getAngleValueStartWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle2 = clamper(startAngle, (startAngle + endAngle) / 2)(startAngle + (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
    return this._spec.clamp ? valueInScaleRange(angle2, this.angleAxisHelper.getScale(0)) : angle2;
  }
  _getAngleValueEndWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle2 = clamper(endAngle, (startAngle + endAngle) / 2)(endAngle - (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
    return this._spec.clamp ? valueInScaleRange(angle2, this.angleAxisHelper.getScale(0)) : angle2;
  }
  _getAngleValueStartWithoutPadAngle(datum) {
    return isValid_default(datum[SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_START]]) : this._startAngle;
  }
  _getAngleValueEndWithoutPadAngle(datum) {
    return this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_END]]);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._segmentMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("segment", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugeSeries.type = SeriesTypeEnum.gauge, GaugeSeries.mark = gaugeSeriesMark, GaugeSeries.transformerConstructor = GaugeSeriesSpecTransformer;
var registerGaugeSeries = () => {
  Factory2.registerSeries(GaugeSeries.type, GaugeSeries), registerArcMark(), registerProgressLikeAnimation(), registerPolarLinearAxis();
};

// node_modules/@visactor/vchart/esm/mark/cell.js
var CellMark = class _CellMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _CellMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      padding: 0
    });
  }
};
CellMark.type = "cell";
var registerCellMark2 = () => {
  Factory2.registerMark(CellMark.type, CellMark), registerCellGraphic(), registerCellMark();
};

// node_modules/@visactor/vchart/esm/series/heatmap/animation.js
function heatmapPresetAnimation(preset) {
  return false === preset ? {} : {
    type: "fadeIn"
  };
}
var registerHeatmapAnimation = () => {
  Factory2.registerAnimation("heatmap", (params2, preset) => Object.assign(Object.assign({}, FadeInOutAnimation), {
    appear: heatmapPresetAnimation(preset)
  }));
};

// node_modules/@visactor/vchart/esm/series/heatmap/tooltip-helper.js
var HeatmapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  enableByType(activeType) {
    return "dimension" !== activeType;
  }
};

// node_modules/@visactor/vchart/esm/series/heatmap/constant.js
var heatmapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  cell: {
    name: "cell",
    type: "cell"
  },
  cellBackground: {
    name: "cellBackground",
    type: "cell"
  }
});

// node_modules/@visactor/vchart/esm/series/heatmap/heatmap-transformer.js
var HeatmapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "cell");
  }
};

// node_modules/@visactor/vchart/esm/series/heatmap/heatmap.js
var HeatmapSeries = class _HeatmapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.heatmap, this.transformerConstructor = HeatmapSeriesSpecTransformer;
  }
  getFieldValue() {
    return this._fieldValue;
  }
  setFieldValue(f) {
    this._fieldValue = array(f);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFieldValue(this._spec.valueField);
  }
  initMark() {
    var _a, _b, _c, _d;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._cellMark = this._createMark(_HeatmapSeries.mark.cell, {
      isSeriesMark: true,
      stateSort: null === (_a = this._spec.cell) || void 0 === _a ? void 0 : _a.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      setCustomizedShape: null === (_b = this._spec.cell) || void 0 === _b ? void 0 : _b.customShape,
      morph: shouldMarkDoMorph(this._spec, _HeatmapSeries.mark.cell.name),
      morphElementKey: this.getDimensionField()[0]
    })), this._backgroundMark = this._createMark(_HeatmapSeries.mark.cellBackground, {
      stateSort: null === (_c = this._spec.cellBackground) || void 0 === _c ? void 0 : _c.stateSort
    }, Object.assign(Object.assign({}, progressive), {
      setCustomizedShape: null === (_d = this._spec.cellBackground) || void 0 === _d ? void 0 : _d.customShape
    }));
  }
  initMarkStyle() {
    this.initCellMarkStyle(), this.initCellBackgroundMarkStyle();
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getMeasureField()[0]]
    });
  }
  initCellMarkStyle() {
    this.setMarkStyle(this._cellMark, {
      x: (datum) => this.dataToPositionX(datum),
      y: (datum) => this.dataToPositionY(datum),
      size: () => [this.getCellSize(this._xAxisHelper), this.getCellSize(this._yAxisHelper)],
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
  }
  initCellBackgroundMarkStyle() {
    var _a, _b, _c;
    const padding = normalizePadding(null !== (_c = null === (_b = null === (_a = this._spec.cellBackground) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : 0);
    this.setMarkStyle(this._backgroundMark, {
      x: (datum) => {
        const width = this.getCellSize(this._xAxisHelper);
        return this.dataToPositionX(datum) - width / 2 + padding[3];
      },
      y: (datum) => {
        const height = this.getCellSize(this._yAxisHelper);
        return this.dataToPositionY(datum) - height / 2 + padding[0];
      },
      width: () => this.getCellSize(this._xAxisHelper) - padding[1] - padding[3],
      height: () => this.getCellSize(this._yAxisHelper) - padding[0] - padding[2]
    }, "normal", AttributeLevel.Series);
  }
  getColorAttribute() {
    var _a;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: this.getFieldValue[0]
    };
  }
  initInteraction() {
    this._parseInteractionConfig(this._cellMark ? [this._cellMark] : []);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._cellMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("heatmap")) || void 0 === _c ? void 0 : _c(appearPreset), userAnimationConfig("cell", this._spec, this._markAttributeContext), animationParams));
  }
  getCellSize(axisHelper) {
    var _a, _b;
    return null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, 0)) && void 0 !== _b ? _b : 6;
  }
  initTooltip() {
    this._tooltipHelper = new HeatmapSeriesTooltipHelper(this), this._cellMark && this._tooltipHelper.activeTriggerSet.mark.add(this._cellMark);
  }
  getDefaultShapeType() {
    return "square";
  }
  getDimensionField() {
    return [].concat(this.fieldX, this.fieldY);
  }
  getMeasureField() {
    return this.getFieldValue();
  }
  getActiveMarks() {
    return [this._cellMark];
  }
};
HeatmapSeries.type = SeriesTypeEnum.heatmap, HeatmapSeries.mark = heatmapSeriesMark, HeatmapSeries.transformerConstructor = HeatmapSeriesSpecTransformer;
var registerHeatmapSeries = () => {
  registerTextMark(), registerCellMark2(), registerHeatmapAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(HeatmapSeries.type, HeatmapSeries);
};

// node_modules/@visactor/vchart/esm/series/correlation/constant.js
var correlationSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nodePoint: {
    name: "nodePoint",
    type: "symbol"
  },
  ripplePoint: {
    name: "ripplePoint",
    type: "ripple"
  },
  centerPoint: {
    name: "centerPoint",
    type: "symbol"
  },
  centerLabel: {
    name: "centerLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/constant/correlation.js
var CORRELATION_X = `${PREFIX}_CORRELATION_X`;
var CORRELATION_Y = `${PREFIX}_CORRELATION_Y`;
var CORRELATION_SIZE = `${PREFIX}_CORRELATION_SIZE`;

// node_modules/@visactor/vchart/esm/data/transforms/correlation.js
var correlation2 = (data, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  if (!data || !(null == options ? void 0 : options.view) || !isArray_default(data)) return data;
  const viewBox = options.view();
  if (viewBox.x1 - viewBox.x0 == 0 || viewBox.y1 - viewBox.y0 == 0 || viewBox.x1 - viewBox.x0 == -1 / 0 || viewBox.x1 - viewBox.x0 == 1 / 0 || viewBox.y1 - viewBox.y0 == -1 / 0 || viewBox.y1 - viewBox.y0 == 1 / 0) return data;
  const startAngle = degreeToRadian(null !== (_a = options.startAngle) && void 0 !== _a ? _a : -90), endAngle = degreeToRadian(null !== (_b = options.endAngle) && void 0 !== _b ? _b : 270), maxRadius = Math.max((viewBox.x1 - viewBox.x0) / 2, (viewBox.y1 - viewBox.y0) / 2), innerRadius = toPercent(null !== (_c = options.innerRadius) && void 0 !== _c ? _c : 0, maxRadius), outerRadius = toPercent(options.outerRadius, maxRadius), center2 = [isNumber_default(null === (_d = options.center) || void 0 === _d ? void 0 : _d[0]) ? options.center[0] : viewBox.x0 + toPercent(null !== (_f = null === (_e = options.center) || void 0 === _e ? void 0 : _e[0]) && void 0 !== _f ? _f : "50%", viewBox.x1 - viewBox.x0), isNumber_default(null === (_g = options.center) || void 0 === _g ? void 0 : _g[1]) ? options.center[1] : viewBox.y0 + toPercent(null !== (_j = null === (_h = options.center) || void 0 === _h ? void 0 : _h[1]) && void 0 !== _j ? _j : "50%", viewBox.y1 - viewBox.y0)], fieldAccessor = field(options.field), values = data.map(fieldAccessor), [min3, max3] = extent(values), radiusScale = min3 === max3 ? (val) => (innerRadius + outerRadius) / 2 : (val) => innerRadius + (outerRadius - innerRadius) * (val - min3) / (max3 - min3), sizeAccessor = isNil_default(options.radiusField) ? fieldAccessor : field(options.radiusField), defaultSize = null !== (_l = null === (_k = null == options ? void 0 : options.radiusRange) || void 0 === _k ? void 0 : _k[1]) && void 0 !== _l ? _l : 5;
  let sizeScale = (datum) => defaultSize;
  if (sizeAccessor) {
    const [minSize, maxSize] = sizeAccessor !== fieldAccessor ? extent(data.map(sizeAccessor)) : [min3, max3], minR = null !== (_o = null === (_m = options.radiusRange) || void 0 === _m ? void 0 : _m[0]) && void 0 !== _o ? _o : 5, maxR = null !== (_q = null === (_p = options.radiusRange) || void 0 === _p ? void 0 : _p[1]) && void 0 !== _q ? _q : 5;
    minSize !== maxSize && (sizeScale = (datum) => minR + (maxR - minR) * (sizeAccessor(datum) - minSize) / (maxSize - minSize));
  }
  const minAngle = Math.min(startAngle, endAngle), maxAngle = Math.max(startAngle, endAngle), angles = getPartialAngles(minAngle, maxAngle, data.length), res = [], searchAngle = (maxAngle - minAngle) / 60;
  return data.forEach((datum, index) => {
    const radius = radiusScale(values[index]), size = sizeScale(datum);
    let x, y, angle2 = angles[index];
    for (let i = 0; i < 60 && (x = center2[0] + radius * Math.cos(angle2), y = center2[1] + radius * Math.sin(angle2), hasOverlap2({
      x,
      y,
      size
    }, res) || x - size < viewBox.x0 || x + size > viewBox.x1 || y - size < viewBox.y0 || y + size > viewBox.y1); i++) i < 59 && (angle2 += searchAngle, angle2 > maxAngle ? angle2 = minAngle : angle2 < minAngle && (angle2 = maxAngle));
    res.push(Object.assign({
      [CORRELATION_X]: x,
      [CORRELATION_Y]: y,
      [CORRELATION_SIZE]: size
    }, datum));
  }), res;
};
var getPartialAngles = (minAngle, maxAngle, count) => {
  let offsetAngle = 0, stepCount = Math.max(Math.ceil(2 * (maxAngle - minAngle) / Math.PI), 2), stepAngle = (maxAngle - minAngle) / stepCount, stepIndex = 0, stepSign = 1, i = 0, j = 0;
  const res = [];
  let startAngle = minAngle;
  for (; i < count; ) j < stepCount && (res.push(startAngle + (j % 2 ? Math.floor(j / 2) + Math.floor(stepCount / 2) : j / 2) * stepAngle * stepSign), j++), i++, j === stepCount && (j = 0, stepIndex += 1, stepSign *= -1, 0 === offsetAngle ? offsetAngle = stepAngle / 2 : offsetAngle /= 2, startAngle = -1 === stepSign ? maxAngle - offsetAngle : minAngle + offsetAngle, stepIndex >= 2 && (stepAngle /= 2, stepCount *= 2));
  return res;
};
var hasOverlap2 = (item, arr) => !(!arr || !arr.length) && arr.some((entry) => Math.pow(item.x - entry.x, 2) + Math.pow(item.y - entry.y, 2) < Math.pow(item.size + entry.size, 2));

// node_modules/@visactor/vchart/esm/data/transforms/correlation-center.js
var correlationCenter = (data, options) => {
  if (!data || !isArray_default(data)) return [];
  const { keyword, categoryField } = options, nodeInfo = data[0].latestData[0];
  return {
    [categoryField]: keyword,
    [DEFAULT_DATA_INDEX]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_INDEX],
    [DEFAULT_DATA_SERIES_FIELD]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_SERIES_FIELD]
  };
};

// node_modules/@visactor/vchart/esm/mark/ripple.js
var RippleMark = class _RippleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RippleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      ripple: 0
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id = this.getProductId();
    this._product = view.glyph("ripplePoint", null != group ? group : view.rootMark).id(id), this._compiledProductId = id;
  }
};
RippleMark.type = "ripple";
var registerRippleMark = () => {
  Factory2.registerMark(RippleMark.type, RippleMark), registerRippleGlyph();
};

// node_modules/@visactor/vchart/esm/series/correlation/animation.js
var correlationPresetAnimation = (_params, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "scaleIn"
};
var registerCorrelationAnimation = () => {
  Factory2.registerAnimation("correlation", (params2, preset) => Object.assign({
    appear: correlationPresetAnimation(0, preset)
  }, ScaleInOutAnimation));
};

// node_modules/@visactor/vchart/esm/series/correlation/correlation-transformer.js
var CorrelationSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nodePoint"), this._addMarkLabelSpec(spec, "centerPoint", "centerLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/correlation/correlation.js
var CorrelationSeries = class _CorrelationSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.correlation, this.transformerConstructor = CorrelationSeriesSpecTransformer, this._viewBox = new Bounds();
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field5) {
    isValid_default(field5) && (this._seriesField = field5);
  }
  getSizeField() {
    return this._sizeField;
  }
  setSizeField(field5) {
    isValid_default(field5) && (this._sizeField = field5);
  }
  getSizeRange() {
    return this._sizeRange;
  }
  setSizeRange(range2) {
    isValid_default(range2) && (this._sizeRange = range2);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(this._spec.seriesField), this.setSizeField(this._spec.sizeField), this.setSizeRange(this._spec.sizeRange);
  }
  initData() {
    var _a, _b, _c;
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "correlation", correlation2);
    const centerDataSet = new DataSet();
    registerDataSetInstanceParser(centerDataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(centerDataSet, "correlationCenter", correlationCenter);
    const centerDataView = new DataView(centerDataSet, {
      name: `${this.type}_${this.id}_center`
    });
    centerDataView.parse([this.getViewData()], {
      type: "dataview"
    }), centerDataView.transform({
      type: "correlationCenter",
      options: {
        keyword: null !== (_c = null === (_b = null === (_a = this._spec.centerLabel) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "",
        categoryField: this._spec.categoryField
      }
    }), this._centerSeriesData = new SeriesData(this._option, centerDataView);
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._centerSeriesData) || void 0 === _a || _a.compile();
  }
  _statisticViewData() {
    super._statisticViewData(), this._data.getDataView().transform({
      type: "correlation",
      options: {
        view: () => ({
          x0: this._viewBox.x1,
          x1: this._viewBox.x2,
          y0: this._viewBox.y1,
          y1: this._viewBox.y2
        }),
        field: this._spec.valueField,
        radiusRange: this._spec.sizeRange,
        radiusField: this._spec.sizeField,
        center: [this._spec.centerX, this._spec.centerY],
        innerRadius: this._spec.innerRadius,
        outerRadius: this._spec.outerRadius,
        startAngle: this._spec.startAngle,
        endAngle: this._spec.endAngle
      }
    });
  }
  initMark() {
    var _a, _b, _c, _d;
    const nodePointMark = this._createMark(_CorrelationSeries.mark.nodePoint, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      key: DEFAULT_DATA_INDEX,
      stateSort: null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.stateSort
    }, {
      setCustomizedShape: null === (_b = this._spec.nodePoint) || void 0 === _b ? void 0 : _b.customShape
    });
    nodePointMark && (nodePointMark.setMarkConfig({
      zIndex: LayoutZIndex.Node
    }), this._nodePointMark = nodePointMark);
    const ripplePointMark = this._createMark(_CorrelationSeries.mark.ripplePoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId()
    });
    ripplePointMark && (this._ripplePointMark = ripplePointMark);
    const centerPointMark = this._createMark(_CorrelationSeries.mark.centerPoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId(),
      stateSort: null === (_c = this._spec.centerPoint) || void 0 === _c ? void 0 : _c.stateSort
    }, {
      setCustomizedShape: null === (_d = this._spec.centerPoint) || void 0 === _d ? void 0 : _d.customShape
    });
    centerPointMark && (centerPointMark.setMarkConfig({
      zIndex: LayoutZIndex.Node
    }), this._centerPointMark = centerPointMark);
  }
  initMarkStyle() {
    this._initNodePointMarkStyle(), this._initRipplePointMarkStyle(), this._initCenterPointMarkStyle();
  }
  _initNodePointMarkStyle() {
    var _a, _b, _c, _d;
    const nodePointMark = this._nodePointMark;
    if (!nodePointMark) return;
    const nodePointStyle = null !== (_b = null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(nodePointMark, {
      x: (datum) => datum[CORRELATION_X],
      y: (datum) => datum[CORRELATION_Y],
      size: (datum) => datum[CORRELATION_SIZE],
      fill: null !== (_c = nodePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_d = nodePointStyle.fillOpacity) && void 0 !== _d ? _d : 1,
      lineWidth: 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initRipplePointMarkStyle() {
    var _a, _b, _c, _d, _e;
    const ripplePointMark = this._ripplePointMark;
    if (!ripplePointMark) return;
    const ripplePointStyle = null !== (_b = null === (_a = this._spec.ripplePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(ripplePointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = ripplePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      opacity: null !== (_d = ripplePointStyle.fillOpacity) && void 0 !== _d ? _d : 0.2,
      ripple: null !== (_e = ripplePointStyle.ripple) && void 0 !== _e ? _e : 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initCenterPointMarkStyle() {
    var _a, _b, _c, _d, _e, _f;
    const centerPointMark = this._centerPointMark;
    centerPointMark && this.setMarkStyle(centerPointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => 0.2 * Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = null === (_b = null === (_a = this._spec.centerPoint) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_f = null === (_e = null === (_d = this._spec.centerPoint) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.fillOpacity) && void 0 !== _f ? _f : 1
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initTooltip() {
    super.initTooltip(), this._nodePointMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodePointMark);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this._categoryField],
      z: this.dataToPositionZ.bind(this)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this._nodePointMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("correlation")) || void 0 === _b ? void 0 : _b({}, appearPreset), userAnimationConfig("nodePoint", this._spec, this._markAttributeContext)));
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  getActiveMarks() {
    return [this._nodePointMark, this._centerPointMark];
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this._rawData.reRunAllTransform(), this.getViewData().reRunAllTransform();
  }
};
CorrelationSeries.type = SeriesTypeEnum.correlation, CorrelationSeries.mark = correlationSeriesMark, CorrelationSeries.transformerConstructor = CorrelationSeriesSpecTransformer;
var registerCorrelationSeries = () => {
  registerSymbolMark(), registerRippleMark(), Factory2.registerSeries(CorrelationSeries.type, CorrelationSeries), registerCorrelationAnimation();
};

// node_modules/@visactor/vchart/esm/series/liquid/animation.js
var Appear_Wave = {
  duration: 2e3,
  loop: true,
  channel: {
    wave: {
      from: 0,
      to: 1
    }
  }
};
var Appear_Grow7 = (params2) => ({
  duration: 2e3,
  channel: {
    wave: {
      from: 0,
      to: 1
    },
    height: params2.height,
    dy: params2.dy
  }
});
var Appear_WaveGrow = (params2) => ({
  duration: 2e3,
  channel: {
    wave: {
      from: 0,
      to: 1
    },
    height: params2.height,
    dy: params2.dy
  }
});
var Appear_Group_Grow = (params2) => ({
  duration: 2e3,
  channel: {
    dy: params2.dy
  }
});
var Appear_Group_WaveGrow = (params2) => ({
  duration: 2e3,
  channel: {
    dy: params2.dy
  }
});
function liquidPresetAnimation(params2, preset) {
  switch (preset) {
    case "wave":
    default:
      return Appear_Wave;
    case "grow":
      return Appear_Grow7(params2);
    case "waveGrow":
      return Appear_WaveGrow(params2);
  }
}
function liquidGroupPresetAnimation(params2, preset) {
  switch (preset) {
    case "wave":
    default:
      return Appear_Wave;
    case "grow":
      return Appear_Group_Grow(params2);
    case "waveGrow":
      return Appear_Group_WaveGrow(params2);
  }
}
var registerLiquidAnimation = () => {
  Factory2.registerAnimation("liquid", (params2, preset) => ({
    appear: liquidPresetAnimation(params2, preset),
    enter: liquidPresetAnimation(params2, preset),
    exit: liquidPresetAnimation(params2, preset)
  })), Factory2.registerAnimation("liquidGroup", (params2, preset) => ({
    appear: liquidGroupPresetAnimation(params2, preset),
    enter: liquidGroupPresetAnimation(params2, preset),
    exit: liquidGroupPresetAnimation(params2, preset)
  }));
};

// node_modules/@visactor/vchart/esm/series/liquid/constant.js
var LiquidSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  liquidGroup: {
    name: "liquidGroup",
    type: "group"
  },
  liquid: {
    name: "liquid",
    type: "liquid"
  },
  liquidBackground: {
    name: "liquidBackground",
    type: "group"
  },
  liquidOutline: {
    name: "liquidOutline",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/mark/liquid.js
var LiquidMark = class _LiquidMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _LiquidMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      wave: 0
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id = this.getProductId();
    this._product = view.glyph("wave", null != group ? group : view.rootMark).id(id), this._compiledProductId = id;
  }
};
LiquidMark.type = "liquid";
var registerLiquidMark = () => {
  Factory2.registerMark(LiquidMark.type, LiquidMark), registerWaveGlyph();
};

// node_modules/@visactor/vchart/esm/series/liquid/util.js
var getShapes = (shapesType, size) => "drop" === shapesType ? pin(0, 0, size) : shapesType;
function pin(x, y, radius) {
  const w = 4 * radius / 3, h = Math.max(w, 2 * radius), r = w / 2, cx = x, cy = r + y - h / 2, theta = Math.asin(r / (0.85 * (h - r))), dy = Math.sin(theta) * r, dx = Math.cos(theta) * r, x0 = cx - dx, y0 = cy + dy, cpX = x, cpY = cy + r / Math.sin(theta);
  return `
      M ${x0} ${y0}
      A ${r} ${r} 0 1 1 ${x0 + 2 * dx} ${y0}
      Q ${cpX} ${cpY} ${x} ${y + h / 2}
      Q ${cpX} ${cpY} ${x0} ${y0}
      Z 
    `;
}

// node_modules/@visactor/vchart/esm/series/liquid/tooltip-helper.js
var LiquidSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => this.series.getValueField(), this.markTooltipValueCallback = (datum) => datum[this.series.getValueField()], this.shapeStrokeCallback = (datum) => this.series.getMarkInName("liquid").getAttribute("fill", datum);
  }
};

// node_modules/@visactor/vchart/esm/series/liquid/liquid.js
var LiquidSeries = class _LiquidSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.liquid, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._liquidBackgroundMark = null, this._liquidOutlineMark = null, this._getLiquidPosY = () => {
      let liquidY = 0;
      const { height: liquidBackHeight, startY } = this._getLiquidBackPosAndSize();
      return liquidY = this._reverse ? liquidBackHeight * this._heightRatio : liquidBackHeight * (1 - this._heightRatio), liquidY + startY;
    }, this._getLiquidHeight = () => {
      const { height: liquidBackHeight } = this._getLiquidBackPosAndSize();
      return liquidBackHeight * this._heightRatio;
    }, this._getLiquidBackPosAndSize = (isOutline = false) => {
      var _a, _b;
      let { top: marginTop = 0, bottom: marginBottom = 0, left: marginLeft = 0, right: marginRight = 0 } = this._marginSpec, { top: paddingTop = 0, bottom: paddingBottom = 0, left: paddingLeft = 0, right: paddingRight = 0 } = isOutline ? {} : this._paddingSpec;
      "triangle" === this._maskShape && (marginBottom /= Math.sqrt(3), marginTop = marginTop / Math.sqrt(3) * 2, paddingBottom /= Math.sqrt(3), paddingTop = paddingTop / Math.sqrt(3) * 2);
      const { width: regionWidth, height: regionHeight } = null !== (_b = null === (_a = this._region) || void 0 === _a ? void 0 : _a.getLayoutRect()) && void 0 !== _b ? _b : {
        width: 0,
        height: 0
      }, x = regionWidth / 2 + (marginLeft + paddingLeft - (marginRight + paddingRight)) / 2, y = regionHeight / 2 + (marginTop + paddingTop - (marginBottom + paddingBottom)) / 2;
      let width = regionWidth - (marginLeft + marginRight + paddingLeft + paddingRight), height = regionHeight - (marginTop + marginBottom + paddingTop + paddingBottom);
      const size = Math.min(width, height);
      return "rect" !== this._maskShape && (width = size, height = size), {
        x,
        y,
        size,
        width,
        height,
        startX: x - width / 2,
        startY: y - height / 2,
        endX: x + width / 2,
        endY: y + height / 2
      };
    }, this._getLiquidBackPath = (isOutline = false) => {
      var _a;
      let symbolPath;
      if ("rect" === this._maskShape) {
        const { x, y, width, height } = this._getLiquidBackPosAndSize(isOutline);
        symbolPath = createRect({
          x: x - width / 2,
          y: y - height / 2,
          width,
          height,
          fill: true
        });
      } else {
        const { x, y, size } = this._getLiquidBackPosAndSize(isOutline);
        symbolPath = createSymbol({
          x,
          y,
          size,
          symbolType: getShapes(null !== (_a = this._spec.maskShape) && void 0 !== _a ? _a : "circle", size),
          fill: true
        });
      }
      return [symbolPath];
    };
  }
  setValueField(field5) {
    isValid_default(field5) && (this._valueField = field5);
  }
  getValueField() {
    return this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._marginSpec = normalizeLayoutPaddingSpec(this._spec.outlineMargin), this._paddingSpec = normalizeLayoutPaddingSpec(this._spec.outlinePadding), this.setValueField(this._spec.valueField), this._reverse = null !== (_a = this._spec.reverse) && void 0 !== _a && _a, this._maskShape = null !== (_b = this._spec.maskShape) && void 0 !== _b ? _b : "circle";
  }
  viewDataUpdate(d) {
    super.viewDataUpdate(d), this._heightRatio = max(...this._data.getLatestData().map((d2) => d2[this._valueField]));
  }
  initMark() {
    this._initLiquidOutlineMark(), this._initLiquidBackgroundMark(), this._initLiquidMark();
  }
  initMarkStyle() {
    this._initLiquidOutlineMarkStyle(), this._initLiquidBackgroundMarkStyle(), this._initLiquidMarkStyle();
  }
  _initLiquidOutlineMark() {
    return this._liquidOutlineMark = this._createMark(_LiquidSeries.mark.liquidOutline, {
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidOutlineMark;
  }
  _initLiquidBackgroundMark() {
    return this._liquidBackgroundMark = this._createMark(_LiquidSeries.mark.liquidBackground, {
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidBackgroundMark;
  }
  _initLiquidMark() {
    return this._liquidGroupMark = this._createMark(_LiquidSeries.mark.liquidGroup, {
      parent: this._liquidBackgroundMark,
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidMark = this._createMark(_LiquidSeries.mark.liquid, {
      parent: this._liquidGroupMark,
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidMark;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getLiquidBackPosAndSize = this._getLiquidBackPosAndSize, this._markAttributeContext.getLiquidPosY = this._getLiquidPosY, this._markAttributeContext.getLiquidHeight = this._getLiquidHeight;
  }
  _initLiquidOutlineMarkStyle() {
    const liquidOutlineMark = this._liquidOutlineMark;
    liquidOutlineMark.created(), this.setMarkStyle(liquidOutlineMark, {
      stroke: this.getColorAttribute(),
      width: () => this._region.getLayoutRect().width,
      height: () => this._region.getLayoutRect().height,
      path: () => this._getLiquidBackPath(true)
    }, "normal", AttributeLevel.Series), this._liquidOutlineMark.setMarkConfig({
      interactive: false,
      zIndex: this.layoutZIndex
    });
  }
  _initLiquidBackgroundMarkStyle() {
    const liquidBackgroundMark = this._liquidBackgroundMark;
    liquidBackgroundMark.created(), this.setMarkStyle(liquidBackgroundMark, {
      width: () => this._region.getLayoutRect().width,
      height: () => this._region.getLayoutRect().height,
      path: () => this._getLiquidBackPath()
    }, "normal", AttributeLevel.Series), this._liquidBackgroundMark.setMarkConfig({
      interactive: false,
      zIndex: this.layoutZIndex,
      clip: true
    });
  }
  _initLiquidMarkStyle() {
    const liquidMark = this._liquidMark, liquidGroupMark = this._liquidGroupMark;
    liquidGroupMark && this.setMarkStyle(liquidGroupMark, {
      x: () => this._region.getLayoutStartPoint().x + this._region.getLayoutRect().width / 2,
      angle: this._reverse ? -Math.PI : 0,
      y: 0,
      dy: this._getLiquidPosY
    }), liquidMark && this.setMarkStyle(liquidMark, {
      y: 0,
      dy: 0,
      height: this._getLiquidHeight,
      fill: this.getColorAttribute(),
      wave: 0
    }, "normal", AttributeLevel.Series);
  }
  initTooltip() {
    this._tooltipHelper = new LiquidSeriesTooltipHelper(this), this._liquidMark && this._tooltipHelper.activeTriggerSet.mark.add(this._liquidMark);
  }
  initInteraction() {
    this._parseInteractionConfig(this._liquidMark ? [this._liquidMark] : []);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      height: {
        from: 0,
        to: () => this._getLiquidHeight()
      },
      dy: {
        from: () => {
          let liquidY = 0;
          const { height: liquidBackHeight, startY } = this._getLiquidBackPosAndSize();
          return liquidY = this._reverse ? 0 : liquidBackHeight, liquidY + startY;
        }
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._liquidMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("liquid")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("liquid", this._spec, this._markAttributeContext))), this._liquidGroupMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("liquidGroup")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("liquidGroup", this._spec, this._markAttributeContext)));
  }
  initEvent() {
    super.initEvent(), this._spec.indicatorSmartInvert && this._option.getChart().getComponentsByKey("indicator") && this.event.on(ChartEvent.renderFinished, () => {
      this._option.getChart().getComponentsByKey("indicator").forEach((indicatorComponent) => {
        var _a, _b;
        const waveItem = this._liquidMark.getProduct().elements[0].glyphGraphicItems.wave1;
        let { y1: waveY1, y2: waveY2 } = waveItem.globalAABBBounds;
        waveY1 += this._region.getLayoutStartPoint().y, waveY2 += this._region.getLayoutStartPoint().y, null === (_b = null === (_a = null == indicatorComponent ? void 0 : indicatorComponent.getIndicatorComponent()) || void 0 === _a ? void 0 : _a.getChildren()[0]) || void 0 === _b || _b.getChildren().forEach((text2) => {
          const { y1: textY1, y2: textY2 } = text2.globalAABBBounds;
          if (waveY1 < textY1 && waveY2 > textY2) {
            const foregroundColor = text2.attribute.fill, backgroundColor = waveItem.attribute.fill, invertColor = labelSmartInvert(foregroundColor, backgroundColor);
            text2.setAttribute("fill", invertColor);
          }
        });
      });
    });
  }
  dataToPosition(data) {
    return null;
  }
  dataToPositionX(data) {
    return null;
  }
  dataToPositionY(data) {
    return null;
  }
  valueToPosition(value1, value2) {
    return null;
  }
  getStatisticFields() {
    return [];
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  getActiveMarks() {
    return [this._liquidMark];
  }
};
LiquidSeries.type = SeriesTypeEnum.liquid, LiquidSeries.mark = LiquidSeriesMark, LiquidSeries.transformerConstructor = LineLikeSeriesSpecTransformer;
var registerLiquidSeries = () => {
  registerLiquidMark(), registerGroupMark(), registerLiquidAnimation(), Factory2.registerSeries(LiquidSeries.type, LiquidSeries);
};

// node_modules/@visactor/vchart/esm/series/venn/util.js
var getVennSeriesDataKey = (sets) => array(sets).join(",");

// node_modules/@visactor/vchart/esm/series/venn/tooltip-helper.js
var VennTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum) => getVennSeriesDataKey(null == datum ? void 0 : datum[this.series.getDimensionField()[0]]), this.markTooltipKeyCallback = (datum) => getVennSeriesDataKey(null == datum ? void 0 : datum[this.series.getDimensionField()[0]]);
  }
};

// node_modules/@visactor/vchart/esm/series/venn/constant.js
var vennSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  circle: {
    name: "circle",
    type: "arc"
  },
  overlap: {
    name: "overlap",
    type: "path"
  },
  overlapLabel: {
    name: "overlapLabel",
    type: "text"
  }
});

// node_modules/@visactor/vgrammar-venn/es/utils/layout/common.js
function distanceFromIntersectArea(r1, r2, overlap2) {
  return Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap2 + SMALL ? Math.abs(r1 - r2) : findZeroOfFunction(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap2;
  }, 0, r1 + r2);
}
function getDistanceMatrices(areas, sets, setIds) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  return areas.filter(function(x) {
    return 2 === x.sets.length;
  }).map(function(current) {
    const left2 = setIds[current.sets[0]], right2 = setIds[current.sets[1]], distance2 = distanceFromIntersectArea(Math.sqrt(sets[left2].size / Math.PI), Math.sqrt(sets[right2].size / Math.PI), current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    let c3 = 0;
    current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size) ? c3 = 1 : current.size <= 1e-10 && (c3 = -1), constraints[left2][right2] = constraints[right2][left2] = c3;
  }), {
    distances,
    constraints
  };
}

// node_modules/@visactor/vgrammar-venn/es/utils/layout/constrained-mds-layout.js
function constrainedMDSLayout(areas, params2) {
  const restarts = (params2 = params2 || {}).restarts || 10, sets = [], setIds = {};
  let i;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    1 === area2.sets.length && (setIds[area2.sets[0]] = sets.length, sets.push(area2));
  }
  const matrices = getDistanceMatrices(areas, sets, setIds);
  let distances = matrices.distances;
  const constraints = matrices.constraints, norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map((row) => row.map((value) => value / norm));
  const obj = function(x, fxPrime) {
    return constrainedMDSGradient(x, fxPrime, distances, constraints);
  };
  let best, current;
  for (i = 0; i < restarts; ++i) {
    const initial = zeros(2 * distances.length).map((entry, i2) => seedRandom(i2));
    current = conjugateGradient(obj, initial, params2), (!best || current.fx < best.fx) && (best = current);
  }
  const positions = best.x, circles = {};
  for (i = 0; i < sets.length; ++i) {
    const set2 = sets[i];
    circles[set2.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set2.size / Math.PI)
    };
  }
  if (params2.history) for (i = 0; i < params2.history.length; ++i) scale(params2.history[i].x, norm);
  return circles;
}
function constrainedMDSGradient(x, fxPrime, distances, constraints) {
  let i, loss = 0;
  for (i = 0; i < fxPrime.length; ++i) fxPrime[i] = 0;
  for (i = 0; i < distances.length; ++i) {
    const xi = x[2 * i], yi = x[2 * i + 1];
    for (let j = i + 1; j < distances.length; ++j) {
      const xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j], squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance2 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      constraint > 0 && distance2 <= dij || constraint < 0 && distance2 >= dij || (loss += 2 * delta * delta, fxPrime[2 * i] += 4 * delta * (xi - xj), fxPrime[2 * i + 1] += 4 * delta * (yi - yj), fxPrime[2 * j] += 4 * delta * (xj - xi), fxPrime[2 * j + 1] += 4 * delta * (yj - yi));
    }
  }
  return loss;
}

// node_modules/@visactor/vgrammar-venn/es/utils/layout/loss.js
function lossFunction(sets, overlaps) {
  let output = 0;
  for (let i = 0; i < overlaps.length; ++i) {
    const area2 = overlaps[i];
    let overlap2;
    if (1 === area2.sets.length) continue;
    if (2 === area2.sets.length) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap2 = circleOverlap(left2.radius, right2.radius, PointService.distancePP(left2, right2));
    } else overlap2 = intersectionArea(area2.sets.map(function(i2) {
      return sets[i2];
    }));
    output += (area2.hasOwnProperty("weight") ? area2.weight : 1) * (overlap2 - area2.size) * (overlap2 - area2.size);
  }
  return output;
}

// node_modules/@visactor/vgrammar-venn/es/utils/layout/greedy-layout.js
function greedyLayout(areas, params2) {
  const loss = params2 && params2.lossFunction ? params2.lossFunction : lossFunction, circles = {}, setOverlaps = {};
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (1 === area2.sets.length) {
      const set2 = area2.sets[0];
      circles[set2] = {
        x: 1e10,
        y: 1e10,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI),
        setId: set2
      }, setOverlaps[set2] = [];
    }
  }
  areas = areas.filter(function(a3) {
    return 2 === a3.sets.length;
  });
  for (let i = 0; i < areas.length; ++i) {
    const current = areas[i];
    let weight = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    current.size + SMALL >= Math.min(circles[left2].size, circles[right2].size) && (weight = 0), setOverlaps[left2].push({
      set: right2,
      size: current.size,
      weight
    }), setOverlaps[right2].push({
      set: left2,
      size: current.size,
      weight
    });
  }
  const mostOverlapped = [];
  for (const set2 in setOverlaps) if (setOverlaps.hasOwnProperty(set2)) {
    let size = 0;
    for (let i = 0; i < setOverlaps[set2].length; ++i) size += setOverlaps[set2][i].size * setOverlaps[set2][i].weight;
    mostOverlapped.push({
      set: set2,
      size
    });
  }
  function sortOrder(a3, b) {
    return b.size - a3.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point6, index) {
    circles[index].x = point6.x, circles[index].y = point6.y, positioned[index] = true;
  }
  positionSet({
    x: 0,
    y: 0
  }, mostOverlapped[0].set);
  for (let i = 1; i < mostOverlapped.length; ++i) {
    const setIndex = mostOverlapped[i].set, overlap2 = setOverlaps[setIndex].filter(isPositioned), set2 = circles[setIndex];
    if (overlap2.sort(sortOrder), 0 === overlap2.length) throw "ERROR: missing pairwise overlap information";
    const points = [];
    for (let j = 0; j < overlap2.length; ++j) {
      const p1 = circles[overlap2[j].set], d1 = distanceFromIntersectArea(set2.radius, p1.radius, overlap2[j].size);
      points.push({
        x: p1.x + d1,
        y: p1.y
      }), points.push({
        x: p1.x - d1,
        y: p1.y
      }), points.push({
        y: p1.y + d1,
        x: p1.x
      }), points.push({
        y: p1.y - d1,
        x: p1.x
      });
      for (let k2 = j + 1; k2 < overlap2.length; ++k2) {
        const p2 = circles[overlap2[k2].set], d2 = distanceFromIntersectArea(set2.radius, p2.radius, overlap2[k2].size), extraPoints = circleCircleIntersection({
          x: p1.x,
          y: p1.y,
          radius: d1
        }, {
          x: p2.x,
          y: p2.y,
          radius: d2
        });
        for (let l = 0; l < extraPoints.length; ++l) points.push(extraPoints[l]);
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x, circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      localLoss < bestLoss && (bestLoss = localLoss, bestPoint = points[j]);
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}

// node_modules/@visactor/vgrammar-venn/es/utils/layout/layout.js
function venn2(areas, parameters) {
  (parameters = parameters || {}).maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout, loss = parameters.lossFunction || lossFunction, circles = initialLayout(areas = addMissingAreas(areas), parameters), initial = [], setIds = [];
  for (const setId in circles) circles.hasOwnProperty(setId) && (initial.push(circles[setId].x), initial.push(circles[setId].y), setIds.push(setId));
  const positions = nelderMead(function(values) {
    const current = {};
    for (let i = 0; i < setIds.length; ++i) {
      const setId = setIds[i];
      current[setId] = {
        x: values[2 * i],
        y: values[2 * i + 1],
        radius: circles[setId].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters).x;
  for (let i = 0; i < setIds.length; ++i) {
    const setId = setIds[i];
    circles[setId].x = positions[2 * i], circles[setId].y = positions[2 * i + 1];
  }
  return circles;
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs = {};
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (1 === area2.sets.length) ids.push(area2.sets[0]);
    else if (2 === area2.sets.length) {
      const a3 = area2.sets[0], b = area2.sets[1];
      pairs[[a3, b].toString()] = true, pairs[[b, a3].toString()] = true;
    }
  }
  ids.sort(function(a3, b) {
    return +(a3 > b);
  });
  for (let i = 0; i < ids.length; ++i) {
    const a3 = ids[i];
    for (let j = i + 1; j < ids.length; ++j) {
      const b = ids[j];
      [a3, b].toString() in pairs || areas.push({
        sets: [a3, b],
        size: 0
      });
    }
  }
  return areas;
}
function bestInitialLayout(areas, params2) {
  let initial = greedyLayout(areas, params2);
  const loss = params2.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params2);
    loss(constrained, areas) + 1e-8 < loss(initial, areas) && (initial = constrained);
  }
  return initial;
}

// node_modules/@visactor/vgrammar-venn/es/utils/solution/common.js
function orientateCircles(circles, orientation, orientationOrder) {
  let i;
  if (null === orientationOrder ? circles.sort(function(a3, b) {
    return b.radius - a3.radius;
  }) : circles.sort(orientationOrder), circles.length > 0) {
    const largestX = circles[0].x, largestY = circles[0].y;
    for (i = 0; i < circles.length; ++i) circles[i].x -= largestX, circles[i].y -= largestY;
  }
  if (2 === circles.length) {
    PointService.distancePP(circles[0], circles[1]) < Math.abs(circles[1].radius - circles[0].radius) && (circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10, circles[1].y = circles[0].y);
  }
  if (circles.length > 1) {
    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation, c3 = Math.cos(rotation), s2 = Math.sin(rotation);
    let x, y;
    for (i = 0; i < circles.length; ++i) x = circles[i].x, y = circles[i].y, circles[i].x = c3 * x - s2 * y, circles[i].y = s2 * x + c3 * y;
  }
  if (circles.length > 2) {
    let angle2 = Math.atan2(circles[2].x, circles[2].y) - orientation;
    for (; angle2 < 0; ) angle2 += 2 * Math.PI;
    for (; angle2 > 2 * Math.PI; ) angle2 -= 2 * Math.PI;
    if (angle2 > Math.PI) {
      const slope = circles[1].y / (1e-10 + circles[1].x);
      for (i = 0; i < circles.length; ++i) {
        const d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
        circles[i].x = 2 * d - circles[i].x, circles[i].y = 2 * d * slope - circles[i].y;
      }
    }
  }
}
function disjointCluster(circles) {
  function find(circle3) {
    return circle3.parent !== circle3 && (circle3.parent = find(circle3.parent)), circle3.parent;
  }
  function union(x, y) {
    const xRoot = find(x), yRoot = find(y);
    xRoot.parent = yRoot;
  }
  circles.map(function(circle3) {
    circle3.parent = circle3;
  });
  for (let i = 0; i < circles.length; ++i) for (let j = i + 1; j < circles.length; ++j) {
    const maxDistance = circles[i].radius + circles[j].radius;
    PointService.distancePP(circles[i], circles[j]) + 1e-10 < maxDistance && union(circles[j], circles[i]);
  }
  const disjointClusters = {};
  let setId;
  for (let i = 0; i < circles.length; ++i) setId = find(circles[i]).parent.setId, setId in disjointClusters || (disjointClusters[setId] = []), disjointClusters[setId].push(circles[i]);
  circles.map(function(circle3) {
    delete circle3.parent;
  });
  const ret = [];
  for (setId in disjointClusters) disjointClusters.hasOwnProperty(setId) && ret.push(disjointClusters[setId]);
  return ret;
}
function getBoundingBox(circles) {
  const minMax = function(d) {
    return {
      max: Math.max.apply(null, circles.map(function(c3) {
        return c3[d] + c3.radius;
      })),
      min: Math.min.apply(null, circles.map(function(c3) {
        return c3[d] - c3.radius;
      }))
    };
  };
  return {
    xRange: minMax("x"),
    yRange: minMax("y")
  };
}

// node_modules/@visactor/vgrammar-venn/es/utils/solution/normalize-solution.js
function normalizeSolution(solution, orientation, orientationOrder) {
  null === orientation && (orientation = Math.PI / 2);
  let circles = [];
  for (const setId in solution) if (solution.hasOwnProperty(setId)) {
    const previous = solution[setId];
    circles.push({
      x: previous.x,
      y: previous.y,
      radius: previous.radius,
      setId
    });
  }
  const clusters = disjointCluster(circles);
  for (let i = 0; i < clusters.length; ++i) {
    orientateCircles(clusters[i], orientation, orientationOrder);
    const bounds = getBoundingBox(clusters[i]);
    clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min), clusters[i].bounds = bounds;
  }
  clusters.sort(function(a3, b) {
    return b.size - a3.size;
  }), circles = clusters[0];
  let returnBounds = circles.bounds;
  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;
  function addCluster(cluster, right2, bottom) {
    if (!cluster) return;
    const bounds = cluster.bounds;
    let xOffset, yOffset, centering;
    right2 ? xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing : (xOffset = returnBounds.xRange.max - bounds.xRange.max, centering = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2, centering < 0 && (xOffset += centering)), bottom ? yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing : (yOffset = returnBounds.yRange.max - bounds.yRange.max, centering = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2, centering < 0 && (yOffset += centering));
    for (let j = 0; j < cluster.length; ++j) cluster[j].x += xOffset, cluster[j].y += yOffset, circles.push(cluster[j]);
  }
  let index = 1;
  for (; index < clusters.length; ) addCluster(clusters[index], true, false), addCluster(clusters[index + 1], false, true), addCluster(clusters[index + 2], true, true), index += 3, returnBounds = getBoundingBox(circles);
  const ret = {};
  for (let i = 0; i < circles.length; ++i) ret[circles[i].setId] = circles[i];
  return ret;
}

// node_modules/@visactor/vgrammar-venn/es/utils/solution/scale-solution.js
function scaleSolution(solution, width, height, x0, y0) {
  width = Math.max(width, 1), height = Math.max(height, 1);
  const circles = [], setIds = [];
  for (const setId in solution) solution.hasOwnProperty(setId) && (setIds.push(setId), circles.push(solution[setId]));
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max === xRange.min || yRange.max === yRange.min) return console.log("not scaling solution: zero size detected"), solution;
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2, scaled = {};
  for (let i = 0; i < circles.length; ++i) {
    const circle3 = circles[i];
    scaled[setIds[i]] = {
      radius: scaling * circle3.radius,
      x: x0 + xOffset + (circle3.x - xRange.min) * scaling,
      y: y0 + yOffset + (circle3.y - yRange.min) * scaling,
      setId: circle3.setId
    };
  }
  return scaled;
}

// node_modules/@visactor/vgrammar-venn/es/utils/label.js
function computeTextCenters(circles, areas) {
  const ret = {}, overlapped = getOverlappingCircles(circles);
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i].sets, areaIds = {}, exclude = {};
    for (let j = 0; j < area2.length; ++j) {
      areaIds[area2[j]] = true;
      const overlaps = overlapped[area2[j]];
      for (let k2 = 0; k2 < overlaps.length; ++k2) exclude[overlaps[k2]] = true;
    }
    const interior = [], exterior = [];
    for (const setId in circles) setId in areaIds ? interior.push(circles[setId]) : setId in exclude || exterior.push(circles[setId]);
    const center2 = computeTextCenter(interior, exterior);
    if (ret[area2.toString()] = center2, center2.disjoint && areas[i].size > 0) {
      Logger.getInstance().error("Area " + area2 + " not represented on screen");
    }
  }
  return ret;
}
function getOverlappingCircles(circles) {
  const ret = {}, circleIds = [];
  for (const circleId in circles) circleIds.push(circleId), ret[circleId] = [];
  for (let i = 0; i < circleIds.length; i++) {
    const a3 = circles[circleIds[i]];
    for (let j = i + 1; j < circleIds.length; ++j) {
      const b = circles[circleIds[j]], d = PointService.distancePP(a3, b);
      d + b.radius <= a3.radius + 1e-10 ? ret[circleIds[j]].push(circleIds[i]) : d + a3.radius <= b.radius + 1e-10 && ret[circleIds[i]].push(circleIds[j]);
    }
  }
  return ret;
}
function computeTextCenter(interior, exterior) {
  const points = [];
  for (let i = 0; i < interior.length; ++i) {
    const c3 = interior[i];
    points.push({
      x: c3.x,
      y: c3.y
    }), points.push({
      x: c3.x + c3.radius / 2,
      y: c3.y
    }), points.push({
      x: c3.x - c3.radius / 2,
      y: c3.y
    }), points.push({
      x: c3.x,
      y: c3.y + c3.radius / 2
    }), points.push({
      x: c3.x,
      y: c3.y - c3.radius / 2
    });
  }
  let initial = points[0], margin = circleMargin(points[0], interior, exterior);
  for (let i = 1; i < points.length; ++i) {
    const m4 = circleMargin(points[i], interior, exterior);
    m4 >= margin && (initial = points[i], margin = m4);
  }
  const solution = nelderMead(function(p) {
    return -1 * circleMargin({
      x: p[0],
      y: p[1]
    }, interior, exterior);
  }, [initial.x, initial.y], {
    maxIterations: 500,
    minErrorDelta: 1e-10
  }).x;
  let ret = {
    x: solution[0],
    y: solution[1]
  }, valid = true;
  for (let i = 0; i < interior.length; ++i) if (PointService.distancePP(ret, interior[i]) > interior[i].radius) {
    valid = false;
    break;
  }
  for (let i = 0; i < exterior.length; ++i) if (PointService.distancePP(ret, exterior[i]) < exterior[i].radius) {
    valid = false;
    break;
  }
  if (!valid) if (1 === interior.length) ret = {
    x: interior[0].x,
    y: interior[0].y
  };
  else {
    const areaStats = {};
    intersectionArea(interior, areaStats), ret = 0 === areaStats.arcs.length ? {
      x: 0,
      y: -1e3,
      disjoint: true
    } : 1 === areaStats.arcs.length ? {
      x: areaStats.arcs[0].circle.x,
      y: areaStats.arcs[0].circle.y
    } : exterior.length ? computeTextCenter(interior, []) : getCenter(areaStats.arcs.map(function(a3) {
      return a3.p1;
    }));
  }
  return ret;
}
function circleMargin(current, interior, exterior) {
  let i, m4, margin = interior[0].radius - PointService.distancePP(interior[0], current);
  for (i = 1; i < interior.length; ++i) m4 = interior[i].radius - PointService.distancePP(interior[i], current), m4 <= margin && (margin = m4);
  for (i = 0; i < exterior.length; ++i) m4 = PointService.distancePP(exterior[i], current) - exterior[i].radius, m4 <= margin && (margin = m4);
  return margin;
}

// node_modules/@visactor/vgrammar-venn/es/utils/path.js
var getArcsFromCircles = (circles) => {
  const areaStats = {}, circleList = Object.values(circles);
  if (!circleList.length) return [];
  intersectionArea(circleList, areaStats);
  const arcs = areaStats.arcs.map(({ p1, p2, circle: circle3, width }) => ({
    p1,
    p2,
    radius: circle3.radius,
    setId: circle3.setId,
    largeArcFlag: width > circle3.radius
  })), result2 = [];
  let i = 0, arc = arcs[0];
  for (; i < arcs.length && arc; ) {
    const { p2 } = arc;
    result2.push(arc), arc = arcs.find((a3) => PointService.distancePP(a3.p1, p2) < SMALL), i++;
  }
  return result2;
};
var getPathFromArcs = (arcs) => {
  if (!(null == arcs ? void 0 : arcs.length)) return "";
  let i = 0, arc = arcs[0];
  const { p1 } = arc;
  let path = `M${p1.x},${p1.y}`;
  for (; arc; ) {
    const { p2, radius, largeArcFlag } = arc;
    path += `A${radius},${radius} 0 ${largeArcFlag ? 1 : 0},0 ${p2.x},${p2.y}`, arc = arcs[++i];
  }
  return path += " Z", path;
};
var getCirclesFromArcs = (arcs) => {
  var _a;
  return null !== (_a = null == arcs ? void 0 : arcs.map((arc) => {
    const { p1, p2, radius, largeArcFlag, setId } = arc, { x: x1, y: y1 } = p1, { x: x2, y: y2 } = p2, d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5, mX = (x1 + x2) / 2, mY = (y1 + y2) / 2, h = (radius ** 2 - (d / 2) ** 2) ** 0.5;
    let x = mX + h * (y2 - y1) / d, y = mY - h * (x2 - x1) / d;
    return (crossProduct([x2 - x1, y2 - y1], [x - x1, y - y1]) > 0 || largeArcFlag) && (x = mX - h * (y2 - y1) / d, y = mY + h * (x2 - x1) / d), {
      x,
      y,
      radius,
      setId
    };
  })) && void 0 !== _a ? _a : [];
};

// node_modules/@visactor/vgrammar-venn/es/venn.js
var transform29 = (options, upstreamData) => {
  const { x0, x1, y0, y1, setField = "sets", valueField = "size", orientation = Math.PI / 2, orientationOrder = null } = options;
  let circles = {}, textCenters = {};
  if (upstreamData.length > 0) {
    const vennData = upstreamData.map((area2) => ({
      sets: array(area2[setField]),
      size: area2[valueField]
    }));
    let solution = venn2(vennData, options);
    solution = normalizeSolution(solution, orientation, orientationOrder), circles = scaleSolution(solution, x1 - x0, y1 - y0, x0, y0), textCenters = computeTextCenters(circles, vennData);
  }
  return upstreamData.map((area2) => {
    const sets = array(area2[setField]), key = sets.toString(), textCenter = textCenters[key], basicDatum = Object.assign(Object.assign({}, area2), {
      datum: area2,
      sets,
      key,
      size: area2[valueField],
      labelX: null == textCenter ? void 0 : textCenter.x,
      labelY: null == textCenter ? void 0 : textCenter.y
    }), circle3 = circles[key];
    if (circle3) return Object.assign(Object.assign({}, basicDatum), {
      type: "circle",
      x: circle3.x,
      y: circle3.y,
      radius: circle3.radius
    });
    const arcs = getArcsFromCircles(sets.map((name) => circles[name]));
    return Object.assign(Object.assign({}, basicDatum), {
      type: "overlap",
      x: 0,
      y: 0,
      path: getPathFromArcs(arcs),
      arcs
    });
  });
};
var transformMark = (options, upstreamData) => upstreamData.filter((datum) => datum.type === options.datumType);

// node_modules/@visactor/vgrammar-venn/es/animation.js
var VennOverlapAnimation = class extends ACustomAnimate {
  onBind() {
    this.fromCircles = {}, getCirclesFromArcs(this.from.arcs).forEach((c3) => {
      this.fromCircles[c3.setId] = c3;
    }), this.toCircles = {}, getCirclesFromArcs(this.to.arcs).forEach((c3) => {
      this.toCircles[c3.setId] = c3;
    });
  }
  onUpdate(end, ratio, out) {
    const circles = [];
    Object.keys(this.fromCircles).forEach((key) => {
      const fromC = this.fromCircles[key], toC = this.toCircles[key];
      fromC && toC && circles.push({
        radius: fromC.radius + (toC.radius - fromC.radius) * ratio,
        x: fromC.x + (toC.x - fromC.x) * ratio,
        y: fromC.y + (toC.y - fromC.y) * ratio,
        setId: key
      });
    });
    const arcs = getArcsFromCircles(circles);
    out.arcs = arcs, out.path = getPathFromArcs(arcs);
  }
};

// node_modules/@visactor/vgrammar-venn/es/index.js
var registerVennTransforms = () => {
  Factory3.registerTransform("venn", {
    transform: transform29,
    markPhase: "beforeJoin"
  }, true), Factory3.registerTransform("vennMark", {
    transform: transformMark,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/series/venn/animation.js
var vennCirclePresetAnimation = (preset) => {
  switch (preset) {
    case "fadeIn":
    default:
      return {
        type: "fadeIn"
      };
    case "growIn":
      return {
        type: "growRadiusIn"
      };
    case "scaleIn":
      return {
        type: "scaleIn"
      };
  }
};
var vennOverlapPresetAnimation = (preset) => {
  switch (preset) {
    case "fadeIn":
    default:
      return {
        type: "fadeIn"
      };
    case "scaleIn":
      return {
        type: "scaleIn"
      };
  }
};
var registerVennAnimation = () => {
  Factory2.registerAnimation("vennCircle", (params2, preset) => ({
    appear: vennCirclePresetAnimation(preset),
    enter: {
      type: "growRadiusIn"
    },
    exit: {
      type: "growRadiusOut"
    },
    disappear: {
      type: "growRadiusOut"
    }
  })), Factory2.registerAnimation("vennOverlap", (params2, preset) => ({
    appear: vennOverlapPresetAnimation(preset),
    update: {
      custom: VennOverlapAnimation
    },
    enter: {
      type: "fadeIn"
    },
    exit: {
      type: "fadeOut"
    },
    disappear: {
      type: "fadeOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/venn/venn-transform.js
var VennSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "circle"), this._addMarkLabelSpec(spec, "overlap", "overlapLabel", "initOverlapLabelMarkStyle");
  }
};

// node_modules/@visactor/vchart/esm/series/venn/venn.js
var VennSeries = class _VennSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.venn, this.transformerConstructor = VennSeriesSpecTransformer, this._viewBox = new Bounds();
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.setCategoryField(null !== (_a = this._spec.categoryField) && void 0 !== _a ? _a : "sets"), this.setValueField(null !== (_b = this._spec.valueField) && void 0 !== _b ? _b : "size"), this.setSeriesField(null !== (_c = this._spec.seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_KEY);
  }
  compile() {
    super.compile(), this._runVennTransform();
  }
  _runVennTransform(render = false) {
    const viewDataProduct = this._data.getProduct();
    viewDataProduct && viewDataProduct.transform([{
      type: "venn",
      x0: this._viewBox.x1,
      x1: this._viewBox.x2,
      y0: this._viewBox.y1,
      y1: this._viewBox.y2,
      setField: this._categoryField,
      valueField: this._valueField
    }]), render && this.getCompiler().renderNextTick();
  }
  initMark() {
    const circleMark = this._createMark(_VennSeries.mark.circle, {
      isSeriesMark: true
    });
    circleMark && (circleMark.setTransform([{
      type: "vennMark",
      datumType: "circle"
    }]), this._circleMark = circleMark);
    const overlapMark = this._createMark(_VennSeries.mark.overlap, {
      isSeriesMark: true
    });
    overlapMark && (overlapMark.setTransform([{
      type: "vennMark",
      datumType: "overlap"
    }]), this._overlapMark = overlapMark);
  }
  initMarkStyle() {
    this._initCircleMarkStyle(), this._initOverlapMarkStyle();
  }
  _initCircleMarkStyle() {
    this._circleMark && this.setMarkStyle(this._circleMark, {
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      innerRadius: 0,
      outerRadius: (datum) => datum.radius,
      startAngle: 0,
      endAngle: 2 * Math.PI,
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initOverlapMarkStyle() {
    this._overlapMark && (this.setMarkStyle(this._overlapMark, {
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      path: (datum) => datum.path,
      arcs: (datum) => datum.arcs,
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute(),
      zIndex: (datum) => 100 * datum.sets.length
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this.setMarkStyle(this._overlapMark, {
      zIndex: (datum) => 100 * datum.sets.length + 1
    }, STATE_VALUE_ENUM.STATE_HOVER, AttributeLevel.Series));
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("venn"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelX,
      y: (datum) => datum.labelY,
      text: (datum) => getVennSeriesDataKey(datum.sets),
      maxLineWidth: (datum) => {
        const { x, radius, labelX } = datum, circleX0 = x - radius, circleX1 = x + radius;
        return Math.min(labelX - circleX0, circleX1 - labelX);
      }
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initOverlapLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("venn"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelX,
      y: (datum) => datum.labelY,
      text: (datum) => getVennSeriesDataKey(datum.sets)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initTooltip() {
    this._tooltipHelper = new VennTooltipHelper(this), this._circleMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circleMark), this._overlapMark && this._tooltipHelper.activeTriggerSet.mark.add(this._overlapMark);
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height), this._runVennTransform();
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._circleMark, this._overlapMark];
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._categoryField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  getGroupFields() {
    return null;
  }
  dataToPosition(data, checkInViewData) {
    return {
      x: data.x,
      y: data.y
    };
  }
  dataToPositionX(data) {
    return data.x;
  }
  dataToPositionY(data) {
    return data.y;
  }
  valueToPosition(value1, value2) {
    throw new Error("Method not implemented.");
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return null;
  }
  _getSeriesInfo(field5, keys) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys.map((originalKey) => ({
      key: getVennSeriesDataKey(originalKey),
      originalKey,
      style: this.getSeriesStyle({
        [field5]: originalKey
      }),
      shapeType: defaultShapeType
    }));
  }
  getSeriesFieldValue(datum, seriesField) {
    const value = super.getSeriesFieldValue(datum, seriesField);
    return getVennSeriesDataKey(value);
  }
  legendSelectedFilter(component2, selectedKeys) {
    if (component2.type === ComponentTypeEnum.discreteLegend) {
      const originalLegendKeys = component2.getLegendDefaultData(true);
      if (0 === selectedKeys.length && originalLegendKeys.length) return [];
      if (selectedKeys.length === originalLegendKeys.length) return selectedKeys;
      const selectedFilter = {};
      selectedKeys.forEach((s2) => {
        selectedFilter[s2] = true;
      });
      const disableKeys = originalLegendKeys.filter((key) => !selectedFilter[getVennSeriesDataKey(key)]), derivedDisableKeys = originalLegendKeys.filter((key) => !disableKeys.includes(key) && disableKeys.some((disableKey) => array(disableKey).every((k2) => key.includes(k2))));
      selectedKeys = selectedKeys.slice(), derivedDisableKeys.forEach((key) => {
        selectedKeys.splice(selectedKeys.indexOf(getVennSeriesDataKey(key)), 1);
      });
    }
    return selectedKeys;
  }
  initAnimation() {
    this.getMarksInType("arc").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("vennCircle")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("path").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("vennOverlap")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
};
VennSeries.type = SeriesTypeEnum.venn, VennSeries.mark = vennSeriesMark, VennSeries.transformerConstructor = VennSeriesSpecTransformer;
var registerVennSeries = () => {
  registerArcMark(), registerPathMark(), registerVennAnimation(), registerFadeInOutAnimation(), registerVennTransforms(), Factory2.registerSeries(VennSeries.type, VennSeries);
};

// node_modules/@visactor/vchart/esm/series/mosaic/mosaic.js
var MosaicSeries = class extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.mosaic, this.transformerConstructor = BarSeriesSpecTransformer;
  }
  getStack() {
    return true;
  }
  getPercent() {
    return !!this.getSeriesField();
  }
  getGroupFields() {
    return "vertical" === this.direction ? this._specXField : this._specYField;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec();
    const isPercent2 = this.getPercent();
    "horizontal" === this.direction ? (isPercent2 && (this.setFieldX(MOSAIC_VALUE_END_PERCENT), this.setFieldX2(MOSAIC_VALUE_START_PERCENT)), this.setFieldY(MOSAIC_CAT_END_PERCENT), this.setFieldY2(MOSAIC_CAT_START_PERCENT)) : (isPercent2 && (this.setFieldY(MOSAIC_VALUE_END_PERCENT), this.setFieldY2(MOSAIC_VALUE_START_PERCENT)), this.setFieldX(MOSAIC_CAT_END_PERCENT), this.setFieldX2(MOSAIC_CAT_START_PERCENT));
  }
  parseLabelStyle(labelStyle, labelSpec) {
    if ((null == labelSpec ? void 0 : labelSpec.filterByGroup) && isNil_default(labelStyle.dataFilter)) {
      const allGroupFields = this.getGroupFields(), { field: field5, type: filterType = "max", filter: filter2 } = labelSpec.filterByGroup;
      delete labelStyle.filterField;
      const fieldIndex = allGroupFields.indexOf(field5);
      if (fieldIndex < 0) return;
      const valueField = !!(fieldIndex % 2) ? "min" === filterType ? "horizontal" === this.direction ? this._fieldY2 : this._fieldX2 : "horizontal" === this.direction ? this._fieldY : this._fieldX : "min" === filterType ? "horizontal" === this.direction ? this._fieldX2 : this._fieldY2 : "horizontal" === this.direction ? this._fieldX : this._fieldY, filterFunc = "min" === filterType ? (a3, b) => {
        var _a, _b;
        return (null === (_a = a3.data) || void 0 === _a ? void 0 : _a[valueField]) < (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
      } : (a3, b) => {
        var _a, _b;
        return (null === (_a = a3.data) || void 0 === _a ? void 0 : _a[valueField]) > (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
      };
      labelStyle.dataFilter = (data) => {
        const filteredData = {};
        return data.forEach((d) => {
          const datum = d.data, fieldValue = null == datum ? void 0 : datum[field5];
          isNil_default(fieldValue) || filter2 && !filter2(d) || filteredData[fieldValue] && !filterFunc(d, filteredData[fieldValue]) || (filteredData[fieldValue] = d);
        }), data.filter((d) => {
          var _a;
          const fieldValue = null === (_a = d.data) || void 0 === _a ? void 0 : _a[field5];
          return filteredData[fieldValue] && filteredData[fieldValue] === d;
        });
      };
    }
    return labelStyle;
  }
};
MosaicSeries.type = SeriesTypeEnum.mosaic, MosaicSeries.transformerConstructor = BarSeriesSpecTransformer;
var registerMosaicSeries = () => {
  registerRectMark(), registerTextMark(), registerFadeInOutAnimation(), registerCartesianLinearAxis(), Factory2.registerSeries(MosaicSeries.type, MosaicSeries);
};

// node_modules/@visactor/vchart/esm/series/pictogram/constant.js
var PictogramSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pictogram: {
    name: "pictogram",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/series/pictogram/pictogram-transformer.js
var PictogramSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _getDefaultSpecFromChart(chartSpec) {
    var _a, _b, _c;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, svg = chartSpec.svg, elements = null === (_c = null === (_b = svgSourceMap.get(svg)) || void 0 === _b ? void 0 : _b.latestData) || void 0 === _c ? void 0 : _c.elements;
    if (elements && elements.length) {
      elements.map((e) => e.name).filter((n) => isValid_default(n)).forEach((name) => {
        chartSpec[name] && (spec[name] = chartSpec[name]);
      });
    }
    return spec;
  }
};

// node_modules/@visactor/vchart/esm/series/pictogram/tooltip-helper.js
var PictogramSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum) => {
      var _a;
      const series2 = this.series;
      return null !== (_a = this._getDimensionData(datum)) && void 0 !== _a ? _a : series2.getDatumName(datum);
    }, this.markTooltipValueCallback = (datum, params2) => {
      const { measureFields } = this._seriesCacheInfo;
      if (measureFields[0] && datum.data) return datum.data[measureFields[0]];
    }, this.markTooltipKeyCallback = (datum) => {
      var _a;
      return null === (_a = datum.data) || void 0 === _a ? void 0 : _a[this.series.getDimensionField()[0]];
    };
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/pictogram.js
function isValidStrokeOrFill(attr) {
  var _a;
  return isValid_default(attr) && "none" !== attr && !(null === (_a = attr.includes) || void 0 === _a ? void 0 : _a.call(attr, "url"));
}
var getLineWidth = (attributes) => {
  const strokeWidth = parseFloat(attributes.strokeWidth);
  if (!isNaN(strokeWidth)) return strokeWidth;
  const stroke2 = attributes.stroke;
  return stroke2 && isValidStrokeOrFill(stroke2) ? 1 : 0;
};
var getFill = (attributes, defaultFill) => {
  var _a;
  const fill = null !== (_a = attributes.fill) && void 0 !== _a ? _a : defaultFill;
  return fill && isValidStrokeOrFill(fill) ? fill : void 0;
};
var getStroke = (attributes, defaultStroke) => {
  var _a;
  const stroke2 = null !== (_a = attributes.stroke) && void 0 !== _a ? _a : defaultStroke;
  return !(!stroke2 || !isValidStrokeOrFill(stroke2)) && stroke2;
};
var commonAttributes2 = (attributes) => Object.assign(Object.assign({}, attributes), {
  x: parseFloat(attributes.x) || void 0,
  y: parseFloat(attributes.y) || void 0,
  fillStrokeOrder: false,
  fill: getFill(attributes),
  lineWidth: getLineWidth(attributes),
  stroke: getStroke(attributes)
});
var graphicAttributeTransform = {
  group: (attributes) => {
    const common = commonAttributes2(attributes);
    return Object.assign(Object.assign({}, common), {
      visibleAll: false !== common.visible
    });
  },
  rule: (attributes) => Object.assign(Object.assign({}, commonAttributes2(attributes)), {
    x: parseFloat(attributes.x1),
    y: parseFloat(attributes.y1),
    x1: parseFloat(attributes.x2),
    y1: parseFloat(attributes.y2)
  }),
  rect: (attributes) => Object.assign(Object.assign({}, commonAttributes2(attributes)), {
    fill: getFill(attributes, "#000"),
    width: parseFloat(attributes.width),
    height: parseFloat(attributes.height)
  }),
  polygon: (attributes) => Object.assign(Object.assign({}, commonAttributes2(attributes)), {
    fill: getFill(attributes, "#000"),
    points: attributes.points.trim().split(/\s+/).map((pair) => {
      const [x, y] = pair.split(",").map(Number);
      return {
        x,
        y
      };
    })
  }),
  line: (attributes) => Object.assign(Object.assign({}, commonAttributes2(attributes)), {
    points: attributes.points.trim().split(/\s+/).map((pair) => {
      const [x, y] = pair.split(",").map(Number);
      return {
        x,
        y
      };
    })
  }),
  path: (attributes) => Object.assign(Object.assign({}, commonAttributes2(attributes)), {
    path: attributes.d,
    fillStrokeOrder: false,
    fill: getFill(attributes, "#000")
  }),
  arc: (attributes) => {
    var _a;
    return Object.assign(Object.assign({}, commonAttributes2(attributes)), {
      outerRadius: null !== (_a = attributes.r) && void 0 !== _a ? _a : attributes.ry,
      x: parseFloat(attributes.cx),
      y: parseFloat(attributes.cy),
      startAngle: 0,
      endAngle: 2 * Math.PI,
      scaleX: parseFloat(attributes.rx) / parseFloat(attributes.ry) || 1,
      fill: getFill(attributes, "#000")
    });
  },
  text: (attributes, value) => {
    var _a, _b;
    return Object.assign(Object.assign({}, commonAttributes2(attributes)), {
      text: value,
      textAlign: null !== (_a = attributes.textAlign) && void 0 !== _a ? _a : "left",
      textBaseLine: null !== (_b = attributes.textAnchor) && void 0 !== _b ? _b : "middle",
      anchor: [0, 0],
      fill: getFill(attributes, "#000")
    });
  }
};
var pictogram = (data) => {
  var _a, _b;
  if (!data || !data[0]) return {};
  const { elements } = data[0].latestData;
  if (elements && elements.length) {
    elements.forEach((el, index) => {
      var _a2;
      el[DEFAULT_DATA_INDEX] = index, el._uniqueId = `${el.id}-${index}`, el.data = void 0;
      const { graphicType: type, transform: transform30 } = el, finalAttributes = {
        visible: "hidden" !== el.attributes.visibility && "collapse" !== el.attributes.visibility
      };
      "text" === el.graphicType ? merge(finalAttributes, el._inheritStyle, null === (_a2 = el.parent) || void 0 === _a2 ? void 0 : _a2._textGroupStyle, el.attributes) : "group" !== el.graphicType && merge(finalAttributes, el._inheritStyle, el.attributes), graphicAttributeTransform[type] ? el._finalAttributes = graphicAttributeTransform[type](finalAttributes, el.value) : el._finalAttributes = finalAttributes, transform30 && (el._finalAttributes.postMatrix = Object.assign({}, transform30));
    });
    const texts = elements.filter((el) => "text" === el.tagName);
    for (let i = 0; i < texts.length; i++) {
      const textId = texts[i]._uniqueId, children = elements.filter((el) => {
        let result2 = false, parent = el.parent;
        for (; parent; ) {
          if (parent._uniqueId === textId) {
            result2 = true;
            break;
          }
          parent = parent.parent;
        }
        return result2;
      });
      if (children && children.length) {
        const startX = null !== (_b = null === (_a = texts[i]._textGroupStyle) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : 0;
        let curX = startX;
        for (let j = 0; j < children.length; j++) {
          const currentChild = children[j];
          if ("group" === currentChild.graphicType) curX = startX;
          else if (currentChild.value && void 0 === currentChild.parent._textGroupStyle.x) {
            const lastText = children.slice(0, j).reverse().find((c3) => "text" === c3.graphicType && c3.value);
            if (lastText) {
              curX += measureText(lastText.value, lastText._finalAttributes).width;
            }
            currentChild._finalAttributes.x = curX;
          }
        }
      }
    }
  }
  return elements;
};

// node_modules/@visactor/vchart/esm/series/pictogram/pictogram.js
var PictogramSeries = class _PictogramSeries extends GeoSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pictogram, this._idToMark = /* @__PURE__ */ new Map();
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.svg = this._spec.svg, this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, this.svg || null === (_a = this._option) || void 0 === _a || _a.onError("svg source is not specified !"), this._parsedSvgResult = null === (_b = getSVGSource(this.svg)) || void 0 === _b ? void 0 : _b.latestData, this._parsedSvgResult || null === (_c = this._option) || void 0 === _c || _c.onError(`'${this.svg}' is not registered !`);
  }
  getDatumCenter(datum) {
    return [Number.NaN, Number.NaN];
  }
  getDatumName(datum) {
    return datum.name || datum._nameFromParent;
  }
  getMarksWithoutRoot() {
    return this.getMarks().filter((m4) => m4.name && !m4.name.includes("seriesGroup") && !m4.name.includes("root") && m4 !== this._pictogramMark);
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getTransformMatrix = this.getRootMatrix.bind(this), this._markAttributeContext.coordToPosition = this.coordToPosition.bind(this), this._markAttributeContext.dataToPosition = this.dataToPosition.bind(this);
  }
  _defaultHoverConfig(selector, finalHoverSpec) {
    return {
      seriesId: this.id,
      regionId: this._region.id,
      selector,
      type: "element-highlight-by-graphic-name",
      trigger: finalHoverSpec.trigger,
      triggerOff: "pointerout",
      blurState: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
      highlightState: STATE_VALUE_ENUM.STATE_HOVER
    };
  }
  _defaultSelectConfig(selector, finalSelectSpec) {
    const isMultiple = "multiple" === finalSelectSpec.mode, triggerOff = isValid_default(finalSelectSpec.triggerOff) ? finalSelectSpec.triggerOff : isMultiple ? ["empty", "self"] : ["empty", finalSelectSpec.trigger];
    return {
      type: "element-select-by-graphic-name",
      seriesId: this.id,
      regionId: this._region.id,
      selector,
      trigger: finalSelectSpec.trigger,
      triggerOff,
      reverseState: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
      state: STATE_VALUE_ENUM.STATE_SELECTED,
      isMultiple
    };
  }
  initMark() {
    var _a;
    if (this._pictogramMark = this._createMark(_PictogramSeries.mark.pictogram, {
      groupKey: this.getDimensionField()[0],
      isSeriesMark: true,
      skipBeforeLayouted: true,
      dataView: this._mapViewData.getDataView(),
      dataProductId: this._mapViewData.getProductId()
    }, {
      morph: shouldMarkDoMorph(this._spec, _PictogramSeries.mark.pictogram.name)
    }), this._pictogramMark) {
      this._pictogramMark.setUserId(_PictogramSeries.mark.pictogram.name);
      for (const element of this._mapViewData.getDataView().latestData) {
        const { graphicType: type, name, parent, id, _nameFromParent, _uniqueId } = element, mark = this._createMark({
          type,
          name: null != name ? name : _nameFromParent
        }, {
          groupKey: _uniqueId,
          isSeriesMark: false,
          skipBeforeLayouted: true,
          dataView: this._mapViewData.getDataView(),
          dataProductId: this._mapViewData.getProductId(),
          parent: null !== (_a = this._idToMark.get(null == parent ? void 0 : parent._uniqueId)) && void 0 !== _a ? _a : this._pictogramMark
        }, {
          morph: shouldMarkDoMorph(this._spec, _PictogramSeries.mark.pictogram.name)
        });
        mark && (mark.setUserId(_uniqueId), this._idToMark.set(_uniqueId, mark), "group" !== mark.type && mark.setMarkConfig({
          graphicName: mark.name
        }), mark.setTransform([{
          type: "filter",
          callback: (datum) => datum._uniqueId === _uniqueId
        }]));
      }
      this._initLabelMark();
    }
  }
  _initLabelMark() {
    if (true !== this._spec.label.visible) return;
    const labelMark = this._createMark(_PictogramSeries.mark.label, {
      isSeriesMark: false,
      parent: this._pictogramMark,
      groupKey: "_uniqueId",
      skipBeforeLayouted: true,
      depend: this.getMarksWithoutRoot()
    });
    labelMark && (this._labelMark = labelMark, this._labelMark.setDataView(this._mapViewData.getDataView()));
  }
  initLabelMarkStyle() {
    this._labelMark && this.setMarkStyle(this._labelMark, {
      visible: (d) => !!this._validElement(d),
      x: (d) => {
        var _a;
        return null === (_a = this.dataToPosition(d, true)) || void 0 === _a ? void 0 : _a.x;
      },
      y: (d) => {
        var _a;
        return null === (_a = this.dataToPosition(d, true)) || void 0 === _a ? void 0 : _a.y;
      },
      text: (d) => d[this.nameField],
      textAlign: "center",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initMarkStyle() {
    const { root, viewBoxRect } = this._parsedSvgResult, elements = this._mapViewData.getDataView().latestData;
    root && (this.setMarkStyle(this._pictogramMark, graphicAttributeTransform.group(root.attributes), "normal", AttributeLevel.Built_In), root.transform && this.setMarkStyle(this._pictogramMark, {
      postMatrix: () => root.transform
    }, "normal", AttributeLevel.Built_In), viewBoxRect && this._pictogramMark.setMarkConfig({
      clip: true,
      clipPath: [createRect(Object.assign(Object.assign({}, viewBoxRect), {
        fill: true
      }))]
    }));
    for (const element of elements) {
      const { _uniqueId, _finalAttributes: attributes } = element, mark = this._idToMark.get(_uniqueId), valid = this._validElement(element);
      mark && (this.setMarkStyle(mark, {
        keepStrokeScale: true
      }, "normal", AttributeLevel.Built_In), valid ? (this.initMarkStyleWithSpec(mark, merge({}, this._spec.pictogram, this._spec[mark.name])), this.setMarkStyle(mark, attributes, "normal", AttributeLevel.Series), mark.setPostProcess("fill", (result2, datum) => isValid_default(result2) ? result2 : this._spec.defaultFillColor)) : (mark.setMarkConfig({
        interactive: false
      }), this.setMarkStyle(mark, attributes, "normal", AttributeLevel.Built_In)));
    }
    this.initLabelMarkStyle();
  }
  _validElement(element) {
    return element.name || element._nameFromParent;
  }
  initTooltip() {
    this._tooltipHelper = new PictogramSeriesTooltipHelper(this), this.getMarksWithoutRoot().forEach((mark) => {
      mark && mark.name && this._tooltipHelper.activeTriggerSet.mark.add(mark);
    });
  }
  dataToPosition(datum, global = false) {
    if (!datum) return null;
    const name = datum[this.nameField];
    if (!name) return null;
    const mark = this.getMarksWithoutRoot().filter((mark2) => mark2.name === name);
    if (!mark || 0 === mark.length) return null;
    let bounds = new Bounds();
    global ? mark.forEach((m4) => {
      bounds = bounds.union(m4.getProduct().getGroupGraphicItem().globalAABBBounds);
    }) : mark.forEach((m4) => {
      bounds = bounds.union(m4.getProduct().getBounds());
    });
    const point6 = {
      x: (bounds.x1 + bounds.x2) / 2,
      y: (bounds.y1 + bounds.y2) / 2
    };
    if (global) {
      const { x, y } = this.getLayoutStartPoint();
      point6.x -= x, point6.y -= y;
    }
    return point6;
  }
  coordToPosition(point6) {
    if (!point6) return null;
    const { x, y } = point6, matrix = this.getRootMatrix();
    if (!matrix) return null;
    const position = {};
    return matrix.getInverse().transformPoint({
      x,
      y
    }, position), position;
  }
  getRootMatrix() {
    var _a;
    return null === (_a = this.getPictogramRootGraphic()) || void 0 === _a ? void 0 : _a.transMatrix;
  }
  getPictogramRootGraphic() {
    var _a;
    return null === (_a = this._pictogramMark.getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
  }
  initData() {
    var _a, _b;
    super.initData();
    const parsedSvg = svgSourceMap.get(this.svg);
    parsedSvg || null === (_a = this._option) || void 0 === _a || _a.onError("no valid svg found!");
    const svgData = new DataView(this._dataSet, {
      name: `pictogram_${this.id}_data`
    });
    registerDataSetInstanceTransform(this._dataSet, "pictogram", pictogram), registerDataSetInstanceTransform(this._dataSet, "lookup", lookup), svgData.parse([parsedSvg], {
      type: "dataview"
    }).transform({
      type: "pictogram"
    }).transform({
      type: "lookup",
      options: {
        from: () => this.getViewData().latestData,
        key: "name",
        fields: this._nameField,
        set: (a3, b) => {
          b && (a3.data = b);
        }
      }
    }).transform({
      type: "lookup",
      options: {
        from: () => this.getViewData().latestData,
        key: "_nameFromParent",
        fields: this._nameField,
        set: (a3, b) => {
          b && (a3.data = b);
        }
      }
    }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", svgData.reRunAllTransform), this._mapViewData = new SeriesData(this._option, svgData);
  }
  mapViewDataUpdate() {
    this._mapViewData.updateData();
  }
  onLayoutEnd(ctx) {
    var _a;
    super.onLayoutEnd(ctx), null === (_a = this._mapViewData) || void 0 === _a || _a.getDataView().reRunAllTransform();
  }
  updateSVGSize() {
    const { width: regionWidth, height: regionHeight } = this.getLayoutRect(), regionCenterX = regionWidth / 2, regionCenterY = regionHeight / 2, root = this.getPictogramRootGraphic();
    if (root) {
      const bounds = root.AABBBounds, { x1, x2, y1, y2 } = root.AABBBounds, rootCenterX = (x1 + x2) / 2, rootCenterY = (y1 + y2) / 2, scaleX = regionWidth / bounds.width(), scaleY = regionHeight / bounds.height(), scale4 = Math.min(scaleX, scaleY);
      root.scale(scale4, scale4, {
        x: rootCenterX,
        y: rootCenterY
      }), root.translate(regionCenterX - rootCenterX, regionCenterY - rootCenterY);
    }
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._mapViewData.getDataView()) || void 0 === _a || _a.target.addListener("change", this.mapViewDataUpdate.bind(this)), this.event.on(HOOK_EVENT.AFTER_MARK_LAYOUT_END, this.updateSVGSize.bind(this));
  }
  handleZoom(e) {
    const { scale: scale4, scaleCenter } = e;
    if (1 === scale4) return;
    const root = this.getPictogramRootGraphic();
    root && (root.attribute.postMatrix || root.setAttributes({
      postMatrix: new Matrix()
    }), root.scale(scale4, scale4, scaleCenter));
  }
  handlePan(e) {
    const { delta } = e;
    if (0 === delta[0] && 0 === delta[1]) return;
    const root = this.getPictogramRootGraphic();
    root && (root.attribute.postMatrix || root.setAttributes({
      postMatrix: new Matrix()
    }), root.translate(delta[0], delta[1]));
  }
  getMarkData(datum) {
    var _a;
    return null !== (_a = datum.data) && void 0 !== _a ? _a : {};
  }
  getMeasureField() {
    return [this.valueField];
  }
  getDimensionField() {
    return [this.nameField];
  }
  _getSeriesInfo(field5, keys) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys.map((key) => ({
      key,
      originalKey: key,
      style: this.getSeriesStyle({
        data: {
          [field5]: key
        }
      }),
      shapeType: defaultShapeType
    }));
  }
  release() {
    this._parsedSvgResult = null, this._idToMark.clear(), this._idToMark = null;
  }
};
PictogramSeries.type = SeriesTypeEnum.pictogram, PictogramSeries.mark = PictogramSeriesMark, PictogramSeries.transformerConstructor = PictogramSeriesSpecTransformer;
var registerPictogramSeries = () => {
  Factory2.registerSeries(PictogramSeries.type, PictogramSeries), Factory2.registerImplement("registerSVG", registerSVGSource), Factory2.registerImplement("unregisterSVG", unregisterSVGSource), registerElementHighlightByGraphicName(), registerElementSelectByGraphicName();
};

// node_modules/@visactor/vchart/esm/chart/map/map-transformer.js
var MapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return type === SeriesTypeEnum.map;
  }
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["type", "nameField", "valueField", "map", "nameProperty", "centroidProperty", "nameMap", "area", "defaultFillColor", "showDefaultName"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.region.forEach((r) => {
      r.coordinate = "geo";
    }), super.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/map/map.js
var MapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = MapChartSpecTransformer, this.type = "map", this.seriesType = SeriesTypeEnum.map;
  }
};
MapChart.type = "map", MapChart.seriesType = SeriesTypeEnum.map, MapChart.transformerConstructor = MapChartSpecTransformer;
var registerMapChart = () => {
  registerMapSeries(), Factory2.registerChart(MapChart.type, MapChart);
};

// node_modules/@visactor/vchart/esm/chart/polar/polar-transformer.js
var PolarChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  getIndicatorSpec(spec) {
    var _a, _b, _c;
    const indicatorSpec = array(spec.indicator), limitRatio = null !== (_a = spec.innerRadius) && void 0 !== _a ? _a : null === (_c = null === (_b = spec.series) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.innerRadius;
    return isValid_default(limitRatio) && indicatorSpec.forEach((indicator2) => {
      isNil_default(indicator2.limitRatio) && (indicator2.limitRatio = limitRatio);
    }), indicatorSpec;
  }
  _getDefaultSeriesSpec(spec, pickKeys) {
    return super._getDefaultSeriesSpec(spec, ["radius", "outerRadius", "innerRadius", "startAngle", "endAngle", "sortDataByAxis"], pickKeys);
  }
  transformSpec(spec) {
    super.transformSpec(spec), isArray_default(spec.dataZoom) && spec.dataZoom.length > 0 && spec.dataZoom.forEach((zoom) => {
      "axis" === zoom.filterMode && (zoom.filterMode = "filter");
    }), this.transformSeriesSpec(spec), isValid_default(spec.indicator) && (spec.indicator = this.getIndicatorSpec(spec));
  }
};

// node_modules/@visactor/vchart/esm/chart/polar/progress-like/progress-like-transformer.js
var ProgressLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec, ["startAngle", "endAngle", "centerX", "centerY"]);
    return series2.categoryField = spec.categoryField || spec.radiusField, series2.valueField = spec.valueField || spec.angleField, series2;
  }
  _transformProgressAxisSpec(spec, angleAxisDefaultSpec, radiusAxisDefaultSpec, angleAxisAppendSpec, radiusAxisAppendSpec) {
    var _a, _b;
    spec.axes || (spec.axes = []);
    let radiusAxis = (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).find((axis2) => "radius" === axis2.orient), angleAxis = (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).find((axis2) => "angle" === axis2.orient);
    angleAxis || (angleAxis = angleAxisDefaultSpec, spec.axes.push(angleAxis)), radiusAxis || (radiusAxis = radiusAxisDefaultSpec, spec.axes.push(radiusAxis)), isNil_default(angleAxis.type) && (angleAxis.type = "linear"), isNil_default(radiusAxis.type) && (radiusAxis.type = "band");
    const domain = getLinearAxisSpecDomain(angleAxis, {
      min: 0,
      max: 1
    });
    isNil_default(angleAxis.min) && (angleAxis.min = domain.min), isNil_default(angleAxis.max) && (angleAxis.max = domain.max), angleAxisAppendSpec && Object.assign(angleAxis, mergeSpec({}, angleAxisAppendSpec, angleAxis)), radiusAxisAppendSpec && Object.assign(radiusAxis, mergeSpec({}, radiusAxisAppendSpec, radiusAxis));
  }
};

// node_modules/@visactor/vchart/esm/chart/polar/rose-like/rose-like-transformer.js
var RoseLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return true;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.categoryField = spec.categoryField || spec.angleField, series2.valueField = spec.valueField || spec.radiusField, series2;
  }
  transformSpec(spec) {
    var _a;
    if (super.transformSpec(spec), this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        radius: false,
        angle: false
      };
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "radius" === orient && (haxAxes.radius = true), "angle" === orient && (haxAxes.angle = true);
      }), haxAxes.angle || spec.axes.push({
        orient: "angle"
      }), haxAxes.radius || spec.axes.push({
        orient: "radius"
      });
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/pie/base/pie-transformer.js
var BasePieChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    var _a;
    const seriesSpec = super._getDefaultSeriesSpec(spec, ["center", "centerOffset", "cornerRadius", "padAngle", "minAngle", "emptyPlaceholder", "showAllZero", "supportNegative", "layoutRadius"]);
    return seriesSpec.categoryField = spec.categoryField || spec.seriesField, seriesSpec.valueField = spec.valueField || spec.angleField, seriesSpec.emptyCircle = null === (_a = spec.emptyPlaceholder) || void 0 === _a ? void 0 : _a.emptyCircle, seriesSpec;
  }
};

// node_modules/@visactor/vchart/esm/chart/pie/base/base.js
var BasePieChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer;
  }
};
BasePieChart.transformerConstructor = BasePieChartSpecTransformer;

// node_modules/@visactor/vchart/esm/chart/pie/pie.js
var PieChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer, this.type = "pie", this.seriesType = SeriesTypeEnum.pie;
  }
};
PieChart.type = "pie", PieChart.seriesType = SeriesTypeEnum.pie, PieChart.transformerConstructor = BasePieChartSpecTransformer;
var registerPieChart = () => {
  registerPieSeries(), Factory2.registerChart(PieChart.type, PieChart);
};

// node_modules/@visactor/vchart/esm/chart/pie/3d/pie-3d.js
var Pie3dChartSpecTransformer = class extends BasePieChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.series.forEach((s2) => {
      "pie3d" === s2.type && (s2.angle3d = spec.angle3d);
    });
  }
};
var Pie3dChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Pie3dChartSpecTransformer, this.type = "pie3d", this.seriesType = SeriesTypeEnum.pie3d;
  }
};
Pie3dChart.type = "pie3d", Pie3dChart.seriesType = SeriesTypeEnum.pie3d, Pie3dChart.transformerConstructor = Pie3dChartSpecTransformer;
var registerPie3dChart = () => {
  register3DPlugin(), registerPie3dSeries(), Factory2.registerChart(Pie3dChart.type, Pie3dChart);
};

// node_modules/@visactor/vchart/esm/chart/rose/rose-transformer.js
var RoseChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b, _c;
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.radius = null !== (_a = spec.radius) && void 0 !== _a ? _a : POLAR_DEFAULT_RADIUS, series2.outerRadius = null !== (_b = spec.outerRadius) && void 0 !== _b ? _b : POLAR_DEFAULT_RADIUS, series2.innerRadius = null !== (_c = spec.innerRadius) && void 0 !== _c ? _c : 0, series2.stack = spec.stack, series2.percent = spec.percent, series2;
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      ["domainLine", "grid", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), "angle" === axis2.orient && isNil_default(axis2.bandPosition) && (axis2.bandPosition = 0.5);
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "rect"
        }
      }
    }, crosshairCfg));
  }
};

// node_modules/@visactor/vchart/esm/chart/rose/rose.js
var RoseChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RoseChartSpecTransformer, this.type = "rose", this.seriesType = SeriesTypeEnum.rose;
  }
};
RoseChart.type = "rose", RoseChart.seriesType = SeriesTypeEnum.rose, RoseChart.transformerConstructor = RoseChartSpecTransformer, mixin(RoseChart, StackChartMixin);
var registerRoseChart = () => {
  registerRoseSeries(), Factory2.registerChart(RoseChart.type, RoseChart);
};

// node_modules/@visactor/vchart/esm/chart/radar/radar-transformer.js
var RadarChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.line = spec.line, series2.point = spec.point, series2.stack = spec.stack, series2.percent = spec.percent, series2.area = mergeSpec({
      visible: false
    }, spec.area), series2.seriesMark = null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "area", series2.activePoint = spec.activePoint, series2.pointDis = spec.pointDis, series2.pointDisMul = spec.pointDisMul, series2.markOverlap = spec.markOverlap, series2;
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      "radius" === axis2.orient && (["domainLine", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), axis2.grid || (axis2.grid = {
        visible: true
      }));
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "line"
        }
      }
    }, crosshairCfg));
  }
};

// node_modules/@visactor/vchart/esm/chart/radar/radar.js
var RadarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RadarChartSpecTransformer, this.type = "radar", this.seriesType = SeriesTypeEnum.radar;
  }
};
RadarChart.type = "radar", RadarChart.seriesType = SeriesTypeEnum.radar, RadarChart.transformerConstructor = RadarChartSpecTransformer, mixin(RadarChart, StackChartMixin);
var registerRadarChart = () => {
  registerRadarSeries(), Factory2.registerChart(RadarChart.type, RadarChart);
};

// node_modules/@visactor/vchart/esm/chart/common/common-transformer.js
var CommonChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const defaultSpec = super._getDefaultSeriesSpec(spec);
    return delete defaultSpec.data, defaultSpec;
  }
  _transformAxisSpec(spec) {
    spec.axes && spec.autoBandSize && spec.series.forEach((series2, seriesIndex) => {
      var _a;
      if ("bar" === series2.type) {
        const relatedAxis = this._findBandAxisBySeries(series2, seriesIndex, spec.axes);
        if (relatedAxis && !relatedAxis.bandSize && !relatedAxis.maxBandSize && !relatedAxis.minBandSize) {
          const extend = isObject_default(series2.autoBandSize) && null !== (_a = series2.autoBandSize.extend) && void 0 !== _a ? _a : 0, { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = series2;
          this._applyAxisBandSize(relatedAxis, extend, {
            barMaxWidth,
            barMinWidth,
            barWidth,
            barGapInGroup
          });
        }
      }
    });
  }
  transformSpec(spec) {
    if (super.transformSpec(spec), spec.series && spec.series.length) {
      const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
      spec.series.forEach((s2) => {
        this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
          k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
        });
      });
    }
    spec.axes && spec.axes.length && spec.axes.forEach((axis2) => {
      get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
    }), this._transformAxisSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/common/common.js
var CommonChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CommonChartSpecTransformer, this.type = "common";
  }
};
CommonChart.type = "common", CommonChart.transformerConstructor = CommonChartSpecTransformer, mixin(CommonChart, StackChartMixin);
var registerCommonChart = () => {
  Factory2.registerChart(CommonChart.type, CommonChart);
};

// node_modules/@visactor/vchart/esm/constant/scroll-bar.js
var SCROLL_BAR_DEFAULT_SIZE = 12;

// node_modules/@visactor/vchart/esm/chart/sequence/sequence-transformer.js
var SequenceChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getSeriesDataLength(spec, seriesSpec) {
    var _a, _b;
    if (seriesSpec.data) {
      const _d = array(seriesSpec.data)[0];
      return _d instanceof DataView ? null === (_a = _d.latestData) || void 0 === _a ? void 0 : _a.length : null === (_b = _d.values) || void 0 === _b ? void 0 : _b.length;
    }
    const dataTemp = array(spec.data).find((_d, index) => seriesSpec.dataId ? _d instanceof DataView ? _d.name === seriesSpec.dataId : _d.id === seriesSpec.dataId : seriesSpec.dataIndex === index);
    return dataTemp ? dataTemp instanceof DataView ? dataTemp.latestData.length : dataTemp.values.length : 0;
  }
  addAttrToComponentSpec(componentSpec, attr, value) {
    return Array.isArray(componentSpec) ? componentSpec[0][attr] = value : componentSpec[attr] = value, componentSpec;
  }
  addPaddingRow(rowHeight, rowNum, size) {
    rowHeight.push({
      index: rowNum,
      size
    });
  }
  addOrientAxes(region, elements, rowNum, spec) {
    region.push({
      id: `regionAxesRow${rowNum}`
    }), elements.push({
      modelId: `axesRow${rowNum}`,
      col: 1,
      row: rowNum
    }), spec.axes[0].id = `axesRow${rowNum}`, spec.axes[0].regionIndex = Array.from(Array(spec.series.length), (_, index) => "top" === spec.axes[0].orient ? index + 1 : index);
  }
  transformSpec(spec) {
    var _a, _b, _c, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    super.transformSpec(spec);
    let rowNum = 0;
    const elements = [], region = [], axes = [], scrollBar2 = [], rowHeight = [], viewLayoutRect_height = (this._option.getCompiler().getVGrammarView().width(), this._option.getCompiler().getVGrammarView().height());
    let componentsHeight = 0;
    if (null == spec ? void 0 : spec.legends) {
      elements.push({
        modelId: `legendRow${rowNum}`,
        col: 1,
        row: rowNum
      }), this.addAttrToComponentSpec(spec.legends, "id", `legendRow${rowNum}`);
      const legendSpec = array(spec.legends);
      let legendHeight = null !== (_a = legendSpec[0].height) && void 0 !== _a ? _a : 40;
      if (legendSpec[0].padding) {
        const legendPadding = normalizeLayoutPaddingSpec(legendSpec[0].padding);
        legendHeight += Number(null !== (_b = null == legendPadding ? void 0 : legendPadding.bottom) && void 0 !== _b ? _b : 0), legendHeight += Number(null !== (_c = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _c ? _c : 0), legendSpec[0].offsetY = Number(null !== (_f = null === (_e = legendSpec[0]) || void 0 === _e ? void 0 : _e.offsetY) && void 0 !== _f ? _f : 0) + Number(null !== (_g = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _g ? _g : 0);
      }
      rowHeight.push({
        index: rowNum,
        size: legendHeight
      }), componentsHeight += legendHeight, rowNum++;
    }
    (null == spec ? void 0 : spec.dataZoom) && (elements.push({
      modelId: `dataZoomRow${rowNum}`,
      col: 1,
      row: rowNum
    }), this.addAttrToComponentSpec(spec.dataZoom, "id", `dataZoomRow${rowNum}`), componentsHeight += 60, rowNum++, this.addPaddingRow(rowHeight, rowNum, 10), componentsHeight += 10, rowNum++), componentsHeight += 60, null !== spec.axes && "top" !== (null === (_j = null === (_h = null == spec ? void 0 : spec.axes) || void 0 === _h ? void 0 : _h[0]) || void 0 === _j ? void 0 : _j.orient) || (this.addOrientAxes(region, elements, rowNum, spec), rowNum++);
    const seriesRegionNum = spec.series.filter((d) => d.type !== SeriesTypeEnum.link).length, defaultSeriesRowHeight = (viewLayoutRect_height - componentsHeight - 20 * seriesRegionNum) / seriesRegionNum, leftAppendPadding = (null === (_k = null == spec ? void 0 : spec.appendPadding) || void 0 === _k ? void 0 : _k.left) || 0, rightAppendPadding = (null === (_l = null == spec ? void 0 : spec.appendPadding) || void 0 === _l ? void 0 : _l.right) || 0;
    null === (_m = null == spec ? void 0 : spec.series) || void 0 === _m || _m.forEach((seriesSpec) => {
      var _a2, _b2;
      if ([SeriesTypeEnum.bar, SeriesTypeEnum.line, SeriesTypeEnum.area, SeriesTypeEnum.dot].includes(seriesSpec.type)) {
        if (elements.push({
          modelId: `${seriesSpec.type}Row${rowNum}`,
          col: 1,
          row: rowNum
        }), elements.push({
          modelId: `axesLeftRow${rowNum}`,
          col: 0,
          row: rowNum
        }), region.push({
          id: `${seriesSpec.type}Row${rowNum}`,
          clip: false
        }), rowHeight.push({
          index: rowNum,
          size: (null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight
        }), axes.push({
          orient: "left",
          id: `axesLeftRow${rowNum}`,
          type: seriesSpec.type === SeriesTypeEnum.dot ? "band" : "linear",
          visible: seriesSpec.type !== SeriesTypeEnum.dot,
          title: {
            visible: true,
            autoRotate: false,
            style: {
              text: null == seriesSpec ? void 0 : seriesSpec.barTitle,
              dx: -20,
              textBaseline: "middle",
              textAlign: "end"
            }
          },
          grid: {
            visible: "boolean" != typeof (null === (_a2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a2 ? void 0 : _a2.visible) || (null === (_b2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _b2 ? void 0 : _b2.visible),
            style: (datum, index) => {
              var _a3, _b3, _c2, _e2, _f2;
              let lineWidth = 0;
              if (0 === index) {
                const style = null === (_a3 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a3 ? void 0 : _a3.style;
                lineWidth = null !== (_c2 = null !== (_b3 = null == style ? void 0 : style.lineWidth) && void 0 !== _b3 ? _b3 : null == style ? void 0 : style.strokeWidth) && void 0 !== _c2 ? _c2 : 1;
              }
              return {
                lineWidth,
                stroke: (null === (_f2 = null === (_e2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _e2 ? void 0 : _e2.style) || void 0 === _f2 ? void 0 : _f2.stroke) || "#dfdfdf",
                lineDash: [0, 0]
              };
            }
          },
          domainLine: {
            visible: false
          },
          tick: {
            visible: false
          },
          label: {
            visible: false
          },
          regionIndex: region.length - 1
        }), seriesSpec.type === SeriesTypeEnum.dot) {
          elements.push({
            modelId: `scrollBarRightRow${rowNum}`,
            col: 2,
            row: rowNum
          });
          const dataLength = this._getSeriesDataLength(spec, seriesSpec);
          let ratio = 0;
          dataLength && (ratio = ((null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight) / (30 * dataLength)), scrollBar2.push(Object.assign({
            orient: "right",
            visible: seriesSpec.type === SeriesTypeEnum.dot && ratio < 1,
            id: `scrollBarRightRow${rowNum}`,
            start: 0,
            end: Math.min(ratio, 1),
            filterMode: "axis",
            regionIndex: region.length - 1,
            axisId: `axesLeftRow${rowNum}`
          }, array(null == spec ? void 0 : spec.scrollBar)[0]));
        }
        seriesSpec.regionIndex = region.length - 1, rowNum++, this.addPaddingRow(rowHeight, rowNum, (null == seriesSpec ? void 0 : seriesSpec.padding) || 20), rowNum++, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.type === SeriesTypeEnum.dot && (seriesSpec.title.style.dx = -leftAppendPadding, seriesSpec.subTitle.style.dx = -leftAppendPadding);
      }
    }), this.addPaddingRow(rowHeight, rowNum, 20), rowNum++, null === (_o = null == spec ? void 0 : spec.series) || void 0 === _o || _o.forEach((seriesSpec) => {
      if (seriesSpec.type === SeriesTypeEnum.link) {
        const dotRowNum = seriesSpec.dotSeriesIndex + 1;
        elements.push({
          modelId: `${seriesSpec.type}Row${dotRowNum}`,
          col: 1,
          row: dotRowNum - 1
        }), seriesSpec.regionIndex = spec.series[seriesSpec.dotSeriesIndex].regionIndex, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.height = spec.series[seriesSpec.dotSeriesIndex].height, seriesSpec.clipHeight = spec.series[seriesSpec.dotSeriesIndex].clipHeight;
      }
    }), (null == spec ? void 0 : spec.legends) && this.addAttrToComponentSpec(spec.legends, "regionIndex", [region.length - 1]), "bottom" === (null === (_q = null === (_p = null == spec ? void 0 : spec.axes) || void 0 === _p ? void 0 : _p[0]) || void 0 === _q ? void 0 : _q.orient) && (this.addOrientAxes(region, elements, rowNum, spec), rowNum++);
    const layout2 = {
      type: "grid",
      col: 4,
      row: rowNum,
      colWidth: [{
        index: 0,
        size: leftAppendPadding
      }, {
        index: 2,
        size: SCROLL_BAR_DEFAULT_SIZE
      }, {
        index: 3,
        size: rightAppendPadding
      }],
      rowHeight,
      elements
    };
    spec.layout = layout2, spec.region = region, null === (_r = spec.axes) || void 0 === _r || _r.push(...axes), spec.scrollBar = scrollBar2;
  }
};

// node_modules/@visactor/vchart/esm/chart/sequence/sequence.js
var __rest25 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var SequenceChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SequenceChartSpecTransformer, this.type = "sequence";
  }
  _createSeries(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest25(specInfo, ["spec"]);
    let region;
    if (spec.type === SeriesTypeEnum.link && (spec.dotSeriesSpec = this._spec.series[spec.dotSeriesIndex]), spec.regionId && (region = this.getRegionsInUserId(spec.regionId)), region || (region = this.getRegionsInIndex(spec.regionIndex ? [spec.regionIndex] : void 0)[0]), !region) return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      region,
      specKey: "series",
      globalScale: this._globalScale
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
};
SequenceChart.type = "sequence", SequenceChart.transformerConstructor = SequenceChartSpecTransformer;
var registerSequenceChart = () => {
  registerDotSeries(), registerLinkSeries(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerChart(SequenceChart.type, SequenceChart);
};

// node_modules/@visactor/vchart/esm/chart/histogram/base/histogram-base-transformer.js
var BaseHistogramChartSpecTransformer = class extends CartesianChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes.forEach((axis2) => axis2.type = "linear");
  }
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["x2Field", "y2Field", "barMinHeight", "barBackground"]);
  }
};

// node_modules/@visactor/vchart/esm/chart/histogram/base/base.js
var BaseHistogramChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseHistogramChartSpecTransformer;
  }
};
BaseHistogramChart.transformerConstructor = BaseHistogramChartSpecTransformer, mixin(BaseHistogramChart, StackChartMixin);

// node_modules/@visactor/vchart/esm/chart/histogram/histogram-transformer.js
var HistogramChartSpecTransformer = class extends BaseHistogramChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/histogram/histogram.js
var HistogramChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram", this.seriesType = SeriesTypeEnum.bar;
  }
};
HistogramChart.type = "histogram", HistogramChart.seriesType = SeriesTypeEnum.bar, HistogramChart.transformerConstructor = HistogramChartSpecTransformer;
var registerHistogramChart = () => {
  registerBarSeries(), Factory2.registerChart(HistogramChart.type, HistogramChart);
};

// node_modules/@visactor/vchart/esm/chart/histogram/3d/histogram-3d.js
var Histogram3dChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Histogram3dChart.type = "histogram3d", Histogram3dChart.seriesType = SeriesTypeEnum.bar3d, Histogram3dChart.transformerConstructor = HistogramChartSpecTransformer;
var registerHistogram3dChart = () => {
  register3DPlugin(), registerBar3dSeries(), Factory2.registerChart(Histogram3dChart.type, Histogram3dChart);
};

// node_modules/@visactor/vchart/esm/chart/progress/circular/circular-progress-transformer.js
var CircularProgressChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.progress = spec.progress, series2.track = spec.track, series2.tickMask = spec.tickMask, series2.cornerRadius = null !== (_a = spec.cornerRadius) && void 0 !== _a ? _a : 0, series2.roundCap = null !== (_b = spec.roundCap) && void 0 !== _b && _b, series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: false
    }, {
      orient: "radius",
      visible: false
    }, {
      forceInitTick: spec.tickMask && false !== spec.tickMask.visible
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/progress/circular/circular.js
var CircularProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CircularProgressChartSpecTransformer, this.type = "circularProgress", this.seriesType = SeriesTypeEnum.circularProgress;
  }
};
CircularProgressChart.type = "circularProgress", CircularProgressChart.seriesType = SeriesTypeEnum.circularProgress, CircularProgressChart.transformerConstructor = CircularProgressChartSpecTransformer, mixin(CircularProgressChart, StackChartMixin);
var registerCircularProgressChart = () => {
  registerCircularProgressSeries(), Factory2.registerChart(CircularProgressChart.type, CircularProgressChart);
};

// node_modules/@visactor/vchart/esm/chart/gauge/gauge-transformer.js
var GaugeChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.radiusField = spec.radiusField, series2.pin = spec.pin, series2.pinBackground = spec.pinBackground, series2.pointer = spec.pointer, series2;
  }
  _getDefaultCircularProgressSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.type = SeriesTypeEnum.circularProgress, series2;
  }
  transformSpec(spec) {
    var _a, _b, _c, _d, _e;
    super.transformSpec(spec);
    let backgroundSeries = null === (_a = spec.series) || void 0 === _a ? void 0 : _a.find((series2) => series2.type === SeriesTypeEnum.gauge || series2.type === SeriesTypeEnum.circularProgress);
    isNil_default(backgroundSeries) && (backgroundSeries = null !== (_b = spec.gauge) && void 0 !== _b ? _b : this._getDefaultCircularProgressSeriesSpec(spec), "circularProgress" === backgroundSeries.type && (isNil_default(backgroundSeries.radiusField) && isNil_default(backgroundSeries.categoryField) && (backgroundSeries.radiusField = null !== (_d = null !== (_c = spec.radiusField) && void 0 !== _c ? _c : spec.categoryField) && void 0 !== _d ? _d : spec.seriesField), isNil_default(backgroundSeries.valueField) && isNil_default(backgroundSeries.angleField) && (backgroundSeries.valueField = null !== (_e = spec.valueField) && void 0 !== _e ? _e : spec.angleField)), 1 === spec.series.length ? spec.series.push(backgroundSeries) : spec.series.forEach((s2) => {
      s2.type === backgroundSeries.type && Object.keys(backgroundSeries).forEach((k2) => {
        k2 in s2 || (s2[k2] = backgroundSeries[k2]);
      });
    })), backgroundSeries.type === SeriesTypeEnum.circularProgress ? this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: true,
      domainLine: {
        visible: false
      },
      grid: {
        visible: false
      }
    }, {
      orient: "radius",
      visible: false
    }, {
      zIndex: LayoutZIndex.Region + 50
    }) : this._transformGaugeAxisSpec(spec);
  }
  _transformGaugeAxisSpec(spec) {
    var _a;
    spec.axes || (spec.axes = []);
    const axesPtr = {
      radius: null,
      angle: null
    };
    (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      const { orient } = axis2;
      "radius" === orient && (axesPtr.radius = axis2), "angle" === orient && (axesPtr.angle = axis2);
    }), axesPtr.angle || (axesPtr.angle = {
      orient: "angle",
      visible: true
    }, spec.axes.push(axesPtr.angle)), axesPtr.radius || (axesPtr.radius = {
      orient: "radius",
      visible: false
    }, spec.axes.push(axesPtr.radius)), isNil_default(axesPtr.angle.type) && (axesPtr.angle.type = "linear"), isNil_default(axesPtr.radius.type) && (axesPtr.radius.type = "linear"), isNil_default(axesPtr.angle.zIndex) && (axesPtr.angle.zIndex = LayoutZIndex.Region + 50);
  }
};

// node_modules/@visactor/vchart/esm/chart/gauge/gauge.js
var GaugeChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = GaugeChartSpecTransformer, this.type = "gauge", this.seriesType = SeriesTypeEnum.gaugePointer;
  }
};
GaugeChart.type = "gauge", GaugeChart.seriesType = SeriesTypeEnum.gaugePointer, GaugeChart.transformerConstructor = GaugeChartSpecTransformer;
var registerGaugeChart = () => {
  registerGaugePointerSeries(), registerGaugeSeries(), registerCircularProgressSeries(), Factory2.registerChart(GaugeChart.type, GaugeChart);
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/base/word-cloud-base-transformer.js
var BaseWordCloudChartSpecTransformer = class extends BaseChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["nameField", "valueField", "fontFamilyField", "fontWeightField", "fontStyleField", "colorHexField", "colorMode", "colorList", "rotateAngles", "fontWeightRange", "fontSizeRange", "maskShape", "keepAspect", "random", "wordCloudConfig", "wordCloudShapeConfig", "word", "fillingWord", "wordMask"]);
  }
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/base/base.js
var BaseWordCloudChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseWordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
BaseWordCloudChart.transformerConstructor = BaseWordCloudChartSpecTransformer;

// node_modules/@visactor/vchart/esm/chart/word-cloud/word-cloud.js
var WordCloudChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseWordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
WordCloudChart.type = "wordCloud", WordCloudChart.seriesType = SeriesTypeEnum.wordCloud, WordCloudChart.transformerConstructor = BaseWordCloudChartSpecTransformer;
var registerWordCloudChart = () => {
  registerWordCloudSeries(), Factory2.registerChart(WordCloudChart.type, WordCloudChart);
};
var registerWordCloudShapeChart = () => {
  registerWordCloudShapeSeries(), registerWordCloudSeries(), Factory2.registerChart(WordCloudChart.type, WordCloudChart);
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/3d/word-cloud-3d-transformer.js
var WordCloud3dChartSpecTransformer = class extends BaseWordCloudChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.depth_3d = spec.depth_3d, series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/3d/word-cloud-3d.js
var WordCloud3dChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WordCloud3dChartSpecTransformer, this.type = "wordCloud3d", this.seriesType = SeriesTypeEnum.wordCloud3d;
  }
};
WordCloud3dChart.type = "wordCloud3d", WordCloud3dChart.seriesType = SeriesTypeEnum.wordCloud3d, WordCloud3dChart.transformerConstructor = WordCloud3dChartSpecTransformer;
var registerWordCloud3dChart = () => {
  register3DPlugin(), registerWordCloud3dSeries(), Factory2.registerChart(WordCloud3dChart.type, WordCloud3dChart);
};
var registerWordCloudShape3dChart = () => {
  register3DPlugin(), registerWordCloudShape3dSeries(), register3DPlugin(), registerWordCloud3dSeries(), Factory2.registerChart(WordCloud3dChart.type, WordCloud3dChart);
};

// node_modules/@visactor/vchart/esm/chart/funnel/funnel-transformer.js
var FunnelChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "funnelAlign", "funnelOrient", "heightRatio", "shape", "funnel", "transform", "outerLabel", "transformLabel", "isTransform", "maxSize", "minSize", "gap", "isCone", "range", "transformRatioText"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), super.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/funnel/funnel.js
var FunnelChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel", this.seriesType = SeriesTypeEnum.funnel;
  }
};
FunnelChart.type = "funnel", FunnelChart.seriesType = SeriesTypeEnum.funnel, FunnelChart.transformerConstructor = FunnelChartSpecTransformer;
var registerFunnelChart = () => {
  registerFunnelSeries(), Factory2.registerChart(FunnelChart.type, FunnelChart);
};

// node_modules/@visactor/vchart/esm/chart/funnel/3d/funnel-3d.js
var Funnel3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel3d", this.seriesType = SeriesTypeEnum.funnel3d;
  }
};
Funnel3dChart.type = "funnel3d", Funnel3dChart.seriesType = SeriesTypeEnum.funnel3d, Funnel3dChart.transformerConstructor = FunnelChartSpecTransformer;
var registerFunnel3dChart = () => {
  register3DPlugin(), registerFunnel3dSeries(), Factory2.registerChart(Funnel3dChart.type, Funnel3dChart);
};

// node_modules/@visactor/vchart/esm/chart/progress/linear/linear-progress-transformer.js
var LinearProgressChartSpecTransformer = class extends CartesianChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec, ["bandWidth", "progress", "track", "clamp"]);
    return series2.direction = null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal", series2.cornerRadius = null !== (_b = spec.cornerRadius) && void 0 !== _b ? _b : 0, series2;
  }
  transformSpec(spec) {
    var _a, _b;
    if (super.transformSpec(spec), spec.axes || (spec.axes = []), "vertical" === spec.direction) {
      let leftAxis = null, bottomAxis = null;
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "band"), isNil_default(leftAxis.type) && (leftAxis.type = "linear");
      const domain = getLinearAxisSpecDomain(leftAxis, {
        min: 0,
        max: 1
      });
      isNil_default(leftAxis.min) && (leftAxis.min = domain.min), isNil_default(leftAxis.max) && (leftAxis.max = domain.max);
    } else {
      let leftAxis = null, bottomAxis = null;
      (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        type: "band",
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "linear"), isNil_default(leftAxis.type) && (leftAxis.type = "band");
      const domain = getLinearAxisSpecDomain(bottomAxis, {
        min: 0,
        max: 1
      });
      isNil_default(bottomAxis.min) && (bottomAxis.min = domain.min), isNil_default(bottomAxis.max) && (bottomAxis.max = domain.max);
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/progress/linear/linear.js
var LinearProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LinearProgressChartSpecTransformer, this.type = "linearProgress", this.seriesType = SeriesTypeEnum.linearProgress;
  }
};
LinearProgressChart.type = "linearProgress", LinearProgressChart.seriesType = SeriesTypeEnum.linearProgress, LinearProgressChart.transformerConstructor = LinearProgressChartSpecTransformer, mixin(LinearProgressChart, StackChartMixin);
var registerLinearProgressChart = () => {
  registerLinearProgressSeries(), Factory2.registerChart(LinearProgressChart.type, LinearProgressChart);
};

// node_modules/@visactor/vchart/esm/chart/range-column/range-column-transformer.js
var RangeColumnChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec, ["barWidth", "barMaxWidth", "barMinWidth", "barGapInGroup", "barBackground", "barMinHeight", "stackCornerRadius", "bar"]);
    return "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/range-column/range-column.js
var RangeColumnChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumnChartSpecTransformer, this.type = "rangeColumn", this.seriesType = SeriesTypeEnum.rangeColumn;
  }
};
RangeColumnChart.type = "rangeColumn", RangeColumnChart.seriesType = SeriesTypeEnum.rangeColumn, RangeColumnChart.transformerConstructor = RangeColumnChartSpecTransformer;
var registerRangeColumnChart = () => {
  registerRangeColumnSeries(), Factory2.registerChart(RangeColumnChart.type, RangeColumnChart);
};

// node_modules/@visactor/vchart/esm/chart/range-column/3d/range-column-3d-transformer.js
var RangeColumn3dChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec, ["bar3d", "barGapInGroup"]);
    return "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/range-column/3d/range-column-3d.js
var RangeColumn3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumn3dChartSpecTransformer, this.type = "rangeColumn3d", this.seriesType = SeriesTypeEnum.rangeColumn3d;
  }
};
RangeColumn3dChart.type = "rangeColumn3d", RangeColumn3dChart.seriesType = SeriesTypeEnum.rangeColumn3d, RangeColumn3dChart.transformerConstructor = RangeColumn3dChartSpecTransformer;
var registerRangeColumn3dChart = () => {
  register3DPlugin(), registerRangeColumn3dSeries(), Factory2.registerChart(RangeColumn3dChart.type, RangeColumn3dChart);
};

// node_modules/@visactor/vchart/esm/chart/sunburst/sunburst-transformer.js
var SunburstChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const startAngle = isValid_default(spec.startAngle) ? spec.startAngle : POLAR_START_ANGLE2, endAngle = isValid_default(spec.endAngle) ? spec.endAngle : startAngle + radianToDegree(2 * Math.PI), series2 = super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "centerX", "centerY", "offsetX", "offsetY", "innerRadius", "outerRadius", "gap", "labelLayout", "label", "labelAutoVisible", "drill", "drillField"]);
    return series2.startAngle = startAngle, series2.endAngle = endAngle, series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/sunburst/sunburst.js
var SunburstChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SunburstChartSpecTransformer, this.type = "sunburst", this.seriesType = SeriesTypeEnum.sunburst;
  }
};
SunburstChart.type = "sunburst", SunburstChart.seriesType = SeriesTypeEnum.sunburst, SunburstChart.transformerConstructor = SunburstChartSpecTransformer;
var registerSunburstChart = () => {
  registerSunBurstSeries(), Factory2.registerChart(SunburstChart.type, SunburstChart);
};

// node_modules/@visactor/vchart/esm/chart/circle-packing/circle-packing-transformer.js
var CirclePackingChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "layoutPadding", "circlePacking", "drill", "drillField"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/circle-packing/circle-packing.js
var CirclePackingChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CirclePackingChartSpecTransformer, this.type = "circlePacking", this.seriesType = SeriesTypeEnum.circlePacking;
  }
};
CirclePackingChart.type = "circlePacking", CirclePackingChart.seriesType = SeriesTypeEnum.circlePacking, CirclePackingChart.transformerConstructor = CirclePackingChartSpecTransformer;
var registerCirclePackingChart = () => {
  registerCirclePackingSeries(), Factory2.registerChart(CirclePackingChart.type, CirclePackingChart);
};

// node_modules/@visactor/vchart/esm/chart/treemap/treemap-transformer.js
var TreemapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "aspectRatio", "splitType", "maxDepth", "gapWidth", "nodePadding", "minVisibleArea", "minChildrenVisibleArea", "minChildrenVisibleSize", "roam", "drill", "drillField", "leaf", "nonLeaf", "nonLeafLabel"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/treemap/treemap.js
var TreemapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = TreemapChartSpecTransformer, this.type = "treemap", this.seriesType = SeriesTypeEnum.treemap;
  }
};
TreemapChart.type = "treemap", TreemapChart.seriesType = SeriesTypeEnum.treemap, TreemapChart.transformerConstructor = TreemapChartSpecTransformer;
var registerTreemapChart = () => {
  registerTreemapSeries(), Factory2.registerChart(TreemapChart.type, TreemapChart);
};

// node_modules/@visactor/vchart/esm/chart/waterfall/waterfall-transformer.js
var WaterfallChartSpecTransformer = class extends BarChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.legends && array(spec.legends).forEach((l) => {
      l.select = false, l.hover = false, l.filter = false;
    }), setDefaultCrosshairForCartesianChart(spec);
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.bar = spec.bar, series2.stackLabel = spec.stackLabel, series2.leaderLine = spec.leaderLine, series2.total = spec.total, series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/waterfall/waterfall.js
var WaterfallChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WaterfallChartSpecTransformer, this.type = "waterfall", this.seriesType = SeriesTypeEnum.waterfall;
  }
};
WaterfallChart.type = "waterfall", WaterfallChart.seriesType = SeriesTypeEnum.waterfall, WaterfallChart.transformerConstructor = WaterfallChartSpecTransformer;
var registerWaterfallChart = () => {
  registerWaterfallSeries(), Factory2.registerChart(WaterfallChart.type, WaterfallChart);
};

// node_modules/@visactor/vchart/esm/chart/box-plot/box-plot-transformer.js
var BoxPlotChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    const dataFields = [spec.maxField, spec.medianField, spec.q1Field, spec.q3Field, spec.minField, spec.outliersField], seriesSpec = super._getDefaultSeriesSpec(spec, ["boxPlot", "minField", "maxField", "q1Field", "medianField", "q3Field", "outliersField", "outliersStyle"]);
    return seriesSpec.direction = null !== (_a = spec.direction) && void 0 !== _a ? _a : "vertical", seriesSpec["horizontal" === seriesSpec.direction ? "xField" : "yField"] = dataFields, seriesSpec;
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes || (spec.axes = [{
      orient: "bottom"
    }, {
      orient: "left"
    }]), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/box-plot/box-plot.js
var BoxPlotChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BoxPlotChartSpecTransformer, this.type = "boxPlot", this.seriesType = SeriesTypeEnum.boxPlot;
  }
};
BoxPlotChart.type = "boxPlot", BoxPlotChart.seriesType = SeriesTypeEnum.boxPlot, BoxPlotChart.transformerConstructor = BoxPlotChartSpecTransformer;
var registerBoxplotChart = () => {
  registerBoxplotSeries(), Factory2.registerChart(BoxPlotChart.type, BoxPlotChart);
};

// node_modules/@visactor/vchart/esm/chart/sankey/sankey-transformer.js
var SankeyChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "sourceField", "targetField", "direction", "nodeAlign", "crossNodeAlign", "nodeGap", "nodeWidth", "linkWidth", "minStepWidth", "minNodeHeight", "maxNodeHeight", "minLinkHeight", "maxLinkHeight", "dropIsolatedNode", "nodeHeight", "linkHeight", "equalNodeHeight", "linkOverlap", "iterations", "nodeKey", "linkSortBy", "nodeSortBy", "setNodeLayer", "node", "link", "emphasis", "inverse", "overflow"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/sankey/sankey.js
var SankeyChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SankeyChartSpecTransformer, this.type = "sankey", this.seriesType = SeriesTypeEnum.sankey;
  }
  _setStateInDatum(stateKey, checkReverse, datum, filter2, region) {
    const activeDatum = isArray_default(datum) ? datum[0] : datum;
    this.filterGraphicsByDatum(activeDatum, {
      filter: (series2, mark) => "text" !== mark.type && mark.getProduct() && (!filter2 || filter2(series2, mark)),
      region,
      getDatum: (e) => {
        var _a;
        let d = null === (_a = e.getDatum()) || void 0 === _a ? void 0 : _a.datum;
        return isArray_default(d) && (d = d[0]), d;
      },
      callback: (element, mark, s2, r) => {
        var _a, _b, _c;
        const id = null === (_a = mark.getProduct()) || void 0 === _a ? void 0 : _a.id();
        id && (id.includes("node") || id.includes("link")) && (null === (_c = (_b = s2)._handleEmphasisElement) || void 0 === _c || _c.call(_b, {
          item: element
        }));
      },
      regionCallback: (elements, r) => {
        activeDatum ? elements.length && (elements.forEach((e) => {
          r.interaction.startInteraction(stateKey, e);
        }), checkReverse && r.interaction.reverseEventElement(stateKey)) : r.interaction.clearEventElement(stateKey, true);
      }
    });
  }
};
SankeyChart.type = "sankey", SankeyChart.seriesType = SeriesTypeEnum.sankey, SankeyChart.transformerConstructor = SankeyChartSpecTransformer;
var registerSankeyChart = () => {
  loadScrollbar(), registerSankeySeries(), Factory2.registerChart(SankeyChart.type, SankeyChart);
};

// node_modules/@visactor/vchart/esm/chart/range-area/range-area-transformer.js
var RangeAreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return series2.area = spec.area, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2.stack = false, series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/range-area/range-area.js
var RangeAreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeAreaChartSpecTransformer, this.type = "rangeArea", this.seriesType = SeriesTypeEnum.rangeArea;
  }
};
RangeAreaChart.type = "rangeArea", RangeAreaChart.seriesType = SeriesTypeEnum.rangeArea, RangeAreaChart.transformerConstructor = RangeAreaChartSpecTransformer;
var registerRangeAreaChart = () => {
  registerRangeAreaSeries(), Factory2.registerChart(RangeAreaChart.type, RangeAreaChart);
};

// node_modules/@visactor/vchart/esm/chart/heatmap/heatmap-transformer.js
var HeatmapChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["valueField", "cell"]);
  }
};

// node_modules/@visactor/vchart/esm/chart/heatmap/heatmap.js
var HeatmapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HeatmapChartSpecTransformer, this.type = "heatmap", this.seriesType = SeriesTypeEnum.heatmap;
  }
};
HeatmapChart.type = "heatmap", HeatmapChart.seriesType = SeriesTypeEnum.heatmap, HeatmapChart.transformerConstructor = HeatmapChartSpecTransformer;
var registerHeatmapChart = () => {
  registerHeatmapSeries(), Factory2.registerChart(HeatmapChart.type, HeatmapChart);
};

// node_modules/@visactor/vchart/esm/chart/correlation/correlation-transformer.js
var CorrelationChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "sizeField", "sizeRange", "centerX", "centerY", "innerRadius", "outerRadius", "startAngle", "endAngle", "ripplePoint", "centerPoint", "centerLabel", "nodePoint"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/correlation/correlation.js
var CorrelationChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CorrelationChartSpecTransformer, this.type = "correlation", this.seriesType = SeriesTypeEnum.correlation;
  }
};
CorrelationChart.type = "correlation", CorrelationChart.seriesType = SeriesTypeEnum.correlation, CorrelationChart.transformerConstructor = CorrelationChartSpecTransformer;
var registerCorrelationChart = () => {
  registerCorrelationSeries(), Factory2.registerChart(CorrelationChart.type, CorrelationChart);
};

// node_modules/@visactor/vchart/esm/component/legend/util.js
function transformLegendTitleAttributes(title3) {
  var _a, _b;
  const transformedTitle = Object.assign({}, title3);
  return isEmpty_default(title3.style) || (transformedTitle.textStyle = transformToGraphic(title3.style)), isEmpty_default(title3.textStyle) || mergeSpec(transformedTitle.textStyle, transformToGraphic(title3.textStyle)), (null === (_a = title3.shape) || void 0 === _a ? void 0 : _a.style) && transformToGraphic(transformedTitle.shape.style), (null === (_b = title3.background) || void 0 === _b ? void 0 : _b.style) && transformToGraphic(transformedTitle.background.style), transformedTitle;
}

// node_modules/@visactor/vchart/esm/component/legend/discrete/util.js
var __rest26 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function getLegendAttributes(spec, rect) {
  const { title: title3 = {}, item = {}, pager = {}, background = {}, type, id, visible, orient, position, data, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = spec, attrs = __rest26(spec, ["title", "item", "pager", "background", "type", "id", "visible", "orient", "position", "data", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible ? attrs.title = transformLegendTitleAttributes(title3) : attrs.title = {
    visible: false
  }, isEmpty_default(item.focusIconStyle) || transformToGraphic(item.focusIconStyle), item.shape && (item.shape = transformComponentStyle(item.shape)), item.label && (item.label = transformComponentStyle(item.label)), item.value && (item.value = transformComponentStyle(item.value)), item.background && (item.background = transformComponentStyle(item.background)), isPercent(item.maxWidth) && (item.maxWidth = Number(item.maxWidth.substring(0, item.maxWidth.length - 1)) * rect.width / 100), isPercent(item.width) && (item.width = Number(item.width.substring(0, item.width.length - 1)) * rect.width / 100), isPercent(item.height) && (item.height = Number(item.height.substring(0, item.height.length - 1)) * rect.width / 100), attrs.item = item, "scrollbar" === pager.type ? (isEmpty_default(pager.railStyle) || transformToGraphic(pager.railStyle), isEmpty_default(pager.sliderStyle) || transformToGraphic(pager.sliderStyle)) : (isEmpty_default(pager.textStyle) || transformToGraphic(pager.textStyle), pager.handler && transformComponentStyle(pager.handler)), attrs.pager = pager, background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}

// node_modules/@visactor/vchart/esm/data/transforms/legend-data/discrete/discrete.js
var discreteLegendDataMake = (data, op) => {
  const result2 = [], tempKey = {}, { series: series2, seriesField } = op;
  return series2().forEach((s2) => {
    const field5 = seriesField(s2);
    let infoList;
    infoList = field5 === s2.getSeriesField() ? s2.getSeriesInfoList() : s2.getSeriesInfoInField(field5), infoList.forEach((info) => {
      tempKey[info.key] || (tempKey[info.key] = true, result2.push(info));
    });
  }), result2;
};
var discreteLegendFilter = (data, op) => {
  var _a, _b, _c;
  const { series: series2, selected, field: field5, data: legendData, customFilter } = op, selectedData = selected(), legendKeys = legendData();
  if (0 === selectedData.length && legendKeys.length) return [];
  if (selectedData.length === legendKeys.length) return data;
  const selectedFilter = {};
  selectedData.forEach((s2) => {
    selectedFilter[s2] = true;
  });
  const datumField = null !== (_a = field5()) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD;
  return customFilter ? customFilter(data, selectedData, datumField) : (isArray_default(data) && (null === (_b = data[0]) || void 0 === _b ? void 0 : _b.nodes) ? (data[0].nodes = data[0].nodes.filter((d) => true === selectedFilter[d.key]), (null === (_c = data[0]) || void 0 === _c ? void 0 : _c.links) && (data[0].links = data[0].links.filter((d) => true === selectedFilter[d.source] && true === selectedFilter[d.target]))) : isValid_default(datumField) && (data = data.filter((d) => true === selectedFilter[series2.getSeriesFieldValue(d, datumField)])), data);
};

// node_modules/@visactor/vchart/esm/component/legend/base-legend.js
var BaseLegend = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Legend, this.layoutLevel = LayoutLevel.Legend, this.specKey = "legends", this._orient = "left", this._visible = true, this._position = "middle", this._preSelectedData = [], this._selectedData = [], this.effect = {
      onSelectedDataChange: () => {
        eachSeries(this._regions, (s2) => {
          var _a;
          null === (_a = s2.getViewData()) || void 0 === _a || _a.markRunning();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }), eachSeries(this._regions, (s2) => {
          s2.reFilterViewData();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  get orient() {
    return this._orient;
  }
  get visible() {
    return this._visible;
  }
  get position() {
    return this._position;
  }
  getLegendData() {
    return this._legendData.getLatestData();
  }
  getSelectedData() {
    return this._selectedData;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._orient = isValidOrient(this._spec.orient) ? this._spec.orient : "left", this._position = null !== (_a = this._spec.position) && void 0 !== _a ? _a : "middle", this._visible = false !== this._spec.visible;
    const { regionId, regionIndex, seriesId, seriesIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionUserIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionUserIndex);
  }
  created() {
    super.created(), this.initData();
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, (null == spec ? void 0 : spec.orient) !== (null == prevSpec ? void 0 : prevSpec.orient) ? (result2.reMake = true, result2) : (isEqual(prevSpec, spec) || (result2.reCompile = true), result2);
  }
  changeRegions(regions) {
  }
  _bindLegendDataChange() {
    this._preSelectedData = this._selectedData.slice(), this._initSelectedData();
  }
  initData() {
    const legendData = this._initLegendData();
    legendData.target.addListener("change", this._bindLegendDataChange.bind(this)), this._legendData = new CompilableData(this._option, legendData), this._initSelectedData(), eachSeries(this._regions, (s2) => {
      s2.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
      }, () => {
        this._legendData.getDataView().reRunAllTransform();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  setSelectedData(selectedData) {
    var _a, _b, _c;
    const lastData = this._selectedData;
    isNil_default(selectedData) || JSON.stringify(lastData) === JSON.stringify(selectedData) || (eachSeries(this._regions, (s2) => {
      s2.legendSelectedFilter && (selectedData = s2.legendSelectedFilter(this, selectedData));
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), this._selectedData = [...selectedData], null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), this.event.emit(ChartEvent.legendSelectedDataChange, {
      model: this
    }), null === (_c = this._legendComponent) || void 0 === _c || _c.setSelected(this._selectedData));
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), this._legendComponent) {
      const { x, y } = pos;
      isValidNumber_default(x * y) && this._legendComponent.setAttributes({
        x,
        y
      });
    }
  }
  getBoundsInRect(rect, fullSpace) {
    if (!this._visible) return this._legendComponent && this._legendComponent.parent && (this._legendComponent.parent.removeChild(this._legendComponent), this._legendComponent = null), {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    }, attrs = this._getLegendAttributes(rect);
    if (attrs.disableTriggerEvent = this._option.disableTriggerEvent, this._legendComponent) isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
      defaultSelected: this._selectedData
    }));
    else {
      const legend = new (this._getLegendConstructor())(mergeSpec({}, attrs, {
        defaultSelected: this._selectedData
      }));
      legend.name = "legend", this._legendComponent = legend;
      this.getContainer().add(legend), this._option.disableTriggerEvent || this._initEvent(), legend.on("*", (event, type) => this._delegateEvent(this._legendComponent, event, type));
    }
    this._cacheAttrs = attrs;
    const width = isFinite(this._legendComponent.AABBBounds.width()) ? this._legendComponent.AABBBounds.width() : 0, height = isFinite(this._legendComponent.AABBBounds.height()) ? this._legendComponent.AABBBounds.height() : 0;
    if ("normal-inline" !== this.layoutType) {
      const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", position = this._position, { width: rectWidth, height: rectHeight } = fullSpace;
      let offsetX = 0, offsetY = 0;
      "horizontal" === layout2 ? "middle" === position ? offsetX = (rectWidth - width) / 2 : "end" === position && (offsetX = rectWidth - width) : "middle" === position ? offsetY = (rectHeight - height) / 2 : "end" === position && (offsetY = rectHeight - height), this._legendComponent.setAttributes({
        dx: offsetX,
        dy: offsetY
      });
    }
    return result2.x2 = result2.x1 + width, result2.y2 = result2.y1 + height, result2;
  }
  onDataUpdate() {
    var _a, _b, _c;
    if (JSON.stringify(this._preSelectedData) !== JSON.stringify(this._selectedData)) {
      if (this._legendComponent) {
        const attrs = this._getLegendAttributes(this.getLayoutRect());
        isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
          defaultSelected: this._selectedData
        }));
      }
      null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), null === (_c = this.getChart()) || void 0 === _c || _c.setLayoutTag(true, null, false), this.event.emit(ChartEvent.legendSelectedDataChange, {
        model: this
      });
    }
  }
  _getNeedClearVRenderComponents() {
    return [this._legendComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null, this._preSelectedData = null;
  }
};
BaseLegend.specKey = "legends";

// node_modules/@visactor/vchart/esm/component/legend/discrete/legend.js
var DiscreteLegend2 = class extends BaseLegend {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.discreteLegend, this.name = ComponentTypeEnum.discreteLegend;
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => !s2.type || "discrete" === s2.type);
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s2) => {
      s2.addViewDataFilter({
        type: "discreteLegendFilter",
        options: {
          series: s2,
          selected: () => this._selectedData,
          field: () => this._getSeriesLegendField(s2),
          data: () => this.getLegendDefaultData(),
          customFilter: this._spec.customFilter
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendFilter", discreteLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendDataMake", discreteLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "discreteLegendDataMake",
      options: {
        series: () => {
          const result2 = [];
          return eachSeries(this._regions, (s2) => {
            result2.push(s2);
          }, {
            specIndex: this._spec.seriesIndex,
            userId: this._spec.seriesId
          }), result2;
        },
        seriesField: (s2) => this._getSeriesLegendField(s2)
      }
    }), legendData;
  }
  _getSeriesLegendField(s2) {
    var _a, _b, _c;
    const defaultField = s2.getSeriesField(), specifyScaleId = null !== (_a = this._spec.scaleName) && void 0 !== _a ? _a : this._spec.scale;
    if (isNil_default(specifyScaleId)) return defaultField;
    if (!s2.getRawData()) return defaultField;
    const scaleSpec = this._option.globalScale.getScaleSpec(specifyScaleId);
    if (!scaleSpec) return defaultField;
    if (this._spec.field) return this._spec.field;
    if (!isDataDomainSpec(scaleSpec.domain)) return defaultField;
    const seriesData = scaleSpec.domain.find((d) => d.dataId === s2.getRawData().name);
    return seriesData && null !== (_c = null === (_b = seriesData.fields) || void 0 === _b ? void 0 : _b[0]) && void 0 !== _c ? _c : defaultField;
  }
  _initSelectedData() {
    const fullSelectedData = this.getLegendDefaultData();
    if (this._unselectedData) {
      const selected = [], unselected = [];
      fullSelectedData.forEach((entry) => {
        this._unselectedData.includes(entry) ? unselected.push(entry) : selected.push(entry);
      }), this._selectedData = selected, this._unselectedData = unselected;
    } else this._spec.defaultSelected ? this._selectedData = [...this._spec.defaultSelected] : this._selectedData = fullSelectedData;
  }
  getLegendDefaultData(originalData) {
    return isFunction_default(this._spec.data) ? this._getLegendItems().map((obj) => obj.label) : this._legendData.getLatestData().map(originalData ? (obj) => obj.originalKey : (obj) => obj.key);
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
      if (!series2) return;
      attrs.title.text = getFieldAlias(series2.getRawData(), series2.getSeriesField());
    }
  }
  _getLegendAttributes(rect) {
    const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", attrs = Object.assign(Object.assign({
      layout: layout2,
      items: this._getLegendItems(),
      zIndex: this.layoutZIndex
    }, getLegendAttributes(this._spec, rect)), {
      maxWidth: rect.width,
      maxHeight: rect.height
    });
    return this._addDefaultTitleText(attrs), this._addLegendItemFormatMethods(attrs), attrs;
  }
  _getLegendConstructor() {
    return DiscreteLegend;
  }
  setSelectedData(selectedData) {
    selectedData && (this._unselectedData = this.getLegendDefaultData().filter((entry) => !selectedData.includes(entry))), super.setSelectedData(selectedData);
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener(LegendEvent.legendItemClick, (e) => {
        const selectedData = get_default(e, "detail.currentSelected");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendItemClick, {
          model: this,
          value: selectedData,
          event: e
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemHover, (e) => {
        const detail = get_default(e, "detail");
        this.event.emit(ChartEvent.legendItemHover, {
          model: this,
          value: detail,
          event: e
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemUnHover, (e) => {
        const detail = get_default(e, "detail");
        this.event.emit(ChartEvent.legendItemUnHover, {
          model: this,
          value: detail,
          event: e
        });
      });
    }
  }
  _getLegendItems() {
    const originData = (this._legendData.getLatestData() || []).map((datum) => {
      var _a, _b;
      const fillOpacity = datum.style("fillOpacity"), strokeOpacity = datum.style("strokeOpacity"), opacity = datum.style("opacity"), texture = datum.style("texture");
      return {
        label: datum.key,
        shape: {
          symbolType: null !== (_b = null !== (_a = datum.style("symbolType")) && void 0 !== _a ? _a : datum.shapeType) && void 0 !== _b ? _b : "circle",
          fillOpacity: isValidNumber_default(fillOpacity) ? fillOpacity : 1,
          strokeOpacity: isValidNumber_default(strokeOpacity) ? strokeOpacity : 1,
          opacity: isValidNumber_default(opacity) ? opacity : 1,
          texturePadding: texture ? 1 : null,
          textureSize: texture ? 4 : null,
          texture,
          fill: datum.style("fill"),
          stroke: datum.style("stroke"),
          textureColor: datum.style("textureColor"),
          innerBorder: datum.style("innerBorder"),
          outerBorder: datum.style("outerBorder"),
          lineDash: datum.style("lineDash"),
          lineDashOffset: datum.style("lineDashOffset"),
          lineWidth: datum.style("lineWidth")
        }
      };
    });
    return isFunction_default(this._spec.data) ? this._spec.data(originData, this._option.globalScale.getScale("color"), this._option.globalScale) : originData;
  }
  _addLegendItemFormatMethods(attrs) {
    var _a, _b, _c, _d;
    const { formatMethod: labelFormatMethod, formatter: labelFormatter } = null !== (_b = null === (_a = this._spec.item) || void 0 === _a ? void 0 : _a.label) && void 0 !== _b ? _b : {}, { formatMethod: valueFormatMethod, formatter: valueFormatter } = null !== (_d = null === (_c = this._spec.item) || void 0 === _c ? void 0 : _c.value) && void 0 !== _d ? _d : {}, { formatFunc: labelFormatFunc } = getFormatFunction(labelFormatMethod, labelFormatter);
    labelFormatter && !labelFormatMethod && labelFormatFunc && (attrs.item.label.formatMethod = (value, datum) => labelFormatFunc(value, datum, labelFormatter));
    const { formatFunc: valueFormatFunc } = getFormatFunction(valueFormatMethod, valueFormatter);
    valueFormatter && !valueFormatMethod && valueFormatFunc && (attrs.item.value.formatMethod = (value, datum) => valueFormatFunc(valueFormatter, value, datum, labelFormatter));
  }
};
DiscreteLegend2.specKey = "legends", DiscreteLegend2.type = ComponentTypeEnum.discreteLegend;
var registerDiscreteLegend = () => {
  Factory2.registerComponent(DiscreteLegend2.type, DiscreteLegend2);
};

// node_modules/@visactor/vchart/esm/data/transforms/legend-data/continuous/continuous.js
var continuousLegendDataMake = (data, op) => {
  const { series: series2, field: field5, scale: scale4 } = op, datumField = field5();
  if (field5 && datumField) {
    let min3 = 1 / 0, max3 = -1 / 0;
    return series2().forEach((s2) => {
      const statisticData = s2.getRawDataStatisticsByField(datumField, true), seriesMin = null == statisticData ? void 0 : statisticData.min, seriesMax = null == statisticData ? void 0 : statisticData.max;
      isValidNumber_default(seriesMin) && (min3 = Math.min(seriesMin, min3)), isValidNumber_default(seriesMax) && (max3 = Math.max(seriesMax, max3));
    }), [min3, max3];
  }
  if (scale4) {
    const _scale = scale4();
    return _scale ? _scale.domain() : [];
  }
  return [];
};
var continuousLegendFilter = (data, op) => {
  const { selected, field: field5, data: legendData, isHierarchyData, customFilter } = op, selectedRange = selected(), datumField = field5(), isHierarchy = isHierarchyData || ((data2) => data2 && data2.some((d) => d && isHierarchyItem(d)));
  if (selectedRange === legendData()) return data;
  if (datumField && !isEmpty_default(selectedRange)) {
    const [min3, max3] = selectedRange;
    return customFilter ? customFilter(data, selectedRange, datumField) : isHierarchy(data) ? filterHierarchyDataByRange(data, +min3, +max3, datumField) : data.filter((datum) => datum[datumField] >= min3 && datum[datumField] <= max3);
  }
  return data;
};

// node_modules/@visactor/vchart/esm/component/legend/continuous/util.js
var __rest27 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function getContinuousLegendAttributes(spec) {
  const _a = mergeSpec({}, spec), { title: title3 = {}, handler = {}, rail = {}, track = {}, startText, endText, handlerText, sizeBackground, background = {}, type, id, visible, orient, position, data, defaultSelected, field: field5, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = _a, attrs = __rest27(_a, ["title", "handler", "rail", "track", "startText", "endText", "handlerText", "sizeBackground", "background", "type", "id", "visible", "orient", "position", "data", "defaultSelected", "field", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible ? attrs.title = transformLegendTitleAttributes(title3) : attrs.title = {
    visible: false
  }, attrs.showHandler = false !== handler.visible, isEmpty_default(handler.style) || (attrs.handlerStyle = transformToGraphic(handler.style)), isValid_default(rail.width) && (attrs.railWidth = rail.width), isValid_default(rail.height) && (attrs.railHeight = rail.height), isEmpty_default(rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(track.style) || (attrs.trackStyle = transformToGraphic(track.style)), attrs.startText = transformComponentStyle(startText), attrs.endText = transformComponentStyle(endText), attrs.handlerText = transformComponentStyle(handlerText), isEmpty_default(sizeBackground) || (attrs.sizeBackground = transformToGraphic(sizeBackground)), background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}
function isContinuousLegend(type) {
  return "color" === type || "size" === type;
}
var ContinuousLegendMap = {
  color: ColorContinuousLegend,
  size: SizeContinuousLegend
};

// node_modules/@visactor/vchart/esm/component/legend/continuous/legend.js
var SINGLE_SEQUENCE = ["#C4E7FF", "#98CAFF", "#75ACFF", "#518FF9", "#2775DC", "#005CBE", "#00429F", "#00287E"];
var SIZE = [2, 10];
var ContinuousLegend = class extends BaseLegend {
  static getSpecInfo(chartSpec) {
    const infos = getSpecInfo(chartSpec, this.specKey, this.type, (s2) => isContinuousLegend(s2.type));
    return infos && infos.forEach((info) => {
      info.type = "color" === info.spec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend;
    }), infos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.colorLegend, this.name = ComponentTypeEnum.colorLegend;
    const legendName = "color" === this._spec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend;
    this.type = legendName, this.name = legendName;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._field = this._spec.field, this._legendType = this._spec.type;
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s2) => {
      s2.addViewDataFilter({
        type: "continuousLegendFilter",
        options: {
          selected: () => this._selectedData,
          field: () => this._field,
          data: () => this._legendData.getLatestData(),
          isHierarchyData: s2.isHierarchyData,
          customFilter: this._spec.customFilter
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _getScaleInGlobal() {
    const globalScale = this._option.globalScale;
    let scaleKey = this._spec.scale;
    return scaleKey || (scaleKey = this._legendType), globalScale.getScale(scaleKey);
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendFilter", continuousLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendDataMake", continuousLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "continuousLegendDataMake",
      options: {
        series: () => getSeries(this._regions, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }),
        field: () => this._field,
        scale: this._getScaleInGlobal.bind(this)
      }
    }), legendData;
  }
  _initSelectedData() {
    this._spec.defaultSelected ? this._selectedData = this._spec.defaultSelected.slice() : this._selectedData = this._legendData.getLatestData();
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const field5 = this._field;
      if (field5) {
        const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
        if (!series2) return;
        return void (attrs.title.text = getFieldAlias(series2.getRawData(), field5));
      }
      let scaleKey = this._spec.scale;
      scaleKey || (scaleKey = this._legendType);
      const scaleSpec = this._option.globalScale.getScaleSpec(scaleKey);
      if (!isDataDomainSpec(null == scaleSpec ? void 0 : scaleSpec.domain)) return;
      const dataInfo = scaleSpec.domain[0];
      if (0 === dataInfo.fields.length) return;
      attrs.title.text = getFieldAlias(this._option.dataSet.getDataView(dataInfo.dataId), dataInfo.fields[0]);
    } else ;
  }
  _getLegendAttributes(rect) {
    var _a, _b;
    const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", align = "horizontal" === layout2 ? "bottom" : this.layoutOrient;
    let visualMappingRange = [];
    const scale4 = this._getScaleInGlobal();
    scale4 && "linear" === scale4.type && (visualMappingRange = scale4.range()), isEmpty_default(visualMappingRange) && (visualMappingRange = "color" === this._legendType ? SINGLE_SEQUENCE : SIZE);
    let min3 = null !== (_a = this._legendData.getLatestData()[0]) && void 0 !== _a ? _a : 0, max3 = null !== (_b = this._legendData.getLatestData()[1]) && void 0 !== _b ? _b : 1;
    this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] && (min3 = Math.min(0, this._legendData.getLatestData()[0]), max3 = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0]));
    const attrs = Object.assign({
      layout: layout2,
      align,
      zIndex: this.layoutZIndex,
      min: min3,
      max: max3,
      value: this._spec.defaultSelected,
      ["color" === this._legendType ? "colors" : "sizeRange"]: visualMappingRange
    }, getContinuousLegendAttributes(this._spec));
    return this._addDefaultTitleText(attrs), attrs;
  }
  _getLegendConstructor() {
    return ContinuousLegendMap[this._legendType];
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener("change", debounce_default((e) => {
        const selectedData = get_default(e, "detail.value");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendFilter, {
          model: this,
          value: selectedData,
          event: e
        });
      }, 30));
    }
  }
};
ContinuousLegend.specKey = "legends", ContinuousLegend.type = ComponentTypeEnum.continuousLegend;
var registerContinuousLegend = () => {
  Factory2.registerComponent(ContinuousLegend.type, ContinuousLegend);
};

// node_modules/@visactor/vchart/esm/component/tooltip/utils/show-tooltip.js
var getDataArrayFromFieldArray = (fields2, datum) => isValid_default(datum) ? fields2.map((f) => datum[f]) : void 0;
var datumContainsArray = (fields2, data) => (datum) => fields2.every((key, i) => datum[key] === (null == data ? void 0 : data[i]));
var hasData = (data) => !isNil_default(data) && (isArray_default(data) ? data.length > 0 && data.every(isValid_default) : Object.keys(data).length > 0);
function showTooltip(datum, options, component2) {
  var _a, _b, _c;
  const opt = Object.assign({
    regionIndex: 0
  }, options), componentOptions = component2.getOption(), region = componentOptions.getRegionsInUserIdOrIndex(isValid_default(opt.regionId) ? [opt.regionId] : void 0, isValid_default(opt.regionIndex) ? [opt.regionIndex] : void 0)[0];
  if (!region) return "none";
  const markInfoList = getMarkInfoList(datum, region), activeType = null !== (_a = opt.activeType) && void 0 !== _a ? _a : markInfoList.length > 1 ? "dimension" : "mark", regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect(), container2 = componentOptions.globalInstance.getContainer(), containerPos = Object.assign({
    x: 0,
    y: 0
  }, container2 ? getElementAbsolutePosition(container2) : {}), getOriginDatum = (info) => {
    var _a2;
    const { dimensionFields, dimensionData, measureFields, measureData, groupField, groupData: groupData2 } = info.data, originDatum = null === (_a2 = info.series.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.find((datum2) => datumContainsArray(dimensionFields, dimensionData)(datum2) && datumContainsArray(measureFields, measureData)(datum2) && (isNil_default(groupField) || datumContainsArray([groupField], [groupData2])(datum2)));
    return originDatum;
  }, getMockEvent = (originPos) => {
    var _a2, _b2;
    const pos = ((pos2) => ({
      x: Math.min(Math.max(pos2.x, 0), regionRect.width),
      y: Math.min(Math.max(pos2.y, 0), regionRect.height)
    }))(originPos), canvasX = null !== (_a2 = opt.x) && void 0 !== _a2 ? _a2 : regionPos.x + pos.x, canvasY = null !== (_b2 = opt.y) && void 0 !== _b2 ? _b2 : regionPos.y + pos.y;
    return {
      canvasX,
      canvasY,
      clientX: containerPos.x + canvasX,
      clientY: containerPos.y + canvasY
    };
  };
  if ("dimension" === activeType) {
    const firstInfo = markInfoList[0];
    if (!firstInfo) return "none";
    const markInfoSeriesMap = /* @__PURE__ */ new Map();
    markInfoList.forEach((info) => {
      var _a2;
      markInfoSeriesMap.has(info.series) || markInfoSeriesMap.set(info.series, []), null === (_a2 = markInfoSeriesMap.get(info.series)) || void 0 === _a2 || _a2.push(info);
    });
    const mockDimensionInfo = [{
      value: datum[firstInfo.data.dimensionFields[0]],
      data: [...markInfoSeriesMap.keys()].map((series2) => {
        var _a2, _b2;
        return {
          series: series2,
          datum: null !== (_b2 = null === (_a2 = markInfoSeriesMap.get(series2)) || void 0 === _a2 ? void 0 : _a2.map((info) => getOriginDatum(info))) && void 0 !== _b2 ? _b2 : []
        };
      })
    }];
    isValid_default(firstInfo.dimType) && (mockDimensionInfo[0].position = firstInfo.pos[firstInfo.dimType], mockDimensionInfo[0].dimType = firstInfo.dimType);
    const mockParams = {
      changePositionOnly: false,
      action: "enter",
      tooltip: null,
      dimensionInfo: mockDimensionInfo,
      chart: null !== (_b = componentOptions.globalInstance.getChart()) && void 0 !== _b ? _b : void 0,
      datum: void 0,
      model: void 0,
      source: Event_Source_Type.chart,
      event: getMockEvent({
        x: markInfoList.reduce((sum3, info) => sum3 + info.pos.x, 0) / markInfoList.length,
        y: markInfoList.reduce((sum3, info) => sum3 + info.pos.y, 0) / markInfoList.length
      }),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    component2.processor.dimension.showTooltip(mockDimensionInfo, mockParams, false);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  if ("mark" === activeType) {
    const info = markInfoList[0];
    if (!info) return "none";
    const mockDatum = Object.assign(Object.assign({}, getOriginDatum(info)), datum), mockDimensionData = [{
      datum: [mockDatum],
      series: info.series
    }], mockParams = {
      changePositionOnly: false,
      tooltip: null,
      dimensionInfo: [{
        value: mockDatum[info.data.dimensionFields[0]],
        data: mockDimensionData
      }],
      chart: null !== (_c = componentOptions.globalInstance.getChart()) && void 0 !== _c ? _c : void 0,
      datum: mockDatum,
      model: info.series,
      source: Event_Source_Type.chart,
      event: getMockEvent(info.pos),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    component2.processor.mark.showTooltip({
      datum: mockDatum,
      mark: null,
      series: info.series
    }, mockParams, false);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  return "none";
}
var getMarkInfoList = (datum, region) => {
  const seriesList = region.getSeries(), markInfoList = [];
  return seriesList.forEach((series2) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const dimensionFields = series2.getDimensionField(), measureFields = series2.getMeasureField(), groupField = series2.getSeriesField(), groupData2 = isValid_default(groupField) ? datum[groupField] : void 0, groupDomain = isValid_default(groupField) && null !== (_d = null === (_c = null === (_b = null === (_a = series2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(series2)) || void 0 === _b ? void 0 : _b.latestData[groupField]) || void 0 === _c ? void 0 : _c.values) && void 0 !== _d ? _d : [], dimensionData = getDataArrayFromFieldArray(dimensionFields, datum);
    let measureData = getDataArrayFromFieldArray(measureFields, datum);
    const hasMeasureData = hasData(measureData), isMultiGroups = !hasMeasureData && isValid_default(groupField) && isNil_default(groupData2) && groupDomain.length > 0, parseMarkInfoOfSimpleSeries = () => {
      var _a2;
      const originDatum = null === (_a2 = series2.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.find(datumContainsArray(dimensionFields, dimensionData));
      if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
      const pos = series2.type === SeriesTypeEnum.pie ? series2.dataToCentralPosition(originDatum) : series2.dataToPosition(originDatum);
      isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
        pos,
        data: {
          dimensionFields,
          dimensionData,
          measureFields,
          measureData,
          hasMeasureData,
          groupField,
          groupData: groupData2
        },
        series: series2
      });
    };
    if ("cartesian" === series2.coordinate) {
      const cartesianSeries = series2, dimType = isDiscrete(null === (_f = null === (_e = series2.getYAxisHelper()) || void 0 === _e ? void 0 : _e.getScale(0)) || void 0 === _f ? void 0 : _f.type) ? "y" : "x", invalidDimensionFields = dimensionFields.map((field5, i) => [field5, i]).filter(([, i]) => isNil_default(null == dimensionData ? void 0 : dimensionData[i]));
      let dimensionDataList = [null != dimensionData ? dimensionData : []];
      invalidDimensionFields.length > 0 && invalidDimensionFields.forEach(([field5, i]) => {
        var _a2, _b2, _c2, _d2;
        const domain = null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = series2.getViewDataStatistics) || void 0 === _a2 ? void 0 : _a2.call(series2)) || void 0 === _b2 ? void 0 : _b2.latestData[field5]) || void 0 === _c2 ? void 0 : _c2.values) && void 0 !== _d2 ? _d2 : [], nextList = [];
        dimensionDataList.forEach((dimensionData2) => {
          domain.forEach((value) => {
            var _a3;
            const newData = null !== (_a3 = null == dimensionData2 ? void 0 : dimensionData2.slice()) && void 0 !== _a3 ? _a3 : [];
            newData[i] = value, nextList.push(newData);
          });
        }), dimensionDataList = nextList;
      }), dimensionDataList.forEach((dimensionData2) => {
        var _a2, _b2;
        if (isMultiGroups) {
          const measureDataList = null === (_a2 = cartesianSeries.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.filter(datumContainsArray(dimensionFields, dimensionData2));
          groupDomain.forEach((groupData3) => {
            const originDatum = measureDataList.find((d) => d[groupField] === groupData3);
            if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)) return;
            const pos = cartesianSeries.dataToPosition(originDatum);
            isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
              pos,
              data: {
                dimensionFields,
                dimensionData: dimensionData2,
                measureFields,
                measureData,
                hasMeasureData,
                groupField,
                groupData: groupData3
              },
              series: series2,
              dimType
            });
          });
        } else {
          const originDatum = null === (_b2 = cartesianSeries.getViewData()) || void 0 === _b2 ? void 0 : _b2.latestData.find(datumContainsArray(dimensionFields, dimensionData2));
          if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
          const pos = cartesianSeries.dataToPosition(originDatum);
          if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y)) return;
          markInfoList.push({
            pos,
            data: {
              dimensionFields,
              dimensionData: dimensionData2,
              measureFields,
              measureData,
              hasMeasureData,
              groupField,
              groupData: groupData2
            },
            dimType,
            series: series2
          });
        }
      });
    } else if ("polar" === series2.coordinate) if (series2.type === SeriesTypeEnum.pie) parseMarkInfoOfSimpleSeries();
    else {
      const polarSeries = series2;
      if (isMultiGroups) {
        const originDatum = (null === (_g = polarSeries.getViewData()) || void 0 === _g ? void 0 : _g.latestData.filter(datumContainsArray(dimensionFields, dimensionData))).find((d) => d[groupField] === groupData2);
        groupDomain.forEach((groupData3) => {
          if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)) return;
          const pos = polarSeries.dataToPosition(originDatum);
          isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
            pos,
            data: {
              dimensionFields,
              dimensionData,
              measureFields,
              measureData,
              hasMeasureData,
              groupField,
              groupData: groupData3
            },
            series: series2
          });
        });
      } else parseMarkInfoOfSimpleSeries();
    }
    else "geo" === series2.coordinate && parseMarkInfoOfSimpleSeries();
  }), markInfoList;
};

// node_modules/@visactor/vchart/esm/component/tooltip/utils/get-spec.js
var pick_keys = ["updateTitle", "updateContent", "updatePosition", "maxLineCount", "othersLine"];
var getTooltipSpecForShow = (activeType, globalSpec, series2, data, params2) => {
  var _a, _b, _c;
  const finalSpec = {
    activeType
  };
  switch (activeType) {
    case "mark":
    case "group":
      if (series2) {
        const seriesSpec = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.tooltip;
        return finalSpec.visible = true, (null == seriesSpec ? void 0 : seriesSpec.handler) && (finalSpec.handler = seriesSpec.handler), (null === (_b = finalSpec.handler) || void 0 === _b ? void 0 : _b.showTooltip) ? finalSpec : ((null == seriesSpec ? void 0 : seriesSpec[activeType]) && pick_keys.forEach((k2) => {
          isValid_default(seriesSpec[activeType][k2]) && (finalSpec[k2] = seriesSpec[activeType][k2]);
        }), Object.assign(Object.assign({}, finalSpec), series2.tooltipHelper.getTooltipData(activeType, globalSpec, data, data[0].datum, params2)));
      }
      break;
    case "dimension":
      if (null == data ? void 0 : data.length) {
        if (getSeriesListFromDimensionInfo(data).every((series3) => {
          var _a2;
          return !isActiveTypeVisible("dimension", null === (_a2 = series3.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.spec);
        }) ? finalSpec.visible = false : finalSpec.visible = true, finalSpec.handler = globalSpec.handler, null === (_c = finalSpec.handler) || void 0 === _c ? void 0 : _c.showTooltip) return finalSpec;
        const patternList = [];
        return data.forEach((info) => info.data.forEach((datum) => {
          const { series: series3 } = datum, pattern = series3.tooltipHelper.getTooltipData(activeType, globalSpec, data, datum.datum, params2);
          pattern && patternList.push(pattern);
        })), combineContents(patternList);
      }
  }
  return null;
};
var getSeriesListFromDimensionInfo = (dimensionInfo) => {
  const list = [];
  return dimensionInfo.forEach((info) => {
    info.data.forEach((datum) => {
      isValid_default(datum.series) && list.push(datum.series);
    });
  }), list;
};

// node_modules/@visactor/vchart/esm/component/tooltip/constant.js
var TooltipHandlerType = {
  dom: `${PREFIX}_TOOLTIP_HANDLER_DOM`,
  canvas: `${PREFIX}_TOOLTIP_HANDLER_CANVAS`
};
var TOOLTIP_EL_CLASS_NAME = "vchart-tooltip-element";
var TOOLTIP_MAX_LINE_COUNT = 20;
var TOOLTIP_OTHERS_LINE = {
  key: "其他",
  value: "..."
};
var TOOLTIP_TYPES = ["group", "mark", "dimension"];
var DEFAULT_SHOW_DELAY = 50;

// node_modules/@visactor/vchart/esm/component/tooltip/processor/base.js
var BaseTooltipProcessor = class {
  constructor(component2) {
    this._showTooltipByHandler = (data, params2) => {
      var _a, _b, _c;
      if (isNil_default(data)) return 1;
      params2.changePositionOnly || this.clearCache(), this._updateViewSpec(data, params2);
      const spec = this._cacheActiveSpec;
      if (isNil_default(spec) || false === spec.visible) return 1;
      params2.tooltipSpec = this.component.getSpec(), params2.activeTooltipSpec = spec;
      const { title: title3, content } = spec, isEmpty = isNil_default(null == title3 ? void 0 : title3.key) && isNil_default(null == title3 ? void 0 : title3.value) && !(null == content ? void 0 : content.length);
      if (this.component.event.emit(ChartEvent.tooltipShow, Object.assign(Object.assign({}, params2), {
        isEmptyTooltip: isEmpty,
        tooltipData: data,
        activeType: this.activeType,
        tooltip: this.component
      })), isEmpty) return 1;
      let showTooltip2;
      return (null === (_a = spec.handler) || void 0 === _a ? void 0 : _a.showTooltip) ? showTooltip2 = spec.handler.showTooltip.bind(spec.handler) : (null === (_b = this.component.tooltipHandler) || void 0 === _b ? void 0 : _b.showTooltip) && (showTooltip2 = this.component.tooltipHandler.showTooltip.bind(this.component.tooltipHandler)), showTooltip2 ? null !== (_c = showTooltip2(this.activeType, data, params2)) && void 0 !== _c ? _c : 0 : 1;
    }, this.component = component2;
  }
  _preprocessDimensionInfo(dimensionInfo) {
    const newDimensionInfo = [];
    if (null == dimensionInfo || dimensionInfo.forEach((info) => {
      const di = Object.assign(Object.assign({}, info), {
        data: info.data.filter(({ series: series2 }) => {
          var _a, _b;
          return false !== (null === (_b = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) || void 0 === _b ? void 0 : _b.visible);
        })
      });
      di.data.length > 0 && newDimensionInfo.push(di);
    }), newDimensionInfo.length > 0) return newDimensionInfo;
  }
  _updateViewSpec(data, params2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { changePositionOnly, model } = params2;
    if (!changePositionOnly || !this._cacheActiveSpec) {
      const tooltipSpec = this.component.getSpec();
      if (this._cacheActiveSpec = getTooltipSpecForShow(this.activeType, this.component.getSpec(), model, data, params2), this._cacheActiveSpec) {
        isNil_default(this._cacheActiveSpec.handler) && isValid_default(tooltipSpec.handler) && (this._cacheActiveSpec.handler = tooltipSpec.handler);
        const specByType = null !== (_a = tooltipSpec[this.activeType]) && void 0 !== _a ? _a : {}, updateTitle = null !== (_b = this._cacheActiveSpec.updateTitle) && void 0 !== _b ? _b : specByType.updateTitle, updateContent = null !== (_c = this._cacheActiveSpec.updateContent) && void 0 !== _c ? _c : specByType.updateContent, maxLineCount = null !== (_e = null !== (_d = this._cacheActiveSpec.maxLineCount) && void 0 !== _d ? _d : specByType.maxLineCount) && void 0 !== _e ? _e : TOOLTIP_MAX_LINE_COUNT;
        if (updateTitle && (this._cacheActiveSpec.title = null !== (_f = updateTitle(this._cacheActiveSpec.title, data, params2)) && void 0 !== _f ? _f : this._cacheActiveSpec.title), updateContent) this._cacheActiveSpec.content = null !== (_g = updateContent(this._cacheActiveSpec.content, data, params2)) && void 0 !== _g ? _g : this._cacheActiveSpec.content;
        else if (maxLineCount >= 1 && (null === (_h = this._cacheActiveSpec.content) || void 0 === _h ? void 0 : _h.length) > maxLineCount) {
          const othersLine = null !== (_j = this._cacheActiveSpec.othersLine) && void 0 !== _j ? _j : specByType.othersLine, otherLine = othersLine ? Object.assign(Object.assign({}, TOOLTIP_OTHERS_LINE), othersLine) : TOOLTIP_OTHERS_LINE;
          this._cacheActiveSpec.content = [...this._cacheActiveSpec.content.slice(0, maxLineCount - 1), Object.assign(Object.assign({}, this._cacheActiveSpec.content[maxLineCount - 1]), otherLine)];
        }
      }
    }
  }
  shouldHandleTooltip(params2, info) {
    var _a, _b;
    return !isNil_default(info) && isActiveTypeVisible(this.activeType, null === (_b = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper) || void 0 === _b ? void 0 : _b.spec);
  }
  clearCache() {
    this._cacheActiveSpec = void 0;
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/dimension-tooltip.js
var DimensionTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "dimension";
  }
  showTooltip(info, params2, changePositionOnly) {
    const newParams = Object.assign(Object.assign({}, params2), {
      dimensionInfo: this._preprocessDimensionInfo(info),
      changePositionOnly,
      tooltip: this.component
    });
    return this._showTooltipByHandler(info, newParams);
  }
  _getDimensionInfo(params2) {
    var _a, _b;
    let targetDimensionInfo;
    const chart = this.component.getChart(), layer = chart.getCompiler().getStage().getLayer(void 0), point6 = {
      x: params2.event.viewX,
      y: params2.event.viewY
    };
    if (layer.globalTransMatrix.transformPoint({
      x: params2.event.viewX,
      y: params2.event.viewY
    }, point6), targetDimensionInfo = [...null !== (_a = getCartesianDimensionInfo(chart, point6, true)) && void 0 !== _a ? _a : [], ...null !== (_b = getPolarDimensionInfo(chart, point6)) && void 0 !== _b ? _b : []], 0 === targetDimensionInfo.length) targetDimensionInfo = void 0;
    else if (targetDimensionInfo.length > 1) {
      const dimensionAxisInfo = targetDimensionInfo.filter((info) => {
        var _a2;
        const axis2 = info.axis;
        if (axis2.getSpec().hasDimensionTooltip) return true;
        if (!isDiscrete(axis2.getScale().type)) return false;
        let firstSeries;
        for (const region of null !== (_a2 = null == axis2 ? void 0 : axis2.getRegions()) && void 0 !== _a2 ? _a2 : []) {
          for (const series2 of region.getSeries()) if ("cartesian" === series2.coordinate) {
            firstSeries = series2;
            break;
          }
          if (isValid_default(firstSeries)) break;
        }
        return isValid_default(firstSeries) && firstSeries.getDimensionField()[0] === firstSeries.fieldY[0] ? "left" === axis2.getOrient() || "right" === axis2.getOrient() : "bottom" === axis2.getOrient() || "top" === axis2.getOrient();
      });
      if (targetDimensionInfo = dimensionAxisInfo.length ? dimensionAxisInfo : targetDimensionInfo.slice(0, 1), targetDimensionInfo.length > 1) {
        const dimensionDataKeySet = /* @__PURE__ */ new Set();
        targetDimensionInfo.forEach((info) => {
          info.data = info.data.filter(({ key }) => !dimensionDataKeySet.has(key) && (dimensionDataKeySet.add(key), true));
        });
      }
    }
    return targetDimensionInfo;
  }
  getMouseEventData(params2) {
    return {
      tooltipInfo: this._getDimensionInfo(params2),
      ignore: false
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/mark-tooltip.js
var MarkTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "mark";
  }
  showTooltip(info, params2, changePositionOnly) {
    var _a, _b, _c;
    const { datum, series: series2 } = info, tooltipSpec = this.component.getSpec(), tooltipData = [{
      datum: [datum],
      series: series2
    }], helper = series2.tooltipHelper, seriesSpec = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.tooltip, seriesCheckOverlap = null === (_b = null == seriesSpec ? void 0 : seriesSpec.mark) || void 0 === _b ? void 0 : _b.checkOverlap;
    let checkOverlap = false;
    if (true === seriesCheckOverlap || true === (null === (_c = tooltipSpec.mark) || void 0 === _c ? void 0 : _c.checkOverlap) && false !== seriesCheckOverlap) {
      const activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.mark;
      if (activeTriggers) {
        checkOverlap = true;
        const layer = this.component.getChart().getCompiler().getStage().getLayer(void 0), point6 = {
          x: params2.event.viewX,
          y: params2.event.viewY
        };
        layer.globalTransMatrix.transformPoint({
          x: params2.event.viewX,
          y: params2.event.viewY
        }, point6), activeTriggers.forEach((mark) => {
          mark.getProductElements().forEach((el) => {
            const graphic = el.getGraphicItem();
            el !== params2.item && graphic && graphic.containsPoint(point6.x, point6.y, IContainPointMode.GLOBAL, graphic.stage.getPickerService()) && tooltipData[0].datum.push(el.getDatum());
          });
        });
      }
    }
    const newParams = Object.assign(Object.assign({}, params2), {
      model: series2,
      changePositionOnly,
      tooltip: this.component
    });
    if (changePositionOnly && checkOverlap) {
      const cacheData = this._cacheActiveSpec && this._cacheActiveSpec.data;
      cacheData && cacheData[0].series === tooltipData[0].series && cacheData[0].datum.length === tooltipData[0].datum.length && !cacheData[0].datum.some((d, index) => d !== tooltipData[0].datum[index]) || (newParams.changePositionOnly = false);
    }
    return this._showTooltipByHandler(tooltipData, newParams);
  }
  getMouseEventData(params2) {
    var _a;
    let info, ignore;
    const modelType = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.modelType;
    if ("series" === modelType) {
      const series2 = params2.model, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.mark, ignoreTriggers = null == helper ? void 0 : helper.ignoreTriggerSet.mark;
      (null == activeTriggers ? void 0 : activeTriggers.has(params2.mark)) ? info = {
        mark: params2.mark,
        datum: params2.datum,
        series: series2
      } : (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark)) && (ignore = true);
    } else if ("component" === modelType) {
      const model = params2.model, node = params2.node;
      if ("label" === model.name && node) {
        const labelInfo = model.getLabelInfoByTextGraphic(node), { baseMark, series: series2, labelMark } = null != labelInfo ? labelInfo : {}, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.mark, ignoreTriggers = null == helper ? void 0 : helper.ignoreTriggerSet.mark;
        (null == activeTriggers ? void 0 : activeTriggers.has(labelMark)) ? info = {
          mark: baseMark,
          datum: node.attribute.data,
          series: series2
        } : (null == ignoreTriggers ? void 0 : ignoreTriggers.has(labelMark)) && (ignore = true);
      }
    }
    return {
      tooltipInfo: info,
      ignore
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/group-tooltip.js
var GroupTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "group";
  }
  showTooltip(info, params2, changePositionOnly) {
    const { datum, series: series2 } = info, tooltipData = [{
      datum: array(datum),
      series: series2
    }], newParams = Object.assign(Object.assign({}, params2), {
      groupDatum: this._getGroupDatum(params2),
      changePositionOnly,
      tooltip: this.component
    });
    return this._showTooltipByHandler(tooltipData, newParams);
  }
  getMouseEventData(params2) {
    var _a, _b;
    let info;
    if ("series" === (null === (_a = params2.model) || void 0 === _a ? void 0 : _a.modelType)) {
      const series2 = params2.model, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.group;
      if (null == activeTriggers ? void 0 : activeTriggers.has(params2.mark)) {
        const patternSpec = this.component.getSpec()[this.activeType];
        ((null == patternSpec ? void 0 : patternSpec.triggerMark) ? array(patternSpec.triggerMark) : []).includes(null === (_b = params2.mark) || void 0 === _b ? void 0 : _b.name) && (info = {
          mark: params2.mark,
          datum: params2.datum,
          series: series2
        });
      }
    }
    return {
      tooltipInfo: info,
      ignore: false
    };
  }
  _getGroupDatum(params2) {
    const { model, mark, datum } = params2, series2 = model;
    if (["line", "area"].includes(mark.type)) return array(datum);
    const datumList = series2.getViewData().latestData, seriesField = series2.getSeriesField();
    if (!seriesField) return datumList;
    const seriesFieldValue = array(datum)[0][seriesField];
    return datumList.filter((d) => d[seriesField] === seriesFieldValue);
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/util.js
var isMarkInfo = (info) => isValid_default(info) && !isArray_default(info);
var isDimensionInfo = (info) => isValid_default(info) && isArray_default(info);

// node_modules/@visactor/vchart/esm/component/tooltip/tooltip-transformer.js
var TooltipSpecTransformer = class extends BaseComponentSpecTransformer {
  _shouldMergeThemeToSpec() {
    return false;
  }
  _initTheme(spec, chartSpec) {
    var _a;
    const { spec: newSpec, theme: theme2 } = super._initTheme(spec, chartSpec);
    return newSpec.style = mergeSpec({}, this._theme, newSpec.style), newSpec.offset = mergeSpec({}, theme2.offset, spec.offset), newSpec.transitionDuration = null !== (_a = spec.transitionDuration) && void 0 !== _a ? _a : theme2.transitionDuration, {
      spec: newSpec,
      theme: theme2
    };
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
    var _a, _b, _c, _d, _e, _f, _g;
    super._transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo), spec.visible = null === (_a = spec.visible) || void 0 === _a || _a, spec.activeType = getTooltipActualActiveType(spec), spec.renderMode = null !== (_b = spec.renderMode) && void 0 !== _b ? _b : isMiniAppLikeMode(this._option.mode) || !isTrueBrowser(this._option.mode) ? "canvas" : "html", spec.trigger = null !== (_c = spec.trigger) && void 0 !== _c ? _c : "hover", spec.className = null !== (_d = spec.className) && void 0 !== _d ? _d : TOOLTIP_EL_CLASS_NAME, spec.enterable = null !== (_e = spec.enterable) && void 0 !== _e && _e, spec.transitionDuration = null !== (_f = spec.transitionDuration) && void 0 !== _f ? _f : 150, spec.confine = null !== (_g = spec.confine) && void 0 !== _g ? _g : "canvas" === spec.renderMode, isValid_default(spec.parentElement) ? isString_default(spec.parentElement) && (spec.parentElement = vglobal.getElementById(spec.parentElement)) : isTrueBrowser(this._option.mode) && (spec.parentElement = null == domDocument ? void 0 : domDocument.body);
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/tooltip.js
var Tooltip3 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = 1, this.type = ComponentTypeEnum.tooltip, this.name = ComponentTypeEnum.tooltip, this.transformerConstructor = TooltipSpecTransformer, this.specKey = "tooltip", this.layoutType = "none", this._isReleased = false, this._alwaysShow = false, this._eventList = [], this._isTooltipShown = false, this._clickLock = false, this._mountEvent = (eType, query, callback) => {
      this.event.on(eType, query, callback), this._eventList.push({
        eventType: eType,
        handler: callback
      });
    }, this._handleClickToLock = (params2) => {
      this._clickLock ? (this._handleChartMouseOut(params2), this._clickLock = false) : this._clickLock = true;
    }, this._getMouseOutHandler = (needPointerDetection) => (params2) => {
      var _a, _b, _c, _d, _e;
      if (this._isReleased) return;
      if (this._alwaysShow || this._clickLock) return;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return;
      const browserEnv = isTrueBrowser(null === (_c = this._option) || void 0 === _c ? void 0 : _c.mode), { clientX, clientY } = params2.event;
      browserEnv && needPointerDetection && this._isPointerInChart({
        x: clientX,
        y: clientY
      }) || (this._enterable ? this._outTimer = setTimeout(() => {
        this._handleChartMouseOut(params2);
      }, null !== (_e = null === (_d = this._spec) || void 0 === _d ? void 0 : _d.showDelay) && void 0 !== _e ? _e : DEFAULT_SHOW_DELAY) : this._handleChartMouseOut(params2));
    }, this._handleChartMouseOut = (params2) => {
      this._alwaysShow || this._isReleased || this._isEnterTooltip || "none" !== this._spec.triggerOff && (this._hideTooltipByHandler(Object.assign(Object.assign({}, params2), {
        tooltip: this
      })), this._handleMouseMove && this._handleMouseMove.cancel && this._handleMouseMove.cancel(), this._cacheEnterableRect = null, this._cacheInfo = void 0, this._cacheParams = void 0, this._cacheActiveType = void 0);
    }, this._getMouseMoveHandler = (isClick) => (params2) => {
      var _a, _b, _c, _d;
      this._isReleased || this._isEnterTooltip || (this._outTimer && (clearTimeout(this._outTimer), this._outTimer = null), this.tooltipHandler || this._initHandler(), this.processor || this._initProcessor(), this._alwaysShow || (this._clickLock ? isClick && (this._handleChartMouseOut(params2), this._clickLock = false) : !isClick && this._enterable && (null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a)) ? (this._showTimer && clearTimeout(this._showTimer), this._showTimer = setTimeout(() => {
        this._handleChartMouseMove(params2, isClick);
      }, null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.showDelay) && void 0 !== _d ? _d : DEFAULT_SHOW_DELAY)) : this._handleChartMouseMove(params2, isClick)));
    }, this._handleChartMouseMove = (params2, isClick) => {
      if (this._isReleased) return;
      const mouseEventData = this._getMouseEventData(params2), { tooltipInfo: { dimension: dimensionInfo }, ignore: { mark: ignoreMark } } = mouseEventData, success = {
        mark: false,
        dimension: false,
        group: false
      };
      for (let i = 0, len = TOOLTIP_TYPES.length; i < len; i++) {
        const type = TOOLTIP_TYPES[i];
        if (!!this.processor[type] && this._showTooltipByMouseEvent(type, mouseEventData, params2, isClick)) {
          success[type] = true;
          break;
        }
      }
      Object.values(success).every((val) => !val) && !isEmptyPos(params2) && (ignoreMark && isMarkInfo(this._cacheInfo) ? success.mark = this._showTooltipByMouseEvent("mark", mouseEventData, params2, isClick, true) : isValid_default(dimensionInfo) && (success.dimension = this._showTooltipByMouseEvent("dimension", mouseEventData, params2, isClick))), success.mark || success.group || success.dimension && !isNil_default(dimensionInfo) ? this._initEventOfTooltipContent() : this._handleChartMouseOut(params2);
    }, this._showTooltipByMouseEvent = (activeType, mouseEventData, params2, isClick, useCache) => {
      var _a;
      const processor = this.processor[activeType];
      if (!processor.shouldHandleTooltip(params2, mouseEventData.tooltipInfo[activeType])) return false;
      let success;
      if (this._hideTimer && clearTimeout(this._hideTimer), useCache) success = !processor.showTooltip(this._cacheInfo, params2, true);
      else {
        const tooltipInfo = mouseEventData.tooltipInfo[activeType], isSameAsCache = this._isSameAsCache(tooltipInfo, params2, activeType);
        success = !processor.showTooltip(tooltipInfo, params2, isSameAsCache), success && (this._cacheInfo = tooltipInfo, this._cacheParams = params2, this._cacheActiveType = activeType);
      }
      success && (this._isTooltipShown = true, isClick && this._spec.lockAfterClick && !this._clickLock ? this._clickLock = true : Number.isFinite(this._spec.hideTimer) && (this._hideTimer = setTimeout(() => {
        this._handleChartMouseOut();
      }, this._spec.hideTimer)));
      const vchart = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance;
      return success && VChart.globalConfig.uniqueTooltip && vchart && VChart.hideTooltip(vchart.id), success;
    }, this._getMouseEventData = (params2) => {
      const result2 = {
        tooltipInfo: {},
        ignore: {}
      };
      return Object.keys(this.processor).forEach((activeType) => {
        const { tooltipInfo, ignore } = this.processor[activeType].getMouseEventData(params2);
        result2.tooltipInfo[activeType] = tooltipInfo, result2.ignore[activeType] = ignore;
      }), result2;
    }, this._hideTooltipByHandler = (params2) => {
      var _a, _b, _c;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return 0;
      this.event.emit(ChartEvent.tooltipHide, Object.assign(Object.assign({}, params2), {
        source: Event_Source_Type.chart,
        tooltip: this
      })), Object.values(this.processor).forEach((processor) => {
        processor.clearCache();
      });
      const handler = null !== (_c = this._spec.handler) && void 0 !== _c ? _c : this.tooltipHandler;
      if (handler.hideTooltip) {
        const result2 = handler.hideTooltip.call(handler, params2);
        return result2 || (this._isTooltipShown = false), result2;
      }
      return 1;
    }, this.hideTooltip = () => {
      if (this._isReleased) return false;
      const params2 = {
        changePositionOnly: false,
        tooltip: this,
        item: void 0,
        datum: void 0,
        source: Event_Source_Type.chart
      };
      return this._alwaysShow = false, !this._hideTooltipByHandler(params2);
    };
  }
  isTooltipShown() {
    return this._isTooltipShown;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  _registerEvent() {
  }
  _releaseEvent() {
  }
  onLayout(ctx) {
  }
  onLayoutEnd(ctx) {
  }
  onRender(ctx) {
  }
  created() {
    super.created(), this._regions = this._option.getAllRegions(), this._initEvent();
  }
  release() {
    var _a, _b;
    super.release(), this._isReleased = true, this._hideTimer && clearTimeout(this._hideTimer), this._eventList.forEach(({ eventType, handler }) => {
      this.event.off(eventType, handler);
    }), this._eventList = [], null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), this._isTooltipShown = false;
  }
  beforeRelease() {
    this.event.emit(ChartEvent.tooltipHide, {
      tooltip: this,
      chart: this.getChart()
    }), this.event.emit(ChartEvent.tooltipRelease, {
      tooltip: this,
      chart: this.getChart()
    });
  }
  _initHandler() {
    var _a, _b, _c;
    const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", userTooltipHandler = this._option.globalInstance.getTooltipHandlerByUser();
    if (userTooltipHandler) this.tooltipHandler = userTooltipHandler, this._enterable = false;
    else {
      const type = "canvas" === renderMode ? TooltipHandlerType.canvas : TooltipHandlerType.dom, handlerConstructor = Factory2.getComponentPluginInType(type);
      handlerConstructor || error("Can not find tooltip handler: " + type);
      const handler = new handlerConstructor();
      handler.name = `${this._spec.className}-${null !== (_b = this._option.globalInstance.id) && void 0 !== _b ? _b : 0}-${this.getSpecIndex()}`, null === (_c = this.pluginService) || void 0 === _c || _c.load([handler]), this.tooltipHandler = handler, this._spec.enterable && "html" === renderMode && this.tooltipHandler ? (this._enterable = true, this._needInitEventOfTooltip = true) : this._enterable = false;
    }
  }
  _initEventOfTooltipContent() {
    var _a, _b;
    if (!this._needInitEventOfTooltip) return;
    const container2 = null === (_b = (_a = this.tooltipHandler).getTooltipContainer) || void 0 === _b ? void 0 : _b.call(_a), element = null == container2 ? void 0 : container2.firstChild;
    element && (element.addEventListener("pointerenter", () => {
      var _a2;
      if (!this._enterable) return;
      this._isEnterTooltip = true;
      const rect = null === (_a2 = element.getBoundingClientRect) || void 0 === _a2 ? void 0 : _a2.call(element);
      rect && (this._cacheEnterableRect = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      }), this._outTimer && (clearTimeout(this._outTimer), this._outTimer = null), this._showTimer && (clearTimeout(this._showTimer), this._showTimer = null);
    }), element.addEventListener("pointerleave", () => {
      var _a2, _b2, _c;
      if (this._enterable && (this._isEnterTooltip = false, this._cacheEnterableRect)) {
        const newRect = null === (_a2 = element.getBoundingClientRect) || void 0 === _a2 ? void 0 : _a2.call(element);
        newRect && Object.keys(this._cacheEnterableRect).every((k2) => this._cacheEnterableRect[k2] === newRect[k2]) && (this._cacheEnterableRect = null, this._outTimer = setTimeout(this.hideTooltip, null !== (_c = null === (_b2 = this._spec) || void 0 === _b2 ? void 0 : _b2.showDelay) && void 0 !== _c ? _c : DEFAULT_SHOW_DELAY));
      }
    }), this._needInitEventOfTooltip = false);
  }
  _initProcessor() {
    const activeType = this._spec.activeType;
    this.processor = {}, activeType.includes("dimension") && (this.processor.dimension = new DimensionTooltipProcessor(this)), activeType.includes("group") && (this.processor.group = new GroupTooltipProcessor(this)), activeType.includes("mark") && (this.processor.mark = new MarkTooltipProcessor(this));
  }
  _initEvent() {
    var _a;
    if (this._option.disableTriggerEvent) return;
    const trigger = array(null !== (_a = this._spec.trigger) && void 0 !== _a ? _a : "hover"), triggerOff = array(this._spec.triggerOff), mode = this._option.mode;
    trigger.forEach((triggerType) => {
      var _a2;
      "hover" === triggerType ? (this._handleMouseMove = this._throttle(this._getMouseMoveHandler(false)), this._mountEvent("pointermove", {
        source: "chart"
      }, this._handleMouseMove), (isMobileLikeMode(mode) || isMiniAppLikeMode(mode)) && (this._mountEvent("pointerdown", {
        source: "chart"
      }, this._getMouseMoveHandler(false)), this._mountEvent("pointerup", {
        source: "window"
      }, this._getMouseOutHandler(true))), this._mountEvent("pointerleave", {
        source: "chart"
      }, this._getMouseOutHandler(false))) : "click" === triggerType ? (this._mountEvent("pointertap", {
        source: "chart"
      }, this._getMouseMoveHandler(true)), this._mountEvent("pointerup", {
        source: "window"
      }, this._getMouseOutHandler(true))) : isObject_default(triggerType) && this._mountEvent(triggerType.eventType, {
        source: null !== (_a2 = triggerType.source) && void 0 !== _a2 ? _a2 : "chart",
        consume: triggerType.consume
      }, this._getMouseMoveHandler(true));
    });
    triggerOff.filter((entry) => isObject_default(entry)).forEach((entry) => {
      var _a2, _b;
      this._mountEvent(entry.eventType, {
        source: null !== (_a2 = entry.source) && void 0 !== _a2 ? _a2 : "chart",
        consume: entry.consume
      }, this._getMouseOutHandler(null !== (_b = entry.checkOutside) && void 0 !== _b && _b));
    }), !trigger.includes("click") && this._spec.lockAfterClick && this._mountEvent("pointertap", {
      source: "chart"
    }, this._handleClickToLock);
  }
  _throttle(callback) {
    let wait;
    return wait = isNumber_default(this._spec.throttleInterval) ? this._spec.throttleInterval : "html" === this._spec.renderMode && this._spec.transitionDuration ? 50 : 10, throttle_default(callback, wait);
  }
  reInit(spec) {
    var _a, _b, _c;
    if (super.reInit(spec), this.tooltipHandler) {
      const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", newEnterable = this._spec.enterable && "html" === renderMode;
      newEnterable && !this._enterable && (this._needInitEventOfTooltip = true), this._enterable = newEnterable, null === (_c = (_b = this.tooltipHandler).reInit) || void 0 === _c || _c.call(_b);
    } else this._initHandler();
  }
  showTooltip(datum, options) {
    var _a;
    if (this.tooltipHandler || this._initHandler(), this.processor || this._initProcessor(), !(null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip)) return false;
    const result2 = showTooltip(datum, options, this);
    return "none" !== result2 && (this._alwaysShow = !!(null == options ? void 0 : options.alwaysShow)), result2;
  }
  _isSameAsCache(nextInfo, nextParams, nextActiveType) {
    if (nextActiveType !== this._cacheActiveType) return false;
    if (nextInfo === this._cacheInfo) return true;
    if (isNil_default(this._cacheInfo) || isNil_default(nextInfo)) return false;
    if (isDimensionInfo(nextInfo)) {
      if (isMarkInfo(this._cacheInfo)) return false;
      const prevInfo2 = this._cacheInfo;
      return prevInfo2.length === nextInfo.length && nextInfo.every((info, i) => isSameDimensionInfo(info, prevInfo2[i]));
    }
    if (isDimensionInfo(this._cacheInfo)) return false;
    const prevInfo = this._cacheInfo;
    if (!((null == nextInfo ? void 0 : nextInfo.datum) === prevInfo.datum && (null == nextInfo ? void 0 : nextInfo.mark) === prevInfo.mark && (null == nextInfo ? void 0 : nextInfo.series) === prevInfo.series)) return false;
    const prevParams = this._cacheParams;
    return !isNil_default(prevParams) && !isNil_default(nextParams) && (prevParams.mark === nextParams.mark && prevParams.model === nextParams.model && prevParams.datum === nextParams.datum);
  }
  _isPointerInChart(point6) {
    var _a;
    const globalInstance = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance;
    if (!globalInstance) return false;
    if (!globalInstance.getChart()) return false;
    const { x, y } = point6, canvas = globalInstance.getCanvas(), { x: chartX, y: chartY, width: chartWidth, height: chartHeight } = canvas.getBoundingClientRect();
    return x >= chartX && x <= chartX + chartWidth && y >= chartY && y <= chartY + chartHeight;
  }
  getVisible() {
    return false !== this._spec.visible;
  }
};
Tooltip3.type = ComponentTypeEnum.tooltip, Tooltip3.transformerConstructor = TooltipSpecTransformer, Tooltip3.specKey = "tooltip";
var registerTooltip = () => {
  Factory2.registerComponent(Tooltip3.type, Tooltip3);
};

// node_modules/@visactor/vchart/esm/component/tooltip/interface/common.js
var TooltipResult;
!function(TooltipResult2) {
  TooltipResult2[TooltipResult2.success = 0] = "success", TooltipResult2[TooltipResult2.failed = 1] = "failed";
}(TooltipResult || (TooltipResult = {}));

// node_modules/@visactor/vchart/esm/component/crosshair/config.js
function getDefaultCrosshairTriggerEventByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    click: "pointertap",
    hover: "pointermove",
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    click: "tap",
    hover: ["pointerdown", "pointermove"],
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : null;
}
var LayoutType;
!function(LayoutType2) {
  LayoutType2[LayoutType2.ALL = 3] = "ALL", LayoutType2[LayoutType2.HORIZONTAL = 2] = "HORIZONTAL", LayoutType2[LayoutType2.VERTICAL = 1] = "VERTICAL";
}(LayoutType || (LayoutType = {}));

// node_modules/@visactor/vchart/esm/component/crosshair/base.js
var __rest28 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var ORIENT_MAP = {
  x: ["top", "bottom"],
  y: ["left", "right"],
  category: ["angle"],
  value: ["radius"]
};
var BaseCrossHair = class extends BaseComponent {
  get enableRemain() {
    return "none" === this.triggerOff;
  }
  constructor(spec, options) {
    super(spec, options), this.specKey = "crosshair", this.layoutType = "none", this.gridZIndex = LayoutZIndex.CrossHair_Grid, this.labelZIndex = LayoutZIndex.CrossHair, this.trigger = "hover", this._handleIn = (params2) => {
      if (!this._option) return;
      const { x, y } = this.calculateTriggerPoint(params2);
      this.showDefault = false, this._layoutCrosshair(x, y);
      const components = this._getNeedClearVRenderComponents();
      this._hasActive = components.some((comp) => comp && false !== comp.attribute.visible);
    }, this._handleClickInEvent = (params2) => {
      if (!this._hasActive || !this._spec.lockAfterClick || this._clickLock) return this._clickLock ? (this._clickLock = false, void this._handleOutEvent()) : void (this._onlyLockClick || (this._handleIn(params2), isNumber_default(this.triggerOff) && (this._timer && clearTimeout(this._timer), this._timer = setTimeout(() => {
        this._handleOutEvent();
      }, this.triggerOff))));
      this._clickLock = true;
    }, this._handleHoverInEvent = throttle_default((params2) => {
      this._clickLock || this._handleIn(params2);
    }, 10), this._handleOutEvent = () => {
      this.enableRemain || this._clickLock || !this._hasActive || (this.clearOutEvent(), this.hide());
    }, this._handleTooltipShow = (params2) => {
      const tooltipData = params2.tooltipData;
      if (params2.isEmptyTooltip || !tooltipData || !tooltipData.length) return void this._handleTooltipHideOrRelease();
      if (isObject_default(this._spec.followTooltip) && false === this._spec.followTooltip[params2.activeType]) return void this._handleTooltipHideOrRelease();
      const { x, y } = this.calculateTriggerPoint(params2);
      this.showDefault = false, this._layoutCrosshair(x, y, tooltipData, params2.activeType);
      const components = this._getNeedClearVRenderComponents();
      this._hasActive = components.some((comp) => comp && false !== comp.attribute.visible);
    }, this._handleTooltipHideOrRelease = () => {
      this.clearOutEvent(), this.hide();
    }, this.enable = true, this.showDefault = true;
  }
  _setAllAxisValues(axisMap, point6, field5) {
    let discrete = false;
    if (axisMap.forEach((item) => {
      isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = false : discrete = true);
    }), !this.enable) return false;
    const { currentValue } = this._stateByField[field5];
    return axisMap.forEach((item, id) => {
      const axis2 = item.axis;
      currentValue.set(id, {
        datum: this._getDatumAtPoint(axis2, point6),
        axis: axis2
      });
    }), true;
  }
  clearAxisValue() {
    Object.keys(this._stateByField).forEach((field5) => {
      this._stateByField[field5].currentValue.clear();
    });
  }
  hideCrosshair() {
    this.clearAxisValue(), this.hide();
  }
  showCrosshair(dimInfo) {
    dimInfo && dimInfo.length && (this.showDefault = false, this.clearAxisValue(), dimInfo.forEach((d) => {
      const { axis: axis2, value } = d;
      this.setAxisValue(value, axis2);
    }), this.layoutByValue(false));
  }
  _getLimitBounds() {
    var _a, _b;
    if (!this._limitBounds) {
      const { width, height } = null !== (_b = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getViewRect()) && void 0 !== _b ? _b : {
        width: 0,
        height: 0
      };
      this._limitBounds = {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height
      };
    }
    return this._limitBounds;
  }
  _showDefaultCrosshairBySpec() {
    Object.keys(this._stateByField).forEach((field5) => {
      const fieldSpec = this._spec[field5];
      if (fieldSpec && fieldSpec.visible && fieldSpec.defaultSelect) {
        const { axisIndex = 0, datum } = fieldSpec.defaultSelect, axis2 = this._option.getComponentsByKey("axes").find((c3) => c3.getSpecIndex() === axisIndex);
        axis2 && (this._stateByField[field5].currentValue.clear(), this._stateByField[field5].currentValue.set(axisIndex, {
          axis: axis2,
          datum
        }));
      }
    });
  }
  _updateVisibleCrosshair() {
    let hasVisible = false;
    Object.keys(this._stateByField).forEach((field5) => {
      const fieldSpec = this._spec[field5];
      fieldSpec && fieldSpec.visible && this._stateByField[field5].currentValue.size ? hasVisible = true : this._hideByField(field5);
    }), hasVisible && this.layoutByValue(false);
  }
  _showDefaultCrosshair() {
    this.showDefault ? (this._showDefaultCrosshairBySpec(), this.layoutByValue(false)) : this._updateVisibleCrosshair();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._parseCrosshairSpec();
  }
  created() {
    super.created(), this._initEvent();
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  _initEvent() {
    if (!this._option.disableTriggerEvent) if (this._spec.followTooltip) this._registerTooltipEvent();
    else {
      const triggerConfig = this._getTriggerEvent();
      triggerConfig && triggerConfig.forEach((cfg) => {
        this._registerEvent(cfg.in, false, cfg.click), cfg.out && this._registerEvent(cfg.out, true);
      });
    }
  }
  _registerEvent(eventName, isOut, click) {
    const handler = isOut ? this._handleOutEvent : click ? this._handleClickInEvent : this._handleHoverInEvent, cfg = isOut ? {
      level: Event_Bubble_Level.chart
    } : {
      source: Event_Source_Type.chart
    };
    isArray_default(eventName) ? eventName.forEach((evt) => {
      this.event.on(evt, cfg, handler);
    }) : this.event.on(eventName, cfg, handler);
  }
  _eventOff(eventName, isOut, click) {
    const handler = isOut ? this._handleOutEvent : click ? this._handleClickInEvent : this._handleHoverInEvent;
    isArray_default(eventName) ? eventName.forEach((evt) => {
      this.event.off(evt, handler);
    }) : this.event.off(eventName, handler);
  }
  updateLayoutAttribute() {
    this._limitBounds = null, this._showDefaultCrosshair();
  }
  calculateTriggerPoint(params2) {
    const { event } = params2, layer = this._option.getCompiler().getStage().getLayer(void 0), point6 = {
      x: event.viewX,
      y: event.viewY
    };
    return layer.globalTransMatrix.transformPoint({
      x: event.viewX,
      y: event.viewY
    }, point6), {
      x: point6.x - this.getLayoutStartPoint().x,
      y: point6.y - this.getLayoutStartPoint().y
    };
  }
  _getTriggerEvent() {
    const { mode = RenderModeEnum["desktop-browser"] } = this._option, triggerConfig = getDefaultCrosshairTriggerEventByMode(mode);
    if (triggerConfig) {
      const trigger = array(this.trigger || "hover"), outTrigger = (inTrigger) => "click" === inTrigger ? "none" === this.triggerOff ? null : triggerConfig.clickOut : triggerConfig.hoverOut;
      this._spec.lockAfterClick && !trigger.includes("click") ? (trigger.push("click"), this._onlyLockClick = true) : this._onlyLockClick = false;
      const res = [];
      return trigger.forEach((item) => {
        res.push({
          click: "click" === item,
          in: triggerConfig[item],
          out: outTrigger(item)
        });
      }), res;
    }
    return null;
  }
  _registerTooltipEvent() {
    this.event.on(ChartEvent.tooltipHide, {
      source: Event_Source_Type.chart
    }, this._handleTooltipHideOrRelease), this.event.on(ChartEvent.tooltipShow, {
      source: Event_Source_Type.chart
    }, this._handleTooltipShow), this.event.on(ChartEvent.tooltipRelease, {
      source: Event_Source_Type.chart
    }, this._handleTooltipHideOrRelease);
  }
  _getAxisInfoByField(field5) {
    var _a, _b;
    const axesComponents = null === (_b = (_a = this._option).getComponentsByKey) || void 0 === _b ? void 0 : _b.call(_a, "axes");
    if (!(null == axesComponents ? void 0 : axesComponents.length)) return null;
    let bindingAxesIndex = get_default(this._spec, `${field5}Field.bindingAxesIndex`);
    if (bindingAxesIndex || (bindingAxesIndex = [], axesComponents.forEach((item, index) => {
      ORIENT_MAP[field5].includes(item.getOrient()) && bindingAxesIndex.push(index);
    })), !bindingAxesIndex.length) return null;
    const map4 = /* @__PURE__ */ new Map();
    let x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0;
    const { x: sx, y: sy } = this.getLayoutStartPoint();
    return bindingAxesIndex.forEach((idx2) => {
      x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0;
      const axis2 = axesComponents.find((axis3) => axis3.getSpecIndex() === idx2);
      if (!axis2) return;
      axis2.getRegions().forEach((r) => {
        const { x: regionStartX, y: regionStartY } = r.getLayoutStartPoint();
        x1 = Math.min(x1, regionStartX - sx), y1 = Math.min(y1, regionStartY - sy), x2 = Math.max(x2, regionStartX + r.getLayoutRect().width - sx), y2 = Math.max(y2, regionStartY + r.getLayoutRect().height - sy);
      }), map4.set(idx2, {
        x1,
        y1,
        x2,
        y2,
        axis: axis2
      });
    }), map4;
  }
  changeRegions(regions) {
  }
  onLayoutEnd(ctx) {
    const region = this._regions[0];
    this.setLayoutRect(region.getLayoutRect()), this.setLayoutStartPosition(region.getLayoutStartPoint()), super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  _releaseEvent() {
    this.clearOutEvent();
    const triggerConfig = this._getTriggerEvent();
    triggerConfig && triggerConfig.forEach((cfg) => {
      this._eventOff(cfg.in, false, cfg.click), cfg.out && this._eventOff(cfg.out, true);
    });
  }
  _parseFieldInfo() {
    Object.keys(this._stateByField).forEach((field5) => {
      const fieldSpec = this._spec[field5], { crosshairComp } = this._stateByField[field5];
      if (fieldSpec && fieldSpec.visible) {
        if (this._stateByField[field5].attributes = this._parseField(fieldSpec, field5), crosshairComp) {
          const { style, type } = this._stateByField[field5].attributes, styleKey = "rect" === type ? "rectStyle" : "lineStyle";
          crosshairComp.setAttributes({
            [styleKey]: style
          });
        }
      } else crosshairComp && crosshairComp.parent && crosshairComp.parent.removeChild(crosshairComp);
    });
  }
  _parseCrosshairSpec() {
    this._parseFieldInfo();
    const { trigger, triggerOff, labelZIndex, gridZIndex } = this._spec;
    trigger && (this.trigger = trigger), ("none" === triggerOff || isNumber_default(triggerOff) && triggerOff > 0) && (this.triggerOff = triggerOff), void 0 !== labelZIndex && (this.labelZIndex = labelZIndex), void 0 !== gridZIndex && (this.gridZIndex = gridZIndex);
  }
  _parseField(field5, fieldName) {
    var _a, _b;
    const hair = {}, { line: line2 = {}, label = {}, visible } = field5;
    if (hair.visible = visible, hair.type = line2.type || "line", false === line2.visible) hair.style = {
      visible: false
    };
    else {
      const style = line2.style || {}, { stroke: stroke2, fill, lineWidth } = style, _c = style, { strokeOpacity, fillOpacity, opacity } = _c, restStyle = __rest28(_c, ["strokeOpacity", "fillOpacity", "opacity"]), isLineType = "line" === hair.type;
      let finalOpacity = isLineType ? strokeOpacity : fillOpacity;
      if (isNumber_default(opacity) && (finalOpacity = (null != finalOpacity ? finalOpacity : 1) * opacity), hair.style = Object.assign({
        opacity: finalOpacity,
        pickable: false,
        visible: true
      }, restStyle), isLineType) hair.style.stroke = stroke2 || fill, hair.style.lineWidth = get_default(line2, "width", lineWidth || 2);
      else {
        hair.style.fill = fill || stroke2, (null === (_b = null === (_a = null == field5 ? void 0 : field5.line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.stroke) && (hair.style.stroke = field5.line.style.stroke);
        const rectSize2 = get_default(line2, "width");
        if ("string" == typeof rectSize2) {
          const percent = parseInt(rectSize2.substring(0, rectSize2.length - 1), 10) / 100;
          hair.style.sizePercent = percent;
        } else "number" != typeof rectSize2 && "function" != typeof rectSize2 || (hair.style.size = rectSize2);
      }
    }
    if (label.visible) {
      const labelBackground = label.labelBackground || {}, labelStyle = label.style || {}, _d = labelBackground.style || {}, { fill: rectFill = "rgba(47, 59, 82, 0.9)", stroke: rectStroke, outerBorder } = _d, rectStyle = __rest28(_d, ["fill", "stroke", "outerBorder"]);
      hair.label = {
        visible: true,
        formatMethod: label.formatMethod,
        formatter: label.formatter,
        minWidth: labelBackground.minWidth,
        maxWidth: labelBackground.maxWidth,
        padding: labelBackground.padding,
        textStyle: Object.assign(Object.assign({
          fontSize: 14,
          pickable: false
        }, labelStyle), {
          fill: labelStyle.fill || "#fff",
          stroke: get_default(labelStyle, "stroke")
        }),
        panel: (isBoolean_default(labelBackground.visible) ? labelBackground.visible : labelBackground) ? Object.assign({
          visible: true,
          pickable: false,
          fill: rectFill,
          stroke: rectStroke,
          outerBorder: Object.assign({
            stroke: rectFill,
            distance: 0,
            lineWidth: 3
          }, outerBorder)
        }, rectStyle) : {
          visible: false
        },
        zIndex: this.labelZIndex,
        childrenPickable: false,
        pickable: false
      };
    } else hair.label = {
      visible: false
    };
    return hair;
  }
  _filterAxisByPoint(axisMap, relativeX, relativeY) {
    return axisMap && axisMap.forEach((item) => {
      const axis2 = item.axis;
      if (outOfBounds(item, relativeX, relativeY) && axisMap.delete(axis2.getSpecIndex()), axis2.type.startsWith("polarAxis")) {
        const center2 = axis2.getCenter(), innerRadius = axis2.getInnerRadius(), outerRadius = axis2.getOuterRadius(), distance2 = PointService.distancePP({
          x: relativeX,
          y: relativeY
        }, center2);
        (distance2 > outerRadius || distance2 < innerRadius) && axisMap.delete(axis2.getSpecIndex());
      }
    }), axisMap;
  }
  _updateCrosshairLabel(label, labelAttrs, callback) {
    const container2 = this.getContainer();
    label ? label.setAttributes(labelAttrs) : (label = new Tag(labelAttrs), null == container2 || container2.add(label), callback(label)), limitTagInBounds(label, this._getLimitBounds());
  }
  clearOutEvent() {
    this._timer && (clearTimeout(this._timer), this._timer = null), this._clickLock && (this._clickLock = null), this._hasActive && (this._hasActive = null);
  }
  _hideByField(field5) {
    const { crosshairComp, labelsComp } = this._stateByField[field5];
    crosshairComp && crosshairComp.hideAll(), labelsComp && Object.keys(labelsComp).forEach((key) => {
      labelsComp[key] && labelsComp[key].hideAll();
    });
  }
  hide() {
    Object.keys(this._stateByField).forEach((field5) => {
      this._hideByField(field5);
    });
  }
  _getNeedClearVRenderComponents() {
    return Object.keys(this._stateByField).reduce((res, field5) => {
      const { crosshairComp, labelsComp } = this._stateByField[field5];
      return crosshairComp && res.push(crosshairComp), labelsComp && Object.keys(labelsComp).forEach((key) => {
        labelsComp[key] && res.push(labelsComp[key]);
      }), res;
    }, []);
  }
};
BaseCrossHair.specKey = "crosshair";

// node_modules/@visactor/vchart/esm/component/crosshair/utils/cartesian.js
var layoutByValue = (stateByField, series2, layoutStartPoint, enableRemain = false) => (layoutStartPoint || (layoutStartPoint = {
  x: 0,
  y: 0
}), Object.keys(stateByField).forEach((field5) => {
  const { currentValue, cacheInfo, labelsComp, attributes, coordKey } = stateByField[field5];
  let axis2 = null, coord = 0;
  if (currentValue.size) {
    const item = Array.from(currentValue.values())[0];
    coord = item.axis.getScale().scale(item.datum) + item.axis.getLayoutStartPoint()[coordKey] - layoutStartPoint[coordKey], axis2 = item.axis;
  }
  const isVisible2 = !!currentValue.size && Number.isFinite(coord) && !Number.isNaN(coord), useCache = enableRemain && !isVisible2 && isValid_default(cacheInfo), newCacheInfo = useCache ? cacheInfo : {
    coordRange: [0, 0],
    sizeRange: [0, 0],
    coord,
    labelsTextStyle: {},
    labels: labelsComp ? Object.keys(labelsComp).reduce((res, labelKey) => (res[labelKey] = {
      visible: false,
      text: "",
      dx: 0,
      dy: 0
    }, res), {}) : null,
    visible: isVisible2,
    axis: axis2
  };
  let bandSize;
  newCacheInfo && (newCacheInfo._isCache = useCache);
  let offsetSize = 0;
  if (attributes && currentValue.forEach(({ axis: axis3, datum: value = "" }) => {
    var _a;
    let niceLabelFormatter = null;
    const scale4 = axis3.getScale();
    if (isDiscrete(scale4.type)) bandSize = scale4.bandwidth(), 0 === bandSize && scale4.step && (offsetSize = scale4.step());
    else if (isContinuous(scale4.type)) {
      const field1 = "xField" === field5 ? series2.fieldX[0] : series2.fieldY[0], field22 = "xField" === field5 ? series2.fieldX2 : series2.fieldY2, datum = getDatumByValue(series2.getViewData().latestData, +value, field1, field22);
      if (datum) {
        const startX = "xField" === field5 ? series2.dataToPositionX(datum) : series2.dataToPositionY(datum);
        field22 ? (bandSize = Math.abs(startX - ("xField" === field5 ? series2.dataToPositionX1(datum) : series2.dataToPositionY1(datum))), value = `${datum[field1]} ~ ${datum[field22]}`) : bandSize = 1, coord = startX;
      }
      niceLabelFormatter = axis3.niceLabelFormatter;
    }
    if (newCacheInfo && (null === (_a = attributes.label) || void 0 === _a ? void 0 : _a.visible) && !useCache) {
      const labelOffset = getAxisLabelOffset(axis3.getSpec()), axisOrient = axis3.getOrient();
      newCacheInfo.labels[axisOrient] && (newCacheInfo.labels[axisOrient].visible = true, newCacheInfo.labels[axisOrient].text = value, "left" === axisOrient ? (newCacheInfo.labels[axisOrient].dx = -labelOffset, newCacheInfo.labelsTextStyle[axisOrient] = {
        textAlign: "right",
        textBaseline: "middle"
      }) : "right" === axisOrient ? (newCacheInfo.labels[axisOrient].dx = labelOffset, newCacheInfo.labelsTextStyle[axisOrient] = {
        textAlign: "left",
        textBaseline: "middle"
      }) : "top" === axisOrient ? (newCacheInfo.labels[axisOrient].y = 0, newCacheInfo.labels[axisOrient].dy = -labelOffset, newCacheInfo.labelsTextStyle[axisOrient] = {
        textAlign: "center",
        textBaseline: "bottom"
      }) : "bottom" === axisOrient && (newCacheInfo.labels[axisOrient].dy = labelOffset, newCacheInfo.labelsTextStyle[axisOrient] = {
        textAlign: "center",
        textBaseline: "top"
      }), newCacheInfo.labels[axisOrient].defaultFormatter = niceLabelFormatter);
    }
  }), newCacheInfo && !useCache) {
    const region = {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0
    };
    setRegionArea(region, currentValue), "xField" === field5 ? (newCacheInfo.coordRange = [region.x1, region.x2], newCacheInfo.sizeRange = [region.y1, region.y2], newCacheInfo.coord = coord + layoutStartPoint.x, newCacheInfo.labels && (newCacheInfo.labels.top.y = region.y1, newCacheInfo.labels.bottom.y = region.y2)) : (newCacheInfo.coordRange = [region.y1, region.y2], newCacheInfo.sizeRange = [region.x1, region.x2], newCacheInfo.coord = coord + layoutStartPoint.y, newCacheInfo.labels && (newCacheInfo.labels.left.x = region.x1, newCacheInfo.labels.right.x = region.x2)), (newCacheInfo.coord < newCacheInfo.coordRange[0] || newCacheInfo.coord > newCacheInfo.coordRange[1]) && (newCacheInfo.visible = false), attributes && attributes.label && Object.keys(newCacheInfo.labels).forEach((labelKey) => {
      newCacheInfo.labels[labelKey].visible && setFormattedCrosshairLabel(newCacheInfo.labels[labelKey], labelKey, attributes.label);
    });
  }
  stateByField[field5].bandSize = null != bandSize ? bandSize : 0, stateByField[field5].offsetSize = offsetSize, stateByField[field5].cacheInfo = newCacheInfo;
}), stateByField);
var setFormattedCrosshairLabel = (labelInfo, position, labelSpec) => {
  const { formatMethod, formatter } = labelSpec, { formatFunc, args } = getFormatFunction(formatMethod, formatter, labelInfo.text, {
    label: labelInfo.text,
    position
  });
  formatFunc ? labelInfo.text = formatFunc(...args) : labelInfo.defaultFormatter && (labelInfo.text = labelInfo.defaultFormatter(labelInfo.text));
};
var setRegionArea = (outRegion, currentValue) => {
  currentValue.forEach(({ axis: axis2 }) => {
    axis2.getRegions().forEach((r) => {
      const { x, y } = r.getLayoutStartPoint(), { width, height } = r.getLayoutRect();
      outRegion.x1 = Math.min(outRegion.x1, x), outRegion.y1 = Math.min(outRegion.y1, y), outRegion.x2 = Math.max(outRegion.x2, x + width), outRegion.y2 = Math.max(outRegion.y2, y + height);
    });
  });
};
var layoutCrosshair = (stateItem) => {
  const { cacheInfo, attributes, bandSize, offsetSize, coordKey, anotherAxisKey } = stateItem, { coord, sizeRange } = cacheInfo, type = attributes.type;
  let positionAttribute;
  if ("line" === type) {
    const pos = coord + bandSize / 2;
    positionAttribute = {
      visible: true,
      start: {
        [coordKey]: pos,
        [anotherAxisKey]: sizeRange[0]
      },
      end: {
        [coordKey]: pos,
        [anotherAxisKey]: sizeRange[1]
      }
    };
  } else if ("rect" === type) {
    const [offset0, offset1] = getRectSize(attributes, bandSize, offsetSize, cacheInfo.axis), { coordRange } = cacheInfo;
    positionAttribute = {
      visible: true,
      start: {
        [coordKey]: Math.max(coord + offset0, coordRange[0]),
        [anotherAxisKey]: sizeRange[0]
      },
      end: {
        [coordKey]: Math.min(coord + offset1, coordRange[1]),
        [anotherAxisKey]: sizeRange[1]
      }
    };
  }
  return positionAttribute;
};
var getRectSize = (hair, bandSize, offsetSize, axis2) => {
  var _a, _b, _c;
  const visualSize = 0 === bandSize ? offsetSize : bandSize;
  let size = visualSize;
  if (null === (_a = hair.style) || void 0 === _a ? void 0 : _a.sizePercent) size = visualSize * hair.style.sizePercent;
  else if ("number" == typeof (null === (_b = hair.style) || void 0 === _b ? void 0 : _b.size)) size = hair.style.size;
  else if ("function" == typeof (null === (_c = hair.style) || void 0 === _c ? void 0 : _c.size)) {
    const axisRect = axis2.getLayoutRect();
    size = hair.style.size(axisRect, axis2);
  }
  return 0 === bandSize ? [-size / 2, size / 2] : [bandSize / 2 - size / 2, size / 2 + bandSize / 2];
};

// node_modules/@visactor/vchart/esm/component/crosshair/cartesian.js
var CartesianCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => s2.xField && false !== s2.xField.visible || s2.yField && false !== s2.yField.visible);
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianCrosshair, this.name = ComponentTypeEnum.cartesianCrosshair, this._stateByField = {
      xField: {
        coordKey: "x",
        anotherAxisKey: "y",
        currentValue: /* @__PURE__ */ new Map(),
        labelsComp: {
          top: null,
          bottom: null
        }
      },
      yField: {
        coordKey: "y",
        anotherAxisKey: "x",
        currentValue: /* @__PURE__ */ new Map(),
        labelsComp: {
          left: null,
          right: null
        }
      }
    };
  }
  _findAllAxisContains(relativeX, relativeY) {
    const xAxisMap = this._getAxisInfoByField("x"), yAxisMap = this._getAxisInfoByField("y");
    return {
      xAxisMap: this._filterAxisByPoint(xAxisMap, relativeX, relativeY),
      yAxisMap: this._filterAxisByPoint(yAxisMap, relativeX, relativeY)
    };
  }
  _getDatumAtPoint(axis2, point6) {
    const dim = isXAxis(axis2.getOrient()) ? "x" : "y", coordByAxis = point6[dim] - (axis2.getLayoutStartPoint()[dim] - this.getLayoutStartPoint()[dim]);
    return axis2.getScale().invert(coordByAxis);
  }
  setAxisValue(datum, axis2) {
    isXAxis(axis2.getOrient()) ? this._stateByField.xField.currentValue.set(axis2.getSpecIndex(), {
      datum,
      axis: axis2
    }) : this._stateByField.yField.currentValue.set(axis2.getSpecIndex(), {
      datum,
      axis: axis2
    });
  }
  _layoutCrosshair(relativeX, relativeY, tooltipData, activeType) {
    var _a;
    let x = relativeX, y = relativeY;
    if (tooltipData && tooltipData.length) {
      if ("dimension" === activeType) {
        const dimensionInfo = tooltipData[0], datumIndex = dimensionInfo.data.findIndex((dimData) => dimData.datum.length > 0);
        let pos;
        if (datumIndex > -1) {
          const dimensionData = dimensionInfo.data[datumIndex];
          pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        }
        (isValid_default(dimensionInfo.dimType) ? "y" === dimensionInfo.dimType : isYAxis(null === (_a = null == dimensionInfo ? void 0 : dimensionInfo.axis) || void 0 === _a ? void 0 : _a.getOrient())) ? y = null == pos ? void 0 : pos.y : x = null == pos ? void 0 : pos.x;
      } else if ("mark" === activeType) {
        const dimensionData = tooltipData[0], pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        x = null == pos ? void 0 : pos.x, y = null == pos ? void 0 : pos.y;
      }
    }
    this.clearAxisValue();
    const { xAxisMap, yAxisMap } = this._findAllAxisContains(x, y);
    if (xAxisMap && 0 === xAxisMap.size || yAxisMap && 0 === yAxisMap.size) {
      if (this.enableRemain) return;
      this.hide();
    } else xAxisMap && xAxisMap.size && this._setAllAxisValues(xAxisMap, {
      x,
      y
    }, "xField"), yAxisMap && yAxisMap.size && this._setAllAxisValues(yAxisMap, {
      x,
      y
    }, "yField"), this.layoutByValue();
  }
  layoutByValue(enableRemain) {
    if (!this.enable) return;
    const series2 = getFirstSeries(this._regions, "cartesian");
    series2 && (layoutByValue(this._stateByField, series2, this.getLayoutStartPoint(), null != enableRemain ? enableRemain : this.enableRemain), Object.keys(this._stateByField).forEach((field5) => {
      this._layoutByField(field5);
    }));
  }
  _layoutByField(field5) {
    const { cacheInfo, attributes, labelsComp, bandSize, coordKey } = this._stateByField[field5];
    if (!attributes || !cacheInfo || cacheInfo._isCache && this.enableRemain) return;
    const { coord, labels, visible, labelsTextStyle } = cacheInfo;
    if (visible) {
      const positionAttribute = layoutCrosshair(this._stateByField[field5]);
      this._updateCrosshairByField(field5, positionAttribute), Object.keys(labels).forEach((labelKey) => {
        var _a;
        if (labels[labelKey].visible) {
          const updateAttrs = Object.assign(Object.assign(Object.assign({
            [coordKey]: coord + bandSize / 2
          }, labels[labelKey]), attributes.label), {
            textStyle: Object.assign(Object.assign({}, null === (_a = attributes.label) || void 0 === _a ? void 0 : _a.textStyle), labelsTextStyle[labelKey]),
            zIndex: this.labelZIndex,
            visible: true
          });
          this._updateCrosshairLabel(labelsComp[labelKey], updateAttrs, (label) => {
            label.name = `crosshair-${field5.replace("Field", "")}-${labelKey}-label`, labelsComp[labelKey] = label;
          });
        } else labelsComp[labelKey] && labelsComp[labelKey].hideAll();
      });
    } else this._hideByField(field5);
  }
  _updateCrosshairByField(field5, positionAttribute) {
    const container2 = this.getContainer(), { attributes } = this._stateByField[field5];
    let { crosshairComp } = this._stateByField[field5];
    if (crosshairComp) crosshairComp.setAttributes(positionAttribute);
    else {
      const style = attributes.style;
      "line" === attributes.type ? crosshairComp = new LineCrosshair(Object.assign(Object.assign({}, positionAttribute), {
        lineStyle: style,
        zIndex: this.gridZIndex + 1,
        disableTriggerEvent: this._option.disableTriggerEvent,
        pickable: false
      })) : "rect" === attributes.type && (crosshairComp = new RectCrosshair(Object.assign(Object.assign({}, positionAttribute), {
        rectStyle: style,
        zIndex: this.gridZIndex,
        disableTriggerEvent: this._option.disableTriggerEvent,
        pickable: false
      }))), null == container2 || container2.add(crosshairComp), this._stateByField[field5].crosshairComp = crosshairComp;
    }
  }
};
CartesianCrossHair.specKey = "crosshair", CartesianCrossHair.type = ComponentTypeEnum.cartesianCrosshair;
var registerCartesianCrossHair = () => {
  Factory2.registerComponent(CartesianCrossHair.type, CartesianCrossHair);
};

// node_modules/@visactor/vchart/esm/component/crosshair/utils/polar.js
var layoutByValue2 = (stateByField, series2, enableRemain = false) => {
  Object.keys(stateByField).forEach((field5) => {
    const { attributes, currentValue, cacheInfo, coordKey } = stateByField[field5];
    if (attributes) {
      const isVisible2 = !!currentValue.size, useCache = enableRemain && !isVisible2 && isValid_default(cacheInfo), newInfo = useCache ? cacheInfo : {
        coord: 0,
        axis: null,
        visible: isVisible2,
        coordRange: [0, 0],
        sizeRange: [0, 0],
        labels: {
          all: {
            visible: false,
            text: "",
            offset: 0
          }
        }
      };
      if (cacheInfo && (cacheInfo._isCache = useCache), "valueField" === field5 && (newInfo.sides = series2.angleAxisHelper.getScale(0).domain().length), currentValue.forEach(({ axis: axis2, datum: value = "" }) => {
        var _a;
        const niceLabelFormatter = axis2.niceLabelFormatter;
        if ((null === (_a = attributes.label) || void 0 === _a ? void 0 : _a.visible) && (newInfo.labels.all.visible = true, newInfo.labels.all.defaultFormatter = niceLabelFormatter, newInfo.labels.all.text = value, newInfo.labels.all.offset = getAxisLabelOffset(axis2.getSpec())), "categoryField" === field5) {
          const angle2 = series2.angleAxisHelper.dataToPosition([value]), bandSize = series2.angleAxisHelper.getBandwidth(0), radius = axis2.getOuterRadius();
          newInfo.coord = angle2, newInfo.coordRange = [angle2 - bandSize / 2, angle2 + bandSize / 2], newInfo.sizeRange = [radius, radius];
        } else {
          const angle2 = axis2.startAngle, radius = series2.radiusAxisHelper.dataToPosition([value]);
          newInfo.coord = radius, newInfo.coordRange = [radius, radius], newInfo.sizeRange = [angle2, angle2];
        }
        newInfo.axis = axis2;
      }), newInfo && !useCache && newInfo.labels.all.visible && attributes && attributes.label) {
        const label = newInfo.labels.all, { formatMethod, formatter } = attributes.label, { formatFunc, args } = getFormatFunction(formatMethod, formatter, label.text, {
          label: label.text,
          orient: coordKey
        });
        formatFunc ? label.text = formatFunc(...args) : label.defaultFormatter && (label.text = label.defaultFormatter(label.text));
      }
      stateByField[field5].cacheInfo = newInfo;
    }
  });
};
var layoutCrosshair2 = (stateItem, layoutStartPoint, smooth) => {
  const { cacheInfo, coordKey, attributes } = stateItem, { axis: axis2, coord, sizeRange, coordRange } = cacheInfo, axisCenter = axis2.getCenter(), center2 = {
    x: axisCenter.x + layoutStartPoint.x,
    y: axisCenter.y + layoutStartPoint.y
  };
  if ("angle" === coordKey) {
    return "sector" === ("rect" === attributes.type ? "sector" : "line") ? {
      center: center2,
      innerRadius: axis2.getInnerRadius(),
      radius: axis2.getOuterRadius(),
      startAngle: coordRange[0],
      endAngle: coordRange[1]
    } : {
      start: polarToCartesian(center2, axis2.getInnerRadius(), coord),
      end: polarToCartesian(center2, axis2.getOuterRadius(), coord)
    };
  }
  const startAngle = axis2.startAngle, endAngle = axis2.endAngle, sides = cacheInfo.sides;
  let polygonRadius = coord;
  if (!smooth) {
    const axisCenter2 = axis2.getCenter(), point6 = axis2.coordToPoint({
      angle: sizeRange[0],
      radius: coord
    }), curAngle = getAngleByPoint(axisCenter2, point6), stepAngle = (endAngle - startAngle) / sides, index = Math.floor((curAngle - startAngle) / stepAngle), preAngle = index * stepAngle + startAngle, nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle), prePoint = polarToCartesian(axisCenter2, coord, preAngle), nextPoint = polarToCartesian(axisCenter2, coord, nextAngle), insertPoint = getIntersectPoint([nextPoint.x, nextPoint.y], [prePoint.x, prePoint.y], [axisCenter2.x, axisCenter2.y], [point6.x, point6.y]);
    insertPoint && (polygonRadius = clamp_default(PointService.distancePN(point6, insertPoint[0], insertPoint[1]) + coord, axis2.getInnerRadius(), axis2.getOuterRadius()));
  }
  return {
    center: center2,
    startAngle,
    endAngle,
    radius: polygonRadius,
    sides
  };
};

// node_modules/@visactor/vchart/esm/component/crosshair/polar.js
var PolarCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => s2.categoryField && false !== s2.categoryField.visible || s2.valueField && false !== s2.valueField.visible);
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.polarCrosshair, this.name = ComponentTypeEnum.polarCrosshair, this._stateByField = {
      categoryField: {
        coordKey: "angle",
        anotherAxisKey: "radius",
        currentValue: /* @__PURE__ */ new Map(),
        labelsComp: {
          all: null
        }
      },
      valueField: {
        coordKey: "radius",
        anotherAxisKey: "angle",
        currentValue: /* @__PURE__ */ new Map(),
        labelsComp: {
          all: null
        }
      }
    };
  }
  setAxisValue(datum, axis2) {
    "radius" === axis2.getOrient() ? this._stateByField.valueField.currentValue.set(axis2.getSpecIndex(), {
      datum,
      axis: axis2
    }) : this._stateByField.categoryField.currentValue.set(axis2.getSpecIndex(), {
      datum,
      axis: axis2
    });
  }
  _findAllAxisContains(relativeX, relativeY) {
    const angleAxisMap = this._getAxisInfoByField("category"), radiusAxisMap = this._getAxisInfoByField("value");
    return {
      angleAxisMap: this._filterAxisByPoint(angleAxisMap, relativeX, relativeY),
      radiusAxisMap: this._filterAxisByPoint(radiusAxisMap, relativeX, relativeY)
    };
  }
  _getDatumAtPoint(axis2, point6) {
    const { x: axisStartX, y: axisStartY } = axis2.getLayoutStartPoint(), { x, y } = this.getLayoutStartPoint();
    return axis2.positionToData({
      x: point6.x - (axisStartX - x),
      y: point6.y - (axisStartY - y)
    });
  }
  _layoutCrosshair(relativeX, relativeY, tooltipData, activeType) {
    let x = relativeX, y = relativeY;
    if (tooltipData && tooltipData.length) {
      if ("dimension" === activeType) {
        const dimensionInfo = tooltipData[0];
        if (dimensionInfo.axis) {
          const triggerCoord = dimensionInfo.axis.pointToCoord({
            x,
            y
          }), coord = "radius" === dimensionInfo.axis.getOrient() ? {
            radius: dimensionInfo.position,
            angle: triggerCoord.angle
          } : {
            radius: triggerCoord.radius,
            angle: dimensionInfo.position
          }, uniformPos = dimensionInfo.axis.coordToPoint(coord);
          x = uniformPos.x, y = uniformPos.y;
        }
      } else if ("mark" === activeType) {
        const dimensionData = tooltipData[0], pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        x = pos.x, y = pos.y;
      }
    }
    this.clearAxisValue();
    const { angleAxisMap, radiusAxisMap } = this._findAllAxisContains(x, y);
    if (0 !== angleAxisMap.size || 0 !== radiusAxisMap.size) angleAxisMap && this._setAllAxisValues(angleAxisMap, {
      x,
      y
    }, "categoryField"), radiusAxisMap && this._setAllAxisValues(radiusAxisMap, {
      x,
      y
    }, "valueField"), this.layoutByValue();
    else {
      if (this.enableRemain) return;
      this.hide();
    }
  }
  layoutByValue(enableRemain) {
    if (!this.enable) return;
    const series2 = getFirstSeries(this._regions, "polar");
    series2 && (layoutByValue2(this._stateByField, series2, null != enableRemain ? enableRemain : this.enableRemain), Object.keys(this._stateByField).forEach((field5) => {
      this._layoutByField(field5);
    }));
  }
  _layoutByField(fieldName) {
    var _a, _b, _c;
    const { cacheInfo, attributes, crosshairComp, labelsComp, coordKey } = this._stateByField[fieldName];
    if (!cacheInfo || cacheInfo._isCache && this.enableRemain) return;
    const container2 = this.getContainer(), { visible, labels, coord, sizeRange, axis: axis2 } = cacheInfo;
    if (visible) {
      const layoutStartPoint = this.getLayoutStartPoint(), smooth = null === (_b = null === (_a = this._spec.valueField) || void 0 === _a ? void 0 : _a.line) || void 0 === _b ? void 0 : _b.smooth, positionAttrs = layoutCrosshair2(this._stateByField[fieldName], layoutStartPoint, smooth);
      if (crosshairComp) crosshairComp.setAttributes(positionAttrs);
      else {
        let crosshair2;
        if ("angle" === coordKey) {
          const crosshairType = "rect" === attributes.type ? "sector" : "line";
          "line" === crosshairType ? crosshair2 = new LineCrosshair(Object.assign(Object.assign({}, positionAttrs), {
            lineStyle: attributes.style,
            zIndex: this.gridZIndex,
            pickable: false
          })) : "sector" === crosshairType && (crosshair2 = new SectorCrosshair(Object.assign(Object.assign({}, positionAttrs), {
            sectorStyle: attributes.style,
            zIndex: this.gridZIndex,
            pickable: false
          })));
        } else {
          crosshair2 = "polygon" === (smooth ? "circle" : "polygon") ? new PolygonCrosshair(Object.assign(Object.assign({}, positionAttrs), {
            lineStyle: attributes.style,
            zIndex: this.gridZIndex + 1
          })) : new CircleCrosshair(Object.assign(Object.assign({}, positionAttrs), {
            lineStyle: attributes.style,
            zIndex: this.gridZIndex
          }));
        }
        this._stateByField[fieldName].crosshairComp = crosshair2, container2.add(crosshair2);
      }
      const label = labels.all;
      if (label.visible) {
        const axisCenter = axis2.getCenter(), center2 = {
          x: axisCenter.x + layoutStartPoint.x,
          y: axisCenter.y + layoutStartPoint.y
        }, orient = "angle" === coordKey ? angleLabelOrientAttribute(coord) : radiusLabelOrientAttribute(axis2.startAngle), point6 = "angle" === coordKey ? polarToCartesian(center2, sizeRange[1] + label.offset, coord) : polarToCartesian(center2, positionAttrs.radius, axis2.startAngle), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, point6), attributes.label), label), {
          textStyle: Object.assign(Object.assign({}, null === (_c = attributes.label) || void 0 === _c ? void 0 : _c.textStyle), {
            textAlign: orient.align,
            textBaseline: orient.baseline
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(labelsComp.all, labelAttrs, (label2) => {
          label2.name = `crosshair-${coordKey}-label`, labelsComp.all = label2;
        });
      } else labelsComp.all && labelsComp.all.hideAll();
    }
  }
};
PolarCrossHair.specKey = "crosshair", PolarCrossHair.type = ComponentTypeEnum.polarCrosshair;
var registerPolarCrossHair = () => {
  Factory2.registerComponent(PolarCrossHair.type, PolarCrossHair);
};

// node_modules/@visactor/vchart/esm/component/data-zoom/util.js
var lockStatisticsFilter = (statisticsData, op) => {
  const { getNewDomain, isContinuous: isContinuous2, field: field5, originalFields } = op, datumField = field5(), newDomain = getNewDomain();
  if (isNil_default(newDomain) || isNil_default(datumField)) return statisticsData;
  const fields2 = originalFields(), realField = isArray_default(datumField) ? datumField[0] : datumField;
  return statisticsData[realField] && fields2 && fields2[realField] && fields2[realField].lockStatisticsByDomain && !isContinuous2() && (statisticsData[realField].values = newDomain), statisticsData;
};
var dataFilterWithNewDomain = (data, op) => {
  const { getNewDomain, isContinuous: isContinuous2, field: field5 } = op, datumField = field5(), newDomain = getNewDomain();
  if (isNil_default(newDomain) || isNil_default(datumField)) return data;
  if (0 === newDomain.length) return [];
  const domainMap = {};
  newDomain.forEach((d) => {
    domainMap[d] || (domainMap[d] = 1);
  });
  let filter2 = null;
  return filter2 = isContinuous2() ? (d) => {
    let flag = false;
    return array(datumField).every((field6) => {
      d[field6] >= newDomain[0] && d[field6] <= last(newDomain) && (flag = true);
    }), flag;
  } : (d) => {
    let flag = false;
    return array(datumField).every((field6) => {
      (domainMap[d[field6] + ""] || domainMap[d[field6]]) && (flag = true);
    }), flag;
  }, data.filter(filter2);
};
var dataFilterComputeDomain = (data, op) => {
  const { stateFields, valueFields, dataCollection } = op.input, { stateField, valueField } = op.output, resultObj = {}, resultData = [];
  return dataCollection.forEach((dv, i) => {
    var _a;
    if (isNil_default(stateFields[i])) return;
    const stateFieldInfo = null === (_a = dv.getFields()) || void 0 === _a ? void 0 : _a[stateFields[i]];
    stateFieldInfo && stateFieldInfo.lockStatisticsByDomain && stateFieldInfo.domain.forEach((d) => {
      resultObj[d] = 0;
    }), dv.latestData.forEach((d) => {
      array(stateFields[i]).forEach((state) => {
        isNil_default(d[state]) || (isNil_default(resultObj[d[state]]) && (resultObj[d[state]] = 0), isNil_default(valueFields[i]) || (resultObj[d[state]] += isNaN(parseFloat(d[valueFields[i]])) ? 1 : parseFloat(d[valueFields[i]])));
      });
    });
  }), Object.keys(resultObj).forEach((d, i) => {
    const res = {
      [stateField]: d
    };
    valueField && (res[valueField] = resultObj[d]), resultData.push(res);
  }), resultData;
};

// node_modules/@visactor/vchart/esm/component/data-zoom/data-filter-base-component.js
var DataFilterBaseComponent = class extends BaseComponent {
  get relatedAxisComponent() {
    return this._relatedAxisComponent;
  }
  setStartAndEnd(start, end, rangeMode = ["percent", "percent"]) {
    const [startMode = "percent", endMode = "percent"] = rangeMode, startPercent = "percent" === startMode ? start : this.dataToStatePoint(start), endPercent = "percent" === endMode ? end : this.dataToStatePoint(end);
    this._handleChange(startPercent, endPercent, true);
  }
  enableInteraction() {
    this._activeRoam = true;
  }
  disableInteraction() {
    this._activeRoam = false;
  }
  zoomIn(location) {
    this._handleChartZoom({
      zoomDelta: 1.2,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  zoomOut(location) {
    this._handleChartZoom({
      zoomDelta: 0.8,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  _handleChange(start, end, updateComponent) {
    var _a, _b;
    null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.zoomLock) && void 0 !== _b && _b || end - start !== this._spanCache && (end - start < this._minSpan || end - start > this._maxSpan) ? this._shouldChange = false : (this._shouldChange = true, this._spanCache = end - start);
  }
  _isReverse() {
    const axis2 = this._relatedAxisComponent;
    if (!axis2) return false;
    const axisScale = axis2.getScale();
    return axisScale.range()[0] > axisScale.range()[1] && (!axis2.getInverse() || this._isHorizontal);
  }
  _updateRangeFactor(tag) {
    const axisScale = this._relatedAxisComponent.getScale(), reverse = this._isReverse(), newRangeFactor = reverse ? [1 - this._end, 1 - this._start] : [this._start, this._end];
    if (reverse) switch (tag) {
      case "startHandler":
        axisScale.rangeFactorEnd(newRangeFactor[1]);
        break;
      case "endHandler":
        axisScale.rangeFactorStart(newRangeFactor[0]);
        break;
      default:
        axisScale.rangeFactorStart(newRangeFactor[0], true), axisScale.rangeFactorEnd(newRangeFactor[1]);
    }
    else switch (tag) {
      case "startHandler":
        axisScale.rangeFactorStart(newRangeFactor[0]);
        break;
      case "endHandler":
        axisScale.rangeFactorEnd(newRangeFactor[1]);
        break;
      default:
        axisScale.rangeFactorEnd(newRangeFactor[1], true), axisScale.rangeFactorStart(newRangeFactor[0]);
    }
    const newFactor = axisScale.rangeFactor();
    newFactor ? (this._start = reverse ? 1 - newFactor[1] : newFactor[0], this._end = reverse ? 1 - newFactor[0] : newFactor[1]) : (this._start = 0, this._end = 1);
  }
  get visible() {
    return this._visible;
  }
  constructor(spec, options) {
    super(spec, options), this.layoutType = "none", this._orient = "left", this._cacheVisibility = void 0, this._dataUpdating = false, this._shouldChange = true, this._stateField = "x", this._activeRoam = true, this._zoomAttr = {
      enable: true,
      rate: 1,
      focus: true
    }, this._dragAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this._scrollAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this.effect = {
      onZoomChange: (tag) => {
        var _a, _b;
        const axis2 = this._relatedAxisComponent;
        if (axis2 && "axis" === this._filterMode) {
          const axisScale = axis2.getScale(), axisSpec = axis2.getSpec();
          this._auto && this._getAxisBandSize(axisSpec) && this._spec.ignoreBandSize && (axisScale.bandwidth("auto"), axisScale.maxBandwidth("auto"), axisScale.minBandwidth("auto")), this._updateRangeFactor(tag), this._auto && (null === (_b = null === (_a = this._component) || void 0 === _a ? void 0 : _a.setStartAndEnd) || void 0 === _b || _b.call(_a, this._start, this._end)), axis2.effect.scaleUpdate({
            value: "force"
          });
        } else eachSeries(this._regions, (s2) => {
          var _a2;
          null === (_a2 = s2.getViewData()) || void 0 === _a2 || _a2.markRunning();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }), eachSeries(this._regions, (s2) => {
          s2.reFilterViewData();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._visible = true, this._handleStateChange = (startValue, endValue, tag) => {
      var _a, _b;
      return this._startValue = startValue, this._endValue = endValue, this._newDomain = this._parseDomainFromState(this._startValue, this._endValue), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a, tag), true;
    }, this._handleChartZoom = (params2, e) => {
      var _a, _b;
      if (!this._activeRoam || this._zoomAttr.filter && !this._zoomAttr.filter(params2, e)) return;
      const { zoomDelta, zoomX, zoomY } = params2, { x, y } = this._regions[0].getLayoutStartPoint(), { width, height } = this._regions[0].getLayoutRect(), delta = Math.abs(this._start - this._end), zoomRate = null !== (_b = null === (_a = this._spec.roamZoom) || void 0 === _a ? void 0 : _a.rate) && void 0 !== _b ? _b : 1;
      if (delta >= 1 && zoomDelta < 1) return;
      if (delta <= 0.01 && zoomDelta > 1) return;
      const focusLoc = this._isHorizontal ? zoomX : zoomY, totalValue = delta * (zoomDelta - 1) * zoomRate;
      let startValue = totalValue / 2, endValue = totalValue / 2;
      if (focusLoc) {
        const startLoc = this._isHorizontal ? x : y, endLoc = this._isHorizontal ? width : height;
        startValue = Math.abs(startLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue, endValue = Math.abs(endLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue;
      }
      const start = clamp_default(this._start + startValue, 0, 1), end = clamp_default(this._end - endValue, 0, 1);
      this._handleChange(Math.min(start, end), Math.max(start, end), true);
    }, this._handleChartScroll = (params2, e) => {
      var _a;
      if (!this._activeRoam || this._scrollAttr.filter && !this._scrollAttr.filter(params2, e)) return false;
      const { scrollX, scrollY } = params2;
      let value = this._isHorizontal ? scrollX : scrollY;
      const active = this._isHorizontal ? abs(scrollX / scrollY) >= 0.5 : abs(scrollY / scrollX) >= 0.5;
      this._scrollAttr.reverse || (value = -value), active && this._handleChartMove(value, null !== (_a = this._scrollAttr.rate) && void 0 !== _a ? _a : 1);
      const hasChange = 0 !== this._start && 1 !== this._end;
      return active && hasChange;
    }, this._handleChartDrag = (delta, e) => {
      var _a;
      if (!this._activeRoam || this._dragAttr.filter && !this._dragAttr.filter(delta, e)) return;
      const [dx, dy] = delta;
      let value = this._isHorizontal ? dx : dy;
      this._dragAttr.reverse && (value = -value), this._handleChartMove(value, null !== (_a = this._dragAttr.rate) && void 0 !== _a ? _a : 1);
    }, this._handleChartMove = (value, rate) => {
      const totalValue = this._isHorizontal ? this.getLayoutRect().width : this.getLayoutRect().height;
      if (Math.abs(value) >= 1e-6) {
        if (value > 0 && this._end < 1) {
          const moveDelta = Math.min(1 - this._end, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        } else if (value < 0 && this._start > 0) {
          const moveDelta = Math.max(-this._start, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        }
      }
      return false;
    }, this._orient = getOrient(spec), this._isHorizontal = "horizontal" === getDirectionByOrient(this._orient);
  }
  created() {
    super.created(), this._setAxisFromSpec(), this._setRegionsFromSpec(), this._initEvent(), this._initData(), this._initStateScale(), this._setStateFromSpec();
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  _setAxisFromSpec() {
    if (isValid_default(this._spec.axisId) ? this._relatedAxisComponent = this._option.getComponentByUserId(this._spec.axisId) : isValid_default(this._spec.axisIndex) && (this._relatedAxisComponent = this._option.getComponentByIndex("axes", this._spec.axisIndex)), isNil_default(this._spec.field) && !this._relatedAxisComponent) {
      const axes = this._option.getComponentsByKey("axes"), sameOrientAxis = axes.find((cm) => cm._orient === this._orient);
      if (sameOrientAxis) this._relatedAxisComponent = sameOrientAxis;
      else {
        const bandAxis = axes.find((cm) => !isContinuous(cm.getScale().type));
        this._relatedAxisComponent = bandAxis;
      }
    }
    this._relatedAxisComponent && "axis" === this._filterMode && (this._relatedAxisComponent.autoIndentOnce = true);
  }
  _setRegionsFromSpec() {
    var _a, _b;
    this._regions = this._relatedAxisComponent ? this._relatedAxisComponent.getRegions() : this._option.getAllRegions();
    const bindSeriesFilter = this._relatedAxisComponent ? null === (_b = (_a = this._relatedAxisComponent).getBindSeriesFilter) || void 0 === _b ? void 0 : _b.call(_a) : null;
    if (isValid_default(bindSeriesFilter) && (isValid_default(bindSeriesFilter.userId) && (this._seriesUserId = array(bindSeriesFilter.userId)), isValid_default(bindSeriesFilter.specIndex) && (this._seriesIndex = array(bindSeriesFilter.specIndex))), isValid_default(this._spec.seriesId)) {
      const specSeriesId = array(this._spec.seriesId);
      this._seriesUserId ? this._seriesUserId = this._seriesUserId.filter((s2) => specSeriesId.includes(s2)) : this._seriesUserId = specSeriesId;
    }
    if (isValid_default(this._spec.seriesIndex)) {
      const specSeriesIndex = array(this._spec.seriesIndex);
      this._seriesIndex ? this._seriesIndex = this._seriesIndex.filter((s2) => specSeriesIndex.includes(s2)) : this._seriesIndex = specSeriesIndex;
    }
    if (isValid_default(this._spec.regionIndex)) {
      const regionsFromSpec = this._option.getRegionsInIndex(array(this._spec.regionIndex));
      this._regions = this._regions.filter((r) => regionsFromSpec.includes(r));
    } else if (isValid_default(this._spec.regionId)) {
      const ids = array(this._spec.regionId);
      this._regions = ids.length ? this._regions.filter((r) => ids.includes(r.id)) : [];
    } else ;
  }
  onDataUpdate() {
    var _a;
    const domain = this._computeDomainOfStateScale(isContinuous(this._stateScale.type));
    this._stateScale.domain(domain, false), this._handleChange(this._start, this._end, true), this._spec.auto && !isEqual(this._domainCache, domain) && (this._domainCache = domain, this._dataUpdating = true, null === (_a = this.getChart()) || void 0 === _a || _a.setLayoutTag(true, null, false));
  }
  _computeDomainOfStateScale(isContinuous2) {
    if (this._spec.customDomain) return this._spec.customDomain;
    const domain = this._data.getLatestData().map((d) => d[this._stateField]);
    if (isContinuous2) {
      const domainNum = domain.map((n) => 1 * n);
      return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [-1 / 0, 1 / 0];
    }
    return domain;
  }
  _initEvent() {
    this._initCommonEvent();
  }
  _initData() {
    const dataCollection = [], stateFields = [], valueFields = [];
    if (this._relatedAxisComponent) {
      const originalStateFields = {};
      eachSeries(this._regions, (s2) => {
        var _a, _b;
        const xAxisHelper = "cartesian" === s2.coordinate ? s2.getXAxisHelper() : "polar" === s2.coordinate ? s2.angleAxisHelper : null, yAxisHelper = "cartesian" === s2.coordinate ? s2.getYAxisHelper() : "polar" === s2.coordinate ? s2.radiusAxisHelper : null;
        if (!xAxisHelper || !yAxisHelper) return;
        const stateAxisHelper = xAxisHelper.getAxisId() === this._relatedAxisComponent.id ? xAxisHelper : yAxisHelper.getAxisId() === this._relatedAxisComponent.id ? yAxisHelper : this._isHorizontal ? xAxisHelper : yAxisHelper, valueAxisHelper = stateAxisHelper === xAxisHelper ? yAxisHelper : xAxisHelper, isValidateValueAxis = isContinuous(valueAxisHelper.getScale(0).type), isValidateStateAxis = isContinuous(stateAxisHelper.getScale(0).type);
        dataCollection.push(s2.getRawData());
        const seriesSpec = s2.getSpec(), xField = "cartesian" === s2.coordinate ? array(seriesSpec.xField) : array(null !== (_a = seriesSpec.angleField) && void 0 !== _a ? _a : seriesSpec.categoryField), yField = "cartesian" === s2.coordinate ? array(seriesSpec.yField) : array(null !== (_b = seriesSpec.radiusField) && void 0 !== _b ? _b : seriesSpec.valueField);
        if (originalStateFields[s2.id] = "link" === s2.type ? ["from_xField"] : stateAxisHelper === xAxisHelper ? xField : yField, isValidateStateAxis ? stateFields.push(originalStateFields[s2.id]) : stateFields.push(originalStateFields[s2.id][0]), this._valueField) {
          const valueField = "link" === s2.type ? ["from_yField"] : valueAxisHelper === xAxisHelper ? xField : yField;
          isValidateValueAxis && valueFields.push(...valueField);
        }
      }, {
        userId: this._seriesUserId,
        specIndex: this._seriesIndex
      }), this._originalStateFields = originalStateFields;
    } else eachSeries(this._regions, (s2) => {
      dataCollection.push(s2.getRawData()), stateFields.push(this._field), this._valueField && valueFields.push(this._spec.valueField);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
    const { dataSet } = this._option;
    registerDataSetInstanceParser(dataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(dataSet, "dataFilterComputeDomain", dataFilterComputeDomain);
    const data = new DataView(dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.transform({
      type: "dataFilterComputeDomain",
      options: {
        input: {
          dataCollection,
          stateFields,
          valueFields
        },
        output: {
          stateField: this._stateField,
          valueField: this._valueField
        }
      }
    }, false), this._data = new CompilableData(this._option, data), data.reRunAllTransform(), dataSet.multipleDataViewAddListener(dataCollection, "change", this._handleDataCollectionChange.bind(this));
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), true === this._spec.roamZoom || this._spec.roamZoom ? this._zoomAttr = merge({}, this._zoomAttr, this._spec.roamZoom) : this._zoomAttr.enable = false, true === this._spec.roamDrag || this._spec.roamDrag ? this._dragAttr = merge({}, this._dragAttr, this._spec.roamDrag) : this._dragAttr.enable = false, true === this._spec.roamScroll || this._spec.roamScroll ? this._scrollAttr = merge({}, this._scrollAttr, this._spec.roamScroll) : this._scrollAttr.enable = false, this._field = this._spec.field, this._width = this._computeWidth(), this._height = this._computeHeight(), this._visible = null === (_a = this._spec.visible) || void 0 === _a || _a;
  }
  statePointToData(state) {
    const scale4 = this._stateScale, domain = scale4.domain();
    if (isContinuous(scale4.type)) return this._isReverse() ? domain[0] + (last(domain) - domain[0]) * (1 - state) : domain[0] + (last(domain) - domain[0]) * state;
    let range2 = scale4.range();
    this._isReverse() && (range2 = range2.slice().reverse());
    const posInRange = range2[0] + (last(range2) - range2[0]) * state;
    return scale4.invert(posInRange);
  }
  dataToStatePoint(data) {
    const scale4 = this._stateScale, pos = scale4.scale(data);
    let range2 = scale4.range();
    return !this._isHorizontal && isContinuous(scale4.type) && (range2 = range2.slice().reverse()), (pos - range2[0]) / (last(range2) - range2[0]);
  }
  _modeCheck(statePoint, mode) {
    return "start" === statePoint ? "percent" === mode && isValid_default(this._spec.start) || "value" === mode && isValid_default(this._spec.startValue) : "percent" === mode && isValid_default(this._spec.end) || "value" === mode && isValid_default(this._spec.endValue);
  }
  _setStateFromSpec() {
    var _a, _b;
    let start, end;
    if (this._auto = !!this._spec.auto, this._spec.rangeMode) {
      const [startMode, endMode] = this._spec.rangeMode;
      this._modeCheck("start", startMode) && this._modeCheck("end", endMode) && (start = "percent" === startMode ? this._spec.start : this.dataToStatePoint(this._spec.startValue), end = "percent" === endMode ? this._spec.end : this.dataToStatePoint(this._spec.endValue));
    } else start = this._spec.start ? this._spec.start : this._spec.startValue ? this.dataToStatePoint(this._spec.startValue) : 0, end = this._spec.end ? this._spec.end : this._spec.endValue ? this.dataToStatePoint(this._spec.endValue) : 1;
    this._startValue = this.statePointToData(start), this._endValue = this.statePointToData(end), this._start = start, this._end = end, this._minSpan = null !== (_a = this._spec.minSpan) && void 0 !== _a ? _a : 0, this._maxSpan = null !== (_b = this._spec.maxSpan) && void 0 !== _b ? _b : 1, isContinuous(this._stateScale.type) && this._stateScale.domain()[0] !== last(this._stateScale.domain()) && (this._spec.minValueSpan && (this._minSpan = this._spec.minValueSpan / (last(this._stateScale.domain()) - this._stateScale.domain()[0])), this._spec.maxValueSpan && (this._maxSpan = this._spec.maxValueSpan / (last(this._stateScale.domain()) - this._stateScale.domain()[0]))), this._minSpan = Math.max(0, this._minSpan), this._maxSpan = Math.min(this._maxSpan, 1), this._relatedAxisComponent && "axis" === this._filterMode || 0 === this._start && 1 === this._end || (this._newDomain = this._parseDomainFromState(this._startValue, this._endValue));
  }
  _parseFieldOfSeries(s2) {
    var _a;
    return null === (_a = this._originalStateFields) || void 0 === _a ? void 0 : _a[s2.id];
  }
  _initStateScale() {
    const defaultRange = [0, 1];
    if (this._relatedAxisComponent) {
      const scale4 = this._relatedAxisComponent.getScale(), isContinuousScale = isContinuous(scale4.type), domain = this._computeDomainOfStateScale(isContinuousScale);
      if (this._stateScale = scale4.clone(), isContinuousScale) {
        const domainNum = domain.map((n) => 1 * n);
        this._stateScale.domain(domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [0, 1], true).range(defaultRange);
      } else this._stateScale.domain(domain, true).range(defaultRange);
    } else this._stateScale = new BandScale(), this._stateScale.domain(this._computeDomainOfStateScale(), true).range(defaultRange);
  }
  init(option) {
    super.init(option), this._addTransformToSeries(), 0 === this._start && 1 === this._end || this.effect.onZoomChange();
  }
  _addTransformToSeries() {
    this._relatedAxisComponent && "axis" === this._filterMode || (registerDataSetInstanceTransform(this._option.dataSet, "dataFilterWithNewDomain", dataFilterWithNewDomain), registerDataSetInstanceTransform(this._option.dataSet, "lockStatisticsFilter", lockStatisticsFilter), eachSeries(this._regions, (s2) => {
      s2.getViewDataStatistics().transform({
        type: "lockStatisticsFilter",
        options: {
          originalFields: () => s2.getViewDataStatistics().getFields(),
          getNewDomain: () => this._newDomain,
          field: () => {
            var _a;
            return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s2);
          },
          isContinuous: () => isContinuous(this._stateScale.type)
        },
        level: 1
      }, false), s2.addViewDataFilter({
        type: "dataFilterWithNewDomain",
        options: {
          getNewDomain: () => this._newDomain,
          field: () => {
            var _a;
            return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s2);
          },
          isContinuous: () => isContinuous(this._stateScale.type)
        },
        level: TransformLevel.dataZoomFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }));
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._marks.forEach((g) => {
      g.getMarks().forEach((m4) => {
        this.initMarkStyleWithSpec(m4, this._spec[m4.name]);
      });
    });
  }
  changeRegions() {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  _parseDomainFromState(startValue, endValue) {
    if (isContinuous(this._stateScale.type)) return [Math.min(endValue, startValue), Math.max(endValue, startValue)];
    const allDomain = this._stateScale.domain(), startIndex = allDomain.indexOf(startValue), endIndex = allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
  }
  _initCommonEvent() {
    var _a, _b, _c, _d, _e, _f, _g;
    const option = {
      delayType: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType) && void 0 !== _b ? _b : "throttle",
      delayTime: isValid_default(null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayType) ? null !== (_e = null === (_d = this._spec) || void 0 === _d ? void 0 : _d.delayTime) && void 0 !== _e ? _e : 30 : 0,
      realTime: null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.realTime) || void 0 === _g || _g,
      allowComponentZoom: true
    };
    this._zoomAttr.enable && this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom, option), this._scrollAttr.enable && this.initScrollEventOfRegions(this._regions, null, this._handleChartScroll, option), this._dragAttr.enable && this.initDragEventOfRegions(this._regions, null, this._handleChartDrag, option);
  }
  updateLayoutAttribute() {
    this._visible && this._createOrUpdateComponent(), super.updateLayoutAttribute();
  }
  _autoVisible(isShown) {
    if (!this._auto) return;
    isShown ? this.show() : this.hide();
    const sizeKey = this._isHorizontal ? "height" : "width";
    this.layout.setLayoutRect({
      [sizeKey]: isShown ? this[`_${sizeKey}`] : 0
    }, {
      [sizeKey]: AttributeLevel.Built_In
    });
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    super.onLayoutStart(layoutRect, viewRect, ctx);
    const isShown = this._autoUpdate(layoutRect);
    this._autoVisible(isShown), this._dataUpdating = false;
  }
  onLayoutEnd(ctx) {
    const isShown = !(0 === this._start && 1 === this._end);
    this._autoVisible(isShown), super.onLayoutEnd(ctx);
  }
  getBoundsInRect(rect) {
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    };
    return this._isHorizontal ? (result2.y2 = result2.y1 + this._height, result2.x2 = result2.x1 + rect.width) : (result2.x2 = result2.x1 + this._width, result2.y2 = result2.y1 + rect.height), result2;
  }
  hide() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.hideAll();
  }
  show() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.showAll();
  }
  _getAxisBandSize(axisSpec) {
    const bandSize = null == axisSpec ? void 0 : axisSpec.bandSize, maxBandSize = null == axisSpec ? void 0 : axisSpec.maxBandSize, minBandSize = null == axisSpec ? void 0 : axisSpec.minBandSize;
    if (bandSize || minBandSize || maxBandSize) return {
      bandSize,
      maxBandSize,
      minBandSize
    };
  }
  _autoUpdate(rect) {
    var _a, _b, _c, _d, _e, _f;
    if (!this._auto) return this._cacheVisibility = void 0, true;
    const axis2 = this._relatedAxisComponent, axisSpec = null == axis2 ? void 0 : axis2.getSpec(), axisScale = null == axis2 ? void 0 : axis2.getScale(), bandSizeResult = this._getAxisBandSize(axisSpec);
    if (!this._dataUpdating && isDiscrete(axisScale.type) && (null == rect ? void 0 : rect.height) === (null === (_a = this._cacheRect) || void 0 === _a ? void 0 : _a.height) && (null == rect ? void 0 : rect.width) === (null === (_b = this._cacheRect) || void 0 === _b ? void 0 : _b.width) && this._fixedBandSize === (null == bandSizeResult ? void 0 : bandSizeResult.bandSize)) return this._cacheVisibility;
    let isShown = true;
    if (this._isHorizontal && (null == rect ? void 0 : rect.width) !== (null === (_c = this._cacheRect) || void 0 === _c ? void 0 : _c.width) ? axisScale.range(axis2.getInverse() ? [rect.width, 0] : [0, rect.width]) : (null == rect ? void 0 : rect.height) !== (null === (_d = this._cacheRect) || void 0 === _d ? void 0 : _d.height) && axisScale.range(axis2.getInverse() ? [0, rect.height] : [rect.height, 0]), this._cacheRect = {
      width: null == rect ? void 0 : rect.width,
      height: null == rect ? void 0 : rect.height
    }, this._fixedBandSize = null == bandSizeResult ? void 0 : bandSizeResult.bandSize, isDiscrete(axisScale.type)) {
      bandSizeResult && (this._start || this._end) && (this.type === ComponentTypeEnum.scrollBar && (this._start = 0, this._end = 1), this._updateRangeFactor());
      const [start, end] = null !== (_e = axisScale.rangeFactor()) && void 0 !== _e ? _e : [];
      isShown = (!isNil_default(start) || !isNil_default(end)) && !(0 === start && 1 === end);
    } else {
      const [start, end] = null !== (_f = axisScale.rangeFactor()) && void 0 !== _f ? _f : [this._start, this._end];
      isShown = !(0 === start && 1 === end);
    }
    return this.setStartAndEnd(this._start, this._end), this._cacheVisibility = isShown, isShown;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
mixin(DataFilterBaseComponent, Zoomable);

// node_modules/@visactor/vchart/esm/component/data-zoom/data-zoom/data-zoom-transformer.js
var DataZoomSpecTransformer = class extends BaseComponentSpecTransformer {
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const merge2 = (originalSpec) => {
        const result2 = mergeSpec({
          selectedBackgroundChart: {
            line: {},
            area: {}
          }
        }, this._theme, originalSpec), { selectedBackgroundChart = {} } = originalSpec, { line: line2, area: area2 } = selectedBackgroundChart;
        return line2 && false !== line2.visible && (result2.selectedBackgroundChart.line.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.line.style), {
          visible: true
        })), area2 && false !== area2.visible && (result2.selectedBackgroundChart.area.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.area.style), {
          visible: true
        })), result2;
      }, baseSpec = spec;
      newSpec = isArray_default(baseSpec) ? baseSpec.map((spec2) => merge2(spec2)) : merge2(baseSpec);
    }
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
};

// node_modules/@visactor/vchart/esm/component/data-zoom/data-zoom/data-zoom.js
var DataZoom2 = class extends DataFilterBaseComponent {
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.dataZoom, this.name = ComponentTypeEnum.dataZoom, this.transformerConstructor = DataZoomSpecTransformer, this.specKey = "dataZoom", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._isReverseCache = false, this._dataToPositionX = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, xField = this._isHorizontal ? this._stateField : this._valueField;
      return xScale.scale(datum[xField]) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionX2 = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, min3 = xScale.domain()[0];
      return xScale.scale(min3) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionY = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, yField = this._isHorizontal ? this._valueField : this._stateField;
      return yScale.scale(datum[yField]) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._dataToPositionY2 = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, min3 = yScale.domain()[0];
      return yScale.scale(min3) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._valueField = "y", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "filter";
  }
  created() {
    super.created(), this._initValueScale();
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = this._spec.roam, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode), this._backgroundSize = null !== (_b = null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 30, this._middleHandlerSize = this._computeMiddleHandlerSize(), this._width = this._computeWidth(), this._height = this._computeHeight(), isNil_default(null === (_e = null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.startHandler) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size) && (this._spec.startHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize), isNil_default(null === (_h = null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.endHandler) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size) && (this._spec.endHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize);
    const startHandlerVisble = null === (_j = this._spec.startHandler.style.visible) || void 0 === _j || _j, endHandlerVisble = null === (_k = this._spec.endHandler.style.visible) || void 0 === _k || _k;
    this._startHandlerSize = startHandlerVisble ? this._spec.startHandler.style.size : 0, this._endHandlerSize = endHandlerVisble ? this._spec.endHandler.style.size : 0;
  }
  onLayoutEnd(ctx) {
    this._updateScaleRange(), this._isReverse() && !this._isReverseCache && (this._isReverseCache = this._isReverse(), this.effect.onZoomChange()), false !== this._cacheVisibility && super.onLayoutEnd(ctx);
  }
  _initValueScale() {
    const domain = this._computeDomainOfValueScale();
    if (domain) {
      const valueScale = new LinearScale();
      valueScale.domain(domain), this._valueScale = valueScale;
    }
  }
  _updateScaleRange() {
    var _a, _b;
    const handlerSize = this._startHandlerSize + this._endHandlerSize;
    if (!this._stateScale || !this._valueScale) return;
    let stateScaleRange;
    const defaultSize = this._isHorizontal ? this.getLayoutRect().width - handlerSize : this.getLayoutRect().height - handlerSize, defaultRange = null !== (_b = null === (_a = this._relatedAxisComponent) || void 0 === _a ? void 0 : _a.getScale().range()) && void 0 !== _b ? _b : [this._startHandlerSize / 2, defaultSize + this._startHandlerSize / 2], compWidth = this._computeWidth(), compHeight = this._computeHeight();
    this._isHorizontal ? (stateScaleRange = this._visible ? [this._startHandlerSize / 2, compWidth - handlerSize + this._startHandlerSize / 2] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([compHeight - this._middleHandlerSize, 0])) : (stateScaleRange = this._visible ? [this._startHandlerSize / 2, compHeight - handlerSize + this._startHandlerSize / 2] : defaultRange, this._stateScale.range(stateScaleRange), "left" === this.layoutOrient ? this._valueScale.range([compWidth - this._middleHandlerSize, 0]) : this._valueScale.range([0, compWidth - this._middleHandlerSize])), this._component && false !== this._cacheVisibility && this._component.setAttributes({
      size: {
        width: compWidth,
        height: compHeight
      },
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      }
    });
  }
  _computeDomainOfValueScale() {
    const domain = this._data.getLatestData().map((d) => d[this._valueField]), domainNum = domain.map((n) => 1 * n);
    return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : null;
  }
  _computeMiddleHandlerSize() {
    var _a, _b, _c, _d;
    let size = 0;
    if (null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.middleHandler) || void 0 === _b ? void 0 : _b.visible) {
      const middleHandlerIconSize = null !== (_c = this._spec.middleHandler.icon.style.size) && void 0 !== _c ? _c : 8, middleHandlerBackSize = null !== (_d = this._spec.middleHandler.background.size) && void 0 !== _d ? _d : 40;
      size += Math.max(middleHandlerIconSize, middleHandlerBackSize);
    }
    return size;
  }
  _computeWidth() {
    return false === this._visible ? 0 : isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : this._backgroundSize + this._middleHandlerSize;
  }
  _computeHeight() {
    return false === this._visible ? 0 : isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? this._backgroundSize + this._middleHandlerSize : this.getLayoutRect().height;
  }
  _isScaleValid(scale4) {
    if (!scale4 || !scale4.domain()) return false;
    const domain = scale4.domain();
    return (!isContinuous(scale4.type) || domain[0] !== last(domain)) && (!isDiscrete(scale4.type) || 1 !== uniqArray(domain).length);
  }
  _getAttrs(isNeedPreview) {
    var _a, _b, _c, _d, _e;
    const spec = null !== (_a = this._spec) && void 0 !== _a ? _a : {};
    return Object.assign({
      zIndex: this.layoutZIndex,
      start: this._start,
      end: this._end,
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      },
      orient: this._orient,
      size: {
        width: this._computeWidth(),
        height: this._computeHeight()
      },
      showDetail: spec.showDetail,
      brushSelect: null !== (_b = spec.brushSelect) && void 0 !== _b && _b,
      zoomLock: null !== (_c = spec.zoomLock) && void 0 !== _c && _c,
      minSpan: this._minSpan,
      maxSpan: this._maxSpan,
      delayType: spec.delayType,
      delayTime: isValid_default(spec.delayType) ? null !== (_d = spec.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_e = spec.realTime) || void 0 === _e || _e,
      previewData: isNeedPreview && this._data.getLatestData(),
      previewPointsX: isNeedPreview && this._dataToPositionX,
      previewPointsY: isNeedPreview && this._dataToPositionY,
      tolerance: this._spec.tolerance
    }, this._getComponentAttrs(isNeedPreview));
  }
  _createOrUpdateComponent() {
    if (this._visible) {
      const xScale = this._isHorizontal ? this._stateScale : this._valueScale, yScale = this._isHorizontal ? this._valueScale : this._stateScale, isNeedPreview = this._isScaleValid(xScale) && this._isScaleValid(yScale) && false !== this._spec.showBackgroundChart, attrs = this._getAttrs(isNeedPreview);
      if (this._component) this._component.setAttributes(attrs);
      else {
        const container2 = this.getContainer();
        this._component = new DataZoom(attrs), this._isHorizontal ? isNeedPreview && this._component.setPreviewPointsY1(this._dataToPositionY2) : isNeedPreview && this._component.setPreviewPointsX1(this._dataToPositionX2), this._component.setStatePointToData((state) => this.statePointToData(state)), this._component.addEventListener("change", (e) => {
          const { start, end, tag } = e.detail;
          this._handleChange(start, end, void 0, tag);
        }), container2.add(this._component), this._updateScaleRange();
      }
    }
  }
  _handleChange(start, end, updateComponent, tag) {
    if (super._handleChange(start, end, updateComponent), this._shouldChange) {
      updateComponent && this._component && this._component.setStartAndEnd(start, end), this._start = start, this._end = end;
      const startValue = this.statePointToData(start), endValue = this.statePointToData(end);
      (isFunction_default(this._spec.updateDataAfterChange) ? this._spec.updateDataAfterChange(start, end, startValue, endValue) : this._handleStateChange(startValue, endValue, tag)) && this.event.emit(ChartEvent.dataZoomChange, {
        model: this,
        value: {
          filterData: "axis" !== this._filterMode,
          start,
          end,
          startValue: this._startValue,
          endValue: this._endValue,
          newDomain: this._newDomain
        }
      });
    }
  }
  _handleDataCollectionChange() {
    var _a;
    const data = this._data.getDataView();
    if (data.reRunAllTransform(), null === (_a = this._component) || void 0 === _a || _a.setPreviewData(data.latestData), this._valueScale) {
      const domain = this._computeDomainOfValueScale();
      domain && this._valueScale.domain(domain);
    }
  }
  _getComponentAttrs(isNeedPreview) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { middleHandler = {}, startText = {}, endText = {}, backgroundChart = {}, selectedBackgroundChart = {} } = this._spec;
    return {
      backgroundStyle: transformToGraphic(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.style),
      startHandlerStyle: transformToGraphic(null === (_b = this._spec.startHandler) || void 0 === _b ? void 0 : _b.style),
      middleHandlerStyle: middleHandler.visible ? {
        visible: true,
        icon: transformToGraphic(null === (_c = middleHandler.icon) || void 0 === _c ? void 0 : _c.style),
        background: {
          size: null === (_d = middleHandler.background) || void 0 === _d ? void 0 : _d.size,
          style: transformToGraphic(null === (_e = middleHandler.background) || void 0 === _e ? void 0 : _e.style)
        }
      } : {
        visible: false
      },
      endHandlerStyle: transformToGraphic(null === (_f = this._spec.endHandler) || void 0 === _f ? void 0 : _f.style),
      startTextStyle: {
        padding: startText.padding,
        formatMethod: this._getHandlerTextFormatMethod(startText),
        textStyle: transformToGraphic(startText.style)
      },
      endTextStyle: {
        padding: endText.padding,
        formatMethod: this._getHandlerTextFormatMethod(endText),
        textStyle: transformToGraphic(endText.style)
      },
      selectedBackgroundStyle: transformToGraphic(this._spec.selectedBackground.style),
      dragMaskStyle: transformToGraphic(null === (_g = this._spec.dragMask) || void 0 === _g ? void 0 : _g.style),
      backgroundChartStyle: isNeedPreview ? {
        line: mergeSpec(transformToGraphic(null === (_h = backgroundChart.line) || void 0 === _h ? void 0 : _h.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_j = backgroundChart.area) || void 0 === _j ? void 0 : _j.style))
      } : {
        line: {
          visible: false
        },
        area: {
          visible: false
        }
      },
      selectedBackgroundChartStyle: isNeedPreview ? {
        line: mergeSpec(transformToGraphic(null === (_k = selectedBackgroundChart.line) || void 0 === _k ? void 0 : _k.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_l = selectedBackgroundChart.area) || void 0 === _l ? void 0 : _l.style))
      } : {
        line: {
          visible: false
        },
        area: {
          visible: false
        }
      },
      disableTriggerEvent: this._option.disableTriggerEvent
    };
  }
  _getHandlerTextFormatMethod(spec) {
    const { formatMethod, formatter } = spec, { formatFunc } = getFormatFunction(formatMethod, formatter);
    return formatFunc ? (text2) => formatFunc(text2, {
      label: text2
    }, formatter) : void 0;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
  clear() {
    if (this._component) {
      const container2 = this.getContainer();
      this._component.removeAllChild(), container2 && container2.removeChild(this._component), this._component = null;
    }
    super.clear();
  }
};
DataZoom2.type = ComponentTypeEnum.dataZoom, DataZoom2.transformerConstructor = DataZoomSpecTransformer, DataZoom2.specKey = "dataZoom";
var registerDataZoom2 = () => {
  Factory2.registerComponent(DataZoom2.type, DataZoom2);
};

// node_modules/@visactor/vchart/esm/component/data-zoom/scroll-bar/scroll-bar.js
var ScrollBar2 = class extends DataFilterBaseComponent {
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.scrollBar, this.name = ComponentTypeEnum.scrollBar, this.specKey = "scrollBar", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "axis";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = false, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode);
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    this._updateScaleRange(), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a), super.onLayoutEnd(ctx);
  }
  _updateScaleRange() {
    this._component && this._component.setAttributes({
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height
    });
  }
  _computeWidth() {
    return isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : SCROLL_BAR_DEFAULT_SIZE;
  }
  _computeHeight() {
    return isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? SCROLL_BAR_DEFAULT_SIZE : this.getLayoutRect().height;
  }
  _getAttrs() {
    var _a, _b, _c, _d, _e, _f;
    return Object.assign({
      zIndex: this.layoutZIndex,
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height,
      range: [this._start, this._end],
      direction: this._isHorizontal ? "horizontal" : "vertical",
      delayType: null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType,
      delayTime: isValid_default(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.delayType) ? null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.realTime) || void 0 === _f || _f
    }, this._getComponentAttrs());
  }
  _createOrUpdateComponent() {
    const attrs = this._getAttrs();
    if (this._component) this._component.setAttributes(attrs);
    else {
      const container2 = this.getContainer();
      this._component = new ScrollBar(attrs), this._component.addEventListener("scrollDrag", (e) => {
        const value = e.detail.value;
        this._handleChange(value[0], value[1]);
      }), this._component.addEventListener("scrollUp", (e) => {
        const value = e.detail.value;
        this._handleChange(value[0], value[1]);
      }), container2.add(this._component);
    }
  }
  _handleChange(start, end, updateComponent) {
    super._handleChange(start, end, updateComponent);
    const isSameScrollValue = isClose(this._start, start) && isClose(this._end, end);
    if (this._shouldChange && (!isSameScrollValue || false === this._spec.realTime)) {
      updateComponent && this._component && this._component.setAttribute("range", [start, end]), this._start = start, this._end = end;
      const startValue = this.statePointToData(start), endValue = this.statePointToData(end);
      (isFunction_default(this._spec.updateDataAfterChange) ? this._spec.updateDataAfterChange(start, end, startValue, endValue) : this._handleStateChange(this.statePointToData(start), this.statePointToData(end))) && this.event.emit(ChartEvent.scrollBarChange, {
        model: this,
        value: {
          filterData: "axis" !== this._filterMode,
          start: this._start,
          end: this._end,
          startValue: this._startValue,
          endValue: this._endValue,
          newDomain: this._newDomain
        }
      });
    }
  }
  _handleDataCollectionChange() {
    if (this._spec.auto) {
      this._data.getDataView().reRunAllTransform();
    }
  }
  _getComponentAttrs() {
    const { rail, slider: slider2, innerPadding } = this._spec, attrs = {};
    return isNil_default(innerPadding) || (attrs.padding = innerPadding), isEmpty_default(null == rail ? void 0 : rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(null == slider2 ? void 0 : slider2.style) || (attrs.sliderStyle = transformToGraphic(slider2.style)), attrs.disableTriggerEvent = this._option.disableTriggerEvent, attrs;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
ScrollBar2.type = ComponentTypeEnum.scrollBar, ScrollBar2.specKey = "scrollBar";
var registerScrollBar = () => {
  Factory2.registerComponent(ScrollBar2.type, ScrollBar2);
};

// node_modules/@visactor/vchart/esm/component/indicator/util.js
var indicatorMapper = (data, op) => {
  const { datum, title: title3, content } = op, mappedData = [], datumResult = datum.call(null);
  return title3.visible && mappedData.push({
    type: "title",
    index: 0,
    datum: datumResult,
    spec: title3
  }), array(content).forEach((c3, i) => {
    c3.visible && mappedData.push({
      type: "content",
      index: i,
      datum: datumResult,
      spec: c3
    });
  }), mappedData;
};

// node_modules/@visactor/vchart/esm/component/indicator/indicator.js
var __rest29 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var Indicator2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.indicator, this.name = ComponentTypeEnum.indicator, this.specKey = "indicator", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Indicator, this.layoutLevel = LayoutLevel.Indicator, this._gap = 0, this._activeDatum = null;
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => s2 && false !== s2.visible);
  }
  created() {
    super.created(), this.initData(), this.initEvent();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._gap = this._spec.gap || 0, this._title = this._spec.title, this._content = array(this._spec.content), this._regions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  initEvent() {
    var _a;
    if (this._option.disableTriggerEvent) return;
    if ("none" === this._spec.trigger) return;
    const view = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
    view && ("hover" === this._spec.trigger ? (view.addEventListener("element-highlight:start", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-highlight:reset", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(null);
    })) : (view.addEventListener("element-select:start", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-select:reset", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(null);
    })));
  }
  updateDatum(datum) {
    this._activeDatum = datum, this._displayData.updateData();
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs);
  }
  initData() {
    registerDataSetInstanceTransform(this._option.dataSet, "indicatorFilter", indicatorMapper);
    const displayData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    displayData.transform({
      type: "indicatorFilter",
      options: {
        title: this._title,
        content: this._content,
        datum: () => this._activeDatum
      }
    }), displayData.target.addListener("change", this.updateDatum.bind(this)), this._displayData = new CompilableData(this._option, displayData);
  }
  updateLayoutAttribute() {
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs), super.updateLayoutAttribute();
  }
  _getIndicatorAttrs() {
    if (false === this._spec.visible || false === this._spec.fixed && null === this._activeDatum) return {
      visible: false
    };
    const region = this._regions[0], { width, height } = region.getLayoutRect(), { x, y } = region.getLayoutStartPoint(), _a = this._spec, { content, offsetX, offsetY, limitRatio, title: title3 } = _a, restSpec = __rest29(_a, ["content", "offsetX", "offsetY", "limitRatio", "title"]), contentComponentSpec = [];
    return array(content).forEach((eachItem) => {
      const contentSpec = mergeSpec({}, this._theme.content, eachItem);
      contentComponentSpec.push({
        visible: false !== contentSpec.visible && (!contentSpec.field || null !== this._activeDatum),
        space: contentSpec.space || this._gap,
        autoLimit: contentSpec.autoLimit,
        autoFit: contentSpec.autoFit,
        fitPercent: contentSpec.fitPercent,
        fitStrategy: contentSpec.fitStrategy,
        style: Object.assign(Object.assign({}, transformIndicatorStyle(pickWithout(contentSpec.style, ["text"]), this._activeDatum)), {
          text: this._createText(contentSpec.field, contentSpec.style.text)
        })
      });
    }), Object.assign({
      visible: true,
      size: {
        width,
        height
      },
      zIndex: this.layoutZIndex,
      x,
      y,
      dx: offsetX ? getActualNumValue(offsetX, this._computeLayoutRadius()) : 0,
      dy: offsetY ? getActualNumValue(offsetY, this._computeLayoutRadius()) : 0,
      limitRatio: limitRatio || 1 / 0,
      title: {
        visible: false !== title3.visible && (!isValid_default(title3.field) || null !== this._activeDatum),
        space: title3.space || this._gap,
        autoLimit: title3.autoLimit,
        autoFit: title3.autoFit,
        fitPercent: title3.fitPercent,
        fitStrategy: title3.fitStrategy,
        style: Object.assign(Object.assign({}, transformIndicatorStyle(pickWithout(title3.style, ["text"]), this._activeDatum)), {
          text: this._createText(title3.field, title3.style.text)
        })
      },
      content: contentComponentSpec
    }, restSpec);
  }
  _createOrUpdateIndicatorComponent(attrs) {
    if (false === attrs.visible) return this._indicatorComponent && this._indicatorComponent.parent && this._indicatorComponent.parent.removeChild(this._indicatorComponent), void (this._indicatorComponent = null);
    if (this._indicatorComponent) isEqual(attrs, this._cacheAttrs) || this._indicatorComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), indicator2 = new Indicator(attrs);
      indicator2.name = "indicator", container2.add(indicator2), this._indicatorComponent = indicator2, this._indicatorComponent.on("*", (event, type) => this._delegateEvent(this._indicatorComponent, event, type));
    }
    this._cacheAttrs = attrs;
  }
  _createText(field5, text2) {
    var _a;
    return field5 ? this._activeDatum ? this._activeDatum[field5] : "" : isFunction_default(text2) ? null !== (_a = text2(this._activeDatum, void 0)) && void 0 !== _a ? _a : "" : null != text2 ? text2 : "";
  }
  _computeLayoutRadius() {
    const region = this._regions[0], { width, height } = region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  isRelativeModel(regionId) {
    return this._regions.some((region) => region.id === regionId);
  }
  _getNeedClearVRenderComponents() {
    return [this._indicatorComponent];
  }
  clear() {
    this._cacheAttrs = null, super.clear();
  }
  getIndicatorComponent() {
    return this._indicatorComponent;
  }
};
Indicator2.type = ComponentTypeEnum.indicator, Indicator2.specKey = "indicator";
var registerIndicator = () => {
  Factory2.registerComponent(Indicator2.type, Indicator2);
};

// node_modules/@visactor/vchart/esm/constant/marker.js
var AGGR_TYPE = ["sum", "average", "min", "max", "variance", "standardDeviation", "median"];

// node_modules/@visactor/vchart/esm/component/marker/utils.js
var __rest30 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function isNeedExtendDomain(domain, datum, autoRange) {
  if (!autoRange) return false;
  const domainNum = domain.map((n) => 1 * n), min3 = minInArray(domainNum), max3 = maxInArray(domainNum);
  return datum < min3 || datum > max3;
}
function getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let x;
  return isNumber_default(datum.x) && isNeedExtendDomain(xDomain, datum.x, autoRange) && (null === (_b = null == relativeSeries ? void 0 : (_a = relativeSeries.getXAxisHelper()).setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", datum.x)), x = isPercent(datum.x) ? convertPercentToValue(datum.x, regionWidth) + regionStartLayoutStartPoint.x : relativeSeries.getXAxisHelper().dataToPosition([datum.x]) + regionStartLayoutStartPoint.x, x;
}
function getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let y;
  return isNumber_default(datum.y) && isNeedExtendDomain(yDomain, datum.y, autoRange) && (null === (_b = null === (_a = relativeSeries.getYAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_yAxis_extend", datum.y)), y = isPercent(datum.y) ? convertPercentToValue(datum.y, regionHeight) + regionStartLayoutStartPoint.y : relativeSeries.getYAxisHelper().dataToPosition([datum.y]) + regionStartLayoutStartPoint.y, y;
}
function getAngleValue(datum, angleDomain, autoRange, refSeries) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  return isNumber_default(datum.angle) && isNeedExtendDomain(angleDomain, datum.angle, autoRange) && (null === (_b = null === (_a = relativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_angleAxis_extend", datum.angle)), relativeSeries.angleAxisHelper.dataToPosition([datum.angle]);
}
function getRadiusValue(datum, radiusDomain, autoRange, refSeries) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  return isNumber_default(datum.radius) && isNeedExtendDomain(radiusDomain, datum.radius, autoRange) && (null === (_b = null === (_a = relativeSeries.radiusAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_radiusAxis_extend", datum.radius)), relativeSeries.radiusAxisHelper.dataToPosition([datum.radius]);
}
function convertPercentToValue(percent, relativeLength) {
  return Number(percent.substring(0, percent.length - 1)) * relativeLength / 100;
}
function isAggrSpec(spec) {
  return AGGR_TYPE.includes(spec);
}
function xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
  const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint(), regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width)), regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height)), refSeries = {
    relativeSeries,
    startRelativeSeries,
    endRelativeSeries
  }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, xDomain = relativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = relativeSeries.getYAxisHelper().getScale(0).domain();
  return dataPoints.forEach((datum) => {
    const isValidX = isValid_default(datum.x), isValidY = isValid_default(datum.y);
    if (isValidX && isValidY) {
      const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint);
      lines.push([{
        x,
        y
      }]);
    } else if (isValidX) {
      const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height), y1 = Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y);
      lines.push([{
        x,
        y
      }, {
        x,
        y: y1
      }]);
    } else if (isValidY) {
      const x = Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint), x1 = Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width);
      lines.push([{
        x,
        y
      }, {
        x: x1,
        y
      }]);
    }
  }), lines;
}
function polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
  const refSeries = {
    relativeSeries,
    startRelativeSeries,
    endRelativeSeries
  }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, angleDomain = relativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = relativeSeries.radiusAxisHelper.getScale(0).domain(), regionRadius = Math.min(relativeSeries.getRegion().getLayoutRect().width / 2, relativeSeries.getRegion().getLayoutRect().height / 2);
  return dataPoints.forEach((datum) => {
    const isValidAngle = isValid_default(datum.angle), isValidRadius = isValid_default(datum.radius);
    if (isValidAngle && isValidRadius) {
      const angle2 = getAngleValue(datum, angleDomain, autoRange, refSeries), radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
      lines.push([{
        angle: angle2,
        radius
      }]);
    } else if (isValidAngle) {
      const angle2 = getAngleValue(datum, angleDomain, autoRange, refSeries);
      lines.push([{
        angle: angle2,
        radius: -regionRadius
      }, {
        angle: angle2,
        radius: regionRadius
      }]);
    } else if (isValidRadius) {
      const radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
      lines.push([{
        radius,
        angle: 0
      }, {
        radius,
        angle: 2 * Math.PI
      }]);
    }
  }), lines;
}
function geoLayout(data, relativeSeries) {
  const lines = [];
  return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum) => {
    isValid_default(datum.areaName) && lines.push([{
      x: relativeSeries.nameValueToPosition(datum.areaName).x + relativeSeries.getRegion().getLayoutStartPoint().x,
      y: relativeSeries.nameValueToPosition(datum.areaName).y + relativeSeries.getRegion().getLayoutStartPoint().y
    }]);
  }), lines;
}
function cartesianCoordinateLayout(data, relativeSeries, autoRange, coordinatesOffset) {
  const points = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, isArrayCoordinatesOffset = isArray_default(coordinatesOffset);
  return dataPoints.forEach((datum, index) => {
    var _a, _b, _c, _d;
    const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, regionStart = refRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = regionStart.getLayoutRect();
    let offsetX = 0, offsetY = 0;
    if (coordinatesOffset) {
      const currentCoordinatesOffset = isArrayCoordinatesOffset ? coordinatesOffset[index] : coordinatesOffset, x = currentCoordinatesOffset.x, y = currentCoordinatesOffset.y;
      x && (offsetX = isPercent(x) ? Number(x.substring(0, x.length - 1)) * regionWidth / 100 : x), y && (offsetY = isPercent(y) ? Number(y.substring(0, y.length - 1)) * regionHeight / 100 : y);
    }
    const xDomain = refRelativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = refRelativeSeries.getYAxisHelper().getScale(0).domain(), xValue = array(datum.x), yValue = array(datum.y);
    1 === xValue.length && isNumber_default(xValue[0]) && isNeedExtendDomain(xDomain, xValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.getXAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", xValue[0])), 1 === yValue.length && isNumber_default(yValue[0]) && isNeedExtendDomain(yDomain, yValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.getYAxisHelper()) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", yValue[0])), points.push({
      x: refRelativeSeries.getXAxisHelper().dataToPosition(xValue) + regionStartLayoutStartPoint.x + offsetX,
      y: refRelativeSeries.getYAxisHelper().dataToPosition(yValue) + regionStartLayoutStartPoint.y + offsetY
    });
  }), points;
}
function polarCoordinateLayout(data, relativeSeries, autoRange) {
  const points = [];
  return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum) => {
    var _a, _b, _c, _d;
    const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, angleDomain = refRelativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = refRelativeSeries.radiusAxisHelper.getScale(0).domain(), angleValue = array(datum.angle), radiusValue = array(datum.radius);
    1 === angleValue.length && isNumber_default(angleValue[0]) && isNeedExtendDomain(angleDomain, angleValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", angleValue[0])), 1 === radiusValue.length && isNumber_default(radiusValue[0]) && isNeedExtendDomain(radiusDomain, radiusValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.radiusAxisHelper) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", radiusValue[0])), points.push({
      angle: refRelativeSeries.angleAxisHelper.dataToPosition(angleValue),
      radius: refRelativeSeries.radiusAxisHelper.dataToPosition(radiusValue)
    });
  }), points;
}
function convertPosition(position, relativeWidth, relativeHeight) {
  let { x, y } = position;
  return isPercent(x) && (x = convertPercentToValue(x, relativeWidth)), isPercent(y) && (y = convertPercentToValue(y, relativeHeight)), {
    x,
    y
  };
}
function positionLayout(positions, series2, regionRelative) {
  let transformPositions;
  if (transformPositions = isFunction_default(positions) ? array(positions(series2.getData().getLatestData(), series2)) : array(positions), regionRelative) {
    const region = series2.getRegion(), { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = region.getLayoutRect();
    return transformPositions.map((position) => {
      let { x, y } = convertPosition(position, regionWidth, regionHeight);
      return x += regionStartX, y += regionStartY, {
        x,
        y
      };
    });
  }
  const { width: canvasWidth, height: canvasHeight } = series2.getOption().getChart().getViewRect();
  return transformPositions.map((position) => convertPosition(position, canvasWidth, canvasHeight));
}
function computeClipRange(regions) {
  let minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY2 = -1 / 0;
  return regions.forEach((region) => {
    const regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect();
    regionPos.x < minX && (minX = regionPos.x), regionPos.x + regionRect.width > maxX && (maxX = regionPos.x + regionRect.width), regionPos.y < minY && (minY = regionPos.y), regionPos.y + regionRect.height > maxY2 && (maxY2 = regionPos.y + regionRect.height);
  }), {
    minX,
    maxX,
    minY,
    maxY: maxY2
  };
}
function transformLabelAttributes(label, markerData, markAttributeContext) {
  const { labelBackground = {}, style, shape } = label, restLabel = __rest30(label, ["labelBackground", "style", "shape"]);
  if (false !== label.visible) {
    const labelAttrs = restLabel;
    return (null == shape ? void 0 : shape.visible) ? labelAttrs.shape = Object.assign({
      visible: true
    }, transformToGraphic(shape.style)) : labelAttrs.shape = {
      visible: false
    }, false !== labelBackground.visible ? (labelAttrs.panel = Object.assign({
      visible: true,
      customShape: labelBackground.customShape
    }, transformStyle(transformToGraphic(labelBackground.style), markerData, markAttributeContext)), isValid_default(labelBackground.padding) && (labelAttrs.padding = normalizePadding(labelBackground.padding))) : (labelAttrs.panel = {
      visible: false
    }, labelAttrs.padding = 0), style && (labelAttrs.textStyle = transformStyle(transformToGraphic(style), markerData, markAttributeContext)), labelAttrs;
  }
  return {
    visible: false
  };
}
function transformState(state, markerData, markerAttributeContext) {
  for (const stateKey in state) isFunction_default(state[stateKey]) && (state[stateKey] = state[stateKey](markerData, markerAttributeContext));
  return state;
}
function transformStyle(style, markerData, markerAttributeContext) {
  return isFunction_default(style) ? style(markerData, markerAttributeContext) : style;
}
function transformOffset(offset, region) {
  return isFunction_default(offset) ? offset(region) : offset;
}
function computeOffsetFromRegion(point6, offset, region) {
  return isValid_default(point6) ? "regionLeft" === offset ? region.getLayoutStartPoint().x - point6.x : "regionRight" === offset ? region.getLayoutStartPoint().x + region.getLayoutRect().width - point6.x : "regionTop" === offset ? region.getLayoutStartPoint().y - point6.y : "regionBottom" === offset ? region.getLayoutStartPoint().y + region.getLayoutRect().height - point6.y : offset : offset;
}
function getProcessInfo(spec) {
  return {
    isXProcess: isValid_default(spec.x),
    isYProcess: isValid_default(spec.y),
    isX1Process: isValid_default(spec.x1),
    isY1Process: isValid_default(spec.y1),
    isAngleProcess: isValid_default(spec.angle),
    isRadiusProcess: isValid_default(spec.radius),
    isAngle1Process: isValid_default(spec.angle1),
    isRadius1Process: isValid_default(spec.radius1),
    isCoordinatesProcess: isValid_default(spec.coordinates),
    isValidProcess: isValid_default(spec.process)
  };
}
function getMarkLineProcessInfo(spec) {
  const { isXProcess, isYProcess, isX1Process, isY1Process, isAngleProcess, isRadiusProcess, isAngle1Process, isRadius1Process, isCoordinatesProcess, isValidProcess } = getProcessInfo(spec);
  return {
    doXProcess: isXProcess && !isYProcess && !isY1Process,
    doXYY1Process: isXProcess && isYProcess && isY1Process,
    doYProcess: isYProcess && !isXProcess && !isX1Process,
    doYXX1Process: isYProcess && isXProcess && isX1Process,
    doXYProcess: isXProcess && isYProcess && isX1Process && isY1Process,
    doAngleProcess: isAngleProcess && !isAngle1Process && !isRadiusProcess && !isRadius1Process,
    doRadiusProcess: isRadiusProcess && !isRadius1Process && !isAngleProcess && !isAngle1Process,
    doAngRadRad1Process: isAngleProcess && !isAngle1Process && isRadiusProcess && isRadius1Process,
    doRadAngAng1Process: isRadiusProcess && isAngleProcess && isAngle1Process && !isRadius1Process,
    doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
    doCoordinatesProcess: isCoordinatesProcess && (!isValidProcess || "process" in spec && "xy" in spec.process)
  };
}
function getMarkAreaProcessInfo(spec) {
  const { isXProcess, isYProcess, isX1Process, isY1Process, isAngleProcess, isRadiusProcess, isAngle1Process, isRadius1Process, isCoordinatesProcess } = getProcessInfo(spec);
  return {
    doXProcess: isXProcess && isX1Process && !isYProcess && !isY1Process,
    doYProcess: isYProcess && isY1Process && !isXProcess && !isX1Process,
    doXYProcess: isXProcess && isX1Process && isYProcess && isY1Process,
    doAngleProcess: isAngleProcess && isAngle1Process && !isRadiusProcess && !isRadius1Process,
    doRadiusProcess: isRadiusProcess && isRadius1Process && !isAngleProcess && !isAngle1Process,
    doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
    doCoordinatesProcess: isCoordinatesProcess
  };
}
function getMarkPointProcessInfo(spec) {
  return {
    doXYProcess: isValid_default(spec.x) && isValid_default(spec.y),
    doPolarProcess: isValid_default(spec.angle) && isValid_default(spec.radius),
    doGeoProcess: isValid_default(spec.areaName)
  };
}

// node_modules/@visactor/vchart/esm/component/marker/mark-line/util.js
function getInsertPoints(start, end, direction, offset = 0) {
  const points = [], dy = start.y - end.y, dx = start.x - end.x;
  switch (direction) {
    case "top":
      points.push(start), points.push({
        x: start.x,
        y: dy > 0 ? start.y - offset - Math.abs(dy) : start.y - offset
      }), points.push({
        x: end.x,
        y: dy > 0 ? end.y - offset : end.y - offset - Math.abs(dy)
      }), points.push(end);
      break;
    case "bottom":
      points.push(start), points.push({
        x: start.x,
        y: dy < 0 ? start.y + offset + Math.abs(dy) : start.y + offset
      }), points.push({
        x: end.x,
        y: dy < 0 ? end.y + offset : end.y + offset + Math.abs(dy)
      }), points.push(end);
      break;
    case "left":
      points.push(start), points.push({
        x: dx > 0 ? start.x - offset - Math.abs(dx) : start.x - offset,
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x - offset : end.x - offset - Math.abs(dx),
        y: end.y
      }), points.push(end);
      break;
    case "right":
      points.push(start), points.push({
        x: dx > 0 ? start.x + offset : start.x + offset + Math.abs(dx),
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x + offset + Math.abs(dx) : end.x + offset,
        y: end.y
      }), points.push(end);
  }
  return points;
}
function getTextOffset(start, end, direction, offset = 0) {
  const dy = start.y - end.y, dx = start.x - end.x;
  return "bottom" === direction ? {
    dx: dx > 0 ? -dx / 2 : Math.abs(dx / 2),
    dy: dy > 0 ? offset : Math.abs(dy) + offset
  } : "top" === direction ? {
    dx: dx > 0 ? -Math.abs(dx / 2) : +Math.abs(dx / 2),
    dy: dy > 0 ? -(Math.abs(dy) + offset) : -offset
  } : "left" === direction ? {
    dx: dx > 0 ? -dx - offset : -offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : "right" === direction ? {
    dx: dx > 0 ? offset : Math.abs(dx) + offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : {};
}

// node_modules/@visactor/vchart/esm/data/transforms/aggregation.js
var __rest31 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var markerMin = (_data, opt) => {
  const data = _data[0].latestData;
  return min2(data, opt.field);
};
var markerMax = (_data, opt) => {
  const data = _data[0].latestData;
  return max2(data, opt.field);
};
function markerSum(_data, opt) {
  const data = _data[0].latestData;
  return sum(data, opt.field);
}
function markerAverage(_data, opt) {
  const data = _data[0].latestData;
  return average(data, opt.field);
}
function markerVariance(_data, opt) {
  const data = _data[0].latestData;
  return variance(data, opt.field);
}
function markerStandardDeviation(_data, opt) {
  const data = _data[0].latestData;
  return standardDeviation(data, opt.field);
}
function markerMedian(_data, opt) {
  const data = _data[0].latestData;
  return median2(data, opt.field);
}
function markerAggregation(_data, options) {
  let markerSource;
  if (options.coordinates) {
    const _a = options, { coordinates: coordinatesInOptions, coordinateType, getSeriesByIdOrIndex } = _a, rest = __rest31(_a, ["coordinates", "coordinateType", "getSeriesByIdOrIndex"]);
    let coordinates, option;
    if (isFunction_default(coordinatesInOptions)) {
      const relativeSeries = options.getRelativeSeries();
      coordinates = coordinatesInOptions(relativeSeries.getData().getLatestData(), relativeSeries);
    } else coordinates = coordinatesInOptions;
    coordinates = array(coordinates), markerSource = coordinates.map((coordinate) => {
      const refRelativeSeries = getSeriesByIdOrIndex(coordinate.refRelativeSeriesId, coordinate.refRelativeSeriesIndex);
      if ("cartesian" === coordinateType) {
        const { xField, yField } = refRelativeSeries.getSpec(), { xFieldDim, xFieldIndex, yFieldDim, yFieldIndex } = coordinate;
        let bindXField = xField;
        isValid_default(xFieldIndex) && (bindXField = array(xField)[xFieldIndex]), xFieldDim && array(xField).includes(xFieldDim) && (bindXField = xFieldDim);
        let bindYField = yField;
        isValid_default(yFieldIndex) && (bindYField = array(yField)[yFieldIndex]), yFieldDim && array(yField).includes(yFieldDim) && (bindYField = yFieldDim), option = Object.assign({
          x: void 0,
          y: void 0
        }, rest), isString_default(coordinate[bindXField]) && isAggrSpec(coordinate[bindXField]) ? option.x = {
          field: bindXField,
          aggrType: coordinate[bindXField]
        } : option.x = array(bindXField).map((field5) => coordinate[field5]), isString_default(coordinate[bindYField]) && isAggrSpec(coordinate[bindYField]) ? option.y = {
          field: bindYField,
          aggrType: coordinate[bindYField]
        } : option.y = array(bindYField).map((field5) => coordinate[field5]);
      } else if ("polar" === coordinateType) {
        const { valueField: radiusField, categoryField: angleField } = refRelativeSeries.getSpec(), { angleFieldDim, angleFieldIndex } = coordinate;
        let bindAngleField = angleField;
        isValid_default(angleFieldIndex) && (bindAngleField = array(angleField)[angleFieldIndex]), angleFieldDim && array(angleField).includes(angleFieldDim) && (bindAngleField = angleFieldDim);
        const bindRadiusField = radiusField;
        option = Object.assign({
          angle: void 0,
          radius: void 0
        }, rest), isString_default(coordinate[bindAngleField]) && isAggrSpec(coordinate[bindAngleField]) ? option.angle = {
          field: bindAngleField,
          aggrType: coordinate[bindAngleField]
        } : option.angle = array(bindAngleField).map((field5) => coordinate[field5]), isString_default(coordinate[bindRadiusField]) && isAggrSpec(coordinate[bindRadiusField]) ? option.radius = {
          field: bindRadiusField,
          aggrType: coordinate[bindRadiusField]
        } : option.radius = array(bindRadiusField).map((field5) => coordinate[field5]);
      }
      return option.getRefRelativeSeries = () => refRelativeSeries, option;
    });
  } else markerSource = options;
  const results = [];
  return markerSource.forEach((option) => {
    const result2 = {
      x: null,
      y: null,
      angle: null,
      radius: null,
      areaName: null
    };
    if (isValid_default(option.x)) {
      const x = option.x;
      isArray_default(x) ? result2.x = x.map((item) => getFinalValue(item, _data, option)) : result2.x = getFinalValue(x, _data, option);
    }
    if (isValid_default(option.y)) {
      const y = option.y;
      isArray_default(y) ? result2.y = y.map((item) => getFinalValue(item, _data, option)) : result2.y = getFinalValue(y, _data, option);
    }
    if (isValid_default(option.angle)) {
      const angle2 = option.angle;
      isArray_default(angle2) ? result2.angle = angle2.map((item) => getFinalValue(item, _data, option)) : result2.angle = getFinalValue(angle2, _data, option);
    }
    if (isValid_default(option.radius)) {
      const radius = option.radius;
      isArray_default(radius) ? result2.radius = radius.map((item) => getFinalValue(item, _data, option)) : result2.radius = getFinalValue(radius, _data, option);
    }
    if (isValid_default(option.areaName)) {
      const name = option.areaName;
      result2.areaName = getFinalValue(name, _data, option);
    }
    option.getRefRelativeSeries && (result2.getRefRelativeSeries = option.getRefRelativeSeries), results.push(result2);
  }), results;
}
var aggrMap = {
  min: markerMin,
  max: markerMax,
  sum: markerSum,
  average: markerAverage,
  variance: markerVariance,
  standardDeviation: markerStandardDeviation,
  median: markerMedian
};
function getFinalValue(source, _data, option) {
  const relativeSeries = option.getRelativeSeries(), startSeries = option.getStartRelativeSeries(), endSeries = option.getEndRelativeSeries(), relativeSeriesData = relativeSeries.getData().getLatestData(), startRelativeSeriesData = startSeries.getData().getLatestData(), endRelativeSeriesData = endSeries.getData().getLatestData();
  if (isFunction_default(source)) return source(relativeSeriesData, startRelativeSeriesData, endRelativeSeriesData, relativeSeries, startSeries, endSeries);
  if (isPlainObject_default(source)) {
    const { aggrType, field: field5 } = source;
    return aggrMap[aggrType](_data, {
      field: field5
    });
  }
  return source;
}

// node_modules/@visactor/vchart/esm/data/transforms/marker-filter.js
function markerFilter(data, options) {
  if (options && options.getRelativeSeries) {
    const series2 = options.getRelativeSeries();
    if (series2) {
      const viewData = series2.getViewData();
      return viewData && viewData.latestData && viewData.latestData.length ? data : [];
    }
  }
  return data;
}

// node_modules/@visactor/vchart/esm/component/marker/base-marker.js
var BaseMarker = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this._layoutOffsetX = 0, this._layoutOffsetY = 0;
  }
  getRelativeSeries() {
    return this._relativeSeries;
  }
  getMarkerData() {
    return this._markerData;
  }
  static _getMarkerCoordinateType(markerSpec) {
    return "cartesian";
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => false !== s2.visible && this._getMarkerCoordinateType(s2) === this.coordinateType);
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  _buildMarkerAttributeContext() {
    this._markAttributeContext = {
      relativeSeries: this._relativeSeries,
      startRelativeSeries: this._startRelativeSeries,
      endRelativeSeries: this._endRelativeSeries,
      vchart: this._option.globalInstance
    };
  }
  created() {
    super.created(), this._bindSeries(), this._initDataView(), this.initEvent(), this._buildMarkerAttributeContext();
  }
  _getAllRelativeSeries() {
    return {
      getRelativeSeries: () => this._relativeSeries,
      getStartRelativeSeries: () => this._startRelativeSeries,
      getEndRelativeSeries: () => this._endRelativeSeries
    };
  }
  _getFieldInfoFromSpec(dim, spec, relativeSeries) {
    const specKeyByDim = {
      x: "xField",
      y: "yField",
      radius: "valueField",
      angle: "categoryField",
      areaName: "nameField"
    };
    return isString_default(spec) && isAggrSpec(spec) ? {
      field: relativeSeries.getSpec()[specKeyByDim[dim]],
      aggrType: spec
    } : spec;
  }
  _processSpecByDims(dimSpec) {
    const relativeSeries = this._relativeSeries, dimMap = {};
    return dimSpec.forEach((d) => dimMap[d.dim] = this._getFieldInfoFromSpec(d.dim, d.specValue, relativeSeries)), Object.assign(Object.assign({}, dimMap), this._getAllRelativeSeries());
  }
  _processSpecCoo(spec) {
    return Object.assign(Object.assign({
      coordinates: spec.coordinates || spec.coordinate
    }, this._getAllRelativeSeries()), {
      getSeriesByIdOrIndex: (seriesUserId, seriesIndex) => this._getSeriesByIdOrIndex(seriesUserId, seriesIndex),
      coordinateType: this.coordinateType
    });
  }
  _getRelativeDataView() {
    if (this._specifiedDataSeries) {
      let resultData = [];
      array(this._specifiedDataSeries).forEach((series2) => {
        resultData = resultData.concat(series2.getViewData().latestData);
      });
      const dataSet = new DataSet();
      return dataSet.registerParser("array", arrayParser), new DataView(dataSet).parse(resultData, {
        type: "array"
      });
    }
    return this._relativeSeries.getViewData();
  }
  updateLayoutAttribute() {
    var _a, _b, _c;
    if (null === (_a = this._spec.visible) || void 0 === _a || _a) {
      if (!this._markerComponent) {
        const markerComponent = this._createMarkerComponent();
        markerComponent.name = null !== (_b = this._spec.name) && void 0 !== _b ? _b : this.type, markerComponent.id = null !== (_c = this._spec.id) && void 0 !== _c ? _c : `${this.type}-${this.id}`, this._markerComponent = markerComponent, this.getContainer().add(this._markerComponent), this._markerComponent.on("*", (event, type) => {
          this._delegateEvent(this._markerComponent, event, type, null, this.getMarkerData.bind(this));
        });
      }
      this._markerLayout();
    }
    super.updateLayoutAttribute();
  }
  _getSeriesByIdOrIndex(seriesUserId, seriesIndex) {
    var _a, _b;
    let series2;
    return series2 = null === (_a = this._option.getSeriesInUserIdOrIndex(isValid_default(seriesUserId) ? [seriesUserId] : [], [seriesIndex])) || void 0 === _a ? void 0 : _a[0], series2 || (series2 = null !== (_b = this._relativeSeries) && void 0 !== _b ? _b : this._getFirstSeries()), series2;
  }
  _bindSeries() {
    const spec = this._spec;
    this._relativeSeries = this._getSeriesByIdOrIndex(spec.relativeSeriesId, spec.relativeSeriesIndex), this._startRelativeSeries = this._getSeriesByIdOrIndex(spec.startRelativeSeriesId, spec.startRelativeSeriesIndex), this._endRelativeSeries = this._getSeriesByIdOrIndex(spec.endRelativeSeriesId, spec.endRelativeSeriesIndex), spec.specifiedDataSeriesIndex && "all" === spec.specifiedDataSeriesIndex || spec.specifiedDataSeriesId && "all" === spec.specifiedDataSeriesId ? this._specifiedDataSeries = this._option.getAllSeries() : (spec.specifiedDataSeriesIndex || spec.specifiedDataSeriesId) && (this._specifiedDataSeries = this._getSeriesByIdOrIndex(spec.specifiedDataSeriesId, spec.specifiedDataSeriesIndex));
  }
  initEvent() {
    "cartesian" !== this._relativeSeries.coordinate && (this._relativeSeries.event.on("zoom", this._markerLayout.bind(this)), this._relativeSeries.event.on("panmove", this._markerLayout.bind(this)), this._relativeSeries.event.on("scroll", this._markerLayout.bind(this)));
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  clear() {
    super.clear(), this._firstSeries = null;
  }
  _getFirstSeries() {
    var _a;
    if (this._firstSeries) return this._firstSeries;
    const firstSeries = getFirstSeries(this._regions);
    return firstSeries ? (this._firstSeries = firstSeries, firstSeries) : (null === (_a = this._option) || void 0 === _a || _a.onError("need at least one series"), null);
  }
  _getNeedClearVRenderComponents() {
    return [this._markerComponent];
  }
  onLayoutStart(layoutRect, chartViewRect, ctx) {
    isNil_default(this._spec.offsetX) || (this._layoutOffsetX = calcLayoutNumber(this._spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(this._spec.offsetY) || (this._layoutOffsetY = calcLayoutNumber(this._spec.offsetY, chartViewRect.height, chartViewRect)), super.onLayoutStart(layoutRect, chartViewRect, ctx);
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true, result2.change = true), result2;
  }
  _initCommonDataView() {
    const { options } = this._computeOptions(), seriesData = this._getRelativeDataView();
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const data = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.parse([seriesData], {
      type: "dataview"
    }), data.transform({
      type: "markerAggregation",
      options
    }), data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/regression.js
function markerRegression(_data, opt) {
  const data = _data[0].latestData;
  return regression(data, opt.fieldX, opt.fieldY);
}

// node_modules/@visactor/vchart/esm/component/marker/mark-line/base-mark-line.js
var BaseMarkLine = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markLine", this.layoutZIndex = LayoutZIndex.MarkLine;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess } = getMarkLineProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess ? "polar" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const { startSymbol = {}, endSymbol = {} } = this._spec, label = array(null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}), markLineAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      hover: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      select: null === (_d = this._spec.interactive) || void 0 === _d || _d,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }],
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0,
      lineStyle: transformStyle(transformToGraphic(null === (_e = this._spec.line) || void 0 === _e ? void 0 : _e.style), this._markerData, this._markAttributeContext),
      clipInRange: null !== (_f = this._spec.clip) && void 0 !== _f && _f,
      label: label.map((labelItem) => transformLabelAttributes(labelItem, this._markerData, this._markAttributeContext)),
      state: {
        line: transformState(null !== (_h = null === (_g = this._spec.line) || void 0 === _g ? void 0 : _g.state) && void 0 !== _h ? _h : {}, this._markerData, this._markAttributeContext),
        lineStartSymbol: transformState(null !== (_k = null === (_j = this._spec.startSymbol) || void 0 === _j ? void 0 : _j.state) && void 0 !== _k ? _k : {}, this._markerData, this._markAttributeContext),
        lineEndSymbol: transformState(null !== (_m = null === (_l = this._spec.endSymbol) || void 0 === _l ? void 0 : _l.state) && void 0 !== _m ? _m : {}, this._markerData, this._markAttributeContext),
        label: label.map((labelItem) => {
          var _a2;
          return transformState(null !== (_a2 = labelItem.state) && void 0 !== _a2 ? _a2 : {}, this._markerData, this._markAttributeContext);
        }),
        labelBackground: label.map((labelItem) => {
          var _a2, _b2;
          return transformState(null !== (_b2 = null === (_a2 = labelItem.labelBackground) || void 0 === _a2 ? void 0 : _a2.state) && void 0 !== _b2 ? _b2 : {}, this._markerData, this._markAttributeContext);
        })
      },
      animation: null !== (_o = this._spec.animation) && void 0 !== _o && _o,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    startSymbol.visible ? markLineAttrs.startSymbol = Object.assign(Object.assign({}, startSymbol), {
      visible: true,
      style: transformStyle(transformToGraphic(startSymbol.style), this._markerData, this._markAttributeContext)
    }) : markLineAttrs.startSymbol = {
      visible: false
    }, endSymbol.visible ? markLineAttrs.endSymbol = Object.assign(Object.assign({}, endSymbol), {
      visible: true,
      style: transformStyle(transformToGraphic(endSymbol.style), this._markerData, this._markAttributeContext)
    }) : markLineAttrs.endSymbol = {
      visible: false
    };
    return this._newMarkLineComponent(markLineAttrs);
  }
  _getUpdateMarkerAttrs() {
    var _a, _b;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = relativeSeries.getViewData().latestData, dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData;
    let limitRect;
    if (spec.clip || array(spec.label).some((labelCfg) => null == labelCfg ? void 0 : labelCfg.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    const markerComponentAttr = null !== (_b = null === (_a = this._markerComponent) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, prevLabelAttrs = array(markerComponentAttr.label), specLabels = array(this._spec.label), labelAttrs = prevLabelAttrs.map((prevLabel, index) => {
      const specLabel = specLabels[index] || {};
      return Object.assign(Object.assign({}, prevLabel), {
        text: specLabel.formatMethod ? specLabel.formatMethod(dataPoints, seriesData) : null == prevLabel ? void 0 : prevLabel.text
      });
    });
    return Object.assign(Object.assign({}, pointsAttr), {
      label: labelAttrs,
      limitRect,
      dx: this._layoutOffsetX,
      dy: this._layoutOffsetY
    });
  }
  _markerLayout() {
    var _a;
    const updateAttrs = this._getUpdateMarkerAttrs();
    null === (_a = this._markerComponent) || void 0 === _a || _a.setAttributes(updateAttrs);
  }
  _initDataView() {
    const spec = this._spec, isCoordinateProcess = "coordinates" in spec, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess } = getMarkLineProcessInfo(spec);
    if (this._markerData = this._getRelativeDataView(), !(doXProcess || doYProcess || doXYY1Process || doYXX1Process || doXYProcess || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess || isCoordinateProcess)) return;
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerRegression", markerRegression), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const { options, needAggr, needRegr, processData } = this._computeOptions(), data = new DataView(this._option.dataSet);
    data.parse([processData], {
      type: "dataview"
    }), needAggr && data.transform({
      type: "markerAggregation",
      options
    }), needRegr && data.transform({
      type: "markerRegression",
      options
    }), data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
BaseMarkLine.specKey = "markLine";

// node_modules/@visactor/vchart/esm/component/marker/mark-line/cartesian-mark-line.js
var CartesianMarkLine = class extends BaseMarkLine {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markLine, this.name = ComponentTypeEnum.markLine, this.coordinateType = "cartesian";
  }
  _newMarkLineComponent(attr) {
    return new MarkLine(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isValidCoordinates = isValid_default(spec.coordinates), isValidProcess = isValid_default(spec.process), isValidProcessX = isValidProcess && isValid_default(spec.process.x), isValidProcessY = isValidProcess && isValid_default(spec.process.y), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let points = [];
    if (doXProcess || doXYY1Process || doYProcess || doYXX1Process || doXYProcess || isValidCoordinates && isValidProcessX || isValidCoordinates && isValidProcessY) {
      const xyPoints = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      points = 1 === xyPoints.length ? xyPoints[0] : xyPoints.map((point6) => point6[0]);
    } else doCoordinatesProcess ? points = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    return {
      points
    };
  }
  _markerLayout() {
    var _a, _b, _c, _d;
    const updateAttrs = this._getUpdateMarkerAttrs();
    if ("type-step" === this._spec.type) {
      const startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, { multiSegment, mainSegmentIndex } = this._spec.line || {}, { connectDirection, expandDistance = 0 } = this._spec;
      let expandDistanceValue;
      if (isPercent(expandDistance)) {
        const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint();
        if ("bottom" === connectDirection || "top" === connectDirection) {
          const regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionHeight / 100;
        } else {
          const regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionWidth / 100;
        }
      } else expandDistanceValue = expandDistance;
      const { points, limitRect } = updateAttrs, joinPoints = getInsertPoints(points[0], points[1], connectDirection, expandDistanceValue);
      let labelPositionAttrs;
      labelPositionAttrs = multiSegment && isValid_default(mainSegmentIndex) ? {
        position: "middle",
        autoRotate: false
      } : Object.assign({
        position: "start",
        autoRotate: false
      }, getTextOffset(points[0], points[1], connectDirection, expandDistanceValue));
      const markerComponentAttr = null !== (_b = null === (_a = this._markerComponent) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, prevLabelAttrs = array(markerComponentAttr.label), updateLabels = array(updateAttrs.label), labelsInSpec = array(this._spec.label);
      null === (_c = this._markerComponent) || void 0 === _c || _c.setAttributes({
        points: multiSegment ? [[joinPoints[0], joinPoints[1]], [joinPoints[1], joinPoints[2]], [joinPoints[2], joinPoints[3]]] : joinPoints,
        label: updateLabels.map((labelItem, index) => {
          var _a2, _b2, _c2, _d2;
          let refX = 0, refY = 0, dx = null !== (_a2 = labelPositionAttrs.dx) && void 0 !== _a2 ? _a2 : 0, dy = null !== (_b2 = labelPositionAttrs.dy) && void 0 !== _b2 ? _b2 : 0;
          const labelSpec = null !== (_c2 = labelsInSpec[index]) && void 0 !== _c2 ? _c2 : labelsInSpec[0];
          return isValidNumber_default(null == labelSpec ? void 0 : labelSpec.refX) && (refX += labelSpec.refX), isValidNumber_default(null == labelSpec ? void 0 : labelSpec.refY) && (refY += labelSpec.refY), isValidNumber_default(null == labelSpec ? void 0 : labelSpec.dx) && (dx += labelSpec.dx), isValidNumber_default(null == labelSpec ? void 0 : labelSpec.dy) && (dy += labelSpec.dy), Object.assign(Object.assign(Object.assign({}, labelItem), labelPositionAttrs), {
            refX,
            refY,
            dx,
            dy,
            textStyle: Object.assign(Object.assign({}, null === (_d2 = prevLabelAttrs[index]) || void 0 === _d2 ? void 0 : _d2.textStyle), {
              textAlign: "center",
              textBaseline: "middle"
            })
          });
        }),
        limitRect,
        multiSegment,
        mainSegmentIndex,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    } else null === (_d = this._markerComponent) || void 0 === _d || _d.setAttributes(updateAttrs);
  }
  _computeOptions() {
    let options, processData = this._getRelativeDataView(), needAggr = true, needRegr = false;
    const spec = this._spec, relativeSeries = this._relativeSeries, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    if (doXYProcess) options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }, {
      dim: "y",
      specValue: spec.y1
    }])];
    else if (doXProcess) options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }])];
    else if (doYProcess) options = [this._processSpecByDims([{
      dim: "y",
      specValue: spec.y
    }])];
    else if (doXYY1Process) options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y1
    }])];
    else if (doYXX1Process) options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }, {
      dim: "y",
      specValue: spec.y
    }])];
    else if (doCoordinatesProcess) {
      if (options = this._processSpecCoo(spec), needAggr = false, processData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_data`
      }).parse([relativeSeries.getViewData()], {
        type: "dataview"
      }).transform({
        type: "markerAggregation",
        options
      }), spec.process && isValid_default(spec.process.x) && (options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.process.x
      }])], needAggr = true), spec.process && isValid_default(spec.process.y) && (options = options = [this._processSpecByDims([{
        dim: "y",
        specValue: spec.process.y
      }])], needAggr = true), spec.process && isValid_default(spec.process.xy)) {
        const { xField, yField } = relativeSeries.getSpec();
        options = {
          fieldX: xField,
          fieldY: yField
        }, needRegr = true;
      }
    } else needAggr = false;
    return {
      options,
      needAggr,
      needRegr,
      processData
    };
  }
};
CartesianMarkLine.type = ComponentTypeEnum.markLine, CartesianMarkLine.coordinateType = "cartesian";
var registerMarkLine = () => {
  Factory2.registerComponent(CartesianMarkLine.type, CartesianMarkLine), registerMarkLineAnimate();
};

// node_modules/@visactor/vchart/esm/component/marker/mark-line/polar-mark-line.js
var PolarMarkLine = class extends BaseMarkLine {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkLine, this.name = ComponentTypeEnum.polarMarkLine, this.coordinateType = "polar";
  }
  _newMarkLineComponent(attr) {
    const { doRadiusProcess, doRadAngAng1Process } = getMarkLineProcessInfo(this._spec);
    return doRadiusProcess || doRadAngAng1Process ? new MarkArcLine(attr) : new MarkLine(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a, { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let points = [], pointsAttr = {};
    const center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    if (doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess) {
      const polarPoints = polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      points = 1 === polarPoints.length ? polarPoints[0] : polarPoints.map((point6) => point6[0]), pointsAttr = points[0].radius === points[1].radius ? {
        radius: points[0].radius,
        startAngle: points[0].angle,
        endAngle: points[1].angle,
        center: center2
      } : {
        points: points.map((point6) => polarToCartesian(center2, point6.radius, point6.angle))
      };
    } else doCoordinatesProcess && (points = polarCoordinateLayout(data, relativeSeries, autoRange), pointsAttr = {
      points: points.map((point6) => polarToCartesian(center2, point6.radius, point6.angle))
    });
    return pointsAttr;
  }
  _computeOptions() {
    const spec = this._spec, { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let options;
    const processData = this._getRelativeDataView();
    return doRadAngProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doAngleProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }])] : doRadiusProcess ? options = [this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius
    }])] : doAngRadRad1Process ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doRadAngAng1Process ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options,
      needAggr: true,
      needRegr: false,
      processData
    };
  }
};
PolarMarkLine.type = ComponentTypeEnum.polarMarkLine, PolarMarkLine.coordinateType = "polar";
var registerPolarMarkLine = () => {
  Factory2.registerComponent(PolarMarkLine.type, PolarMarkLine), registerMarkArcLineAnimate(), registerMarkLineAnimate();
};

// node_modules/@visactor/vchart/esm/component/title/title.js
var Title3 = class extends BaseComponent {
  get orient() {
    return this._orient;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.title, this.specKey = ComponentTypeEnum.title, this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Title, this.layoutLevel = LayoutLevel.Title, this._orient = "top", this._orient = isValidOrient(spec.orient) ? spec.orient : "top";
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, ComponentTypeEnum.title, (s2) => false !== s2.visible);
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return (null == prevSpec ? void 0 : prevSpec.orient) === (null == spec ? void 0 : spec.orient) && (null == prevSpec ? void 0 : prevSpec.visible) === spec.visible || (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  afterSetLayoutStartPoint(pos) {
    isValidNumber_default(pos.x) && this._titleComponent && this._titleComponent.setAttribute("x", pos.x), isValidNumber_default(pos.y) && this._titleComponent && this._titleComponent.setAttribute("y", pos.y), super.afterSetLayoutStartPoint(pos);
  }
  getBoundsInRect(rect) {
    let result2 = {};
    this.setLayoutRect(rect);
    const attrs = this._getTitleAttrs();
    this._createOrUpdateTitleComponent(attrs), result2 = this._getTitleLayoutRect();
    const { x, y } = this.getLayoutStartPoint();
    return {
      x1: x,
      y1: y,
      x2: x + result2.width,
      y2: y + result2.height
    };
  }
  _getTitleLayoutRect() {
    const titleBounds = this._titleComponent.AABBBounds;
    return {
      width: this._spec.width ? this._spec.width : isValidNumber_default(titleBounds.width()) ? titleBounds.width() : 0,
      height: this._spec.height ? this._spec.height : isValidNumber_default(titleBounds.height()) ? titleBounds.height() : 0
    };
  }
  _getTitleAttrs() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (false === this._spec.visible) return {
      visible: false
    };
    const layoutRect = this.getLayoutRect(), titleWidth = calcLayoutNumber(this._spec.width, layoutRect.width, null, layoutRect.width), titleMaxWidth = calcLayoutNumber(this._spec.maxWidth, layoutRect.width, null, layoutRect.width), maxWidth = Math.max(Math.min(titleWidth, titleMaxWidth, layoutRect.width), 0), attrs = Object.assign(Object.assign({}, pickWithout(this._spec, ["padding"])), {
      textType: null !== (_a = this._spec.textType) && void 0 !== _a ? _a : "text",
      text: null !== (_b = this._spec.text) && void 0 !== _b ? _b : "",
      subtextType: null !== (_c = this._spec.subtextType) && void 0 !== _c ? _c : "text",
      subtext: null !== (_d = this._spec.subtext) && void 0 !== _d ? _d : "",
      x: null !== (_e = this._spec.x) && void 0 !== _e ? _e : 0,
      y: null !== (_f = this._spec.y) && void 0 !== _f ? _f : 0,
      height: this._spec.height,
      minWidth: this._spec.minWidth,
      maxWidth,
      minHeight: this._spec.minHeight,
      maxHeight: this._spec.maxHeight,
      padding: this._spec.innerPadding,
      align: null !== (_g = this._spec.align) && void 0 !== _g ? _g : "left",
      verticalAlign: null !== (_h = this._spec.verticalAlign) && void 0 !== _h ? _h : "top",
      textStyle: Object.assign({
        width: maxWidth,
        maxLineWidth: maxWidth
      }, this._spec.textStyle),
      subtextStyle: Object.assign({
        maxLineWidth: maxWidth
      }, this._spec.subtextStyle)
    });
    return isValid_default(this._spec.width) && (attrs.textStyle.width = Math.max(titleWidth, layoutRect.width), attrs.subtextStyle.width = attrs.textStyle.width), attrs;
  }
  _createOrUpdateTitleComponent(attrs) {
    if (this._titleComponent) isEqual(attrs, this._cacheAttrs) || this._titleComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), title3 = new Title(attrs);
      title3.name = "title", container2.add(title3), this._titleComponent = title3, title3.on("*", (event, type) => this._delegateEvent(title3, event, type));
    }
    return this._cacheAttrs = attrs, this._titleComponent;
  }
  _getNeedClearVRenderComponents() {
    return [this._titleComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null;
  }
};
Title3.type = ComponentTypeEnum.title, Title3.specKey = ComponentTypeEnum.title;
var registerTitle2 = () => {
  Factory2.registerComponent(Title3.type, Title3);
};

// node_modules/@visactor/vchart/esm/component/marker/mark-area/base-mark-area.js
var BaseMarkArea = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markArea", this.layoutZIndex = LayoutZIndex.MarkArea;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doAngleProcess, doRadiusProcess, doRadAngProcess } = getMarkAreaProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doRadAngProcess ? "polar" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const label = array(null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}), markAreaAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      hover: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      select: null === (_d = this._spec.interactive) || void 0 === _d || _d,
      points: [{
        x: 0,
        y: 0
      }],
      center: {
        x: 0,
        y: 0
      },
      innerRadius: 0,
      outerRadius: 0,
      startAngle: 0,
      endAngle: 0,
      areaStyle: transformStyle(transformToGraphic(null === (_e = this._spec.area) || void 0 === _e ? void 0 : _e.style), this._markerData, this._markAttributeContext),
      clipInRange: null !== (_f = this._spec.clip) && void 0 !== _f && _f,
      label: label.map((labelItem) => transformLabelAttributes(labelItem, this._markerData, this._markAttributeContext)),
      state: {
        area: transformState(null === (_g = this._spec.area) || void 0 === _g ? void 0 : _g.state, this._markerData, this._markAttributeContext),
        label: label.map((labelItem) => transformState(labelItem.state, this._markerData, this._markAttributeContext)),
        labelBackground: label.map((labelItem) => {
          var _a2;
          return transformState(null === (_a2 = labelItem.labelBackground) || void 0 === _a2 ? void 0 : _a2.state, this._markerData, this._markAttributeContext);
        })
      },
      animation: null !== (_h = this._spec.animation) && void 0 !== _h && _h,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    return this._newMarkAreaComponent(markAreaAttrs);
  }
  _markerLayout() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || array(spec.label).some((labelCfg) => null == labelCfg ? void 0 : labelCfg.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    if (this._markerComponent) {
      const prevLabelAttrs = array(null === (_a = this._markerComponent.attribute) || void 0 === _a ? void 0 : _a.label), specLabels = array(this._spec.label);
      this._markerComponent.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
        label: prevLabelAttrs.map((prevLabel, index) => {
          const specLabel = specLabels[index] || {};
          return Object.assign(Object.assign({}, prevLabel), {
            text: specLabel.formatMethod ? specLabel.formatMethod(dataPoints, seriesData) : null == prevLabel ? void 0 : prevLabel.text
          });
        }),
        limitRect,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      }));
    }
  }
  _initDataView() {
    const spec = this._spec, { doXProcess, doYProcess, doXYProcess, doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    if (!(doXProcess || doYProcess || doXYProcess || doAngleProcess || doRadiusProcess || doRadAngProcess || doCoordinatesProcess)) return null;
    this._initCommonDataView();
  }
};
BaseMarkArea.specKey = "markArea";

// node_modules/@visactor/vchart/esm/component/marker/mark-area/cartesian-mark-area.js
var CartesianMarkArea = class extends BaseMarkArea {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markArea, this.name = ComponentTypeEnum.markArea, this.coordinateType = "cartesian";
  }
  _newMarkAreaComponent(attr) {
    return new MarkArea(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, { doXProcess, doYProcess, doXYProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points = [], lines = [];
    if (doXYProcess) {
      lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      const [start, end] = lines;
      start && start.length && end && end.length && (points = [{
        x: start[0].x,
        y: end[0].y
      }, start[0], {
        x: end[0].x,
        y: start[0].y
      }, end[0]]);
    } else if (doXProcess || doYProcess) {
      lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      const [start, end] = lines;
      start && start.length && end && end.length && (points = [...start, end[1], end[0]]);
    } else doCoordinatesProcess ? points = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    return {
      points
    };
  }
  _computeOptions() {
    const spec = this._spec, { doXProcess, doYProcess, doXYProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    let options;
    return doXYProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }, {
      dim: "y",
      specValue: spec.y1
    }])] : doXProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }])] : doYProcess ? options = [this._processSpecByDims([{
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "y",
      specValue: spec.y1
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
CartesianMarkArea.type = ComponentTypeEnum.markArea, CartesianMarkArea.coordinateType = "cartesian";
var registerMarkArea = () => {
  Factory2.registerComponent(CartesianMarkArea.type, CartesianMarkArea), registerMarkAreaAnimate();
};

// node_modules/@visactor/vchart/esm/component/marker/mark-area/polar-mark-area.js
var PolarMarkArea = class extends BaseMarkArea {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkArea, this.name = ComponentTypeEnum.polarMarkArea, this.coordinateType = "polar";
  }
  _newMarkAreaComponent(attr) {
    const { doRadiusProcess, doAngleProcess, doRadAngProcess } = getMarkAreaProcessInfo(this._spec);
    return doAngleProcess || doRadiusProcess || doRadAngProcess ? new MarkArcArea(attr) : new MarkArea(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, { doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points, pointsAttr = {};
    const center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    if (doAngleProcess || doRadiusProcess || doRadAngProcess) {
      const polarLines = polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      doRadAngProcess ? pointsAttr = {
        innerRadius: polarLines[0][0].radius,
        outerRadius: polarLines[1][0].radius,
        startAngle: polarLines[0][0].angle,
        endAngle: polarLines[1][0].angle,
        center: center2
      } : doAngleProcess ? pointsAttr = {
        innerRadius: 0,
        outerRadius: Math.abs(polarLines[0][0].radius),
        startAngle: polarLines[0][1].angle,
        endAngle: polarLines[1][1].angle,
        center: center2
      } : doRadiusProcess && (pointsAttr = {
        innerRadius: polarLines[0][0].radius,
        outerRadius: polarLines[1][0].radius,
        startAngle: polarLines[0][0].angle,
        endAngle: polarLines[1][1].angle,
        center: center2
      });
    } else doCoordinatesProcess && (points = polarCoordinateLayout(data, relativeSeries, autoRange), pointsAttr = {
      points: points.map((point6) => polarToCartesian(center2, point6.radius, point6.angle))
    });
    return pointsAttr;
  }
  _computeOptions() {
    const spec = this._spec, { doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    let options;
    return doRadAngProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doAngleProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius
    }])] : doRadiusProcess ? options = [this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius1
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
PolarMarkArea.type = ComponentTypeEnum.polarMarkArea, PolarMarkArea.coordinateType = "polar";
var registerPolarMarkArea = () => {
  Factory2.registerComponent(PolarMarkArea.type, PolarMarkArea), registerMarkArcAreaAnimate(), registerMarkAreaAnimate();
};

// node_modules/@visactor/vchart/esm/component/player/utils/transform.js
var rectToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var symbolToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var baseToAttribute = (spec) => Object.assign(Object.assign({}, spec), {
  style: Object.assign({}, transformToGraphic(spec.style))
});
var transformToAttrs = (spec) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  const trackStyle = rectToAttribute(null !== (_b = null === (_a = null == spec ? void 0 : spec.slider) || void 0 === _a ? void 0 : _a.trackStyle) && void 0 !== _b ? _b : {}), railStyle = rectToAttribute(null !== (_d = null === (_c = null == spec ? void 0 : spec.slider) || void 0 === _c ? void 0 : _c.railStyle) && void 0 !== _d ? _d : {}), handlerStyle = symbolToAttribute(null !== (_f = null === (_e = null == spec ? void 0 : spec.slider) || void 0 === _e ? void 0 : _e.handlerStyle) && void 0 !== _f ? _f : {}), start = baseToAttribute(null !== (_h = null === (_g = null == spec ? void 0 : spec.controller) || void 0 === _g ? void 0 : _g.start) && void 0 !== _h ? _h : {}), pause = baseToAttribute(null !== (_k = null === (_j = null == spec ? void 0 : spec.controller) || void 0 === _j ? void 0 : _j.pause) && void 0 !== _k ? _k : {}), backward = baseToAttribute(null !== (_m = null === (_l = null == spec ? void 0 : spec.controller) || void 0 === _l ? void 0 : _l.backward) && void 0 !== _m ? _m : {}), forward = baseToAttribute(null !== (_p = null === (_o = null == spec ? void 0 : spec.controller) || void 0 === _o ? void 0 : _o.forward) && void 0 !== _p ? _p : {}), attrs = Object.assign(Object.assign({}, spec), {
    direction: spec.direction,
    interval: spec.interval,
    visible: spec.visible,
    orient: null !== (_q = spec.orient) && void 0 !== _q ? _q : "bottom",
    slider: Object.assign(Object.assign({}, spec.slider), {
      trackStyle,
      railStyle,
      handlerStyle
    }),
    controller: Object.assign(Object.assign({}, spec.controller), {
      start,
      pause,
      backward,
      forward
    })
  });
  return spec.visible || (attrs.controller.visible = false, attrs.slider.visible = false), attrs;
};
var transformContinuousSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "continuous"
});
var transformDiscreteSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "discrete"
});

// node_modules/@visactor/vchart/esm/component/player/utils/orient.js
var isVertical2 = (orient) => "left" === orient || "right" === orient;
var isHorizontal3 = (orient) => "top" === orient || "bottom" === orient;

// node_modules/@visactor/vchart/esm/component/player/player.js
var Player2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = LayoutZIndex.Player, this.layoutLevel = LayoutLevel.Player, this.specKey = "player", this.type = ComponentTypeEnum.player, this._orient = "bottom", this._getPlayerAttrs = () => {
      var _a, _b, _c, _d, _e, _f;
      const type = this._spec.type, layoutAttrs = {
        size: {
          width: this._width,
          height: this._height
        },
        dx: null !== (_a = this._spec.dx) && void 0 !== _a ? _a : 0 + this._dx,
        dy: null !== (_b = this._spec.dy) && void 0 !== _b ? _b : 0 + this._dy
      };
      return "discrete" === type ? Object.assign(Object.assign(Object.assign({}, transformDiscreteSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent,
        loop: null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.loop) || void 0 === _d || _d
      }) : Object.assign(Object.assign(Object.assign({}, transformContinuousSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent,
        loop: null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.loop) || void 0 === _f || _f
      });
    }, this._createOrUpdatePlayerComponent = () => {
      const attrs = Object.assign({}, this._getPlayerAttrs()), container2 = this.getContainer();
      this._playerComponent ? isEqual(attrs, this._cacheAttrs) || (this._cacheAttrs = attrs, this._playerComponent.setAttributes(attrs), this._playerComponent._initAttributes(), this._playerComponent.render()) : ("discrete" === attrs.type ? this._playerComponent = new DiscretePlayer(attrs) : this._playerComponent = new ContinuousPlayer(attrs), this._cacheAttrs = attrs, this._playerComponent.name = "player", container2.add(this._playerComponent), this._initEvent());
    }, this._maxSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      return Math.max(...array(null === (_b = null === (_a = this._spec.controller.start) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.size), ...array(null === (_d = null === (_c = this._spec.controller.pause) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.size), ...array(null === (_f = null === (_e = this._spec.controller.backward) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.size), ...array(null === (_h = null === (_g = this._spec.controller.forward) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size), null !== (_j = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _j ? _j : 10);
    }, this._sliderExceededSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const sliderHeight = null !== (_a = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _a ? _a : 10, controllersHeight = Math.max(...array(null === (_c = null === (_b = this._spec.controller.start) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size), ...array(null === (_e = null === (_d = this._spec.controller.pause) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size), ...array(null === (_g = null === (_f = this._spec.controller.backward) || void 0 === _f ? void 0 : _f.style) || void 0 === _g ? void 0 : _g.size), ...array(null === (_j = null === (_h = this._spec.controller.forward) || void 0 === _h ? void 0 : _h.style) || void 0 === _j ? void 0 : _j.size));
      return sliderHeight >= controllersHeight ? sliderHeight - controllersHeight : 0;
    }, this._initEvent = () => {
      this._option.disableTriggerEvent || (this._option.globalInstance.on(ChartEvent.rendered, () => {
        var _a;
        (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.auto) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.end, () => {
        var _a;
        this.event.emit(ChartEvent.playerEnd, {
          model: this
        }), this._alternate && "discrete" === this._spec.type && (this._direction = "default" === this._direction ? "reverse" : "default", this._playerComponent.setAttributes({
          direction: this._direction,
          dataIndex: "reverse" === this._direction ? this._specs.length - 2 : 1
        })), (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.loop) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.change, (e) => {
        const { index } = e.detail;
        this.changePlayerIndex(index);
      }), this._playerComponent.addEventListener(PlayerEventEnum.backward, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerBackward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.forward, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerForward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.play, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPlay, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.pause, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPause, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }));
    };
  }
  get orient() {
    return this._orient;
  }
  set layoutOrient(v) {
    this._orient = v;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super.setAttrFromSpec(), this._orient = null !== (_a = this._spec.orient) && void 0 !== _a ? _a : "bottom", this._specs = null !== (_b = this._spec.specs) && void 0 !== _b ? _b : [], this._direction = null !== (_c = this._spec.direction) && void 0 !== _c ? _c : "default", this._alternate = null !== (_d = this._spec.alternate) && void 0 !== _d && _d, this._dx = null !== (_e = this._spec.dx) && void 0 !== _e ? _e : 0, this._dy = null !== (_f = this._spec.dy) && void 0 !== _f ? _f : 0, this._position = null !== (_g = this._spec.position) && void 0 !== _g ? _g : "middle", this._visible = null === (_h = this._spec.visible) || void 0 === _h || _h;
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), isValidNumber_default(pos.x)) {
      const offsetX = isVertical2(this._orient) ? pos.x + this._sliderExceededSize() / 2 : pos.x;
      this._playerComponent && this._playerComponent.setAttribute("x", offsetX);
    }
    if (isValidNumber_default(pos.y)) {
      const offsetY = isHorizontal3(this._orient) ? pos.y + this._sliderExceededSize() / 2 : pos.y;
      this._playerComponent && this._playerComponent.setAttribute("y", offsetY);
    }
  }
  getBoundsInRect(rect, fullSpace) {
    this._width = this._computeWidth(rect), this._height = this._computeHeight(rect), this._dx = this._computeDx(fullSpace), this._dy = this._computeDy(fullSpace);
    const bounds = this._computeLayoutRect(rect, this._width, this._height);
    return this._createOrUpdatePlayerComponent(), bounds;
  }
  changeRegions(regions) {
  }
  onRender(ctx) {
  }
  _getNeedClearVRenderComponents() {
    return [this._playerComponent];
  }
  _computeLayoutRect(rect, width, height) {
    if (false === this._visible) return {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
    switch (this._orient) {
      case "top":
      case "left":
        return {
          x1: 0,
          y1: 0,
          x2: width,
          y2: height
        };
      case "right":
        return {
          x1: rect.width - width,
          y1: 0,
          x2: rect.width,
          y2: rect.height
        };
      default:
        return {
          x1: 0,
          y1: rect.height - height,
          x2: rect.width,
          y2: rect.height
        };
    }
  }
  _computeWidth(rect) {
    return isNumber_default(this._spec.width) ? Math.min(rect.width, Number(this._spec.width)) : isVertical2(this._orient) ? this._maxSize() : rect.width;
  }
  _computeHeight(rect) {
    return isNumber_default(this._spec.height) ? (this._height = this._spec.height, Math.min(rect.height, Number(this._spec.height))) : isHorizontal3(this._orient) ? this._maxSize() : rect.height;
  }
  _computeDx(rect) {
    return isVertical2(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.width - this._width) / 2 : rect.width - this._width;
  }
  _computeDy(rect) {
    return isHorizontal3(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.height - this._height) / 2 : rect.height - this._height;
  }
  changePlayerIndex(index) {
    const spec = this._specs[index];
    array(spec.data).forEach((data) => {
      var _a, _b;
      null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b || _b.updateData(data.id, data.values);
    }), this.event.emit(ChartEvent.playerChange, {
      model: this,
      value: {
        spec,
        index,
        specs: this._specs
      }
    });
  }
};
Player2.specKey = "player", Player2.type = ComponentTypeEnum.player;
var registerPlayer2 = () => {
  Factory2.registerComponent(Player2.type, Player2);
};

// node_modules/@visactor/vchart/esm/component/label/base-label.js
var BaseLabelComponent = class extends BaseComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Label, this._regions = options.getRegionsInIndex(options.regionIndexes);
  }
  _interactiveConfig(labelSpec) {
    const { interactive } = labelSpec, result2 = {
      hover: false,
      select: false,
      state: labelSpec.state
    };
    if (true !== interactive) return result2;
    const { hover, select } = this._option.getChart().getSpec();
    return false === hover && false === hover.enable || (result2.hover = true), false === select && false === select.enable || (result2.select = true), result2;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, isEqual(prevSpec, spec) || (result2.reMake = true), result2;
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
};
BaseLabelComponent.type = ComponentTypeEnum.label;

// node_modules/@visactor/vchart/esm/mark/label.js
var LabelMark = class extends TextMark {
  constructor() {
    super(...arguments), this.skipEncode = false;
  }
  getRule() {
    return this._rule;
  }
  setRule(rule) {
    this._rule = rule;
  }
  getTarget() {
    return this._target;
  }
  setTarget(target) {
    this._target = target, this._rule || this.setRule(target.type);
  }
  getComponent() {
    return this._component;
  }
  setComponent(component2) {
    this._component = component2;
  }
};
LabelMark.type = "text", LabelMark.constructorType = "label";
var registerLabelMark = () => {
  Factory2.registerMark(LabelMark.constructorType, LabelMark), registerTextGraphic2();
};

// node_modules/@visactor/vchart/esm/component/label/label-transformer.js
var LabelSpecTransformer = class extends BaseComponentSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// node_modules/@visactor/vchart/esm/component/label/label.js
var Label2 = class extends BaseLabelComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.specKey = "label", this.transformerConstructor = LabelSpecTransformer, this.layoutZIndex = LayoutZIndex.Label, this._layoutRule = spec.labelLayout || "series";
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    const specInfo = [], regionSpecInfo = (null == chartSpecInfo ? void 0 : chartSpecInfo.region) || [];
    return regionSpecInfo.forEach((regionInfo, i) => {
      (regionInfo.seriesIndexes || []).some((seriesIndex) => {
        const seriesInfo = chartSpecInfo.series[seriesIndex], { markLabelSpec = {} } = seriesInfo;
        return Object.values(markLabelSpec).some((labelSpecList) => Array.isArray(labelSpecList) && ((labelSpecList2) => labelSpecList2.some((labelSpec) => labelSpec.visible))(labelSpecList));
      }) && specInfo.push({
        spec: chartSpec,
        type: ComponentTypeEnum.label,
        specInfoPath: ["component", this.specKey, i],
        regionIndexes: [i]
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this.initEvent(), this._initTextMark(), this._initLabelComponent(), this._initTextMarkStyle();
  }
  reInit(spec) {
    super.reInit(spec), this._labelInfoMap && this._labelInfoMap.clear(), this._initTextMark(), this._initTextMarkStyle();
  }
  initEvent() {
    this.event.on(ChartEvent.dataZoomChange, () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.disableAnimation();
      }), this.event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    });
    const enableAnimation = () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.enableAnimation();
      }), this.event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    };
  }
  _initTextMark() {
    this._labelInfoMap || (this._labelInfoMap = /* @__PURE__ */ new Map()), this._labelComponentMap || (this._labelComponentMap = /* @__PURE__ */ new Map()), eachSeries(this._regions, (series2) => {
      const { markLabelSpec = {} } = series2.getSpecInfo(), markNames = Object.keys(markLabelSpec), region = series2.getRegion();
      this._labelInfoMap.get(region) || this._labelInfoMap.set(region, []);
      for (let i = 0; i < markNames.length; i++) {
        const markName = markNames[i], mark = series2.getMarkInName(markName);
        mark && markLabelSpec[markName].forEach((spec, index) => {
          var _a, _b;
          if (spec.visible) {
            const info = this._labelInfoMap.get(region), labelMark = this._createMark({
              type: "label",
              name: `${markName}-label-${index}`
            }, {
              noSeparateStyle: true,
              attributeContext: series2.getMarkAttributeContext()
            });
            spec.showRelatedMarkTooltip && (null === (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.activeTriggerSet.mark) || void 0 === _b || _b.add(labelMark)), labelMark.setTarget(mark), info.push({
              labelMark,
              baseMark: mark,
              series: series2,
              labelSpec: spec
            });
          }
        });
      }
    });
  }
  _initLabelComponent() {
    this._labelInfoMap.forEach((regionLabelInfo, region) => {
      if ("region" === this._layoutRule) {
        const component2 = this._createMark({
          type: "component",
          name: `${region.getGroupMark().name}-label-component`
        }, {
          componentType: "label",
          noSeparateStyle: true
        }, {
          support3d: this._spec.support3d
        });
        component2 && (component2.setSkipBeforeLayouted(true), regionLabelInfo[0] && isValid_default(regionLabelInfo[0].labelSpec.zIndex) && component2.setMarkConfig({
          zIndex: regionLabelInfo[0].labelSpec.zIndex
        }), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)));
      } else regionLabelInfo.forEach((labelInfo, i) => {
        const component2 = this._createMark({
          type: "component",
          name: `${labelInfo.labelMark.name}-component`
        }, {
          componentType: "label",
          noSeparateStyle: true
        }, {
          support3d: labelInfo.baseMark.getMarkConfig().support3d
        });
        component2 && (isValid_default(labelInfo.labelSpec.zIndex) && component2.setMarkConfig({
          zIndex: labelInfo.labelSpec.zIndex
        }), component2.setSkipBeforeLayouted(true), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)[i]));
      });
    });
  }
  _initTextMarkStyle() {
    this._labelComponentMap.forEach((labelInfoCb, labelComponent) => {
      array(labelInfoCb()).forEach(({ labelMark }) => {
        labelMark.setComponent(labelComponent);
      });
    }), this._labelInfoMap.forEach((labelInfos) => {
      labelInfos.forEach((info) => {
        var _a, _b;
        const { labelMark, labelSpec, series: series2 } = info;
        if (this.initMarkStyleWithSpec(labelMark, labelSpec, void 0), isFunction_default(null == labelSpec ? void 0 : labelSpec.getStyleHandler)) {
          const styleHandler = labelSpec.getStyleHandler(series2);
          null == styleHandler || styleHandler.call(series2, labelMark, labelSpec);
        }
        (null === (_b = null === (_a = labelMark.stateStyle) || void 0 === _a ? void 0 : _a.normal) || void 0 === _b ? void 0 : _b.lineWidth) && labelMark.setAttribute("stroke", series2.getColorAttribute(), "normal", AttributeLevel.Base_Series);
      });
    });
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute(), this._labelComponentMap.forEach((labelInfoCb, labelComponent) => {
      const labelInfo = labelInfoCb();
      isArray_default(labelInfo) ? this._updateMultiLabelAttribute(labelInfo, labelComponent) : this._updateSingleLabelAttribute(labelInfo, labelComponent);
    });
  }
  _updateMultiLabelAttribute(labelInfo, labelComponent) {
    this._updateLabelComponentAttribute(labelComponent.getProduct(), labelInfo.map(({ baseMark }) => baseMark.getProduct()), labelInfo);
  }
  _updateSingleLabelAttribute(labelInfo, labelComponent) {
    const { baseMark } = labelInfo;
    this._updateLabelComponentAttribute(labelComponent.getProduct(), baseMark.getProduct(), [labelInfo]);
  }
  _updateLabelComponentAttribute(component2, target, labelInfos) {
    const dependCmp = this._option.getComponentsByType("totalLabel");
    component2.target(target).configure({
      interactive: false
    }).depend(dependCmp.map((cmp) => cmp.getMarks()[0].getProduct())).labelStyle((mark, params2) => {
      var _a, _b;
      const labelInfo = labelInfos[params2.labelIndex];
      if (labelInfo) {
        const { labelSpec, labelMark, series: series2 } = labelInfo, rule = labelMark.getRule(), interactive = this._interactiveConfig(labelSpec), centerOffset = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerOffset) && void 0 !== _b ? _b : 0;
        let spec = mergeSpec({
          textStyle: Object.assign({
            pickable: true === labelSpec.interactive
          }, labelSpec.style),
          overlap: {
            avoidMarks: dependCmp.map((cmp) => cmp.getMarks()[0].getProductId())
          }
        }, defaultLabelConfig(rule, labelInfo), Object.assign(Object.assign(Object.assign({}, pickWithout(labelSpec, ["position", "style", "state", "type", "stackDataFilterType", "getStyleHandler"])), interactive), {
          centerOffset
        }), labelSpec.stackDataFilterType ? {
          dataFilter: "min" === labelSpec.stackDataFilterType ? (data) => data.filter((d) => d.data[STACK_FIELD_TOTAL_BOTTOM]) : (data) => data.filter((d) => d.data[STACK_FIELD_TOTAL_TOP])
        } : {});
        return series2 && series2.parseLabelStyle && (spec = series2.parseLabelStyle(spec, labelSpec, labelMark)), "line" !== rule && "area" !== rule || (spec.type = rule), spec;
      }
    }).encode((datum, element, params2) => {
      if (labelInfos[params2.labelIndex]) {
        const { labelSpec, labelMark } = labelInfos[params2.labelIndex];
        return labelMark.skipEncode ? {
          data: datum
        } : textAttribute(labelInfos[params2.labelIndex], datum, labelSpec.formatMethod, labelSpec.formatter);
      }
    }).size(() => {
      var _a;
      return Object.assign({
        padding: null === (_a = labelInfos[0].labelSpec.overlap) || void 0 === _a ? void 0 : _a.padding
      }, labelInfos[0].series.getRegion().getLayoutRect());
    });
  }
  compileMarks() {
    this.getMarks().forEach((m4) => {
      const labelInfo = this._labelComponentMap.get(m4)();
      let group;
      group = isArray_default(labelInfo) ? labelInfo[0].series.getRegion().getGroupMark().getProduct() : labelInfo.series.getRegion().getGroupMark().getProduct(), m4.compile({
        group,
        context: {
          model: this,
          labelInfo
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this._labelComponentMap.forEach((infoFunc, component2) => {
      const graphicItem = component2.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
  getLabelInfoByTextGraphic(text2) {
    let labelInfo;
    const vrenderLabel = null == text2 ? void 0 : text2.parent, vrenderDataLabel = null == vrenderLabel ? void 0 : vrenderLabel.parent;
    if (vrenderDataLabel) {
      const labelIndex = vrenderDataLabel.getChildren().indexOf(vrenderLabel);
      this._labelComponentMap.forEach((infoFunc, component2) => {
        component2.getProduct().getGroupGraphicItem() === vrenderDataLabel && (labelInfo = array(infoFunc())[labelIndex]);
      });
    }
    return labelInfo;
  }
};
Label2.type = ComponentTypeEnum.label, Label2.specKey = "label", Label2.transformerConstructor = LabelSpecTransformer;
var registerLabel2 = () => {
  registerLabel(), registerLabelMark(), registerComponentMark(), Factory2.registerComponent(Label2.type, Label2, true);
};

// node_modules/@visactor/vchart/esm/component/label/total-label.js
var TotalLabel = class extends BaseLabelComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.totalLabel, this.name = ComponentTypeEnum.totalLabel, this.specKey = "totalLabel", this.layoutZIndex = LayoutZIndex.Label;
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    var _a;
    const specInfo = [];
    return null === (_a = null == chartSpecInfo ? void 0 : chartSpecInfo.region) || void 0 === _a || _a.forEach((regionInfo, regionIndex) => {
      var _a2;
      null === (_a2 = regionInfo.seriesIndexes) || void 0 === _a2 || _a2.forEach((seriesIndex) => {
        const { spec } = chartSpecInfo.series[seriesIndex], labelSpec = spec[this.specKey];
        (null == labelSpec ? void 0 : labelSpec.visible) && specInfo.push({
          spec: labelSpec,
          type: ComponentTypeEnum.totalLabel,
          specPath: ["series", seriesIndex, this.specKey],
          specInfoPath: ["component", this.specKey, seriesIndex],
          regionIndexes: [regionIndex],
          seriesIndexes: [seriesIndex]
        });
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this._initTextMark(), this._initLabelComponent();
  }
  reInit(spec) {
    super.reInit(spec), this._initTextMark();
  }
  _initTextMark() {
    var _a;
    const series2 = this._getSeries();
    if (null === (_a = series2.getSpec().totalLabel) || void 0 === _a ? void 0 : _a.visible) {
      const mark = series2.getSeriesMark();
      if (mark) {
        const textMark = this._createMark({
          type: "label",
          name: `${mark.name}-total-label`
        });
        this._baseMark = mark, this._textMark = textMark, this._initTextMarkStyle();
      }
    }
  }
  _initTextMarkStyle() {
    var _a;
    super.initMarkStyleWithSpec(this._textMark, this._spec), this.setMarkStyle(this._textMark, {
      text: (datum) => datum[STACK_FIELD_TOTAL]
    }, "normal", AttributeLevel.Default);
    const series2 = this._getSeries();
    null === (_a = series2.initTotalLabelMarkStyle) || void 0 === _a || _a.call(series2, this._textMark);
  }
  _initLabelComponent() {
    const series2 = this._getSeries(), component2 = this._createMark({
      type: "component",
      name: `${series2.name}-total-label-component`
    }, {
      componentType: "label",
      noSeparateStyle: true
    }, {
      support3d: this._spec.support3d
    });
    component2 && this._marks.addMark(component2);
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute();
    const series2 = this._getSeries();
    this._marks.forEach((componentMark, index) => {
      componentMark.getProduct().target(this._baseMark.getProduct()).configure({
        interactive: false
      }).labelStyle(() => {
        var _a, _b;
        if (this._baseMark) {
          const { offset, animation, overlap: overlap2, position = "top" } = this._spec, interactive = this._interactiveConfig(this._spec);
          return mergeSpec({
            textStyle: {
              pickable: true === this._spec.interactive
            },
            position: totalLabelPosition(series2, this._baseMark.type, position),
            x: 0,
            y: 0
          }, null !== (_b = null === (_a = series2.getTotalLabelComponentStyle) || void 0 === _a ? void 0 : _a.call(series2, {
            baseMark: this._baseMark,
            labelMark: this._textMark
          })) && void 0 !== _b ? _b : {}, Object.assign({
            offset,
            animation,
            overlap: overlap2,
            dataFilter: (data) => data.filter((d) => "bottom" === position ? d.data[STACK_FIELD_TOTAL_BOTTOM] : d.data[STACK_FIELD_TOTAL_TOP])
          }, interactive));
        }
      }).encode((datum) => textAttribute({
        baseMark: this._baseMark,
        labelMark: this._textMark,
        series: series2,
        labelSpec: series2.getSpec().totalLabel
      }, datum, this._spec.formatMethod)).size(() => {
        var _a;
        return Object.assign({
          padding: null === (_a = this._spec.overlap) || void 0 === _a ? void 0 : _a.padding
        }, this._regions[0].getLayoutRect());
      });
    });
  }
  compileMarks() {
    this.getMarks().forEach((m4) => {
      const group = this._regions[0].getGroupMark().getProduct();
      m4.compile({
        group,
        context: {
          model: this
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this.getMarks().forEach((m4) => {
      const graphicItem = m4.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
  _getSeries() {
    return this._option.getSeriesInIndex([this.getSpecPath()[1]])[0];
  }
};
TotalLabel.type = ComponentTypeEnum.totalLabel, TotalLabel.specKey = "totalLabel";
function totalLabelPosition(series2, type, position = "top") {
  var _a, _b;
  let finalPosition;
  const { direction } = series2;
  let positionMap;
  positionMap = "bottom" === position ? {
    vertical: ["bottom", "top"],
    horizontal: ["left", "right"]
  } : {
    vertical: ["top", "bottom"],
    horizontal: ["right", "left"]
  };
  const index = ("horizontal" === direction ? null === (_a = series2.getXAxisHelper()) || void 0 === _a ? void 0 : _a.isInverse() : null === (_b = series2.getYAxisHelper()) || void 0 === _b ? void 0 : _b.isInverse()) ? 1 : 0;
  switch (type) {
    case "rect":
    case "symbol":
      finalPosition = positionMap[direction][index];
      break;
    default:
      finalPosition = "top";
  }
  return finalPosition;
}
var registerTotalLabel = () => {
  registerLabel(), registerLabelMark(), registerComponentMark(), Factory2.registerComponent(TotalLabel.type, TotalLabel, true);
};

// node_modules/@visactor/vchart/esm/component/marker/mark-point/base-mark-point.js
var __rest32 = function(s2, e) {
  var t = {};
  for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseMarkPoint = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markPoint", this.layoutZIndex = LayoutZIndex.MarkPoint;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doPolarProcess, doGeoProcess } = getMarkPointProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doPolarProcess ? "polar" : "geo" === markerSpec.coordinateType || doGeoProcess ? "geo" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
    const { itemContent = {}, itemLine = {}, targetSymbol = {} } = this._spec, { text: label = {}, symbol, image, richText: richText2 } = itemContent, restItemContent = __rest32(itemContent, ["text", "symbol", "image", "richText"]), markPointAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_a = this._spec.interactive) || void 0 === _a || _a,
      hover: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      select: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      position: {
        x: 0,
        y: 0
      },
      clipInRange: null !== (_d = this._spec.clip) && void 0 !== _d && _d,
      itemContent: Object.assign({
        offsetX: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion()),
        offsetY: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion())
      }, restItemContent),
      targetSymbol: {
        offset: null !== (_e = targetSymbol.offset) && void 0 !== _e ? _e : 0,
        visible: null !== (_f = targetSymbol.visible) && void 0 !== _f && _f,
        size: null !== (_g = targetSymbol.size) && void 0 !== _g ? _g : 20,
        style: transformStyle(targetSymbol.style, this._markerData, this._markAttributeContext)
      },
      state: {
        line: transformState(null !== (_j = null === (_h = this._spec.itemLine.line) || void 0 === _h ? void 0 : _h.state) && void 0 !== _j ? _j : {}, this._markerData, this._markAttributeContext),
        lineStartSymbol: transformState(null !== (_l = null === (_k = this._spec.itemLine.startSymbol) || void 0 === _k ? void 0 : _k.state) && void 0 !== _l ? _l : {}, this._markerData, this._markAttributeContext),
        lineEndSymbol: transformState(null !== (_o = null === (_m = this._spec.itemLine.endSymbol) || void 0 === _m ? void 0 : _m.state) && void 0 !== _o ? _o : {}, this._markerData, this._markAttributeContext),
        symbol: transformState(null !== (_q = null === (_p = this._spec.itemContent.symbol) || void 0 === _p ? void 0 : _p.state) && void 0 !== _q ? _q : {}, this._markerData, this._markAttributeContext),
        image: transformState(null !== (_s = null === (_r = this._spec.itemContent.image) || void 0 === _r ? void 0 : _r.state) && void 0 !== _s ? _s : {}, this._markerData, this._markAttributeContext),
        text: transformState(null !== (_u = null === (_t = this._spec.itemContent.text) || void 0 === _t ? void 0 : _t.state) && void 0 !== _u ? _u : {}, this._markerData, this._markAttributeContext),
        textBackground: transformState(null === (_w = null === (_v = this._spec.itemContent.text) || void 0 === _v ? void 0 : _v.labelBackground) || void 0 === _w ? void 0 : _w.state, this._markerData, this._markAttributeContext),
        richText: transformState(null !== (_y = null === (_x = this._spec.itemContent.richText) || void 0 === _x ? void 0 : _x.state) && void 0 !== _y ? _y : {}, this._markerData, this._markAttributeContext),
        customMark: transformState(null !== (_0 = null === (_z = this._spec.itemContent.customMark) || void 0 === _z ? void 0 : _z.state) && void 0 !== _0 ? _0 : {}, this._markerData, this._markAttributeContext),
        targetItem: transformState(null !== (_2 = null === (_1 = this._spec.targetSymbol) || void 0 === _1 ? void 0 : _1.state) && void 0 !== _2 ? _2 : {}, this._markerData, this._markAttributeContext)
      },
      animation: null !== (_3 = this._spec.animation) && void 0 !== _3 && _3,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    (null == symbol ? void 0 : symbol.style) && (markPointAttrs.itemContent.symbolStyle = transformToGraphic(transformStyle(symbol.style, this._markerData, this._markAttributeContext))), (null == image ? void 0 : image.style) && (markPointAttrs.itemContent.imageStyle = transformStyle(image.style, this._markerData, this._markAttributeContext)), label && (markPointAttrs.itemContent.textStyle = transformLabelAttributes(label, this._markerData, this._markAttributeContext)), (null == richText2 ? void 0 : richText2.style) && (markPointAttrs.itemContent.richTextStyle = transformStyle(richText2.style, this._markerData, this._markAttributeContext));
    const { visible, line: line2 = {} } = itemLine, restItemLine = __rest32(itemLine, ["visible", "line"]);
    markPointAttrs.itemLine = false !== visible ? Object.assign(Object.assign({}, restItemLine), {
      visible: true,
      lineStyle: transformToGraphic(line2.style)
    }) : {
      visible: false
    };
    return new MarkPoint(markPointAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e;
    const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, { point: point6 } = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || (null === (_a = spec.itemContent) || void 0 === _a ? void 0 : _a.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    if (this._markerComponent) {
      const attribute = null !== (_b = this._markerComponent.attribute) && void 0 !== _b ? _b : {}, textStyle = null !== (_d = null === (_c = attribute.itemContent) || void 0 === _c ? void 0 : _c.textStyle) && void 0 !== _d ? _d : {};
      this._markerComponent.setAttributes({
        position: void 0 === point6 ? {
          x: null,
          y: null
        } : point6,
        itemContent: Object.assign(Object.assign({}, attribute.itemContent), {
          textStyle: Object.assign(Object.assign({}, textStyle), {
            text: (null === (_e = this._spec.itemContent.text) || void 0 === _e ? void 0 : _e.formatMethod) ? this._spec.itemContent.text.formatMethod(dataPoints, seriesData) : textStyle.text
          }),
          offsetX: computeOffsetFromRegion(point6, attribute.itemContent.offsetX, this._relativeSeries.getRegion()),
          offsetY: computeOffsetFromRegion(point6, attribute.itemContent.offsetY, this._relativeSeries.getRegion())
        }),
        limitRect,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    }
  }
  _initDataView() {
    const spec = this._spec, { doXYProcess, doPolarProcess, doGeoProcess } = getMarkPointProcessInfo(spec);
    (isValid_default(spec.coordinate) || doXYProcess || doPolarProcess || doGeoProcess) && this._initCommonDataView();
  }
};
BaseMarkPoint.specKey = "markPoint";

// node_modules/@visactor/vchart/esm/component/marker/mark-point/cartesian-mark-point.js
var CartesianMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markPoint, this.name = ComponentTypeEnum.markPoint, this.coordinateType = "cartesian";
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, isXYLayout = isValid_default(spec.x) && isValid_default(spec.y), isCoordinateLayout = isValid_default(spec.coordinate), isPositionLayout = isValid_default(spec.position), autoRange = null !== (_a = null == spec ? void 0 : spec.autoRange) && void 0 !== _a && _a;
    let point6;
    return isXYLayout ? point6 = xyLayout(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0] : isCoordinateLayout ? point6 = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset)[0] : isPositionLayout && (point6 = positionLayout(spec.position, relativeSeries, spec.regionRelative)[0]), {
      point: point6
    };
  }
  _computeOptions() {
    const spec = this._spec, { doXYProcess } = getMarkPointProcessInfo(spec), isCoordinateProcess = isValid_default(spec.coordinate);
    let options;
    return doXYProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }])] : isCoordinateProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
CartesianMarkPoint.type = ComponentTypeEnum.markPoint, CartesianMarkPoint.coordinateType = "cartesian";
var registerMarkPoint = () => {
  Factory2.registerComponent(CartesianMarkPoint.type, CartesianMarkPoint), registerMarkPointAnimate();
};

// node_modules/@visactor/vchart/esm/component/marker/mark-point/polar-mark-point.js
var PolarMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkPoint, this.name = ComponentTypeEnum.polarMarkPoint, this.coordinateType = "polar";
  }
  _computePointsAttr() {
    var _a, _b;
    const data = this._markerData, relativeSeries = this._relativeSeries, autoRange = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.autoRange) && void 0 !== _b && _b, polarPoint = polarLayout(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0], center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    return {
      point: polarToCartesian(center2, polarPoint.radius, polarPoint.angle)
    };
  }
  _computeOptions() {
    const spec = this._spec;
    return {
      options: [this._processSpecByDims([{
        dim: "radius",
        specValue: spec.radius
      }, {
        dim: "angle",
        specValue: spec.angle
      }])]
    };
  }
};
PolarMarkPoint.type = ComponentTypeEnum.polarMarkPoint, PolarMarkPoint.coordinateType = "polar";
var registerPolarMarkPoint = () => {
  Factory2.registerComponent(PolarMarkPoint.type, PolarMarkPoint), registerMarkPointAnimate();
};

// node_modules/@visactor/vchart/esm/component/marker/mark-point/geo-mark-point.js
var GeoMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.geoMarkPoint, this.name = ComponentTypeEnum.geoMarkPoint, this.coordinateType = "geo";
  }
  _computePointsAttr() {
    const data = this._markerData, relativeSeries = this._relativeSeries;
    return {
      point: geoLayout(data, relativeSeries)[0][0]
    };
  }
  _computeOptions() {
    const spec = this._spec;
    return {
      options: [this._processSpecByDims([{
        dim: "areaName",
        specValue: spec.areaName
      }])]
    };
  }
};
GeoMarkPoint.type = ComponentTypeEnum.geoMarkPoint, GeoMarkPoint.coordinateType = "geo";
var registerGeoMarkPoint = () => {
  Factory2.registerComponent(GeoMarkPoint.type, GeoMarkPoint), registerMarkPointAnimate();
};

// node_modules/@visactor/vchart/esm/component/brush/brush.js
var Brush2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this.type = ComponentTypeEnum.brush, this.name = ComponentTypeEnum.brush, this.specKey = "brush", this.layoutZIndex = LayoutZIndex.Brush, this._linkedSeries = [], this._itemMap = {}, this._linkedItemMap = {}, this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, this._cacheInteractiveRangeAttrs = [], this._needDisablePickable = false, this._releatedAxes = [], this._regionAxisMap = {}, this._axisDataZoomMap = {}, this._zoomRecord = [];
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => false !== s2.visible);
  }
  init() {
    const inBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.inBrush), outOfBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.outOfBrush);
    this._option.getAllSeries().forEach((s2) => {
      s2.getActiveMarks().forEach((m4) => {
        m4 && (s2.setMarkStyle(m4, Object.assign({}, inBrushMarkAttr), "inBrush", AttributeLevel.Series), s2.setMarkStyle(m4, Object.assign({}, outOfBrushMarkAttr), "outOfBrush", AttributeLevel.Series));
      });
    });
  }
  _initNeedOperatedItem() {
    const seriesUserId = this._spec.seriesId, seriesIndex = this._spec.seriesIndex;
    this._relativeRegions.forEach((r) => {
      const allMarks = [];
      r.getSeries().forEach((s2) => {
        (seriesUserId && array(seriesUserId).includes(s2.userId.toString()) || seriesIndex && array(seriesIndex).includes(s2.getSpecIndex()) || !seriesIndex && !seriesUserId) && allMarks.push(...s2.getMarksWithoutRoot()), this._itemMap[r.id] = allMarks;
      });
    }), this._linkedSeries.forEach((s2) => {
      this._linkedItemMap[s2.id] = s2.getMarksWithoutRoot();
    });
  }
  created() {
    super.created(), this.initEvent(), this._bindRegions(), this._bindLinkedSeries(), this._initRegionAxisMap(), this._initAxisDataZoomMap(), this._initNeedOperatedItem();
  }
  _bindRegions() {
    isValid_default(this._spec.regionId) || isValid_default(this._spec.regionIndex) ? this._relativeRegions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex)) : this._relativeRegions = this._option.getAllRegions();
  }
  _bindLinkedSeries() {
    (isValid_default(this._spec.brushLinkSeriesId) || isValid_default(this._spec.brushLinkSeriesIndex)) && (this._linkedSeries = this._option.getSeriesInUserIdOrIndex(array(this._spec.brushLinkSeriesId), array(this._spec.brushLinkSeriesIndex)));
  }
  _initRegionAxisMap() {
    isValid_default(this._spec.axisId) ? array(this._spec.axisId).forEach((axisId) => {
      this._releatedAxes.push(this._option.getComponentByUserId(axisId));
    }) : isValid_default(this._spec.axisIndex) ? array(this._spec.axisIndex).forEach((axisIndex) => {
      this._releatedAxes.push(this._option.getComponentByIndex("axes", axisIndex));
    }) : this._releatedAxes = this._option.getComponentsByKey("axes"), this._releatedAxes.forEach((axis2) => {
      null == axis2 || axis2.getRegions().forEach((region) => {
        this._regionAxisMap["region_" + region.id] ? this._regionAxisMap["region_" + region.id].push(axis2) : this._regionAxisMap["region_" + region.id] = [axis2];
      });
    });
  }
  _initAxisDataZoomMap() {
    this._option.getComponentsByKey("dataZoom").forEach((dz) => {
      dz.relatedAxisComponent && (this._axisDataZoomMap[dz.relatedAxisComponent.id] = dz);
    });
  }
  initEvent() {
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _compareSpec(spec, prevSpec) {
    this._brushComponents && this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    });
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  onLayoutEnd(ctx) {
    var _a;
    if (super.onLayoutEnd(ctx), this._option.disableTriggerEvent) return;
    (null === (_a = this._spec.visible) || void 0 === _a || _a) && (this._brushComponents ? this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    }) : (this._brushComponents = [], this._relativeRegions.forEach((region, index) => {
      this._createBrushComponent(region, index);
    })));
  }
  _updateBrushComponent(region, componentIndex) {
    const interactiveAttr = this._getBrushInteractiveAttr(region), brushComponent = this._brushComponents[componentIndex];
    brushComponent.setAttributes(interactiveAttr), this._initMarkBrushState(componentIndex, ""), brushComponent.children[0].removeAllChild();
  }
  _createBrushComponent(region, componentIndex) {
    var _a, _b;
    const interactiveAttr = this._getBrushInteractiveAttr(region), brush2 = new Brush(Object.assign(Object.assign(Object.assign({
      zIndex: this.layoutZIndex,
      brushStyle: transformToGraphic(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.style)
    }, interactiveAttr), this._spec), {
      disableTriggerEvent: this._option.disableTriggerEvent
    }));
    brush2.id = null !== (_b = this._spec.id) && void 0 !== _b ? _b : `brush-${this.id}`, this.getContainer().add(brush2), this._brushComponents.push(brush2), this._cacheInteractiveRangeAttrs.push(interactiveAttr), brush2.addEventListener(IOperateType.brushActive, (e) => {
      this._initMarkBrushState(componentIndex, "outOfBrush"), this._emitEvent(ChartEvent.brushActive, region);
    }), brush2.addEventListener(IOperateType.drawStart, (e) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.moveStart, (e) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.drawing, (e) => {
      this._needDisablePickable = true, this._handleBrushChange(region, e), this._emitEvent(ChartEvent.brushChange, region);
    }), brush2.addEventListener(IOperateType.moving, (e) => {
      this._handleBrushChange(region, e), this._emitEvent(ChartEvent.brushChange, region);
    }), brush2.addEventListener(IOperateType.brushClear, (e) => {
      this._initMarkBrushState(componentIndex, ""), this._needDisablePickable = false, this._emitEvent(ChartEvent.brushClear, region);
    }), brush2.addEventListener(IOperateType.drawEnd, (e) => {
      var _a2;
      this._needDisablePickable = false;
      const { operateMask } = e.detail;
      if (null === (_a2 = this._spec) || void 0 === _a2 ? void 0 : _a2.onBrushEnd) true === this._spec.onBrushEnd(e) ? (this.clearGraphic(), this._initMarkBrushState(componentIndex, ""), this._needDisablePickable = false, this._emitEvent(ChartEvent.brushClear, region)) : (this._spec.onBrushEnd(e), this._emitEvent(ChartEvent.brushEnd, region));
      else {
        const inBrushData = this._extendDataInBrush(this._inBrushElementsMap);
        !this._spec.zoomWhenEmpty && inBrushData.length > 0 && this._setAxisAndDataZoom(operateMask, region), this._emitEvent(ChartEvent.brushEnd, region);
      }
    }), brush2.addEventListener(IOperateType.moveEnd, (e) => {
      const { operateMask } = e.detail, inBrushData = this._extendDataInBrush(this._inBrushElementsMap);
      !this._spec.zoomWhenEmpty && inBrushData.length > 0 && this._setAxisAndDataZoom(operateMask, region), this._emitEvent(ChartEvent.brushEnd, region);
    });
  }
  _getBrushInteractiveAttr(region) {
    const regionLayoutPosition = region.getLayoutStartPoint(), regionLayoutRect = region.getLayoutRect(), seriesRegionStartX = regionLayoutPosition.x, seriesRegionEndX = seriesRegionStartX + regionLayoutRect.width, seriesRegionStartY = regionLayoutPosition.y, seriesRegionEndY = seriesRegionStartY + regionLayoutRect.height;
    return {
      interactiveRange: {
        minY: seriesRegionStartY,
        maxY: seriesRegionEndY,
        minX: seriesRegionStartX,
        maxX: seriesRegionEndX
      },
      xRange: [seriesRegionStartX, seriesRegionEndX],
      yRange: [seriesRegionStartY, seriesRegionEndY]
    };
  }
  _transformBrushedMarkAttr(brushedStyle) {
    const styleResult = {};
    return (null == brushedStyle ? void 0 : brushedStyle.symbol) && (styleResult.symbolType = brushedStyle.symbol), (null == brushedStyle ? void 0 : brushedStyle.symbolSize) && (styleResult.size = brushedStyle.symbolSize), (null == brushedStyle ? void 0 : brushedStyle.color) && (styleResult.fill = brushedStyle.color), (null == brushedStyle ? void 0 : brushedStyle.colorAlpha) && (styleResult.fillOpacity = brushedStyle.colorAlpha), Object.assign(Object.assign({}, transformToGraphic(brushedStyle)), styleResult);
  }
  _handleBrushChange(region, e) {
    const { operateMask } = e.detail;
    this._reconfigItem(operateMask, region), this._reconfigLinkedItem(operateMask, region);
  }
  _extendDataInBrush(elementsMap) {
    var _a, _b;
    const data = [];
    for (const brushName in elementsMap) for (const elementKey in elementsMap[brushName]) data.push(Object.assign({}, null === (_b = null === (_a = elementsMap[brushName][elementKey]) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0]));
    return data;
  }
  _extendDatumOutOfBrush(elementsMap) {
    var _a;
    const data = [];
    for (const elementKey in elementsMap) data.push(null === (_a = elementsMap[elementKey].data) || void 0 === _a ? void 0 : _a[0]);
    return data;
  }
  _emitEvent(eventType, region) {
    var _a;
    this.event.emit(eventType, {
      model: this,
      value: {
        operateType: eventType,
        operateRegion: region,
        inBrushData: this._extendDataInBrush(this._inBrushElementsMap),
        outOfBrushData: this._extendDatumOutOfBrush(this._outOfBrushElementsMap),
        linkInBrushData: this._extendDataInBrush(this._linkedInBrushElementsMap),
        linkOutOfBrushData: this._extendDatumOutOfBrush(this._linkedOutOfBrushElementsMap),
        inBrushElementsMap: this._inBrushElementsMap,
        outOfBrushElementsMap: this._outOfBrushElementsMap,
        linkedInBrushElementsMap: this._linkedInBrushElementsMap,
        linkedOutOfBrushElementsMap: this._linkedOutOfBrushElementsMap,
        zoomRecord: this._zoomRecord
      },
      vchart: null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance
    });
  }
  _reconfigItem(operateMask, region) {
    var _a, _b, _c;
    if (!(null == operateMask ? void 0 : operateMask.globalTransMatrix) || !(null === (_a = null == operateMask ? void 0 : operateMask.attribute) || void 0 === _a ? void 0 : _a.points)) return;
    const points = null !== (_c = null === (_b = null == operateMask ? void 0 : operateMask.attribute) || void 0 === _b ? void 0 : _b.points) && void 0 !== _c ? _c : [], { a: a3, b, c: c3, d, e, f } = operateMask.globalTransMatrix, pointsCoord = points.map((p) => ({
      x: a3 * p.x + c3 * p.y + e,
      y: b * p.x + d * p.y + f
    })), { markTypeFilter = [] } = this._spec;
    this._itemMap[region.id].forEach((mark) => {
      if (markTypeFilter.includes(mark.type)) return;
      const grammarMark = mark.getProduct();
      if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
      grammarMark.elements.forEach((el) => {
        var _a2, _b2, _c2;
        const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key, isBrushContainItem = this._isBrushContainItem(operateMask.globalAABBBounds, pointsCoord, graphicItem);
        (null === (_a2 = this._outOfBrushElementsMap) || void 0 === _a2 ? void 0 : _a2[elementKey]) && isBrushContainItem ? (el.addState("inBrush"), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._outOfBrushElementsMap[elementKey]) : (null === (_c2 = null === (_b2 = this._inBrushElementsMap) || void 0 === _b2 ? void 0 : _b2[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c2 ? void 0 : _c2[elementKey]) && !isBrushContainItem && (el.removeState("inBrush"), el.addState("outOfBrush"), this._outOfBrushElementsMap[elementKey] = el, delete this._inBrushElementsMap[operateMask.name][elementKey]), graphicItem.setAttribute("pickable", !this._needDisablePickable);
      });
    });
  }
  _reconfigLinkedItem(operateMask, region) {
    var _a;
    if (!(null == operateMask ? void 0 : operateMask.globalTransMatrix) || !(null === (_a = null == operateMask ? void 0 : operateMask.attribute) || void 0 === _a ? void 0 : _a.points)) return;
    const regionLayoutPos = region.getLayoutStartPoint(), seriesId = region.getSeries().map((s2) => s2.id);
    this._linkedSeries.forEach((s2) => {
      var _a2, _b;
      if (!seriesId.includes(s2.id)) {
        const sRegionLayoutPos = s2.getRegion().getLayoutStartPoint(), regionOffsetX = sRegionLayoutPos.x - regionLayoutPos.x, regionOffsetY = sRegionLayoutPos.y - regionLayoutPos.y, points = null !== (_b = null === (_a2 = null == operateMask ? void 0 : operateMask.attribute) || void 0 === _a2 ? void 0 : _a2.points) && void 0 !== _b ? _b : [], { a: a3, b, c: c3, d, e, f } = operateMask.globalTransMatrix, dx = regionOffsetX || 0, dy = regionOffsetY || 0, pointsCoord = points.map((p) => ({
          x: a3 * p.x + c3 * p.y + e + dx,
          y: b * p.x + d * p.y + f + dy
        }));
        operateMask.globalAABBBounds.clone().set(operateMask.globalAABBBounds.x1 + dx, operateMask.globalAABBBounds.y1 + dy, operateMask.globalAABBBounds.x2 + dx, operateMask.globalAABBBounds.y2 + dy);
        const { markTypeFilter = [] } = this._spec;
        this._linkedItemMap[s2.id].forEach((mark) => {
          if (markTypeFilter.includes(mark.type)) return;
          const grammarMark = mark.getProduct();
          if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
          grammarMark.elements.forEach((el) => {
            var _a3, _b2, _c;
            const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
            (null === (_a3 = this._linkedOutOfBrushElementsMap) || void 0 === _a3 ? void 0 : _a3[elementKey]) && this._isBrushContainItem(operateMask.globalAABBBounds, pointsCoord, graphicItem) ? (el.addState("inBrush"), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._linkedOutOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b2 = this._linkedInBrushElementsMap) || void 0 === _b2 ? void 0 : _b2[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask.globalAABBBounds, pointsCoord, graphicItem) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._linkedOutOfBrushElementsMap[elementKey] = el), graphicItem.setAttribute("pickable", !this._needDisablePickable);
          });
        });
      }
    });
  }
  _isBrushContainItem(brushMaskAABBBounds, brushMaskPointsCoord, item) {
    let itemBounds = [];
    if (["symbol", "rect"].includes(item.type)) {
      const { x1, x2, y1, y2 } = null == item ? void 0 : item.globalAABBBounds;
      return itemBounds = [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y1
      }, {
        x: x2,
        y: y2
      }, {
        x: x1,
        y: y2
      }], polygonIntersectPolygon(brushMaskPointsCoord, itemBounds);
    }
    return brushMaskAABBBounds.intersects(item.globalAABBBounds);
  }
  _initMarkBrushState(componentIndex, stateName) {
    this._brushComponents.forEach((brush2, index) => {
      index !== componentIndex && brush2.children[0].removeAllChild();
    }), this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {};
    const { markTypeFilter = [] } = this._spec;
    Object.entries(this._itemMap).forEach(([regionId, marks]) => {
      marks.forEach((mark) => {
        if (markTypeFilter.includes(mark.type)) return;
        const grammarMark = mark.getProduct();
        if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
        grammarMark.elements.forEach((el) => {
          const elementKey = mark.id + "_" + el.key;
          el.removeState("inBrush"), el.removeState("outOfBrush"), el.addState(stateName), this._outOfBrushElementsMap[elementKey] = el;
        });
      });
    }), Object.entries(this._linkedItemMap).forEach(([seriesId, marks]) => {
      marks.forEach((mark) => {
        if (markTypeFilter.includes(mark.type)) return;
        const grammarMark = mark.getProduct();
        if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
        grammarMark.elements.forEach((el) => {
          const elementKey = mark.id + "_" + el.key;
          el.removeState("inBrush"), el.removeState("outOfBrush"), el.addState(stateName), this._linkedOutOfBrushElementsMap[elementKey] = el;
        });
      });
    });
  }
  _stateClamp(state) {
    return Math.min(Math.max(0, state), 1);
  }
  _setAxisAndDataZoom(operateMask, region) {
    var _a;
    if (this._zoomRecord = [], this._spec.zoomAfterBrush) {
      const operateMaskBounds = operateMask.AABBBounds;
      null === (_a = this._regionAxisMap["region_" + region.id]) || void 0 === _a || _a.forEach((axis2) => {
        var _a2, _b;
        const isHorizontal4 = "bottom" === axis2.layoutOrient || "top" === axis2.layoutOrient, axisRangeExpand = null !== (_a2 = this._spec.axisRangeExpand) && void 0 !== _a2 ? _a2 : 0, { x1, x2, y1, y2 } = operateMaskBounds, regionStartAttr = isHorizontal4 ? "x" : "y", boundsStart = isHorizontal4 ? x1 : y1, boundsEnd = isHorizontal4 ? x2 : y2;
        if (this._axisDataZoomMap[axis2.id]) {
          const dataZoom2 = this._axisDataZoomMap[axis2.id], releatedAxis = dataZoom2.relatedAxisComponent, startValue = releatedAxis.getScale().invert(boundsStart - region.getLayoutStartPoint()[regionStartAttr]), endValue = releatedAxis.getScale().invert(boundsEnd - region.getLayoutStartPoint()[regionStartAttr]), startPercent = dataZoom2.dataToStatePoint(startValue), endPercent = dataZoom2.dataToStatePoint(endValue), newStartPercent = this._stateClamp(startPercent - axisRangeExpand), newEndPercent = this._stateClamp(endPercent + axisRangeExpand);
          dataZoom2.setStartAndEnd(Math.min(newStartPercent, newEndPercent), Math.max(newStartPercent, newEndPercent), ["percent", "percent"]), this._zoomRecord.push({
            operateComponent: dataZoom2,
            start: newStartPercent,
            end: newEndPercent,
            startValue: dataZoom2.statePointToData(newStartPercent),
            endValue: dataZoom2.statePointToData(newEndPercent)
          });
        } else {
          const range2 = axis2.getScale().range(), rangeFactor = null !== (_b = axis2.getScale().rangeFactor()) && void 0 !== _b ? _b : [0, 1], isAxisReverse = last(range2) < range2[0], startPosTemp = boundsStart - region.getLayoutStartPoint()[regionStartAttr], endPosTemp = boundsEnd - region.getLayoutStartPoint()[regionStartAttr], endPos = isAxisReverse ? Math.min(startPosTemp, endPosTemp) : Math.max(startPosTemp, endPosTemp), startPos = isAxisReverse ? Math.max(startPosTemp, endPosTemp) : Math.min(startPosTemp, endPosTemp), start = (startPos - range2[0]) / (last(range2) - range2[0]) * (rangeFactor[1] - rangeFactor[0]) + rangeFactor[0], end = (endPos - range2[0]) / (last(range2) - range2[0]) * (rangeFactor[1] - rangeFactor[0]) + rangeFactor[0], newStart = this._stateClamp(start - axisRangeExpand), newEnd = this._stateClamp(end + axisRangeExpand);
          axis2.getScale().rangeFactor([newStart, newEnd]), axis2.effect.scaleUpdate(), this._zoomRecord.push({
            operateComponent: axis2,
            start: newStart,
            end: newEnd,
            startValue: axis2.getScale().invert(startPos),
            endValue: axis2.getScale().invert(endPos)
          });
        }
      });
    }
  }
  _getNeedClearVRenderComponents() {
    return this._brushComponents;
  }
  clearGraphic() {
    this._brushComponents && this._brushComponents.forEach((brush2) => {
      brush2._container.incrementalClearChild();
    });
  }
  clear() {
    if (this._brushComponents) {
      const container2 = this.getContainer();
      this._brushComponents.forEach((brush2, index) => {
        this._initMarkBrushState(index, ""), this._needDisablePickable = false, brush2.removeAllChild(), brush2.releaseBrushEvents(), container2 && container2.removeChild(brush2);
      }), this._brushComponents = null;
    }
  }
};
Brush2.type = ComponentTypeEnum.brush, Brush2.specKey = "brush";
var registerBrush = () => {
  Factory2.registerComponent(Brush2.type, Brush2);
};

// node_modules/@visactor/vchart/esm/component/custom-mark/custom-mark.js
var CustomMark = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.customMark, this.specKey = "customMark", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.CustomMark, this.layoutLevel = LayoutLevel.CustomMark;
  }
  created() {
    super.created(), this.initMarks(), this.initEvent();
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  _buildMarkAttributeContext() {
    this._markAttributeContext = {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      }
    };
  }
  initMarks() {
    if (!this._spec) return;
    const series2 = this._option && this._option.getAllSeries(), hasAnimation = false !== this._option.animation, depend = [];
    series2 && series2.length && series2.forEach((s2) => {
      const marks = s2 && s2.getMarksWithoutRoot();
      marks && marks.length && marks.forEach((mark) => {
        depend.push(mark);
      });
    });
    let parentMark = null;
    if (this._spec.parent) {
      const mark = this.getChart().getAllMarks().find((m4) => m4.getUserId() === this._spec.parent);
      "group" === mark.type && (parentMark = mark);
    }
    this._createExtensionMark(this._spec, parentMark, `${PREFIX}_series_${this.id}_extensionMark`, 0, {
      depend,
      hasAnimation
    });
  }
  _createExtensionMark(spec, parentMark, namePrefix, index = 0, options) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: isValid_default(spec.name) ? `${spec.name}` : `${namePrefix}_${index}`
    }, {
      skipBeforeLayouted: true,
      attributeContext: this._getMarkAttributeContext(),
      componentType: spec.componentType,
      key: spec.dataKey
    });
    if (mark) {
      if (isValid_default(spec.id) && mark.setUserId(spec.id), options.hasAnimation && spec.animation) {
        const config2 = animationConfig({}, userAnimationConfig(spec.type, spec, this._markAttributeContext));
        mark.setAnimationConfig(config2);
      }
      if (options.depend && options.depend.length && mark.setDepend(...options.depend), isNil_default(parentMark) ? this._marks.addMark(mark) : parentMark && parentMark.addMark(mark), this.initMarkStyleWithSpec(mark, spec), "group" === spec.type && (namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s2, i) => {
        this._createExtensionMark(s2, mark, namePrefix, i, options);
      })), isValid_default(spec.dataId) || isValidNumber_default(spec.dataIndex)) {
        const dataview = this.getChart().getSeriesData(spec.dataId, spec.dataIndex);
        dataview && (dataview.target.addListener("change", () => {
          mark.getData().updateData();
        }), mark.setDataView(dataview));
      }
    }
  }
  initEvent() {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  onRender(ctx) {
  }
  _getMarkAttributeContext() {
    return {
      vchart: this._option.globalInstance,
      chart: this.getChart(),
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      },
      getLayoutBounds: () => {
        const { x, y } = this.getLayoutStartPoint(), { width, height } = this.getLayoutRect();
        return new Bounds().set(x, y, x + width, y + height);
      }
    };
  }
  _getLayoutRect() {
    const bounds = new Bounds();
    return this.getMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && bounds.union(product.getBounds());
    }), bounds.empty() ? {
      width: 0,
      height: 0
    } : {
      width: bounds.width(),
      height: bounds.height()
    };
  }
  getBoundsInRect(rect) {
    this.setLayoutRect(rect);
    const result2 = this._getLayoutRect(), { x, y } = this.getLayoutStartPoint();
    return {
      x1: x,
      y1: y,
      x2: x + result2.width,
      y2: y + result2.height
    };
  }
  getVRenderComponents() {
    const comps = [], checkFunc = (m4) => {
      var _a;
      if (m4 && "group" === m4.type) m4.getMarks().forEach((child) => {
        checkFunc(child);
      });
      else if ("component" === m4.type) {
        const comp = null === (_a = null == m4 ? void 0 : m4.getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
        comp && comps.push(comp);
      }
    };
    return this.getMarks().forEach((m4) => {
      checkFunc(m4);
    }), comps;
  }
};
CustomMark.type = ComponentTypeEnum.customMark, CustomMark.specKey = "customMark";
var registerCustomMark = () => {
  Factory2.registerComponent(CustomMark.type, CustomMark);
};

// node_modules/@visactor/vchart/esm/component/map-label/layout.js
function overlap(a3, b, sep = 0) {
  return sep > Math.max(b.x1 - a3.x2, a3.x1 - b.x2, b.y1 - a3.y2, a3.y1 - b.y2);
}
function bound(rect) {
  return {
    x1: rect.x,
    x2: rect.x + rect.width,
    y1: rect.y,
    y2: rect.y + rect.height
  };
}
function toRect(bound2) {
  return {
    x: bound2.x1,
    y: bound2.y1,
    width: bound2.x2 - bound2.x1,
    height: bound2.y2 - bound2.y1
  };
}
function layoutByPosition(pairs) {
  var _a;
  if (!pairs || 0 === pairs.length) return [];
  if (1 === pairs.length) return [pairs[0].rect];
  const _pairs = pairs.map((pair) => {
    var _a2;
    return Object.assign(Object.assign({}, pair), {
      bound: bound(pair.rect),
      anchorCandidates: candidatesByOrient(null !== (_a2 = pair.anchors) && void 0 !== _a2 ? _a2 : [], pair.point, pair.rect, pair.offset)
    });
  }), resultBound = [];
  resultBound.push(_pairs[0].bound);
  for (let i = 1; i <= _pairs.length - 1; i++) {
    const curPair = _pairs[i], curBound = curPair.bound;
    let isOverlap2 = resultBound.some((r) => overlap(r, curBound));
    if (curPair.anchorCandidates) if (isOverlap2 && (null === (_a = curPair.anchorCandidates) || void 0 === _a ? void 0 : _a.length) > 0) {
      for (let j = 0; j < curPair.anchorCandidates.length; j++) {
        const anchor = curPair.anchorCandidates[j], newBound = {
          x1: anchor.x,
          y1: anchor.y,
          x2: anchor.x + curBound.x2 - curBound.x1,
          y2: anchor.y + curBound.y2 - curBound.y1,
          anchor
        };
        if (!resultBound.some((r) => overlap(r, newBound))) {
          resultBound.push(newBound), isOverlap2 = false;
          break;
        }
      }
      isOverlap2 && resultBound.push(curPair.bound);
    } else resultBound.push(curPair.bound);
  }
  return resultBound.map((bound2) => toRect(bound2));
}
function layoutOuter(pairs, features, dataToPosition) {
  const _points = pairs.map((rect) => rect.pointCoord), { x1, x2, y1, y2 } = getAABBFromPoints(_points), centerPosition = dataToPosition([(x1 + x2) / 2, (y1 + y2) / 2]);
  if (!centerPosition) return [];
  return layoutByPosition(pairs.map((pair) => {
    const rect = pair.rect, targetPoint = isPointWithinFeatures(features, pair.pointCoord) ? dataToPosition(nearestPoint(features, [pair.pointCoord.x, pair.pointCoord.y], uniformDegree(lineDegree(pair.point, centerPosition)))) : pair.point;
    targetPoint && (rect.x = targetPoint.x, rect.y = targetPoint.y);
    const degree = uniformDegree(lineDegree(pair.point, centerPosition));
    let position;
    const anchors = [];
    return degree >= -45 && degree < 45 ? (position = "top", anchors.push("left", "right")) : degree >= 45 && degree < 135 ? position = "right" : degree >= -135 && degree < -45 ? (position = "left", anchors.push("left")) : (position = "bottom", anchors.push("left", "right")), pair.anchors = anchors, pair.offset = 20, pair.rect = placeRectByOrient(pair.rect, position, 0), pair;
  }));
}
function uniformDegree(degree) {
  return degree > 180 ? degree - 360 : degree;
}
function lineDegree(start, end) {
  return 180 * Math.atan2(start.y - end.y, start.x - end.x) / Math.PI + 90;
}
function nearestPoint(features, origin, bearing, distance2 = 200) {
  const count = 5621 / distance2;
  let curOrigin = origin;
  for (let i = 1; i <= count; i++) {
    const dest = destination(curOrigin, distance2, bearing);
    if (!isPointWithinFeatures(features, dest)) return [dest.x, dest.y];
    curOrigin = [dest.x, dest.y];
  }
  return origin;
}
function isPointWithinFeatures(features, p) {
  for (let i = 0; i < features.length; i++) {
    if (isPointInPolygon(p, features[i])) return true;
  }
  return false;
}
function placeRectByOrient(rect, position, offset = 0) {
  const result2 = Object.assign({}, rect);
  return "top" === position ? (result2.x -= rect.width / 2, result2.y -= offset + rect.height / 2) : "bottom" === position ? (result2.x -= rect.width / 2, result2.y += offset - rect.height / 2) : "left" === position ? (result2.x -= offset + rect.width, result2.y -= rect.height / 2) : "right" === position && (result2.x += offset, result2.y -= rect.height / 2), result2;
}
function candidatesByOrient(positions, anchor, rect, offset = 0) {
  const candidates = [];
  return positions.forEach((p) => {
    const { x, y } = placeRectByOrient(Object.assign(Object.assign({}, anchor), {
      width: rect.width,
      height: rect.height
    }), p, offset);
    candidates.push({
      x,
      y
    });
  }), candidates;
}

// node_modules/@visactor/vchart/esm/component/map-label/component.js
var MapLabelComponent = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.mapLabel, this.name = ComponentTypeEnum.mapLabel, this.specKey = "mapLabel", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.MarkPoint, this._activeDatum = [];
  }
  static getSpecInfo(chartSpec) {
    return getSpecInfo(chartSpec, this.specKey, this.type, (s2) => s2.visible && isValid_default(s2.seriesId));
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d;
    this.nameField = null !== (_a = this._spec.nameField) && void 0 !== _a ? _a : null === (_b = this._series) || void 0 === _b ? void 0 : _b.getDimensionField()[0], this.valueField = null !== (_c = this._spec.valueField) && void 0 !== _c ? _c : null === (_d = this._series) || void 0 === _d ? void 0 : _d.getMeasureField()[0];
  }
  created() {
    super.created(), false != !!this._spec.visible && (this.initRelatedInfo(), this.initData(), this.initEvent());
  }
  initRelatedInfo() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this._series = this._option.getSeriesInUserIdOrIndex([this._spec.seriesId])[0], "outer" === this._spec.position && (this._map = null === (_b = null === (_a = this._regions[0].getSeriesInType("map")[0]) || void 0 === _a ? void 0 : _a.getMapViewData()) || void 0 === _b ? void 0 : _b.latestData, this._longitudeField = null === (_e = null === (_d = (_c = this._regions[0]).getSpec) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.longitudeField, this._latitudeField = null === (_h = null === (_g = (_f = this._regions[0]).getSpec) || void 0 === _g ? void 0 : _g.call(_f)) || void 0 === _h ? void 0 : _h.latitudeField);
  }
  initData() {
    const series2 = this._series;
    if (!series2) return;
    const seriesData = series2.getViewData();
    if (seriesData) {
      const data = new DataView(this._option.dataSet, {
        name: `${this.name}_data`
      });
      data.parse([seriesData], {
        type: "dataview"
      }), data.transform({
        type: "copyDataView",
        level: TransformLevel.copyDataView
      }, false), this._data = new CompilableData(this._option, data), data.target.addListener("change", () => {
        "hover" !== this._spec.trigger && "click" !== this._spec.trigger && (this._activeDatum = this._data.getLatestData());
      });
    }
  }
  initEvent() {
    var _a;
    this.event.on("zoom", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e) => (this.handleZoom(e), true)), this.event.on("panmove", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e) => (this.handlePan(e), true));
    const trigger = this._spec.trigger;
    if ("none" === trigger) return;
    const view = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
    view && ("hover" === trigger ? (view.addEventListener("element-highlight:start", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-highlight:reset", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(null);
    })) : "click" === trigger && (view.addEventListener("element-select:start", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("elementSelectReset", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum([]);
    })));
  }
  handlePan(e) {
    const { delta } = e;
    this._markerComponents.forEach((marker) => {
      marker.translate(delta[0], delta[1]);
    });
  }
  handleZoom(e) {
    this._updateMarkerLayoutAttribute();
  }
  _updateDatum(datum) {
    this._activeDatum = datum, this._markerComponents.forEach((marker, index) => {
      var _a;
      const markerDatum = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData()[index];
      this._activeDatum.includes(markerDatum) ? marker.setAttribute("visible", true) : marker.setAttribute("visible", false);
    });
  }
  dataToPosition(datum) {
    return this._series.dataToPosition(datum);
  }
  updateLayoutAttribute() {
    var _a;
    const markData = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData();
    markData && 0 !== markData.length && (super.updateLayoutAttribute(), this._updateMarkerLayoutAttribute());
  }
  _updateMarkerLayoutAttribute() {
    var _a;
    const layoutPairInfo = [], markerMarks = [];
    this._markerComponents || (this._markerComponents = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData().map((data, index) => {
      var _a2;
      const cmp = new MarkPoint({
        position: void 0,
        animation: false
      });
      return cmp && (cmp.name = `${this.name}_marker_${index}`, cmp.id = null !== (_a2 = this._spec.id) && void 0 !== _a2 ? _a2 : `${this.name}_marker_${this.id}`, cmp.setAttribute("zIndex", this.layoutZIndex)), cmp;
    }));
    this._markerComponents.forEach((marker, index) => {
      marker.removeAllChild();
      const { pairInfo, contentMarks } = this._evaluateMarker(this._data.getLatestData()[index], index);
      pairInfo && layoutPairInfo.push(pairInfo), contentMarks && markerMarks.push(contentMarks);
    });
    const positionedRects = this._layoutLabels(layoutPairInfo);
    this._layoutMarkers(positionedRects, markerMarks), this._renderMarkers();
  }
  _evaluateMarker(data, index) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let contentItemCount = 0, paddingWidth = 0, paddingHeight = 0, contentWidth = 0, contentHeight = 0;
    const position = this._spec.position || "top", offset = this._spec.offset, padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0;
    paddingWidth += ((null == padding ? void 0 : padding.left) || 0) + ((null == padding ? void 0 : padding.right) || 0), paddingHeight += ((null == padding ? void 0 : padding.top) || 0) + ((null == padding ? void 0 : padding.bottom) || 0);
    const contentMarks = {}, positionAttr = this.dataToPosition(data), container2 = createGroup({});
    if (container2.name = `${this.name}_marker_itemContainer_${index}`, contentMarks.container = container2, null === (_b = this._spec.background) || void 0 === _b ? void 0 : _b.visible) {
      const labelBackground = createRect(transformToGraphic(Object.assign({}, this._spec.background.style)));
      labelBackground.setAttributes(positionAttr), contentMarks.labelBackground = labelBackground, container2.appendChild(labelBackground);
    }
    if (null === (_c = this._spec.icon) || void 0 === _c ? void 0 : _c.visible) {
      const icon = createSymbol(transformToGraphic(Object.assign({}, this._spec.icon.style)));
      icon.setAttributes(positionAttr), icon.setAttribute("symbolType", null === (_d = this._spec.icon.style) || void 0 === _d ? void 0 : _d.shape);
      const iconBound = icon.AABBBounds, iconHeight = null !== (_e = (null == iconBound ? void 0 : iconBound.y2) - (null == iconBound ? void 0 : iconBound.y1)) && void 0 !== _e ? _e : 0, iconWidth = null !== (_f = (null == iconBound ? void 0 : iconBound.x2) - (null == iconBound ? void 0 : iconBound.x1)) && void 0 !== _f ? _f : 0;
      contentMarks.icon = icon, container2.appendChild(icon), contentHeight = iconHeight, contentWidth += iconWidth, contentItemCount++;
    }
    if (null === (_g = this._spec.nameLabel) || void 0 === _g ? void 0 : _g.visible) {
      const nameLabel = createText(transformToGraphic(Object.assign({}, this._spec.nameLabel.style)));
      nameLabel.setAttributes(positionAttr), nameLabel.setAttribute("text", data[this.nameField]);
      const nameLabelBound = nameLabel.AABBBounds, nameLabelHeight = null !== (_h = (null == nameLabelBound ? void 0 : nameLabelBound.y2) - (null == nameLabelBound ? void 0 : nameLabelBound.y1)) && void 0 !== _h ? _h : 0, nameLabelWidth = null !== (_j = (null == nameLabelBound ? void 0 : nameLabelBound.x2) - (null == nameLabelBound ? void 0 : nameLabelBound.x1)) && void 0 !== _j ? _j : 0;
      contentMarks.nameLabel = nameLabel, container2.appendChild(nameLabel), contentHeight = Math.max(contentHeight, nameLabelHeight), contentWidth += nameLabelWidth, contentItemCount++;
    }
    if ((null === (_k = this._spec.valueLabel) || void 0 === _k ? void 0 : _k.visible) && isValid_default(data[this.valueField])) {
      const valueLabel = createText(transformToGraphic(Object.assign({}, this._spec.valueLabel.style)));
      valueLabel.setAttributes(positionAttr), valueLabel.setAttribute("text", data[this.valueField]);
      const valueLabelBound = valueLabel.AABBBounds, valueLabelHeight = null !== (_l = (null == valueLabelBound ? void 0 : valueLabelBound.y2) - (null == valueLabelBound ? void 0 : valueLabelBound.y1)) && void 0 !== _l ? _l : 0, valueLabelWidth = null !== (_m = (null == valueLabelBound ? void 0 : valueLabelBound.x2) - (null == valueLabelBound ? void 0 : valueLabelBound.x1)) && void 0 !== _m ? _m : 0;
      contentMarks.valueLabel = valueLabel, container2.appendChild(valueLabel), contentHeight = Math.max(contentHeight, valueLabelHeight), contentWidth += valueLabelWidth, contentItemCount++;
    }
    const firstValidMark = Object.values(contentMarks).find((m4) => !!m4 && "group" !== m4.type), anchor = {
      x: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("x"),
      y: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("y")
    }, itemRect = {
      x: anchor.x,
      y: anchor.y,
      width: 0,
      height: 0
    };
    itemRect.width = paddingWidth + contentWidth + (contentItemCount - 1) * space, itemRect.height = paddingHeight + contentHeight;
    const pairInfo = {
      rect: itemRect,
      point: anchor,
      index
    };
    if ("outer" !== position) {
      const anchors = ["top", "right", "left", "bottom"].filter((a3) => a3 !== position);
      pairInfo.rect = placeRectByOrient(itemRect, position, offset), pairInfo.anchors = anchors, pairInfo.offset = offset;
    } else pairInfo.pointCoord = {
      x: +(null == data ? void 0 : data[this._longitudeField]),
      y: +(null == data ? void 0 : data[this._latitudeField])
    };
    return {
      pairInfo,
      contentMarks
    };
  }
  _layoutMarkers(positionedRects, contentMarks) {
    var _a, _b, _c;
    for (let i = 0; i < contentMarks.length; i++) {
      if (!positionedRects[i] || !contentMarks[i]) return;
      const { icon, nameLabel, valueLabel, labelBackground, container: container2 } = contentMarks[i], itemRect = positionedRects[i], padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0, curY = itemRect.height / 2;
      let curX = (null == padding ? void 0 : padding.left) || 0;
      [icon, nameLabel, valueLabel].forEach((item, index) => {
        var _a2, _b2;
        if (item) {
          const bounds = item.AABBBounds;
          let offset = 0;
          "symbol" === item.type && (offset += (null !== (_a2 = bounds.x2 - bounds.x1) && void 0 !== _a2 ? _a2 : 0) / 2), item.setAttributes({
            x: curX + offset,
            y: curY
          }), curX += null !== (_b2 = bounds.x2 - bounds.x1) && void 0 !== _b2 ? _b2 : 0, 2 !== index && (curX += space);
        }
      }), null == labelBackground || labelBackground.setAttributes({
        x: 0,
        y: 0,
        width: itemRect.width,
        height: itemRect.height
      }), null == container2 || container2.setAttributes({
        dx: -itemRect.width / 2,
        dy: -itemRect.height / 2
      });
      const datum = this._data.getLatestData()[i], anchor = this.dataToPosition(datum), regionPos = this.getRegions()[0].getLayoutStartPoint(), showLeader = !(!(null === (_b = this._spec.leader) || void 0 === _b ? void 0 : _b.visible) || !(icon || nameLabel || valueLabel));
      this._markerComponents[i].setAttributes({
        x: regionPos.x,
        y: regionPos.y,
        position: anchor,
        visible: this._activeDatum.includes(datum),
        itemContent: {
          refX: 0,
          type: "custom",
          renderCustomCallback: () => container2,
          autoRotate: false,
          offsetX: itemRect.x + itemRect.width / 2 - anchor.x,
          offsetY: itemRect.y + itemRect.height / 2 - anchor.y
        },
        itemLine: {
          visible: showLeader,
          type: "type-po",
          lineStyle: transformToGraphic(Object.assign({}, null === (_c = this._spec.leader) || void 0 === _c ? void 0 : _c.style)),
          startSymbol: {
            visible: false
          }
        }
      });
    }
  }
  _renderMarkers() {
    if (this._markerComponents && this._markerComponents.length) for (let i = 0; i < this._markerComponents.length; i++) this.getContainer().add(this._markerComponents[i]);
  }
  _layoutLabels(rects) {
    return "outer" === this._spec.position && this._map ? layoutOuter(rects, this._map, (coord) => this._series.dataToPosition({
      [this._longitudeField]: coord[0],
      [this._latitudeField]: coord[1]
    })) : layoutByPosition(rects);
  }
  _isRelativeModel(model) {
    var _a, _b, _c;
    const id = null !== (_b = null === (_a = this._series.getXAxisHelper()) || void 0 === _a ? void 0 : _a.getAxisId()) && void 0 !== _b ? _b : null === (_c = this._series.getCoordinateHelper()) || void 0 === _c ? void 0 : _c.getCoordinateId();
    return (null == model ? void 0 : model.id) === id;
  }
  _isRelativeSeries(model) {
    return (null == model ? void 0 : model.id) === this._series.id;
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _getNeedClearVRenderComponents() {
    return this._markerComponents;
  }
};
MapLabelComponent.type = ComponentTypeEnum.mapLabel, MapLabelComponent.specKey = "mapLabel";
var registerMapLabel = () => {
  Factory2.registerComponent(MapLabelComponent.type, MapLabelComponent);
};

// node_modules/@visactor/vchart/esm/layout/grid-layout/grid-layout.js
var GridLayout2 = class {
  constructor(gridInfo, ctx) {
    this._chartLayoutRect = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    }, this._col = 1, this._row = 1, this._elementMap = /* @__PURE__ */ new Map(), this.standardizationSpec(gridInfo), this._gridInfo = gridInfo, this._col = gridInfo.col, this._row = gridInfo.row, this._colSize = new Array(this._col).fill(null), this._rowSize = new Array(this._row).fill(null), this._colElements = new Array(this._col).fill([]), this._rowElements = new Array(this._row).fill([]), this._onError = null == ctx ? void 0 : ctx.onError, this.initUserSetting();
  }
  standardizationSpec(gridInfo) {
    var _a, _b, _c;
    gridInfo.col = null !== (_a = gridInfo.col) && void 0 !== _a ? _a : 1, gridInfo.row = null !== (_b = gridInfo.row) && void 0 !== _b ? _b : 1, gridInfo.elements = null !== (_c = gridInfo.elements) && void 0 !== _c ? _c : [];
  }
  initUserSetting() {
    this._gridInfo.colWidth && this.setSizeFromUserSetting(this._gridInfo.colWidth, this._colSize, this._col, this._chartLayoutRect.width), this._gridInfo.rowHeight && this.setSizeFromUserSetting(this._gridInfo.rowHeight, this._rowSize, this._row, this._chartLayoutRect.height), this._colSize.forEach((c3, i) => {
      c3 || (this._colSize[i] = {
        value: 0,
        isUserSetting: false,
        isLayoutSetting: false
      });
    }), this._rowSize.forEach((r, i) => {
      r || (this._rowSize[i] = {
        value: 0,
        isUserSetting: false,
        isLayoutSetting: false
      });
    });
  }
  setSizeFromUserSetting(userSetting, gridSize, gridMax, maxSize) {
    userSetting.forEach((userSet) => {
      userSet.index < 0 && userSet.index >= gridMax || (isValidNumber_default(userSet.size) ? gridSize[userSet.index] = {
        value: +userSet.size,
        isUserSetting: true,
        isLayoutSetting: false
      } : isFunction_default(userSet.size) && (gridSize[userSet.index] = {
        value: userSet.size(maxSize),
        isUserSetting: true,
        isLayoutSetting: false
      }));
    });
  }
  clearLayoutSize() {
    this._colSize.forEach((c3) => {
      c3.isLayoutSetting = false, c3.isUserSetting || (c3.value = 0);
    }), this._rowSize.forEach((r) => {
      r.isLayoutSetting = false, r.isUserSetting || (r.value = 0);
    });
  }
  getItemGridInfo(item) {
    var _a;
    const mapResult = this._elementMap.get(item);
    if (mapResult) return mapResult;
    let result2;
    return result2 = null === (_a = this._gridInfo.elements) || void 0 === _a ? void 0 : _a.find((e) => {
      var _a2;
      if ("modelId" in e && isValid_default(e.modelId)) {
        if (isValid_default(item.model.userId) && item.model.userId === e.modelId) return true;
      } else if ("modelKey" in e && isValid_default(e.modelKey) && "modelIndex" in e && isValid_default(e.modelIndex)) {
        if ((null !== (_a2 = item.model.specKey) && void 0 !== _a2 ? _a2 : item.model.type) === e.modelKey && item.model.getSpecIndex() === e.modelIndex) return true;
      }
      return false;
    }), result2 || (result2 = {
      col: 0,
      colSpan: 1,
      row: 0,
      rowSpan: 1
    }), this._elementMap.set(item, result2), result2;
  }
  getSizeFromGrid(spec, type) {
    var _a;
    const sizeList = "col" === type ? this._colSize : this._rowSize;
    let result2 = 0;
    for (let index = spec[type]; index < spec[type] + (null !== (_a = spec[`${type}Span`]) && void 0 !== _a ? _a : 1); index++) result2 += sizeList[index].value;
    return result2;
  }
  getSizeFromUser(spec, type) {
    var _a, _b;
    const sizeList = "col" === type ? this._colSize : this._rowSize;
    if (!(null === (_a = sizeList[spec[type]]) || void 0 === _a ? void 0 : _a.isUserSetting)) return;
    let result2 = 0;
    for (let index = spec[type]; index < spec[type] + (null !== (_b = spec[`${type}Span`]) && void 0 !== _b ? _b : 1); index++) {
      if (!sizeList[index].isUserSetting) return;
      result2 += sizeList[index].value;
    }
    return result2;
  }
  setItemLayoutSizeToGrid(item, gridSpec) {
    if (isColItem(item)) {
      if (gridSpec.colSpan && gridSpec.colSpan > 1) return;
      if (this._colSize[gridSpec.col].isUserSetting) return;
      this._colSize[gridSpec.col].value = Math.max(this._colSize[gridSpec.col].value, item.getLayoutRect().width + item.layoutPaddingLeft + item.layoutPaddingRight), this._colSize[gridSpec.col].isLayoutSetting = true;
    } else {
      if (gridSpec.rowSpan && gridSpec.rowSpan > 1) return;
      if (this._rowSize[gridSpec.row].isUserSetting) return;
      this._rowSize[gridSpec.row].value = Math.max(this._rowSize[gridSpec.row].value, item.getLayoutRect().height + item.layoutPaddingTop + item.layoutPaddingBottom), this._rowSize[gridSpec.row].isLayoutSetting = true;
    }
  }
  layoutGrid(type) {
    const gridSize = "col" === type ? this._colSize : this._rowSize;
    let unSetSize = "col" === type ? this._chartLayoutRect.width : this._chartLayoutRect.height;
    const willSize = [];
    gridSize.forEach((s2) => {
      s2.isUserSetting || s2.isLayoutSetting ? unSetSize -= s2.value : willSize.push(s2);
    }), unSetSize < 0 && console.warn(`layout content ${type} size bigger than chart`), willSize.forEach((s2) => s2.value = unSetSize / willSize.length);
  }
  getItemPosition(item) {
    const gridSpec = this.getItemGridInfo(item), point6 = {
      x: this._chartLayoutRect.x,
      y: this._chartLayoutRect.y
    };
    for (let col = 0; col < gridSpec.col; col++) point6.x += this._colSize[col].value;
    for (let row = 0; row < gridSpec.row; row++) point6.y += this._rowSize[row].value;
    return point6.x += item.layoutPaddingLeft + item.layoutOffsetX, point6.y += item.layoutPaddingTop + item.layoutOffsetY, point6;
  }
  getItemLayoutRect(item) {
    var _a, _b;
    const gridSpec = this.getItemGridInfo(item);
    return {
      width: (null !== (_a = this.getSizeFromGrid(gridSpec, "col")) && void 0 !== _a ? _a : this._chartLayoutRect.width) - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: (null !== (_b = this.getSizeFromGrid(gridSpec, "row")) && void 0 !== _b ? _b : this._chartLayoutRect.height) - item.layoutPaddingTop - item.layoutPaddingBottom
    };
  }
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._chartLayoutRect = chartLayoutRect, this._chartViewBox = chartViewBox, this.clearLayoutSize(), items.sort((a3, b) => b.layoutLevel - a3.layoutLevel);
    const normalItems = items.filter((item) => "normal" === item.layoutType && false !== item.getModelVisible()), normalItemsCol = normalItems.filter((item) => isColItem(item)), normalItemsRow = normalItems.filter((item) => !isColItem(item));
    normalItems.forEach((item) => {
      this.layoutOneItem(item, "user", false);
    });
    const regionsRelative = items.filter((x) => "region-relative" === x.layoutType), regionsRelativeCol = regionsRelative.filter((item) => isColItem(item)), regionsRelativeRow = regionsRelative.filter((item) => !isColItem(item));
    regionsRelativeCol.forEach((item) => this.layoutOneItem(item, "user", false)), this.layoutGrid("col"), normalItemsRow.forEach((item) => this.layoutOneItem(item, "colGrid", false)), regionsRelativeRow.forEach((item) => {
      this.layoutOneItem(item, "colGrid", false);
    }), this.layoutGrid("row"), regionsRelativeRow.forEach((item) => {
      this.layoutOneItem(item, "grid", false);
    }), normalItemsCol.forEach((item) => this.layoutOneItem(item, "grid", false)), regionsRelativeCol.forEach((item) => {
      this.layoutOneItem(item, "grid", true);
    }), this.layoutGrid("col"), items.filter((x) => "region" === x.layoutType).forEach((item) => this.layoutOneItem(item, "grid", false)), this.layoutAbsoluteItems(items.filter((x) => "absolute" === x.layoutType)), items.filter((x) => "absolute" !== x.layoutType).forEach((item) => {
      item.setLayoutStartPosition(this.getItemPosition(item));
    });
  }
  layoutAbsoluteItems(absoluteItems) {
    absoluteItems.forEach((item) => {
      item.absoluteLayoutInRect(this._chartLayoutRect);
    });
  }
  layoutOneItem(item, sizeType, ignoreTag) {
    var _a, _b;
    const sizeCallRow = "rowGrid" === sizeType || "grid" === sizeType ? this.getSizeFromGrid.bind(this) : this.getSizeFromUser.bind(this), sizeCallCol = "colGrid" === sizeType || "grid" === sizeType ? this.getSizeFromGrid.bind(this) : this.getSizeFromUser.bind(this), gridSpec = this.getItemGridInfo(item), computeRect = {
      width: (null !== (_a = sizeCallCol(gridSpec, "col")) && void 0 !== _a ? _a : this._chartLayoutRect.width) - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: (null !== (_b = sizeCallRow(gridSpec, "row")) && void 0 !== _b ? _b : this._chartLayoutRect.height) - item.layoutPaddingTop - item.layoutPaddingBottom
    }, rect = item.computeBoundsInRect(computeRect);
    isValidNumber_default(rect.width) || (rect.width = computeRect.width), isValidNumber_default(rect.height) || (rect.height = computeRect.height), item.setLayoutRect("grid" !== sizeType ? rect : computeRect), this.setItemLayoutSizeToGrid(item, gridSpec);
  }
};
function isColItem(item) {
  return "left" === item.layoutOrient || "right" === item.layoutOrient;
}
GridLayout2.type = "grid";
var registerGridLayout = () => {
  Factory2.registerLayout(GridLayout2.type, GridLayout2);
};

// node_modules/@visactor/vchart/esm/layout/layout3d/index.js
var Layout3d = class extends Layout {
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._layoutInit(_chart, items, chartLayoutRect, chartViewBox), this._layoutNormalItems(items);
    const layoutTemp = {
      left: this.leftCurrent,
      top: this.topCurrent,
      right: this.rightCurrent,
      bottom: this.bottomCurrent
    }, absoluteItem = items.filter((x) => "absolute" === x.layoutType), zItems = absoluteItem.filter((i) => "z" === i.layoutOrient);
    let extraWH = {
      width: 0,
      height: 0
    };
    if (zItems.length) {
      extraWH = zItems[0].getLayoutRect();
    }
    this.leftCurrent += extraWH.width / 8, this.rightCurrent -= extraWH.width / 8, this.topCurrent += extraWH.height / 8, this.bottomCurrent -= extraWH.height / 8;
    const { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
    this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems), this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp);
    const absoluteItemExceptZAxis = absoluteItem.filter((i) => "z" !== i.layoutOrient);
    this.layoutAbsoluteItems(absoluteItemExceptZAxis);
    const xAxis = relativeItems.filter((item) => "axes" === item.model.specKey && isXAxis(item.layoutOrient))[0], yAxis = relativeItems.filter((item) => "axes" === item.model.specKey && isYAxis(item.layoutOrient))[0];
    if (xAxis && zItems.length) {
      const sp = xAxis.getLayoutStartPoint(), lr = xAxis.getLayoutRect(), zRect = {
        x: "left" === yAxis.layoutOrient ? sp.x + lr.width : sp.x,
        y: sp.y,
        width: this._chartLayoutRect.width,
        height: this._chartLayoutRect.height
      };
      zItems[0].model.directionStr = "left" === yAxis.layoutOrient ? "r2l" : "l2r";
      const xRect = xAxis.getLayoutRect(), yRect = yAxis.getLayoutRect(), box3d = {
        length: zItems[0].getLayoutRect().width,
        width: xRect.width,
        height: yRect.height
      };
      xAxis.model.setLayout3dBox && xAxis.model.setLayout3dBox(box3d), yAxis.model.setLayout3dBox && yAxis.model.setLayout3dBox(box3d), zItems[0].model.setLayout3dBox && zItems[0].model.setLayout3dBox(box3d), this.layoutZAxisItems(zItems, zRect);
    }
  }
  layoutZAxisItems(zItems, zRect) {
    zItems.forEach((item) => {
      item.absoluteLayoutInRect(zRect);
    });
  }
  getItemComputeLayoutRect(item, extraOffset) {
    extraOffset || (extraOffset = {
      offsetLeft: 0,
      offsetRight: 0,
      offsetTop: 0,
      offsetBottom: 0
    });
    return {
      width: this.rightCurrent - this.leftCurrent - item.layoutPaddingLeft - item.layoutPaddingRight - (extraOffset.offsetLeft + extraOffset.offsetRight),
      height: this.bottomCurrent - this.topCurrent - item.layoutPaddingTop - item.layoutPaddingBottom - (extraOffset.offsetTop + extraOffset.offsetBottom)
    };
  }
  _checkAutoIndent(items) {
    const result2 = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    }, rightCurrent = this._chartViewBox.x2 - this._chartViewBox.x1 - this.rightCurrent, bottomCurrent = this._chartViewBox.y2 - this._chartViewBox.y1 - this.bottomCurrent;
    return items.forEach((i) => {
      if (!i.getModelVisible() || !i.autoIndent) return;
      const vOrH = "left" === i.layoutOrient || "right" === i.layoutOrient, outer = i.getLastComputeOutBounds();
      vOrH ? (result2.top = Math.max(result2.top, outer.y1 - this.topCurrent), result2.bottom = Math.max(result2.bottom, outer.y2 - bottomCurrent)) : (result2.left = Math.max(result2.left, outer.x1 - this.leftCurrent), result2.right = Math.max(result2.right, outer.x2 - rightCurrent));
    }), result2;
  }
};
Layout3d.type = "layout3d";
var registerLayout3d = () => {
  Factory2.registerLayout(Layout3d.type, Layout3d);
};

// node_modules/@visactor/vchart/esm/component/poptip/index.js
var registerPoptip = () => {
  loadPoptip();
};

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/constants.js
var TOOLTIP_PREFIX = "vchart-tooltip";
var TOOLTIP_CONTAINER_EL_CLASS_NAME = `${TOOLTIP_PREFIX}-container`;
var TOOLTIP_TITLE_CLASS_NAME = `${TOOLTIP_PREFIX}-title`;
var TOOLTIP_CONTENT_BOX_CLASS_NAME = `${TOOLTIP_PREFIX}-content-box`;
var TOOLTIP_EMPTY_STRING = "";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10
};
var DEFAULT_TOOLTIP_Z_INDEX = "99999999999999";

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/utils/common.js
function escapeHTML(value) {
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\(/g, "&#40;").replace(/  /g, " &nbsp;");
}
var getScale = (element, boundingClientRect) => element ? (boundingClientRect || (boundingClientRect = element.getBoundingClientRect()), element.offsetWidth > 0 ? boundingClientRect.width / element.offsetWidth : element.offsetHeight > 0 ? boundingClientRect.height / element.offsetHeight : 1) : 1;
var formatContent = (content) => isString_default(content) && "" !== (null == content ? void 0 : content.trim()) || isNumber_default(content) ? escapeHTML(content) : TOOLTIP_EMPTY_STRING;

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/utils/position.js
var getActualTooltipPositionValue = (position, event) => {
  let result2;
  if (isValid_default(position)) {
    if (isNumber_default(position)) result2 = position;
    else if (isFunction_default(position)) {
      const tooltipPosition = position(event);
      isNumber_default(tooltipPosition) && (result2 = tooltipPosition);
    }
  }
  return result2;
};
var positionType = {
  left: [-2, 0],
  right: [2, 0],
  top: [0, -2],
  lt: [-2, -2],
  tl: [-2, -2],
  rt: [2, -2],
  tr: [2, -2],
  bottom: [0, 2],
  bl: [-2, 2],
  lb: [-2, 2],
  br: [2, 2],
  rb: [2, 2],
  inside: [0, 0],
  center: [0, 0],
  centerBottom: [0, 1],
  centerTop: [0, -1],
  centerLeft: [-1, 0],
  centerRight: [1, 0]
};
var getPositionType = (position, dim, defaultCase = 2) => {
  var _a, _b;
  return null !== (_b = null === (_a = positionType[position]) || void 0 === _a ? void 0 : _a["x" === dim ? 0 : 1]) && void 0 !== _b ? _b : defaultCase;
};
var getCartesianCrosshairRect = (dimensionData, layoutStartPoint) => {
  var _a;
  const currValueX = /* @__PURE__ */ new Map(), currValueY = /* @__PURE__ */ new Map(), { series: series2, datum } = dimensionData, isHorizontal4 = "horizontal" === series2.direction, axisId = (isHorizontal4 ? series2.getYAxisHelper() : series2.getXAxisHelper()).getAxisId(), axis2 = series2.getChart().getComponentsByKey("axes").find((axis3) => axis3.id === axisId);
  if (!axis2) return;
  (isHorizontal4 ? currValueY : currValueX).set(axis2.getSpecIndex(), {
    datum: null === (_a = series2.getDatumPositionValues(datum[0], series2.getDimensionField())) || void 0 === _a ? void 0 : _a[0],
    axis: axis2
  });
  const state = {
    xField: {
      coordKey: "x",
      anotherAxisKey: "y",
      currentValue: currValueX,
      attributes: {
        visible: !!currValueX.size,
        type: "rect"
      }
    },
    yField: {
      coordKey: "y",
      anotherAxisKey: "x",
      currentValue: currValueY,
      attributes: {
        visible: !!currValueY.size,
        type: "rect"
      }
    }
  };
  return layoutByValue(state, series2, layoutStartPoint), state.xField.cacheInfo ? layoutCrosshair(state.xField) : state.yField.cacheInfo ? layoutCrosshair(state.yField) : void 0;
};
var isGlobalTooltipPositionPattern = (obj) => isObject_default(obj) && (isValid_default(obj.left) || isValid_default(obj.right) || isValid_default(obj.top) || isValid_default(obj.bottom));
var isFixedTooltipPositionPattern = (obj) => isObject_default(obj) && (isValid_default(obj.x) || isValid_default(obj.y));

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/base.js
var BaseTooltipHandler = class extends BasePlugin {
  constructor() {
    super(...arguments), this._visible = true, this._isReleased = false, this.showTooltip = (activeType, data, params2) => {
      const { changePositionOnly } = params2;
      return changePositionOnly ? this.changeTooltipPosition(params2, data) : this.changeTooltip(true, params2, data);
    }, this.changeTooltip = (visible, params2, data) => this._isReleased ? 1 : visible ? this.changeTooltipPosition(params2, data) : (this._updateTooltip(false, params2), 0), this.changeTooltipPosition = (params2, data) => {
      var _a, _b, _c, _d, _e;
      if (this._isReleased) return 1;
      const event = params2.event, { tooltipSpec, activeTooltipSpec, changePositionOnly } = params2;
      if (!activeTooltipSpec) return 1;
      const activeType = activeTooltipSpec.activeType;
      if (activeTooltipSpec.handler) return null !== (_c = null === (_b = (_a = activeTooltipSpec.handler).showTooltip) || void 0 === _b ? void 0 : _b.call(_a, activeType, data, params2)) && void 0 !== _c ? _c : 0;
      const pattern = activeTooltipSpec, position = this._getActualTooltipPosition(activeTooltipSpec, params2, this._getTooltipBoxSize(activeTooltipSpec, changePositionOnly));
      activeTooltipSpec.position = position;
      const updatePosition = null !== (_d = activeTooltipSpec.updatePosition) && void 0 !== _d ? _d : null === (_e = tooltipSpec[activeType]) || void 0 === _e ? void 0 : _e.updatePosition;
      updatePosition && (activeTooltipSpec.position = updatePosition(activeTooltipSpec.position, data, params2));
      let tooltipVisible = false !== (null == pattern ? void 0 : pattern.visible);
      return data && "pointerout" !== event.type && activeTooltipSpec.visible && (activeTooltipSpec.title || activeTooltipSpec.content) || (tooltipVisible = false), this._updateTooltip(tooltipVisible, Object.assign(Object.assign({}, params2), {
        changePositionOnly
      })), 0;
    }, this._getActualTooltipPosition = (actualTooltip, params2, tooltipBoxSize) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const { tooltipSpec } = params2, invalidPosition = {
        x: 1 / 0,
        y: 1 / 0
      };
      if (!tooltipSpec) return invalidPosition;
      const event = params2.event, { activeType, data } = actualTooltip, firstDim = "dimension" === activeType ? null === (_b = null === (_a = data[0]) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0] : null == data ? void 0 : data[0], { offsetX, offsetY } = this._option, spec = tooltipSpec[activeType], position = getTooltipPatternValue(null == spec ? void 0 : spec.position, data, params2), positionMode = null !== (_c = getTooltipPatternValue(null == spec ? void 0 : spec.positionMode, data, params2)) && void 0 !== _c ? _c : "mark" === activeType ? "mark" : "pointer", { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = null != tooltipBoxSize ? tooltipBoxSize : {}, isCanvas = "canvas" === tooltipSpec.renderMode, canvasRect = null === (_d = null == params2 ? void 0 : params2.chart) || void 0 === _d ? void 0 : _d.getCanvasRect(), canvasWidth = null !== (_e = null == canvasRect ? void 0 : canvasRect.width) && void 0 !== _e ? _e : DEFAULT_CHART_WIDTH, canvasHeight = null !== (_f = null == canvasRect ? void 0 : canvasRect.height) && void 0 !== _f ? _f : DEFAULT_CHART_HEIGHT;
      let isFixedPosition = false;
      const containerSize = {
        width: 0,
        height: 0
      };
      let chartElementRect, relativePosOffset = {
        x: 0,
        y: 0
      }, tooltipParentElementRect = {
        x: 0,
        y: 0
      }, chartElementScale = 1, tooltipParentElementScale = 1;
      const isBrowser2 = isTrueBrowser(this._env);
      if (isBrowser2 && !tooltipSpec.confine ? (containerSize.width = window.innerWidth, containerSize.height = window.innerHeight) : (containerSize.width = canvasWidth, containerSize.height = canvasHeight), isBrowser2 && !isCanvas) {
        const tooltipParentElement = this._getParentElement(tooltipSpec);
        tooltipParentElementRect = null !== (_h = null === (_g = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect) || void 0 === _g ? void 0 : _g.call(tooltipParentElement)) && void 0 !== _h ? _h : invalidPosition;
        const chartElement = null !== (_j = this._compiler.getCanvas()) && void 0 !== _j ? _j : this._chartContainer;
        chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect(), relativePosOffset = {
          x: chartElementRect.x - tooltipParentElementRect.x,
          y: chartElementRect.y - tooltipParentElementRect.y
        }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
      }
      const tooltipSizeScale = tooltipParentElementScale / chartElementScale, calcPos = {}, pointerFixedPosition = {
        x: position,
        y: position
      }, dimToPos = {
        x: ["left", "right"],
        y: ["top", "bottom"]
      }, processCartesianFixedPosition = ({ orient, mode, offset }, dim) => {
        var _a2;
        let dim1, dim2;
        const model = params2.model, startPoint = null == model ? void 0 : model.getLayoutStartPoint(), dimOffset = null != offset ? offset : "x" === dim ? offsetX : offsetY;
        if ("mark" === mode) {
          isFixedPosition = true;
          const element = params2.item, bounds = null == element ? void 0 : element.getBounds();
          bounds && startPoint && (dim1 = ("x" === dim ? bounds.x1 : bounds.y1) + startPoint[dim], dim2 = ("x" === dim ? bounds.x2 : bounds.y2) + startPoint[dim]);
        } else if ("crosshair" === mode && "cartesian" === (null === (_a2 = null == firstDim ? void 0 : firstDim.series) || void 0 === _a2 ? void 0 : _a2.coordinate) && firstDim.datum && firstDim.datum.length) {
          isFixedPosition = true;
          const rect = getCartesianCrosshairRect(firstDim, startPoint);
          rect && (dim1 = rect.start[dim], dim2 = rect.end[dim]);
        } else pointerFixedPosition[dim] = orient;
        if (isFixedPosition) {
          const posKey = dimToPos[dim][0], boxSize = "x" === dim ? tooltipBoxWidth : tooltipBoxHeight;
          switch (getPositionType(orient, dim)) {
            case -2:
              calcPos[posKey] = dim1 - boxSize * tooltipSizeScale - dimOffset;
              break;
            case 0:
              calcPos[posKey] = (dim1 + dim2) / 2 - boxSize * tooltipSizeScale / 2;
              break;
            case -1:
              calcPos[posKey] = (dim1 + dim2) / 2 - boxSize * tooltipSizeScale - dimOffset;
              break;
            case 1:
              calcPos[posKey] = (dim1 + dim2) / 2 + dimOffset;
              break;
            case 2:
              calcPos[posKey] = dim2 + dimOffset;
          }
        }
      }, dims = ["x", "y"];
      if (isObject_default(position)) if (isGlobalTooltipPositionPattern(position)) {
        const { left: posLeft, right: posRight, top: posTop, bottom: posBottom } = position;
        calcPos.left = getActualTooltipPositionValue(posLeft, event), calcPos.top = getActualTooltipPositionValue(posTop, event), calcPos.right = getActualTooltipPositionValue(posRight, event), calcPos.bottom = getActualTooltipPositionValue(posBottom, event);
      } else isFixedTooltipPositionPattern(position) && dims.forEach((dim) => {
        const dimValue = position[dim];
        isNumber_default(dimValue) || isFunction_default(dimValue) ? calcPos[dimToPos[dim][0]] = getActualTooltipPositionValue(dimValue, event) : processCartesianFixedPosition(dimValue, dim);
      });
      else isValid_default(position) && (processCartesianFixedPosition({
        orient: position,
        mode: positionMode
      }, "x"), processCartesianFixedPosition({
        orient: position,
        mode: positionMode
      }, "y"));
      const result2 = {
        x: null,
        y: null
      };
      return dims.forEach((dim) => {
        var _a2;
        const boxSize = "x" === dim ? tooltipBoxWidth : tooltipBoxHeight, canvasSize = "x" === dim ? canvasWidth : canvasHeight, offset = "x" === dim ? offsetX : offsetY, posType = getPositionType(pointerFixedPosition[dim], dim);
        if (isValidNumber_default(calcPos[dimToPos[dim][0]])) result2[dim] = calcPos[dimToPos[dim][0]];
        else if (isValidNumber_default(calcPos[dimToPos[dim][1]])) result2[dim] = canvasSize - boxSize * tooltipSizeScale - calcPos[dimToPos[dim][1]];
        else {
          const value0 = "x" === dim ? event.canvasX : event.canvasY;
          result2[dim] = posType > 0 ? value0 + offset : 0 === posType ? value0 - boxSize * tooltipSizeScale / 2 : value0 - boxSize * tooltipSizeScale - offset;
        }
        result2[dim] *= chartElementScale, isBrowser2 && (result2[dim] += relativePosOffset[dim]), result2[dim] /= tooltipParentElementScale;
        const containerDimSize = "x" === dim ? containerSize.width : containerSize.height, leftOrTop = tooltipSpec.confine ? -(tooltipParentElementRect[dim] - (null !== (_a2 = null == chartElementRect ? void 0 : chartElementRect[dim]) && void 0 !== _a2 ? _a2 : 0) / chartElementScale) / tooltipParentElementScale : -tooltipParentElementRect[dim] / tooltipParentElementScale, rightOrBottom = containerDimSize / tooltipParentElementScale + leftOrTop - boxSize;
        2 !== posType && result2[dim] < leftOrTop ? isFixedPosition ? result2[dim] = leftOrTop : (result2[dim] += 0 === posType ? offset + boxSize / 2 : 2 * offset + boxSize, result2[dim] > rightOrBottom && (result2[dim] = rightOrBottom)) : -2 !== posType && result2[dim] > rightOrBottom && (isFixedPosition ? result2[dim] = rightOrBottom : (result2[dim] -= 0 === posType ? offset + boxSize / 2 : 2 * offset + boxSize, result2[dim] < leftOrTop && (result2[dim] = leftOrTop)));
      }), result2;
    };
  }
  get env() {
    return this._env;
  }
  onAdd(service) {
    super.onAdd(service);
    const component2 = service.component;
    this._component = component2, this._chartOption = component2.getOption(), this._env = this._chartOption.mode, this._chartContainer = this._chartOption.globalInstance.getContainer(), this._compiler = component2.getCompiler(), this._initFromSpec();
  }
  hideTooltip(params2) {
    return this.changeTooltip(false, params2);
  }
  release() {
    var _a, _b, _c;
    const spec = null !== (_a = this._component.getSpec()) && void 0 !== _a ? _a : {};
    spec.handler ? null === (_c = (_b = spec.handler).release) || void 0 === _c || _c.call(_b) : (this._removeTooltip(), this._isReleased = true);
  }
  _getDefaultOption() {
    var _a, _b;
    const { offset } = this._component.getSpec();
    return offset ? {
      offsetX: null !== (_a = offset.x) && void 0 !== _a ? _a : DEFAULT_OPTIONS.offsetX,
      offsetY: null !== (_b = offset.y) && void 0 !== _b ? _b : DEFAULT_OPTIONS.offsetY
    } : DEFAULT_OPTIONS;
  }
  _getParentElement(spec) {
    return spec.parentElement;
  }
  getTooltipContainer() {
    return this._container;
  }
  _initFromSpec() {
    this._option = this._getDefaultOption();
  }
  reInit() {
    this._initFromSpec();
  }
};
BaseTooltipHandler.specKey = "tooltip";

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/utils/style.js
var getPixelPropertyStr = (num, defaultStr) => isValid_default(num) ? isArray_default(num) ? num.map((n) => `${n}px`).join(" ") : `${num}px` : null != defaultStr ? defaultStr : "initial";
var getTextStyle2 = (style = {}, textStyle = {}) => {
  var _a, _b;
  isValid_default(style.fontFamily) && (textStyle.fontFamily = style.fontFamily);
  const color = null !== (_a = style.fill) && void 0 !== _a ? _a : style.fontColor;
  return isValid_default(color) && (textStyle.color = color), isValid_default(style.fontWeight) && (textStyle.fontWeight = style.fontWeight), isValid_default(style.textAlign) && (textStyle.textAlign = style.textAlign), isValid_default(style.fontSize) && (textStyle.fontSize = getPixelPropertyStr(style.fontSize)), isValid_default(style.maxWidth) && (textStyle.maxWidth = getPixelPropertyStr(style.maxWidth)), style.multiLine || isValid_default(style.maxWidth) && false !== style.multiLine ? (textStyle.whiteSpace = "initial", textStyle.wordBreak = null !== (_b = style.wordBreak) && void 0 !== _b ? _b : "break-word") : (textStyle.wordBreak = "normal", textStyle.whiteSpace = "nowrap"), textStyle;
};
var getLineHeight = (style = {}) => {
  const { lineHeight } = style;
  return style.fontSize ? calcLayoutNumber(lineHeight, style.fontSize) : 0;
};
var getDomStyle = (spec = {}) => {
  var _a, _b, _c, _d;
  const { style = {}, enterable, transitionDuration } = spec, { panel = {}, titleLabel, shape, keyLabel, valueLabel, spaceRow: commonSpaceRow, align } = style, { panelStyle, panelPadding } = getPanelStyle(panel), rowStyle = {
    marginTop: "0px",
    marginBottom: "0px"
  };
  panelStyle.pointerEvents = enterable ? "auto" : "none", transitionDuration && (panelStyle.transitionDuration = transitionDuration ? `${transitionDuration}ms` : "initial", panelStyle.transitionProperty = transitionDuration ? "transform" : "initial", panelStyle.transitionTimingFunction = transitionDuration ? "ease-out" : "initial"), isValidNumber_default(commonSpaceRow) && (rowStyle.marginBottom = `${commonSpaceRow}px`);
  const shapeStyle = {
    width: getPixelPropertyStr(null !== (_a = null == shape ? void 0 : shape.size) && void 0 !== _a ? _a : 8)
  }, titleStyle = getTextStyle2(titleLabel), keyStyle = getTextStyle2(keyLabel), valueStyle = getTextStyle2(valueLabel), marginKey = "right" === align ? "marginLeft" : "marginRight";
  "right" === align ? (panelStyle.direction = "rtl", titleStyle.textAlign = "right", keyStyle.textAlign = "right", valueStyle.textAlign = "left") : (titleStyle.textAlign = "left", keyStyle.textAlign = "left", valueStyle.textAlign = "right"), shapeStyle[marginKey] = getPixelPropertyStr(null !== (_b = shape.spacing) && void 0 !== _b ? _b : 8), keyStyle[marginKey] = getPixelPropertyStr(null !== (_c = keyLabel.spacing) && void 0 !== _c ? _c : 26), valueStyle[marginKey] = getPixelPropertyStr(null !== (_d = valueLabel.spacing) && void 0 !== _d ? _d : 0);
  const lineHeight = Math.max(getLineHeight(valueLabel), getLineHeight(keyLabel));
  return rowStyle.lineHeight = lineHeight > 0 ? `${lineHeight}px` : "20px", {
    panelPadding,
    row: rowStyle,
    panel: panelStyle,
    title: titleStyle,
    shape: shapeStyle,
    key: keyStyle,
    value: valueStyle
  };
};
var getPanelStyle = (style) => {
  var _a;
  const { backgroundColor, border, shadow, padding } = style, panelStyle = {
    borderWidth: `${null !== (_a = null == border ? void 0 : border.width) && void 0 !== _a ? _a : 0}px`
  };
  let panelPadding = null;
  (null == border ? void 0 : border.color) && (panelStyle.borderColor = border.color), backgroundColor && (panelStyle.backgroundColor = backgroundColor), panelStyle.boxShadow = shadow ? `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.spread}px ${shadow.color}` : "initial";
  const { radius } = null != border ? border : {};
  return isValid_default(radius) && (panelStyle.borderRadius = isValidNumber_default(radius) ? `${radius}px` : `${radius}`), padding && (panelPadding = normalizePadding(padding), panelStyle.padding = getPixelPropertyStr(panelPadding)), {
    panelStyle,
    panelPadding
  };
};
function setStyleToDom(dom, style) {
  dom && dom.style && style && Object.keys(style).forEach((key) => {
    dom.style[key] = style[key];
  });
}

// node_modules/@visactor/vchart/esm/plugin/components/register.js
var registerComponentPlugin = (plugin) => {
  Factory2.registerComponentPlugin(plugin.type, plugin);
};

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/utils/svg.js
function getSvgHtml(option, gradientId) {
  var _a, _b, _c, _d, _e, _f;
  if (!option || !option.hasShape || !option.shapeType) return "";
  const styleString = 'style="display:inline-block;vertical-align:middle;"', { shapeType, shapeFill, shapeStroke, shapeHollow = false } = option, size = null !== (_a = option.shapeSize) && void 0 !== _a ? _a : 8, lineWidth = option.shapeLineWidth ? escapeHTML(option.shapeLineWidth) + "px" : "0px";
  let fillString = "currentColor";
  const getStroke2 = () => shapeStroke ? escapeHTML(shapeStroke) : fillString, sizeNumber = size, createSymbol2 = (symbolType) => new Symbol2({
    symbolType,
    size: sizeNumber,
    fill: true
  });
  let symbol = createSymbol2(shapeType);
  const parsedPath = symbol.getParsedPath();
  let bounds, path;
  if (!parsedPath.path && parsedPath.pathStr && (symbol = createSymbol2(parsedPath.pathStr)), symbol.getParsedPath().path) {
    const pathModel = symbol.getParsedPath().path;
    path = pathModel.toString(), bounds = pathModel.bounds;
  } else parsedPath.isSvg && parsedPath.svgCache && (path = parsedPath.svgCache.map((s2) => s2.path.toString()).join(), bounds = parsedPath.svgCache.reduce((acc, cur) => acc.union(cur.path.bounds), new Bounds()));
  let viewBox = `${bounds.x1} ${bounds.y1} ${bounds.width()} ${bounds.height()}`;
  if ("0px" !== lineWidth) {
    const [x, y, w, h] = viewBox.split(" ").map((n) => Number(n)), lw = Number(lineWidth.slice(0, -2));
    viewBox = `${x - lw / 2} ${y - lw / 2} ${w + lw} ${h + lw}`;
  }
  if (!shapeFill || isString_default(shapeFill) || shapeHollow) return fillString = shapeHollow ? "none" : shapeFill ? escapeHTML(shapeFill) : "currentColor", `
    <svg ${styleString} width="${size}" height="${size}" viewBox="${viewBox}">
      <path
        d="${path}"
        style="fill: ${fillString}; stroke: ${getStroke2()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  if (isObject_default(shapeFill)) {
    fillString = "gradientColor" + (null != gradientId ? gradientId : "");
    let gradient = "";
    const stops = (null !== (_b = shapeFill.stops) && void 0 !== _b ? _b : []).map((s2) => `<stop offset="${escapeHTML(s2.offset.toString())}" stop-color="${escapeHTML(s2.color)}"/>`).join("");
    return "radial" === shapeFill.gradient ? gradient = `<radialGradient id="${fillString}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">
      ${stops}
      </radialGradient>` : "linear" === shapeFill.gradient && (gradient = `<linearGradient id="${fillString}" x1="${100 * (null !== (_c = shapeFill.x0) && void 0 !== _c ? _c : 0)}%" y1="${100 * (null !== (_d = shapeFill.y0) && void 0 !== _d ? _d : 0)}%" x2="${100 * (null !== (_e = shapeFill.x1) && void 0 !== _e ? _e : 0)}%" y2="${100 * (null !== (_f = shapeFill.y1) && void 0 !== _f ? _f : 0)}%">
      ${stops}
      </linearGradient>`), `
    <svg ${styleString} width="${size}" height="${size}" viewBox="-0.5 -0.5 1 1">
      ${gradient}
      <path
        d="${path}"
        style="fill: url(#${fillString}); stroke: ${getStroke2()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  }
  return "";
}

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/dom-tooltip-handler.js
var DomTooltipHandler = class _DomTooltipHandler extends BaseTooltipHandler {
  getVisibility() {
    return !!this._rootDom && "visible" === this._rootDom.style.visibility;
  }
  setVisibility(_value) {
    _value !== this.getVisibility() && this._rootDom && (this._rootDom.style.visibility = _value ? "visible" : "hidden");
  }
  constructor() {
    super(_DomTooltipHandler.type), this.type = TooltipHandlerType.dom, this._tooltipContainer = null == domDocument ? void 0 : domDocument.body;
  }
  onAdd(service) {
    super.onAdd(service), this._initStyle(), this.initEl();
  }
  initEl() {
    const parentElement = this._component.getSpec().parentElement;
    if (domDocument && parentElement && parentElement.children && parentElement.children.length) {
      for (let i = 0; i < parentElement.children.length; i++) if (parentElement.children[i].classList.contains(TOOLTIP_CONTAINER_EL_CLASS_NAME)) {
        this._container = parentElement.children[i];
        break;
      }
      this._container || (this._container = domDocument.createElement("div"), this._container.style.position = "relative", this._container.style.zIndex = DEFAULT_TOOLTIP_Z_INDEX, this._container.classList.add(TOOLTIP_CONTAINER_EL_CLASS_NAME), parentElement.appendChild(this._container));
    }
  }
  initRootDom() {
    var _a, _b, _c;
    const tooltipSpec = this._component.getSpec(), tooltipElement = document.createElement("div"), globalTheme2 = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
    setStyleToDom(tooltipElement, Object.assign({
      left: "0",
      top: "0",
      pointerEvents: "none",
      padding: "12px",
      position: "absolute",
      zIndex: DEFAULT_TOOLTIP_Z_INDEX,
      fontFamily: null !== (_c = null == globalTheme2 ? void 0 : globalTheme2.fontFamily) && void 0 !== _c ? _c : token.fontFamily,
      fontSize: "11px",
      borderRadius: "3px",
      borderStyle: "solid",
      lineHeight: "initial",
      background: "#fff",
      boxShadow: "2px 2px 4px rgba(0, 0, 0, 0.1)",
      maxWidth: "100wh",
      maxHeight: "100vh",
      visibility: "hidden"
    }, this._domStyle.panel)), tooltipElement.classList.add(tooltipSpec.className), tooltipElement.setAttribute("vchart-tooltip-id", `${this.id}`), this._container.appendChild(tooltipElement), this._rootDom = tooltipElement;
  }
  _getTooltipBoxSize(actualTooltip, changePositionOnly) {
    var _a;
    this._rootDom || this.initRootDom(), changePositionOnly || this._updateDomStringByCol(actualTooltip), this._updateDomStyle("height");
    const rect = null === (_a = this._rootDom) || void 0 === _a ? void 0 : _a.getBoundingClientRect();
    return {
      width: null == rect ? void 0 : rect.width,
      height: null == rect ? void 0 : rect.height
    };
  }
  _removeTooltip() {
    this._rootDom && this._rootDom.parentNode && (this._rootDom.parentNode.removeChild(this._rootDom), this._rootDom = null), this._container = null;
  }
  _updateTooltip(visible, params2) {
    var _a, _b, _c;
    if (visible && this._rootDom) {
      const { tooltipSpec, activeTooltipSpec } = params2;
      params2.changePositionOnly || (this._tooltipActual = activeTooltipSpec);
      const currentVisible = this.getVisibility(), el = this._rootDom;
      if (el) {
        const { x = 0, y = 0 } = null !== (_a = activeTooltipSpec.position) && void 0 !== _a ? _a : {};
        if (tooltipSpec.updateElement) {
          this._updatePosition(null !== (_b = this._cacheCustomTooltipPosition) && void 0 !== _b ? _b : {
            x,
            y
          }), tooltipSpec.updateElement(el, activeTooltipSpec, params2);
          const position = this._getActualTooltipPosition(activeTooltipSpec, params2, {
            width: el.offsetWidth,
            height: el.offsetHeight
          });
          this._updatePosition(position), this._cacheCustomTooltipPosition = position;
        } else this._rootDom.style.transitionDuration = currentVisible ? null !== (_c = this._domStyle.panel.transitionDuration) && void 0 !== _c ? _c : "initial" : "0ms", this._updatePosition({
          x,
          y
        });
      }
      this.setVisibility(visible);
    } else this.setVisibility(visible), this._cacheCustomTooltipPosition = void 0;
  }
  _initStyle() {
    const tooltipSpec = this._component.getSpec();
    this._domStyle = getDomStyle(tooltipSpec);
  }
  _updateDomStringByCol(actualTooltip) {
    var _a;
    const { title: title3 = {}, content } = actualTooltip, hasContent = content && content.length, rowStyle = this._domStyle.row, chilren = [...this._rootDom.children];
    let titleDom = chilren.find((child) => child.className.includes(TOOLTIP_TITLE_CLASS_NAME));
    if (!titleDom && false !== title3.visible) {
      titleDom = document.createElement("h2");
      const span = document.createElement("span");
      titleDom.appendChild(span), titleDom.classList.add(TOOLTIP_TITLE_CLASS_NAME), this._rootDom.appendChild(titleDom);
    }
    titleDom && false !== title3.visible ? (setStyleToDom(titleDom, Object.assign(Object.assign(Object.assign({}, this._domStyle.title), hasContent ? rowStyle : {
      marginBottom: "0px"
    }), {
      marginTop: "0px"
    })), titleDom.firstChild.innerHTML = `${null !== (_a = title3.value) && void 0 !== _a ? _a : ""}`) : titleDom && false === title3.visible && titleDom.parentNode.removeChild(titleDom);
    let contentDom = chilren.find((child) => child.className.includes(TOOLTIP_CONTENT_BOX_CLASS_NAME));
    const columns = ["shape", "key", "value"];
    if (!contentDom && hasContent && (contentDom = document.createElement("div"), columns.forEach((col) => {
      const colDiv = document.createElement("div");
      colDiv.classList.add(`${TOOLTIP_PREFIX}-column`), colDiv.classList.add(`${TOOLTIP_PREFIX}-${col}-column`), colDiv.setAttribute("data-col", col), contentDom.appendChild(colDiv);
    }), contentDom.classList.add(TOOLTIP_CONTENT_BOX_CLASS_NAME), this._rootDom.appendChild(contentDom)), contentDom && hasContent) {
      const columnDivs = [...contentDom.children];
      setStyleToDom(contentDom, {
        whiteSpace: "nowrap"
      }), columnDivs.forEach((colDiv, index) => {
        const colName = colDiv.getAttribute("data-col");
        if (colName && columns.includes(colName)) {
          const hideColumn = "shape" === colName && content.every((c3) => !c3.hasShape || !c3.shapeType);
          setStyleToDom(colDiv, Object.assign(Object.assign({}, this._domStyle[colName]), {
            display: hideColumn ? "none" : "inline-block",
            verticalAlign: "top"
          }));
          const rows = [...colDiv.children];
          rows.slice(content.length).forEach((extraRow) => {
            extraRow.parentNode.removeChild(extraRow);
          }), content.forEach((entry, index2) => {
            let row = rows[index2];
            row || (row = document.createElement("div"), row.classList.add(`${TOOLTIP_PREFIX}-${colName}`), colDiv.appendChild(row));
            const styleByRow = Object.assign({}, rowStyle);
            index2 === content.length - 1 && (styleByRow.marginBottom = "0px"), styleByRow.display = false === entry.visible ? "none" : "block", styleByRow.height = "initial", "key" === colName ? (row.innerHTML = formatContent(entry.key), entry.keyStyle && getTextStyle2(entry.keyStyle, styleByRow)) : "value" === colName ? (row.innerHTML = formatContent(entry.value), entry.valueStyle && getTextStyle2(entry.valueStyle, styleByRow)) : "shape" === colName && (row.innerHTML = getSvgHtml(entry, `${this.id}_${index2}`)), setStyleToDom(row, styleByRow);
          });
        }
      });
    } else contentDom && !hasContent && contentDom.parentNode.removeChild(contentDom);
  }
  _updateDomStyle(sizeKey = "width") {
    var _a, _b, _c, _d, _e;
    const rootDom = this._rootDom, contentDom = [...rootDom.children].find((child) => child.className.includes(TOOLTIP_CONTENT_BOX_CLASS_NAME)), titleDom = [...rootDom.children].find((child) => child.className.includes(TOOLTIP_TITLE_CLASS_NAME));
    if (contentDom) {
      const tooltipSpec = this._component.getSpec(), contentStyle = {}, titleLabel = null === (_a = tooltipSpec.style) || void 0 === _a ? void 0 : _a.titleLabel;
      if (titleLabel && titleLabel.autoWidth && false !== titleLabel.multiLine && titleDom) {
        const maxWidth = [...contentDom.children].reduce((res, col) => "height" === sizeKey ? res + col.getBoundingClientRect().width : Math.max(res, col.getBoundingClientRect().width), 0);
        maxWidth > 0 && (titleDom.style.maxWidth = `${maxWidth}px`, titleDom.style.maxWidth = `${Math.ceil(contentDom.getBoundingClientRect().width)}px`);
      }
      if (isValid_default(null === (_b = null == tooltipSpec ? void 0 : tooltipSpec.style) || void 0 === _b ? void 0 : _b.maxContentHeight)) {
        const titleHeight = titleDom && titleDom.className.includes(TOOLTIP_TITLE_CLASS_NAME) ? titleDom.getBoundingClientRect().height + (null !== (_c = tooltipSpec.style.spaceRow) && void 0 !== _c ? _c : 0) : 0, viewRect = this._chartOption.getChartViewRect(), maxHeight = calcLayoutNumber(tooltipSpec.style.maxContentHeight, Math.min(viewRect.height, document.body.clientHeight) - titleHeight - (this._domStyle.panelPadding ? this._domStyle.panelPadding[0] + this._domStyle.panelPadding[1] : 0));
        maxHeight > 0 && (contentStyle.maxHeight = `${maxHeight}px`, contentStyle.overflowY = "auto", contentStyle.width = `calc(100% + ${this._domStyle.panelPadding ? this._domStyle.panelPadding[1] + "px" : "10px"})`, setStyleToDom(contentDom, contentStyle));
      }
      const rows = contentDom.children, widthByCol = [];
      if (rows) {
        for (let i = 0; i < rows.length; i++) {
          const cols = null !== (_d = rows[i].children) && void 0 !== _d ? _d : [];
          for (let j = 0; j < cols.length; j++) {
            const width = cols[j].getBoundingClientRect()[sizeKey];
            (void 0 === widthByCol[j] || widthByCol[j] < width) && (widthByCol[j] = width);
          }
        }
        for (let i = 0; i < rows.length; i++) {
          const cols = null !== (_e = rows[i].children) && void 0 !== _e ? _e : [];
          for (let j = 0; j < cols.length; j++) cols[j].style[sizeKey] = `${widthByCol[j]}px`;
        }
      }
    }
  }
  _getParentElement(spec) {
    var _a;
    return null !== (_a = this._container) && void 0 !== _a ? _a : super._getParentElement(spec);
  }
  isTooltipShown() {
    return this.getVisibility();
  }
  reInit() {
    super.reInit(), this._initStyle(), this._rootDom && setStyleToDom(this._rootDom, this._domStyle.panel), this.getVisibility() && (this._updateDomStringByCol(this._tooltipActual), this._updateDomStyle("height"));
  }
  _updatePosition({ x, y }) {
    this._rootDom && (this._rootDom.style.transform = `translate3d(${x}px, ${y}px, 0)`);
  }
};
DomTooltipHandler.type = TooltipHandlerType.dom;
var registerDomTooltipHandler = () => {
  registerComponentPlugin(DomTooltipHandler);
};

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/utils/attribute.js
var DEFAULT_TEXT_ATTRIBUTES = {
  fontFamily: token.fontFamily,
  spacing: 10,
  wordBreak: "break-word"
};
var measureTooltipText = (text2, style) => {
  var _a;
  let textLines, textConfig;
  "rich" !== (null == text2 ? void 0 : text2.type) && "html" !== (null == text2 ? void 0 : text2.type) ? (text2 = (null != text2 ? text2 : "").toString(), style.multiLine ? (textLines = text2.split("\n"), textLines = textLines.map((line2, i) => i < textLines.length - 1 ? line2 + "\n" : line2)) : textLines = [text2], textConfig = textLines.map((line2) => Object.assign(Object.assign({}, style), {
    text: line2
  }))) : (textConfig = text2.text, textLines = text2);
  const bound2 = getRichTextBounds({
    wordBreak: null !== (_a = style.wordBreak) && void 0 !== _a ? _a : "break-word",
    maxWidth: style.maxWidth ? style.maxWidth : void 0,
    width: 0,
    height: 0,
    textConfig
  });
  return {
    width: bound2.width(),
    height: bound2.height(),
    text: textLines
  };
};
function getTextAttributes(style = {}, globalTheme2, defaultAttributes2) {
  var _a, _b;
  return Object.assign(Object.assign({}, null != defaultAttributes2 ? defaultAttributes2 : DEFAULT_TEXT_ATTRIBUTES), {
    fill: null !== (_a = style.fill) && void 0 !== _a ? _a : style.fontColor,
    textAlign: style.textAlign,
    textBaseline: style.textBaseline,
    fontFamily: null !== (_b = style.fontFamily) && void 0 !== _b ? _b : null == globalTheme2 ? void 0 : globalTheme2.fontFamily,
    fontSize: style.fontSize,
    fontWeight: style.fontWeight,
    lineHeight: style.lineHeight,
    spacing: style.spacing,
    multiLine: isValid_default(style.maxWidth) ? false !== style.multiLine : style.multiLine,
    maxWidth: style.maxWidth,
    wordBreak: style.wordBreak,
    autoWidth: style.autoWidth
  });
}
var getPanelAttributes = (style) => {
  var _a;
  const { backgroundColor, border, shadow } = style, panelAttrs = {
    lineWidth: null !== (_a = null == border ? void 0 : border.width) && void 0 !== _a ? _a : 0,
    shadow: !!shadow
  };
  (null == border ? void 0 : border.color) && (panelAttrs.stroke = border.color), backgroundColor && (panelAttrs.fill = backgroundColor), shadow && (panelAttrs.shadowColor = shadow.color, panelAttrs.shadowBlur = shadow.blur, panelAttrs.shadowOffsetX = shadow.x, panelAttrs.shadowOffsetY = shadow.y, panelAttrs.shadowSpread = shadow.spread);
  const { radius } = null != border ? border : {};
  return isValid_default(radius) && (panelAttrs.cornerRadius = [radius, radius, radius, radius]), panelAttrs;
};
var getTooltipAttributes = (actualTooltip, spec, globalTheme2) => {
  var _a, _b, _c, _d, _e;
  const { style = {}, enterable, transitionDuration } = spec, { panel = {}, titleLabel, shape, keyLabel, valueLabel, spaceRow: commonSpaceRow, align } = style, padding = normalizePadding(panel.padding), paddingSpec = normalizeLayoutPaddingSpec(panel.padding), titleStyle = getTextAttributes(Object.assign({
    textAlign: "right" === align ? "right" : "left"
  }, titleLabel), globalTheme2), keyStyle = getTextAttributes(Object.assign({
    textAlign: "right" === align ? "right" : "left"
  }, keyLabel), globalTheme2), valueStyle = getTextAttributes(valueLabel, globalTheme2), shapeStyle = {
    fill: true,
    size: null !== (_a = null == shape ? void 0 : shape.size) && void 0 !== _a ? _a : 8,
    spacing: null !== (_b = null == shape ? void 0 : shape.spacing) && void 0 !== _b ? _b : 6
  }, attributes = {
    panel: getPanelAttributes(panel),
    padding,
    title: {},
    content: [],
    titleStyle: {
      value: titleStyle,
      spaceRow: commonSpaceRow
    },
    contentStyle: {
      shape: shapeStyle,
      key: keyStyle,
      value: valueStyle,
      spaceRow: commonSpaceRow
    },
    hasContentShape: false,
    keyWidth: 0,
    valueWidth: 0,
    enterable,
    transitionDuration,
    align
  }, { title: title3 = {}, content = [] } = actualTooltip;
  let panelWidth = paddingSpec.left + paddingSpec.right, panelHeight = paddingSpec.top + paddingSpec.bottom, contentMaxWidth = 0;
  const hasContent = !!content.length;
  let maxKeyWidth = 0, maxAdaptiveKeyWidth = 0, maxValueWidth = 0, maxShapeWidth = 0;
  if (hasContent) {
    const keyWidths = [], adaptiveKeyWidths = [], valueWidths = [], shapeWidths = [];
    let contentHeight = 0;
    attributes.content = content.map((item, i) => {
      let itemHeight = 0;
      const { hasShape: actualHasShape, key: actualKey, shapeType: actualShapeType = "", shapeFill: actualShapeFill, shapeStroke: actualShapeStroke, shapeLineWidth: actualShapeLineWidth, shapeSize: actualShapeSize, value: actualValue, isKeyAdaptive: actualIsKeyAdaptive, spaceRow: actualSpaceRow, keyStyle: actualKeyStyle, valueStyle: actualValueStyle, shapeHollow: actualShapeHollow } = item, itemAttrs = {
        height: 0,
        spaceRow: null != actualSpaceRow ? actualSpaceRow : commonSpaceRow
      };
      if (isValid_default(actualKey)) {
        const itemKeyStyle = mergeSpec({}, keyStyle, getTextAttributes(actualKeyStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualKey, itemKeyStyle);
        itemAttrs.key = Object.assign(Object.assign({
          width,
          height
        }, itemKeyStyle), {
          text: text2
        }), actualIsKeyAdaptive ? adaptiveKeyWidths.push(width) : keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (isValid_default(actualValue)) {
        const itemValueStyle = mergeSpec({}, valueStyle, getTextAttributes(actualValueStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualValue, itemValueStyle);
        itemAttrs.value = Object.assign(Object.assign({
          width,
          height
        }, itemValueStyle), {
          text: text2
        }), valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (actualHasShape) {
        const shape2 = {
          visible: true,
          symbolType: actualShapeType
        };
        actualShapeHollow ? shape2.stroke = actualShapeFill : shape2.fill = actualShapeFill, shape2.stroke = null != actualShapeStroke ? actualShapeStroke : actualShapeFill, shape2.lineWidth = actualShapeLineWidth, itemAttrs.shape = shape2;
        const shapeWidth = null != actualShapeSize ? actualShapeSize : shapeStyle.size;
        itemHeight = Math.max(shapeWidth, itemHeight), shapeWidths.push(shapeWidth);
      } else itemAttrs.shape = {
        visible: false
      };
      return itemAttrs.height = itemHeight, contentHeight += itemHeight, i < content.length - 1 && (contentHeight += itemAttrs.spaceRow), itemAttrs;
    }), panelHeight += contentHeight, maxKeyWidth = keyWidths.length ? maxInArray(keyWidths) : 0, maxAdaptiveKeyWidth = adaptiveKeyWidths.length ? maxInArray(adaptiveKeyWidths) : 0, maxValueWidth = valueWidths.length ? maxInArray(valueWidths) : 0, maxShapeWidth = shapeWidths.length ? maxInArray(shapeWidths) + shapeStyle.spacing : 0, contentMaxWidth = Math.max(maxShapeWidth + maxKeyWidth + keyStyle.spacing + maxValueWidth + valueStyle.spacing, maxShapeWidth + maxAdaptiveKeyWidth, contentMaxWidth), attributes.hasContentShape = !!shapeWidths.length, attributes.keyWidth = maxKeyWidth, attributes.valueWidth = maxValueWidth;
  }
  let titleMaxWidth = 0, titleMaxHeight = 0, titleHeightWithSpace = 0;
  const { visible: actualTitleVisible = true, value: actualTitleValue = "", valueStyle: actualTitleValueStyle, spaceRow: actualTitleSpaceRow } = title3;
  attributes.title.visible = actualTitleVisible, attributes.title.spaceRow = null != actualTitleSpaceRow ? actualTitleSpaceRow : commonSpaceRow;
  let titleValueStyle = {};
  const isAutoWidthMode = () => titleValueStyle.autoWidth && false !== titleValueStyle.multiLine;
  if (actualTitleVisible) {
    titleValueStyle = mergeSpec({}, titleStyle, getTextAttributes(actualTitleValueStyle, void 0, {})), isAutoWidthMode() && (titleValueStyle.multiLine = null === (_c = titleValueStyle.multiLine) || void 0 === _c || _c, titleValueStyle.maxWidth = null !== (_d = titleValueStyle.maxWidth) && void 0 !== _d ? _d : hasContent ? Math.ceil(contentMaxWidth) : void 0);
    const { text: text2, width, height } = measureTooltipText(actualTitleValue, titleValueStyle);
    attributes.title.value = Object.assign(Object.assign({
      width: isAutoWidthMode() ? Math.min(width, null !== (_e = titleValueStyle.maxWidth) && void 0 !== _e ? _e : Number.MAX_VALUE) : width,
      height
    }, titleValueStyle), {
      text: text2
    }), titleMaxWidth = attributes.title.value.width, titleMaxHeight = attributes.title.value.height, titleHeightWithSpace = titleMaxHeight + (hasContent ? attributes.title.spaceRow : 0);
  }
  return panelHeight += titleHeightWithSpace, attributes.title.width = titleMaxWidth, attributes.title.height = titleMaxHeight, isAutoWidthMode() ? panelWidth += contentMaxWidth || titleMaxWidth : panelWidth += Math.max(titleMaxWidth, contentMaxWidth), hasContent && attributes.content.forEach((item) => {
    var _a2;
    const value = item.value;
    value && (null === (_a2 = value.autoWidth) || void 0 === _a2 || _a2) && (value.width = panelWidth - paddingSpec.left - paddingSpec.right - maxShapeWidth - maxKeyWidth - keyStyle.spacing - valueStyle.spacing, value.maxWidth || (value.maxWidth = Math.ceil(value.width)), attributes.valueWidth = Math.max(attributes.valueWidth, value.width));
  }), attributes.panel.width = panelWidth, attributes.panel.height = panelHeight, attributes;
};

// node_modules/@visactor/vchart/esm/plugin/components/tooltip-handler/canvas-tooltip-handler.js
var CanvasTooltipHandler = class _CanvasTooltipHandler extends BaseTooltipHandler {
  constructor() {
    super(_CanvasTooltipHandler.type), this.type = TooltipHandlerType.canvas, this._attributes = null;
  }
  onAdd(service) {
    var _a;
    super.onAdd(service), this._tooltipCanvasId = null === (_a = this._chartOption.modeParams) || void 0 === _a ? void 0 : _a.tooltipCanvasId;
  }
  _initTooltipComponent(stage) {
    const layer = this._getLayer(stage);
    this._tooltipComponent = new Tooltip({
      autoCalculatePosition: false,
      autoMeasure: false
    }), layer.add(this._tooltipComponent);
  }
  _getLayer(stage) {
    if (this._layer) return this._layer;
    this._layer = stage.createLayer(this._tooltipCanvasId);
    const layerCanvas = this._layer.layerHandler.canvas.nativeCanvas;
    return layerCanvas && layerCanvas.style && (layerCanvas.style.touchAction = "none", layerCanvas.style.pointerEvents = "none"), this._layer;
  }
  _getTooltipBoxSize(actualTooltip, changePositionOnly) {
    var _a, _b, _c;
    if (!changePositionOnly || isNil_default(this._attributes)) {
      const chartTheme = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
      this._attributes = getTooltipAttributes(actualTooltip, this._component.getSpec(), chartTheme);
    }
    const { panel } = null !== (_c = this._attributes) && void 0 !== _c ? _c : {};
    return {
      width: panel.width + panel.lineWidth,
      height: panel.height + panel.lineWidth
    };
  }
  _removeTooltip() {
    this._layer && this._layer.removeAllChild(), this._attributes = null;
  }
  _updateTooltip(visible, params2) {
    this._visible = visible;
    const stage = this._compiler.getStage();
    if (!stage) return;
    if (!visible) return void (this._tooltipComponent && this._tooltipComponent.attribute.visible && (this._tooltipComponent.hideAll(), this._tooltipComponent.setAttributes({
      visibleAll: false
    })));
    this._tooltipComponent || this._initTooltipComponent(stage);
    const { activeTooltipSpec } = params2, pos = activeTooltipSpec.position;
    params2.changePositionOnly ? isValid_default(pos) && this._tooltipComponent.setAttributes(pos) : this._tooltipComponent.setAttributes(Object.assign(Object.assign({}, this._attributes), pos)), this._tooltipComponent.attribute.visible || (this._tooltipComponent.showAll(), this._tooltipComponent.setAttributes({
      visibleAll: true
    }));
  }
  isTooltipShown() {
    var _a;
    return null === (_a = this._tooltipComponent) || void 0 === _a ? void 0 : _a.attribute.visibleAll;
  }
  release() {
    var _a;
    super.release(), null === (_a = this._layer) || void 0 === _a || _a.release();
  }
};
CanvasTooltipHandler.type = TooltipHandlerType.canvas;
var registerCanvasTooltipHandler = () => {
  registerComponentPlugin(CanvasTooltipHandler);
};

// node_modules/@visactor/vchart/esm/plugin/chart/register.js
var registerChartPlugin = (plugin) => {
  Factory2.registerChartPlugin(plugin.type, plugin);
};

// node_modules/@visactor/vchart/esm/plugin/chart/formatter/formatter.js
var bracketReg = /\{([^}]+)\}/;
var bracketGReg = /\{([^}]+)\}/g;
var semicolonReg = /:/;
var FormatterPlugin = class _FormatterPlugin extends BasePlugin {
  constructor() {
    super(_FormatterPlugin.type), this.type = "formatterPlugin", this._timeModeFormat = {
      utc: TimeUtil.getInstance().timeUTCFormat,
      local: TimeUtil.getInstance().timeFormat
    }, this._formatter = this._format, this._timeFormatter = this._timeModeFormat.local, this._numericFormatter = NumberUtil.getInstance().format, this._numericSpecifier = NumberUtil.getInstance().formatter, this._numericFormatterCache = /* @__PURE__ */ new Map(), this._isNumericFormatterCache = /* @__PURE__ */ new Map();
  }
  onInit(service, chartSpec) {
    var _a;
    const { globalInstance } = service;
    if (!globalInstance) return;
    this._spec = null !== (_a = null == chartSpec ? void 0 : chartSpec[_FormatterPlugin.specKey]) && void 0 !== _a ? _a : {};
    const { timeMode, customFormatter, numericFormatter, timeFormatter } = this._spec;
    isFunction_default(customFormatter) ? this._formatter = customFormatter : (this._formatter = this._format.bind(this), isFunction_default(timeFormatter) ? this._timeFormatter = timeFormatter : timeMode && this._timeModeFormat[timeMode] && (this._timeFormatter = this._timeModeFormat[timeMode]), numericFormatter && (this._numericFormatter = numericFormatter, this._numericSpecifier = null, this._numericFormatterCache = null)), Factory2.registerFormatter(this._formatter);
  }
  _format(text2, datum, formatter) {
    return isArray_default(text2) ? text2.map((t, i) => {
      const f = isArray_default(formatter) ? formatter[i] : formatter;
      return f ? this._formatSingleLine(t, datum, f) : t;
    }) : isArray_default(formatter) ? formatter.map((f) => this._formatSingleLine(text2, datum, f)) : this._formatSingleLine(text2, datum, formatter);
  }
  _formatSingleLine(text2, datum, formatter) {
    let isTemplate;
    if (this._isNumericFormatterCache && (this._isNumericFormatterCache.get(formatter) ? isTemplate = this._isNumericFormatterCache.get(formatter) : (isTemplate = bracketReg.test(formatter), this._isNumericFormatterCache.set(formatter, isTemplate))), isTemplate) {
      return formatter.replace(bracketGReg, (match, key) => {
        if (!semicolonReg.test(key)) {
          const value2 = datum[key.trim()];
          return void 0 !== value2 ? value2 : match;
        }
        const parts = key.split(":"), value = datum[parts.shift()], valueFormatter = parts.join(":");
        return this._formatSingleText(value, valueFormatter);
      });
    }
    return this._formatSingleText(text2, formatter);
  }
  _formatSingleText(text2, formatter) {
    if (numberSpecifierReg.test(formatter) && this._numericFormatter) {
      let numericFormat;
      return this._numericFormatterCache && this._numericSpecifier ? (this._numericFormatterCache.get(formatter) ? numericFormat = this._numericFormatterCache.get(formatter) : (numericFormat = this._numericSpecifier(formatter), this._numericFormatterCache.set(formatter, numericFormat)), numericFormat(Number(text2))) : this._numericFormatter(formatter, Number(text2));
    }
    return formatter.includes("%") && this._timeFormatter ? this._timeFormatter(formatter, text2) : text2;
  }
  release() {
    super.release(), this._format = null, this._timeFormatter = null, this._numericFormatter = null, this._numericSpecifier = null, this._numericFormatterCache = null, this._isNumericFormatterCache = null;
  }
};
FormatterPlugin.pluginType = "chart", FormatterPlugin.specKey = "formatter", FormatterPlugin.type = "formatterPlugin";
var registerFormatPlugin = () => {
  registerChartPlugin(FormatterPlugin);
};

// node_modules/@visactor/vchart/esm/mark/image.js
var ImageMark = class _ImageMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _ImageMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      lineWidth: 0
    });
  }
};
ImageMark.type = "image";
var registerImageMark = () => {
  Factory2.registerMark(ImageMark.type, ImageMark), registerImageGraphic2();
};

// node_modules/@visactor/vchart/esm/mark/index.js
var registerAllMarks = () => {
  registerGroupMark(), registerLineMark(), registerSymbolMark(), registerRuleMark(), registerTextMark(), registerAreaMark(), registerRectMark(), registerPathMark(), registerArcMark(), registerPolygonMark(), registerImageMark(), registerRippleMark(), registerComponentMark(), registerArc3dMark(), registerRect3dMark(), registerPyramid3dMark();
};

// node_modules/@visactor/vchart/esm/vchart-all.js
VChart.useRegisters([registerLineChart, registerAreaChart, registerBarChart, registerScatterChart, registerPieChart, registerRoseChart, registerRadarChart, registerHistogramChart, registerMapChart, registerGaugeChart, registerWordCloudChart, registerWordCloudShapeChart, registerFunnelChart, registerWaterfallChart, registerBoxplotChart, registerCircularProgressChart, registerLinearProgressChart, registerRangeColumnChart, registerRangeAreaChart, registerSunburstChart, registerCirclePackingChart, registerTreemapChart, registerSankeyChart, registerHeatmapChart, registerSequenceChart, registerCorrelationChart, registerCommonChart, registerBar3dChart, registerPie3dChart, registerHistogram3dChart, registerFunnel3dChart, registerRangeColumn3dChart, registerWordCloud3dChart, registerWordCloudShape3dChart, registerCartesianLinearAxis, registerCartesianBandAxis, registerCartesianTimeAxis, registerCartesianLogAxis, registerCartesianSymlogAxis, registerPolarBandAxis, registerPolarLinearAxis, registerDiscreteLegend, registerContinuousLegend, registerTooltip, registerCartesianCrossHair, registerPolarCrossHair, registerDataZoom2, registerScrollBar, registerIndicator, registerGeoCoordinate, registerMarkLine, registerMarkArea, registerMarkPoint, registerPolarMarkLine, registerPolarMarkArea, registerPolarMarkPoint, registerGeoMarkPoint, registerTitle2, registerPlayer2, registerLabel2, registerTotalLabel, registerBrush, registerCustomMark, registerMapLabel, registerPoptip, registerGridLayout, registerLayout3d, registerAllMarks, registerDomTooltipHandler, registerCanvasTooltipHandler, registerFormatPlugin, registerElementActive, registerElementActiveByLegend, registerElementHighlightByLegend, registerElementHighlightByName, registerElementHighlightByGroup, registerElementHighlightByKey, registerAnimate2, registerReactAttributePlugin, registerHtmlAttributePlugin]);

// node_modules/@visactor/vchart/esm/chart/liquid/liquid-transformer.js
var LiquidChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["valueField", "maskShape", "reverse", "outlineMargin", "outlinePadding", "indicatorSmartInvert", "liquidBackground", "liquidOutline"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/liquid/liquid.js
var LiquidChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LiquidChartSpecTransformer, this.type = "liquid", this.seriesType = SeriesTypeEnum.liquid;
  }
};
LiquidChart.type = "liquid", LiquidChart.seriesType = SeriesTypeEnum.liquid, LiquidChart.transformerConstructor = LiquidChartSpecTransformer;
var registerLiquidChart = () => {
  registerLiquidSeries(), Factory2.registerChart(LiquidChart.type, LiquidChart);
};

// node_modules/@visactor/vchart/esm/chart/venn/venn-transformer.js
var VennChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["categoryField", "valueField", "circle", "overlap", "overlapLabel"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/venn/venn.js
var VennChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = VennChartSpecTransformer, this.type = "venn", this.seriesType = SeriesTypeEnum.venn;
  }
};
VennChart.type = "venn", VennChart.seriesType = SeriesTypeEnum.venn, VennChart.transformerConstructor = VennChartSpecTransformer;
var registerVennChart = () => {
  registerVennSeries(), Factory2.registerChart(VennChart.type, VennChart);
};

// node_modules/@visactor/vchart/esm/chart/mosaic/mosaic-transformer.js
var MosaicChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["barWidth", "barMaxWidth", "barMinWidth", "barGapInGroup", "barBackground", "barMinHeight", "stackCornerRadius", "bar"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
  _setDefaultXAxisSpec(spec) {
    return {
      orient: "bottom",
      type: "linear",
      label: {
        visible: false
      }
    };
  }
  _setDefaultYAxisSpec(spec) {
    return {
      orient: "left",
      type: "linear"
    };
  }
};

// node_modules/@visactor/vchart/esm/chart/mosaic/mosaic.js
var MosaicChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = MosaicChartSpecTransformer, this.type = "mosaic", this.seriesType = SeriesTypeEnum.mosaic, this.handleAfterStackRegion = (region, stackValueGroup) => {
      region.getSeries().forEach((s2) => {
        const stackData = s2.getStackData(), stackValue = s2.getStackValue(), stackValueField = s2.getStackValueField();
        stackData && stackValueField && (stackMosaicTotal(stackValueGroup[stackValue], stackValueField), stackMosaic(s2, stackValueGroup[stackValue]));
      });
    };
  }
  _beforeInit() {
    this._dataSet && registerDataSetInstanceTransform(this._dataSet, "stackSplit", stackSplit);
  }
  _initStack() {
    this._stack = new Stack(this, {
      afterStackRegion: this.handleAfterStackRegion
    }), this._stack.init();
  }
};
MosaicChart.type = "mosaic", MosaicChart.seriesType = SeriesTypeEnum.mosaic, MosaicChart.transformerConstructor = MosaicChartSpecTransformer;
var registerMosaicChart = () => {
  registerMosaicSeries(), Factory2.registerChart(MosaicChart.type, MosaicChart);
};

// node_modules/@visactor/vchart/esm/chart/pictogram/pictogram-transformer.js
var PictogramChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return type === SeriesTypeEnum.pictogram;
  }
  _getDefaultSeriesSpec(spec) {
    return super._getDefaultSeriesSpec(spec, ["type", "nameField", "valueField", "svg", "pictogram", "defaultFillColor"]);
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.region.forEach((r) => {
      r.coordinate = "geo";
    }), super.transformSeriesSpec(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/pictogram/pictogram.js
var PictogramChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = PictogramChartSpecTransformer, this.type = "pictogram", this.seriesType = SeriesTypeEnum.pictogram;
  }
};
PictogramChart.type = "pictogram", PictogramChart.seriesType = SeriesTypeEnum.pictogram, PictogramChart.transformerConstructor = PictogramChartSpecTransformer;
var registerPictogramChart = () => {
  registerPictogramSeries(), Factory2.registerChart(PictogramChart.type, PictogramChart);
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/query.js
var checkMediaQuery = (query, mediaInfo, globalInstance) => {
  for (const conditionKey in query) switch (conditionKey) {
    case "maxHeight":
      if (isValid_default(query.maxHeight) && mediaInfo.height > query.maxHeight) return false;
      break;
    case "minHeight":
      if (isValid_default(query.minHeight) && mediaInfo.height < query.minHeight) return false;
      break;
    case "maxWidth":
      if (isValid_default(query.maxWidth) && mediaInfo.width > query.maxWidth) return false;
      break;
    case "minWidth":
      if (isValid_default(query.minWidth) && mediaInfo.width < query.minWidth) return false;
      break;
    case "onResize":
      if (isValid_default(query.onResize) && !query.onResize(mediaInfo, globalInstance)) return false;
  }
  return true;
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/filter.js
var executeMediaQueryActionFilter = (filterType = "chart", filter2, action, query, chartSpec, chartSpecInfo) => {
  const result2 = executeMediaQueryActionFilterType(filterType, chartSpec, chartSpecInfo);
  return Object.assign(Object.assign({}, result2), {
    modelInfo: result2.modelInfo.filter((info) => !!isNil_default(filter2) || array(filter2).some((f) => isFunction_default(f) ? f(info, action, query) : includeSpec(info.spec, f)))
  });
};
var executeMediaQueryActionFilterType = (filterType = "chart", chartSpec, chartSpecInfo) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const result2 = {
    modelInfo: []
  };
  if ("chart" === filterType) result2.isChart = true, result2.modelInfo.push({
    spec: chartSpec,
    type: "chart"
  });
  else if ("region" === filterType) result2.modelType = "region", result2.specKey = "region", null === (_a = chartSpec.region) || void 0 === _a || _a.forEach((regionSpec, i) => {
    result2.modelInfo.push({
      spec: regionSpec,
      specPath: ["region", i],
      type: "region"
    });
  });
  else if ("series" === filterType) result2.modelType = "series", result2.specKey = "series", null === (_b = chartSpec.series) || void 0 === _b || _b.forEach((seriesSpec, i) => {
    result2.modelInfo.push({
      spec: seriesSpec,
      specPath: ["series", i],
      type: seriesSpec.type
    });
  });
  else if (Object.values(SeriesTypeEnum).includes(filterType)) result2.modelType = "series", result2.specKey = "series", result2.type = filterType, null === (_c = chartSpec.series) || void 0 === _c || _c.forEach((seriesSpec, i) => {
    seriesSpec.type === filterType && result2.modelInfo.push({
      spec: seriesSpec,
      specPath: ["series", i],
      type: filterType
    });
  });
  else if (Object.values(ComponentTypeEnum).includes(filterType)) {
    result2.modelType = "component", result2.type = filterType, result2.specKey = null === (_d = Factory2.getComponentInKey(filterType)) || void 0 === _d ? void 0 : _d.specKey;
    const { specKey } = result2, infoList = array(null !== (_f = null === (_e = chartSpecInfo.component) || void 0 === _e ? void 0 : _e[specKey]) && void 0 !== _f ? _f : []);
    null === (_h = array(null !== (_g = chartSpec[specKey]) && void 0 !== _g ? _g : [])) || void 0 === _h || _h.forEach((componentSpec, i) => {
      const specInfo = infoList[i];
      specInfo && specInfo.type === filterType ? result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
        spec: componentSpec
      })) : componentSpec && false === componentSpec.visible && result2.modelInfo.push({
        type: filterType,
        spec: componentSpec
      });
    });
  } else {
    const componentTypes = Factory2.getComponents().filter(({ cmp }) => cmp.specKey === filterType).map(({ cmp }) => cmp.type);
    if (componentTypes.length > 0) {
      result2.modelType = "component";
      const specKey = filterType;
      result2.specKey = specKey;
      const infoList = array(null !== (_k = null === (_j = chartSpecInfo.component) || void 0 === _j ? void 0 : _j[specKey]) && void 0 !== _k ? _k : []);
      array(null !== (_l = chartSpec[specKey]) && void 0 !== _l ? _l : []).forEach((componentSpec, i) => {
        const specInfo = infoList[i];
        specInfo && componentTypes.includes(specInfo.type) && result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
          spec: componentSpec
        }));
      });
    }
  }
  return result2;
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/action.js
var executeMediaQueryAction = (action, query, chartSpec, chartSpecInfo) => {
  const { spec, filter: filter2, filterType, forceAppend } = action, { isChart, modelType, specKey, type, modelInfo } = executeMediaQueryActionFilter(filterType, filter2, action, query, chartSpec, chartSpecInfo);
  if (0 === modelInfo.length && !forceAppend) return {
    chartSpec,
    hasChanged: false
  };
  const targetSpec = mergeSpec({}, chartSpec), newSpec = isFunction_default(spec) ? spec(modelInfo, action, query) : spec;
  for (const { spec: spec2, specPath } of modelInfo) {
    if (isChart) return {
      chartSpec: mergeSpec(targetSpec, newSpec),
      hasChanged: true
    };
    const modelSpec = mergeSpec({}, spec2, newSpec);
    setProperty(targetSpec, specPath, modelSpec);
  }
  if (0 === modelInfo.length && forceAppend) {
    const newSpecToAppend = Object.assign({
      type
    }, newSpec);
    isArray_default(targetSpec[specKey]) ? targetSpec[specKey].push(newSpecToAppend) : isNil_default(targetSpec[specKey]) ? targetSpec[specKey] = "component" === modelType ? newSpecToAppend : [newSpecToAppend] : targetSpec[specKey] = [targetSpec[specKey], newSpecToAppend];
  }
  return {
    chartSpec: targetSpec,
    hasChanged: true
  };
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/media-query.js
var MediaQuery = class _MediaQuery extends BasePlugin {
  constructor() {
    super(_MediaQuery.type), this.type = "MediaQueryPlugin", this._currentMediaInfo = {}, this.currentActiveItems = /* @__PURE__ */ new Set(), this._initialized = false;
  }
  onInit(service, chartSpec) {
    if (!(null == chartSpec ? void 0 : chartSpec[_MediaQuery.specKey])) return;
    const { globalInstance } = service;
    this._option = {
      globalInstance: service.globalInstance,
      updateSpec: (spec, compile, render) => {
        render ? globalInstance.updateSpecSync(spec) : compile ? globalInstance.updateSpecAndRecompile(spec, false, {
          transformSpec: true
        }) : globalInstance.setRuntimeSpec(spec);
      }
    }, this._spec = chartSpec[_MediaQuery.specKey], this._initialized = true;
  }
  onBeforeResize(service, width, height) {
    this._initialized && this._changeSize(width, height, true, false);
  }
  onAfterChartSpecTransform(service, chartSpec, actionSource) {
    this._initialized && "setCurrentTheme" === actionSource && this._reInit(false, false);
  }
  onAfterModelSpecTransform(service, chartSpec, chartInfo, actionSource) {
    this._initialized && "updateSpec" === actionSource && this.onBeforeInitChart(service, chartSpec, "setCurrentTheme");
  }
  onBeforeInitChart(service, chartSpec, actionSource) {
    if (!this._initialized) return;
    let resetMediaQuery, checkMediaQuery2;
    switch (actionSource) {
      case "render":
      case "updateModelSpec":
        resetMediaQuery = false, checkMediaQuery2 = true;
        break;
      case "setCurrentTheme":
        resetMediaQuery = true, checkMediaQuery2 = false;
        break;
      case "updateSpecAndRecompile":
        resetMediaQuery = false, checkMediaQuery2 = false;
    }
    if (resetMediaQuery && this.release(), this._initialized || this.onInit(service, chartSpec), resetMediaQuery || checkMediaQuery2) {
      const { width, height } = this._option.globalInstance.getCurrentSize();
      this._changeSize(width, height, false, false);
    }
  }
  _changeSize(width, height, compile, render) {
    return (this._currentMediaInfo.width !== width || this._currentMediaInfo.height !== height) && (this._currentMediaInfo.width = width, this._currentMediaInfo.height = height, this._applyQueries(compile, render));
  }
  _applyQueries(compile, render) {
    const changeToActive = [], changeToInactive = [];
    if (this._spec.forEach((item) => {
      const { hasChanged: hasChanged2, isActive } = this._check(item);
      hasChanged2 && (isActive ? changeToActive.push(item) : changeToInactive.push(item));
    }), !changeToActive.length && !changeToInactive.length) return false;
    let chartSpec, chartSpecInfo;
    this._baseChartSpec || (this._baseChartSpec = cloneDeepSpec(this._option.globalInstance.getSpec(), ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo());
    let hasChanged = false;
    return changeToInactive.length > 0 ? (chartSpec = cloneDeepSpec(this._baseChartSpec, ["data", _MediaQuery.specKey]), chartSpecInfo = this._baseChartSpecInfo, Array.from(this.currentActiveItems).forEach((item) => {
      if (changeToInactive.includes(item)) return void this.currentActiveItems.delete(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec;
    }), hasChanged = true) : (chartSpec = this._option.globalInstance.getSpec(), chartSpecInfo = this._option.globalInstance.getSpecInfo()), changeToActive.forEach((item) => {
      this.currentActiveItems.add(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render), true;
  }
  _check(item) {
    const { globalInstance } = this._option, isActive = checkMediaQuery(item.query, this._currentMediaInfo, globalInstance);
    return {
      isActive,
      hasChanged: isActive !== this.currentActiveItems.has(item)
    };
  }
  _apply(item, chartSpec, chartSpecInfo) {
    const { query, action } = item;
    let hasChanged = false;
    return array(action).forEach((actionItem) => {
      const result2 = executeMediaQueryAction(actionItem, query, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), {
      chartSpec,
      hasChanged
    };
  }
  _reInit(compile, render) {
    let chartSpec = this._option.globalInstance.getSpec();
    this._baseChartSpec = cloneDeepSpec(chartSpec, ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo();
    let hasChanged = false;
    this.currentActiveItems.forEach((item) => {
      const result2 = this._apply(item, chartSpec, this._baseChartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render);
  }
  release() {
    super.release(), this._initialized = false, this._spec = [], this._option = void 0, this._currentMediaInfo = {}, this.currentActiveItems.clear();
  }
};
MediaQuery.pluginType = "chart", MediaQuery.specKey = "media", MediaQuery.type = "MediaQueryPlugin";
var registerMediaQuery = () => {
  registerChartPlugin(MediaQuery);
};

// node_modules/@visactor/vchart/esm/index.js
var esm_default = VChart;
export {
  Arc3dMark,
  ArcMark,
  AreaChart,
  AreaMark,
  AreaSeries,
  AxisSyncPlugin,
  Bar3dChart,
  Bar3dSeries,
  BarChart,
  BarSeries,
  BaseChart,
  BaseChartSpecTransformer,
  BaseMark,
  BaseSeries,
  BoxPlotChart,
  BoxPlotSeries,
  Brush2 as Brush,
  CanvasTooltipHandler,
  CartesianAxis,
  CartesianBandAxis,
  CartesianChartSpecTransformer,
  CartesianCrossHair,
  CartesianLinearAxis,
  CartesianLogAxis,
  CartesianMarkArea,
  CartesianMarkLine,
  CartesianMarkPoint,
  CartesianSeries,
  CartesianSymlogAxis,
  CartesianTimeAxis,
  CirclePackingChart,
  CirclePackingSeries,
  CircularProgressChart,
  CircularProgressSeries,
  CommonChart,
  CommonChartSpecTransformer,
  ComponentMark,
  ComposedEventMapper,
  ContinuousLegend,
  CorrelationChart,
  CorrelationSeries,
  CustomMark,
  DEFAULT_CHART_HEIGHT,
  DEFAULT_CHART_WIDTH,
  DEFAULT_DATA_INDEX,
  DEFAULT_DATA_KEY,
  DEFAULT_DATA_SERIES_FIELD,
  DEFAULT_MEASURE_CANVAS_ID,
  DEFAULT_SERIES_STYLE_NAME,
  DataZoom2 as DataZoom,
  DimensionClickEvent,
  DimensionEventEnum,
  DimensionHoverEvent,
  DiscreteLegend2 as DiscreteLegend,
  DomTooltipHandler,
  DotSeries,
  Event2 as Event,
  Factory2 as Factory,
  FormatterPlugin,
  Funnel3dChart,
  Funnel3dSeries,
  FunnelChart,
  FunnelSeries,
  GaugeChart,
  GaugePointerSeries,
  GaugeSeries,
  GeoCoordinate,
  GeoMarkPoint,
  GridLayout2 as GridLayout,
  GroupMark2 as GroupMark,
  HeatmapChart,
  HeatmapSeries,
  Histogram3dChart,
  HistogramChart,
  ImageMark,
  Indicator2 as Indicator,
  Label2 as Label,
  Layout,
  Layout3d,
  LineChart,
  LineMark,
  LineSeries,
  LinearProgressChart,
  LinearProgressSeries,
  LinkSeries,
  LiquidChart,
  LiquidSeries,
  MOSAIC_CAT_END_PERCENT,
  MOSAIC_CAT_START_PERCENT,
  MOSAIC_VALUE_END_PERCENT,
  MOSAIC_VALUE_START_PERCENT,
  MapChart,
  MapLabelComponent,
  MapSeries,
  MediaQuery,
  MosaicChart,
  MosaicSeries,
  PREFIX,
  PathMark,
  PictogramChart,
  PictogramSeries,
  Pie3dChart,
  Pie3dSeries,
  PieChart,
  PieSeries,
  Player2 as Player,
  PolarAxis,
  PolarBandAxis,
  PolarCrossHair,
  PolarLinearAxis,
  PolarMarkArea,
  PolarMarkLine,
  PolarMarkPoint,
  PolarSeries,
  PolygonMark,
  ProgressLikeSeries,
  Pyramid3dMark,
  RadarChart,
  RadarSeries,
  RangeAreaChart,
  RangeAreaSeries,
  RangeColumn3dChart,
  RangeColumn3dSeries,
  RangeColumnChart,
  RangeColumnSeries,
  Rect3dMark,
  RectMark,
  RenderModeEnum,
  RippleMark,
  RoseChart,
  RoseLikeSeries,
  RoseSeries,
  RuleMark,
  SEGMENT_FIELD_END,
  SEGMENT_FIELD_START,
  STACK_FIELD_END,
  STACK_FIELD_END_OffsetSilhouette,
  STACK_FIELD_END_PERCENT,
  STACK_FIELD_KEY,
  STACK_FIELD_START,
  STACK_FIELD_START_OffsetSilhouette,
  STACK_FIELD_START_PERCENT,
  STACK_FIELD_TOTAL,
  STACK_FIELD_TOTAL_BOTTOM,
  STACK_FIELD_TOTAL_PERCENT,
  STACK_FIELD_TOTAL_TOP,
  SankeyChart,
  SankeySeries,
  ScatterChart,
  ScatterSeries,
  ScrollBar2 as ScrollBar,
  SequenceChart,
  SeriesMarkNameEnum,
  SeriesTypeEnum,
  SeriesTypeForThemeEnum,
  SunburstChart,
  SunburstSeries,
  SymbolMark,
  TextMark,
  ThemeManager,
  Title3 as Title,
  Tooltip3 as Tooltip,
  TooltipResult,
  TotalLabel,
  TreemapChart,
  TreemapSeries,
  VChart,
  VennChart,
  VennSeries,
  WaterfallChart,
  WaterfallSeries,
  WordCloud3dChart,
  WordCloud3dSeries,
  WordCloudChart,
  WordCloudSeries,
  alternatingWave,
  builtinThemes,
  centerToCorner,
  columnCenterToEdge,
  columnEdgeToCenter,
  columnLeftToRight,
  columnRightToLeft,
  computeActualDataScheme,
  cornerToCenter,
  createArc,
  createArea,
  createGroup,
  createLine,
  createRect,
  createRichText,
  createSymbol,
  createText,
  darkTheme,
  dataScheme,
  esm_default as default,
  defaultThemeName,
  diagonalCenterToEdge,
  diagonalTopLeftToBottomRight,
  functionTransform,
  getActualColor,
  getCartesianDimensionInfo,
  getColorSchemeBySeries,
  getDataScheme,
  getFieldAlias,
  getMergedTheme,
  getPolarDimensionInfo,
  getRegionStackGroup,
  getTheme2 as getTheme,
  hasThemeMerged,
  isColorKey,
  isProgressiveDataColorScheme,
  isTokenKey,
  lightTheme,
  mergeFields,
  particleEffect,
  pulseWave,
  queryColorFromColorScheme,
  queryToken,
  randomOpacity,
  register3DPlugin,
  registerAllEnv,
  registerAllMarks,
  registerAnimate2 as registerAnimate,
  registerArc3dMark,
  registerArcMark,
  registerAreaChart,
  registerAreaMark,
  registerAreaSeries,
  registerBar3dChart,
  registerBar3dSeries,
  registerBarChart,
  registerBarSeries,
  registerBoxplotChart,
  registerBoxplotSeries,
  registerBrowserEnv,
  registerBrush,
  registerCanvasTooltipHandler,
  registerCartesianBandAxis,
  registerCartesianCrossHair,
  registerCartesianLinearAxis,
  registerCartesianLogAxis,
  registerCartesianSymlogAxis,
  registerCartesianTimeAxis,
  registerChartPlugin,
  registerCirclePackingChart,
  registerCirclePackingSeries,
  registerCircularProgressChart,
  registerCircularProgressSeries,
  registerCommonChart,
  registerComponentMark,
  registerContinuousLegend,
  registerCorrelationChart,
  registerCustomMark,
  registerDataZoom2 as registerDataZoom,
  registerDiscreteLegend,
  registerDomTooltipHandler,
  registerDotSeries,
  registerDragPlugin,
  registerFormatPlugin,
  registerFunnel3dChart,
  registerFunnel3dSeries,
  registerFunnelChart,
  registerFunnelSeries,
  registerGaugeChart,
  registerGaugePointerSeries,
  registerGaugeSeries,
  registerGeoCoordinate,
  registerGeoMarkPoint,
  registerGesturePlugin,
  registerGridLayout,
  registerGroupMark,
  registerHarmonyEnv,
  registerHeatmapChart,
  registerHeatmapSeries,
  registerHistogram3dChart,
  registerHistogramChart,
  registerHtmlAttributePlugin,
  registerImageMark,
  registerIndicator,
  registerLabel2 as registerLabel,
  registerLarkEnv,
  registerLayout3d,
  registerLineChart,
  registerLineMark,
  registerLineSeries,
  registerLinearProgressChart,
  registerLinearProgressSeries,
  registerLinkSeries,
  registerLiquidChart,
  registerLiquidSeries,
  registerLynxEnv,
  registerMapChart,
  registerMapLabel,
  registerMapSeries,
  registerMarkArea,
  registerMarkLine,
  registerMarkPoint,
  registerMediaQuery,
  registerMorph,
  registerMosaicChart,
  registerMosaicSeries,
  registerNodeEnv,
  registerPathMark,
  registerPictogramChart,
  registerPictogramSeries,
  registerPie3dChart,
  registerPie3dSeries,
  registerPieChart,
  registerPieSeries,
  registerPlayer2 as registerPlayer,
  registerPolarBandAxis,
  registerPolarCrossHair,
  registerPolarLinearAxis,
  registerPolarMarkArea,
  registerPolarMarkLine,
  registerPolarMarkPoint,
  registerPolygonMark,
  registerPoptip,
  registerPyramid3dMark,
  registerRadarChart,
  registerRadarSeries,
  registerRangeAreaChart,
  registerRangeAreaSeries,
  registerRangeColumn3dChart,
  registerRangeColumn3dSeries,
  registerRangeColumnChart,
  registerRangeColumnSeries,
  registerReactAttributePlugin,
  registerRect3dMark,
  registerRectMark,
  registerRippleMark,
  registerRoseChart,
  registerRoseSeries,
  registerRuleMark,
  registerSankeyChart,
  registerSankeySeries,
  registerScatterChart,
  registerScatterSeries,
  registerScrollBar,
  registerSequenceChart,
  registerSunBurstSeries,
  registerSunburstChart,
  registerSymbolMark,
  registerTTEnv,
  registerTaroEnv,
  registerTextMark,
  registerTheme,
  registerTitle2 as registerTitle,
  registerTooltip,
  registerTotalLabel,
  registerTreemapChart,
  registerTreemapSeries,
  registerVennChart,
  registerVennSeries,
  registerWXEnv,
  registerWaterfallChart,
  registerWaterfallSeries,
  registerWordCloud3dChart,
  registerWordCloud3dSeries,
  registerWordCloudChart,
  registerWordCloudSeries,
  registerWordCloudShapeChart,
  removeTheme,
  rippleEffect,
  rotationScan,
  rowBottomToTop,
  rowCenterToEdge,
  rowEdgeToCenter,
  rowTopToBottom,
  snakeWave,
  sortStackValueGroup,
  specTransform,
  spiralEffect,
  stack,
  stackGroup,
  stackMosaic,
  stackMosaicTotal,
  stackOffsetSilhouette,
  stackTotal,
  themeExist,
  themes,
  token,
  transformColorSchemeToStandardStruct,
  version,
  vglobal
};
//# sourceMappingURL=@visactor_vchart.js.map
