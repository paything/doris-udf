import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has2.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j2;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/js-binary-schema-parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/js-binary-schema-parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.loop = exports2.conditional = exports2.parse = void 0;
    var parse = function parse2(stream, schema) {
      var result = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parent2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : result;
      if (Array.isArray(schema)) {
        schema.forEach(function(partSchema) {
          return parse2(stream, partSchema, result, parent2);
        });
      } else if (typeof schema === "function") {
        schema(stream, result, parent2, parse2);
      } else {
        var key2 = Object.keys(schema)[0];
        if (Array.isArray(schema[key2])) {
          parent2[key2] = {};
          parse2(stream, schema[key2], result, parent2[key2]);
        } else {
          parent2[key2] = schema[key2](stream, result, parent2, parse2);
        }
      }
      return result;
    };
    exports2.parse = parse;
    var conditional = function conditional2(schema, conditionFunc) {
      return function(stream, result, parent2, parse2) {
        if (conditionFunc(stream, result, parent2)) {
          parse2(stream, schema, result, parent2);
        }
      };
    };
    exports2.conditional = conditional;
    var loop = function loop2(schema, continueFunc) {
      return function(stream, result, parent2, parse2) {
        var arr = [];
        var lastStreamPos = stream.pos;
        while (continueFunc(stream, result, parent2)) {
          var newParent = {};
          parse2(stream, schema, result, newParent);
          if (stream.pos === lastStreamPos) {
            break;
          }
          lastStreamPos = stream.pos;
          arr.push(newParent);
        }
        return arr;
      };
    };
    exports2.loop = loop;
  }
});

// node_modules/js-binary-schema-parser/lib/parsers/uint8.js
var require_uint8 = __commonJS({
  "node_modules/js-binary-schema-parser/lib/parsers/uint8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readBits = exports2.readArray = exports2.readUnsigned = exports2.readString = exports2.peekBytes = exports2.readBytes = exports2.peekByte = exports2.readByte = exports2.buildStream = void 0;
    var buildStream = function buildStream2(uint8Data) {
      return {
        data: uint8Data,
        pos: 0
      };
    };
    exports2.buildStream = buildStream;
    var readByte = function readByte2() {
      return function(stream) {
        return stream.data[stream.pos++];
      };
    };
    exports2.readByte = readByte;
    var peekByte = function peekByte2() {
      var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return function(stream) {
        return stream.data[stream.pos + offset];
      };
    };
    exports2.peekByte = peekByte;
    var readBytes = function readBytes2(length2) {
      return function(stream) {
        return stream.data.subarray(stream.pos, stream.pos += length2);
      };
    };
    exports2.readBytes = readBytes;
    var peekBytes = function peekBytes2(length2) {
      return function(stream) {
        return stream.data.subarray(stream.pos, stream.pos + length2);
      };
    };
    exports2.peekBytes = peekBytes;
    var readString = function readString2(length2) {
      return function(stream) {
        return Array.from(readBytes(length2)(stream)).map(function(value2) {
          return String.fromCharCode(value2);
        }).join("");
      };
    };
    exports2.readString = readString;
    var readUnsigned = function readUnsigned2(littleEndian) {
      return function(stream) {
        var bytes = readBytes(2)(stream);
        return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];
      };
    };
    exports2.readUnsigned = readUnsigned;
    var readArray = function readArray2(byteSize, totalOrFunc) {
      return function(stream, result, parent2) {
        var total = typeof totalOrFunc === "function" ? totalOrFunc(stream, result, parent2) : totalOrFunc;
        var parser = readBytes(byteSize);
        var arr = new Array(total);
        for (var i2 = 0; i2 < total; i2++) {
          arr[i2] = parser(stream);
        }
        return arr;
      };
    };
    exports2.readArray = readArray;
    var subBitsTotal = function subBitsTotal2(bits, startIndex, length2) {
      var result = 0;
      for (var i2 = 0; i2 < length2; i2++) {
        result += bits[startIndex + i2] && Math.pow(2, length2 - i2 - 1);
      }
      return result;
    };
    var readBits = function readBits2(schema) {
      return function(stream) {
        var _byte = readByte()(stream);
        var bits = new Array(8);
        for (var i2 = 0; i2 < 8; i2++) {
          bits[7 - i2] = !!(_byte & 1 << i2);
        }
        return Object.keys(schema).reduce(function(res, key2) {
          var def = schema[key2];
          if (def.length) {
            res[key2] = subBitsTotal(bits, def.index, def.length);
          } else {
            res[key2] = bits[def.index];
          }
          return res;
        }, {});
      };
    };
    exports2.readBits = readBits;
  }
});

// node_modules/js-binary-schema-parser/lib/schemas/gif.js
var require_gif = __commonJS({
  "node_modules/js-binary-schema-parser/lib/schemas/gif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _2 = require_lib();
    var _uint = require_uint8();
    var subBlocksSchema = {
      blocks: function blocks(stream) {
        var terminator = 0;
        var chunks = [];
        var streamSize = stream.data.length;
        var total = 0;
        for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {
          if (!size) break;
          if (stream.pos + size >= streamSize) {
            var availableSize = streamSize - stream.pos;
            chunks.push((0, _uint.readBytes)(availableSize)(stream));
            total += availableSize;
            break;
          }
          chunks.push((0, _uint.readBytes)(size)(stream));
          total += size;
        }
        var result = new Uint8Array(total);
        var offset = 0;
        for (var i2 = 0; i2 < chunks.length; i2++) {
          result.set(chunks[i2], offset);
          offset += chunks[i2].length;
        }
        return result;
      }
    };
    var gceSchema = (0, _2.conditional)({
      gce: [{
        codes: (0, _uint.readBytes)(2)
      }, {
        byteSize: (0, _uint.readByte)()
      }, {
        extras: (0, _uint.readBits)({
          future: {
            index: 0,
            length: 3
          },
          disposal: {
            index: 3,
            length: 3
          },
          userInput: {
            index: 6
          },
          transparentColorGiven: {
            index: 7
          }
        })
      }, {
        delay: (0, _uint.readUnsigned)(true)
      }, {
        transparentColorIndex: (0, _uint.readByte)()
      }, {
        terminator: (0, _uint.readByte)()
      }]
    }, function(stream) {
      var codes = (0, _uint.peekBytes)(2)(stream);
      return codes[0] === 33 && codes[1] === 249;
    });
    var imageSchema = (0, _2.conditional)({
      image: [{
        code: (0, _uint.readByte)()
      }, {
        descriptor: [{
          left: (0, _uint.readUnsigned)(true)
        }, {
          top: (0, _uint.readUnsigned)(true)
        }, {
          width: (0, _uint.readUnsigned)(true)
        }, {
          height: (0, _uint.readUnsigned)(true)
        }, {
          lct: (0, _uint.readBits)({
            exists: {
              index: 0
            },
            interlaced: {
              index: 1
            },
            sort: {
              index: 2
            },
            future: {
              index: 3,
              length: 2
            },
            size: {
              index: 5,
              length: 3
            }
          })
        }]
      }, (0, _2.conditional)({
        lct: (0, _uint.readArray)(3, function(stream, result, parent2) {
          return Math.pow(2, parent2.descriptor.lct.size + 1);
        })
      }, function(stream, result, parent2) {
        return parent2.descriptor.lct.exists;
      }), {
        data: [{
          minCodeSize: (0, _uint.readByte)()
        }, subBlocksSchema]
      }]
    }, function(stream) {
      return (0, _uint.peekByte)()(stream) === 44;
    });
    var textSchema = (0, _2.conditional)({
      text: [{
        codes: (0, _uint.readBytes)(2)
      }, {
        blockSize: (0, _uint.readByte)()
      }, {
        preData: function preData(stream, result, parent2) {
          return (0, _uint.readBytes)(parent2.text.blockSize)(stream);
        }
      }, subBlocksSchema]
    }, function(stream) {
      var codes = (0, _uint.peekBytes)(2)(stream);
      return codes[0] === 33 && codes[1] === 1;
    });
    var applicationSchema = (0, _2.conditional)({
      application: [{
        codes: (0, _uint.readBytes)(2)
      }, {
        blockSize: (0, _uint.readByte)()
      }, {
        id: function id(stream, result, parent2) {
          return (0, _uint.readString)(parent2.blockSize)(stream);
        }
      }, subBlocksSchema]
    }, function(stream) {
      var codes = (0, _uint.peekBytes)(2)(stream);
      return codes[0] === 33 && codes[1] === 255;
    });
    var commentSchema = (0, _2.conditional)({
      comment: [{
        codes: (0, _uint.readBytes)(2)
      }, subBlocksSchema]
    }, function(stream) {
      var codes = (0, _uint.peekBytes)(2)(stream);
      return codes[0] === 33 && codes[1] === 254;
    });
    var schema = [
      {
        header: [{
          signature: (0, _uint.readString)(3)
        }, {
          version: (0, _uint.readString)(3)
        }]
      },
      {
        lsd: [{
          width: (0, _uint.readUnsigned)(true)
        }, {
          height: (0, _uint.readUnsigned)(true)
        }, {
          gct: (0, _uint.readBits)({
            exists: {
              index: 0
            },
            resolution: {
              index: 1,
              length: 3
            },
            sort: {
              index: 4
            },
            size: {
              index: 5,
              length: 3
            }
          })
        }, {
          backgroundColorIndex: (0, _uint.readByte)()
        }, {
          pixelAspectRatio: (0, _uint.readByte)()
        }]
      },
      (0, _2.conditional)({
        gct: (0, _uint.readArray)(3, function(stream, result) {
          return Math.pow(2, result.lsd.gct.size + 1);
        })
      }, function(stream, result) {
        return result.lsd.gct.exists;
      }),
      // content frames
      {
        frames: (0, _2.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function(stream) {
          var nextCode = (0, _uint.peekByte)()(stream);
          return nextCode === 33 || nextCode === 44;
        })
      }
    ];
    var _default = schema;
    exports2["default"] = _default;
  }
});

// node_modules/gifuct-js/lib/deinterlace.js
var require_deinterlace = __commonJS({
  "node_modules/gifuct-js/lib/deinterlace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deinterlace = void 0;
    var deinterlace = function deinterlace2(pixels, width2) {
      var newPixels = new Array(pixels.length);
      var rows = pixels.length / width2;
      var cpRow = function cpRow2(toRow2, fromRow2) {
        var fromPixels = pixels.slice(fromRow2 * width2, (fromRow2 + 1) * width2);
        newPixels.splice.apply(newPixels, [toRow2 * width2, width2].concat(fromPixels));
      };
      var offsets = [0, 4, 2, 1];
      var steps = [8, 8, 4, 2];
      var fromRow = 0;
      for (var pass = 0; pass < 4; pass++) {
        for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
          cpRow(toRow, fromRow);
          fromRow++;
        }
      }
      return newPixels;
    };
    exports2.deinterlace = deinterlace;
  }
});

// node_modules/gifuct-js/lib/lzw.js
var require_lzw = __commonJS({
  "node_modules/gifuct-js/lib/lzw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lzw = void 0;
    var lzw = function lzw2(minCodeSize, data2, pixelCount) {
      var MAX_STACK_SIZE = 4096;
      var nullCode = -1;
      var npix = pixelCount;
      var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i2, datum, data_size, first, top, bi, pi4;
      var dstPixels = new Array(pixelCount);
      var prefix = new Array(MAX_STACK_SIZE);
      var suffix = new Array(MAX_STACK_SIZE);
      var pixelStack = new Array(MAX_STACK_SIZE + 1);
      data_size = minCodeSize;
      clear = 1 << data_size;
      end_of_information = clear + 1;
      available = clear + 2;
      old_code = nullCode;
      code_size = data_size + 1;
      code_mask = (1 << code_size) - 1;
      for (code = 0; code < clear; code++) {
        prefix[code] = 0;
        suffix[code] = code;
      }
      var datum, bits, count2, first, top, pi4, bi;
      datum = bits = count2 = first = top = pi4 = bi = 0;
      for (i2 = 0; i2 < npix; ) {
        if (top === 0) {
          if (bits < code_size) {
            datum += data2[bi] << bits;
            bits += 8;
            bi++;
            continue;
          }
          code = datum & code_mask;
          datum >>= code_size;
          bits -= code_size;
          if (code > available || code == end_of_information) {
            break;
          }
          if (code == clear) {
            code_size = data_size + 1;
            code_mask = (1 << code_size) - 1;
            available = clear + 2;
            old_code = nullCode;
            continue;
          }
          if (old_code == nullCode) {
            pixelStack[top++] = suffix[code];
            old_code = code;
            first = code;
            continue;
          }
          in_code = code;
          if (code == available) {
            pixelStack[top++] = first;
            code = old_code;
          }
          while (code > clear) {
            pixelStack[top++] = suffix[code];
            code = prefix[code];
          }
          first = suffix[code] & 255;
          pixelStack[top++] = first;
          if (available < MAX_STACK_SIZE) {
            prefix[available] = old_code;
            suffix[available] = first;
            available++;
            if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
              code_size++;
              code_mask += available;
            }
          }
          old_code = in_code;
        }
        top--;
        dstPixels[pi4++] = pixelStack[top];
        i2++;
      }
      for (i2 = pi4; i2 < npix; i2++) {
        dstPixels[i2] = 0;
      }
      return dstPixels;
    };
    exports2.lzw = lzw;
  }
});

// node_modules/gifuct-js/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/gifuct-js/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.decompressFrames = exports2.decompressFrame = exports2.parseGIF = void 0;
    var _gif = _interopRequireDefault(require_gif());
    var _jsBinarySchemaParser = require_lib();
    var _uint = require_uint8();
    var _deinterlace = require_deinterlace();
    var _lzw = require_lzw();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parseGIF = function parseGIF2(arrayBuffer) {
      var byteData = new Uint8Array(arrayBuffer);
      return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif["default"]);
    };
    exports2.parseGIF = parseGIF;
    var generatePatch = function generatePatch2(image) {
      var totalPixels = image.pixels.length;
      var patchData = new Uint8ClampedArray(totalPixels * 4);
      for (var i2 = 0; i2 < totalPixels; i2++) {
        var pos = i2 * 4;
        var colorIndex = image.pixels[i2];
        var color = image.colorTable[colorIndex] || [0, 0, 0];
        patchData[pos] = color[0];
        patchData[pos + 1] = color[1];
        patchData[pos + 2] = color[2];
        patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
      }
      return patchData;
    };
    var decompressFrame = function decompressFrame2(frame, gct, buildImagePatch) {
      if (!frame.image) {
        console.warn("gif frame does not have associated image.");
        return;
      }
      var image = frame.image;
      var totalPixels = image.descriptor.width * image.descriptor.height;
      var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels);
      if (image.descriptor.lct.interlaced) {
        pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);
      }
      var resultImage = {
        pixels,
        dims: {
          top: frame.image.descriptor.top,
          left: frame.image.descriptor.left,
          width: frame.image.descriptor.width,
          height: frame.image.descriptor.height
        }
      };
      if (image.descriptor.lct && image.descriptor.lct.exists) {
        resultImage.colorTable = image.lct;
      } else {
        resultImage.colorTable = gct;
      }
      if (frame.gce) {
        resultImage.delay = (frame.gce.delay || 10) * 10;
        resultImage.disposalType = frame.gce.extras.disposal;
        if (frame.gce.extras.transparentColorGiven) {
          resultImage.transparentIndex = frame.gce.transparentColorIndex;
        }
      }
      if (buildImagePatch) {
        resultImage.patch = generatePatch(resultImage);
      }
      return resultImage;
    };
    exports2.decompressFrame = decompressFrame;
    var decompressFrames = function decompressFrames2(parsedGif, buildImagePatches) {
      return parsedGif.frames.filter(function(f2) {
        return f2.image;
      }).map(function(f2) {
        return decompressFrame(f2, parsedGif.gct, buildImagePatches);
      });
    };
    exports2.decompressFrames = decompressFrames;
  }
});

// node_modules/lottie-web/build/player/lottie.js
var require_lottie = __commonJS({
  "node_modules/lottie-web/build/player/lottie.js"(exports, module) {
    typeof navigator !== "undefined" && function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.lottie = factory());
    }(exports, function() {
      "use strict";
      var svgNS = "http://www.w3.org/2000/svg";
      var locationHref = "";
      var _useWebWorker = false;
      var initialDefaultFrame = -999999;
      var setWebWorker = function setWebWorker2(flag) {
        _useWebWorker = !!flag;
      };
      var getWebWorker = function getWebWorker2() {
        return _useWebWorker;
      };
      var setLocationHref = function setLocationHref2(value2) {
        locationHref = value2;
      };
      var getLocationHref = function getLocationHref2() {
        return locationHref;
      };
      function createTag(type) {
        return document.createElement(type);
      }
      function extendPrototype(sources, destination2) {
        var i2;
        var len = sources.length;
        var sourcePrototype;
        for (i2 = 0; i2 < len; i2 += 1) {
          sourcePrototype = sources[i2].prototype;
          for (var attr in sourcePrototype) {
            if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination2.prototype[attr] = sourcePrototype[attr];
          }
        }
      }
      function getDescriptor(object2, prop) {
        return Object.getOwnPropertyDescriptor(object2, prop);
      }
      function createProxyFunction(prototype) {
        function ProxyFunction() {
        }
        ProxyFunction.prototype = prototype;
        return ProxyFunction;
      }
      var audioControllerFactory = function() {
        function AudioController(audioFactory) {
          this.audios = [];
          this.audioFactory = audioFactory;
          this._volume = 1;
          this._isMuted = false;
        }
        AudioController.prototype = {
          addAudio: function addAudio(audio) {
            this.audios.push(audio);
          },
          pause: function pause() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].pause();
            }
          },
          resume: function resume() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].resume();
            }
          },
          setRate: function setRate(rateValue) {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].setRate(rateValue);
            }
          },
          createAudio: function createAudio(assetPath) {
            if (this.audioFactory) {
              return this.audioFactory(assetPath);
            }
            if (window.Howl) {
              return new window.Howl({
                src: [assetPath]
              });
            }
            return {
              isPlaying: false,
              play: function play() {
                this.isPlaying = true;
              },
              seek: function seek() {
                this.isPlaying = false;
              },
              playing: function playing() {
              },
              rate: function rate() {
              },
              setVolume: function setVolume() {
              }
            };
          },
          setAudioFactory: function setAudioFactory(audioFactory) {
            this.audioFactory = audioFactory;
          },
          setVolume: function setVolume(value2) {
            this._volume = value2;
            this._updateVolume();
          },
          mute: function mute() {
            this._isMuted = true;
            this._updateVolume();
          },
          unmute: function unmute() {
            this._isMuted = false;
            this._updateVolume();
          },
          getVolume: function getVolume() {
            return this._volume;
          },
          _updateVolume: function _updateVolume() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].volume(this._volume * (this._isMuted ? 0 : 1));
            }
          }
        };
        return function() {
          return new AudioController();
        };
      }();
      var createTypedArray = function() {
        function createRegularArray(type, len) {
          var i2 = 0;
          var arr = [];
          var value2;
          switch (type) {
            case "int16":
            case "uint8c":
              value2 = 1;
              break;
            default:
              value2 = 1.1;
              break;
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            arr.push(value2);
          }
          return arr;
        }
        function createTypedArrayFactory(type, len) {
          if (type === "float32") {
            return new Float32Array(len);
          }
          if (type === "int16") {
            return new Int16Array(len);
          }
          if (type === "uint8c") {
            return new Uint8ClampedArray(len);
          }
          return createRegularArray(type, len);
        }
        if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
          return createTypedArrayFactory;
        }
        return createRegularArray;
      }();
      function createSizedArray(len) {
        return Array.apply(null, {
          length: len
        });
      }
      function _typeof$6(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$6 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$6 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$6(obj);
      }
      var subframeEnabled = true;
      var expressionsPlugin = null;
      var expressionsInterfaces = null;
      var idPrefix$1 = "";
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      var _shouldRoundValues = false;
      var bmPow = Math.pow;
      var bmSqrt = Math.sqrt;
      var bmFloor = Math.floor;
      var bmMax = Math.max;
      var bmMin = Math.min;
      var BMMath = {};
      (function() {
        var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
        var i2;
        var len = propertyNames.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          BMMath[propertyNames[i2]] = Math[propertyNames[i2]];
        }
      })();
      function ProjectInterface$1() {
        return {};
      }
      BMMath.random = Math.random;
      BMMath.abs = function(val2) {
        var tOfVal = _typeof$6(val2);
        if (tOfVal === "object" && val2.length) {
          var absArr = createSizedArray(val2.length);
          var i2;
          var len = val2.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            absArr[i2] = Math.abs(val2[i2]);
          }
          return absArr;
        }
        return Math.abs(val2);
      };
      var defaultCurveSegments = 150;
      var degToRads = Math.PI / 180;
      var roundCorner = 0.5519;
      function roundValues(flag) {
        _shouldRoundValues = !!flag;
      }
      function bmRnd(value2) {
        if (_shouldRoundValues) {
          return Math.round(value2);
        }
        return value2;
      }
      function styleDiv(element) {
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = "block";
        element.style.transformOrigin = "0 0";
        element.style.webkitTransformOrigin = "0 0";
        element.style.backfaceVisibility = "visible";
        element.style.webkitBackfaceVisibility = "visible";
        element.style.transformStyle = "preserve-3d";
        element.style.webkitTransformStyle = "preserve-3d";
        element.style.mozTransformStyle = "preserve-3d";
      }
      function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteEvent(type, frameMultiplier) {
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMSegmentStartEvent(type, firstFrame, totalFrames) {
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
      }
      function BMDestroyEvent(type, target) {
        this.type = type;
        this.target = target;
      }
      function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = "renderFrameError";
        this.nativeError = nativeError;
        this.currentTime = currentTime;
      }
      function BMConfigErrorEvent(nativeError) {
        this.type = "configError";
        this.nativeError = nativeError;
      }
      function BMAnimationConfigErrorEvent(type, nativeError) {
        this.type = type;
        this.nativeError = nativeError;
      }
      var createElementID = /* @__PURE__ */ function() {
        var _count = 0;
        return function createID() {
          _count += 1;
          return idPrefix$1 + "__lottie_element_" + _count;
        };
      }();
      function HSVtoRGB(h2, s2, v2) {
        var r2;
        var g3;
        var b2;
        var i2;
        var f2;
        var p2;
        var q2;
        var t2;
        i2 = Math.floor(h2 * 6);
        f2 = h2 * 6 - i2;
        p2 = v2 * (1 - s2);
        q2 = v2 * (1 - f2 * s2);
        t2 = v2 * (1 - (1 - f2) * s2);
        switch (i2 % 6) {
          case 0:
            r2 = v2;
            g3 = t2;
            b2 = p2;
            break;
          case 1:
            r2 = q2;
            g3 = v2;
            b2 = p2;
            break;
          case 2:
            r2 = p2;
            g3 = v2;
            b2 = t2;
            break;
          case 3:
            r2 = p2;
            g3 = q2;
            b2 = v2;
            break;
          case 4:
            r2 = t2;
            g3 = p2;
            b2 = v2;
            break;
          case 5:
            r2 = v2;
            g3 = p2;
            b2 = q2;
            break;
          default:
            break;
        }
        return [r2, g3, b2];
      }
      function RGBtoHSV(r2, g3, b2) {
        var max3 = Math.max(r2, g3, b2);
        var min3 = Math.min(r2, g3, b2);
        var d2 = max3 - min3;
        var h2;
        var s2 = max3 === 0 ? 0 : d2 / max3;
        var v2 = max3 / 255;
        switch (max3) {
          case min3:
            h2 = 0;
            break;
          case r2:
            h2 = g3 - b2 + d2 * (g3 < b2 ? 6 : 0);
            h2 /= 6 * d2;
            break;
          case g3:
            h2 = b2 - r2 + d2 * 2;
            h2 /= 6 * d2;
            break;
          case b2:
            h2 = r2 - g3 + d2 * 4;
            h2 /= 6 * d2;
            break;
          default:
            break;
        }
        return [h2, s2, v2];
      }
      function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;
        if (hsv[1] > 1) {
          hsv[1] = 1;
        } else if (hsv[1] <= 0) {
          hsv[1] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;
        if (hsv[2] > 1) {
          hsv[2] = 1;
        } else if (hsv[2] < 0) {
          hsv[2] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;
        if (hsv[0] > 1) {
          hsv[0] -= 1;
        } else if (hsv[0] < 0) {
          hsv[0] += 1;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      var rgbToHex = function() {
        var colorMap = [];
        var i2;
        var hex2;
        for (i2 = 0; i2 < 256; i2 += 1) {
          hex2 = i2.toString(16);
          colorMap[i2] = hex2.length === 1 ? "0" + hex2 : hex2;
        }
        return function(r2, g3, b2) {
          if (r2 < 0) {
            r2 = 0;
          }
          if (g3 < 0) {
            g3 = 0;
          }
          if (b2 < 0) {
            b2 = 0;
          }
          return "#" + colorMap[r2] + colorMap[g3] + colorMap[b2];
        };
      }();
      var setSubframeEnabled = function setSubframeEnabled2(flag) {
        subframeEnabled = !!flag;
      };
      var getSubframeEnabled = function getSubframeEnabled2() {
        return subframeEnabled;
      };
      var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
        expressionsPlugin = value2;
      };
      var getExpressionsPlugin = function getExpressionsPlugin2() {
        return expressionsPlugin;
      };
      var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
        expressionsInterfaces = value2;
      };
      var getExpressionInterfaces = function getExpressionInterfaces2() {
        return expressionsInterfaces;
      };
      var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
        defaultCurveSegments = value2;
      };
      var getDefaultCurveSegments = function getDefaultCurveSegments2() {
        return defaultCurveSegments;
      };
      var setIdPrefix = function setIdPrefix2(value2) {
        idPrefix$1 = value2;
      };
      var getIdPrefix = function getIdPrefix2() {
        return idPrefix$1;
      };
      function createNS(type) {
        return document.createElementNS(svgNS, type);
      }
      function _typeof$5(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$5 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$5 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$5(obj);
      }
      var dataManager = /* @__PURE__ */ function() {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
          onmessage: function onmessage() {
          },
          postMessage: function postMessage(path) {
            workerFn({
              data: path
            });
          }
        };
        var _workerSelf = {
          postMessage: function postMessage(data2) {
            workerProxy.onmessage({
              data: data2
            });
          }
        };
        function createWorker(fn) {
          if (window.Worker && window.Blob && getWebWorker()) {
            var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
              type: "text/javascript"
            });
            var url = URL.createObjectURL(blob);
            return new Worker(url);
          }
          workerFn = fn;
          return workerProxy;
        }
        function setupWorker() {
          if (!workerInstance) {
            workerInstance = createWorker(function workerStart(e3) {
              function dataFunctionManager() {
                function completeLayers(layers, comps) {
                  var layerData;
                  var i2;
                  var len = layers.length;
                  var j2;
                  var jLen;
                  var k2;
                  var kLen;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    layerData = layers[i2];
                    if ("ks" in layerData && !layerData.completed) {
                      layerData.completed = true;
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (maskProps[j2].pt.k.i) {
                            convertPathsToAbsoluteValues(maskProps[j2].pt.k);
                          } else {
                            kLen = maskProps[j2].pt.k.length;
                            for (k2 = 0; k2 < kLen; k2 += 1) {
                              if (maskProps[j2].pt.k[k2].s) {
                                convertPathsToAbsoluteValues(maskProps[j2].pt.k[k2].s[0]);
                              }
                              if (maskProps[j2].pt.k[k2].e) {
                                convertPathsToAbsoluteValues(maskProps[j2].pt.k[k2].e[0]);
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 0) {
                        layerData.layers = findCompLayers(layerData.refId, comps);
                        completeLayers(layerData.layers, comps);
                      } else if (layerData.ty === 4) {
                        completeShapes(layerData.shapes);
                      } else if (layerData.ty === 5) {
                        completeText(layerData);
                      }
                    }
                  }
                }
                function completeChars(chars, assets) {
                  if (chars) {
                    var i2 = 0;
                    var len = chars.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (chars[i2].t === 1) {
                        chars[i2].data.layers = findCompLayers(chars[i2].data.refId, assets);
                        completeLayers(chars[i2].data.layers, assets);
                      }
                    }
                  }
                }
                function findComp(id, comps) {
                  var i2 = 0;
                  var len = comps.length;
                  while (i2 < len) {
                    if (comps[i2].id === id) {
                      return comps[i2];
                    }
                    i2 += 1;
                  }
                  return null;
                }
                function findCompLayers(id, comps) {
                  var comp2 = findComp(id, comps);
                  if (comp2) {
                    if (!comp2.layers.__used) {
                      comp2.layers.__used = true;
                      return comp2.layers;
                    }
                    return JSON.parse(JSON.stringify(comp2.layers));
                  }
                  return null;
                }
                function completeShapes(arr) {
                  var i2;
                  var len = arr.length;
                  var j2;
                  var jLen;
                  for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                    if (arr[i2].ty === "sh") {
                      if (arr[i2].ks.k.i) {
                        convertPathsToAbsoluteValues(arr[i2].ks.k);
                      } else {
                        jLen = arr[i2].ks.k.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (arr[i2].ks.k[j2].s) {
                            convertPathsToAbsoluteValues(arr[i2].ks.k[j2].s[0]);
                          }
                          if (arr[i2].ks.k[j2].e) {
                            convertPathsToAbsoluteValues(arr[i2].ks.k[j2].e[0]);
                          }
                        }
                      }
                    } else if (arr[i2].ty === "gr") {
                      completeShapes(arr[i2].it);
                    }
                  }
                }
                function convertPathsToAbsoluteValues(path) {
                  var i2;
                  var len = path.i.length;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    path.i[i2][0] += path.v[i2][0];
                    path.i[i2][1] += path.v[i2][1];
                    path.o[i2][0] += path.v[i2][0];
                    path.o[i2][1] += path.v[i2][1];
                  }
                }
                function checkVersion(minimum, animVersionString) {
                  var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                  if (minimum[0] > animVersion[0]) {
                    return true;
                  }
                  if (animVersion[0] > minimum[0]) {
                    return false;
                  }
                  if (minimum[1] > animVersion[1]) {
                    return true;
                  }
                  if (animVersion[1] > minimum[1]) {
                    return false;
                  }
                  if (minimum[2] > animVersion[2]) {
                    return true;
                  }
                  if (animVersion[2] > minimum[2]) {
                    return false;
                  }
                  return null;
                }
                var checkText = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 14];
                  function updateTextLayer(textLayer) {
                    var documentData = textLayer.t.d;
                    textLayer.t.d = {
                      k: [{
                        s: documentData,
                        t: 0
                      }]
                    };
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 5) {
                        updateTextLayer(layers[i2]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i2;
                        var len = animationData2.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData2.assets[i2].layers) {
                            iterateLayers(animationData2.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkChars = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 7, 99];
                  return function(animationData2) {
                    if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                      var i2;
                      var len = animationData2.chars.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        var charData = animationData2.chars[i2];
                        if (charData.data && charData.data.shapes) {
                          completeShapes(charData.data.shapes);
                          charData.data.ip = 0;
                          charData.data.op = 99999;
                          charData.data.st = 0;
                          charData.data.sr = 1;
                          charData.data.ks = {
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            }
                          };
                          if (!animationData2.chars[i2].t) {
                            charData.data.shapes.push({
                              ty: "no"
                            });
                            charData.data.shapes[0].it.push({
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              },
                              sk: {
                                k: 0,
                                a: 0
                              },
                              sa: {
                                k: 0,
                                a: 0
                              },
                              ty: "tr"
                            });
                          }
                        }
                      }
                    }
                  };
                }();
                var checkPathProperties = /* @__PURE__ */ function() {
                  var minimumVersion = [5, 7, 15];
                  function updateTextLayer(textLayer) {
                    var pathData = textLayer.t.p;
                    if (typeof pathData.a === "number") {
                      pathData.a = {
                        a: 0,
                        k: pathData.a
                      };
                    }
                    if (typeof pathData.p === "number") {
                      pathData.p = {
                        a: 0,
                        k: pathData.p
                      };
                    }
                    if (typeof pathData.r === "number") {
                      pathData.r = {
                        a: 0,
                        k: pathData.r
                      };
                    }
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 5) {
                        updateTextLayer(layers[i2]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i2;
                        var len = animationData2.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData2.assets[i2].layers) {
                            iterateLayers(animationData2.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkColors = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 1, 9];
                  function iterateShapes(shapes) {
                    var i2;
                    var len = shapes.length;
                    var j2;
                    var jLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (shapes[i2].ty === "gr") {
                        iterateShapes(shapes[i2].it);
                      } else if (shapes[i2].ty === "fl" || shapes[i2].ty === "st") {
                        if (shapes[i2].c.k && shapes[i2].c.k[0].i) {
                          jLen = shapes[i2].c.k.length;
                          for (j2 = 0; j2 < jLen; j2 += 1) {
                            if (shapes[i2].c.k[j2].s) {
                              shapes[i2].c.k[j2].s[0] /= 255;
                              shapes[i2].c.k[j2].s[1] /= 255;
                              shapes[i2].c.k[j2].s[2] /= 255;
                              shapes[i2].c.k[j2].s[3] /= 255;
                            }
                            if (shapes[i2].c.k[j2].e) {
                              shapes[i2].c.k[j2].e[0] /= 255;
                              shapes[i2].c.k[j2].e[1] /= 255;
                              shapes[i2].c.k[j2].e[2] /= 255;
                              shapes[i2].c.k[j2].e[3] /= 255;
                            }
                          }
                        } else {
                          shapes[i2].c.k[0] /= 255;
                          shapes[i2].c.k[1] /= 255;
                          shapes[i2].c.k[2] /= 255;
                          shapes[i2].c.k[3] /= 255;
                        }
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 4) {
                        iterateShapes(layers[i2].shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i2;
                        var len = animationData2.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData2.assets[i2].layers) {
                            iterateLayers(animationData2.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkShapes = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 18];
                  function completeClosingShapes(arr) {
                    var i2;
                    var len = arr.length;
                    var j2;
                    var jLen;
                    for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                      if (arr[i2].ty === "sh") {
                        if (arr[i2].ks.k.i) {
                          arr[i2].ks.k.c = arr[i2].closed;
                        } else {
                          jLen = arr[i2].ks.k.length;
                          for (j2 = 0; j2 < jLen; j2 += 1) {
                            if (arr[i2].ks.k[j2].s) {
                              arr[i2].ks.k[j2].s[0].c = arr[i2].closed;
                            }
                            if (arr[i2].ks.k[j2].e) {
                              arr[i2].ks.k[j2].e[0].c = arr[i2].closed;
                            }
                          }
                        }
                      } else if (arr[i2].ty === "gr") {
                        completeClosingShapes(arr[i2].it);
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var layerData;
                    var i2;
                    var len = layers.length;
                    var j2;
                    var jLen;
                    var k2;
                    var kLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      layerData = layers[i2];
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j2 = 0; j2 < jLen; j2 += 1) {
                          if (maskProps[j2].pt.k.i) {
                            maskProps[j2].pt.k.c = maskProps[j2].cl;
                          } else {
                            kLen = maskProps[j2].pt.k.length;
                            for (k2 = 0; k2 < kLen; k2 += 1) {
                              if (maskProps[j2].pt.k[k2].s) {
                                maskProps[j2].pt.k[k2].s[0].c = maskProps[j2].cl;
                              }
                              if (maskProps[j2].pt.k[k2].e) {
                                maskProps[j2].pt.k[k2].e[0].c = maskProps[j2].cl;
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 4) {
                        completeClosingShapes(layerData.shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i2;
                        var len = animationData2.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData2.assets[i2].layers) {
                            iterateLayers(animationData2.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                function completeData(animationData2) {
                  if (animationData2.__complete) {
                    return;
                  }
                  checkColors(animationData2);
                  checkText(animationData2);
                  checkChars(animationData2);
                  checkPathProperties(animationData2);
                  checkShapes(animationData2);
                  completeLayers(animationData2.layers, animationData2.assets);
                  completeChars(animationData2.chars, animationData2.assets);
                  animationData2.__complete = true;
                }
                function completeText(data2) {
                  if (data2.t.a.length === 0 && !("m" in data2.t.p)) {
                  }
                }
                var moduleOb = {};
                moduleOb.completeData = completeData;
                moduleOb.checkColors = checkColors;
                moduleOb.checkChars = checkChars;
                moduleOb.checkPathProperties = checkPathProperties;
                moduleOb.checkShapes = checkShapes;
                moduleOb.completeLayers = completeLayers;
                return moduleOb;
              }
              if (!_workerSelf.dataManager) {
                _workerSelf.dataManager = dataFunctionManager();
              }
              if (!_workerSelf.assetLoader) {
                _workerSelf.assetLoader = /* @__PURE__ */ function() {
                  function formatResponse(xhr) {
                    var contentTypeHeader = xhr.getResponseHeader("content-type");
                    if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                      return xhr.response;
                    }
                    if (xhr.response && _typeof$5(xhr.response) === "object") {
                      return xhr.response;
                    }
                    if (xhr.response && typeof xhr.response === "string") {
                      return JSON.parse(xhr.response);
                    }
                    if (xhr.responseText) {
                      return JSON.parse(xhr.responseText);
                    }
                    return null;
                  }
                  function loadAsset(path, fullPath, callback, errorCallback) {
                    var response;
                    var xhr = new XMLHttpRequest();
                    try {
                      xhr.responseType = "json";
                    } catch (err) {
                    }
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                          response = formatResponse(xhr);
                          callback(response);
                        } else {
                          try {
                            response = formatResponse(xhr);
                            callback(response);
                          } catch (err) {
                            if (errorCallback) {
                              errorCallback(err);
                            }
                          }
                        }
                      }
                    };
                    try {
                      xhr.open(["G", "E", "T"].join(""), path, true);
                    } catch (error) {
                      xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                    }
                    xhr.send();
                  }
                  return {
                    load: loadAsset
                  };
                }();
              }
              if (e3.data.type === "loadAnimation") {
                _workerSelf.assetLoader.load(e3.data.path, e3.data.fullPath, function(data2) {
                  _workerSelf.dataManager.completeData(data2);
                  _workerSelf.postMessage({
                    id: e3.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e3.data.id,
                    status: "error"
                  });
                });
              } else if (e3.data.type === "complete") {
                var animation = e3.data.animation;
                _workerSelf.dataManager.completeData(animation);
                _workerSelf.postMessage({
                  id: e3.data.id,
                  payload: animation,
                  status: "success"
                });
              } else if (e3.data.type === "loadData") {
                _workerSelf.assetLoader.load(e3.data.path, e3.data.fullPath, function(data2) {
                  _workerSelf.postMessage({
                    id: e3.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e3.data.id,
                    status: "error"
                  });
                });
              }
            });
            workerInstance.onmessage = function(event) {
              var data2 = event.data;
              var id = data2.id;
              var process = processes[id];
              processes[id] = null;
              if (data2.status === "success") {
                process.onComplete(data2.payload);
              } else if (process.onError) {
                process.onError();
              }
            };
          }
        }
        function createProcess(onComplete, onError) {
          _counterId += 1;
          var id = "processId_" + _counterId;
          processes[id] = {
            onComplete,
            onError
          };
          return id;
        }
        function loadAnimation2(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadAnimation",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function loadData(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadData",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function completeAnimation(anim, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "complete",
            animation: anim,
            id: processId
          });
        }
        return {
          loadAnimation: loadAnimation2,
          loadData,
          completeAnimation
        };
      }();
      var ImagePreloader = function() {
        var proxyImage = function() {
          var canvas = createTag("canvas");
          canvas.width = 1;
          canvas.height = 1;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fillRect(0, 0, 1, 1);
          return canvas;
        }();
        function imageLoaded() {
          this.loadedAssets += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function footageLoaded() {
          this.loadedFootagesCount += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function getAssetsPath(assetData, assetsPath, originalPath) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = assetsPath + imagePath;
          } else {
            path = originalPath;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        }
        function testImageLoaded(img) {
          var _count = 0;
          var intervalId = setInterval((function() {
            var box = img.getBBox();
            if (box.width || _count > 500) {
              this._imageLoaded();
              clearInterval(intervalId);
            }
            _count += 1;
          }).bind(this), 50);
        }
        function createImageData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createNS("image");
          if (isSafari) {
            this.testImageLoaded(img);
          } else {
            img.addEventListener("load", this._imageLoaded, false);
          }
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
          if (this._elementHelper.append) {
            this._elementHelper.append(img);
          } else {
            this._elementHelper.appendChild(img);
          }
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createImgData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createTag("img");
          img.crossOrigin = "anonymous";
          img.addEventListener("load", this._imageLoaded, false);
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.src = path;
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createFootageData(data2) {
          var ob2 = {
            assetData: data2
          };
          var path = getAssetsPath(data2, this.assetsPath, this.path);
          dataManager.loadData(path, (function(footageData) {
            ob2.img = footageData;
            this._footageLoaded();
          }).bind(this), (function() {
            ob2.img = {};
            this._footageLoaded();
          }).bind(this));
          return ob2;
        }
        function loadAssets(assets, cb) {
          this.imagesLoadedCb = cb;
          var i2;
          var len = assets.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!assets[i2].layers) {
              if (!assets[i2].t || assets[i2].t === "seq") {
                this.totalImages += 1;
                this.images.push(this._createImageData(assets[i2]));
              } else if (assets[i2].t === 3) {
                this.totalFootages += 1;
                this.images.push(this.createFootageData(assets[i2]));
              }
            }
          }
        }
        function setPath(path) {
          this.path = path || "";
        }
        function setAssetsPath(path) {
          this.assetsPath = path || "";
        }
        function getAsset(assetData) {
          var i2 = 0;
          var len = this.images.length;
          while (i2 < len) {
            if (this.images[i2].assetData === assetData) {
              return this.images[i2].img;
            }
            i2 += 1;
          }
          return null;
        }
        function destroy() {
          this.imagesLoadedCb = null;
          this.images.length = 0;
        }
        function loadedImages() {
          return this.totalImages === this.loadedAssets;
        }
        function loadedFootages() {
          return this.totalFootages === this.loadedFootagesCount;
        }
        function setCacheType(type, elementHelper) {
          if (type === "svg") {
            this._elementHelper = elementHelper;
            this._createImageData = this.createImageData.bind(this);
          } else {
            this._createImageData = this.createImgData.bind(this);
          }
        }
        function ImagePreloaderFactory() {
          this._imageLoaded = imageLoaded.bind(this);
          this._footageLoaded = footageLoaded.bind(this);
          this.testImageLoaded = testImageLoaded.bind(this);
          this.createFootageData = createFootageData.bind(this);
          this.assetsPath = "";
          this.path = "";
          this.totalImages = 0;
          this.totalFootages = 0;
          this.loadedAssets = 0;
          this.loadedFootagesCount = 0;
          this.imagesLoadedCb = null;
          this.images = [];
        }
        ImagePreloaderFactory.prototype = {
          loadAssets,
          setAssetsPath,
          setPath,
          loadedImages,
          loadedFootages,
          destroy,
          getAsset,
          createImgData,
          createImageData,
          imageLoaded,
          footageLoaded,
          setCacheType
        };
        return ImagePreloaderFactory;
      }();
      function BaseEvent() {
      }
      BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
          if (this._cbs[eventName]) {
            var callbacks = this._cbs[eventName];
            for (var i2 = 0; i2 < callbacks.length; i2 += 1) {
              callbacks[i2](args);
            }
          }
        },
        addEventListener: function addEventListener(eventName, callback) {
          if (!this._cbs[eventName]) {
            this._cbs[eventName] = [];
          }
          this._cbs[eventName].push(callback);
          return (function() {
            this.removeEventListener(eventName, callback);
          }).bind(this);
        },
        removeEventListener: function removeEventListener(eventName, callback) {
          if (!callback) {
            this._cbs[eventName] = null;
          } else if (this._cbs[eventName]) {
            var i2 = 0;
            var len = this._cbs[eventName].length;
            while (i2 < len) {
              if (this._cbs[eventName][i2] === callback) {
                this._cbs[eventName].splice(i2, 1);
                i2 -= 1;
                len -= 1;
              }
              i2 += 1;
            }
            if (!this._cbs[eventName].length) {
              this._cbs[eventName] = null;
            }
          }
        }
      };
      var markerParser = /* @__PURE__ */ function() {
        function parsePayloadLines(payload) {
          var lines = payload.split("\r\n");
          var keys2 = {};
          var line;
          var keysCount = 0;
          for (var i2 = 0; i2 < lines.length; i2 += 1) {
            line = lines[i2].split(":");
            if (line.length === 2) {
              keys2[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }
          if (keysCount === 0) {
            throw new Error();
          }
          return keys2;
        }
        return function(_markers) {
          var markers = [];
          for (var i2 = 0; i2 < _markers.length; i2 += 1) {
            var _marker = _markers[i2];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr
            };
            try {
              markerData.payload = JSON.parse(_markers[i2].cm);
            } catch (_2) {
              try {
                markerData.payload = parsePayloadLines(_markers[i2].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i2].cm
                };
              }
            }
            markers.push(markerData);
          }
          return markers;
        };
      }();
      var ProjectInterface = /* @__PURE__ */ function() {
        function registerComposition(comp2) {
          this.compositions.push(comp2);
        }
        return function() {
          function _thisProjectFunction(name2) {
            var i2 = 0;
            var len = this.compositions.length;
            while (i2 < len) {
              if (this.compositions[i2].data && this.compositions[i2].data.nm === name2) {
                if (this.compositions[i2].prepareFrame && this.compositions[i2].data.xt) {
                  this.compositions[i2].prepareFrame(this.currentFrame);
                }
                return this.compositions[i2].compInterface;
              }
              i2 += 1;
            }
            return null;
          }
          _thisProjectFunction.compositions = [];
          _thisProjectFunction.currentFrame = 0;
          _thisProjectFunction.registerComposition = registerComposition;
          return _thisProjectFunction;
        };
      }();
      var renderers = {};
      var registerRenderer = function registerRenderer2(key2, value2) {
        renderers[key2] = value2;
      };
      function getRenderer(key2) {
        return renderers[key2];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) {
          return "canvas";
        }
        for (var key2 in renderers) {
          if (renderers[key2]) {
            return key2;
          }
        }
        return "";
      }
      function _typeof$4(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$4 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$4 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$4(obj);
      }
      var AnimationItem = function AnimationItem2() {
        this._cbs = [];
        this.name = "";
        this.path = "";
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = "";
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
        this.expressionsPlugin = getExpressionsPlugin();
      };
      extendPrototype([BaseEvent], AnimationItem);
      AnimationItem.prototype.setParams = function(params) {
        if (params.wrapper || params.container) {
          this.wrapper = params.wrapper || params.container;
        }
        var animType = "svg";
        if (params.animType) {
          animType = params.animType;
        } else if (params.renderer) {
          animType = params.renderer;
        }
        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
          this.loop = true;
        } else if (params.loop === false) {
          this.loop = false;
        } else {
          this.loop = parseInt(params.loop, 10);
        }
        this.autoplay = "autoplay" in params ? params.autoplay : true;
        this.name = params.name ? params.name : "";
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.audioFactory) {
          this.audioController.setAudioFactory(params.audioFactory);
        }
        if (params.animationData) {
          this.setupAnimation(params.animationData);
        } else if (params.path) {
          if (params.path.lastIndexOf("\\") !== -1) {
            this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
          } else {
            this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
          }
          this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
          dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
      };
      AnimationItem.prototype.onSetupError = function() {
        this.trigger("data_failed");
      };
      AnimationItem.prototype.setupAnimation = function(data2) {
        dataManager.completeAnimation(data2, this.configAnimation);
      };
      AnimationItem.prototype.setData = function(wrapper, animationData2) {
        if (animationData2) {
          if (_typeof$4(animationData2) !== "object") {
            animationData2 = JSON.parse(animationData2);
          }
        }
        var params = {
          wrapper,
          animationData: animationData2
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
        params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
        var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
        if (loop === "false") {
          params.loop = false;
        } else if (loop === "true") {
          params.loop = true;
        } else if (loop !== "") {
          params.loop = parseInt(loop, 10);
        }
        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
        params.autoplay = autoplay !== "false";
        params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
        var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
        if (prerender === "false") {
          params.prerender = false;
        }
        if (!params.path) {
          this.trigger("destroy");
        } else {
          this.setParams(params);
        }
      };
      AnimationItem.prototype.includeLayers = function(data2) {
        if (data2.op > this.animationData.op) {
          this.animationData.op = data2.op;
          this.totalFrames = Math.floor(data2.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i2;
        var len = layers.length;
        var newLayers = data2.layers;
        var j2;
        var jLen = newLayers.length;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          i2 = 0;
          while (i2 < len) {
            if (layers[i2].id === newLayers[j2].id) {
              layers[i2] = newLayers[j2];
              break;
            }
            i2 += 1;
          }
        }
        if (data2.chars || data2.fonts) {
          this.renderer.globalData.fontManager.addChars(data2.chars);
          this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
        }
        if (data2.assets) {
          len = data2.assets.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.animationData.assets.push(data2.assets[i2]);
          }
        }
        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
      };
      AnimationItem.prototype.onSegmentComplete = function(data2) {
        this.animationData = data2;
        var expressionsPlugin2 = getExpressionsPlugin();
        if (expressionsPlugin2) {
          expressionsPlugin2.initExpressions(this);
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if (!segments || segments.length === 0 || !this.autoloadSegments) {
          this.trigger("data_ready");
          this.timeCompleted = this.totalFrames;
          return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {
          this.trigger("data_failed");
        }).bind(this));
      };
      AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if (!segments) {
          this.timeCompleted = this.totalFrames;
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.imagesLoaded = function() {
        this.trigger("loaded_images");
        this.checkLoaded();
      };
      AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
      };
      AnimationItem.prototype.configAnimation = function(animData) {
        if (!this.renderer) {
          return;
        }
        try {
          this.animationData = animData;
          if (this.initialSegment) {
            this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
            this.firstFrame = Math.round(this.initialSegment[0]);
          } else {
            this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
            this.firstFrame = Math.round(this.animationData.ip);
          }
          this.renderer.configAnimation(animData);
          if (!animData.assets) {
            animData.assets = [];
          }
          this.assets = this.animationData.assets;
          this.frameRate = this.animationData.fr;
          this.frameMult = this.animationData.fr / 1e3;
          this.renderer.searchExtraCompositions(animData.assets);
          this.markers = markerParser(animData.markers || []);
          this.trigger("config_ready");
          this.preloadImages();
          this.loadSegments();
          this.updaFrameModifier();
          this.waitForFontsLoaded();
          if (this.isPaused) {
            this.audioController.pause();
          }
        } catch (error) {
          this.triggerConfigError(error);
        }
      };
      AnimationItem.prototype.waitForFontsLoaded = function() {
        if (!this.renderer) {
          return;
        }
        if (this.renderer.globalData.fontManager.isLoaded) {
          this.checkLoaded();
        } else {
          setTimeout(this.waitForFontsLoaded.bind(this), 20);
        }
      };
      AnimationItem.prototype.checkLoaded = function() {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
          this.isLoaded = true;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.renderer.initItems();
          setTimeout((function() {
            this.trigger("DOMLoaded");
          }).bind(this), 0);
          this.gotoFrame();
          if (this.autoplay) {
            this.play();
          }
        }
      };
      AnimationItem.prototype.resize = function(width2, height2) {
        var _width = typeof width2 === "number" ? width2 : void 0;
        var _height = typeof height2 === "number" ? height2 : void 0;
        this.renderer.updateContainerSize(_width, _height);
      };
      AnimationItem.prototype.setSubframe = function(flag) {
        this.isSubframeEnabled = !!flag;
      };
      AnimationItem.prototype.gotoFrame = function() {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
          this.currentFrame = this.timeCompleted;
        }
        this.trigger("enterFrame");
        this.renderFrame();
        this.trigger("drawnFrame");
      };
      AnimationItem.prototype.renderFrame = function() {
        if (this.isLoaded === false || !this.renderer) {
          return;
        }
        try {
          if (this.expressionsPlugin) {
            this.expressionsPlugin.resetFrame();
          }
          this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
          this.triggerRenderFrameError(error);
        }
      };
      AnimationItem.prototype.play = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.isPaused = false;
          this.trigger("_play");
          this.audioController.resume();
          if (this._idle) {
            this._idle = false;
            this.trigger("_active");
          }
        }
      };
      AnimationItem.prototype.pause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === false) {
          this.isPaused = true;
          this.trigger("_pause");
          this._idle = true;
          this.trigger("_idle");
          this.audioController.pause();
        }
      };
      AnimationItem.prototype.togglePause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.play();
        } else {
          this.pause();
        }
      };
      AnimationItem.prototype.stop = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
      };
      AnimationItem.prototype.getMarkerData = function(markerName) {
        var marker;
        for (var i2 = 0; i2 < this.markers.length; i2 += 1) {
          marker = this.markers[i2];
          if (marker.payload && marker.payload.name === markerName) {
            return marker;
          }
        }
        return null;
      };
      AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            this.goToAndStop(marker.time, true);
          }
        } else if (isFrame) {
          this.setCurrentRawFrameValue(value2);
        } else {
          this.setCurrentRawFrameValue(value2 * this.frameModifier);
        }
        this.pause();
      };
      AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            if (!marker.duration) {
              this.goToAndStop(marker.time, true);
            } else {
              this.playSegments([marker.time, marker.time + marker.duration], true);
            }
          }
        } else {
          this.goToAndStop(numValue, isFrame, name2);
        }
        this.play();
      };
      AnimationItem.prototype.advanceTime = function(value2) {
        if (this.isPaused === true || this.isLoaded === false) {
          return;
        }
        var nextValue = this.currentRawFrame + value2 * this.frameModifier;
        var _isComplete = false;
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
          if (!this.loop || this.playCount === this.loop) {
            if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
              _isComplete = true;
              nextValue = this.totalFrames - 1;
            }
          } else if (nextValue >= this.totalFrames) {
            this.playCount += 1;
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              this.setCurrentRawFrameValue(nextValue % this.totalFrames);
              this._completedLoop = true;
              this.trigger("loopComplete");
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
        } else if (nextValue < 0) {
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
              this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
              if (!this._completedLoop) {
                this._completedLoop = true;
              } else {
                this.trigger("loopComplete");
              }
            } else {
              _isComplete = true;
              nextValue = 0;
            }
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
        if (_isComplete) {
          this.setCurrentRawFrameValue(nextValue);
          this.pause();
          this.trigger("complete");
        }
      };
      AnimationItem.prototype.adjustSegment = function(arr, offset) {
        this.playCount = 0;
        if (arr[1] < arr[0]) {
          if (this.frameModifier > 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(-1);
            }
          }
          this.totalFrames = arr[0] - arr[1];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[1];
          this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
        } else if (arr[1] > arr[0]) {
          if (this.frameModifier < 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(1);
            }
          }
          this.totalFrames = arr[1] - arr[0];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[0];
          this.setCurrentRawFrameValue(1e-3 + offset);
        }
        this.trigger("segmentStart");
      };
      AnimationItem.prototype.setSegment = function(init, end) {
        var pendingFrame = -1;
        if (this.isPaused) {
          if (this.currentRawFrame + this.firstFrame < init) {
            pendingFrame = init;
          } else if (this.currentRawFrame + this.firstFrame > end) {
            pendingFrame = end - init;
          }
        }
        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;
        if (pendingFrame !== -1) {
          this.goToAndStop(pendingFrame, true);
        }
      };
      AnimationItem.prototype.playSegments = function(arr, forceFlag) {
        if (forceFlag) {
          this.segments.length = 0;
        }
        if (_typeof$4(arr[0]) === "object") {
          var i2;
          var len = arr.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.segments.push(arr[i2]);
          }
        } else {
          this.segments.push(arr);
        }
        if (this.segments.length && forceFlag) {
          this.adjustSegment(this.segments.shift(), 0);
        }
        if (this.isPaused) {
          this.play();
        }
      };
      AnimationItem.prototype.resetSegments = function(forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip, this.animationData.op]);
        if (forceFlag) {
          this.checkSegments(0);
        }
      };
      AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
          this.adjustSegment(this.segments.shift(), offset);
          return true;
        }
        return false;
      };
      AnimationItem.prototype.destroy = function(name2) {
        if (name2 && this.name !== name2 || !this.renderer) {
          return;
        }
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger("destroy");
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.expressionsPlugin = null;
        this.imagePreloader = null;
        this.projectInterface = null;
      };
      AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
        this.currentRawFrame = value2;
        this.gotoFrame();
      };
      AnimationItem.prototype.setSpeed = function(val2) {
        this.playSpeed = val2;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setDirection = function(val2) {
        this.playDirection = val2 < 0 ? -1 : 1;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setLoop = function(isLooping) {
        this.loop = isLooping;
      };
      AnimationItem.prototype.setVolume = function(val2, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.setVolume(val2);
      };
      AnimationItem.prototype.getVolume = function() {
        return this.audioController.getVolume();
      };
      AnimationItem.prototype.mute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.mute();
      };
      AnimationItem.prototype.unmute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.unmute();
      };
      AnimationItem.prototype.updaFrameModifier = function() {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
      };
      AnimationItem.prototype.getPath = function() {
        return this.path;
      };
      AnimationItem.prototype.getAssetsPath = function(assetData) {
        var path = "";
        if (assetData.e) {
          path = assetData.p;
        } else if (this.assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf("images/") !== -1) {
            imagePath = imagePath.split("/")[1];
          }
          path = this.assetsPath + imagePath;
        } else {
          path = this.path;
          path += assetData.u ? assetData.u : "";
          path += assetData.p;
        }
        return path;
      };
      AnimationItem.prototype.getAssetData = function(id) {
        var i2 = 0;
        var len = this.assets.length;
        while (i2 < len) {
          if (id === this.assets[i2].id) {
            return this.assets[i2];
          }
          i2 += 1;
        }
        return null;
      };
      AnimationItem.prototype.hide = function() {
        this.renderer.hide();
      };
      AnimationItem.prototype.show = function() {
        this.renderer.show();
      };
      AnimationItem.prototype.getDuration = function(isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
      };
      AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
        try {
          var element = this.renderer.getElementByPath(path);
          element.updateDocumentData(documentData, index2);
        } catch (error) {
        }
      };
      AnimationItem.prototype.trigger = function(name2) {
        if (this._cbs && this._cbs[name2]) {
          switch (name2) {
            case "enterFrame":
              this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
              break;
            case "drawnFrame":
              this.drawnFrameEvent.currentTime = this.currentFrame;
              this.drawnFrameEvent.totalTime = this.totalFrames;
              this.drawnFrameEvent.direction = this.frameModifier;
              this.triggerEvent(name2, this.drawnFrameEvent);
              break;
            case "loopComplete":
              this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
              break;
            case "complete":
              this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
              break;
            case "segmentStart":
              this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
              break;
            case "destroy":
              this.triggerEvent(name2, new BMDestroyEvent(name2, this));
              break;
            default:
              this.triggerEvent(name2);
          }
        }
        if (name2 === "enterFrame" && this.onEnterFrame) {
          this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
        }
        if (name2 === "loopComplete" && this.onLoopComplete) {
          this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
        }
        if (name2 === "complete" && this.onComplete) {
          this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
        }
        if (name2 === "segmentStart" && this.onSegmentStart) {
          this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
        }
        if (name2 === "destroy" && this.onDestroy) {
          this.onDestroy.call(this, new BMDestroyEvent(name2, this));
        }
      };
      AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      AnimationItem.prototype.triggerConfigError = function(nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      var animationManager = function() {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;
        function removeElement(ev) {
          var i2 = 0;
          var animItem = ev.target;
          while (i2 < len) {
            if (registeredAnimations[i2].animation === animItem) {
              registeredAnimations.splice(i2, 1);
              i2 -= 1;
              len -= 1;
              if (!animItem.isPaused) {
                subtractPlayingCount();
              }
            }
            i2 += 1;
          }
        }
        function registerAnimation(element, animationData2) {
          if (!element) {
            return null;
          }
          var i2 = 0;
          while (i2 < len) {
            if (registeredAnimations[i2].elem === element && registeredAnimations[i2].elem !== null) {
              return registeredAnimations[i2].animation;
            }
            i2 += 1;
          }
          var animItem = new AnimationItem();
          setupAnimation(animItem, element);
          animItem.setData(element, animationData2);
          return animItem;
        }
        function getRegisteredAnimations() {
          var i2;
          var lenAnims = registeredAnimations.length;
          var animations = [];
          for (i2 = 0; i2 < lenAnims; i2 += 1) {
            animations.push(registeredAnimations[i2].animation);
          }
          return animations;
        }
        function addPlayingCount() {
          playingAnimationsNum += 1;
          activate();
        }
        function subtractPlayingCount() {
          playingAnimationsNum -= 1;
        }
        function setupAnimation(animItem, element) {
          animItem.addEventListener("destroy", removeElement);
          animItem.addEventListener("_active", addPlayingCount);
          animItem.addEventListener("_idle", subtractPlayingCount);
          registeredAnimations.push({
            elem: element,
            animation: animItem
          });
          len += 1;
        }
        function loadAnimation2(params) {
          var animItem = new AnimationItem();
          setupAnimation(animItem, null);
          animItem.setParams(params);
          return animItem;
        }
        function setSpeed(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setSpeed(val2, animation);
          }
        }
        function setDirection(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setDirection(val2, animation);
          }
        }
        function play(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.play(animation);
          }
        }
        function resume(nowTime) {
          var elapsedTime = nowTime - initTime;
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.advanceTime(elapsedTime);
          }
          initTime = nowTime;
          if (playingAnimationsNum && !_isFrozen) {
            window.requestAnimationFrame(resume);
          } else {
            _stopped = true;
          }
        }
        function first(nowTime) {
          initTime = nowTime;
          window.requestAnimationFrame(resume);
        }
        function pause(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.pause(animation);
          }
        }
        function goToAndStop(value2, isFrame, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.goToAndStop(value2, isFrame, animation);
          }
        }
        function stop(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.stop(animation);
          }
        }
        function togglePause(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.togglePause(animation);
          }
        }
        function destroy(animation) {
          var i2;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            registeredAnimations[i2].animation.destroy(animation);
          }
        }
        function searchAnimations2(animationData2, standalone2, renderer2) {
          var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
          var i2;
          var lenAnims = animElements.length;
          for (i2 = 0; i2 < lenAnims; i2 += 1) {
            if (renderer2) {
              animElements[i2].setAttribute("data-bm-type", renderer2);
            }
            registerAnimation(animElements[i2], animationData2);
          }
          if (standalone2 && lenAnims === 0) {
            if (!renderer2) {
              renderer2 = "svg";
            }
            var body = document.getElementsByTagName("body")[0];
            body.innerText = "";
            var div2 = createTag("div");
            div2.style.width = "100%";
            div2.style.height = "100%";
            div2.setAttribute("data-bm-type", renderer2);
            body.appendChild(div2);
            registerAnimation(div2, animationData2);
          }
        }
        function resize() {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.resize();
          }
        }
        function activate() {
          if (!_isFrozen && playingAnimationsNum) {
            if (_stopped) {
              window.requestAnimationFrame(first);
              _stopped = false;
            }
          }
        }
        function freeze() {
          _isFrozen = true;
        }
        function unfreeze() {
          _isFrozen = false;
          activate();
        }
        function setVolume(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setVolume(val2, animation);
          }
        }
        function mute(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.mute(animation);
          }
        }
        function unmute(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.unmute(animation);
          }
        }
        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation2;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations2;
        moduleOb.resize = resize;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
      }();
      var BezierFactory = function() {
        var ob2 = {};
        ob2.getBezierEasing = getBezierEasing;
        var beziers = {};
        function getBezierEasing(a2, b2, c2, d2, nm) {
          var str = nm || ("bez_" + a2 + "_" + b2 + "_" + c2 + "_" + d2).replace(/\./g, "p");
          if (beziers[str]) {
            return beziers[str];
          }
          var bezEasing = new BezierEasing([a2, b2, c2, d2]);
          beziers[str] = bezEasing;
          return bezEasing;
        }
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 1e-3;
        var SUBDIVISION_PRECISION = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1 / (kSplineTableSize - 1);
        var float32ArraySupported = typeof Float32Array === "function";
        function A5(aA1, aA2) {
          return 1 - 3 * aA2 + 3 * aA1;
        }
        function B2(aA1, aA2) {
          return 3 * aA2 - 6 * aA1;
        }
        function C2(aA1) {
          return 3 * aA1;
        }
        function calcBezier(aT, aA1, aA2) {
          return ((A5(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
        }
        function getSlope(aT, aA1, aA2) {
          return 3 * A5(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
          var currentX, currentT, i2 = 0;
          do {
            currentT = aA + (aB - aA) / 2;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
          for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0) return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
        }
        function BezierEasing(points) {
          this._p = points;
          this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
          this._precomputed = false;
          this.get = this.get.bind(this);
        }
        BezierEasing.prototype = {
          get: function get2(x3) {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            if (!this._precomputed) this._precompute();
            if (mX1 === mY1 && mX2 === mY2) return x3;
            if (x3 === 0) return 0;
            if (x3 === 1) return 1;
            return calcBezier(this._getTForX(x3), mY1, mY2);
          },
          // Private part
          _precompute: function _precompute() {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            this._precomputed = true;
            if (mX1 !== mY1 || mX2 !== mY2) {
              this._calcSampleValues();
            }
          },
          _calcSampleValues: function _calcSampleValues() {
            var mX1 = this._p[0], mX2 = this._p[2];
            for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
              this._mSampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
            }
          },
          /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
          _getTForX: function _getTForX(aX) {
            var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;
            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
            }
            --currentSample;
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            }
            if (initialSlope === 0) {
              return guessForT;
            }
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        };
        return ob2;
      }();
      var pooling = /* @__PURE__ */ function() {
        function _double(arr) {
          return arr.concat(createSizedArray(arr.length));
        }
        return {
          "double": _double
        };
      }();
      var poolFactory = /* @__PURE__ */ function() {
        return function(initialLength, _create, _release) {
          var _length = 0;
          var _maxLength = initialLength;
          var pool = createSizedArray(_maxLength);
          var ob2 = {
            newElement,
            release
          };
          function newElement() {
            var element;
            if (_length) {
              _length -= 1;
              element = pool[_length];
            } else {
              element = _create();
            }
            return element;
          }
          function release(element) {
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            if (_release) {
              _release(element);
            }
            pool[_length] = element;
            _length += 1;
          }
          return ob2;
        };
      }();
      var bezierLengthPool = function() {
        function create() {
          return {
            addedLength: 0,
            percents: createTypedArray("float32", getDefaultCurveSegments()),
            lengths: createTypedArray("float32", getDefaultCurveSegments())
          };
        }
        return poolFactory(8, create);
      }();
      var segmentsLengthPool = function() {
        function create() {
          return {
            lengths: [],
            totalLength: 0
          };
        }
        function release(element) {
          var i2;
          var len = element.lengths.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            bezierLengthPool.release(element.lengths[i2]);
          }
          element.lengths.length = 0;
        }
        return poolFactory(8, create, release);
      }();
      function bezFunction() {
        var math = Math;
        function pointOnLine2D(x13, y13, x22, y22, x3, y3) {
          var det1 = x13 * y22 + y13 * x3 + x22 * y3 - x3 * y22 - y3 * x13 - x22 * y13;
          return det1 > -1e-3 && det1 < 1e-3;
        }
        function pointOnLine3D(x13, y13, z1, x22, y22, z2, x3, y3, z3) {
          if (z1 === 0 && z2 === 0 && z3 === 0) {
            return pointOnLine2D(x13, y13, x22, y22, x3, y3);
          }
          var dist1 = math.sqrt(math.pow(x22 - x13, 2) + math.pow(y22 - y13, 2) + math.pow(z2 - z1, 2));
          var dist2 = math.sqrt(math.pow(x3 - x13, 2) + math.pow(y3 - y13, 2) + math.pow(z3 - z1, 2));
          var dist3 = math.sqrt(math.pow(x3 - x22, 2) + math.pow(y3 - y22, 2) + math.pow(z3 - z2, 2));
          var diffDist;
          if (dist1 > dist2) {
            if (dist1 > dist3) {
              diffDist = dist1 - dist2 - dist3;
            } else {
              diffDist = dist3 - dist2 - dist1;
            }
          } else if (dist3 > dist2) {
            diffDist = dist3 - dist2 - dist1;
          } else {
            diffDist = dist2 - dist1 - dist3;
          }
          return diffDist > -1e-4 && diffDist < 1e-4;
        }
        var getBezierLength = /* @__PURE__ */ function() {
          return function(pt1, pt2, pt3, pt4) {
            var curveSegments = getDefaultCurveSegments();
            var k2;
            var i2;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point2 = [];
            var lastPoint = [];
            var lengthData = bezierLengthPool.newElement();
            len = pt3.length;
            for (k2 = 0; k2 < curveSegments; k2 += 1) {
              perc = k2 / (curveSegments - 1);
              ptDistance = 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * pt3[i2] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i2] + bmPow(perc, 3) * pt2[i2];
                point2[i2] = ptCoord;
                if (lastPoint[i2] !== null) {
                  ptDistance += bmPow(point2[i2] - lastPoint[i2], 2);
                }
                lastPoint[i2] = point2[i2];
              }
              if (ptDistance) {
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
              }
              lengthData.percents[k2] = perc;
              lengthData.lengths[k2] = addedLength;
            }
            lengthData.addedLength = addedLength;
            return lengthData;
          };
        }();
        function getSegmentsLength(shapeData) {
          var segmentsLength = segmentsLengthPool.newElement();
          var closed = shapeData.c;
          var pathV = shapeData.v;
          var pathO = shapeData.o;
          var pathI = shapeData.i;
          var i2;
          var len = shapeData._length;
          var lengths = segmentsLength.lengths;
          var totalLength = 0;
          for (i2 = 0; i2 < len - 1; i2 += 1) {
            lengths[i2] = getBezierLength(pathV[i2], pathV[i2 + 1], pathO[i2], pathI[i2 + 1]);
            totalLength += lengths[i2].addedLength;
          }
          if (closed && len) {
            lengths[i2] = getBezierLength(pathV[i2], pathV[0], pathO[i2], pathI[0]);
            totalLength += lengths[i2].addedLength;
          }
          segmentsLength.totalLength = totalLength;
          return segmentsLength;
        }
        function BezierData(length2) {
          this.segmentLength = 0;
          this.points = new Array(length2);
        }
        function PointData(partial, point2) {
          this.partialLength = partial;
          this.point = point2;
        }
        var buildBezierData = /* @__PURE__ */ function() {
          var storedData = {};
          return function(pt1, pt2, pt3, pt4) {
            var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
            if (!storedData[bezierName]) {
              var curveSegments = getDefaultCurveSegments();
              var k2;
              var i2;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point2;
              var lastPoint = null;
              if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                curveSegments = 2;
              }
              var bezierData = new BezierData(curveSegments);
              len = pt3.length;
              for (k2 = 0; k2 < curveSegments; k2 += 1) {
                point2 = createSizedArray(len);
                perc = k2 / (curveSegments - 1);
                ptDistance = 0;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i2] + pt3[i2]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i2] + pt4[i2]) + bmPow(perc, 3) * pt2[i2];
                  point2[i2] = ptCoord;
                  if (lastPoint !== null) {
                    ptDistance += bmPow(point2[i2] - lastPoint[i2], 2);
                  }
                }
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
                bezierData.points[k2] = new PointData(ptDistance, point2);
                lastPoint = point2;
              }
              bezierData.segmentLength = addedLength;
              storedData[bezierName] = bezierData;
            }
            return storedData[bezierName];
          };
        }();
        function getDistancePerc(perc, bezierData) {
          var percents = bezierData.percents;
          var lengths = bezierData.lengths;
          var len = percents.length;
          var initPos = bmFloor((len - 1) * perc);
          var lengthPos = perc * bezierData.addedLength;
          var lPerc = 0;
          if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
            return percents[initPos];
          }
          var dir = lengths[initPos] > lengthPos ? -1 : 1;
          var flag = true;
          while (flag) {
            if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
              lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
              flag = false;
            } else {
              initPos += dir;
            }
            if (initPos < 0 || initPos >= len - 1) {
              if (initPos === len - 1) {
                return percents[initPos];
              }
              flag = false;
            }
          }
          return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }
        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
          var t1 = getDistancePerc(percent, bezierData);
          var u1 = 1 - t1;
          var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
          var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
          return [ptX, ptY];
        }
        var bezierSegmentPoints = createTypedArray("float32", 8);
        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
          if (startPerc < 0) {
            startPerc = 0;
          } else if (startPerc > 1) {
            startPerc = 1;
          }
          var t0 = getDistancePerc(startPerc, bezierData);
          endPerc = endPerc > 1 ? 1 : endPerc;
          var t1 = getDistancePerc(endPerc, bezierData);
          var i2;
          var len = pt1.length;
          var u0 = 1 - t0;
          var u1 = 1 - t1;
          var u0u0u0 = u0 * u0 * u0;
          var t0u0u0_3 = t0 * u0 * u0 * 3;
          var t0t0u0_3 = t0 * t0 * u0 * 3;
          var t0t0t0 = t0 * t0 * t0;
          var u0u0u1 = u0 * u0 * u1;
          var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
          var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
          var t0t0t1 = t0 * t0 * t1;
          var u0u1u1 = u0 * u1 * u1;
          var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
          var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
          var t0t1t1 = t0 * t1 * t1;
          var u1u1u1 = u1 * u1 * u1;
          var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
          var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
          var t1t1t1 = t1 * t1 * t1;
          for (i2 = 0; i2 < len; i2 += 1) {
            bezierSegmentPoints[i2 * 4] = math.round((u0u0u0 * pt1[i2] + t0u0u0_3 * pt3[i2] + t0t0u0_3 * pt4[i2] + t0t0t0 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 1] = math.round((u0u0u1 * pt1[i2] + t0u0u1_3 * pt3[i2] + t0t0u1_3 * pt4[i2] + t0t0t1 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 2] = math.round((u0u1u1 * pt1[i2] + t0u1u1_3 * pt3[i2] + t0t1u1_3 * pt4[i2] + t0t1t1 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 3] = math.round((u1u1u1 * pt1[i2] + t1u1u1_3 * pt3[i2] + t1t1u1_3 * pt4[i2] + t1t1t1 * pt2[i2]) * 1e3) / 1e3;
          }
          return bezierSegmentPoints;
        }
        return {
          getSegmentsLength,
          getNewSegment,
          getPointInSegment,
          buildBezierData,
          pointOnLine2D,
          pointOnLine3D
        };
      }
      var bez = bezFunction();
      var initFrame = initialDefaultFrame;
      var mathAbs = Math.abs;
      function interpolateValue(frameNum, caching) {
        var offsetTime = this.offsetTime;
        var newValue;
        if (this.propType === "multidimensional") {
          newValue = createTypedArray("float32", this.pv.length);
        }
        var iterationIndex = caching.lastIndex;
        var i2 = iterationIndex;
        var len = this.keyframes.length - 1;
        var flag = true;
        var keyData;
        var nextKeyData;
        var keyframeMetadata;
        while (flag) {
          keyData = this.keyframes[i2];
          nextKeyData = this.keyframes[i2 + 1];
          if (i2 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
            if (keyData.h) {
              keyData = nextKeyData;
            }
            iterationIndex = 0;
            break;
          }
          if (nextKeyData.t - offsetTime > frameNum) {
            iterationIndex = i2;
            break;
          }
          if (i2 < len - 1) {
            i2 += 1;
          } else {
            iterationIndex = 0;
            flag = false;
          }
        }
        keyframeMetadata = this.keyframesMetadata[i2] || {};
        var k2;
        var kLen;
        var perc;
        var jLen;
        var j2;
        var fnc;
        var nextKeyTime = nextKeyData.t - offsetTime;
        var keyTime = keyData.t - offsetTime;
        var endValue;
        if (keyData.to) {
          if (!keyframeMetadata.bezierData) {
            keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
          }
          var bezierData = keyframeMetadata.bezierData;
          if (frameNum >= nextKeyTime || frameNum < keyTime) {
            var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
            kLen = bezierData.points[ind].point.length;
            for (k2 = 0; k2 < kLen; k2 += 1) {
              newValue[k2] = bezierData.points[ind].point[k2];
            }
          } else {
            if (keyframeMetadata.__fnct) {
              fnc = keyframeMetadata.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
              keyframeMetadata.__fnct = fnc;
            }
            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            var distanceInLine = bezierData.segmentLength * perc;
            var segmentPerc;
            var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastAddedLength : 0;
            j2 = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastPoint : 0;
            flag = true;
            jLen = bezierData.points.length;
            while (flag) {
              addedLength += bezierData.points[j2].partialLength;
              if (distanceInLine === 0 || perc === 0 || j2 === bezierData.points.length - 1) {
                kLen = bezierData.points[j2].point.length;
                for (k2 = 0; k2 < kLen; k2 += 1) {
                  newValue[k2] = bezierData.points[j2].point[k2];
                }
                break;
              } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j2 + 1].partialLength) {
                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j2 + 1].partialLength;
                kLen = bezierData.points[j2].point.length;
                for (k2 = 0; k2 < kLen; k2 += 1) {
                  newValue[k2] = bezierData.points[j2].point[k2] + (bezierData.points[j2 + 1].point[k2] - bezierData.points[j2].point[k2]) * segmentPerc;
                }
                break;
              }
              if (j2 < jLen - 1) {
                j2 += 1;
              } else {
                flag = false;
              }
            }
            caching._lastPoint = j2;
            caching._lastAddedLength = addedLength - bezierData.points[j2].partialLength;
            caching._lastKeyframeIndex = i2;
          }
        } else {
          var outX;
          var outY;
          var inX;
          var inY;
          var keyValue;
          len = keyData.s.length;
          endValue = nextKeyData.s || keyData.e;
          if (this.sh && keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              newValue[0] = endValue[0];
              newValue[1] = endValue[1];
              newValue[2] = endValue[2];
            } else if (frameNum <= keyTime) {
              newValue[0] = keyData.s[0];
              newValue[1] = keyData.s[1];
              newValue[2] = keyData.s[2];
            } else {
              var quatStart = createQuaternion(keyData.s);
              var quatEnd = createQuaternion(endValue);
              var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
              quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
            }
          } else {
            for (i2 = 0; i2 < len; i2 += 1) {
              if (keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  perc = 1;
                } else if (frameNum < keyTime) {
                  perc = 0;
                } else {
                  if (keyData.o.x.constructor === Array) {
                    if (!keyframeMetadata.__fnct) {
                      keyframeMetadata.__fnct = [];
                    }
                    if (!keyframeMetadata.__fnct[i2]) {
                      outX = keyData.o.x[i2] === void 0 ? keyData.o.x[0] : keyData.o.x[i2];
                      outY = keyData.o.y[i2] === void 0 ? keyData.o.y[0] : keyData.o.y[i2];
                      inX = keyData.i.x[i2] === void 0 ? keyData.i.x[0] : keyData.i.x[i2];
                      inY = keyData.i.y[i2] === void 0 ? keyData.i.y[0] : keyData.i.y[i2];
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyframeMetadata.__fnct[i2] = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct[i2];
                    }
                  } else if (!keyframeMetadata.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.keyframeMetadata = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                }
              }
              endValue = nextKeyData.s || keyData.e;
              keyValue = keyData.h === 1 ? keyData.s[i2] : keyData.s[i2] + (endValue[i2] - keyData.s[i2]) * perc;
              if (this.propType === "multidimensional") {
                newValue[i2] = keyValue;
              } else {
                newValue = keyValue;
              }
            }
          }
        }
        caching.lastIndex = iterationIndex;
        return newValue;
      }
      function slerp(a2, b2, t2) {
        var out = [];
        var ax = a2[0];
        var ay = a2[1];
        var az = a2[2];
        var aw = a2[3];
        var bx = b2[0];
        var by = b2[1];
        var bz = b2[2];
        var bw = b2[3];
        var omega;
        var cosom;
        var sinom;
        var scale0;
        var scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t2) * omega) / sinom;
          scale1 = Math.sin(t2 * omega) / sinom;
        } else {
          scale0 = 1 - t2;
          scale1 = t2;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
      function quaternionToEuler(out, quat) {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];
        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
        out[0] = heading / degToRads;
        out[1] = attitude / degToRads;
        out[2] = bank / degToRads;
      }
      function createQuaternion(values) {
        var heading = values[0] * degToRads;
        var attitude = values[1] * degToRads;
        var bank = values[2] * degToRads;
        var c1 = Math.cos(heading / 2);
        var c2 = Math.cos(attitude / 2);
        var c3 = Math.cos(bank / 2);
        var s1 = Math.sin(heading / 2);
        var s2 = Math.sin(attitude / 2);
        var s3 = Math.sin(bank / 2);
        var w2 = c1 * c2 * c3 - s1 * s2 * s3;
        var x3 = s1 * s2 * c3 + c1 * c2 * s3;
        var y3 = s1 * c2 * c3 + c1 * s2 * s3;
        var z2 = c1 * s2 * c3 - s1 * c2 * s3;
        return [x3, y3, z2, w2];
      }
      function getValueAtCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
          if (this._caching.lastFrame >= frameNum) {
            this._caching._lastKeyframeIndex = -1;
            this._caching.lastIndex = 0;
          }
          var renderResult = this.interpolateValue(frameNum, this._caching);
          this.pv = renderResult;
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function setVValue(val2) {
        var multipliedValue;
        if (this.propType === "unidimensional") {
          multipliedValue = val2 * this.mult;
          if (mathAbs(this.v - multipliedValue) > 1e-5) {
            this.v = multipliedValue;
            this._mdf = true;
          }
        } else {
          var i2 = 0;
          var len = this.v.length;
          while (i2 < len) {
            multipliedValue = val2[i2] * this.mult;
            if (mathAbs(this.v[i2] - multipliedValue) > 1e-5) {
              this.v[i2] = multipliedValue;
              this._mdf = true;
            }
            i2 += 1;
          }
        }
      }
      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = this._isFirstFrame;
        var i2;
        var len = this.effectsSequence.length;
        var finalValue = this.kf ? this.pv : this.data.k;
        for (i2 = 0; i2 < len; i2 += 1) {
          finalValue = this.effectsSequence[i2](finalValue);
        }
        this.setVValue(finalValue);
        this._isFirstFrame = false;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      function ValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this.v = mult ? data2.k * mult : data2.k;
        this.pv = data2.k;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.vel = 0;
        this.effectsSequence = [];
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function MultiDimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.frameId = -1;
        var i2;
        var len = data2.k.length;
        this.v = createTypedArray("float32", len);
        this.pv = createTypedArray("float32", len);
        this.vel = createTypedArray("float32", len);
        for (i2 = 0; i2 < len; i2 += 1) {
          this.v[i2] = data2.k[i2] * this.mult;
          this.pv[i2] = data2.k[i2];
        }
        this._isFirstFrame = true;
        this.effectsSequence = [];
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function KeyframedValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.frameId = -1;
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: 0,
          _lastKeyframeIndex: -1
        };
        this.k = true;
        this.kf = true;
        this.data = data2;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.v = initFrame;
        this.pv = initFrame;
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.addEffect = addEffect;
      }
      function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        var i2;
        var len = data2.k.length;
        var s2;
        var e3;
        var to;
        var ti;
        for (i2 = 0; i2 < len - 1; i2 += 1) {
          if (data2.k[i2].to && data2.k[i2].s && data2.k[i2 + 1] && data2.k[i2 + 1].s) {
            s2 = data2.k[i2].s;
            e3 = data2.k[i2 + 1].s;
            to = data2.k[i2].to;
            ti = data2.k[i2].ti;
            if (s2.length === 2 && !(s2[0] === e3[0] && s2[1] === e3[1]) && bez.pointOnLine2D(s2[0], s2[1], e3[0], e3[1], s2[0] + to[0], s2[1] + to[1]) && bez.pointOnLine2D(s2[0], s2[1], e3[0], e3[1], e3[0] + ti[0], e3[1] + ti[1]) || s2.length === 3 && !(s2[0] === e3[0] && s2[1] === e3[1] && s2[2] === e3[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e3[0], e3[1], e3[2], s2[0] + to[0], s2[1] + to[1], s2[2] + to[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e3[0], e3[1], e3[2], e3[0] + ti[0], e3[1] + ti[1], e3[2] + ti[2])) {
              data2.k[i2].to = null;
              data2.k[i2].ti = null;
            }
            if (s2[0] === e3[0] && s2[1] === e3[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
              if (s2.length === 2 || s2[2] === e3[2] && to[2] === 0 && ti[2] === 0) {
                data2.k[i2].to = null;
                data2.k[i2].ti = null;
              }
            }
          }
        }
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.data = data2;
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.k = true;
        this.kf = true;
        this._isFirstFrame = true;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.frameId = -1;
        var arrLen = data2.k[0].s.length;
        this.v = createTypedArray("float32", arrLen);
        this.pv = createTypedArray("float32", arrLen);
        for (i2 = 0; i2 < arrLen; i2 += 1) {
          this.v[i2] = initFrame;
          this.pv[i2] = initFrame;
        }
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", arrLen)
        };
        this.addEffect = addEffect;
      }
      var PropertyFactory = /* @__PURE__ */ function() {
        function getProp(elem2, data2, type, mult, container) {
          if (data2.sid) {
            data2 = elem2.globalData.slotManager.getProp(data2);
          }
          var p2;
          if (!data2.k.length) {
            p2 = new ValueProperty(elem2, data2, mult, container);
          } else if (typeof data2.k[0] === "number") {
            p2 = new MultiDimensionalProperty(elem2, data2, mult, container);
          } else {
            switch (type) {
              case 0:
                p2 = new KeyframedValueProperty(elem2, data2, mult, container);
                break;
              case 1:
                p2 = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
                break;
              default:
                break;
            }
          }
          if (p2.effectsSequence.length) {
            container.addDynamicProperty(p2);
          }
          return p2;
        }
        var ob2 = {
          getProp
        };
        return ob2;
      }();
      function DynamicPropertyContainer() {
      }
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
            this.container.addDynamicProperty(this);
            this._isAnimated = true;
          }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
          this._mdf = false;
          var i2;
          var len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.dynamicProperties[i2].getValue();
            if (this.dynamicProperties[i2]._mdf) {
              this._mdf = true;
            }
          }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
          this.container = container;
          this.dynamicProperties = [];
          this._mdf = false;
          this._isAnimated = false;
        }
      };
      var pointPool = function() {
        function create() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, create);
      }();
      function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
      }
      ShapePath.prototype.setPathData = function(closed, len) {
        this.c = closed;
        this.setLength(len);
        var i2 = 0;
        while (i2 < len) {
          this.v[i2] = pointPool.newElement();
          this.o[i2] = pointPool.newElement();
          this.i[i2] = pointPool.newElement();
          i2 += 1;
        }
      };
      ShapePath.prototype.setLength = function(len) {
        while (this._maxLength < len) {
          this.doubleArrayLength();
        }
        this._length = len;
      };
      ShapePath.prototype.doubleArrayLength = function() {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      };
      ShapePath.prototype.setXYAt = function(x3, y3, type, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);
        if (this._length >= this._maxLength) {
          this.doubleArrayLength();
        }
        switch (type) {
          case "v":
            arr = this.v;
            break;
          case "i":
            arr = this.i;
            break;
          case "o":
            arr = this.o;
            break;
          default:
            arr = [];
            break;
        }
        if (!arr[pos] || arr[pos] && !replace) {
          arr[pos] = pointPool.newElement();
        }
        arr[pos][0] = x3;
        arr[pos][1] = y3;
      };
      ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, "v", pos, replace);
        this.setXYAt(oX, oY, "o", pos, replace);
        this.setXYAt(iX, iY, "i", pos, replace);
      };
      ShapePath.prototype.reverse = function() {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;
        if (this.c) {
          newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
          init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;
        var i2;
        for (i2 = init; i2 < len; i2 += 1) {
          newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i2, false);
          cnt -= 1;
        }
        return newPath;
      };
      ShapePath.prototype.length = function() {
        return this._length;
      };
      var shapePool = function() {
        function create() {
          return new ShapePath();
        }
        function release(shapePath) {
          var len = shapePath._length;
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            pointPool.release(shapePath.v[i2]);
            pointPool.release(shapePath.i[i2]);
            pointPool.release(shapePath.o[i2]);
            shapePath.v[i2] = null;
            shapePath.i[i2] = null;
            shapePath.o[i2] = null;
          }
          shapePath._length = 0;
          shapePath.c = false;
        }
        function clone3(shape) {
          var cloned = factory.newElement();
          var i2;
          var len = shape._length === void 0 ? shape.v.length : shape._length;
          cloned.setLength(len);
          cloned.c = shape.c;
          for (i2 = 0; i2 < len; i2 += 1) {
            cloned.setTripleAt(shape.v[i2][0], shape.v[i2][1], shape.o[i2][0], shape.o[i2][1], shape.i[i2][0], shape.i[i2][1], i2);
          }
          return cloned;
        }
        var factory = poolFactory(4, create, release);
        factory.clone = clone3;
        return factory;
      }();
      function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
      }
      ShapeCollection.prototype.addShape = function(shapeData) {
        if (this._length === this._maxLength) {
          this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        }
        this.shapes[this._length] = shapeData;
        this._length += 1;
      };
      ShapeCollection.prototype.releaseShapes = function() {
        var i2;
        for (i2 = 0; i2 < this._length; i2 += 1) {
          shapePool.release(this.shapes[i2]);
        }
        this._length = 0;
      };
      var shapeCollectionPool = function() {
        var ob2 = {
          newShapeCollection,
          release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);
        function newShapeCollection() {
          var shapeCollection;
          if (_length) {
            _length -= 1;
            shapeCollection = pool[_length];
          } else {
            shapeCollection = new ShapeCollection();
          }
          return shapeCollection;
        }
        function release(shapeCollection) {
          var i2;
          var len = shapeCollection._length;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapePool.release(shapeCollection.shapes[i2]);
          }
          shapeCollection._length = 0;
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          pool[_length] = shapeCollection;
          _length += 1;
        }
        return ob2;
      }();
      var ShapePropertyFactory = function() {
        var initFrame2 = -999999;
        function interpolateShape(frameNum, previousValue, caching) {
          var iterationIndex = caching.lastIndex;
          var keyPropS;
          var keyPropE;
          var isHold;
          var j2;
          var k2;
          var jLen;
          var kLen;
          var perc;
          var vertexValue;
          var kf = this.keyframes;
          if (frameNum < kf[0].t - this.offsetTime) {
            keyPropS = kf[0].s[0];
            isHold = true;
            iterationIndex = 0;
          } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
            isHold = true;
          } else {
            var i2 = iterationIndex;
            var len = kf.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while (flag) {
              keyData = kf[i2];
              nextKeyData = kf[i2 + 1];
              if (nextKeyData.t - this.offsetTime > frameNum) {
                break;
              }
              if (i2 < len - 1) {
                i2 += 1;
              } else {
                flag = false;
              }
            }
            keyframeMetadata = this.keyframesMetadata[i2] || {};
            isHold = keyData.h === 1;
            iterationIndex = i2;
            if (!isHold) {
              if (frameNum >= nextKeyData.t - this.offsetTime) {
                perc = 1;
              } else if (frameNum < keyData.t - this.offsetTime) {
                perc = 0;
              } else {
                var fnc;
                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                  keyframeMetadata.__fnct = fnc;
                }
                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
              }
              keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
            }
            keyPropS = keyData.s[0];
          }
          jLen = previousValue._length;
          kLen = keyPropS.i[0].length;
          caching.lastIndex = iterationIndex;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            for (k2 = 0; k2 < kLen; k2 += 1) {
              vertexValue = isHold ? keyPropS.i[j2][k2] : keyPropS.i[j2][k2] + (keyPropE.i[j2][k2] - keyPropS.i[j2][k2]) * perc;
              previousValue.i[j2][k2] = vertexValue;
              vertexValue = isHold ? keyPropS.o[j2][k2] : keyPropS.o[j2][k2] + (keyPropE.o[j2][k2] - keyPropS.o[j2][k2]) * perc;
              previousValue.o[j2][k2] = vertexValue;
              vertexValue = isHold ? keyPropS.v[j2][k2] : keyPropS.v[j2][k2] + (keyPropE.v[j2][k2] - keyPropS.v[j2][k2]) * perc;
              previousValue.v[j2][k2] = vertexValue;
            }
          }
        }
        function interpolateShapeCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          var lastFrame = this._caching.lastFrame;
          if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
            this.interpolateShape(frameNum, this.pv, this._caching);
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function resetShape() {
          this.paths = this.localShapeCollection;
        }
        function shapesEqual(shape1, shape2) {
          if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
            return false;
          }
          var i2;
          var len = shape1._length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (shape1.v[i2][0] !== shape2.v[i2][0] || shape1.v[i2][1] !== shape2.v[i2][1] || shape1.o[i2][0] !== shape2.o[i2][0] || shape1.o[i2][1] !== shape2.o[i2][1] || shape1.i[i2][0] !== shape2.i[i2][0] || shape1.i[i2][1] !== shape2.i[i2][1]) {
              return false;
            }
          }
          return true;
        }
        function setVValue2(newPath) {
          if (!shapesEqual(this.v, newPath)) {
            this.v = shapePool.clone(newPath);
            this.localShapeCollection.releaseShapes();
            this.localShapeCollection.addShape(this.v);
            this._mdf = true;
            this.paths = this.localShapeCollection;
          }
        }
        function processEffectsSequence2() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (!this.effectsSequence.length) {
            this._mdf = false;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var finalValue;
          if (this.kf) {
            finalValue = this.pv;
          } else if (this.data.ks) {
            finalValue = this.data.ks.k;
          } else {
            finalValue = this.data.pt.k;
          }
          var i2;
          var len = this.effectsSequence.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            finalValue = this.effectsSequence[i2](finalValue);
          }
          this.setVValue(finalValue);
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.container = elem2;
          this.elem = elem2;
          this.data = data2;
          this.k = false;
          this.kf = false;
          this._mdf = false;
          var pathData = type === 3 ? data2.pt.k : data2.ks.k;
          this.v = shapePool.clone(pathData);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.reset = resetShape;
          this.effectsSequence = [];
        }
        function addEffect2(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence2;
        ShapeProperty.prototype.setVValue = setVValue2;
        ShapeProperty.prototype.addEffect = addEffect2;
        function KeyframedShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.elem = elem2;
          this.container = elem2;
          this.offsetTime = elem2.data.st;
          this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
          this.keyframesMetadata = [];
          this.k = true;
          this.kf = true;
          var len = this.keyframes[0].s[0].i.length;
          this.v = shapePool.newElement();
          this.v.setPathData(this.keyframes[0].s[0].c, len);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.lastFrame = initFrame2;
          this.reset = resetShape;
          this._caching = {
            lastFrame: initFrame2,
            lastIndex: 0
          };
          this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue2;
        KeyframedShapeProperty.prototype.addEffect = addEffect2;
        var EllShapeProperty = function() {
          var cPoint = roundCorner;
          function EllShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 4);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.localShapeCollection.addShape(this.v);
            this.d = data2.d;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertEllToPath();
            }
          }
          EllShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertEllToPath();
              }
            },
            convertEllToPath: function convertEllToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var s0 = this.s.v[0] / 2;
              var s1 = this.s.v[1] / 2;
              var _cw = this.d !== 3;
              var _v = this.v;
              _v.v[0][0] = p0;
              _v.v[0][1] = p1 - s1;
              _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.v[1][1] = p1;
              _v.v[2][0] = p0;
              _v.v[2][1] = p1 + s1;
              _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.v[3][1] = p1;
              _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.i[0][1] = p1 - s1;
              _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.i[1][1] = p1 - s1 * cPoint;
              _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.i[2][1] = p1 + s1;
              _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.i[3][1] = p1 + s1 * cPoint;
              _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.o[0][1] = p1 - s1;
              _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.o[1][1] = p1 + s1 * cPoint;
              _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.o[2][1] = p1 + s1;
              _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.o[3][1] = p1 - s1 * cPoint;
            }
          };
          extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
          return EllShapePropertyFactory;
        }();
        var StarShapeProperty = function() {
          function StarShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 0);
            this.elem = elem2;
            this.comp = elem2.comp;
            this.data = data2;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            if (data2.sy === 1) {
              this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
              this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
              this.convertToPath = this.convertStarToPath;
            } else {
              this.convertToPath = this.convertPolygonToPath;
            }
            this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
            this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
            this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertToPath();
            }
          }
          StarShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertToPath();
              }
            },
            convertStarToPath: function convertStarToPath() {
              var numPts = Math.floor(this.pt.v) * 2;
              var angle = Math.PI * 2 / numPts;
              var longFlag = true;
              var longRad = this.or.v;
              var shortRad = this.ir.v;
              var longRound = this.os.v;
              var shortRound = this.is.v;
              var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
              var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
              var i2;
              var rad;
              var roundness;
              var perimSegment;
              var currentAng = -Math.PI / 2;
              currentAng += this.r.v;
              var dir = this.data.d === 3 ? -1 : 1;
              this.v._length = 0;
              for (i2 = 0; i2 < numPts; i2 += 1) {
                rad = longFlag ? longRad : shortRad;
                roundness = longFlag ? longRound : shortRound;
                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                var x3 = rad * Math.cos(currentAng);
                var y3 = rad * Math.sin(currentAng);
                var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                x3 += +this.p.v[0];
                y3 += +this.p.v[1];
                this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i2, true);
                longFlag = !longFlag;
                currentAng += angle * dir;
              }
            },
            convertPolygonToPath: function convertPolygonToPath() {
              var numPts = Math.floor(this.pt.v);
              var angle = Math.PI * 2 / numPts;
              var rad = this.or.v;
              var roundness = this.os.v;
              var perimSegment = 2 * Math.PI * rad / (numPts * 4);
              var i2;
              var currentAng = -Math.PI * 0.5;
              var dir = this.data.d === 3 ? -1 : 1;
              currentAng += this.r.v;
              this.v._length = 0;
              for (i2 = 0; i2 < numPts; i2 += 1) {
                var x3 = rad * Math.cos(currentAng);
                var y3 = rad * Math.sin(currentAng);
                var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                x3 += +this.p.v[0];
                y3 += +this.p.v[1];
                this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i2, true);
                currentAng += angle * dir;
              }
              this.paths.length = 0;
              this.paths[0] = this.v;
            }
          };
          extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
          return StarShapePropertyFactory;
        }();
        var RectShapeProperty = function() {
          function RectShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.c = true;
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertRectToPath();
            }
          }
          RectShapePropertyFactory.prototype = {
            convertRectToPath: function convertRectToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var v0 = this.s.v[0] / 2;
              var v1 = this.s.v[1] / 2;
              var round = bmMin(v0, v1, this.r.v);
              var cPoint = round * (1 - roundCorner);
              this.v._length = 0;
              if (this.d === 2 || this.d === 1) {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                }
              } else {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                }
              }
            },
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertRectToPath();
              }
            },
            reset: resetShape
          };
          extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
          return RectShapePropertyFactory;
        }();
        function getShapeProp(elem2, data2, type) {
          var prop;
          if (type === 3 || type === 4) {
            var dataProp = type === 3 ? data2.pt : data2.ks;
            var keys2 = dataProp.k;
            if (keys2.length) {
              prop = new KeyframedShapeProperty(elem2, data2, type);
            } else {
              prop = new ShapeProperty(elem2, data2, type);
            }
          } else if (type === 5) {
            prop = new RectShapeProperty(elem2, data2);
          } else if (type === 6) {
            prop = new EllShapeProperty(elem2, data2);
          } else if (type === 7) {
            prop = new StarShapeProperty(elem2, data2);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        }
        function getConstructorFunction() {
          return ShapeProperty;
        }
        function getKeyframedConstructorFunction() {
          return KeyframedShapeProperty;
        }
        var ob2 = {};
        ob2.getShapeProp = getShapeProp;
        ob2.getConstructorFunction = getConstructorFunction;
        ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob2;
      }();
      var Matrix = /* @__PURE__ */ function() {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;
        function reset() {
          this.props[0] = 1;
          this.props[1] = 0;
          this.props[2] = 0;
          this.props[3] = 0;
          this.props[4] = 0;
          this.props[5] = 1;
          this.props[6] = 0;
          this.props[7] = 0;
          this.props[8] = 0;
          this.props[9] = 0;
          this.props[10] = 1;
          this.props[11] = 0;
          this.props[12] = 0;
          this.props[13] = 0;
          this.props[14] = 0;
          this.props[15] = 1;
          return this;
        }
        function rotate(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function rotateX(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }
        function rotateY(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }
        function rotateZ(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function shear(sx, sy) {
          return this._t(1, sy, sx, 1, 0, 0);
        }
        function skew(ax, ay) {
          return this.shear(_tan(ax), _tan(ay));
        }
        function skewFromAxis(ax, angle) {
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function scale3(sx, sy, sz) {
          if (!sz && sz !== 0) {
            sz = 1;
          }
          if (sx === 1 && sy === 1 && sz === 1) {
            return this;
          }
          return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }
        function setTransform(a2, b2, c2, d2, e3, f2, g3, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
          this.props[0] = a2;
          this.props[1] = b2;
          this.props[2] = c2;
          this.props[3] = d2;
          this.props[4] = e3;
          this.props[5] = f2;
          this.props[6] = g3;
          this.props[7] = h2;
          this.props[8] = i2;
          this.props[9] = j2;
          this.props[10] = k2;
          this.props[11] = l2;
          this.props[12] = m2;
          this.props[13] = n2;
          this.props[14] = o2;
          this.props[15] = p2;
          return this;
        }
        function translate(tx, ty, tz) {
          tz = tz || 0;
          if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
          }
          return this;
        }
        function transform2(a2, b2, c2, d2, e23, f2, g22, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
          var _p = this.props;
          if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e23 === 0 && f2 === 1 && g22 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
            _p[12] = _p[12] * a2 + _p[15] * m2;
            _p[13] = _p[13] * f2 + _p[15] * n2;
            _p[14] = _p[14] * k2 + _p[15] * o2;
            _p[15] *= p2;
            this._identityCalculated = false;
            return this;
          }
          var a1 = _p[0];
          var b1 = _p[1];
          var c1 = _p[2];
          var d1 = _p[3];
          var e1 = _p[4];
          var f1 = _p[5];
          var g1 = _p[6];
          var h1 = _p[7];
          var i1 = _p[8];
          var j1 = _p[9];
          var k1 = _p[10];
          var l1 = _p[11];
          var m1 = _p[12];
          var n1 = _p[13];
          var o1 = _p[14];
          var p1 = _p[15];
          _p[0] = a1 * a2 + b1 * e23 + c1 * i2 + d1 * m2;
          _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
          _p[2] = a1 * c2 + b1 * g22 + c1 * k2 + d1 * o2;
          _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
          _p[4] = e1 * a2 + f1 * e23 + g1 * i2 + h1 * m2;
          _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
          _p[6] = e1 * c2 + f1 * g22 + g1 * k2 + h1 * o2;
          _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
          _p[8] = i1 * a2 + j1 * e23 + k1 * i2 + l1 * m2;
          _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
          _p[10] = i1 * c2 + j1 * g22 + k1 * k2 + l1 * o2;
          _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
          _p[12] = m1 * a2 + n1 * e23 + o1 * i2 + p1 * m2;
          _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
          _p[14] = m1 * c2 + n1 * g22 + o1 * k2 + p1 * o2;
          _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
          this._identityCalculated = false;
          return this;
        }
        function multiply(matrix) {
          var matrixProps = matrix.props;
          return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
        }
        function isIdentity() {
          if (!this._identityCalculated) {
            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
            this._identityCalculated = true;
          }
          return this._identity;
        }
        function equals(matr) {
          var i2 = 0;
          while (i2 < 16) {
            if (matr.props[i2] !== this.props[i2]) {
              return false;
            }
            i2 += 1;
          }
          return true;
        }
        function clone3(matr) {
          var i2;
          for (i2 = 0; i2 < 16; i2 += 1) {
            matr.props[i2] = this.props[i2];
          }
          return matr;
        }
        function cloneFromProps(props) {
          var i2;
          for (i2 = 0; i2 < 16; i2 += 1) {
            this.props[i2] = props[i2];
          }
        }
        function applyToPoint(x3, y3, z2) {
          return {
            x: x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12],
            y: x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13],
            z: x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14]
          };
        }
        function applyToX(x3, y3, z2) {
          return x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12];
        }
        function applyToY(x3, y3, z2) {
          return x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13];
        }
        function applyToZ(x3, y3, z2) {
          return x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14];
        }
        function getInverseMatrix() {
          var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
          var a2 = this.props[5] / determinant;
          var b2 = -this.props[1] / determinant;
          var c2 = -this.props[4] / determinant;
          var d2 = this.props[0] / determinant;
          var e3 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
          var f2 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
          var inverseMatrix = new Matrix();
          inverseMatrix.props[0] = a2;
          inverseMatrix.props[1] = b2;
          inverseMatrix.props[4] = c2;
          inverseMatrix.props[5] = d2;
          inverseMatrix.props[12] = e3;
          inverseMatrix.props[13] = f2;
          return inverseMatrix;
        }
        function inversePoint(pt) {
          var inverseMatrix = this.getInverseMatrix();
          return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }
        function inversePoints(pts) {
          var i2;
          var len = pts.length;
          var retPts = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            retPts[i2] = inversePoint(pts[i2]);
          }
          return retPts;
        }
        function applyToTriplePoints(pt1, pt2, pt3) {
          var arr = createTypedArray("float32", 6);
          if (this.isIdentity()) {
            arr[0] = pt1[0];
            arr[1] = pt1[1];
            arr[2] = pt2[0];
            arr[3] = pt2[1];
            arr[4] = pt3[0];
            arr[5] = pt3[1];
          } else {
            var p0 = this.props[0];
            var p1 = this.props[1];
            var p4 = this.props[4];
            var p5 = this.props[5];
            var p12 = this.props[12];
            var p13 = this.props[13];
            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
          }
          return arr;
        }
        function applyToPointArray(x3, y3, z2) {
          var arr;
          if (this.isIdentity()) {
            arr = [x3, y3, z2];
          } else {
            arr = [x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12], x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13], x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14]];
          }
          return arr;
        }
        function applyToPointStringified(x3, y3) {
          if (this.isIdentity()) {
            return x3 + "," + y3;
          }
          var _p = this.props;
          return Math.round((x3 * _p[0] + y3 * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x3 * _p[1] + y3 * _p[5] + _p[13]) * 100) / 100;
        }
        function toCSS() {
          var i2 = 0;
          var props = this.props;
          var cssValue = "matrix3d(";
          var v2 = 1e4;
          while (i2 < 16) {
            cssValue += _rnd(props[i2] * v2) / v2;
            cssValue += i2 === 15 ? ")" : ",";
            i2 += 1;
          }
          return cssValue;
        }
        function roundMatrixProperty(val2) {
          var v2 = 1e4;
          if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
            return _rnd(val2 * v2) / v2;
          }
          return val2;
        }
        function to2dCSS() {
          var props = this.props;
          var _a = roundMatrixProperty(props[0]);
          var _b = roundMatrixProperty(props[1]);
          var _c = roundMatrixProperty(props[4]);
          var _d = roundMatrixProperty(props[5]);
          var _e = roundMatrixProperty(props[12]);
          var _f = roundMatrixProperty(props[13]);
          return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
        }
        return function() {
          this.reset = reset;
          this.rotate = rotate;
          this.rotateX = rotateX;
          this.rotateY = rotateY;
          this.rotateZ = rotateZ;
          this.skew = skew;
          this.skewFromAxis = skewFromAxis;
          this.shear = shear;
          this.scale = scale3;
          this.setTransform = setTransform;
          this.translate = translate;
          this.transform = transform2;
          this.multiply = multiply;
          this.applyToPoint = applyToPoint;
          this.applyToX = applyToX;
          this.applyToY = applyToY;
          this.applyToZ = applyToZ;
          this.applyToPointArray = applyToPointArray;
          this.applyToTriplePoints = applyToTriplePoints;
          this.applyToPointStringified = applyToPointStringified;
          this.toCSS = toCSS;
          this.to2dCSS = to2dCSS;
          this.clone = clone3;
          this.cloneFromProps = cloneFromProps;
          this.equals = equals;
          this.inversePoints = inversePoints;
          this.inversePoint = inversePoint;
          this.getInverseMatrix = getInverseMatrix;
          this._t = this.transform;
          this.isIdentity = isIdentity;
          this._identity = true;
          this._identityCalculated = false;
          this.props = createTypedArray("float32", 16);
          this.reset();
        };
      }();
      function _typeof$3(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$3 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$3 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$3(obj);
      }
      var lottie = {};
      var standalone = "__[STANDALONE]__";
      var animationData = "__[ANIMATIONDATA]__";
      var renderer = "";
      function setLocation(href) {
        setLocationHref(href);
      }
      function searchAnimations() {
        if (standalone === true) {
          animationManager.searchAnimations(animationData, standalone, renderer);
        } else {
          animationManager.searchAnimations();
        }
      }
      function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
      }
      function setPrefix(prefix) {
        setIdPrefix(prefix);
      }
      function loadAnimation(params) {
        if (standalone === true) {
          params.animationData = JSON.parse(animationData);
        }
        return animationManager.loadAnimation(params);
      }
      function setQuality(value2) {
        if (typeof value2 === "string") {
          switch (value2) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        } else if (!isNaN(value2) && value2 > 1) {
          setDefaultCurveSegments(value2);
        }
        if (getDefaultCurveSegments() >= 50) {
          roundValues(false);
        } else {
          roundValues(true);
        }
      }
      function inBrowser() {
        return typeof navigator !== "undefined";
      }
      function installPlugin(type, plugin) {
        if (type === "expressions") {
          setExpressionsPlugin(plugin);
        }
      }
      function getFactory(name2) {
        switch (name2) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      lottie.play = animationManager.play;
      lottie.pause = animationManager.pause;
      lottie.setLocationHref = setLocation;
      lottie.togglePause = animationManager.togglePause;
      lottie.setSpeed = animationManager.setSpeed;
      lottie.setDirection = animationManager.setDirection;
      lottie.stop = animationManager.stop;
      lottie.searchAnimations = searchAnimations;
      lottie.registerAnimation = animationManager.registerAnimation;
      lottie.loadAnimation = loadAnimation;
      lottie.setSubframeRendering = setSubframeRendering;
      lottie.resize = animationManager.resize;
      lottie.goToAndStop = animationManager.goToAndStop;
      lottie.destroy = animationManager.destroy;
      lottie.setQuality = setQuality;
      lottie.inBrowser = inBrowser;
      lottie.installPlugin = installPlugin;
      lottie.freeze = animationManager.freeze;
      lottie.unfreeze = animationManager.unfreeze;
      lottie.setVolume = animationManager.setVolume;
      lottie.mute = animationManager.mute;
      lottie.unmute = animationManager.unmute;
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
      lottie.useWebWorker = setWebWorker;
      lottie.setIDPrefix = setPrefix;
      lottie.__getFactory = getFactory;
      lottie.version = "5.12.2";
      function checkReady() {
        if (document.readyState === "complete") {
          clearInterval(readyStateCheckInterval);
          searchAnimations();
        }
      }
      function getQueryVariable(variable) {
        var vars = queryString.split("&");
        for (var i2 = 0; i2 < vars.length; i2 += 1) {
          var pair2 = vars[i2].split("=");
          if (decodeURIComponent(pair2[0]) == variable) {
            return decodeURIComponent(pair2[1]);
          }
        }
        return null;
      }
      var queryString = "";
      if (standalone) {
        var scripts = document.getElementsByTagName("script");
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
          src: ""
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
        renderer = getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        if (!((typeof exports === "undefined" ? "undefined" : _typeof$3(exports)) === "object" && typeof module !== "undefined") && !(typeof define === "function" && define.amd)) {
          window.bodymovin = lottie;
        }
      } catch (err) {
      }
      var ShapeModifiers = function() {
        var ob2 = {};
        var modifiers = {};
        ob2.registerModifier = registerModifier;
        ob2.getModifier = getModifier;
        function registerModifier(nm, factory) {
          if (!modifiers[nm]) {
            modifiers[nm] = factory;
          }
        }
        function getModifier(nm, elem2, data2) {
          return new modifiers[nm](elem2, data2);
        }
        return ob2;
      }();
      function ShapeModifier() {
      }
      ShapeModifier.prototype.initModifierProperties = function() {
      };
      ShapeModifier.prototype.addShapeToModifier = function() {
      };
      ShapeModifier.prototype.addShape = function(data2) {
        if (!this.closed) {
          data2.sh.container.addDynamicProperty(data2.sh);
          var shapeData = {
            shape: data2.sh,
            data: data2,
            localShapeCollection: shapeCollectionPool.newShapeCollection()
          };
          this.shapes.push(shapeData);
          this.addShapeToModifier(shapeData);
          if (this._isAnimated) {
            data2.setAsAnimated();
          }
        }
      };
      ShapeModifier.prototype.init = function(elem2, data2) {
        this.shapes = [];
        this.elem = elem2;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, data2);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      ShapeModifier.prototype.processKeys = function() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {
      }
      extendPrototype([ShapeModifier], TrimModifier);
      TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data2.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
      };
      TrimModifier.prototype.addShapeToModifier = function(shapeData) {
        shapeData.pathsData = [];
      };
      TrimModifier.prototype.calculateShapeEdges = function(s2, e3, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e3 <= 1) {
          segments.push({
            s: s2,
            e: e3
          });
        } else if (s2 >= 1) {
          segments.push({
            s: s2 - 1,
            e: e3 - 1
          });
        } else {
          segments.push({
            s: s2,
            e: 1
          });
          segments.push({
            s: 0,
            e: e3 - 1
          });
        }
        var shapeSegments = [];
        var i2;
        var len = segments.length;
        var segmentOb;
        for (i2 = 0; i2 < len; i2 += 1) {
          segmentOb = segments[i2];
          if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
            var shapeS;
            var shapeE;
            if (segmentOb.s * totalModifierLength <= addedLength) {
              shapeS = 0;
            } else {
              shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
            }
            if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
              shapeE = 1;
            } else {
              shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
            }
            shapeSegments.push([shapeS, shapeE]);
          }
        }
        if (!shapeSegments.length) {
          shapeSegments.push([0, 0]);
        }
        return shapeSegments;
      };
      TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i2;
        var len = pathsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          segmentsLengthPool.release(pathsData[i2]);
        }
        pathsData.length = 0;
        return pathsData;
      };
      TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s2;
        var e3;
        if (this._mdf || _isFirstFrame) {
          var o2 = this.o.v % 360 / 360;
          if (o2 < 0) {
            o2 += 1;
          }
          if (this.s.v > 1) {
            s2 = 1 + o2;
          } else if (this.s.v < 0) {
            s2 = 0 + o2;
          } else {
            s2 = this.s.v + o2;
          }
          if (this.e.v > 1) {
            e3 = 1 + o2;
          } else if (this.e.v < 0) {
            e3 = 0 + o2;
          } else {
            e3 = this.e.v + o2;
          }
          if (s2 > e3) {
            var _s = s2;
            s2 = e3;
            e3 = _s;
          }
          s2 = Math.round(s2 * 1e4) * 1e-4;
          e3 = Math.round(e3 * 1e4) * 1e-4;
          this.sValue = s2;
          this.eValue = e3;
        } else {
          s2 = this.sValue;
          e3 = this.eValue;
        }
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;
        if (e3 === s2) {
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].localShapeCollection.releaseShapes();
            this.shapes[i2].shape._mdf = true;
            this.shapes[i2].shape.paths = this.shapes[i2].localShapeCollection;
            if (this._mdf) {
              this.shapes[i2].pathsData.length = 0;
            }
          }
        } else if (!(e3 === 1 && s2 === 0 || e3 === 0 && s2 === 1)) {
          var segments = [];
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
              shapeData.shape.paths = shapeData.localShapeCollection;
            } else {
              shapePaths = shapeData.shape.paths;
              jLen = shapePaths._length;
              totalShapeLength = 0;
              if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                totalShapeLength = shapeData.totalShapeLength;
              } else {
                pathsData = this.releasePathsData(shapeData.pathsData);
                for (j2 = 0; j2 < jLen; j2 += 1) {
                  pathData = bez.getSegmentsLength(shapePaths.shapes[j2]);
                  pathsData.push(pathData);
                  totalShapeLength += pathData.totalLength;
                }
                shapeData.totalShapeLength = totalShapeLength;
                shapeData.pathsData = pathsData;
              }
              totalModifierLength += totalShapeLength;
              shapeData.shape._mdf = true;
            }
          }
          var shapeS = s2;
          var shapeE = e3;
          var addedLength = 0;
          var edges;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            shapeData = this.shapes[i2];
            if (shapeData.shape._mdf) {
              localShapeCollection = shapeData.localShapeCollection;
              localShapeCollection.releaseShapes();
              if (this.m === 2 && len > 1) {
                edges = this.calculateShapeEdges(s2, e3, shapeData.totalShapeLength, addedLength, totalModifierLength);
                addedLength += shapeData.totalShapeLength;
              } else {
                edges = [[shapeS, shapeE]];
              }
              jLen = edges.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                shapeS = edges[j2][0];
                shapeE = edges[j2][1];
                segments.length = 0;
                if (shapeE <= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength * shapeE
                  });
                } else if (shapeS >= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * (shapeS - 1),
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                } else {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength
                  });
                  segments.push({
                    s: 0,
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                }
                var newShapesData = this.addShapes(shapeData, segments[0]);
                if (segments[0].s !== segments[0].e) {
                  if (segments.length > 1) {
                    var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                    if (lastShapeInCollection.c) {
                      var lastShape = newShapesData.pop();
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                    } else {
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1]);
                    }
                  }
                  this.addPaths(newShapesData, localShapeCollection);
                }
              }
              shapeData.shape.paths = localShapeCollection;
            }
          }
        } else if (this._mdf) {
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].pathsData.length = 0;
            this.shapes[i2].shape._mdf = true;
          }
        }
      };
      TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i2;
        var len = newPaths.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          localShapeCollection.addShape(newPaths[i2]);
        }
      };
      TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
        shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
        }
        shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
      };
      TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], "o", pos);
        shapePath.setXYAt(points[2], points[6], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(points[0], points[4], "v", pos);
        }
        shapePath.setXYAt(points[3], points[7], "v", pos + 1);
      };
      TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i2;
        var len = shapeData.shape.paths._length;
        var j2;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
          shapePath = shapePool.newElement();
          segmentCount = 0;
          initPos = 0;
        } else {
          segmentCount = shapePath._length;
          initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for (i2 = 0; i2 < len; i2 += 1) {
          lengths = pathsData[i2].lengths;
          shapePath.c = shapePaths[i2].c;
          jLen = shapePaths[i2].c ? lengths.length : lengths.length + 1;
          for (j2 = 1; j2 < jLen; j2 += 1) {
            currentLengthData = lengths[j2 - 1];
            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
              addedLength += currentLengthData.addedLength;
              shapePath.c = false;
            } else if (addedLength > shapeSegment.e) {
              shapePath.c = false;
              break;
            } else {
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                this.addSegment(shapePaths[i2].v[j2 - 1], shapePaths[i2].o[j2 - 1], shapePaths[i2].i[j2], shapePaths[i2].v[j2], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i2].v[j2 - 1], shapePaths[i2].v[j2], shapePaths[i2].o[j2 - 1], shapePaths[i2].i[j2], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j2 - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
          }
          if (shapePaths[i2].c && lengths.length) {
            currentLengthData = lengths[j2 - 1];
            if (addedLength <= shapeSegment.e) {
              var segmentLength = lengths[j2 - 1].addedLength;
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                this.addSegment(shapePaths[i2].v[j2 - 1], shapePaths[i2].o[j2 - 1], shapePaths[i2].i[0], shapePaths[i2].v[0], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i2].v[j2 - 1], shapePaths[i2].v[0], shapePaths[i2].o[j2 - 1], shapePaths[i2].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j2 - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
            } else {
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
          if (shapePath._length) {
            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
          }
          if (addedLength > shapeSegment.e) {
            break;
          }
          if (i2 < len - 1) {
            shapePath = shapePool.newElement();
            newShape = true;
            shapes.push(shapePath);
            segmentCount = 0;
          }
        }
        return shapes;
      };
      function PuckerAndBloatModifier() {
      }
      extendPrototype([ShapeModifier], PuckerAndBloatModifier);
      PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
      };
      PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length;
        var i2 = 0;
        for (i2 = 0; i2 < pathLength; i2 += 1) {
          centerPoint[0] += path.v[i2][0];
          centerPoint[1] += path.v[i2][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i2 = 0; i2 < pathLength; i2 += 1) {
          vX = path.v[i2][0] + (centerPoint[0] - path.v[i2][0]) * percent;
          vY = path.v[i2][1] + (centerPoint[1] - path.v[i2][1]) * percent;
          oX = path.o[i2][0] + (centerPoint[0] - path.o[i2][0]) * -percent;
          oY = path.o[i2][1] + (centerPoint[1] - path.o[i2][1]) * -percent;
          iX = path.i[i2][0] + (centerPoint[0] - path.i[i2][0]) * -percent;
          iY = path.i[i2][1] + (centerPoint[1] - path.i[i2][1]) * -percent;
          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i2);
        }
        return clonedPath;
      };
      PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amount = this.amount.v;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amount));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      var TransformPropertyFactory = function() {
        var defaultVector = [0, 0];
        function applyToMatrix(mat) {
          var _mdf = this._mdf;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || _mdf;
          if (this.a) {
            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.s) {
            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk) {
            mat.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r) {
            mat.rotate(-this.r.v);
          } else {
            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.data.p.s) {
            if (this.data.p.z) {
              mat.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              mat.translate(this.px.v, this.py.v, 0);
            }
          } else {
            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        function processKeys(forceRender) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (this._isDirty) {
            this.precalculateMatrix();
            this._isDirty = false;
          }
          this.iterateDynamicProperties();
          if (this._mdf || forceRender) {
            var frameRate;
            this.v.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.appliedTransformations < 2) {
              this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk && this.appliedTransformations < 3) {
              this.v.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r && this.appliedTransformations < 4) {
              this.v.rotate(-this.r.v);
            } else if (!this.r && this.appliedTransformations < 4) {
              this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.autoOriented) {
              var v1;
              var v2;
              frameRate = this.elem.globalData.frameRate;
              if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                  v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                  v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                  v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                  v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                } else {
                  v1 = this.p.pv;
                  v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                }
              } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                v1 = [];
                v2 = [];
                var px = this.px;
                var py = this.py;
                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                  v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                  v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                  v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                  v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                  v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                  v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                  v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                } else {
                  v1 = [px.pv, py.pv];
                  v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                  v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                }
              } else {
                v2 = defaultVector;
                v1 = v2;
              }
              this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
            }
            if (this.data.p && this.data.p.s) {
              if (this.data.p.z) {
                this.v.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                this.v.translate(this.px.v, this.py.v, 0);
              }
            } else {
              this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          this.frameId = this.elem.globalData.frameId;
        }
        function precalculateMatrix() {
          this.appliedTransformations = 0;
          this.pre.reset();
          if (!this.a.effectsSequence.length) {
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            this.appliedTransformations = 1;
          } else {
            return;
          }
          if (!this.s.effectsSequence.length) {
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            this.appliedTransformations = 2;
          } else {
            return;
          }
          if (this.sk) {
            if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
              this.pre.skewFromAxis(-this.sk.v, this.sa.v);
              this.appliedTransformations = 3;
            } else {
              return;
            }
          }
          if (this.r) {
            if (!this.r.effectsSequence.length) {
              this.pre.rotate(-this.r.v);
              this.appliedTransformations = 4;
            }
          } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            this.appliedTransformations = 4;
          }
        }
        function autoOrient() {
        }
        function addDynamicProperty(prop) {
          this._addDynamicProperty(prop);
          this.elem.addDynamicProperty(prop);
          this._isDirty = true;
        }
        function TransformProperty(elem2, data2, container) {
          this.elem = elem2;
          this.frameId = -1;
          this.propType = "transform";
          this.data = data2;
          this.v = new Matrix();
          this.pre = new Matrix();
          this.appliedTransformations = 0;
          this.initDynamicPropertyContainer(container || elem2);
          if (data2.p && data2.p.s) {
            this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
            this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
            if (data2.p.z) {
              this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
            }
          } else {
            this.p = PropertyFactory.getProp(elem2, data2.p || {
              k: [0, 0, 0]
            }, 1, 0, this);
          }
          if (data2.rx) {
            this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
            this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
            this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
            if (data2.or.k[0].ti) {
              var i2;
              var len = data2.or.k.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                data2.or.k[i2].to = null;
                data2.or.k[i2].ti = null;
              }
            }
            this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
            this.or.sh = true;
          } else {
            this.r = PropertyFactory.getProp(elem2, data2.r || {
              k: 0
            }, 0, degToRads, this);
          }
          if (data2.sk) {
            this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
            this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
          }
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: [0, 0, 0]
          }, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: [100, 100, 100]
          }, 1, 0.01, this);
          if (data2.o) {
            this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
          } else {
            this.o = {
              _mdf: false,
              v: 1
            };
          }
          this._isDirty = true;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
        }
        TransformProperty.prototype = {
          applyToMatrix,
          getValue: processKeys,
          precalculateMatrix,
          autoOrient
        };
        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
        function getTransformProperty(elem2, data2, container) {
          return new TransformProperty(elem2, data2, container);
        }
        return {
          getTransformProperty
        };
      }();
      function RepeaterModifier() {
      }
      extendPrototype([ShapeModifier], RepeaterModifier);
      RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
        this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
        this.data = data2;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
      };
      RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
        var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
        pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
        rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        rMatrix.rotate(-transform2.r.v * dir * perc);
        rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
      };
      RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
        this.elem = elem2;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, arr[pos]);
        while (pos > 0) {
          pos -= 1;
          this._elements.unshift(arr[pos]);
        }
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      RepeaterModifier.prototype.resetElements = function(elements) {
        var i2;
        var len = elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          elements[i2]._processed = false;
          if (elements[i2].ty === "gr") {
            this.resetElements(elements[i2].it);
          }
        }
      };
      RepeaterModifier.prototype.cloneElements = function(elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
      };
      RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i2;
        var len = elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          elements[i2]._render = renderFlag;
          if (elements[i2].ty === "gr") {
            this.changeGroupRender(elements[i2].it, renderFlag);
          }
        }
      };
      RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items;
        var itemsTransform;
        var i2;
        var dir;
        var cont;
        var hasReloaded = false;
        if (this._mdf || _isFirstFrame) {
          var copies = Math.ceil(this.c.v);
          if (this._groups.length < copies) {
            while (this._groups.length < copies) {
              var group = {
                it: this.cloneElements(this._elements),
                ty: "gr"
              };
              group.it.push({
                a: {
                  a: 0,
                  ix: 1,
                  k: [0, 0]
                },
                nm: "Transform",
                o: {
                  a: 0,
                  ix: 7,
                  k: 100
                },
                p: {
                  a: 0,
                  ix: 2,
                  k: [0, 0]
                },
                r: {
                  a: 1,
                  ix: 6,
                  k: [{
                    s: 0,
                    e: 0,
                    t: 0
                  }, {
                    s: 0,
                    e: 0,
                    t: 1
                  }]
                },
                s: {
                  a: 0,
                  ix: 3,
                  k: [100, 100]
                },
                sa: {
                  a: 0,
                  ix: 5,
                  k: 0
                },
                sk: {
                  a: 0,
                  ix: 4,
                  k: 0
                },
                ty: "tr"
              });
              this.arr.splice(0, 0, group);
              this._groups.splice(0, 0, group);
              this._currentCopies += 1;
            }
            this.elem.reloadShapes();
            hasReloaded = true;
          }
          cont = 0;
          var renderFlag;
          for (i2 = 0; i2 <= this._groups.length - 1; i2 += 1) {
            renderFlag = cont < copies;
            this._groups[i2]._render = renderFlag;
            this.changeGroupRender(this._groups[i2].it, renderFlag);
            if (!renderFlag) {
              var elems = this.elemsData[i2].it;
              var transformData = elems[elems.length - 1];
              if (transformData.transform.op.v !== 0) {
                transformData.transform.op._mdf = true;
                transformData.transform.op.v = 0;
              } else {
                transformData.transform.op._mdf = false;
              }
            }
            cont += 1;
          }
          this._currentCopies = copies;
          var offset = this.o.v;
          var offsetModulo = offset % 1;
          var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
          var pProps = this.pMatrix.props;
          var rProps = this.rMatrix.props;
          var sProps = this.sMatrix.props;
          this.pMatrix.reset();
          this.rMatrix.reset();
          this.sMatrix.reset();
          this.tMatrix.reset();
          this.matrix.reset();
          var iteration = 0;
          if (offset > 0) {
            while (iteration < roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              iteration += 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
              iteration += offsetModulo;
            }
          } else if (offset < 0) {
            while (iteration > roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
              iteration -= 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
              iteration -= offsetModulo;
            }
          }
          i2 = this.data.m === 1 ? 0 : this._currentCopies - 1;
          dir = this.data.m === 1 ? 1 : -1;
          cont = this._currentCopies;
          var j2;
          var jLen;
          while (cont) {
            items = this.elemsData[i2].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            jLen = itemsTransform.length;
            items[items.length - 1].transform.mProps._mdf = true;
            items[items.length - 1].transform.op._mdf = true;
            items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i2 / (this._currentCopies - 1));
            if (iteration !== 0) {
              if (i2 !== 0 && dir === 1 || i2 !== this._currentCopies - 1 && dir === -1) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              }
              this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
              this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
              this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsTransform[j2] = this.matrix.props[j2];
              }
              this.matrix.reset();
            } else {
              this.matrix.reset();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsTransform[j2] = this.matrix.props[j2];
              }
            }
            iteration += 1;
            cont -= 1;
            i2 += dir;
          }
        } else {
          cont = this._currentCopies;
          i2 = 0;
          dir = 1;
          while (cont) {
            items = this.elemsData[i2].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            items[items.length - 1].transform.mProps._mdf = false;
            items[items.length - 1].transform.op._mdf = false;
            cont -= 1;
            i2 += dir;
          }
        }
        return hasReloaded;
      };
      RepeaterModifier.prototype.addShape = function() {
      };
      function RoundCornersModifier() {
      }
      extendPrototype([ShapeModifier], RoundCornersModifier);
      RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
      };
      RoundCornersModifier.prototype.processPath = function(path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i2;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance;
        var newPosPerc;
        var index2 = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i2 = 0; i2 < len; i2 += 1) {
          currentV = path.v[i2];
          currentO = path.o[i2];
          currentI = path.i[i2];
          if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
            if ((i2 === 0 || i2 === len - 1) && !path.c) {
              clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
              index2 += 1;
            } else {
              if (i2 === 0) {
                closerV = path.v[len - 1];
              } else {
                closerV = path.v[i2 - 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = iX;
              iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
              vY = iY;
              oX = vX - (vX - currentV[0]) * roundCorner;
              oY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
              if (i2 === len - 1) {
                closerV = path.v[0];
              } else {
                closerV = path.v[i2 + 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = oX;
              oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
              vY = oY;
              iX = vX - (vX - currentV[0]) * roundCorner;
              iY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
            }
          } else {
            clonedPath.setTripleAt(path.v[i2][0], path.v[i2][1], path.o[i2][0], path.o[i2][1], path.i[i2][0], path.i[i2][1], index2);
            index2 += 1;
          }
        }
        return clonedPath;
      };
      RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var rd = this.rd.v;
        if (rd !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], rd));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function floatEqual(a2, b2) {
        return Math.abs(a2 - b2) * 1e5 <= Math.min(Math.abs(a2), Math.abs(b2));
      }
      function floatZero(f2) {
        return Math.abs(f2) <= 1e-5;
      }
      function lerp(p0, p1, amount) {
        return p0 * (1 - amount) + p1 * amount;
      }
      function lerpPoint(p0, p1, amount) {
        return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
      }
      function quadRoots(a2, b2, c2) {
        if (a2 === 0) return [];
        var s2 = b2 * b2 - 4 * a2 * c2;
        if (s2 < 0) return [];
        var singleRoot = -b2 / (2 * a2);
        if (s2 === 0) return [singleRoot];
        var delta = Math.sqrt(s2) / (2 * a2);
        return [singleRoot - delta, singleRoot + delta];
      }
      function polynomialCoefficients(p0, p1, p2, p3) {
        return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
      }
      function singlePoint(p2) {
        return new PolynomialBezier(p2, p2, p2, p2, false);
      }
      function PolynomialBezier(p0, p1, p2, p3, linearize) {
        if (linearize && pointEqual(p0, p1)) {
          p1 = lerpPoint(p0, p3, 1 / 3);
        }
        if (linearize && pointEqual(p2, p3)) {
          p2 = lerpPoint(p0, p3, 2 / 3);
        }
        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
        this.a = [coeffx[0], coeffy[0]];
        this.b = [coeffx[1], coeffy[1]];
        this.c = [coeffx[2], coeffy[2]];
        this.d = [coeffx[3], coeffy[3]];
        this.points = [p0, p1, p2, p3];
      }
      PolynomialBezier.prototype.point = function(t2) {
        return [((this.a[0] * t2 + this.b[0]) * t2 + this.c[0]) * t2 + this.d[0], ((this.a[1] * t2 + this.b[1]) * t2 + this.c[1]) * t2 + this.d[1]];
      };
      PolynomialBezier.prototype.derivative = function(t2) {
        return [(3 * t2 * this.a[0] + 2 * this.b[0]) * t2 + this.c[0], (3 * t2 * this.a[1] + 2 * this.b[1]) * t2 + this.c[1]];
      };
      PolynomialBezier.prototype.tangentAngle = function(t2) {
        var p2 = this.derivative(t2);
        return Math.atan2(p2[1], p2[0]);
      };
      PolynomialBezier.prototype.normalAngle = function(t2) {
        var p2 = this.derivative(t2);
        return Math.atan2(p2[0], p2[1]);
      };
      PolynomialBezier.prototype.inflectionPoints = function() {
        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
        if (floatZero(denom)) return [];
        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
        if (square < 0) return [];
        var root = Math.sqrt(square);
        if (floatZero(root)) {
          if (root > 0 && root < 1) return [tcusp];
          return [];
        }
        return [tcusp - root, tcusp + root].filter(function(r2) {
          return r2 > 0 && r2 < 1;
        });
      };
      PolynomialBezier.prototype.split = function(t2) {
        if (t2 <= 0) return [singlePoint(this.points[0]), this];
        if (t2 >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
        var p10 = lerpPoint(this.points[0], this.points[1], t2);
        var p11 = lerpPoint(this.points[1], this.points[2], t2);
        var p12 = lerpPoint(this.points[2], this.points[3], t2);
        var p20 = lerpPoint(p10, p11, t2);
        var p21 = lerpPoint(p11, p12, t2);
        var p3 = lerpPoint(p20, p21, t2);
        return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
      };
      function extrema(bez2, comp2) {
        var min3 = bez2.points[0][comp2];
        var max3 = bez2.points[bez2.points.length - 1][comp2];
        if (min3 > max3) {
          var e3 = max3;
          max3 = min3;
          min3 = e3;
        }
        var f2 = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
        for (var i2 = 0; i2 < f2.length; i2 += 1) {
          if (f2[i2] > 0 && f2[i2] < 1) {
            var val2 = bez2.point(f2[i2])[comp2];
            if (val2 < min3) min3 = val2;
            else if (val2 > max3) max3 = val2;
          }
        }
        return {
          min: min3,
          max: max3
        };
      }
      PolynomialBezier.prototype.bounds = function() {
        return {
          x: extrema(this, 0),
          y: extrema(this, 1)
        };
      };
      PolynomialBezier.prototype.boundingBox = function() {
        var bounds = this.bounds();
        return {
          left: bounds.x.min,
          right: bounds.x.max,
          top: bounds.y.min,
          bottom: bounds.y.max,
          width: bounds.x.max - bounds.x.min,
          height: bounds.y.max - bounds.y.min,
          cx: (bounds.x.max + bounds.x.min) / 2,
          cy: (bounds.y.max + bounds.y.min) / 2
        };
      };
      function intersectData(bez2, t1, t2) {
        var box = bez2.boundingBox();
        return {
          cx: box.cx,
          cy: box.cy,
          width: box.width,
          height: box.height,
          bez: bez2,
          t: (t1 + t2) / 2,
          t1,
          t2
        };
      }
      function splitData(data2) {
        var split = data2.bez.split(0.5);
        return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
      }
      function boxIntersect(b1, b2) {
        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
      }
      function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
        if (!boxIntersect(d1, d2)) return;
        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
          intersections.push([d1.t, d2.t]);
          return;
        }
        var d1s = splitData(d1);
        var d2s = splitData(d2);
        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      }
      PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
        if (tolerance === void 0) tolerance = 2;
        if (maxRecursion === void 0) maxRecursion = 7;
        var intersections = [];
        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
        return intersections;
      };
      PolynomialBezier.shapeSegment = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
      };
      PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
      };
      function crossProduct(a2, b2) {
        return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
      }
      function lineIntersection(start1, end1, start2, end2) {
        var v1 = [start1[0], start1[1], 1];
        var v2 = [end1[0], end1[1], 1];
        var v3 = [start2[0], start2[1], 1];
        var v4 = [end2[0], end2[1], 1];
        var r2 = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
        if (floatZero(r2[2])) return null;
        return [r2[0] / r2[2], r2[1] / r2[2]];
      }
      function polarOffset(p2, angle, length2) {
        return [p2[0] + Math.cos(angle) * length2, p2[1] - Math.sin(angle) * length2];
      }
      function pointDistance(p1, p2) {
        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
      }
      function pointEqual(p1, p2) {
        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
      }
      function ZigZagModifier() {
      }
      extendPrototype([ShapeModifier], ZigZagModifier);
      ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
        this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
      };
      function setPoint(outputBezier, point2, angle, direction, amplitude, outAmplitude, inAmplitude) {
        var angO = angle - Math.PI / 2;
        var angI = angle + Math.PI / 2;
        var px = point2[0] + Math.cos(angle) * direction * amplitude;
        var py = point2[1] - Math.sin(angle) * direction * amplitude;
        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
      }
      function getPerpendicularVector(pt1, pt2) {
        var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
        var rot = -Math.PI * 0.5;
        var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
        return rotatedVector;
      }
      function getProjectingAngle(path, cur) {
        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
        var nextIndex = (cur + 1) % path.length();
        var prevPoint = path.v[prevIndex];
        var nextPoint = path.v[nextIndex];
        var pVector = getPerpendicularVector(prevPoint, nextPoint);
        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
      }
      function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
        var angle = getProjectingAngle(path, cur);
        var point2 = path.v[cur % path._length];
        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
        var nextPoint = path.v[(cur + 1) % path._length];
        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point2[0] - prevPoint[0], 2) + Math.pow(point2[1] - prevPoint[1], 2)) : 0;
        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point2[0] - nextPoint[0], 2) + Math.pow(point2[1] - nextPoint[1], 2)) : 0;
        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);
      }
      function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
        for (var i2 = 0; i2 < frequency; i2 += 1) {
          var t2 = (i2 + 1) / (frequency + 1);
          var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
          var angle = segment.normalAngle(t2);
          var point2 = segment.point(t2);
          setPoint(outputBezier, point2, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);
          direction = -direction;
        }
        return direction;
      }
      ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
        var count2 = path._length;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        if (!path.c) {
          count2 -= 1;
        }
        if (count2 === 0) return clonedPath;
        var direction = -1;
        var segment = PolynomialBezier.shapeSegment(path, 0);
        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
        for (var i2 = 0; i2 < count2; i2 += 1) {
          direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
          if (i2 === count2 - 1 && !path.c) {
            segment = null;
          } else {
            segment = PolynomialBezier.shapeSegment(path, (i2 + 1) % count2);
          }
          zigZagCorner(clonedPath, path, i2 + 1, amplitude, frequency, pointType, direction);
        }
        return clonedPath;
      };
      ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amplitude = this.amplitude.v;
        var frequency = Math.max(0, Math.round(this.frequency.v));
        var pointType = this.pointsType.v;
        if (amplitude !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amplitude, frequency, pointType));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function linearOffset(p1, p2, amount) {
        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
        return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
      }
      function offsetSegment(segment, amount) {
        var p0;
        var p1a;
        var p1b;
        var p2b;
        var p2a;
        var p3;
        var e3;
        e3 = linearOffset(segment.points[0], segment.points[1], amount);
        p0 = e3[0];
        p1a = e3[1];
        e3 = linearOffset(segment.points[1], segment.points[2], amount);
        p1b = e3[0];
        p2b = e3[1];
        e3 = linearOffset(segment.points[2], segment.points[3], amount);
        p2a = e3[0];
        p3 = e3[1];
        var p1 = lineIntersection(p0, p1a, p1b, p2b);
        if (p1 === null) p1 = p1a;
        var p2 = lineIntersection(p2a, p3, p1b, p2b);
        if (p2 === null) p2 = p2a;
        return new PolynomialBezier(p0, p1, p2, p3);
      }
      function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
        var p0 = seg1.points[3];
        var p1 = seg2.points[0];
        if (lineJoin === 3) return p0;
        if (pointEqual(p0, p1)) return p0;
        if (lineJoin === 2) {
          var angleOut = -seg1.tangentAngle(1);
          var angleIn = -seg2.tangentAngle(0) + Math.PI;
          var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
          var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
          var tan2 = polarOffset(p0, angleOut, 2 * radius * roundCorner);
          outputBezier.setXYAt(tan2[0], tan2[1], "o", outputBezier.length() - 1);
          tan2 = polarOffset(p1, angleIn, 2 * radius * roundCorner);
          outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan2[0], tan2[1], outputBezier.length());
          return p1;
        }
        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
        var intersection = lineIntersection(t0, p0, p1, t1);
        if (intersection && pointDistance(intersection, p0) < miterLimit) {
          outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
          return intersection;
        }
        return p0;
      }
      function getIntersection(a2, b2) {
        var intersect = a2.intersections(b2);
        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
        if (intersect.length) return intersect[0];
        return null;
      }
      function pruneSegmentIntersection(a2, b2) {
        var outa = a2.slice();
        var outb = b2.slice();
        var intersect = getIntersection(a2[a2.length - 1], b2[0]);
        if (intersect) {
          outa[a2.length - 1] = a2[a2.length - 1].split(intersect[0])[0];
          outb[0] = b2[0].split(intersect[1])[1];
        }
        if (a2.length > 1 && b2.length > 1) {
          intersect = getIntersection(a2[0], b2[b2.length - 1]);
          if (intersect) {
            return [[a2[0].split(intersect[0])[0]], [b2[b2.length - 1].split(intersect[1])[1]]];
          }
        }
        return [outa, outb];
      }
      function pruneIntersections(segments) {
        var e3;
        for (var i2 = 1; i2 < segments.length; i2 += 1) {
          e3 = pruneSegmentIntersection(segments[i2 - 1], segments[i2]);
          segments[i2 - 1] = e3[0];
          segments[i2] = e3[1];
        }
        if (segments.length > 1) {
          e3 = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
          segments[segments.length - 1] = e3[0];
          segments[0] = e3[1];
        }
        return segments;
      }
      function offsetSegmentSplit(segment, amount) {
        var flex = segment.inflectionPoints();
        var left;
        var right;
        var split;
        var mid;
        if (flex.length === 0) {
          return [offsetSegment(segment, amount)];
        }
        if (flex.length === 1 || floatEqual(flex[1], 1)) {
          split = segment.split(flex[0]);
          left = split[0];
          right = split[1];
          return [offsetSegment(left, amount), offsetSegment(right, amount)];
        }
        split = segment.split(flex[0]);
        left = split[0];
        var t2 = (flex[1] - flex[0]) / (1 - flex[0]);
        split = split[1].split(t2);
        mid = split[0];
        right = split[1];
        return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
      }
      function OffsetPathModifier() {
      }
      extendPrototype([ShapeModifier], OffsetPathModifier);
      OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
        this.lineJoin = data2.lj;
        this._isAnimated = this.amount.effectsSequence.length !== 0;
      };
      OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
        var outputBezier = shapePool.newElement();
        outputBezier.c = inputBezier.c;
        var count2 = inputBezier.length();
        if (!inputBezier.c) {
          count2 -= 1;
        }
        var i2;
        var j2;
        var segment;
        var multiSegments = [];
        for (i2 = 0; i2 < count2; i2 += 1) {
          segment = PolynomialBezier.shapeSegment(inputBezier, i2);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
        if (!inputBezier.c) {
          for (i2 = count2 - 1; i2 >= 0; i2 -= 1) {
            segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i2);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
        }
        multiSegments = pruneIntersections(multiSegments);
        var lastPoint = null;
        var lastSeg = null;
        for (i2 = 0; i2 < multiSegments.length; i2 += 1) {
          var multiSegment = multiSegments[i2];
          if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
          lastSeg = multiSegment[multiSegment.length - 1];
          for (j2 = 0; j2 < multiSegment.length; j2 += 1) {
            segment = multiSegment[j2];
            if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
              outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
            } else {
              outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
            }
            outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
            lastPoint = segment.points[3];
          }
        }
        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
        return outputBezier;
      };
      OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j2;
        var jLen;
        var amount = this.amount.v;
        var miterLimit = this.miterLimit.v;
        var lineJoin = this.lineJoin;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j2], amount, lineJoin, miterLimit));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
        var fWeight = "normal";
        var fStyle = "normal";
        var len = styles.length;
        var styleName;
        for (var i2 = 0; i2 < len; i2 += 1) {
          styleName = styles[i2].toLowerCase();
          switch (styleName) {
            case "italic":
              fStyle = "italic";
              break;
            case "bold":
              fWeight = "700";
              break;
            case "black":
              fWeight = "900";
              break;
            case "medium":
              fWeight = "500";
              break;
            case "regular":
            case "normal":
              fWeight = "400";
              break;
            case "light":
            case "thin":
              fWeight = "200";
              break;
            default:
              break;
          }
        }
        return {
          style: fStyle,
          weight: fontData.fWeight || fWeight
        };
      }
      var FontManager = function() {
        var maxWaitingTime = 5e3;
        var emptyChar = {
          w: 0,
          size: 0,
          shapes: [],
          data: {
            shapes: []
          }
        };
        var combinedCharacters = [];
        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
        var BLACK_FLAG_CODE_POINT = 127988;
        var CANCEL_TAG_CODE_POINT = 917631;
        var A_TAG_CODE_POINT = 917601;
        var Z_TAG_CODE_POINT = 917626;
        var VARIATION_SELECTOR_16_CODE_POINT = 65039;
        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
        var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function trimFontOptions(font) {
          var familyArray = font.split(",");
          var i2;
          var len = familyArray.length;
          var enabledFamilies = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            if (familyArray[i2] !== "sans-serif" && familyArray[i2] !== "monospace") {
              enabledFamilies.push(familyArray[i2]);
            }
          }
          return enabledFamilies.join(",");
        }
        function setUpNode(font, family) {
          var parentNode = createTag("span");
          parentNode.setAttribute("aria-hidden", true);
          parentNode.style.fontFamily = family;
          var node = createTag("span");
          node.innerText = "giItT1WQy@!-/#";
          parentNode.style.position = "absolute";
          parentNode.style.left = "-10000px";
          parentNode.style.top = "-10000px";
          parentNode.style.fontSize = "300px";
          parentNode.style.fontVariant = "normal";
          parentNode.style.fontStyle = "normal";
          parentNode.style.fontWeight = "normal";
          parentNode.style.letterSpacing = "0";
          parentNode.appendChild(node);
          document.body.appendChild(parentNode);
          var width2 = node.offsetWidth;
          node.style.fontFamily = trimFontOptions(font) + ", " + family;
          return {
            node,
            w: width2,
            parent: parentNode
          };
        }
        function checkLoadedFonts() {
          var i2;
          var len = this.fonts.length;
          var node;
          var w2;
          var loadedCount = len;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.fonts[i2].loaded) {
              loadedCount -= 1;
            } else if (this.fonts[i2].fOrigin === "n" || this.fonts[i2].origin === 0) {
              this.fonts[i2].loaded = true;
            } else {
              node = this.fonts[i2].monoCase.node;
              w2 = this.fonts[i2].monoCase.w;
              if (node.offsetWidth !== w2) {
                loadedCount -= 1;
                this.fonts[i2].loaded = true;
              } else {
                node = this.fonts[i2].sansCase.node;
                w2 = this.fonts[i2].sansCase.w;
                if (node.offsetWidth !== w2) {
                  loadedCount -= 1;
                  this.fonts[i2].loaded = true;
                }
              }
              if (this.fonts[i2].loaded) {
                this.fonts[i2].sansCase.parent.parentNode.removeChild(this.fonts[i2].sansCase.parent);
                this.fonts[i2].monoCase.parent.parentNode.removeChild(this.fonts[i2].monoCase.parent);
              }
            }
          }
          if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
            setTimeout(this.checkLoadedFontsBinded, 20);
          } else {
            setTimeout(this.setIsLoadedBinded, 10);
          }
        }
        function createHelper(fontData, def) {
          var engine = document.body && def ? "svg" : "canvas";
          var helper;
          var fontProps = getFontProperties(fontData);
          if (engine === "svg") {
            var tHelper = createNS("text");
            tHelper.style.fontSize = "100px";
            tHelper.setAttribute("font-family", fontData.fFamily);
            tHelper.setAttribute("font-style", fontProps.style);
            tHelper.setAttribute("font-weight", fontProps.weight);
            tHelper.textContent = "1";
            if (fontData.fClass) {
              tHelper.style.fontFamily = "inherit";
              tHelper.setAttribute("class", fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            helper = tHelper;
          } else {
            var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
            tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
            helper = tCanvasHelper;
          }
          function measure(text2) {
            if (engine === "svg") {
              helper.textContent = text2;
              return helper.getComputedTextLength();
            }
            return helper.measureText(text2).width;
          }
          return {
            measureText: measure
          };
        }
        function addFonts(fontData, defs) {
          if (!fontData) {
            this.isLoaded = true;
            return;
          }
          if (this.chars) {
            this.isLoaded = true;
            this.fonts = fontData.list;
            return;
          }
          if (!document.body) {
            this.isLoaded = true;
            fontData.list.forEach(function(data2) {
              data2.helper = createHelper(data2);
              data2.cache = {};
            });
            this.fonts = fontData.list;
            return;
          }
          var fontArr = fontData.list;
          var i2;
          var len = fontArr.length;
          var _pendingFonts = len;
          for (i2 = 0; i2 < len; i2 += 1) {
            var shouldLoadFont = true;
            var loadedSelector;
            var j2;
            fontArr[i2].loaded = false;
            fontArr[i2].monoCase = setUpNode(fontArr[i2].fFamily, "monospace");
            fontArr[i2].sansCase = setUpNode(fontArr[i2].fFamily, "sans-serif");
            if (!fontArr[i2].fPath) {
              fontArr[i2].loaded = true;
              _pendingFonts -= 1;
            } else if (fontArr[i2].fOrigin === "p" || fontArr[i2].origin === 3) {
              loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i2].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i2].fFamily + '"]');
              if (loadedSelector.length > 0) {
                shouldLoadFont = false;
              }
              if (shouldLoadFont) {
                var s2 = createTag("style");
                s2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                s2.setAttribute("f-origin", fontArr[i2].origin);
                s2.setAttribute("f-family", fontArr[i2].fFamily);
                s2.type = "text/css";
                s2.innerText = "@font-face {font-family: " + fontArr[i2].fFamily + "; font-style: normal; src: url('" + fontArr[i2].fPath + "');}";
                defs.appendChild(s2);
              }
            } else if (fontArr[i2].fOrigin === "g" || fontArr[i2].origin === 1) {
              loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
              for (j2 = 0; j2 < loadedSelector.length; j2 += 1) {
                if (loadedSelector[j2].href.indexOf(fontArr[i2].fPath) !== -1) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var l2 = createTag("link");
                l2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                l2.setAttribute("f-origin", fontArr[i2].origin);
                l2.type = "text/css";
                l2.rel = "stylesheet";
                l2.href = fontArr[i2].fPath;
                document.body.appendChild(l2);
              }
            } else if (fontArr[i2].fOrigin === "t" || fontArr[i2].origin === 2) {
              loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
              for (j2 = 0; j2 < loadedSelector.length; j2 += 1) {
                if (fontArr[i2].fPath === loadedSelector[j2].src) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var sc = createTag("link");
                sc.setAttribute("f-forigin", fontArr[i2].fOrigin);
                sc.setAttribute("f-origin", fontArr[i2].origin);
                sc.setAttribute("rel", "stylesheet");
                sc.setAttribute("href", fontArr[i2].fPath);
                defs.appendChild(sc);
              }
            }
            fontArr[i2].helper = createHelper(fontArr[i2], defs);
            fontArr[i2].cache = {};
            this.fonts.push(fontArr[i2]);
          }
          if (_pendingFonts === 0) {
            this.isLoaded = true;
          } else {
            setTimeout(this.checkLoadedFonts.bind(this), 100);
          }
        }
        function addChars(chars) {
          if (!chars) {
            return;
          }
          if (!this.chars) {
            this.chars = [];
          }
          var i2;
          var len = chars.length;
          var j2;
          var jLen = this.chars.length;
          var found;
          for (i2 = 0; i2 < len; i2 += 1) {
            j2 = 0;
            found = false;
            while (j2 < jLen) {
              if (this.chars[j2].style === chars[i2].style && this.chars[j2].fFamily === chars[i2].fFamily && this.chars[j2].ch === chars[i2].ch) {
                found = true;
              }
              j2 += 1;
            }
            if (!found) {
              this.chars.push(chars[i2]);
              jLen += 1;
            }
          }
        }
        function getCharData(_char, style, font) {
          var i2 = 0;
          var len = this.chars.length;
          while (i2 < len) {
            if (this.chars[i2].ch === _char && this.chars[i2].style === style && this.chars[i2].fFamily === font) {
              return this.chars[i2];
            }
            i2 += 1;
          }
          if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
            this._warned = true;
            console.warn("Missing character from exported characters list: ", _char, style, font);
          }
          return emptyChar;
        }
        function measureText(_char2, fontName, size) {
          var fontData = this.getFontByName(fontName);
          var index2 = _char2;
          if (!fontData.cache[index2]) {
            var tHelper = fontData.helper;
            if (_char2 === " ") {
              var doubleSize = tHelper.measureText("|" + _char2 + "|");
              var singleSize = tHelper.measureText("||");
              fontData.cache[index2] = (doubleSize - singleSize) / 100;
            } else {
              fontData.cache[index2] = tHelper.measureText(_char2) / 100;
            }
          }
          return fontData.cache[index2] * size;
        }
        function getFontByName(name2) {
          var i2 = 0;
          var len = this.fonts.length;
          while (i2 < len) {
            if (this.fonts[i2].fName === name2) {
              return this.fonts[i2];
            }
            i2 += 1;
          }
          return this.fonts[0];
        }
        function getCodePoint(string) {
          var codePoint = 0;
          var first = string.charCodeAt(0);
          if (first >= 55296 && first <= 56319) {
            var second = string.charCodeAt(1);
            if (second >= 56320 && second <= 57343) {
              codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            }
          }
          return codePoint;
        }
        function isModifier(firstCharCode, secondCharCode) {
          var sum4 = firstCharCode.toString(16) + secondCharCode.toString(16);
          return surrogateModifiers.indexOf(sum4) !== -1;
        }
        function isZeroWidthJoiner(charCode) {
          return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
        }
        function isVariationSelector(charCode) {
          return charCode === VARIATION_SELECTOR_16_CODE_POINT;
        }
        function isRegionalCode(string) {
          var codePoint = getCodePoint(string);
          if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
            return true;
          }
          return false;
        }
        function isFlagEmoji(string) {
          return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
        }
        function isCombinedCharacter(_char3) {
          return combinedCharacters.indexOf(_char3) !== -1;
        }
        function isRegionalFlag(text2, index2) {
          var codePoint = getCodePoint(text2.substr(index2, 2));
          if (codePoint !== BLACK_FLAG_CODE_POINT) {
            return false;
          }
          var count2 = 0;
          index2 += 2;
          while (count2 < 5) {
            codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
              return false;
            }
            count2 += 1;
            index2 += 2;
          }
          return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
        }
        function setIsLoaded() {
          this.isLoaded = true;
        }
        var Font = function Font2() {
          this.fonts = [];
          this.chars = null;
          this.typekitLoaded = 0;
          this.isLoaded = false;
          this._warned = false;
          this.initTime = Date.now();
          this.setIsLoadedBinded = this.setIsLoaded.bind(this);
          this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isFlagEmoji = isFlagEmoji;
        Font.isRegionalCode = isRegionalCode;
        Font.isCombinedCharacter = isCombinedCharacter;
        Font.isRegionalFlag = isRegionalFlag;
        Font.isVariationSelector = isVariationSelector;
        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
        var fontPrototype = {
          addChars,
          addFonts,
          getCharData,
          getFontByName,
          measureText,
          checkLoadedFonts,
          setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
      }();
      function SlotManager(animationData2) {
        this.animationData = animationData2;
      }
      SlotManager.prototype.getProp = function(data2) {
        if (this.animationData.slots && this.animationData.slots[data2.sid]) {
          return Object.assign(data2, this.animationData.slots[data2.sid].p);
        }
        return data2;
      };
      function slotFactory(animationData2) {
        return new SlotManager(animationData2);
      }
      function RenderableElement() {
      }
      RenderableElement.prototype = {
        initRenderable: function initRenderable() {
          this.isInRange = false;
          this.hidden = false;
          this.isTransparent = false;
          this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) === -1) {
            this.renderableComponents.push(component);
          }
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) !== -1) {
            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
          }
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
          this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
          if (this.finalTransform.mProp.o.v <= 0) {
            if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
              this.isTransparent = true;
              this.hide();
            }
          } else if (this.isTransparent) {
            this.isTransparent = false;
            this.show();
          }
        },
        /**
           * @function
           * Initializes frame related properties.
           *
           * @param {number} num
           * current frame number in Layer's time
           *
           */
        checkLayerLimits: function checkLayerLimits(num) {
          if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
            if (this.isInRange !== true) {
              this.globalData._mdf = true;
              this._mdf = true;
              this.isInRange = true;
              this.show();
            }
          } else if (this.isInRange !== false) {
            this.globalData._mdf = true;
            this.isInRange = false;
            this.hide();
          }
        },
        renderRenderable: function renderRenderable() {
          var i2;
          var len = this.renderableComponents.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.renderableComponents[i2].renderFrame(this._isFirstFrame);
          }
        },
        sourceRectAtTime: function sourceRectAtTime2() {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100
          };
        },
        getLayerSize: function getLayerSize() {
          if (this.data.ty === 5) {
            return {
              w: this.data.textData.width,
              h: this.data.textData.height
            };
          }
          return {
            w: this.data.width,
            h: this.data.height
          };
        }
      };
      var getBlendMode = /* @__PURE__ */ function() {
        var blendModeEnums = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity"
        };
        return function(mode2) {
          return blendModeEnums[mode2] || "";
        };
      }();
      function SliderEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function AngleEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function ColorEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function PointEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function LayerIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function MaskIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function CheckboxEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(data2, element) {
        var effects = data2.ef || [];
        this.effectElements = [];
        var i2;
        var len = effects.length;
        var effectItem;
        for (i2 = 0; i2 < len; i2 += 1) {
          effectItem = new GroupEffect(effects[i2], element);
          this.effectElements.push(effectItem);
        }
      }
      function GroupEffect(data2, element) {
        this.init(data2, element);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect);
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
      GroupEffect.prototype.init = function(data2, element) {
        this.data = data2;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i2;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;
        for (i2 = 0; i2 < len; i2 += 1) {
          eff = null;
          switch (effects[i2].ty) {
            case 0:
              eff = new SliderEffect(effects[i2], element, this);
              break;
            case 1:
              eff = new AngleEffect(effects[i2], element, this);
              break;
            case 2:
              eff = new ColorEffect(effects[i2], element, this);
              break;
            case 3:
              eff = new PointEffect(effects[i2], element, this);
              break;
            case 4:
            case 7:
              eff = new CheckboxEffect(effects[i2], element, this);
              break;
            case 10:
              eff = new LayerIndexEffect(effects[i2], element, this);
              break;
            case 11:
              eff = new MaskIndexEffect(effects[i2], element, this);
              break;
            case 5:
              eff = new EffectsManager(effects[i2], element, this);
              break;
            // case 6:
            default:
              eff = new NoValueEffect(effects[i2], element, this);
              break;
          }
          if (eff) {
            this.effectElements.push(eff);
          }
        }
      };
      function BaseElement() {
      }
      BaseElement.prototype = {
        checkMasks: function checkMasks() {
          if (!this.data.hasMask) {
            return false;
          }
          var i2 = 0;
          var len = this.data.masksProperties.length;
          while (i2 < len) {
            if (this.data.masksProperties[i2].mode !== "n" && this.data.masksProperties[i2].cl !== false) {
              return true;
            }
            i2 += 1;
          }
          return false;
        },
        initExpressions: function initExpressions() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var LayerExpressionInterface2 = expressionsInterfaces2("layer");
          var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
          var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
          var TextExpressionInterface2 = expressionsInterfaces2("text");
          var CompExpressionInterface2 = expressionsInterfaces2("comp");
          this.layerInterface = LayerExpressionInterface2(this);
          if (this.data.hasMask && this.maskManager) {
            this.layerInterface.registerMaskInterface(this.maskManager);
          }
          var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(effectsInterface);
          if (this.data.ty === 0 || this.data.xt) {
            this.compInterface = CompExpressionInterface2(this);
          } else if (this.data.ty === 4) {
            this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
            this.layerInterface.content = this.layerInterface.shapeInterface;
          } else if (this.data.ty === 5) {
            this.layerInterface.textInterface = TextExpressionInterface2(this);
            this.layerInterface.text = this.layerInterface.textInterface;
          }
        },
        setBlendMode: function setBlendMode() {
          var blendModeValue = getBlendMode(this.data.bm);
          var elem2 = this.baseElement || this.layerElement;
          elem2.style["mix-blend-mode"] = blendModeValue;
        },
        initBaseData: function initBaseData(data2, globalData2, comp2) {
          this.globalData = globalData2;
          this.comp = comp2;
          this.data = data2;
          this.layerId = createElementID();
          if (!this.data.sr) {
            this.data.sr = 1;
          }
          this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType2() {
          return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime2() {
        }
      };
      function FrameElement() {
      }
      FrameElement.prototype = {
        /**
           * @function
           * Initializes frame related properties.
           *
           */
        initFrame: function initFrame2() {
          this._isFirstFrame = false;
          this.dynamicProperties = [];
          this._mdf = false;
        },
        /**
           * @function
           * Calculates all dynamic values
           *
           * @param {number} num
           * current frame number in Layer's time
           * @param {boolean} isVisible
           * if layers is currently in range
           *
           */
        prepareProperties: function prepareProperties(num, isVisible) {
          var i2;
          var len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (isVisible || this._isParent && this.dynamicProperties[i2].propType === "transform") {
              this.dynamicProperties[i2].getValue();
              if (this.dynamicProperties[i2]._mdf) {
                this.globalData._mdf = true;
                this._mdf = true;
              }
            }
          }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
          }
        }
      };
      function FootageElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.footageData = globalData2.imageLoader.getAsset(this.assetData);
        this.initBaseData(data2, globalData2, comp2);
      }
      FootageElement.prototype.prepareFrame = function() {
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
      FootageElement.prototype.getBaseElement = function() {
        return null;
      };
      FootageElement.prototype.renderFrame = function() {
      };
      FootageElement.prototype.destroy = function() {
      };
      FootageElement.prototype.initExpressions = function() {
        var expressionsInterfaces2 = getExpressionInterfaces();
        if (!expressionsInterfaces2) {
          return;
        }
        var FootageInterface2 = expressionsInterfaces2("footage");
        this.layerInterface = FootageInterface2(this);
      };
      FootageElement.prototype.getFootageData = function() {
        return this.footageData;
      };
      function AudioElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initBaseData(data2, globalData2, comp2);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
          k: [100]
        }, 1, 0.01, this);
      }
      AudioElement.prototype.prepareFrame = function(num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          this._currentTime = timeRemapped;
        } else {
          this._currentTime = num / this.data.sr;
        }
        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;
        if (this._previousVolume !== totalVolume) {
          this._previousVolume = totalVolume;
          this.audio.volume(totalVolume);
        }
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
      AudioElement.prototype.renderFrame = function() {
        if (this.isInRange && this._canPlay) {
          if (!this._isPlaying) {
            this.audio.play();
            this.audio.seek(this._currentTime / this.globalData.frameRate);
            this._isPlaying = true;
          } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
            this.audio.seek(this._currentTime / this.globalData.frameRate);
          }
        }
      };
      AudioElement.prototype.show = function() {
      };
      AudioElement.prototype.hide = function() {
        this.audio.pause();
        this._isPlaying = false;
      };
      AudioElement.prototype.pause = function() {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
      };
      AudioElement.prototype.resume = function() {
        this._canPlay = true;
      };
      AudioElement.prototype.setRate = function(rateValue) {
        this.audio.rate(rateValue);
      };
      AudioElement.prototype.volume = function(volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
      };
      AudioElement.prototype.getBaseElement = function() {
        return null;
      };
      AudioElement.prototype.destroy = function() {
      };
      AudioElement.prototype.sourceRectAtTime = function() {
      };
      AudioElement.prototype.initExpressions = function() {
      };
      function BaseRenderer() {
      }
      BaseRenderer.prototype.checkLayers = function(num) {
        var i2;
        var len = this.layers.length;
        var data2;
        this.completeLayers = true;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (!this.elements[i2]) {
            data2 = this.layers[i2];
            if (data2.ip - data2.st <= num - this.layers[i2].st && data2.op - data2.st > num - this.layers[i2].st) {
              this.buildItem(i2);
            }
          }
          this.completeLayers = this.elements[i2] ? this.completeLayers : false;
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.createItem = function(layer) {
        switch (layer.ty) {
          case 2:
            return this.createImage(layer);
          case 0:
            return this.createComp(layer);
          case 1:
            return this.createSolid(layer);
          case 3:
            return this.createNull(layer);
          case 4:
            return this.createShape(layer);
          case 5:
            return this.createText(layer);
          case 6:
            return this.createAudio(layer);
          case 13:
            return this.createCamera(layer);
          case 15:
            return this.createFootage(layer);
          default:
            return this.createNull(layer);
        }
      };
      BaseRenderer.prototype.createCamera = function() {
        throw new Error("You're using a 3d camera. Try the html renderer.");
      };
      BaseRenderer.prototype.createAudio = function(data2) {
        return new AudioElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.createFootage = function(data2) {
        return new FootageElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.buildAllItems = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.buildItem(i2);
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.includeLayers = function(newLayers) {
        this.completeLayers = false;
        var i2;
        var len = newLayers.length;
        var j2;
        var jLen = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          j2 = 0;
          while (j2 < jLen) {
            if (this.layers[j2].id === newLayers[i2].id) {
              this.layers[j2] = newLayers[i2];
              break;
            }
            j2 += 1;
          }
        }
      };
      BaseRenderer.prototype.setProjectInterface = function(pInterface) {
        this.globalData.projectInterface = pInterface;
      };
      BaseRenderer.prototype.initItems = function() {
        if (!this.globalData.progressiveLoad) {
          this.buildAllItems();
        }
      };
      BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy2) {
        var elements = this.elements;
        var layers = this.layers;
        var i2 = 0;
        var len = layers.length;
        while (i2 < len) {
          if (layers[i2].ind == parentName) {
            if (!elements[i2] || elements[i2] === true) {
              this.buildItem(i2);
              this.addPendingElement(element);
            } else {
              hierarchy2.push(elements[i2]);
              elements[i2].setAsParent();
              if (layers[i2].parent !== void 0) {
                this.buildElementParenting(element, layers[i2].parent, hierarchy2);
              } else {
                element.setHierarchy(hierarchy2);
              }
            }
          }
          i2 += 1;
        }
      };
      BaseRenderer.prototype.addPendingElement = function(element) {
        this.pendingElements.push(element);
      };
      BaseRenderer.prototype.searchExtraCompositions = function(assets) {
        var i2;
        var len = assets.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (assets[i2].xt) {
            var comp2 = this.createComp(assets[i2]);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      BaseRenderer.prototype.getElementById = function(ind) {
        var i2;
        var len = this.elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2].data.ind === ind) {
            return this.elements[i2];
          }
        }
        return null;
      };
      BaseRenderer.prototype.getElementByPath = function(path) {
        var pathValue = path.shift();
        var element;
        if (typeof pathValue === "number") {
          element = this.elements[pathValue];
        } else {
          var i2;
          var len = this.elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2].data.nm === pathValue) {
              element = this.elements[i2];
              break;
            }
          }
        }
        if (path.length === 0) {
          return element;
        }
        return element.getElementByPath(path);
      };
      BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.slotManager = slotFactory(animData);
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
          w: animData.w,
          h: animData.h
        };
      };
      var effectTypes = {
        TRANSFORM_EFFECT: "transformEFfect"
      };
      function TransformElement() {
      }
      TransformElement.prototype = {
        initTransform: function initTransform() {
          var mat = new Matrix();
          this.finalTransform = {
            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
              o: 0
            },
            _matMdf: false,
            _localMatMdf: false,
            _opMdf: false,
            mat,
            localMat: mat,
            localOpacity: 1
          };
          if (this.data.ao) {
            this.finalTransform.mProp.autoOriented = true;
          }
          if (this.data.ty !== 11) {
          }
        },
        renderTransform: function renderTransform() {
          this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
          this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
          if (this.hierarchy) {
            var mat;
            var finalMat = this.finalTransform.mat;
            var i2 = 0;
            var len = this.hierarchy.length;
            if (!this.finalTransform._matMdf) {
              while (i2 < len) {
                if (this.hierarchy[i2].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = true;
                  break;
                }
                i2 += 1;
              }
            }
            if (this.finalTransform._matMdf) {
              mat = this.finalTransform.mProp.v.props;
              finalMat.cloneFromProps(mat);
              for (i2 = 0; i2 < len; i2 += 1) {
                finalMat.multiply(this.hierarchy[i2].finalTransform.mProp.v);
              }
            }
          }
          if (this.finalTransform._matMdf) {
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          }
          if (this.finalTransform._opMdf) {
            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
          }
        },
        renderLocalTransform: function renderLocalTransform() {
          if (this.localTransforms) {
            var i2 = 0;
            var len = this.localTransforms.length;
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
              while (i2 < len) {
                if (this.localTransforms[i2]._mdf) {
                  this.finalTransform._localMatMdf = true;
                }
                if (this.localTransforms[i2]._opMdf && !this.finalTransform._opMdf) {
                  this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                  this.finalTransform._opMdf = true;
                }
                i2 += 1;
              }
            }
            if (this.finalTransform._localMatMdf) {
              var localMat = this.finalTransform.localMat;
              this.localTransforms[0].matrix.clone(localMat);
              for (i2 = 1; i2 < len; i2 += 1) {
                var lmat = this.localTransforms[i2].matrix;
                localMat.multiply(lmat);
              }
              localMat.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var localOp = this.finalTransform.localOpacity;
              for (i2 = 0; i2 < len; i2 += 1) {
                localOp *= this.localTransforms[i2].opacity * 0.01;
              }
              this.finalTransform.localOpacity = localOp;
            }
          }
        },
        searchEffectTransforms: function searchEffectTransforms() {
          if (this.renderableEffectsManager) {
            var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
            if (transformEffects.length) {
              this.localTransforms = [];
              this.finalTransform.localMat = new Matrix();
              var i2 = 0;
              var len = transformEffects.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.localTransforms.push(transformEffects[i2]);
              }
            }
          }
        },
        globalToLocal: function globalToLocal(pt) {
          var transforms = [];
          transforms.push(this.finalTransform);
          var flag = true;
          var comp2 = this.comp;
          while (flag) {
            if (comp2.finalTransform) {
              if (comp2.data.hasMask) {
                transforms.splice(0, 0, comp2.finalTransform);
              }
              comp2 = comp2.comp;
            } else {
              flag = false;
            }
          }
          var i2;
          var len = transforms.length;
          var ptNew;
          for (i2 = 0; i2 < len; i2 += 1) {
            ptNew = transforms[i2].mat.applyToPointArray(0, 0, 0);
            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
          }
          return pt;
        },
        mHelper: new Matrix()
      };
      function MaskElement(data2, element, globalData2) {
        this.data = data2;
        this.element = element;
        this.globalData = globalData2;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i2;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = "";
        var path;
        var properties = this.masksProperties;
        var count2 = 0;
        var currentMasks = [];
        var j2;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x3;
        var maskType = "clipPath";
        var maskRef = "clip-path";
        for (i2 = 0; i2 < len; i2 += 1) {
          if (properties[i2].mode !== "a" && properties[i2].mode !== "n" || properties[i2].inv || properties[i2].o.k !== 100 || properties[i2].o.x) {
            maskType = "mask";
            maskRef = "mask";
          }
          if ((properties[i2].mode === "s" || properties[i2].mode === "i") && count2 === 0) {
            rect = createNS("rect");
            rect.setAttribute("fill", "#ffffff");
            rect.setAttribute("width", this.element.comp.data.w || 0);
            rect.setAttribute("height", this.element.comp.data.h || 0);
            currentMasks.push(rect);
          } else {
            rect = null;
          }
          path = createNS("path");
          if (properties[i2].mode === "n") {
            this.viewData[i2] = {
              op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
              elem: path,
              lastPath: ""
            };
            defs.appendChild(path);
          } else {
            count2 += 1;
            path.setAttribute("fill", properties[i2].mode === "s" ? "#000000" : "#ffffff");
            path.setAttribute("clip-rule", "nonzero");
            var filterID;
            if (properties[i2].x.k !== 0) {
              maskType = "mask";
              maskRef = "mask";
              x3 = PropertyFactory.getProp(this.element, properties[i2].x, 0, null, this.element);
              filterID = createElementID();
              expansor = createNS("filter");
              expansor.setAttribute("id", filterID);
              feMorph = createNS("feMorphology");
              feMorph.setAttribute("operator", "erode");
              feMorph.setAttribute("in", "SourceGraphic");
              feMorph.setAttribute("radius", "0");
              expansor.appendChild(feMorph);
              defs.appendChild(expansor);
              path.setAttribute("stroke", properties[i2].mode === "s" ? "#000000" : "#ffffff");
            } else {
              feMorph = null;
              x3 = null;
            }
            this.storedData[i2] = {
              elem: path,
              x: x3,
              expan: feMorph,
              lastPath: "",
              lastOperator: "",
              filterId: filterID,
              lastRadius: 0
            };
            if (properties[i2].mode === "i") {
              jLen = currentMasks.length;
              var g3 = createNS("g");
              for (j2 = 0; j2 < jLen; j2 += 1) {
                g3.appendChild(currentMasks[j2]);
              }
              var mask2 = createNS("mask");
              mask2.setAttribute("mask-type", "alpha");
              mask2.setAttribute("id", layerId + "_" + count2);
              mask2.appendChild(path);
              defs.appendChild(mask2);
              g3.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count2 + ")");
              currentMasks.length = 0;
              currentMasks.push(g3);
            } else {
              currentMasks.push(path);
            }
            if (properties[i2].inv && !this.solidPath) {
              this.solidPath = this.createLayerSolidPath();
            }
            this.viewData[i2] = {
              elem: path,
              lastPath: "",
              op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
              invRect: rect
            };
            if (!this.viewData[i2].prop.k) {
              this.drawPath(properties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
            }
          }
        }
        this.maskElement = createNS(maskType);
        len = currentMasks.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.maskElement.appendChild(currentMasks[i2]);
        }
        if (count2 > 0) {
          this.maskElement.setAttribute("id", layerId);
          this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
          defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) {
          this.element.addRenderableComponent(this);
        }
      }
      MaskElement.prototype.getMaskProperty = function(pos) {
        return this.viewData[pos].prop;
      };
      MaskElement.prototype.renderFrame = function(isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i2;
        var len = this.masksProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.viewData[i2].prop._mdf || isFirstFrame) {
            this.drawPath(this.masksProperties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
          }
          if (this.viewData[i2].op._mdf || isFirstFrame) {
            this.viewData[i2].elem.setAttribute("fill-opacity", this.viewData[i2].op.v);
          }
          if (this.masksProperties[i2].mode !== "n") {
            if (this.viewData[i2].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
              this.viewData[i2].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
            }
            if (this.storedData[i2].x && (this.storedData[i2].x._mdf || isFirstFrame)) {
              var feMorph = this.storedData[i2].expan;
              if (this.storedData[i2].x.v < 0) {
                if (this.storedData[i2].lastOperator !== "erode") {
                  this.storedData[i2].lastOperator = "erode";
                  this.storedData[i2].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i2].filterId + ")");
                }
                feMorph.setAttribute("radius", -this.storedData[i2].x.v);
              } else {
                if (this.storedData[i2].lastOperator !== "dilate") {
                  this.storedData[i2].lastOperator = "dilate";
                  this.storedData[i2].elem.setAttribute("filter", null);
                }
                this.storedData[i2].elem.setAttribute("stroke-width", this.storedData[i2].x.v * 2);
              }
            }
          }
        }
      };
      MaskElement.prototype.getMaskelement = function() {
        return this.maskElement;
      };
      MaskElement.prototype.createLayerSolidPath = function() {
        var path = "M0,0 ";
        path += " h" + this.globalData.compSize.w;
        path += " v" + this.globalData.compSize.h;
        path += " h-" + this.globalData.compSize.w;
        path += " v-" + this.globalData.compSize.h + " ";
        return path;
      };
      MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
        var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        var i2;
        var len;
        len = pathNodes._length;
        for (i2 = 1; i2 < len; i2 += 1) {
          pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[i2][0] + "," + pathNodes.i[i2][1] + " " + pathNodes.v[i2][0] + "," + pathNodes.v[i2][1];
        }
        if (pathNodes.c && len > 1) {
          pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        }
        if (viewData.lastPath !== pathString) {
          var pathShapeValue = "";
          if (viewData.elem) {
            if (pathNodes.c) {
              pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
            }
            viewData.elem.setAttribute("d", pathShapeValue);
          }
          viewData.lastPath = pathString;
        }
      };
      MaskElement.prototype.destroy = function() {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
      };
      var filtersFactory = function() {
        var ob2 = {};
        ob2.createFilter = createFilter;
        ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
        function createFilter(filId, skipCoordinates) {
          var fil = createNS("filter");
          fil.setAttribute("id", filId);
          if (skipCoordinates !== true) {
            fil.setAttribute("filterUnits", "objectBoundingBox");
            fil.setAttribute("x", "0%");
            fil.setAttribute("y", "0%");
            fil.setAttribute("width", "100%");
            fil.setAttribute("height", "100%");
          }
          return fil;
        }
        function createAlphaToLuminanceFilter() {
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
          return feColorMatrix;
        }
        return ob2;
      }();
      var featureSupport = function() {
        var ob2 = {
          maskType: true,
          svgLumaHidden: true,
          offscreenCanvas: typeof OffscreenCanvas !== "undefined"
        };
        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
          ob2.maskType = false;
        }
        if (/firefox/i.test(navigator.userAgent)) {
          ob2.svgLumaHidden = false;
        }
        return ob2;
      }();
      var registeredEffects$1 = {};
      var idPrefix = "filter_result_";
      function SVGEffects(elem2) {
        var i2;
        var source = "SourceGraphic";
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count2 = 0;
        this.filters = [];
        var filterManager;
        for (i2 = 0; i2 < len; i2 += 1) {
          filterManager = null;
          var type = elem2.data.ef[i2].ty;
          if (registeredEffects$1[type]) {
            var Effect = registeredEffects$1[type].effect;
            filterManager = new Effect(fil, elem2.effectsManager.effectElements[i2], elem2, idPrefix + count2, source);
            source = idPrefix + count2;
            if (registeredEffects$1[type].countsAsEffect) {
              count2 += 1;
            }
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (count2) {
          elem2.globalData.defs.appendChild(fil);
          elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i2;
        var len = this.filters.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.filters[i2].renderFrame(_isFirstFrame);
        }
      };
      SVGEffects.prototype.getEffects = function(type) {
        var i2;
        var len = this.filters.length;
        var effects = [];
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.filters[i2].type === type) {
            effects.push(this.filters[i2]);
          }
        }
        return effects;
      };
      function registerEffect$1(id, effect2, countsAsEffect) {
        registeredEffects$1[id] = {
          effect: effect2,
          countsAsEffect
        };
      }
      function SVGBaseElement() {
      }
      SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
          this.layerElement = createNS("g");
        },
        createContainerElements: function createContainerElements() {
          this.matteElement = createNS("g");
          this.transformedElement = this.layerElement;
          this.maskedElement = this.layerElement;
          this._sizeChanged = false;
          var layerElementParent = null;
          if (this.data.td) {
            this.matteMasks = {};
            var gg = createNS("g");
            gg.setAttribute("id", this.layerId);
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            this.globalData.defs.appendChild(gg);
          } else if (this.data.tt) {
            this.matteElement.appendChild(this.layerElement);
            layerElementParent = this.matteElement;
            this.baseElement = this.matteElement;
          } else {
            this.baseElement = this.layerElement;
          }
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.ty === 0 && !this.data.hd) {
            var cp = createNS("clipPath");
            var pt = createNS("path");
            pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
            var clipId = createElementID();
            cp.setAttribute("id", clipId);
            cp.appendChild(pt);
            this.globalData.defs.appendChild(cp);
            if (this.checkMasks()) {
              var cpGroup = createNS("g");
              cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              cpGroup.appendChild(this.layerElement);
              this.transformedElement = cpGroup;
              if (layerElementParent) {
                layerElementParent.appendChild(this.transformedElement);
              } else {
                this.baseElement = this.transformedElement;
              }
            } else {
              this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            }
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          if (this.finalTransform._localMatMdf) {
            this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
          }
          if (this.finalTransform._opMdf) {
            this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
          }
        },
        destroyBaseElement: function destroyBaseElement() {
          this.layerElement = null;
          this.matteElement = null;
          this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
          if (this.data.hd) {
            return null;
          }
          return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
          this.renderableEffectsManager = new SVGEffects(this);
          this.searchEffectTransforms();
        },
        getMatte: function getMatte(matteType) {
          if (!this.matteMasks) {
            this.matteMasks = {};
          }
          if (!this.matteMasks[matteType]) {
            var id = this.layerId + "_" + matteType;
            var filId;
            var fil;
            var useElement;
            var gg;
            if (matteType === 1 || matteType === 3) {
              var masker = createNS("mask");
              masker.setAttribute("id", id);
              masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              masker.appendChild(useElement);
              this.globalData.defs.appendChild(masker);
              if (!featureSupport.maskType && matteType === 1) {
                masker.setAttribute("mask-type", "luminance");
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                this.globalData.defs.appendChild(fil);
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                gg.appendChild(useElement);
                masker.appendChild(gg);
                gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              }
            } else if (matteType === 2) {
              var maskGroup = createNS("mask");
              maskGroup.setAttribute("id", id);
              maskGroup.setAttribute("mask-type", "alpha");
              var maskGrouper = createNS("g");
              maskGroup.appendChild(maskGrouper);
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              var feCTr = createNS("feComponentTransfer");
              feCTr.setAttribute("in", "SourceGraphic");
              fil.appendChild(feCTr);
              var feFunc = createNS("feFuncA");
              feFunc.setAttribute("type", "table");
              feFunc.setAttribute("tableValues", "1.0 0.0");
              feCTr.appendChild(feFunc);
              this.globalData.defs.appendChild(fil);
              var alphaRect = createNS("rect");
              alphaRect.setAttribute("width", this.comp.data.w);
              alphaRect.setAttribute("height", this.comp.data.h);
              alphaRect.setAttribute("x", "0");
              alphaRect.setAttribute("y", "0");
              alphaRect.setAttribute("fill", "#ffffff");
              alphaRect.setAttribute("opacity", "0");
              maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              maskGrouper.appendChild(alphaRect);
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              maskGrouper.appendChild(useElement);
              if (!featureSupport.maskType) {
                maskGroup.setAttribute("mask-type", "luminance");
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                maskGrouper.appendChild(alphaRect);
                gg.appendChild(this.layerElement);
                maskGrouper.appendChild(gg);
              }
              this.globalData.defs.appendChild(maskGroup);
            }
            this.matteMasks[matteType] = id;
          }
          return this.matteMasks[matteType];
        },
        setMatte: function setMatte(id) {
          if (!this.matteElement) {
            return;
          }
          this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        }
      };
      function HierarchyElement() {
      }
      HierarchyElement.prototype = {
        /**
           * @function
           * Initializes hierarchy properties
           *
           */
        initHierarchy: function initHierarchy() {
          this.hierarchy = [];
          this._isParent = false;
          this.checkParenting();
        },
        /**
           * @function
           * Sets layer's hierarchy.
           * @param {array} hierarch
           * layer's parent list
           *
           */
        setHierarchy: function setHierarchy(hierarchy2) {
          this.hierarchy = hierarchy2;
        },
        /**
           * @function
           * Sets layer as parent.
           *
           */
        setAsParent: function setAsParent() {
          this._isParent = true;
        },
        /**
           * @function
           * Searches layer's parenting chain
           *
           */
        checkParenting: function checkParenting() {
          if (this.data.parent !== void 0) {
            this.comp.buildElementParenting(this, this.data.parent, []);
          }
        }
      };
      function RenderableDOMElement() {
      }
      (function() {
        var _prototype = {
          initElement: function initElement(data2, globalData2, comp2) {
            this.initFrame();
            this.initBaseData(data2, globalData2, comp2);
            this.initTransform(data2, globalData2, comp2);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
          },
          hide: function hide() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var elem2 = this.baseElement || this.layerElement;
              elem2.style.display = "none";
              this.hidden = true;
            }
          },
          show: function show() {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "block";
              }
              this.hidden = false;
              this._isFirstFrame = true;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          renderInnerContent: function renderInnerContent() {
          },
          prepareFrame: function prepareFrame(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            this.checkTransparency();
          },
          destroy: function destroy() {
            this.innerElem = null;
            this.destroyBaseElement();
          }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
      })();
      function IImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        if (this.assetData && this.assetData.sid) {
          this.assetData = globalData2.slotManager.getProp(this.assetData);
        }
        this.initElement(data2, globalData2, comp2);
        this.sourceRect = {
          top: 0,
          left: 0,
          width: this.assetData.w,
          height: this.assetData.h
        };
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
      IImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS("image");
        this.innerElem.setAttribute("width", this.assetData.w + "px");
        this.innerElem.setAttribute("height", this.assetData.h + "px");
        this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.innerElem);
      };
      IImageElement.prototype.sourceRectAtTime = function() {
        return this.sourceRect;
      };
      function ProcessedElement(element, position2) {
        this.elem = element;
        this.pos = position2;
      }
      function IShapeElement() {
      }
      IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data2) {
          var i2;
          var len = this.shapeModifiers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapeModifiers[i2].addShape(data2);
          }
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
          var i2 = 0;
          var len = this.shapeModifiers.length;
          while (i2 < len) {
            if (this.shapeModifiers[i2].isAnimatedWithShape(data2)) {
              return true;
            }
          }
          return false;
        },
        renderModifiers: function renderModifiers() {
          if (!this.shapeModifiers.length) {
            return;
          }
          var i2;
          var len = this.shapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].sh.reset();
          }
          len = this.shapeModifiers.length;
          var shouldBreakProcess;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            shouldBreakProcess = this.shapeModifiers[i2].processShapes(this._isFirstFrame);
            if (shouldBreakProcess) {
              break;
            }
          }
        },
        searchProcessedElement: function searchProcessedElement(elem2) {
          var elements = this.processedElements;
          var i2 = 0;
          var len = elements.length;
          while (i2 < len) {
            if (elements[i2].elem === elem2) {
              return elements[i2].pos;
            }
            i2 += 1;
          }
          return 0;
        },
        addProcessedElement: function addProcessedElement(elem2, pos) {
          var elements = this.processedElements;
          var i2 = elements.length;
          while (i2) {
            i2 -= 1;
            if (elements[i2].elem === elem2) {
              elements[i2].pos = pos;
              return;
            }
          }
          elements.push(new ProcessedElement(elem2, pos));
        },
        prepareFrame: function prepareFrame(num) {
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        }
      };
      var lineCapEnum = {
        1: "butt",
        2: "round",
        3: "square"
      };
      var lineJoinEnum = {
        1: "miter",
        2: "round",
        3: "bevel"
      };
      function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = "";
        this.sh = shape;
        this.lvl = level;
        this._isAnimated = !!shape.k;
        var i2 = 0;
        var len = transformers.length;
        while (i2 < len) {
          if (transformers[i2].mProps.dynamicProperties.length) {
            this._isAnimated = true;
            break;
          }
          i2 += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
      };
      function SVGStyleData(data2, level) {
        this.data = data2;
        this.type = data2.ty;
        this.d = "";
        this.lvl = level;
        this._mdf = false;
        this.closed = data2.hd === true;
        this.pElem = createNS("path");
        this.msElem = null;
      }
      SVGStyleData.prototype.reset = function() {
        this.d = "";
        this._mdf = false;
      };
      function DashProperty(elem2, data2, renderer2, container) {
        this.elem = elem2;
        this.frameId = -1;
        this.dataProps = createSizedArray(data2.length);
        this.renderer = renderer2;
        this.k = false;
        this.dashStr = "";
        this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
        this.dashoffset = createTypedArray("float32", 1);
        this.initDynamicPropertyContainer(container);
        var i2;
        var len = data2.length || 0;
        var prop;
        for (i2 = 0; i2 < len; i2 += 1) {
          prop = PropertyFactory.getProp(elem2, data2[i2].v, 0, 0, this);
          this.k = prop.k || this.k;
          this.dataProps[i2] = {
            n: data2[i2].n,
            p: prop
          };
        }
        if (!this.k) {
          this.getValue(true);
        }
        this._isAnimated = this.k;
      }
      DashProperty.prototype.getValue = function(forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
          var i2 = 0;
          var len = this.dataProps.length;
          if (this.renderer === "svg") {
            this.dashStr = "";
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.dataProps[i2].n !== "o") {
              if (this.renderer === "svg") {
                this.dashStr += " " + this.dataProps[i2].p.v;
              } else {
                this.dashArray[i2] = this.dataProps[i2].p.v;
              }
            } else {
              this.dashoffset[0] = this.dataProps[i2].p.v;
            }
          }
        }
      };
      extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(elem2, data2, container) {
        this.data = data2;
        this.c = createTypedArray("uint8c", data2.p * 4);
        var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
        this.o = createTypedArray("float32", cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
      }
      GradientProperty.prototype.comparePoints = function(values, points) {
        var i2 = 0;
        var len = this.o.length / 2;
        var diff;
        while (i2 < len) {
          diff = Math.abs(values[i2 * 4] - values[points * 4 + i2 * 2]);
          if (diff > 0.01) {
            return false;
          }
          i2 += 1;
        }
        return true;
      };
      GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length / 2 !== this.c.length / 4) {
          return false;
        }
        if (this.data.k.k[0].s) {
          var i2 = 0;
          var len = this.data.k.k.length;
          while (i2 < len) {
            if (!this.comparePoints(this.data.k.k[i2].s, this.data.p)) {
              return false;
            }
            i2 += 1;
          }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
          return false;
        }
        return true;
      };
      GradientProperty.prototype.getValue = function(forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if (this.prop._mdf || forceRender) {
          var i2;
          var len = this.data.p * 4;
          var mult;
          var val2;
          for (i2 = 0; i2 < len; i2 += 1) {
            mult = i2 % 4 === 0 ? 100 : 255;
            val2 = Math.round(this.prop.v[i2] * mult);
            if (this.c[i2] !== val2) {
              this.c[i2] = val2;
              this._cmdf = !forceRender;
            }
          }
          if (this.o.length) {
            len = this.prop.v.length;
            for (i2 = this.data.p * 4; i2 < len; i2 += 1) {
              mult = i2 % 2 === 0 ? 100 : 1;
              val2 = i2 % 2 === 0 ? Math.round(this.prop.v[i2] * 100) : this.prop.v[i2];
              if (this.o[i2 - this.data.p * 4] !== val2) {
                this.o[i2 - this.data.p * 4] = val2;
                this._omdf = !forceRender;
              }
            }
          }
          this._mdf = !forceRender;
        }
      };
      extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem2, data2, styleOb);
      }
      SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem2, data2.h || {
          k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem2, data2.a || {
          k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem2, data2.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data2);
        this.setGradientOpacity(data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      };
      SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
        var gradientId = createElementID();
        var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
        gfill.setAttribute("id", gradientId);
        gfill.setAttribute("spreadMethod", "pad");
        gfill.setAttribute("gradientUnits", "userSpaceOnUse");
        var stops = [];
        var stop;
        var j2;
        var jLen;
        jLen = data2.g.p * 4;
        for (j2 = 0; j2 < jLen; j2 += 4) {
          stop = createNS("stop");
          gfill.appendChild(stop);
          stops.push(stop);
        }
        pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
        this.gf = gfill;
        this.cst = stops;
      };
      SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
          var stop;
          var j2;
          var jLen;
          var mask2 = createNS("mask");
          var maskElement = createNS("path");
          mask2.appendChild(maskElement);
          var opacityId = createElementID();
          var maskId = createElementID();
          mask2.setAttribute("id", maskId);
          var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          opFill.setAttribute("id", opacityId);
          opFill.setAttribute("spreadMethod", "pad");
          opFill.setAttribute("gradientUnits", "userSpaceOnUse");
          jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
          var stops = this.stops;
          for (j2 = data2.g.p * 4; j2 < jLen; j2 += 2) {
            stop = createNS("stop");
            stop.setAttribute("stop-color", "rgb(255,255,255)");
            opFill.appendChild(stop);
            stops.push(stop);
          }
          maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
          if (data2.ty === "gs") {
            maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            if (data2.lj === 1) {
              maskElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          this.of = opFill;
          this.ms = mask2;
          this.ost = stops;
          this.maskId = maskId;
          styleOb.msElem = maskElement;
        }
      };
      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.initGradientData(elem2, data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
      function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS("g");
      }
      function SVGTransformData(mProps, op, container) {
        this.transform = {
          mProps,
          op,
          container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
      }
      var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
        if (length2 === 0) {
          return "";
        }
        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i2;
        var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        for (i2 = 1; i2 < length2; i2 += 1) {
          shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[i2][0], _i[i2][1]) + " " + mat.applyToPointStringified(_v[i2][0], _v[i2][1]);
        }
        if (closed && length2) {
          shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          shapeString += "z";
        }
        return shapeString;
      };
      var SVGElementsRenderer = function() {
        var _identityMatrix = new Matrix();
        var _matrixHelper = new Matrix();
        var ob2 = {
          createRenderFunction
        };
        function createRenderFunction(data2) {
          switch (data2.ty) {
            case "fl":
              return renderFill;
            case "gf":
              return renderGradient;
            case "gs":
              return renderGradientStroke;
            case "st":
              return renderStroke;
            case "sh":
            case "el":
            case "rc":
            case "sr":
              return renderPath;
            case "tr":
              return renderContentTransform;
            case "no":
              return renderNoop;
            default:
              return null;
          }
        }
        function renderContentTransform(styleData, itemData, isFirstFrame) {
          if (isFirstFrame || itemData.transform.op._mdf) {
            itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
          }
          if (isFirstFrame || itemData.transform.mProps._mdf) {
            itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
          }
        }
        function renderNoop() {
        }
        function renderPath(styleData, itemData, isFirstFrame) {
          var j2;
          var jLen;
          var pathStringTransformed;
          var redraw;
          var pathNodes;
          var l2;
          var lLen = itemData.styles.length;
          var lvl = itemData.lvl;
          var paths;
          var mat;
          var iterations2;
          var k2;
          for (l2 = 0; l2 < lLen; l2 += 1) {
            redraw = itemData.sh._mdf || isFirstFrame;
            if (itemData.styles[l2].lvl < lvl) {
              mat = _matrixHelper.reset();
              iterations2 = lvl - itemData.styles[l2].lvl;
              k2 = itemData.transformers.length - 1;
              while (!redraw && iterations2 > 0) {
                redraw = itemData.transformers[k2].mProps._mdf || redraw;
                iterations2 -= 1;
                k2 -= 1;
              }
              if (redraw) {
                iterations2 = lvl - itemData.styles[l2].lvl;
                k2 = itemData.transformers.length - 1;
                while (iterations2 > 0) {
                  mat.multiply(itemData.transformers[k2].mProps.v);
                  iterations2 -= 1;
                  k2 -= 1;
                }
              }
            } else {
              mat = _identityMatrix;
            }
            paths = itemData.sh.paths;
            jLen = paths._length;
            if (redraw) {
              pathStringTransformed = "";
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathNodes = paths.shapes[j2];
                if (pathNodes && pathNodes._length) {
                  pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                }
              }
              itemData.caches[l2] = pathStringTransformed;
            } else {
              pathStringTransformed = itemData.caches[l2];
            }
            itemData.styles[l2].d += styleData.hd === true ? "" : pathStringTransformed;
            itemData.styles[l2]._mdf = redraw || itemData.styles[l2]._mdf;
          }
        }
        function renderFill(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
          }
        }
        function renderGradientStroke(styleData, itemData, isFirstFrame) {
          renderGradient(styleData, itemData, isFirstFrame);
          renderStroke(styleData, itemData, isFirstFrame);
        }
        function renderGradient(styleData, itemData, isFirstFrame) {
          var gfill = itemData.gf;
          var hasOpacity = itemData.g._hasOpacity;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (itemData.o._mdf || isFirstFrame) {
            var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
            itemData.style.pElem.setAttribute(attr, itemData.o.v);
          }
          if (itemData.s._mdf || isFirstFrame) {
            var attr1 = styleData.t === 1 ? "x1" : "cx";
            var attr2 = attr1 === "x1" ? "y1" : "cy";
            gfill.setAttribute(attr1, pt1[0]);
            gfill.setAttribute(attr2, pt1[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute(attr1, pt1[0]);
              itemData.of.setAttribute(attr2, pt1[1]);
            }
          }
          var stops;
          var i2;
          var len;
          var stop;
          if (itemData.g._cmdf || isFirstFrame) {
            stops = itemData.cst;
            var cValues = itemData.g.c;
            len = stops.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              stop = stops[i2];
              stop.setAttribute("offset", cValues[i2 * 4] + "%");
              stop.setAttribute("stop-color", "rgb(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + ")");
            }
          }
          if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
            var oValues = itemData.g.o;
            if (itemData.g._collapsable) {
              stops = itemData.cst;
            } else {
              stops = itemData.ost;
            }
            len = stops.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              stop = stops[i2];
              if (!itemData.g._collapsable) {
                stop.setAttribute("offset", oValues[i2 * 2] + "%");
              }
              stop.setAttribute("stop-opacity", oValues[i2 * 2 + 1]);
            }
          }
          if (styleData.t === 1) {
            if (itemData.e._mdf || isFirstFrame) {
              gfill.setAttribute("x2", pt2[0]);
              gfill.setAttribute("y2", pt2[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("x2", pt2[0]);
                itemData.of.setAttribute("y2", pt2[1]);
              }
            }
          } else {
            var rad;
            if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              gfill.setAttribute("r", rad);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("r", rad);
              }
            }
            if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
              if (!rad) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              }
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x3 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y3 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              gfill.setAttribute("fx", x3);
              gfill.setAttribute("fy", y3);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("fx", x3);
                itemData.of.setAttribute("fy", y3);
              }
            }
          }
        }
        function renderStroke(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          var d2 = itemData.d;
          if (d2 && (d2._mdf || isFirstFrame) && d2.dashStr) {
            styleElem.pElem.setAttribute("stroke-dasharray", d2.dashStr);
            styleElem.pElem.setAttribute("stroke-dashoffset", d2.dashoffset[0]);
          }
          if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
            styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
          }
          if (itemData.w._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
            if (styleElem.msElem) {
              styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
            }
          }
        }
        return ob2;
      }();
      function SVGShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
      SVGShapeElement.prototype.initSecondaryElement = function() {
      };
      SVGShapeElement.prototype.identityMatrix = new Matrix();
      SVGShapeElement.prototype.buildExpressionInterface = function() {
      };
      SVGShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
      };
      SVGShapeElement.prototype.filterUniqueShapes = function() {
        var i2;
        var len = this.shapes.length;
        var shape;
        var j2;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          style = this.stylesList[j2];
          areAnimated = false;
          tempShapes.length = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            shape = this.shapes[i2];
            if (shape.styles.indexOf(style) !== -1) {
              tempShapes.push(shape);
              areAnimated = shape._isAnimated || areAnimated;
            }
          }
          if (tempShapes.length > 1 && areAnimated) {
            this.setShapesAsAnimated(tempShapes);
          }
        }
      };
      SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
        var i2;
        var len = shapes.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          shapes[i2].setAsAnimated();
        }
      };
      SVGShapeElement.prototype.createStyleElement = function(data2, level) {
        var elementData;
        var styleOb = new SVGStyleData(data2, level);
        var pathElement = styleOb.pElem;
        if (data2.ty === "st") {
          elementData = new SVGStrokeStyleData(this, data2, styleOb);
        } else if (data2.ty === "fl") {
          elementData = new SVGFillStyleData(this, data2, styleOb);
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
          elementData = new GradientConstructor(this, data2, styleOb);
          this.globalData.defs.appendChild(elementData.gf);
          if (elementData.maskId) {
            this.globalData.defs.appendChild(elementData.ms);
            this.globalData.defs.appendChild(elementData.of);
            pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
          }
        } else if (data2.ty === "no") {
          elementData = new SVGNoStyleData(this, data2, styleOb);
        }
        if (data2.ty === "st" || data2.ty === "gs") {
          pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
          pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
          pathElement.setAttribute("fill-opacity", "0");
          if (data2.lj === 1) {
            pathElement.setAttribute("stroke-miterlimit", data2.ml);
          }
        }
        if (data2.r === 2) {
          pathElement.setAttribute("fill-rule", "evenodd");
        }
        if (data2.ln) {
          pathElement.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          pathElement.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createGroupElement = function(data2) {
        var elementData = new ShapeGroupData();
        if (data2.ln) {
          elementData.gr.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          elementData.gr.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        return elementData;
      };
      SVGShapeElement.prototype.createTransformElement = function(data2, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
        var i2 = 0;
        var len = this.animatedContents.length;
        while (i2 < len) {
          if (this.animatedContents[i2].element === element) {
            return;
          }
          i2 += 1;
        }
        this.animatedContents.push({
          fn: SVGElementsRenderer.createRenderFunction(data2),
          element,
          data: data2
        });
      };
      SVGShapeElement.prototype.setElementStyles = function(elementData) {
        var arr = elementData.styles;
        var j2;
        var jLen = this.stylesList.length;
        for (j2 = 0; j2 < jLen; j2 += 1) {
          if (!this.stylesList[j2].closed) {
            arr.push(this.stylesList[j2]);
          }
        }
      };
      SVGShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i2;
        var len = this.itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.prevViewData[i2] = this.itemsData[i2];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.dynamicProperties[i2].getValue();
        }
        this.renderModifiers();
      };
      SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
        var ownTransformers = [].concat(transformers);
        var i2;
        var len = arr.length - 1;
        var j2;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;
        for (i2 = len; i2 >= 0; i2 -= 1) {
          processedPos = this.searchProcessedElement(arr[i2]);
          if (!processedPos) {
            arr[i2]._render = render;
          } else {
            itemsData[i2] = prevViewData[processedPos - 1];
          }
          if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs" || arr[i2].ty === "no") {
            if (!processedPos) {
              itemsData[i2] = this.createStyleElement(arr[i2], level);
            } else {
              itemsData[i2].style.closed = false;
            }
            if (arr[i2]._render) {
              if (itemsData[i2].style.pElem.parentNode !== container) {
                container.appendChild(itemsData[i2].style.pElem);
              }
            }
            ownStyles.push(itemsData[i2].style);
          } else if (arr[i2].ty === "gr") {
            if (!processedPos) {
              itemsData[i2] = this.createGroupElement(arr[i2]);
            } else {
              jLen = itemsData[i2].it.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsData[i2].prevViewData[j2] = itemsData[i2].it[j2];
              }
            }
            this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, itemsData[i2].gr, level + 1, ownTransformers, render);
            if (arr[i2]._render) {
              if (itemsData[i2].gr.parentNode !== container) {
                container.appendChild(itemsData[i2].gr);
              }
            }
          } else if (arr[i2].ty === "tr") {
            if (!processedPos) {
              itemsData[i2] = this.createTransformElement(arr[i2], container);
            }
            currentTransform = itemsData[i2].transform;
            ownTransformers.push(currentTransform);
          } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
            if (!processedPos) {
              itemsData[i2] = this.createShapeElement(arr[i2], ownTransformers, level);
            }
            this.setElementStyles(itemsData[i2]);
          } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "ms" || arr[i2].ty === "pb" || arr[i2].ty === "zz" || arr[i2].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              modifier.init(this, arr[i2]);
              itemsData[i2] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i2];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i2].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              itemsData[i2] = modifier;
              modifier.init(this, arr, i2, itemsData);
              this.shapeModifiers.push(modifier);
              render = false;
            } else {
              modifier = itemsData[i2];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i2], i2 + 1);
        }
        len = ownStyles.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownStyles[i2].closed = true;
        }
        len = ownModifiers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownModifiers[i2].closed = true;
        }
      };
      SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.stylesList[i2].reset();
        }
        this.renderShape();
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.stylesList[i2]._mdf || this._isFirstFrame) {
            if (this.stylesList[i2].msElem) {
              this.stylesList[i2].msElem.setAttribute("d", this.stylesList[i2].d);
              this.stylesList[i2].d = "M0 0" + this.stylesList[i2].d;
            }
            this.stylesList[i2].pElem.setAttribute("d", this.stylesList[i2].d || "M0 0");
          }
        }
      };
      SVGShapeElement.prototype.renderShape = function() {
        var i2;
        var len = this.animatedContents.length;
        var animatedContent;
        for (i2 = 0; i2 < len; i2 += 1) {
          animatedContent = this.animatedContents[i2];
          if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
          }
        }
      };
      SVGShapeElement.prototype.destroy = function() {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
      };
      function LetterProps(o2, sw, sc, fc, m2, p2) {
        this.o = o2;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m2;
        this.p = p2;
        this._mdf = {
          o: true,
          sw: !!sw,
          sc: !!sc,
          fc: !!fc,
          m: true,
          p: true
        };
      }
      LetterProps.prototype.update = function(o2, sw, sc, fc, m2, p2) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;
        if (this.o !== o2) {
          this.o = o2;
          this._mdf.o = true;
          updated = true;
        }
        if (this.sw !== sw) {
          this.sw = sw;
          this._mdf.sw = true;
          updated = true;
        }
        if (this.sc !== sc) {
          this.sc = sc;
          this._mdf.sc = true;
          updated = true;
        }
        if (this.fc !== fc) {
          this.fc = fc;
          this._mdf.fc = true;
          updated = true;
        }
        if (this.m !== m2) {
          this.m = m2;
          this._mdf.m = true;
          updated = true;
        }
        if (p2.length && (this.p[0] !== p2[0] || this.p[1] !== p2[1] || this.p[4] !== p2[4] || this.p[5] !== p2[5] || this.p[12] !== p2[12] || this.p[13] !== p2[13])) {
          this.p = p2;
          this._mdf.p = true;
          updated = true;
        }
        return updated;
      };
      function TextProperty(elem2, data2) {
        this._frameId = initialDefaultFrame;
        this.pv = "";
        this.v = "";
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        if (data2.d && data2.d.sid) {
          data2.d = elem2.globalData.slotManager.getProp(data2.d);
        }
        this.data = data2;
        this.elem = elem2;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
          ascent: 0,
          boxWidth: this.defaultBoxWidth,
          f: "",
          fStyle: "",
          fWeight: "",
          fc: "",
          j: "",
          justifyOffset: "",
          l: [],
          lh: 0,
          lineWidths: [],
          ls: "",
          of: "",
          s: "",
          sc: "",
          sw: 0,
          t: 0,
          tr: 0,
          sz: 0,
          ps: null,
          fillColorAnim: false,
          strokeColorAnim: false,
          strokeWidthAnim: false,
          yOffset: 0,
          finalSize: 0,
          finalText: [],
          finalLineHeight: 0,
          __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);
        if (!this.searchProperty()) {
          this.completeTextData(this.currentData);
        }
      }
      TextProperty.prototype.defaultBoxWidth = [0, 0];
      TextProperty.prototype.copyData = function(obj, data2) {
        for (var s2 in data2) {
          if (Object.prototype.hasOwnProperty.call(data2, s2)) {
            obj[s2] = data2[s2];
          }
        }
        return obj;
      };
      TextProperty.prototype.setCurrentData = function(data2) {
        if (!data2.__complete) {
          this.completeTextData(data2);
        }
        this.currentData = data2;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
      };
      TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
      };
      TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if (this.kf) {
          this.addEffect(this.getKeyframeValue.bind(this));
        }
        return this.kf;
      };
      TextProperty.prototype.addEffect = function(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.getValue = function(_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
          return;
        }
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var i2;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (currentIndex !== this.keysIndex) {
            finalValue = this.effectsSequence[i2](finalValue, finalValue.t);
          } else {
            finalValue = this.effectsSequence[i2](this.currentData, finalValue.t);
          }
        }
        if (currentValue !== finalValue) {
          this.setCurrentData(finalValue);
        }
        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      };
      TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i2 = 0;
        var len = textKeys.length;
        while (i2 <= len - 1) {
          if (i2 === len - 1 || textKeys[i2 + 1].t > frameNum) {
            break;
          }
          i2 += 1;
        }
        if (this.keysIndex !== i2) {
          this.keysIndex = i2;
        }
        return this.data.d.k[this.keysIndex].s;
      };
      TextProperty.prototype.buildFinalText = function(text2) {
        var charactersArray = [];
        var i2 = 0;
        var len = text2.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;
        var shouldCombineNext = false;
        var currentChars = "";
        while (i2 < len) {
          shouldCombine = shouldCombineNext;
          shouldCombineNext = false;
          charCode = text2.charCodeAt(i2);
          currentChars = text2.charAt(i2);
          if (FontManager.isCombinedCharacter(charCode)) {
            shouldCombine = true;
          } else if (charCode >= 55296 && charCode <= 56319) {
            if (FontManager.isRegionalFlag(text2, i2)) {
              currentChars = text2.substr(i2, 14);
            } else {
              secondCharCode = text2.charCodeAt(i2 + 1);
              if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                if (FontManager.isModifier(charCode, secondCharCode)) {
                  currentChars = text2.substr(i2, 2);
                  shouldCombine = true;
                } else if (FontManager.isFlagEmoji(text2.substr(i2, 4))) {
                  currentChars = text2.substr(i2, 4);
                } else {
                  currentChars = text2.substr(i2, 2);
                }
              }
            }
          } else if (charCode > 56319) {
            secondCharCode = text2.charCodeAt(i2 + 1);
            if (FontManager.isVariationSelector(charCode)) {
              shouldCombine = true;
            }
          } else if (FontManager.isZeroWidthJoiner(charCode)) {
            shouldCombine = true;
            shouldCombineNext = true;
          }
          if (shouldCombine) {
            charactersArray[charactersArray.length - 1] += currentChars;
            shouldCombine = false;
          } else {
            charactersArray.push(currentChars);
          }
          i2 += currentChars.length;
        }
        return charactersArray;
      };
      TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data2 = this.data;
        var letters = [];
        var i2;
        var len;
        var newLineFlag;
        var index2 = 0;
        var val2;
        var anchorGrouping = data2.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j2;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
        var charCode;
        if (documentData.sz) {
          var flag = true;
          var boxWidth = documentData.sz[0];
          var boxHeight = documentData.sz[1];
          var currentHeight;
          var finalText;
          while (flag) {
            finalText = this.buildFinalText(documentData.t);
            currentHeight = 0;
            lineWidth = 0;
            len = finalText.length;
            trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
            var lastSpaceIndex = -1;
            for (i2 = 0; i2 < len; i2 += 1) {
              charCode = finalText[i2].charCodeAt(0);
              newLineFlag = false;
              if (finalText[i2] === " ") {
                lastSpaceIndex = i2;
              } else if (charCode === 13 || charCode === 3) {
                lineWidth = 0;
                newLineFlag = true;
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              }
              if (fontManager.chars) {
                charData = fontManager.getCharData(finalText[i2], fontData.fStyle, fontData.fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                cLength = fontManager.measureText(finalText[i2], documentData.f, documentData.finalSize);
              }
              if (lineWidth + cLength > boxWidth && finalText[i2] !== " ") {
                if (lastSpaceIndex === -1) {
                  len += 1;
                } else {
                  i2 = lastSpaceIndex;
                }
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                finalText.splice(i2, lastSpaceIndex === i2 ? 1 : 0, "\r");
                lastSpaceIndex = -1;
                lineWidth = 0;
              } else {
                lineWidth += cLength;
                lineWidth += trackingOffset;
              }
            }
            currentHeight += fontData.ascent * documentData.finalSize / 100;
            if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
              documentData.finalSize -= 1;
              documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
            } else {
              documentData.finalText = finalText;
              len = documentData.finalText.length;
              flag = false;
            }
          }
        }
        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for (i2 = 0; i2 < len; i2 += 1) {
          newLineFlag = false;
          currentChar = documentData.finalText[i2];
          charCode = currentChar.charCodeAt(0);
          if (charCode === 13 || charCode === 3) {
            uncollapsedSpaces = 0;
            lineWidths.push(lineWidth);
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidth = -2 * trackingOffset;
            val2 = "";
            newLineFlag = true;
            currentLine += 1;
          } else {
            val2 = currentChar;
          }
          if (fontManager.chars) {
            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
          }
          if (currentChar === " ") {
            uncollapsedSpaces += cLength + trackingOffset;
          } else {
            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
            uncollapsedSpaces = 0;
          }
          letters.push({
            l: cLength,
            an: cLength,
            add: currentSize,
            n: newLineFlag,
            anIndexes: [],
            val: val2,
            line: currentLine,
            animatorJustifyOffset: 0
          });
          if (anchorGrouping == 2) {
            currentSize += cLength;
            if (val2 === "" || val2 === " " || i2 === len - 1) {
              if (val2 === "" || val2 === " ") {
                currentSize -= cLength;
              }
              while (currentPos <= i2) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              index2 += 1;
              currentSize = 0;
            }
          } else if (anchorGrouping == 3) {
            currentSize += cLength;
            if (val2 === "" || i2 === len - 1) {
              if (val2 === "") {
                currentSize -= cLength;
              }
              while (currentPos <= i2) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              currentSize = 0;
              index2 += 1;
            }
          } else {
            letters[index2].ind = index2;
            letters[index2].extra = 0;
            index2 += 1;
          }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if (documentData.sz) {
          documentData.boxWidth = documentData.sz[0];
          documentData.justifyOffset = 0;
        } else {
          documentData.boxWidth = maxLineWidth;
          switch (documentData.j) {
            case 1:
              documentData.justifyOffset = -documentData.boxWidth;
              break;
            case 2:
              documentData.justifyOffset = -documentData.boxWidth / 2;
              break;
            default:
              documentData.justifyOffset = 0;
          }
        }
        documentData.lineWidths = lineWidths;
        var animators = data2.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];
        for (j2 = 0; j2 < jLen; j2 += 1) {
          animatorData = animators[j2];
          if (animatorData.a.sc) {
            documentData.strokeColorAnim = true;
          }
          if (animatorData.a.sw) {
            documentData.strokeWidthAnim = true;
          }
          if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
            documentData.fillColorAnim = true;
          }
          ind = 0;
          based = animatorData.s.b;
          for (i2 = 0; i2 < len; i2 += 1) {
            letterData = letters[i2];
            letterData.anIndexes[j2] = ind;
            if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i2 == len - 1) || based == 4 && (letterData.n || i2 == len - 1)) {
              if (animatorData.s.rn === 1) {
                indexes.push(ind);
              }
              ind += 1;
            }
          }
          data2.a[j2].s.totalChars = ind;
          var currentInd = -1;
          var newInd;
          if (animatorData.s.rn === 1) {
            for (i2 = 0; i2 < len; i2 += 1) {
              letterData = letters[i2];
              if (currentInd != letterData.anIndexes[j2]) {
                currentInd = letterData.anIndexes[j2];
                newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
              }
              letterData.anIndexes[j2] = newInd;
            }
          }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
      };
      TextProperty.prototype.updateDocumentData = function(newData, index2) {
        index2 = index2 === void 0 ? this.keysIndex : index2;
        var dData = this.copyData({}, this.data.d.k[index2].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index2].s = dData;
        this.recalculate(index2);
        this.setCurrentData(dData);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.recalculate = function(index2) {
        var dData = this.data.d.k[index2].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
      };
      TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      var TextSelectorProp = function() {
        var max3 = Math.max;
        var min3 = Math.min;
        var floor = Math.floor;
        function TextSelectorPropFactory(elem2, data2) {
          this._currentTextLength = -1;
          this.k = false;
          this.data = data2;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.finalS = 0;
          this.finalE = 0;
          this.initDynamicPropertyContainer(elem2);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: 0
          }, 0, 0, this);
          if ("e" in data2) {
            this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
          } else {
            this.e = {
              v: 100
            };
          }
          this.o = PropertyFactory.getProp(elem2, data2.o || {
            k: 0
          }, 0, 0, this);
          this.xe = PropertyFactory.getProp(elem2, data2.xe || {
            k: 0
          }, 0, 0, this);
          this.ne = PropertyFactory.getProp(elem2, data2.ne || {
            k: 0
          }, 0, 0, this);
          this.sm = PropertyFactory.getProp(elem2, data2.sm || {
            k: 100
          }, 0, 0, this);
          this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
          if (!this.dynamicProperties.length) {
            this.getValue();
          }
        }
        TextSelectorPropFactory.prototype = {
          getMult: function getMult(ind) {
            if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
              this.getValue();
            }
            var x13 = 0;
            var y13 = 0;
            var x22 = 1;
            var y22 = 1;
            if (this.ne.v > 0) {
              x13 = this.ne.v / 100;
            } else {
              y13 = -this.ne.v / 100;
            }
            if (this.xe.v > 0) {
              x22 = 1 - this.xe.v / 100;
            } else {
              y22 = 1 + this.xe.v / 100;
            }
            var easer = BezierFactory.getBezierEasing(x13, y13, x22, y22).get;
            var mult = 0;
            var s2 = this.finalS;
            var e3 = this.finalE;
            var type = this.data.sh;
            if (type === 2) {
              if (e3 === s2) {
                mult = ind >= e3 ? 1 : 0;
              } else {
                mult = max3(0, min3(0.5 / (e3 - s2) + (ind - s2) / (e3 - s2), 1));
              }
              mult = easer(mult);
            } else if (type === 3) {
              if (e3 === s2) {
                mult = ind >= e3 ? 0 : 1;
              } else {
                mult = 1 - max3(0, min3(0.5 / (e3 - s2) + (ind - s2) / (e3 - s2), 1));
              }
              mult = easer(mult);
            } else if (type === 4) {
              if (e3 === s2) {
                mult = 0;
              } else {
                mult = max3(0, min3(0.5 / (e3 - s2) + (ind - s2) / (e3 - s2), 1));
                if (mult < 0.5) {
                  mult *= 2;
                } else {
                  mult = 1 - 2 * (mult - 0.5);
                }
              }
              mult = easer(mult);
            } else if (type === 5) {
              if (e3 === s2) {
                mult = 0;
              } else {
                var tot = e3 - s2;
                ind = min3(max3(0, ind + 0.5 - s2), e3 - s2);
                var x3 = -tot / 2 + ind;
                var a2 = tot / 2;
                mult = Math.sqrt(1 - x3 * x3 / (a2 * a2));
              }
              mult = easer(mult);
            } else if (type === 6) {
              if (e3 === s2) {
                mult = 0;
              } else {
                ind = min3(max3(0, ind + 0.5 - s2), e3 - s2);
                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e3 - s2))) / 2;
              }
              mult = easer(mult);
            } else {
              if (ind >= floor(s2)) {
                if (ind - s2 < 0) {
                  mult = max3(0, min3(min3(e3, 1) - (s2 - ind), 1));
                } else {
                  mult = max3(0, min3(e3 - ind, 1));
                }
              }
              mult = easer(mult);
            }
            if (this.sm.v !== 100) {
              var smoothness = this.sm.v * 0.01;
              if (smoothness === 0) {
                smoothness = 1e-8;
              }
              var threshold = 0.5 - smoothness * 0.5;
              if (mult < threshold) {
                mult = 0;
              } else {
                mult = (mult - threshold) / smoothness;
                if (mult > 1) {
                  mult = 1;
                }
              }
            }
            return mult * this.a.v;
          },
          getValue: function getValue(newCharsFlag) {
            this.iterateDynamicProperties();
            this._mdf = newCharsFlag || this._mdf;
            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
            if (newCharsFlag && this.data.r === 2) {
              this.e.v = this._currentTextLength;
            }
            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
            var o2 = this.o.v / divisor;
            var s2 = this.s.v / divisor + o2;
            var e3 = this.e.v / divisor + o2;
            if (s2 > e3) {
              var _s = s2;
              s2 = e3;
              e3 = _s;
            }
            this.finalS = s2;
            this.finalE = e3;
          }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
        function getTextSelectorProp(elem2, data2, arr) {
          return new TextSelectorPropFactory(elem2, data2, arr);
        }
        return {
          getTextSelectorProp
        };
      }();
      function TextAnimatorDataProperty(elem2, animatorProps, container) {
        var defaultData = {
          propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
          r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
          rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
          ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
          sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
          sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
          s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
          a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
          o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
          p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
          sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
          sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
          fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
          fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
          fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
          fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
          t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
      }
      function TextAnimatorProperty(textData, renderType, elem2) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem2;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
          alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem2);
      }
      TextAnimatorProperty.prototype.searchProperties = function() {
        var i2;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;
        for (i2 = 0; i2 < len; i2 += 1) {
          animatorProps = this._textData.a[i2];
          this._animatorsData[i2] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if (this._textData.p && "m" in this._textData.p) {
          this._pathData = {
            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          };
          this._hasMaskedPath = true;
        } else {
          this._hasMaskedPath = false;
        }
        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
      };
      TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;
        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
          return;
        }
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i2;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength;
        var perc;
        var tanAngle;
        var mask2;
        if (this._hasMaskedPath) {
          mask2 = this._pathData.m;
          if (!this._pathData.n || this._pathData._mdf) {
            var paths = mask2.v;
            if (this._pathData.r.v) {
              paths = paths.reverse();
            }
            pathInfo = {
              tLength: 0,
              segments: []
            };
            len = paths._length - 1;
            var bezierData;
            totalLength = 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierData = bez.buildBezierData(paths.v[i2], paths.v[i2 + 1], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[i2 + 1][0] - paths.v[i2 + 1][0], paths.i[i2 + 1][1] - paths.v[i2 + 1][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            i2 = len;
            if (mask2.v.c) {
              bezierData = bez.buildBezierData(paths.v[i2], paths.v[0], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            this._pathData.pi = pathInfo;
          }
          pathInfo = this._pathData.pi;
          currentLength = this._pathData.f.v;
          segmentInd = 0;
          pointInd = 1;
          segmentLength = 0;
          flag = true;
          segments = pathInfo.segments;
          if (currentLength < 0 && mask2.v.c) {
            if (pathInfo.tLength < Math.abs(currentLength)) {
              currentLength = -Math.abs(currentLength) % pathInfo.tLength;
            }
            segmentInd = segments.length - 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;
            while (currentLength < 0) {
              currentLength += points[pointInd].partialLength;
              pointInd -= 1;
              if (pointInd < 0) {
                segmentInd -= 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
              }
            }
          }
          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
        }
        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j2;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k2;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = "";
        var letterP = this.defaultPropsArray;
        var letterO;
        if (documentData.j === 2 || documentData.j === 1) {
          var animatorJustifyOffset = 0;
          var animatorFirstCharOffset = 0;
          var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
          var lastIndex = 0;
          var isNewLine = true;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (letters[i2].n) {
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }
              while (lastIndex < i2) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }
              animatorJustifyOffset = 0;
              isNewLine = true;
            } else {
              for (j2 = 0; j2 < jLen; j2 += 1) {
                animatorProps = animators[j2].a;
                if (animatorProps.t.propType) {
                  if (isNewLine && documentData.j === 2) {
                    animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                  }
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                  } else {
                    animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                  }
                }
              }
              isNewLine = false;
            }
          }
          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }
          while (lastIndex < i2) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }
        }
        for (i2 = 0; i2 < len; i2 += 1) {
          matrixHelper.reset();
          elemOpacity = 1;
          if (letters[i2].n) {
            xPos = 0;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            currentLength = initPathPos;
            firstLine = false;
            if (this._hasMaskedPath) {
              segmentInd = initSegmentInd;
              pointInd = initPointInd;
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
              segmentLength = 0;
            }
            letterM = "";
            letterFc = "";
            letterSw = "";
            letterO = "";
            letterP = this.defaultPropsArray;
          } else {
            if (this._hasMaskedPath) {
              if (currentLine !== letters[i2].line) {
                switch (documentData.j) {
                  case 1:
                    currentLength += totalLength - documentData.lineWidths[letters[i2].line];
                    break;
                  case 2:
                    currentLength += (totalLength - documentData.lineWidths[letters[i2].line]) / 2;
                    break;
                  default:
                    break;
                }
                currentLine = letters[i2].line;
              }
              if (ind !== letters[i2].ind) {
                if (letters[ind]) {
                  currentLength += letters[ind].extra;
                }
                currentLength += letters[i2].an / 2;
                ind = letters[i2].ind;
              }
              currentLength += alignment[0] * letters[i2].an * 5e-3;
              var animatorOffset = 0;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                animatorProps = animators[j2].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.p.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.p.v[0] * mult;
                  }
                }
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j2].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.a.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.a.v[0] * mult;
                  }
                }
              }
              flag = true;
              if (this._pathData.a.v) {
                currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                currentLength += this._pathData.f.v;
              }
              while (flag) {
                if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                  perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                  xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                  yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                  matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                  flag = false;
                } else if (points) {
                  segmentLength += currentPoint.partialLength;
                  pointInd += 1;
                  if (pointInd >= points.length) {
                    pointInd = 0;
                    segmentInd += 1;
                    if (!segments[segmentInd]) {
                      if (mask2.v.c) {
                        pointInd = 0;
                        segmentInd = 0;
                        points = segments[segmentInd].points;
                      } else {
                        segmentLength -= currentPoint.partialLength;
                        points = null;
                      }
                    } else {
                      points = segments[segmentInd].points;
                    }
                  }
                  if (points) {
                    prevPoint = currentPoint;
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                  }
                }
              }
              offf = letters[i2].an / 2 - letters[i2].add;
              matrixHelper.translate(-offf, 0, 0);
            } else {
              offf = letters[i2].an / 2 - letters[i2].add;
              matrixHelper.translate(-offf, 0, 0);
              matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.t.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                if (xPos !== 0 || documentData.j !== 0) {
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      currentLength += animatorProps.t.v * mult[0];
                    } else {
                      currentLength += animatorProps.t.v * mult;
                    }
                  } else if (mult.length) {
                    xPos += animatorProps.t.v * mult[0];
                  } else {
                    xPos += animatorProps.t.v * mult;
                  }
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              sw = documentData.sw || 0;
            }
            if (documentData.strokeColorAnim) {
              if (documentData.sc) {
                sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
              } else {
                sc = [0, 0, 0];
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.a.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                if (mult.length) {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.s.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                if (mult.length) {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                } else {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              animatorSelector = animators[j2].s;
              mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
              if (animatorProps.sk.propType) {
                if (mult.length) {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                } else {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                }
              }
              if (animatorProps.r.propType) {
                if (mult.length) {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                } else {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult);
                }
              }
              if (animatorProps.ry.propType) {
                if (mult.length) {
                  matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                } else {
                  matrixHelper.rotateY(animatorProps.ry.v * mult);
                }
              }
              if (animatorProps.rx.propType) {
                if (mult.length) {
                  matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                } else {
                  matrixHelper.rotateX(animatorProps.rx.v * mult);
                }
              }
              if (animatorProps.o.propType) {
                if (mult.length) {
                  elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                } else {
                  elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                }
              }
              if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                if (mult.length) {
                  sw += animatorProps.sw.v * mult[0];
                } else {
                  sw += animatorProps.sw.v * mult;
                }
              }
              if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                for (k2 = 0; k2 < 3; k2 += 1) {
                  if (mult.length) {
                    sc[k2] += (animatorProps.sc.v[k2] - sc[k2]) * mult[0];
                  } else {
                    sc[k2] += (animatorProps.sc.v[k2] - sc[k2]) * mult;
                  }
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                if (animatorProps.fc.propType) {
                  for (k2 = 0; k2 < 3; k2 += 1) {
                    if (mult.length) {
                      fc[k2] += (animatorProps.fc.v[k2] - fc[k2]) * mult[0];
                    } else {
                      fc[k2] += (animatorProps.fc.v[k2] - fc[k2]) * mult;
                    }
                  }
                }
                if (animatorProps.fh.propType) {
                  if (mult.length) {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                  } else {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                  }
                }
                if (animatorProps.fs.propType) {
                  if (mult.length) {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                  } else {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                  }
                }
                if (animatorProps.fb.propType) {
                  if (mult.length) {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                  } else {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                  }
                }
              }
            }
            for (j2 = 0; j2 < jLen; j2 += 1) {
              animatorProps = animators[j2].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j2].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j2], textData.a[j2].s.totalChars);
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                  } else {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                } else if (mult.length) {
                  matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              letterSw = sw < 0 ? 0 : sw;
            }
            if (documentData.strokeColorAnim) {
              letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
            }
            if (documentData.fillColorAnim && documentData.fc) {
              letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
            }
            if (this._hasMaskedPath) {
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
              if (this._pathData.p.v) {
                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                var rot = Math.atan(tanAngle) * 180 / Math.PI;
                if (currentPoint.point[0] < prevPoint.point[0]) {
                  rot += 180;
                }
                matrixHelper.rotate(-rot * Math.PI / 180);
              }
              matrixHelper.translate(xPathPos, yPathPos, 0);
              currentLength -= alignment[0] * letters[i2].an * 5e-3;
              if (letters[i2 + 1] && ind !== letters[i2 + 1].ind) {
                currentLength += letters[i2].an / 2;
                currentLength += documentData.tr * 1e-3 * documentData.finalSize;
              }
            } else {
              matrixHelper.translate(xPos, yPos, 0);
              if (documentData.ps) {
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }
              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]), 0, 0);
                  break;
                case 2:
                  matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]) / 2, 0, 0);
                  break;
                default:
                  break;
              }
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(offf, 0, 0);
              matrixHelper.translate(alignment[0] * letters[i2].an * 5e-3, alignment[1] * yOff * 0.01, 0);
              xPos += letters[i2].l + documentData.tr * 1e-3 * documentData.finalSize;
            }
            if (renderType === "html") {
              letterM = matrixHelper.toCSS();
            } else if (renderType === "svg") {
              letterM = matrixHelper.to2dCSS();
            } else {
              letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
            }
            letterO = elemOpacity;
          }
          if (renderedLettersCount <= i2) {
            letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
            this.renderedLetters.push(letterValue);
            renderedLettersCount += 1;
            this.lettersChangedFlag = true;
          } else {
            letterValue = this.renderedLetters[i2];
            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
          }
        }
      };
      TextAnimatorProperty.prototype.getValue = function() {
        if (this._elem.globalData.frameId === this._frameId) {
          return;
        }
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      TextAnimatorProperty.prototype.mHelper = new Matrix();
      TextAnimatorProperty.prototype.defaultPropsArray = [];
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {
      }
      ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
      };
      ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      };
      ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j2;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = "";
        for (j2 = 0; j2 < jLen; j2 += 1) {
          if (shapes[j2].ty === "sh") {
            pathNodes = shapes[j2].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
        }
        return shapeStr;
      };
      ITextElement.prototype.updateDocumentData = function(newData, index2) {
        this.textProperty.updateDocumentData(newData, index2);
      };
      ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
      };
      ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
      };
      ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) {
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        matrixHelper.translate(0, -documentData.ls, 0);
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
            break;
          default:
            break;
        }
        matrixHelper.translate(xPos, yPos, 0);
      };
      ITextElement.prototype.buildColor = function(colorData) {
        return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
      };
      ITextElement.prototype.emptyProp = new LetterProps();
      ITextElement.prototype.destroy = function() {
      };
      ITextElement.prototype.validateText = function() {
        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
          this.buildNewText();
          this.textProperty._isFirstFrame = false;
          this.textProperty._mdf = false;
        }
      };
      var emptyShapeData = {
        shapes: []
      };
      function SVGTextLottieElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.renderType = "svg";
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
      SVGTextLottieElement.prototype.createContent = function() {
        if (this.data.singleShape && !this.globalData.fontManager.chars) {
          this.textContainer = createNS("text");
        }
      };
      SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
        var i2 = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = "";
        while (i2 < len) {
          if (textArray[i2] === String.fromCharCode(13) || textArray[i2] === String.fromCharCode(3)) {
            textContents.push(currentTextContent);
            currentTextContent = "";
          } else {
            currentTextContent += textArray[i2];
          }
          i2 += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
      };
      SVGTextLottieElement.prototype.buildShapeData = function(data2, scale3) {
        if (data2.shapes && data2.shapes.length) {
          var shape = data2.shapes[0];
          if (shape.it) {
            var shapeItem = shape.it[shape.it.length - 1];
            if (shapeItem.s) {
              shapeItem.s.k[0] = scale3;
              shapeItem.s.k[1] = scale3;
            }
          }
        }
        return data2;
      };
      SVGTextLottieElement.prototype.buildNewText = function() {
        this.addDynamicProperty(this);
        var i2;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if (documentData.fc) {
          this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
        } else {
          this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
        }
        if (documentData.sc) {
          this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
          this.layerElement.setAttribute("stroke-width", documentData.sw);
        }
        this.layerElement.setAttribute("font-size", documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (fontData.fClass) {
          this.layerElement.setAttribute("class", fontData.fClass);
        } else {
          this.layerElement.setAttribute("font-family", fontData.fFamily);
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          this.layerElement.setAttribute("font-style", fStyle);
          this.layerElement.setAttribute("font-weight", fWeight);
        }
        this.layerElement.setAttribute("aria-label", documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = "";
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        if (singleShape && !usesGlyphs && !documentData.sz) {
          var tElement = this.textContainer;
          var justify = "start";
          switch (documentData.j) {
            case 1:
              justify = "end";
              break;
            case 2:
              justify = "middle";
              break;
            default:
              justify = "start";
              break;
          }
          tElement.setAttribute("text-anchor", justify);
          tElement.setAttribute("letter-spacing", trackingOffset);
          var textContent = this.buildTextContents(documentData.finalText);
          len = textContent.length;
          yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            tSpan = this.textSpans[i2].span || createNS("tspan");
            tSpan.textContent = textContent[i2];
            tSpan.setAttribute("x", 0);
            tSpan.setAttribute("y", yPos);
            tSpan.style.display = "inherit";
            tElement.appendChild(tSpan);
            if (!this.textSpans[i2]) {
              this.textSpans[i2] = {
                span: null,
                glyph: null
              };
            }
            this.textSpans[i2].span = tSpan;
            yPos += documentData.finalLineHeight;
          }
          this.layerElement.appendChild(tElement);
        } else {
          var cachedSpansLength = this.textSpans.length;
          var charData;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!this.textSpans[i2]) {
              this.textSpans[i2] = {
                span: null,
                childSpan: null,
                glyph: null
              };
            }
            if (!usesGlyphs || !singleShape || i2 === 0) {
              tSpan = cachedSpansLength > i2 ? this.textSpans[i2].span : createNS(usesGlyphs ? "g" : "text");
              if (cachedSpansLength <= i2) {
                tSpan.setAttribute("stroke-linecap", "butt");
                tSpan.setAttribute("stroke-linejoin", "round");
                tSpan.setAttribute("stroke-miterlimit", "4");
                this.textSpans[i2].span = tSpan;
                if (usesGlyphs) {
                  var childSpan = createNS("g");
                  tSpan.appendChild(childSpan);
                  this.textSpans[i2].childSpan = childSpan;
                }
                this.textSpans[i2].span = tSpan;
                this.layerElement.appendChild(tSpan);
              }
              tSpan.style.display = "inherit";
            }
            matrixHelper.reset();
            if (singleShape) {
              if (letters[i2].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
              xPos += letters[i2].l || 0;
              xPos += trackingOffset;
            }
            if (usesGlyphs) {
              charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var glyphElement;
              if (charData.t === 1) {
                glyphElement = new SVGCompElement(charData.data, this.globalData, this);
              } else {
                var data2 = emptyShapeData;
                if (charData.data && charData.data.shapes) {
                  data2 = this.buildShapeData(charData.data, documentData.finalSize);
                }
                glyphElement = new SVGShapeElement(data2, this.globalData, this);
              }
              if (this.textSpans[i2].glyph) {
                var glyph = this.textSpans[i2].glyph;
                this.textSpans[i2].childSpan.removeChild(glyph.layerElement);
                glyph.destroy();
              }
              this.textSpans[i2].glyph = glyphElement;
              glyphElement._debug = true;
              glyphElement.prepareFrame(0);
              glyphElement.renderFrame();
              this.textSpans[i2].childSpan.appendChild(glyphElement.layerElement);
              if (charData.t === 1) {
                this.textSpans[i2].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
              }
            } else {
              if (singleShape) {
                tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
              }
              tSpan.textContent = letters[i2].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            }
          }
          if (singleShape && tSpan) {
            tSpan.setAttribute("d", shapeStr);
          }
        }
        while (i2 < this.textSpans.length) {
          this.textSpans[i2].span.style.display = "none";
          i2 += 1;
        }
        this._sizeChanged = true;
      };
      SVGTextLottieElement.prototype.sourceRectAtTime = function() {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if (this._sizeChanged) {
          this._sizeChanged = false;
          var textBox = this.layerElement.getBBox();
          this.bbox = {
            top: textBox.y,
            left: textBox.x,
            width: textBox.width,
            height: textBox.height
          };
        }
        return this.bbox;
      };
      SVGTextLottieElement.prototype.getValue = function() {
        var i2;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;
        for (i2 = 0; i2 < len; i2 += 1) {
          glyphElement = this.textSpans[i2].glyph;
          if (glyphElement) {
            glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
            if (glyphElement._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      SVGTextLottieElement.prototype.renderInnerContent = function() {
        this.validateText();
        if (!this.data.singleShape || this._mdf) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
            this._sizeChanged = true;
            var i2;
            var len;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var glyphElement;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!letters[i2].n) {
                renderedLetter = renderedLetters[i2];
                textSpan = this.textSpans[i2].span;
                glyphElement = this.textSpans[i2].glyph;
                if (glyphElement) {
                  glyphElement.renderFrame();
                }
                if (renderedLetter._mdf.m) {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
                if (renderedLetter._mdf.o) {
                  textSpan.setAttribute("opacity", renderedLetter.o);
                }
                if (renderedLetter._mdf.sw) {
                  textSpan.setAttribute("stroke-width", renderedLetter.sw);
                }
                if (renderedLetter._mdf.sc) {
                  textSpan.setAttribute("stroke", renderedLetter.sc);
                }
                if (renderedLetter._mdf.fc) {
                  textSpan.setAttribute("fill", renderedLetter.fc);
                }
              }
            }
          }
        }
      };
      function ISolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([IImageElement], ISolidElement);
      ISolidElement.prototype.createContent = function() {
        var rect = createNS("rect");
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.layerElement.appendChild(rect);
      };
      function NullElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initFrame();
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
      }
      NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      NullElement.prototype.renderFrame = function() {
      };
      NullElement.prototype.getBaseElement = function() {
        return null;
      };
      NullElement.prototype.destroy = function() {
      };
      NullElement.prototype.sourceRectAtTime = function() {
      };
      NullElement.prototype.hide = function() {
      };
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
      function SVGRendererBase() {
      }
      extendPrototype([BaseRenderer], SVGRendererBase);
      SVGRendererBase.prototype.createNull = function(data2) {
        return new NullElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createShape = function(data2) {
        return new SVGShapeElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createText = function(data2) {
        return new SVGTextLottieElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createImage = function(data2) {
        return new IImageElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createSolid = function(data2) {
        return new ISolidElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.configAnimation = function(animData) {
        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        if (this.renderConfig.viewBoxSize) {
          this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
        } else {
          this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
        }
        if (!this.renderConfig.viewBoxOnly) {
          this.svgElement.setAttribute("width", animData.w);
          this.svgElement.setAttribute("height", animData.h);
          this.svgElement.style.width = "100%";
          this.svgElement.style.height = "100%";
          this.svgElement.style.transform = "translate3d(0,0,0)";
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }
        if (this.renderConfig.width) {
          this.svgElement.setAttribute("width", this.renderConfig.width);
        }
        if (this.renderConfig.height) {
          this.svgElement.setAttribute("height", this.renderConfig.height);
        }
        if (this.renderConfig.className) {
          this.svgElement.setAttribute("class", this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.svgElement.setAttribute("id", this.renderConfig.id);
        }
        if (this.renderConfig.focusable !== void 0) {
          this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
        }
        this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
        this.animationItem.wrapper.appendChild(this.svgElement);
        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS("clipPath");
        var rect = createNS("rect");
        rect.setAttribute("width", animData.w);
        rect.setAttribute("height", animData.h);
        rect.setAttribute("x", 0);
        rect.setAttribute("y", 0);
        var maskId = createElementID();
        maskElement.setAttribute("id", maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
      };
      SVGRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.layerElement = null;
        this.globalData.defs = null;
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      SVGRendererBase.prototype.updateContainerSize = function() {
      };
      SVGRendererBase.prototype.findIndexByInd = function(ind) {
        var i2 = 0;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.layers[i2].ind === ind) {
            return i2;
          }
        }
        return -1;
      };
      SVGRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;
        if (getExpressionsPlugin()) {
          if (this.layers[pos].ty === 0) {
            this.globalData.projectInterface.registerComposition(element);
          }
          element.initExpressions();
        }
        this.appendElementInPos(element, pos);
        if (this.layers[pos].tt) {
          var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
          if (elementIndex === -1) {
            return;
          }
          if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
            this.buildItem(elementIndex);
            this.addPendingElement(element);
          } else {
            var matteElement = elements[elementIndex];
            var matteMask = matteElement.getMatte(this.layers[pos].tt);
            element.setMatte(matteMask);
          }
        }
      };
      SVGRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
          if (element.data.tt) {
            var i2 = 0;
            var len = this.elements.length;
            while (i2 < len) {
              if (this.elements[i2] === element) {
                var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i2 - 1;
                var matteElement = this.elements[elementIndex];
                var matteMask = matteElement.getMatte(this.layers[i2].tt);
                element.setMatte(matteMask);
                break;
              }
              i2 += 1;
            }
          }
        }
      };
      SVGRendererBase.prototype.renderFrame = function(num) {
        if (this.renderedFrame === num || this.destroyed) {
          return;
        }
        if (num === null) {
          num = this.renderedFrame;
        } else {
          this.renderedFrame = num;
        }
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i2;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(num - this.layers[i2].st);
          }
        }
        if (this.globalData._mdf) {
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
        }
      };
      SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newElement = element.getBaseElement();
        if (!newElement) {
          return;
        }
        var i2 = 0;
        var nextElement;
        while (i2 < pos) {
          if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement()) {
            nextElement = this.elements[i2].getBaseElement();
          }
          i2 += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(newElement, nextElement);
        } else {
          this.layerElement.appendChild(newElement);
        }
      };
      SVGRendererBase.prototype.hide = function() {
        this.layerElement.style.display = "none";
      };
      SVGRendererBase.prototype.show = function() {
        this.layerElement.style.display = "block";
      };
      function ICompElement() {
      }
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
      ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initTransform(data2, globalData2, comp2);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if (this.data.xt || !globalData2.progressiveLoad) {
          this.buildAllItems();
        }
        this.hide();
      };
      ICompElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (!this.isInRange && !this.data.xt) {
          return;
        }
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          if (timeRemapped === this.data.op) {
            timeRemapped = this.data.op - 1;
          }
          this.renderedFrame = timeRemapped;
        } else {
          this.renderedFrame = num / this.data.sr;
        }
        var i2;
        var len = this.elements.length;
        if (!this.completeLayers) {
          this.checkLayers(this.renderedFrame);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(this.renderedFrame - this.layers[i2].st);
            if (this.elements[i2]._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      ICompElement.prototype.renderInnerContent = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].renderFrame();
          }
        }
      };
      ICompElement.prototype.setElements = function(elems) {
        this.elements = elems;
      };
      ICompElement.prototype.getElements = function() {
        return this.elements;
      };
      ICompElement.prototype.destroyElements = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2]) {
            this.elements[i2].destroy();
          }
        }
      };
      ICompElement.prototype.destroy = function() {
        this.destroyElements();
        this.destroyBaseElement();
      };
      function SVGCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
      SVGCompElement.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function SVGRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS("svg");
        var ariaLabel = "";
        if (config && config.title) {
          var titleElement = createNS("title");
          var titleId = createElementID();
          titleElement.setAttribute("id", titleId);
          titleElement.textContent = config.title;
          this.svgElement.appendChild(titleElement);
          ariaLabel += titleId;
        }
        if (config && config.description) {
          var descElement = createNS("desc");
          var descId = createElementID();
          descElement.setAttribute("id", descId);
          descElement.textContent = config.description;
          this.svgElement.appendChild(descElement);
          ariaLabel += " " + descId;
        }
        if (ariaLabel) {
          this.svgElement.setAttribute("aria-labelledby", ariaLabel);
        }
        var defs = createNS("defs");
        this.svgElement.appendChild(defs);
        var maskElement = createNS("g");
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          progressiveLoad: config && config.progressiveLoad || false,
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          viewBoxOnly: config && config.viewBoxOnly || false,
          viewBoxSize: config && config.viewBoxSize || false,
          className: config && config.className || "",
          id: config && config.id || "",
          focusable: config && config.focusable,
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "100%",
            height: config && config.filterSize && config.filterSize.height || "100%",
            x: config && config.filterSize && config.filterSize.x || "0%",
            y: config && config.filterSize && config.filterSize.y || "0%"
          },
          width: config && config.width,
          height: config && config.height,
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          defs,
          renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = "svg";
      }
      extendPrototype([SVGRendererBase], SVGRenderer);
      SVGRenderer.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
          var i2;
          var len = transforms.length;
          var key2 = "_";
          for (i2 = 0; i2 < len; i2 += 1) {
            key2 += transforms[i2].transform.key + "_";
          }
          var sequence = this.sequences[key2];
          if (!sequence) {
            sequence = {
              transforms: [].concat(transforms),
              finalTransform: new Matrix(),
              _mdf: false
            };
            this.sequences[key2] = sequence;
            this.sequenceList.push(sequence);
          }
          return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
          var i2 = 0;
          var len = sequence.transforms.length;
          var _mdf = isFirstFrame;
          while (i2 < len && !isFirstFrame) {
            if (sequence.transforms[i2].transform.mProps._mdf) {
              _mdf = true;
              break;
            }
            i2 += 1;
          }
          if (_mdf) {
            sequence.finalTransform.reset();
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              sequence.finalTransform.multiply(sequence.transforms[i2].transform.mProps.v);
            }
          }
          sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
          var i2;
          var len = this.sequenceList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.processSequence(this.sequenceList[i2], isFirstFrame);
          }
        },
        getNewKey: function getNewKey() {
          this.transform_key_count += 1;
          return "_" + this.transform_key_count;
        }
      };
      var lumaLoader = function lumaLoader2() {
        var id = "__lottie_element_luma_buffer";
        var lumaBuffer = null;
        var lumaBufferCtx = null;
        var svg = null;
        function createLumaSvgFilter() {
          var _svg = createNS("svg");
          var fil = createNS("filter");
          var matrix = createNS("feColorMatrix");
          fil.setAttribute("id", id);
          matrix.setAttribute("type", "matrix");
          matrix.setAttribute("color-interpolation-filters", "sRGB");
          matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
          fil.appendChild(matrix);
          _svg.appendChild(fil);
          _svg.setAttribute("id", id + "_svg");
          if (featureSupport.svgLumaHidden) {
            _svg.style.display = "none";
          }
          return _svg;
        }
        function loadLuma() {
          if (!lumaBuffer) {
            svg = createLumaSvgFilter();
            document.body.appendChild(svg);
            lumaBuffer = createTag("canvas");
            lumaBufferCtx = lumaBuffer.getContext("2d");
            lumaBufferCtx.filter = "url(#" + id + ")";
            lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
            lumaBufferCtx.fillRect(0, 0, 1, 1);
          }
        }
        function getLuma(canvas) {
          if (!lumaBuffer) {
            loadLuma();
          }
          lumaBuffer.width = canvas.width;
          lumaBuffer.height = canvas.height;
          lumaBufferCtx.filter = "url(#" + id + ")";
          return lumaBuffer;
        }
        return {
          load: loadLuma,
          get: getLuma
        };
      };
      function createCanvas(width2, height2) {
        if (featureSupport.offscreenCanvas) {
          return new OffscreenCanvas(width2, height2);
        }
        var canvas = createTag("canvas");
        canvas.width = width2;
        canvas.height = height2;
        return canvas;
      }
      var assetLoader = function() {
        return {
          loadLumaCanvas: lumaLoader.load,
          getLumaCanvas: lumaLoader.get,
          createCanvas
        };
      }();
      var registeredEffects = {};
      function CVEffects(elem2) {
        var i2;
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        this.filters = [];
        var filterManager;
        for (i2 = 0; i2 < len; i2 += 1) {
          filterManager = null;
          var type = elem2.data.ef[i2].ty;
          if (registeredEffects[type]) {
            var Effect = registeredEffects[type].effect;
            filterManager = new Effect(elem2.effectsManager.effectElements[i2], elem2);
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      CVEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i2;
        var len = this.filters.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.filters[i2].renderFrame(_isFirstFrame);
        }
      };
      CVEffects.prototype.getEffects = function(type) {
        var i2;
        var len = this.filters.length;
        var effects = [];
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.filters[i2].type === type) {
            effects.push(this.filters[i2]);
          }
        }
        return effects;
      };
      function registerEffect(id, effect2) {
        registeredEffects[id] = {
          effect: effect2
        };
      }
      function CVMaskElement(data2, element) {
        this.data = data2;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i2;
        var len = this.masksProperties.length;
        var hasMasks = false;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.masksProperties[i2].mode !== "n") {
            hasMasks = true;
          }
          this.viewData[i2] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i2], 3);
        }
        this.hasMasks = hasMasks;
        if (hasMasks) {
          this.element.addRenderableComponent(this);
        }
      }
      CVMaskElement.prototype.renderFrame = function() {
        if (!this.hasMasks) {
          return;
        }
        var transform2 = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i2;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data2;
        ctx.beginPath();
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.masksProperties[i2].mode !== "n") {
            if (this.masksProperties[i2].inv) {
              ctx.moveTo(0, 0);
              ctx.lineTo(this.element.globalData.compSize.w, 0);
              ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
              ctx.lineTo(0, this.element.globalData.compSize.h);
              ctx.lineTo(0, 0);
            }
            data2 = this.viewData[i2].v;
            pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
            ctx.moveTo(pt[0], pt[1]);
            var j2;
            var jLen = data2._length;
            for (j2 = 1; j2 < jLen; j2 += 1) {
              pts = transform2.applyToTriplePoints(data2.o[j2 - 1], data2.i[j2], data2.v[j2]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
            pts = transform2.applyToTriplePoints(data2.o[j2 - 1], data2.i[0], data2.v[0]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
        }
        this.element.globalData.renderer.save(true);
        ctx.clip();
      };
      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
      CVMaskElement.prototype.destroy = function() {
        this.element = null;
      };
      function CVBaseElement() {
      }
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out"
      };
      CVBaseElement.prototype = {
        createElements: function createElements() {
        },
        initRendererElement: function initRendererElement() {
        },
        createContainerElements: function createContainerElements() {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var canvasContext = this.globalData.canvasContext;
            var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas);
            var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas2);
            if (this.data.tt >= 3 && !document._isProxy) {
              assetLoader.loadLumaCanvas();
            }
          }
          this.canvasContext = this.globalData.canvasContext;
          this.transformCanvas = this.globalData.transformCanvas;
          this.renderableEffectsManager = new CVEffects(this);
          this.searchEffectTransforms();
        },
        createContent: function createContent() {
        },
        setBlendMode: function setBlendMode() {
          var globalData2 = this.globalData;
          if (globalData2.blendMode !== this.data.bm) {
            globalData2.blendMode = this.data.bm;
            var blendModeValue = getBlendMode(this.data.bm);
            globalData2.canvasContext.globalCompositeOperation = blendModeValue;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new CVMaskElement(this.data, this);
          this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
        },
        hideElement: function hideElement() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            this.hidden = true;
          }
        },
        showElement: function showElement() {
          if (this.isInRange && !this.isTransparent) {
            this.hidden = false;
            this._isFirstFrame = true;
            this.maskManager._isFirstFrame = true;
          }
        },
        clearCanvas: function clearCanvas(canvasContext) {
          canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
        },
        prepareLayer: function prepareLayer() {
          if (this.data.tt >= 1) {
            var buffer2 = this.buffers[0];
            var bufferCtx = buffer2.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.currentTransform = this.canvasContext.getTransform();
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function exitLayer() {
          if (this.data.tt >= 1) {
            var buffer2 = this.buffers[1];
            var bufferCtx = buffer2.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
            var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
            mask2.renderFrame(true);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            if (this.data.tt >= 3 && !document._isProxy) {
              var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
              var lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.drawImage(lumaBuffer, 0, 0);
            }
            this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
            this.canvasContext.drawImage(buffer2, 0, 0);
            this.canvasContext.globalCompositeOperation = "destination-over";
            this.canvasContext.drawImage(this.buffers[0], 0, 0);
            this.canvasContext.setTransform(this.currentTransform);
            this.canvasContext.globalCompositeOperation = "source-over";
          }
        },
        renderFrame: function renderFrame(forceRender) {
          if (this.hidden || this.data.hd) {
            return;
          }
          if (this.data.td === 1 && !forceRender) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.setBlendMode();
          var forceRealStack = this.data.ty === 0;
          this.prepareLayer();
          this.globalData.renderer.save(forceRealStack);
          this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
          this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
          this.renderInnerContent();
          this.globalData.renderer.restore(forceRealStack);
          this.exitLayer();
          if (this.maskManager.hasMasks) {
            this.globalData.renderer.restore(true);
          }
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.canvasContext = null;
          this.data = null;
          this.globalData = null;
          this.maskManager.destroy();
        },
        mHelper: new Matrix()
      };
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
      function CVShapeData(element, data2, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0, 0, 0, 0, 0, 0];
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
        var i2;
        var len = styles.length;
        var styledShape;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!styles[i2].closed) {
            styledShape = {
              transforms: transformsManager.addTransformSequence(styles[i2].transforms),
              trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i2].elements.push(styledShape);
          }
        }
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
      CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
      };
      CVShapeElement.prototype.dashResetter = [];
      CVShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      };
      CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
        var styleElem = {
          data: data2,
          type: data2.ty,
          preTransforms: this.transformsManager.addTransformSequence(transforms),
          transforms: [],
          elements: [],
          closed: data2.hd === true
        };
        var elementData = {};
        if (data2.ty === "fl" || data2.ty === "st") {
          elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
          if (!elementData.c.k) {
            styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
          }
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
          elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
          elementData.h = PropertyFactory.getProp(this, data2.h || {
            k: 0
          }, 0, 0.01, this);
          elementData.a = PropertyFactory.getProp(this, data2.a || {
            k: 0
          }, 0, degToRads, this);
          elementData.g = new GradientProperty(this, data2.g, this);
        }
        elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
        if (data2.ty === "st" || data2.ty === "gs") {
          styleElem.lc = lineCapEnum[data2.lc || 2];
          styleElem.lj = lineJoinEnum[data2.lj || 2];
          if (data2.lj == 1) {
            styleElem.ml = data2.ml;
          }
          elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
          if (!elementData.w.k) {
            styleElem.wi = elementData.w.v;
          }
          if (data2.d) {
            var d2 = new DashProperty(this, data2.d, "canvas", this);
            elementData.d = d2;
            if (!elementData.d.k) {
              styleElem.da = elementData.d.dashArray;
              styleElem["do"] = elementData.d.dashoffset[0];
            }
          }
        } else {
          styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
        }
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
      };
      CVShapeElement.prototype.createGroupElement = function() {
        var elementData = {
          it: [],
          prevViewData: []
        };
        return elementData;
      };
      CVShapeElement.prototype.createTransformElement = function(data2) {
        var elementData = {
          transform: {
            opacity: 1,
            _opMdf: false,
            key: this.transformsManager.getNewKey(),
            op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
            mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
          }
        };
        return elementData;
      };
      CVShapeElement.prototype.createShapeElement = function(data2) {
        var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
      };
      CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i2;
        var len = this.itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.prevViewData[i2] = this.itemsData[i2];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.dynamicProperties[i2].getValue();
        }
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
      };
      CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!this.stylesList[i2].closed) {
            this.stylesList[i2].transforms.push(transform2);
          }
        }
      };
      CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!this.stylesList[i2].closed) {
            this.stylesList[i2].transforms.pop();
          }
        }
      };
      CVShapeElement.prototype.closeStyles = function(styles) {
        var i2;
        var len = styles.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          styles[i2].closed = true;
        }
      };
      CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
        var i2;
        var len = arr.length - 1;
        var j2;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);
        for (i2 = len; i2 >= 0; i2 -= 1) {
          processedPos = this.searchProcessedElement(arr[i2]);
          if (!processedPos) {
            arr[i2]._shouldRender = shouldRender;
          } else {
            itemsData[i2] = prevViewData[processedPos - 1];
          }
          if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs") {
            if (!processedPos) {
              itemsData[i2] = this.createStyleElement(arr[i2], ownTransforms);
            } else {
              itemsData[i2].style.closed = false;
            }
            ownStyles.push(itemsData[i2].style);
          } else if (arr[i2].ty === "gr") {
            if (!processedPos) {
              itemsData[i2] = this.createGroupElement(arr[i2]);
            } else {
              jLen = itemsData[i2].it.length;
              for (j2 = 0; j2 < jLen; j2 += 1) {
                itemsData[i2].prevViewData[j2] = itemsData[i2].it[j2];
              }
            }
            this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, shouldRender, ownTransforms);
          } else if (arr[i2].ty === "tr") {
            if (!processedPos) {
              currentTransform = this.createTransformElement(arr[i2]);
              itemsData[i2] = currentTransform;
            }
            ownTransforms.push(itemsData[i2]);
            this.addTransformToStyleList(itemsData[i2]);
          } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
            if (!processedPos) {
              itemsData[i2] = this.createShapeElement(arr[i2]);
            }
          } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "pb" || arr[i2].ty === "zz" || arr[i2].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              modifier.init(this, arr[i2]);
              itemsData[i2] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i2];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i2].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              itemsData[i2] = modifier;
              modifier.init(this, arr, i2, itemsData);
              this.shapeModifiers.push(modifier);
              shouldRender = false;
            } else {
              modifier = itemsData[i2];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i2], i2 + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownModifiers[i2].closed = true;
        }
      };
      CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
      };
      CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
          groupTransform.opacity = parentTransform.opacity;
          groupTransform.opacity *= groupTransform.op.v;
          groupTransform._opMdf = true;
        }
      };
      CVShapeElement.prototype.drawLayer = function() {
        var i2;
        var len = this.stylesList.length;
        var j2;
        var jLen;
        var k2;
        var kLen;
        var elems;
        var nodes;
        var renderer2 = this.globalData.renderer;
        var ctx = this.globalData.canvasContext;
        var type;
        var currentStyle;
        for (i2 = 0; i2 < len; i2 += 1) {
          currentStyle = this.stylesList[i2];
          type = currentStyle.type;
          if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
            renderer2.save();
            elems = currentStyle.elements;
            if (type === "st" || type === "gs") {
              renderer2.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
              renderer2.ctxLineWidth(currentStyle.wi);
              renderer2.ctxLineCap(currentStyle.lc);
              renderer2.ctxLineJoin(currentStyle.lj);
              renderer2.ctxMiterLimit(currentStyle.ml || 0);
            } else {
              renderer2.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
            }
            renderer2.ctxOpacity(currentStyle.coOp);
            if (type !== "st" && type !== "gs") {
              ctx.beginPath();
            }
            renderer2.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;
            for (j2 = 0; j2 < jLen; j2 += 1) {
              if (type === "st" || type === "gs") {
                ctx.beginPath();
                if (currentStyle.da) {
                  ctx.setLineDash(currentStyle.da);
                  ctx.lineDashOffset = currentStyle["do"];
                }
              }
              nodes = elems[j2].trNodes;
              kLen = nodes.length;
              for (k2 = 0; k2 < kLen; k2 += 1) {
                if (nodes[k2].t === "m") {
                  ctx.moveTo(nodes[k2].p[0], nodes[k2].p[1]);
                } else if (nodes[k2].t === "c") {
                  ctx.bezierCurveTo(nodes[k2].pts[0], nodes[k2].pts[1], nodes[k2].pts[2], nodes[k2].pts[3], nodes[k2].pts[4], nodes[k2].pts[5]);
                } else {
                  ctx.closePath();
                }
              }
              if (type === "st" || type === "gs") {
                renderer2.ctxStroke();
                if (currentStyle.da) {
                  ctx.setLineDash(this.dashResetter);
                }
              }
            }
            if (type !== "st" && type !== "gs") {
              this.globalData.renderer.ctxFill(currentStyle.r);
            }
            renderer2.restore();
          }
        }
      };
      CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
        var i2;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for (i2 = len; i2 >= 0; i2 -= 1) {
          if (items[i2].ty === "tr") {
            groupTransform = data2[i2].transform;
            this.renderShapeTransform(parentTransform, groupTransform);
          } else if (items[i2].ty === "sh" || items[i2].ty === "el" || items[i2].ty === "rc" || items[i2].ty === "sr") {
            this.renderPath(items[i2], data2[i2]);
          } else if (items[i2].ty === "fl") {
            this.renderFill(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "st") {
            this.renderStroke(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "gf" || items[i2].ty === "gs") {
            this.renderGradientFill(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "gr") {
            this.renderShape(groupTransform, items[i2].it, data2[i2].it);
          } else if (items[i2].ty === "tm") {
          }
        }
        if (isMain) {
          this.drawLayer();
        }
      };
      CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
          var shapeNodes = styledShape.trNodes;
          var paths = shape.paths;
          var i2;
          var len;
          var j2;
          var jLen = paths._length;
          shapeNodes.length = 0;
          var groupTransformMat = styledShape.transforms.finalTransform;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            var pathNodes = paths.shapes[j2];
            if (pathNodes && pathNodes.v) {
              len = pathNodes._length;
              for (i2 = 1; i2 < len; i2 += 1) {
                if (i2 === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[i2], pathNodes.v[i2])
                });
              }
              if (len === 1) {
                shapeNodes.push({
                  t: "m",
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              if (pathNodes.c && len) {
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[0], pathNodes.v[0])
                });
                shapeNodes.push({
                  t: "z"
                });
              }
            }
          }
          styledShape.trNodes = shapeNodes;
        }
      };
      CVShapeElement.prototype.renderPath = function(pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
          var i2;
          var len = itemData.styledShapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.renderStyledShape(itemData.styledShapes[i2], itemData.sh);
          }
        }
      };
      CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
      };
      CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;
        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
          var ctx = this.globalData.canvasContext;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (styleData.t === 1) {
            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
          } else {
            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x3 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y3 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            grd = ctx.createRadialGradient(x3, y3, 0, pt1[0], pt1[1], rad);
          }
          var i2;
          var len = styleData.g.p;
          var cValues = itemData.g.c;
          var opacity = 1;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (itemData.g._hasOpacity && itemData.g._collapsable) {
              opacity = itemData.g.o[i2 * 2 + 1];
            }
            grd.addColorStop(cValues[i2 * 4] / 100, "rgba(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + "," + opacity + ")");
          }
          styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      };
      CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d2 = itemData.d;
        if (d2 && (d2._mdf || this._isFirstFrame)) {
          styleElem.da = d2.dashArray;
          styleElem["do"] = d2.dashoffset[0];
        }
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
        if (itemData.w._mdf || this._isFirstFrame) {
          styleElem.wi = itemData.w.v;
        }
      };
      CVShapeElement.prototype.destroy = function() {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
      };
      function CVTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = "canvas";
        this.values = {
          fill: "rgba(0,0,0,0)",
          stroke: "rgba(0,0,0,0)",
          sWidth: 0,
          fValue: ""
        };
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
      CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
      CVTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;
        if (documentData.fc) {
          hasFill = true;
          this.values.fill = this.buildColor(documentData.fc);
        } else {
          this.values.fill = "rgba(0,0,0,0)";
        }
        this.fill = hasFill;
        var hasStroke = false;
        if (documentData.sc) {
          hasStroke = true;
          this.values.stroke = this.buildColor(documentData.sc);
          this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i2;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length;
        var charData;
        var shapeData;
        var k2;
        var kLen;
        var shapes;
        var j2;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          matrixHelper.reset();
          if (singleShape && letters[i2].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }
          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
          jLen = shapes.length;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          if (singleShape) {
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
          }
          commands = createSizedArray(jLen - 1);
          var commandsCounter = 0;
          for (j2 = 0; j2 < jLen; j2 += 1) {
            if (shapes[j2].ty === "sh") {
              kLen = shapes[j2].ks.k.i.length;
              pathNodes = shapes[j2].ks.k;
              pathArr = [];
              for (k2 = 1; k2 < kLen; k2 += 1) {
                if (k2 === 1) {
                  pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToY(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToX(pathNodes.v[k2][0], pathNodes.v[k2][1], 0), matrixHelper.applyToY(pathNodes.v[k2][0], pathNodes.v[k2][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              commands[commandsCounter] = pathArr;
              commandsCounter += 1;
            }
          }
          if (singleShape) {
            xPos += letters[i2].l;
            xPos += trackingOffset;
          }
          if (this.textSpans[cnt]) {
            this.textSpans[cnt].elem = commands;
          } else {
            this.textSpans[cnt] = {
              elem: commands
            };
          }
          cnt += 1;
        }
      };
      CVTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var ctx = this.canvasContext;
        ctx.font = this.values.fValue;
        this.globalData.renderer.ctxLineCap("butt");
        this.globalData.renderer.ctxLineJoin("miter");
        this.globalData.renderer.ctxMiterLimit(4);
        if (!this.data.singleShape) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }
        var i2;
        var len;
        var j2;
        var jLen;
        var k2;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;
        var renderer2 = this.globalData.renderer;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!letters[i2].n) {
            renderedLetter = renderedLetters[i2];
            if (renderedLetter) {
              renderer2.save();
              renderer2.ctxTransform(renderedLetter.p);
              renderer2.ctxOpacity(renderedLetter.o);
            }
            if (this.fill) {
              if (renderedLetter && renderedLetter.fc) {
                if (lastFill !== renderedLetter.fc) {
                  renderer2.ctxFillStyle(renderedLetter.fc);
                  lastFill = renderedLetter.fc;
                }
              } else if (lastFill !== this.values.fill) {
                lastFill = this.values.fill;
                renderer2.ctxFillStyle(this.values.fill);
              }
              commands = this.textSpans[i2].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathArr = commands[j2];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k2 = 2; k2 < kLen; k2 += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxFill();
            }
            if (this.stroke) {
              if (renderedLetter && renderedLetter.sw) {
                if (lastStrokeW !== renderedLetter.sw) {
                  lastStrokeW = renderedLetter.sw;
                  renderer2.ctxLineWidth(renderedLetter.sw);
                }
              } else if (lastStrokeW !== this.values.sWidth) {
                lastStrokeW = this.values.sWidth;
                renderer2.ctxLineWidth(this.values.sWidth);
              }
              if (renderedLetter && renderedLetter.sc) {
                if (lastStroke !== renderedLetter.sc) {
                  lastStroke = renderedLetter.sc;
                  renderer2.ctxStrokeStyle(renderedLetter.sc);
                }
              } else if (lastStroke !== this.values.stroke) {
                lastStroke = this.values.stroke;
                renderer2.ctxStrokeStyle(this.values.stroke);
              }
              commands = this.textSpans[i2].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j2 = 0; j2 < jLen; j2 += 1) {
                pathArr = commands[j2];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k2 = 2; k2 < kLen; k2 += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxStroke();
            }
            if (renderedLetter) {
              this.globalData.renderer.restore();
            }
          }
        }
      };
      function CVImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.img = globalData2.imageLoader.getAsset(this.assetData);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVImageElement.prototype.createContent = function() {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
          var canvas = createTag("canvas");
          canvas.width = this.assetData.w;
          canvas.height = this.assetData.h;
          var ctx = canvas.getContext("2d");
          var imgW = this.img.width;
          var imgH = this.img.height;
          var imgRel = imgW / imgH;
          var canvasRel = this.assetData.w / this.assetData.h;
          var widthCrop;
          var heightCrop;
          var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
          if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
            heightCrop = imgH;
            widthCrop = heightCrop * canvasRel;
          } else {
            widthCrop = imgW;
            heightCrop = widthCrop / canvasRel;
          }
          ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
          this.img = canvas;
        }
      };
      CVImageElement.prototype.renderInnerContent = function() {
        this.canvasContext.drawImage(this.img, 0, 0);
      };
      CVImageElement.prototype.destroy = function() {
        this.img = null;
      };
      function CVSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVSolidElement.prototype.renderInnerContent = function() {
        this.globalData.renderer.ctxFillStyle(this.data.sc);
        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
      };
      function CanvasRendererBase() {
      }
      extendPrototype([BaseRenderer], CanvasRendererBase);
      CanvasRendererBase.prototype.createShape = function(data2) {
        return new CVShapeElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createText = function(data2) {
        return new CVTextElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createImage = function(data2) {
        return new CVImageElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createSolid = function(data2) {
        return new CVSolidElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      CanvasRendererBase.prototype.ctxTransform = function(props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
          return;
        }
        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
      };
      CanvasRendererBase.prototype.ctxOpacity = function(op) {
        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
      };
      CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
        this.canvasContext.fillStyle = value2;
      };
      CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
        this.canvasContext.strokeStyle = value2;
      };
      CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
        this.canvasContext.lineWidth = value2;
      };
      CanvasRendererBase.prototype.ctxLineCap = function(value2) {
        this.canvasContext.lineCap = value2;
      };
      CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
        this.canvasContext.lineJoin = value2;
      };
      CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
        this.canvasContext.miterLimit = value2;
      };
      CanvasRendererBase.prototype.ctxFill = function(rule) {
        this.canvasContext.fill(rule);
      };
      CanvasRendererBase.prototype.ctxFillRect = function(x3, y3, w2, h2) {
        this.canvasContext.fillRect(x3, y3, w2, h2);
      };
      CanvasRendererBase.prototype.ctxStroke = function() {
        this.canvasContext.stroke();
      };
      CanvasRendererBase.prototype.reset = function() {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        this.contextData.reset();
      };
      CanvasRendererBase.prototype.save = function() {
        this.canvasContext.save();
      };
      CanvasRendererBase.prototype.restore = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        if (actionFlag) {
          this.globalData.blendMode = "source-over";
        }
        this.contextData.restore(actionFlag);
      };
      CanvasRendererBase.prototype.configAnimation = function(animData) {
        if (this.animationItem.wrapper) {
          this.animationItem.container = createTag("canvas");
          var containerStyle = this.animationItem.container.style;
          containerStyle.width = "100%";
          containerStyle.height = "100%";
          var origin = "0px 0px 0px";
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          containerStyle["-webkit-transform"] = origin;
          containerStyle.contentVisibility = this.renderConfig.contentVisibility;
          this.animationItem.wrapper.appendChild(this.animationItem.container);
          this.canvasContext = this.animationItem.container.getContext("2d");
          if (this.renderConfig.className) {
            this.animationItem.container.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.animationItem.container.setAttribute("id", this.renderConfig.id);
          }
        } else {
          this.canvasContext = this.renderConfig.context;
        }
        this.contextData.setContext(this.canvasContext);
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
          w: animData.w,
          h: animData.h,
          sx: 0,
          sy: 0,
          tx: 0,
          ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
      };
      CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
        this.reset();
        var elementWidth;
        var elementHeight;
        if (width2) {
          elementWidth = width2;
          elementHeight = height2;
          this.canvasContext.canvas.width = elementWidth;
          this.canvasContext.canvas.height = elementHeight;
        } else {
          if (this.animationItem.wrapper && this.animationItem.container) {
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
          } else {
            elementWidth = this.canvasContext.canvas.width;
            elementHeight = this.canvasContext.canvas.height;
          }
          this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
          this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
        }
        var elementRel;
        var animationRel;
        if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
          var par = this.renderConfig.preserveAspectRatio.split(" ");
          var fillType = par[1] || "meet";
          var pos = par[0] || "xMidYMid";
          var xPos = pos.substr(0, 4);
          var yPos = pos.substr(4);
          elementRel = elementWidth / elementHeight;
          animationRel = this.transformCanvas.w / this.transformCanvas.h;
          if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          } else {
            this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          }
          if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
          } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.tx = 0;
          }
          if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
          } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.ty = 0;
          }
        } else if (this.renderConfig.preserveAspectRatio === "none") {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        } else {
          this.transformCanvas.sx = this.renderConfig.dpr;
          this.transformCanvas.sy = this.renderConfig.dpr;
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
      };
      CanvasRendererBase.prototype.destroy = function() {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
      };
      CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
          return;
        }
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num;
        var i2;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(num - this.layers[i2].st);
          }
        }
        if (this.globalData._mdf) {
          if (this.renderConfig.clearCanvas === true) {
            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          } else {
            this.save();
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
          if (this.renderConfig.clearCanvas !== true) {
            this.restore();
          }
        }
      };
      CanvasRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
      };
      CanvasRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      CanvasRendererBase.prototype.hide = function() {
        this.animationItem.container.style.display = "none";
      };
      CanvasRendererBase.prototype.show = function() {
        this.animationItem.container.style.display = "block";
      };
      function CanvasContext() {
        this.opacity = -1;
        this.transform = createTypedArray("float32", 16);
        this.fillStyle = "";
        this.strokeStyle = "";
        this.lineWidth = "";
        this.lineCap = "";
        this.lineJoin = "";
        this.miterLimit = "";
        this.id = Math.random();
      }
      function CVContextData() {
        this.stack = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        var i2;
        var len = 15;
        for (i2 = 0; i2 < len; i2 += 1) {
          var canvasContext = new CanvasContext();
          this.stack[i2] = canvasContext;
        }
        this._length = len;
        this.nativeContext = null;
        this.transformMat = new Matrix();
        this.currentOpacity = 1;
        this.currentFillStyle = "";
        this.appliedFillStyle = "";
        this.currentStrokeStyle = "";
        this.appliedStrokeStyle = "";
        this.currentLineWidth = "";
        this.appliedLineWidth = "";
        this.currentLineCap = "";
        this.appliedLineCap = "";
        this.currentLineJoin = "";
        this.appliedLineJoin = "";
        this.appliedMiterLimit = "";
        this.currentMiterLimit = "";
      }
      CVContextData.prototype.duplicate = function() {
        var newLength = this._length * 2;
        var i2 = 0;
        for (i2 = this._length; i2 < newLength; i2 += 1) {
          this.stack[i2] = new CanvasContext();
        }
        this._length = newLength;
      };
      CVContextData.prototype.reset = function() {
        this.cArrPos = 0;
        this.cTr.reset();
        this.stack[this.cArrPos].opacity = 1;
      };
      CVContextData.prototype.restore = function(forceRestore) {
        this.cArrPos -= 1;
        var currentContext = this.stack[this.cArrPos];
        var transform2 = currentContext.transform;
        var i2;
        var arr = this.cTr.props;
        for (i2 = 0; i2 < 16; i2 += 1) {
          arr[i2] = transform2[i2];
        }
        if (forceRestore) {
          this.nativeContext.restore();
          var prevStack = this.stack[this.cArrPos + 1];
          this.appliedFillStyle = prevStack.fillStyle;
          this.appliedStrokeStyle = prevStack.strokeStyle;
          this.appliedLineWidth = prevStack.lineWidth;
          this.appliedLineCap = prevStack.lineCap;
          this.appliedLineJoin = prevStack.lineJoin;
          this.appliedMiterLimit = prevStack.miterLimit;
        }
        this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
          this.nativeContext.globalAlpha = currentContext.opacity;
          this.currentOpacity = currentContext.opacity;
        }
        this.currentFillStyle = currentContext.fillStyle;
        this.currentStrokeStyle = currentContext.strokeStyle;
        this.currentLineWidth = currentContext.lineWidth;
        this.currentLineCap = currentContext.lineCap;
        this.currentLineJoin = currentContext.lineJoin;
        this.currentMiterLimit = currentContext.miterLimit;
      };
      CVContextData.prototype.save = function(saveOnNativeFlag) {
        if (saveOnNativeFlag) {
          this.nativeContext.save();
        }
        var props = this.cTr.props;
        if (this._length <= this.cArrPos) {
          this.duplicate();
        }
        var currentStack = this.stack[this.cArrPos];
        var i2;
        for (i2 = 0; i2 < 16; i2 += 1) {
          currentStack.transform[i2] = props[i2];
        }
        this.cArrPos += 1;
        var newStack = this.stack[this.cArrPos];
        newStack.opacity = currentStack.opacity;
        newStack.fillStyle = currentStack.fillStyle;
        newStack.strokeStyle = currentStack.strokeStyle;
        newStack.lineWidth = currentStack.lineWidth;
        newStack.lineCap = currentStack.lineCap;
        newStack.lineJoin = currentStack.lineJoin;
        newStack.miterLimit = currentStack.miterLimit;
      };
      CVContextData.prototype.setOpacity = function(value2) {
        this.stack[this.cArrPos].opacity = value2;
      };
      CVContextData.prototype.setContext = function(value2) {
        this.nativeContext = value2;
      };
      CVContextData.prototype.fillStyle = function(value2) {
        if (this.stack[this.cArrPos].fillStyle !== value2) {
          this.currentFillStyle = value2;
          this.stack[this.cArrPos].fillStyle = value2;
        }
      };
      CVContextData.prototype.strokeStyle = function(value2) {
        if (this.stack[this.cArrPos].strokeStyle !== value2) {
          this.currentStrokeStyle = value2;
          this.stack[this.cArrPos].strokeStyle = value2;
        }
      };
      CVContextData.prototype.lineWidth = function(value2) {
        if (this.stack[this.cArrPos].lineWidth !== value2) {
          this.currentLineWidth = value2;
          this.stack[this.cArrPos].lineWidth = value2;
        }
      };
      CVContextData.prototype.lineCap = function(value2) {
        if (this.stack[this.cArrPos].lineCap !== value2) {
          this.currentLineCap = value2;
          this.stack[this.cArrPos].lineCap = value2;
        }
      };
      CVContextData.prototype.lineJoin = function(value2) {
        if (this.stack[this.cArrPos].lineJoin !== value2) {
          this.currentLineJoin = value2;
          this.stack[this.cArrPos].lineJoin = value2;
        }
      };
      CVContextData.prototype.miterLimit = function(value2) {
        if (this.stack[this.cArrPos].miterLimit !== value2) {
          this.currentMiterLimit = value2;
          this.stack[this.cArrPos].miterLimit = value2;
        }
      };
      CVContextData.prototype.transform = function(props) {
        this.transformMat.cloneFromProps(props);
        var currentTransform = this.cTr;
        this.transformMat.multiply(currentTransform);
        currentTransform.cloneFromProps(this.transformMat.props);
        var trProps = currentTransform.props;
        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
      };
      CVContextData.prototype.opacity = function(op) {
        var currentOpacity = this.stack[this.cArrPos].opacity;
        currentOpacity *= op < 0 ? 0 : op;
        if (this.stack[this.cArrPos].opacity !== currentOpacity) {
          if (this.currentOpacity !== op) {
            this.nativeContext.globalAlpha = op;
            this.currentOpacity = op;
          }
          this.stack[this.cArrPos].opacity = currentOpacity;
        }
      };
      CVContextData.prototype.fill = function(rule) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fill(rule);
      };
      CVContextData.prototype.fillRect = function(x3, y3, w2, h2) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fillRect(x3, y3, w2, h2);
      };
      CVContextData.prototype.stroke = function() {
        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
          this.appliedStrokeStyle = this.currentStrokeStyle;
          this.nativeContext.strokeStyle = this.appliedStrokeStyle;
        }
        if (this.appliedLineWidth !== this.currentLineWidth) {
          this.appliedLineWidth = this.currentLineWidth;
          this.nativeContext.lineWidth = this.appliedLineWidth;
        }
        if (this.appliedLineCap !== this.currentLineCap) {
          this.appliedLineCap = this.currentLineCap;
          this.nativeContext.lineCap = this.appliedLineCap;
        }
        if (this.appliedLineJoin !== this.currentLineJoin) {
          this.appliedLineJoin = this.currentLineJoin;
          this.nativeContext.lineJoin = this.appliedLineJoin;
        }
        if (this.appliedMiterLimit !== this.currentMiterLimit) {
          this.appliedMiterLimit = this.currentMiterLimit;
          this.nativeContext.miterLimit = this.appliedMiterLimit;
        }
        this.nativeContext.stroke();
      };
      function CVCompElement(data2, globalData2, comp2) {
        this.completeLayers = false;
        this.layers = data2.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
      CVCompElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i2;
        var len = this.layers.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].renderFrame();
          }
        }
      };
      CVCompElement.prototype.destroy = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.elements[i2]) {
            this.elements[i2].destroy();
          }
        }
        this.layers = null;
        this.elements = null;
      };
      CVCompElement.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function CanvasRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
          context: config && config.context || null,
          progressiveLoad: config && config.progressiveLoad || false,
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          className: config && config.className || "",
          id: config && config.id || "",
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.renderConfig.dpr = config && config.dpr || 1;
        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        }
        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
        if (this.renderConfig.clearCanvas) {
          this.ctxTransform = this.contextData.transform.bind(this.contextData);
          this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
          this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
          this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
          this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
          this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
          this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
          this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
          this.ctxFill = this.contextData.fill.bind(this.contextData);
          this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
          this.ctxStroke = this.contextData.stroke.bind(this.contextData);
          this.save = this.contextData.save.bind(this.contextData);
        }
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer);
      CanvasRenderer.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function HBaseElement() {
      }
      HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {
        },
        initRendererElement: function initRendererElement() {
          this.baseElement = createTag(this.data.tg || "div");
          if (this.data.hasMask) {
            this.svgElement = createNS("svg");
            this.layerElement = createNS("g");
            this.maskedElement = this.layerElement;
            this.svgElement.appendChild(this.layerElement);
            this.baseElement.appendChild(this.svgElement);
          } else {
            this.layerElement = this.baseElement;
          }
          styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
          this.renderableEffectsManager = new CVEffects(this);
          this.transformedElement = this.baseElement;
          this.maskedElement = this.layerElement;
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var matrixValue = this.finalTransform.mat.toCSS();
            transformedElementStyle.transform = matrixValue;
            transformedElementStyle.webkitTransform = matrixValue;
          }
          if (this.finalTransform._opMdf) {
            transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
          }
        },
        renderFrame: function renderFrame() {
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.layerElement = null;
          this.transformedElement = null;
          if (this.matteElement) {
            this.matteElement = null;
          }
          if (this.maskManager) {
            this.maskManager.destroy();
            this.maskManager = null;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {
        },
        setMatte: function setMatte() {
        }
      };
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
      function HSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
      HSolidElement.prototype.createContent = function() {
        var rect;
        if (this.data.hasMask) {
          rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.svgElement.setAttribute("width", this.data.sw);
          this.svgElement.setAttribute("height", this.data.sh);
        } else {
          rect = createTag("div");
          rect.style.width = this.data.sw + "px";
          rect.style.height = this.data.sh + "px";
          rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
      };
      function HShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.shapesContainer = createNS("g");
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
      }
      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
      HShapeElement.prototype.createContent = function() {
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
          this.layerElement.appendChild(this.shapesContainer);
          cont = this.svgElement;
        } else {
          cont = createNS("svg");
          var size = this.comp.data ? this.comp.data : this.globalData.compSize;
          cont.setAttribute("width", size.w);
          cont.setAttribute("height", size.h);
          cont.appendChild(this.shapesContainer);
          this.layerElement.appendChild(cont);
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
      };
      HShapeElement.prototype.getTransformedPoint = function(transformers, point2) {
        var i2;
        var len = transformers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          point2 = transformers[i2].mProps.v.applyToPointArray(point2[0], point2[1], 0);
        }
        return point2;
      };
      HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i2;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;
        if (len <= 1) {
          return;
        }
        for (i2 = 0; i2 < len - 1; i2 += 1) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[i2 + 1]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[i2 + 1]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if (shape.c) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
      };
      HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
      };
      HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
      };
      HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
        var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
        for (var a2, b2, c2, t2, b2ac, t1, t22, i2 = 0; i2 < 2; ++i2) {
          b2 = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
          a2 = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
          c2 = 3 * p1[i2] - 3 * p0[i2];
          b2 |= 0;
          a2 |= 0;
          c2 |= 0;
          if (a2 === 0 && b2 === 0) {
          } else if (a2 === 0) {
            t2 = -c2 / b2;
            if (t2 > 0 && t2 < 1) {
              bounds[i2].push(this.calculateF(t2, p0, p1, p2, p3, i2));
            }
          } else {
            b2ac = b2 * b2 - 4 * c2 * a2;
            if (b2ac >= 0) {
              t1 = (-b2 + bmSqrt(b2ac)) / (2 * a2);
              if (t1 > 0 && t1 < 1) bounds[i2].push(this.calculateF(t1, p0, p1, p2, p3, i2));
              t22 = (-b2 - bmSqrt(b2ac)) / (2 * a2);
              if (t22 > 0 && t22 < 1) bounds[i2].push(this.calculateF(t22, p0, p1, p2, p3, i2));
            }
          }
        }
        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
      };
      HShapeElement.prototype.calculateF = function(t2, p0, p1, p2, p3, i2) {
        return bmPow(1 - t2, 3) * p0[i2] + 3 * bmPow(1 - t2, 2) * t2 * p1[i2] + 3 * (1 - t2) * bmPow(t2, 2) * p2[i2] + bmPow(t2, 3) * p3[i2];
      };
      HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i2;
        var len = itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (itemsData[i2] && itemsData[i2].sh) {
            this.calculateShapeBoundingBox(itemsData[i2], boundingBox);
          } else if (itemsData[i2] && itemsData[i2].it) {
            this.calculateBoundingBox(itemsData[i2].it, boundingBox);
          } else if (itemsData[i2] && itemsData[i2].style && itemsData[i2].w) {
            this.expandStrokeBoundingBox(itemsData[i2].w, boundingBox);
          }
        }
      };
      HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
        var width2 = 0;
        if (widthProperty.keyframes) {
          for (var i2 = 0; i2 < widthProperty.keyframes.length; i2 += 1) {
            var kfw = widthProperty.keyframes[i2].s;
            if (kfw > width2) {
              width2 = kfw;
            }
          }
          width2 *= widthProperty.mult;
        } else {
          width2 = widthProperty.v * widthProperty.mult;
        }
        boundingBox.x -= width2;
        boundingBox.xMax += width2;
        boundingBox.y -= width2;
        boundingBox.yMax += width2;
      };
      HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
      };
      HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();
        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
          var tempBoundingBox = this.tempBoundingBox;
          var max3 = 999999;
          tempBoundingBox.x = max3;
          tempBoundingBox.xMax = -max3;
          tempBoundingBox.y = max3;
          tempBoundingBox.yMax = -max3;
          this.calculateBoundingBox(this.itemsData, tempBoundingBox);
          tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
          tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
          if (this.currentBoxContains(tempBoundingBox)) {
            return;
          }
          var changed = false;
          if (this.currentBBox.w !== tempBoundingBox.width) {
            this.currentBBox.w = tempBoundingBox.width;
            this.shapeCont.setAttribute("width", tempBoundingBox.width);
            changed = true;
          }
          if (this.currentBBox.h !== tempBoundingBox.height) {
            this.currentBBox.h = tempBoundingBox.height;
            this.shapeCont.setAttribute("height", tempBoundingBox.height);
            changed = true;
          }
          if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
            this.currentBBox.w = tempBoundingBox.width;
            this.currentBBox.h = tempBoundingBox.height;
            this.currentBBox.x = tempBoundingBox.x;
            this.currentBBox.y = tempBoundingBox.y;
            this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            var shapeStyle = this.shapeCont.style;
            var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            shapeStyle.transform = shapeTransform;
            shapeStyle.webkitTransform = shapeTransform;
          }
        }
      };
      function HTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
        this.renderType = "svg";
        this.isMasked = false;
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
      HTextElement.prototype.createContent = function() {
        this.isMasked = this.checkMasks();
        if (this.isMasked) {
          this.renderType = "svg";
          this.compW = this.comp.data.w;
          this.compH = this.comp.data.h;
          this.svgElement.setAttribute("width", this.compW);
          this.svgElement.setAttribute("height", this.compH);
          var g3 = createNS("g");
          this.maskedElement.appendChild(g3);
          this.innerElem = g3;
        } else {
          this.renderType = "html";
          this.innerElem = this.layerElement;
        }
        this.checkParenting();
      };
      HTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;
        if (documentData.sc) {
          innerElemStyle.stroke = this.buildColor(documentData.sc);
          innerElemStyle.strokeWidth = documentData.sw + "px";
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (!this.globalData.fontManager.chars) {
          innerElemStyle.fontSize = documentData.finalSize + "px";
          innerElemStyle.lineHeight = documentData.finalSize + "px";
          if (fontData.fClass) {
            this.innerElem.className = fontData.fClass;
          } else {
            innerElemStyle.fontFamily = fontData.fFamily;
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            innerElemStyle.fontStyle = fStyle;
            innerElemStyle.fontWeight = fWeight;
          }
        }
        var i2;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = "";
        var cnt = 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.globalData.fontManager.chars) {
            if (!this.textPaths[cnt]) {
              tSpan = createNS("path");
              tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
              tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
              tSpan.setAttribute("stroke-miterlimit", "4");
            } else {
              tSpan = this.textPaths[cnt];
            }
            if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tCont = tParent.children[0];
              } else {
                tParent = createTag("div");
                tParent.style.lineHeight = 0;
                tCont = createNS("svg");
                tCont.appendChild(tSpan);
                styleDiv(tParent);
              }
            }
          } else if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tSpan = this.textPaths[cnt];
            } else {
              tParent = createTag("span");
              styleDiv(tParent);
              tSpan = createTag("span");
              styleDiv(tSpan);
              tParent.appendChild(tSpan);
            }
          } else {
            tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
          }
          if (this.globalData.fontManager.chars) {
            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var shapeData;
            if (charData) {
              shapeData = charData.data;
            } else {
              shapeData = null;
            }
            matrixHelper.reset();
            if (shapeData && shapeData.shapes && shapeData.shapes.length) {
              shapes = shapeData.shapes[0].it;
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              shapeStr = this.createPathShape(matrixHelper, shapes);
              tSpan.setAttribute("d", shapeStr);
            }
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              if (shapeData && shapeData.shapes) {
                document.body.appendChild(tCont);
                var boundingBox = tCont.getBBox();
                tCont.setAttribute("width", boundingBox.width + 2);
                tCont.setAttribute("height", boundingBox.height + 2);
                tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                var tContStyle = tCont.style;
                var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                tContStyle.transform = tContTranslation;
                tContStyle.webkitTransform = tContTranslation;
                letters[i2].yOffset = boundingBox.y - 1;
              } else {
                tCont.setAttribute("width", 1);
                tCont.setAttribute("height", 1);
              }
              tParent.appendChild(tCont);
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } else {
            tSpan.textContent = letters[i2].val;
            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              var tStyle = tSpan.style;
              var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
              tStyle.transform = tSpanTranslation;
              tStyle.webkitTransform = tSpanTranslation;
            } else {
              this.innerElem.appendChild(tSpan);
            }
          }
          if (!this.isMasked) {
            this.textSpans[cnt] = tParent;
          } else {
            this.textSpans[cnt] = tSpan;
          }
          this.textSpans[cnt].style.display = "block";
          this.textPaths[cnt] = tSpan;
          cnt += 1;
        }
        while (cnt < this.textSpans.length) {
          this.textSpans[cnt].style.display = "none";
          cnt += 1;
        }
      };
      HTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var svgStyle;
        if (this.data.singleShape) {
          if (!this._isFirstFrame && !this.lettersChangedFlag) {
            return;
          }
          if (this.isMasked && this.finalTransform._matMdf) {
            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
            svgStyle = this.svgElement.style;
            var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
            svgStyle.transform = translation;
            svgStyle.webkitTransform = translation;
          }
        }
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
          return;
        }
        var i2;
        var len;
        var count2 = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (letters[i2].n) {
            count2 += 1;
          } else {
            textSpan = this.textSpans[i2];
            textPath = this.textPaths[i2];
            renderedLetter = renderedLetters[count2];
            count2 += 1;
            if (renderedLetter._mdf.m) {
              if (!this.isMasked) {
                textSpan.style.webkitTransform = renderedLetter.m;
                textSpan.style.transform = renderedLetter.m;
              } else {
                textSpan.setAttribute("transform", renderedLetter.m);
              }
            }
            textSpan.style.opacity = renderedLetter.o;
            if (renderedLetter.sw && renderedLetter._mdf.sw) {
              textPath.setAttribute("stroke-width", renderedLetter.sw);
            }
            if (renderedLetter.sc && renderedLetter._mdf.sc) {
              textPath.setAttribute("stroke", renderedLetter.sc);
            }
            if (renderedLetter.fc && renderedLetter._mdf.fc) {
              textPath.setAttribute("fill", renderedLetter.fc);
              textPath.style.color = renderedLetter.fc;
            }
          }
        }
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var boundingBox = this.innerElem.getBBox();
          if (this.currentBBox.w !== boundingBox.width) {
            this.currentBBox.w = boundingBox.width;
            this.svgElement.setAttribute("width", boundingBox.width);
          }
          if (this.currentBBox.h !== boundingBox.height) {
            this.currentBBox.h = boundingBox.height;
            this.svgElement.setAttribute("height", boundingBox.height);
          }
          var margin = 1;
          if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
            this.currentBBox.w = boundingBox.width + margin * 2;
            this.currentBBox.h = boundingBox.height + margin * 2;
            this.currentBBox.x = boundingBox.x - margin;
            this.currentBBox.y = boundingBox.y - margin;
            this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            svgStyle = this.svgElement.style;
            var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            svgStyle.transform = svgTransform;
            svgStyle.webkitTransform = svgTransform;
          }
        }
      };
      function HCameraElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data2.pe, 0, 0, this);
        if (data2.ks.p.s) {
          this.px = getProp(this, data2.ks.p.x, 1, 0, this);
          this.py = getProp(this, data2.ks.p.y, 1, 0, this);
          this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
        } else {
          this.p = getProp(this, data2.ks.p, 1, 0, this);
        }
        if (data2.ks.a) {
          this.a = getProp(this, data2.ks.a, 1, 0, this);
        }
        if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
          var i2;
          var len = data2.ks.or.k.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            data2.ks.or.k[i2].to = null;
            data2.ks.or.k[i2].ti = null;
          }
        }
        this.or = getProp(this, data2.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true;
        this.finalTransform = {
          mProp: this
        };
      }
      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
      HCameraElement.prototype.setup = function() {
        var i2;
        var len = this.comp.threeDElements.length;
        var comp2;
        var perspectiveStyle;
        var containerStyle;
        for (i2 = 0; i2 < len; i2 += 1) {
          comp2 = this.comp.threeDElements[i2];
          if (comp2.type === "3d") {
            perspectiveStyle = comp2.perspectiveElem.style;
            containerStyle = comp2.container.style;
            var perspective = this.pe.v + "px";
            var origin = "0px 0px 0px";
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            perspectiveStyle.perspective = perspective;
            perspectiveStyle.webkitPerspective = perspective;
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            perspectiveStyle.transform = matrix;
            perspectiveStyle.webkitTransform = matrix;
          }
        }
      };
      HCameraElement.prototype.createElements = function() {
      };
      HCameraElement.prototype.hide = function() {
      };
      HCameraElement.prototype.renderFrame = function() {
        var _mdf = this._isFirstFrame;
        var i2;
        var len;
        if (this.hierarchy) {
          len = this.hierarchy.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            _mdf = this.hierarchy[i2].finalTransform.mProp._mdf || _mdf;
          }
        }
        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
          this.mat.reset();
          if (this.hierarchy) {
            len = this.hierarchy.length - 1;
            for (i2 = len; i2 >= 0; i2 -= 1) {
              var mTransf = this.hierarchy[i2].finalTransform.mProp;
              this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
              this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
              this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
              this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
              this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
            }
          }
          if (this.p) {
            this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
          } else {
            this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
          }
          if (this.a) {
            var diffVector;
            if (this.p) {
              diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
            } else {
              diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
            }
            var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
            var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
            var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
            var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
            var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
            this.mat.rotateY(mRotationY).rotateX(-mRotationX);
          }
          this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
          this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
          this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
          this.mat.translate(0, 0, this.pe.v);
          var hasMatrixChanged = !this._prevMat.equals(this.mat);
          if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
            len = this.comp.threeDElements.length;
            var comp2;
            var perspectiveStyle;
            var containerStyle;
            for (i2 = 0; i2 < len; i2 += 1) {
              comp2 = this.comp.threeDElements[i2];
              if (comp2.type === "3d") {
                if (hasMatrixChanged) {
                  var matValue = this.mat.toCSS();
                  containerStyle = comp2.container.style;
                  containerStyle.transform = matValue;
                  containerStyle.webkitTransform = matValue;
                }
                if (this.pe._mdf) {
                  perspectiveStyle = comp2.perspectiveElem.style;
                  perspectiveStyle.perspective = this.pe.v + "px";
                  perspectiveStyle.webkitPerspective = this.pe.v + "px";
                }
              }
            }
            this.mat.clone(this._prevMat);
          }
        }
        this._isFirstFrame = false;
      };
      HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      HCameraElement.prototype.destroy = function() {
      };
      HCameraElement.prototype.getBaseElement = function() {
        return null;
      };
      function HImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
      HImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();
        if (this.data.hasMask) {
          this.imageElem = createNS("image");
          this.imageElem.setAttribute("width", this.assetData.w + "px");
          this.imageElem.setAttribute("height", this.assetData.h + "px");
          this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.imageElem);
          this.baseElement.setAttribute("width", this.assetData.w);
          this.baseElement.setAttribute("height", this.assetData.h);
        } else {
          this.layerElement.appendChild(img);
        }
        img.crossOrigin = "anonymous";
        img.src = assetPath;
        if (this.data.ln) {
          this.baseElement.setAttribute("id", this.data.ln);
        }
      };
      function HybridRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([BaseRenderer], HybridRendererBase);
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
      HybridRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newDOMElement = element.getBaseElement();
        if (!newDOMElement) {
          return;
        }
        var layer = this.layers[pos];
        if (!layer.ddd || !this.supports3d) {
          if (this.threeDElements) {
            this.addTo3dContainer(newDOMElement, pos);
          } else {
            var i2 = 0;
            var nextDOMElement;
            var nextLayer;
            var tmpDOMElement;
            while (i2 < pos) {
              if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement) {
                nextLayer = this.elements[i2];
                tmpDOMElement = this.layers[i2].ddd ? this.getThreeDContainerByPos(i2) : nextLayer.getBaseElement();
                nextDOMElement = tmpDOMElement || nextDOMElement;
              }
              i2 += 1;
            }
            if (nextDOMElement) {
              if (!layer.ddd || !this.supports3d) {
                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
              }
            } else if (!layer.ddd || !this.supports3d) {
              this.layerElement.appendChild(newDOMElement);
            }
          }
        } else {
          this.addTo3dContainer(newDOMElement, pos);
        }
      };
      HybridRendererBase.prototype.createShape = function(data2) {
        if (!this.supports3d) {
          return new SVGShapeElement(data2, this.globalData, this);
        }
        return new HShapeElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createText = function(data2) {
        if (!this.supports3d) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        }
        return new HTextElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createCamera = function(data2) {
        this.camera = new HCameraElement(data2, this.globalData, this);
        return this.camera;
      };
      HybridRendererBase.prototype.createImage = function(data2) {
        if (!this.supports3d) {
          return new IImageElement(data2, this.globalData, this);
        }
        return new HImageElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createSolid = function(data2) {
        if (!this.supports3d) {
          return new ISolidElement(data2, this.globalData, this);
        }
        return new HSolidElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
        var i2 = 0;
        var len = this.threeDElements.length;
        while (i2 < len) {
          if (this.threeDElements[i2].startPos <= pos && this.threeDElements[i2].endPos >= pos) {
            return this.threeDElements[i2].perspectiveElem;
          }
          i2 += 1;
        }
        return null;
      };
      HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
        var perspectiveElem = createTag("div");
        var style;
        var containerStyle;
        styleDiv(perspectiveElem);
        var container = createTag("div");
        styleDiv(container);
        if (type === "3d") {
          style = perspectiveElem.style;
          style.width = this.globalData.compSize.w + "px";
          style.height = this.globalData.compSize.h + "px";
          var center = "50% 50%";
          style.webkitTransformOrigin = center;
          style.mozTransformOrigin = center;
          style.transformOrigin = center;
          containerStyle = container.style;
          var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          containerStyle.transform = matrix;
          containerStyle.webkitTransform = matrix;
        }
        perspectiveElem.appendChild(container);
        var threeDContainerData = {
          container,
          perspectiveElem,
          startPos: pos,
          endPos: pos,
          type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
      };
      HybridRendererBase.prototype.build3dContainers = function() {
        var i2;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = "";
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.layers[i2].ddd && this.layers[i2].ty !== 3) {
            if (currentContainer !== "3d") {
              currentContainer = "3d";
              lastThreeDContainerData = this.createThreeDContainer(i2, "3d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
          } else {
            if (currentContainer !== "2d") {
              currentContainer = "2d";
              lastThreeDContainerData = this.createThreeDContainer(i2, "2d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
          }
        }
        len = this.threeDElements.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          this.resizerElem.appendChild(this.threeDElements[i2].perspectiveElem);
        }
      };
      HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
        var i2 = 0;
        var len = this.threeDElements.length;
        while (i2 < len) {
          if (pos <= this.threeDElements[i2].endPos) {
            var j2 = this.threeDElements[i2].startPos;
            var nextElement;
            while (j2 < pos) {
              if (this.elements[j2] && this.elements[j2].getBaseElement) {
                nextElement = this.elements[j2].getBaseElement();
              }
              j2 += 1;
            }
            if (nextElement) {
              this.threeDElements[i2].container.insertBefore(elem2, nextElement);
            } else {
              this.threeDElements[i2].container.appendChild(elem2);
            }
            break;
          }
          i2 += 1;
        }
      };
      HybridRendererBase.prototype.configAnimation = function(animData) {
        var resizerElem = createTag("div");
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + "px";
        style.height = animData.h + "px";
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = "flat";
        style.mozTransformStyle = "flat";
        style.webkitTransformStyle = "flat";
        if (this.renderConfig.className) {
          resizerElem.setAttribute("class", this.renderConfig.className);
        }
        wrapper.appendChild(resizerElem);
        style.overflow = "hidden";
        var svg = createNS("svg");
        svg.setAttribute("width", "1");
        svg.setAttribute("height", "1");
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS("defs");
        svg.appendChild(defs);
        this.data = animData;
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
      };
      HybridRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      HybridRendererBase.prototype.updateContainerSize = function() {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;
        if (animationRel > elementRel) {
          sx = elementWidth / this.globalData.compSize.w;
          sy = elementWidth / this.globalData.compSize.w;
          tx = 0;
          ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
          sx = elementHeight / this.globalData.compSize.h;
          sy = elementHeight / this.globalData.compSize.h;
          tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
          ty = 0;
        }
        var style = this.resizerElem.style;
        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
        style.transform = style.webkitTransform;
      };
      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
      HybridRendererBase.prototype.hide = function() {
        this.resizerElem.style.display = "none";
      };
      HybridRendererBase.prototype.show = function() {
        this.resizerElem.style.display = "block";
      };
      HybridRendererBase.prototype.initItems = function() {
        this.buildAllItems();
        if (this.camera) {
          this.camera.setup();
        } else {
          var cWidth = this.globalData.compSize.w;
          var cHeight = this.globalData.compSize.h;
          var i2;
          var len = this.threeDElements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            var style = this.threeDElements[i2].perspectiveElem.style;
            style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
            style.perspective = style.webkitPerspective;
          }
        }
      };
      HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
        var i2;
        var len = assets.length;
        var floatingContainer = createTag("div");
        for (i2 = 0; i2 < len; i2 += 1) {
          if (assets[i2].xt) {
            var comp2 = this.createComp(assets[i2], floatingContainer, this.globalData.comp, null);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      function HCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = !data2.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
      HCompElement.prototype.createContainerElements = function() {
        this._createBaseContainerElements();
        if (this.data.hasMask) {
          this.svgElement.setAttribute("width", this.data.w);
          this.svgElement.setAttribute("height", this.data.h);
          this.transformedElement = this.baseElement;
        } else {
          this.transformedElement = this.layerElement;
        }
      };
      HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
        var j2 = 0;
        var nextElement;
        while (j2 < pos) {
          if (this.elements[j2] && this.elements[j2].getBaseElement) {
            nextElement = this.elements[j2].getBaseElement();
          }
          j2 += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(elem2, nextElement);
        } else {
          this.layerElement.appendChild(elem2);
        }
      };
      HCompElement.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      function HybridRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          },
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([HybridRendererBase], HybridRenderer);
      HybridRenderer.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      var CompExpressionInterface = /* @__PURE__ */ function() {
        return function(comp2) {
          function _thisLayerFunction(name2) {
            var i2 = 0;
            var len = comp2.layers.length;
            while (i2 < len) {
              if (comp2.layers[i2].nm === name2 || comp2.layers[i2].ind === name2) {
                return comp2.elements[i2].layerInterface;
              }
              i2 += 1;
            }
            return null;
          }
          Object.defineProperty(_thisLayerFunction, "_name", {
            value: comp2.data.nm
          });
          _thisLayerFunction.layer = _thisLayerFunction;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
          _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
          _thisLayerFunction.displayStartTime = 0;
          _thisLayerFunction.numLayers = comp2.layers.length;
          return _thisLayerFunction;
        };
      }();
      function _typeof$2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$2 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$2 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$2(obj);
      }
      function seedRandom(pool, math) {
        var global = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
        function seedrandom(seed, options, callback) {
          var key2 = [];
          options = options === true ? {
            entropy: true
          } : options || {};
          var shortseed = mixkey(flatten2(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
          var arc4 = new ARC4(key2);
          var prng = function prng2() {
            var n2 = arc4.g(chunks), d2 = startdenom, x3 = 0;
            while (n2 < significance) {
              n2 = (n2 + x3) * width2;
              d2 *= width2;
              x3 = arc4.g(1);
            }
            while (n2 >= overflow) {
              n2 /= 2;
              d2 /= 2;
              x3 >>>= 1;
            }
            return (n2 + x3) / d2;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng["double"] = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom;
        function ARC4(key2) {
          var t2, keylen = key2.length, me = this, i2 = 0, j2 = me.i = me.j = 0, s2 = me.S = [];
          if (!keylen) {
            key2 = [keylen++];
          }
          while (i2 < width2) {
            s2[i2] = i2++;
          }
          for (i2 = 0; i2 < width2; i2++) {
            s2[i2] = s2[j2 = mask2 & j2 + key2[i2 % keylen] + (t2 = s2[i2])];
            s2[j2] = t2;
          }
          me.g = function(count2) {
            var t3, r2 = 0, i3 = me.i, j3 = me.j, s3 = me.S;
            while (count2--) {
              t3 = s3[i3 = mask2 & i3 + 1];
              r2 = r2 * width2 + s3[mask2 & (s3[i3] = s3[j3 = mask2 & j3 + t3]) + (s3[j3] = t3)];
            }
            me.i = i3;
            me.j = j3;
            return r2;
          };
        }
        function copy(f2, t2) {
          t2.i = f2.i;
          t2.j = f2.j;
          t2.S = f2.S.slice();
          return t2;
        }
        function flatten2(obj, depth) {
          var result = [], typ = _typeof$2(obj), prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten2(obj[prop], depth - 1));
              } catch (e3) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key2) {
          var stringseed = seed + "", smear, j2 = 0;
          while (j2 < stringseed.length) {
            key2[mask2 & j2] = mask2 & (smear ^= key2[mask2 & j2] * 19) + stringseed.charCodeAt(j2++);
          }
          return tostring(key2);
        }
        function autoseed() {
          try {
            if (nodecrypto) {
              return tostring(nodecrypto.randomBytes(width2));
            }
            var out = new Uint8Array(width2);
            (global.crypto || global.msCrypto).getRandomValues(out);
            return tostring(out);
          } catch (e3) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
          }
        }
        function tostring(a2) {
          return String.fromCharCode.apply(0, a2);
        }
        mixkey(math.random(), pool);
      }
      ;
      function initialize$2(BMMath2) {
        seedRandom([], BMMath2);
      }
      var propTypes = {
        SHAPE: "shape"
      };
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$1 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$1 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$1(obj);
      }
      var ExpressionManager = function() {
        "use strict";
        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        var _lottieGlobal = {};
        initialize$2(BMMath);
        function resetFrame() {
          _lottieGlobal = {};
        }
        function $bm_isInstanceOfArray(arr) {
          return arr.constructor === Array || arr.constructor === Float32Array;
        }
        function isNumerable(tOfV, v2) {
          return tOfV === "number" || v2 instanceof Number || tOfV === "boolean" || tOfV === "string";
        }
        function $bm_neg(a2) {
          var tOfA = _typeof$1(a2);
          if (tOfA === "number" || a2 instanceof Number || tOfA === "boolean") {
            return -a2;
          }
          if ($bm_isInstanceOfArray(a2)) {
            var i2;
            var lenA = a2.length;
            var retArr = [];
            for (i2 = 0; i2 < lenA; i2 += 1) {
              retArr[i2] = -a2[i2];
            }
            return retArr;
          }
          if (a2.propType) {
            return a2.v;
          }
          return -a2;
        }
        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
        function sum(a2, b2) {
          var tOfA = _typeof$1(a2);
          var tOfB = _typeof$1(b2);
          if (isNumerable(tOfA, a2) && isNumerable(tOfB, b2) || tOfA === "string" || tOfB === "string") {
            return a2 + b2;
          }
          if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b2)) {
            a2 = a2.slice(0);
            a2[0] += b2;
            return a2;
          }
          if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b2)) {
            b2 = b2.slice(0);
            b2[0] = a2 + b2[0];
            return b2;
          }
          if ($bm_isInstanceOfArray(a2) && $bm_isInstanceOfArray(b2)) {
            var i2 = 0;
            var lenA = a2.length;
            var lenB = b2.length;
            var retArr = [];
            while (i2 < lenA || i2 < lenB) {
              if ((typeof a2[i2] === "number" || a2[i2] instanceof Number) && (typeof b2[i2] === "number" || b2[i2] instanceof Number)) {
                retArr[i2] = a2[i2] + b2[i2];
              } else {
                retArr[i2] = b2[i2] === void 0 ? a2[i2] : a2[i2] || b2[i2];
              }
              i2 += 1;
            }
            return retArr;
          }
          return 0;
        }
        var add = sum;
        function sub(a2, b2) {
          var tOfA = _typeof$1(a2);
          var tOfB = _typeof$1(b2);
          if (isNumerable(tOfA, a2) && isNumerable(tOfB, b2)) {
            if (tOfA === "string") {
              a2 = parseInt(a2, 10);
            }
            if (tOfB === "string") {
              b2 = parseInt(b2, 10);
            }
            return a2 - b2;
          }
          if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b2)) {
            a2 = a2.slice(0);
            a2[0] -= b2;
            return a2;
          }
          if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b2)) {
            b2 = b2.slice(0);
            b2[0] = a2 - b2[0];
            return b2;
          }
          if ($bm_isInstanceOfArray(a2) && $bm_isInstanceOfArray(b2)) {
            var i2 = 0;
            var lenA = a2.length;
            var lenB = b2.length;
            var retArr = [];
            while (i2 < lenA || i2 < lenB) {
              if ((typeof a2[i2] === "number" || a2[i2] instanceof Number) && (typeof b2[i2] === "number" || b2[i2] instanceof Number)) {
                retArr[i2] = a2[i2] - b2[i2];
              } else {
                retArr[i2] = b2[i2] === void 0 ? a2[i2] : a2[i2] || b2[i2];
              }
              i2 += 1;
            }
            return retArr;
          }
          return 0;
        }
        function mul(a2, b2) {
          var tOfA = _typeof$1(a2);
          var tOfB = _typeof$1(b2);
          var arr;
          if (isNumerable(tOfA, a2) && isNumerable(tOfB, b2)) {
            return a2 * b2;
          }
          var i2;
          var len;
          if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b2)) {
            len = a2.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a2[i2] * b2;
            }
            return arr;
          }
          if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b2)) {
            len = b2.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a2 * b2[i2];
            }
            return arr;
          }
          return 0;
        }
        function div(a2, b2) {
          var tOfA = _typeof$1(a2);
          var tOfB = _typeof$1(b2);
          var arr;
          if (isNumerable(tOfA, a2) && isNumerable(tOfB, b2)) {
            return a2 / b2;
          }
          var i2;
          var len;
          if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b2)) {
            len = a2.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a2[i2] / b2;
            }
            return arr;
          }
          if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b2)) {
            len = b2.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a2 / b2[i2];
            }
            return arr;
          }
          return 0;
        }
        function mod(a2, b2) {
          if (typeof a2 === "string") {
            a2 = parseInt(a2, 10);
          }
          if (typeof b2 === "string") {
            b2 = parseInt(b2, 10);
          }
          return a2 % b2;
        }
        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;
        function clamp(num, min3, max3) {
          if (min3 > max3) {
            var mm = max3;
            max3 = min3;
            min3 = mm;
          }
          return Math.min(Math.max(num, min3), max3);
        }
        function radiansToDegrees(val2) {
          return val2 / degToRads;
        }
        var radians_to_degrees = radiansToDegrees;
        function degreesToRadians(val2) {
          return val2 * degToRads;
        }
        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [0, 0, 0, 0, 0, 0];
        function length(arr1, arr2) {
          if (typeof arr1 === "number" || arr1 instanceof Number) {
            arr2 = arr2 || 0;
            return Math.abs(arr1 - arr2);
          }
          if (!arr2) {
            arr2 = helperLengthArray;
          }
          var i2;
          var len = Math.min(arr1.length, arr2.length);
          var addedLength = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            addedLength += Math.pow(arr2[i2] - arr1[i2], 2);
          }
          return Math.sqrt(addedLength);
        }
        function normalize(vec) {
          return div(vec, length(vec));
        }
        function rgbToHsl(val2) {
          var r2 = val2[0];
          var g3 = val2[1];
          var b2 = val2[2];
          var max3 = Math.max(r2, g3, b2);
          var min3 = Math.min(r2, g3, b2);
          var h2;
          var s2;
          var l2 = (max3 + min3) / 2;
          if (max3 === min3) {
            h2 = 0;
            s2 = 0;
          } else {
            var d2 = max3 - min3;
            s2 = l2 > 0.5 ? d2 / (2 - max3 - min3) : d2 / (max3 + min3);
            switch (max3) {
              case r2:
                h2 = (g3 - b2) / d2 + (g3 < b2 ? 6 : 0);
                break;
              case g3:
                h2 = (b2 - r2) / d2 + 2;
                break;
              case b2:
                h2 = (r2 - g3) / d2 + 4;
                break;
              default:
                break;
            }
            h2 /= 6;
          }
          return [h2, s2, l2, val2[3]];
        }
        function hue2rgb(p2, q2, t2) {
          if (t2 < 0) t2 += 1;
          if (t2 > 1) t2 -= 1;
          if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
          if (t2 < 1 / 2) return q2;
          if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
          return p2;
        }
        function hslToRgb(val2) {
          var h2 = val2[0];
          var s2 = val2[1];
          var l2 = val2[2];
          var r2;
          var g3;
          var b2;
          if (s2 === 0) {
            r2 = l2;
            b2 = l2;
            g3 = l2;
          } else {
            var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
            var p2 = 2 * l2 - q2;
            r2 = hue2rgb(p2, q2, h2 + 1 / 3);
            g3 = hue2rgb(p2, q2, h2);
            b2 = hue2rgb(p2, q2, h2 - 1 / 3);
          }
          return [r2, g3, b2, val2[3]];
        }
        function linear(t2, tMin, tMax, value1, value2) {
          if (value1 === void 0 || value2 === void 0) {
            value1 = tMin;
            value2 = tMax;
            tMin = 0;
            tMax = 1;
          }
          if (tMax < tMin) {
            var _tMin = tMax;
            tMax = tMin;
            tMin = _tMin;
          }
          if (t2 <= tMin) {
            return value1;
          }
          if (t2 >= tMax) {
            return value2;
          }
          var perc = tMax === tMin ? 0 : (t2 - tMin) / (tMax - tMin);
          if (!value1.length) {
            return value1 + (value2 - value1) * perc;
          }
          var i2;
          var len = value1.length;
          var arr = createTypedArray("float32", len);
          for (i2 = 0; i2 < len; i2 += 1) {
            arr[i2] = value1[i2] + (value2[i2] - value1[i2]) * perc;
          }
          return arr;
        }
        function random(min3, max3) {
          if (max3 === void 0) {
            if (min3 === void 0) {
              min3 = 0;
              max3 = 1;
            } else {
              max3 = min3;
              min3 = void 0;
            }
          }
          if (max3.length) {
            var i2;
            var len = max3.length;
            if (!min3) {
              min3 = createTypedArray("float32", len);
            }
            var arr = createTypedArray("float32", len);
            var rnd = BMMath.random();
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = min3[i2] + rnd * (max3[i2] - min3[i2]);
            }
            return arr;
          }
          if (min3 === void 0) {
            min3 = 0;
          }
          var rndm = BMMath.random();
          return min3 + rndm * (max3 - min3);
        }
        function createPath(points, inTangents, outTangents, closed) {
          var i2;
          var len = points.length;
          var path = shapePool.newElement();
          path.setPathData(!!closed, len);
          var arrPlaceholder = [0, 0];
          var inVertexPoint;
          var outVertexPoint;
          for (i2 = 0; i2 < len; i2 += 1) {
            inVertexPoint = inTangents && inTangents[i2] ? inTangents[i2] : arrPlaceholder;
            outVertexPoint = outTangents && outTangents[i2] ? outTangents[i2] : arrPlaceholder;
            path.setTripleAt(points[i2][0], points[i2][1], outVertexPoint[0] + points[i2][0], outVertexPoint[1] + points[i2][1], inVertexPoint[0] + points[i2][0], inVertexPoint[1] + points[i2][1], i2, true);
          }
          return path;
        }
        function initiateExpression(elem, data, property) {
          function noOp(_value) {
            return _value;
          }
          if (!elem.globalData.renderConfig.runExpressions) {
            return noOp;
          }
          var val = data.x;
          var needsVelocity = /velocity(?![\w\d])/.test(val);
          var _needsRandom = val.indexOf("random") !== -1;
          var elemType = elem.data.ty;
          var transform;
          var $bm_transform;
          var content;
          var effect;
          var thisProperty = property;
          thisProperty.valueAtTime = thisProperty.getValueAtTime;
          Object.defineProperty(thisProperty, "value", {
            get: function get2() {
              return thisProperty.v;
            }
          });
          elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
          elem.comp.displayStartTime = 0;
          var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          var outPoint = elem.data.op / elem.comp.globalData.frameRate;
          var width = elem.data.sw ? elem.data.sw : 0;
          var height = elem.data.sh ? elem.data.sh : 0;
          var name = elem.data.nm;
          var loopIn;
          var loop_in;
          var loopOut;
          var loop_out;
          var smooth;
          var toWorld;
          var fromWorld;
          var fromComp;
          var toComp;
          var fromCompToSurface;
          var position;
          var rotation;
          var anchorPoint;
          var scale;
          var thisLayer;
          var thisComp;
          var mask;
          var valueAtTime;
          var velocityAtTime;
          var scoped_bm_rt;
          var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
          var numKeys = property.kf ? data.k.length : 0;
          var active = !this.data || this.data.hd !== true;
          var wiggle = (function wiggle2(freq, amp) {
            var iWiggle;
            var j2;
            var lenWiggle = this.pv.length ? this.pv.length : 1;
            var addedAmps = createTypedArray("float32", lenWiggle);
            freq = 5;
            var iterations2 = Math.floor(time * freq);
            iWiggle = 0;
            j2 = 0;
            while (iWiggle < iterations2) {
              for (j2 = 0; j2 < lenWiggle; j2 += 1) {
                addedAmps[j2] += -amp + amp * 2 * BMMath.random();
              }
              iWiggle += 1;
            }
            var periods = time * freq;
            var perc = periods - Math.floor(periods);
            var arr = createTypedArray("float32", lenWiggle);
            if (lenWiggle > 1) {
              for (j2 = 0; j2 < lenWiggle; j2 += 1) {
                arr[j2] = this.pv[j2] + addedAmps[j2] + (-amp + amp * 2 * BMMath.random()) * perc;
              }
              return arr;
            }
            return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
          }).bind(this);
          if (thisProperty.loopIn) {
            loopIn = thisProperty.loopIn.bind(thisProperty);
            loop_in = loopIn;
          }
          if (thisProperty.loopOut) {
            loopOut = thisProperty.loopOut.bind(thisProperty);
            loop_out = loopOut;
          }
          if (thisProperty.smooth) {
            smooth = thisProperty.smooth.bind(thisProperty);
          }
          function loopInDuration(type, duration) {
            return loopIn(type, duration, true);
          }
          function loopOutDuration(type, duration) {
            return loopOut(type, duration, true);
          }
          if (this.getValueAtTime) {
            valueAtTime = this.getValueAtTime.bind(this);
          }
          if (this.getVelocityAtTime) {
            velocityAtTime = this.getVelocityAtTime.bind(this);
          }
          var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
          function lookAt(elem1, elem2) {
            var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
            var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
            var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
            return [yaw, pitch, 0];
          }
          function easeOut(t2, tMin, tMax, val1, val2) {
            return applyEase(easeOutBez, t2, tMin, tMax, val1, val2);
          }
          function easeIn(t2, tMin, tMax, val1, val2) {
            return applyEase(easeInBez, t2, tMin, tMax, val1, val2);
          }
          function ease(t2, tMin, tMax, val1, val2) {
            return applyEase(easeInOutBez, t2, tMin, tMax, val1, val2);
          }
          function applyEase(fn, t2, tMin, tMax, val1, val2) {
            if (val1 === void 0) {
              val1 = tMin;
              val2 = tMax;
            } else {
              t2 = (t2 - tMin) / (tMax - tMin);
            }
            if (t2 > 1) {
              t2 = 1;
            } else if (t2 < 0) {
              t2 = 0;
            }
            var mult = fn(t2);
            if ($bm_isInstanceOfArray(val1)) {
              var iKey;
              var lenKey = val1.length;
              var arr = createTypedArray("float32", lenKey);
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
              }
              return arr;
            }
            return (val2 - val1) * mult + val1;
          }
          function nearestKey(time2) {
            var iKey;
            var lenKey = data.k.length;
            var index2;
            var keyTime;
            if (!data.k.length || typeof data.k[0] === "number") {
              index2 = 0;
              keyTime = 0;
            } else {
              index2 = -1;
              time2 *= elem.comp.globalData.frameRate;
              if (time2 < data.k[0].t) {
                index2 = 1;
                keyTime = data.k[0].t;
              } else {
                for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                  if (time2 === data.k[iKey].t) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                    break;
                  } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                    if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                      index2 = iKey + 2;
                      keyTime = data.k[iKey + 1].t;
                    } else {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }
                    break;
                  }
                }
                if (index2 === -1) {
                  index2 = iKey + 1;
                  keyTime = data.k[iKey].t;
                }
              }
            }
            var obKey = {};
            obKey.index = index2;
            obKey.time = keyTime / elem.comp.globalData.frameRate;
            return obKey;
          }
          function key(ind) {
            var obKey;
            var iKey;
            var lenKey;
            if (!data.k.length || typeof data.k[0] === "number") {
              throw new Error("The property has no keyframe at index " + ind);
            }
            ind -= 1;
            obKey = {
              time: data.k[ind].t / elem.comp.globalData.frameRate,
              value: []
            };
            var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
            lenKey = arr.length;
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              obKey[iKey] = arr[iKey];
              obKey.value[iKey] = arr[iKey];
            }
            return obKey;
          }
          function framesToTime(fr, fps) {
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return fr / fps;
          }
          function timeToFrames(t2, fps) {
            if (!t2 && t2 !== 0) {
              t2 = time;
            }
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return t2 * fps;
          }
          function seedRandom(seed) {
            BMMath.seedrandom(randSeed + seed);
          }
          function sourceRectAtTime() {
            return elem.sourceRectAtTime();
          }
          function substring(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substring(init);
              }
              return value.substring(init, end);
            }
            return "";
          }
          function substr(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substr(init);
              }
              return value.substr(init, end);
            }
            return "";
          }
          function posterizeTime(framesPerSecond) {
            time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
            value = valueAtTime(time);
          }
          var time;
          var velocity;
          var value;
          var text;
          var textIndex;
          var textTotal;
          var selectorValue;
          var index = elem.data.ind;
          var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          var parent;
          var randSeed = Math.floor(Math.random() * 1e6);
          var globalData = elem.globalData;
          function executeExpression(_value) {
            value = _value;
            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
              return value;
            }
            if (this.propType === "textSelector") {
              textIndex = this.textIndex;
              textTotal = this.textTotal;
              selectorValue = this.selectorValue;
            }
            if (!thisLayer) {
              text = elem.layerInterface.text;
              thisLayer = elem.layerInterface;
              thisComp = elem.comp.compInterface;
              toWorld = thisLayer.toWorld.bind(thisLayer);
              fromWorld = thisLayer.fromWorld.bind(thisLayer);
              fromComp = thisLayer.fromComp.bind(thisLayer);
              toComp = thisLayer.toComp.bind(thisLayer);
              mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
              fromCompToSurface = fromComp;
            }
            if (!transform) {
              transform = elem.layerInterface("ADBE Transform Group");
              $bm_transform = transform;
              if (transform) {
                anchorPoint = transform.anchorPoint;
              }
            }
            if (elemType === 4 && !content) {
              content = thisLayer("ADBE Root Vectors Group");
            }
            if (!effect) {
              effect = thisLayer(4);
            }
            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            if (hasParent && !parent) {
              parent = elem.hierarchy[0].layerInterface;
            }
            time = this.comp.renderedFrame / this.comp.globalData.frameRate;
            if (_needsRandom) {
              seedRandom(randSeed + time);
            }
            if (needsVelocity) {
              velocity = velocityAtTime(time);
            }
            expression_function();
            this.frameExpressionId = elem.globalData.frameId;
            scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
            return scoped_bm_rt;
          }
          executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
          return executeExpression;
        }
        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
        ob.resetFrame = resetFrame;
        return ob;
      }();
      var Expressions = function() {
        var ob2 = {};
        ob2.initExpressions = initExpressions;
        ob2.resetFrame = ExpressionManager.resetFrame;
        function initExpressions(animation) {
          var stackCount = 0;
          var registers = [];
          function pushExpression() {
            stackCount += 1;
          }
          function popExpression() {
            stackCount -= 1;
            if (stackCount === 0) {
              releaseInstances();
            }
          }
          function registerExpressionProperty(expression) {
            if (registers.indexOf(expression) === -1) {
              registers.push(expression);
            }
          }
          function releaseInstances() {
            var i2;
            var len = registers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              registers[i2].release();
            }
            registers.length = 0;
          }
          animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
          animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
          animation.renderer.globalData.pushExpression = pushExpression;
          animation.renderer.globalData.popExpression = popExpression;
          animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
        return ob2;
      }();
      var MaskManagerInterface = function() {
        function MaskInterface(mask2, data2) {
          this._mask = mask2;
          this._data = data2;
        }
        Object.defineProperty(MaskInterface.prototype, "maskPath", {
          get: function get2() {
            if (this._mask.prop.k) {
              this._mask.prop.getValue();
            }
            return this._mask.prop;
          }
        });
        Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
          get: function get2() {
            if (this._mask.op.k) {
              this._mask.op.getValue();
            }
            return this._mask.op.v * 100;
          }
        });
        var MaskManager = function MaskManager2(maskManager) {
          var _masksInterfaces = createSizedArray(maskManager.viewData.length);
          var i2;
          var len = maskManager.viewData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            _masksInterfaces[i2] = new MaskInterface(maskManager.viewData[i2], maskManager.masksProperties[i2]);
          }
          var maskFunction = function maskFunction2(name2) {
            i2 = 0;
            while (i2 < len) {
              if (maskManager.masksProperties[i2].nm === name2) {
                return _masksInterfaces[i2];
              }
              i2 += 1;
            }
            return null;
          };
          return maskFunction;
        };
        return MaskManager;
      }();
      var ExpressionPropertyInterface = /* @__PURE__ */ function() {
        var defaultUnidimensionalValue = {
          pv: 0,
          v: 0,
          mult: 1
        };
        var defaultMultidimensionalValue = {
          pv: [0, 0, 0],
          v: [0, 0, 0],
          mult: 1
        };
        function completeProperty(expressionValue, property2, type) {
          Object.defineProperty(expressionValue, "velocity", {
            get: function get2() {
              return property2.getVelocityAtTime(property2.comp.currentFrame);
            }
          });
          expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
          expressionValue.key = function(pos) {
            if (!expressionValue.numKeys) {
              return 0;
            }
            var value2 = "";
            if ("s" in property2.keyframes[pos - 1]) {
              value2 = property2.keyframes[pos - 1].s;
            } else if ("e" in property2.keyframes[pos - 2]) {
              value2 = property2.keyframes[pos - 2].e;
            } else {
              value2 = property2.keyframes[pos - 2].s;
            }
            var valueProp = type === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
            valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
            valueProp.value = type === "unidimensional" ? value2[0] : value2;
            return valueProp;
          };
          expressionValue.valueAtTime = property2.getValueAtTime;
          expressionValue.speedAtTime = property2.getSpeedAtTime;
          expressionValue.velocityAtTime = property2.getVelocityAtTime;
          expressionValue.propertyGroup = property2.propertyGroup;
        }
        function UnidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultUnidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var val2 = property2.pv * mult;
          var expressionValue = new Number(val2);
          expressionValue.value = val2;
          completeProperty(expressionValue, property2, "unidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            val2 = property2.v * mult;
            if (expressionValue.value !== val2) {
              expressionValue = new Number(val2);
              expressionValue.value = val2;
              completeProperty(expressionValue, property2, "unidimensional");
            }
            return expressionValue;
          };
        }
        function MultidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultMultidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var len = property2.data && property2.data.l || property2.pv.length;
          var expressionValue = createTypedArray("float32", len);
          var arrValue = createTypedArray("float32", len);
          expressionValue.value = arrValue;
          completeProperty(expressionValue, property2, "multidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            for (var i2 = 0; i2 < len; i2 += 1) {
              arrValue[i2] = property2.v[i2] * mult;
              expressionValue[i2] = arrValue[i2];
            }
            return expressionValue;
          };
        }
        function defaultGetter() {
          return defaultUnidimensionalValue;
        }
        return function(property2) {
          if (!property2) {
            return defaultGetter;
          }
          if (property2.propType === "unidimensional") {
            return UnidimensionalPropertyInterface(property2);
          }
          return MultidimensionalPropertyInterface(property2);
        };
      }();
      var TransformExpressionInterface = /* @__PURE__ */ function() {
        return function(transform2) {
          function _thisFunction(name2) {
            switch (name2) {
              case "scale":
              case "Scale":
              case "ADBE Scale":
              case 6:
                return _thisFunction.scale;
              case "rotation":
              case "Rotation":
              case "ADBE Rotation":
              case "ADBE Rotate Z":
              case 10:
                return _thisFunction.rotation;
              case "ADBE Rotate X":
                return _thisFunction.xRotation;
              case "ADBE Rotate Y":
                return _thisFunction.yRotation;
              case "position":
              case "Position":
              case "ADBE Position":
              case 2:
                return _thisFunction.position;
              case "ADBE Position_0":
                return _thisFunction.xPosition;
              case "ADBE Position_1":
                return _thisFunction.yPosition;
              case "ADBE Position_2":
                return _thisFunction.zPosition;
              case "anchorPoint":
              case "AnchorPoint":
              case "Anchor Point":
              case "ADBE AnchorPoint":
              case 1:
                return _thisFunction.anchorPoint;
              case "opacity":
              case "Opacity":
              case 11:
                return _thisFunction.opacity;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisFunction, "rotation", {
            get: ExpressionPropertyInterface(transform2.r || transform2.rz)
          });
          Object.defineProperty(_thisFunction, "zRotation", {
            get: ExpressionPropertyInterface(transform2.rz || transform2.r)
          });
          Object.defineProperty(_thisFunction, "xRotation", {
            get: ExpressionPropertyInterface(transform2.rx)
          });
          Object.defineProperty(_thisFunction, "yRotation", {
            get: ExpressionPropertyInterface(transform2.ry)
          });
          Object.defineProperty(_thisFunction, "scale", {
            get: ExpressionPropertyInterface(transform2.s)
          });
          var _px;
          var _py;
          var _pz;
          var _transformFactory;
          if (transform2.p) {
            _transformFactory = ExpressionPropertyInterface(transform2.p);
          } else {
            _px = ExpressionPropertyInterface(transform2.px);
            _py = ExpressionPropertyInterface(transform2.py);
            if (transform2.pz) {
              _pz = ExpressionPropertyInterface(transform2.pz);
            }
          }
          Object.defineProperty(_thisFunction, "position", {
            get: function get2() {
              if (transform2.p) {
                return _transformFactory();
              }
              return [_px(), _py(), _pz ? _pz() : 0];
            }
          });
          Object.defineProperty(_thisFunction, "xPosition", {
            get: ExpressionPropertyInterface(transform2.px)
          });
          Object.defineProperty(_thisFunction, "yPosition", {
            get: ExpressionPropertyInterface(transform2.py)
          });
          Object.defineProperty(_thisFunction, "zPosition", {
            get: ExpressionPropertyInterface(transform2.pz)
          });
          Object.defineProperty(_thisFunction, "anchorPoint", {
            get: ExpressionPropertyInterface(transform2.a)
          });
          Object.defineProperty(_thisFunction, "opacity", {
            get: ExpressionPropertyInterface(transform2.o)
          });
          Object.defineProperty(_thisFunction, "skew", {
            get: ExpressionPropertyInterface(transform2.sk)
          });
          Object.defineProperty(_thisFunction, "skewAxis", {
            get: ExpressionPropertyInterface(transform2.sa)
          });
          Object.defineProperty(_thisFunction, "orientation", {
            get: ExpressionPropertyInterface(transform2.or)
          });
          return _thisFunction;
        };
      }();
      var LayerExpressionInterface = /* @__PURE__ */ function() {
        function getMatrix(time2) {
          var toWorldMat = new Matrix();
          if (time2 !== void 0) {
            var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
            propMatrix.clone(toWorldMat);
          } else {
            var transformMat = this._elem.finalTransform.mProp;
            transformMat.applyToMatrix(toWorldMat);
          }
          return toWorldMat;
        }
        function toWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.applyPoint(toWorldMat, arr);
        }
        function toWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.applyPoint(toWorldMat, arr);
        }
        function fromWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.invertPoint(toWorldMat, arr);
        }
        function fromWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.invertPoint(toWorldMat, arr);
        }
        function applyPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }
        function invertPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.inversePoint(arr);
        }
        function fromComp2(arr) {
          var toWorldMat = new Matrix();
          toWorldMat.reset();
          this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(toWorldMat);
            }
            return toWorldMat.inversePoint(arr);
          }
          return toWorldMat.inversePoint(arr);
        }
        function sampleImage() {
          return [1, 1, 1, 1];
        }
        return function(elem2) {
          var transformInterface;
          function _registerMaskInterface(maskManager) {
            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
          }
          function _registerEffectsInterface(effects) {
            _thisLayerFunction.effect = effects;
          }
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Root Vectors Group":
              case "Contents":
              case 2:
                return _thisLayerFunction.shapeInterface;
              case 1:
              case 6:
              case "Transform":
              case "transform":
              case "ADBE Transform Group":
                return transformInterface;
              case 4:
              case "ADBE Effect Parade":
              case "effects":
              case "Effects":
                return _thisLayerFunction.effect;
              case "ADBE Text Properties":
                return _thisLayerFunction.textInterface;
              default:
                return null;
            }
          }
          _thisLayerFunction.getMatrix = getMatrix;
          _thisLayerFunction.invertPoint = invertPoint;
          _thisLayerFunction.applyPoint = applyPoint;
          _thisLayerFunction.toWorld = toWorld2;
          _thisLayerFunction.toWorldVec = toWorldVec;
          _thisLayerFunction.fromWorld = fromWorld2;
          _thisLayerFunction.fromWorldVec = fromWorldVec;
          _thisLayerFunction.toComp = toWorld2;
          _thisLayerFunction.fromComp = fromComp2;
          _thisLayerFunction.sampleImage = sampleImage;
          _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
          _thisLayerFunction._elem = elem2;
          transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
          var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
          Object.defineProperties(_thisLayerFunction, {
            hasParent: {
              get: function get2() {
                return elem2.hierarchy.length;
              }
            },
            parent: {
              get: function get2() {
                return elem2.hierarchy[0].layerInterface;
              }
            },
            rotation: getDescriptor(transformInterface, "rotation"),
            scale: getDescriptor(transformInterface, "scale"),
            position: getDescriptor(transformInterface, "position"),
            opacity: getDescriptor(transformInterface, "opacity"),
            anchorPoint: anchorPointDescriptor,
            anchor_point: anchorPointDescriptor,
            transform: {
              get: function get2() {
                return transformInterface;
              }
            },
            active: {
              get: function get2() {
                return elem2.isInRange;
              }
            }
          });
          _thisLayerFunction.startTime = elem2.data.st;
          _thisLayerFunction.index = elem2.data.ind;
          _thisLayerFunction.source = elem2.data.refId;
          _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
          _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
          _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
          _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
          _thisLayerFunction._name = elem2.data.nm;
          _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
          _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
          return _thisLayerFunction;
        };
      }();
      var propertyGroupFactory = /* @__PURE__ */ function() {
        return function(interfaceFunction, parentPropertyGroup) {
          return function(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return parentPropertyGroup(val2 - 1);
          };
        };
      }();
      var PropertyInterface = /* @__PURE__ */ function() {
        return function(propertyName, propertyGroup) {
          var interfaceFunction = {
            _name: propertyName
          };
          function _propertyGroup(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return propertyGroup(val2 - 1);
          }
          return _propertyGroup;
        };
      }();
      var EffectsExpressionInterface = /* @__PURE__ */ function() {
        var ob2 = {
          createEffectsInterface
        };
        function createEffectsInterface(elem2, propertyGroup) {
          if (elem2.effectsManager) {
            var effectElements = [];
            var effectsData = elem2.data.ef;
            var i2;
            var len = elem2.effectsManager.effectElements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              effectElements.push(createGroupInterface(effectsData[i2], elem2.effectsManager.effectElements[i2], propertyGroup, elem2));
            }
            var effects = elem2.data.ef || [];
            var groupInterface = function groupInterface2(name2) {
              i2 = 0;
              len = effects.length;
              while (i2 < len) {
                if (name2 === effects[i2].nm || name2 === effects[i2].mn || name2 === effects[i2].ix) {
                  return effectElements[i2];
                }
                i2 += 1;
              }
              return null;
            };
            Object.defineProperty(groupInterface, "numProperties", {
              get: function get2() {
                return effects.length;
              }
            });
            return groupInterface;
          }
          return null;
        }
        function createGroupInterface(data2, elements, propertyGroup, elem2) {
          function groupInterface(name2) {
            var effects = data2.ef;
            var i3 = 0;
            var len2 = effects.length;
            while (i3 < len2) {
              if (name2 === effects[i3].nm || name2 === effects[i3].mn || name2 === effects[i3].ix) {
                if (effects[i3].ty === 5) {
                  return effectElements[i3];
                }
                return effectElements[i3]();
              }
              i3 += 1;
            }
            throw new Error();
          }
          var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
          var effectElements = [];
          var i2;
          var len = data2.ef.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (data2.ef[i2].ty === 5) {
              effectElements.push(createGroupInterface(data2.ef[i2], elements.effectElements[i2], elements.effectElements[i2].propertyGroup, elem2));
            } else {
              effectElements.push(createValueInterface(elements.effectElements[i2], data2.ef[i2].ty, elem2, _propertyGroup));
            }
          }
          if (data2.mn === "ADBE Color Control") {
            Object.defineProperty(groupInterface, "color", {
              get: function get2() {
                return effectElements[0]();
              }
            });
          }
          Object.defineProperties(groupInterface, {
            numProperties: {
              get: function get2() {
                return data2.np;
              }
            },
            _name: {
              value: data2.nm
            },
            propertyGroup: {
              value: _propertyGroup
            }
          });
          groupInterface.enabled = data2.en !== 0;
          groupInterface.active = groupInterface.enabled;
          return groupInterface;
        }
        function createValueInterface(element, type, elem2, propertyGroup) {
          var expressionProperty = ExpressionPropertyInterface(element.p);
          function interfaceFunction() {
            if (type === 10) {
              return elem2.comp.compInterface(element.p.v);
            }
            return expressionProperty();
          }
          if (element.p.setGroupProperty) {
            element.p.setGroupProperty(PropertyInterface("", propertyGroup));
          }
          return interfaceFunction;
        }
        return ob2;
      }();
      var ShapePathInterface = /* @__PURE__ */ function() {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;
          function interfaceFunction(val2) {
            if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
              return interfaceFunction.path;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function get2() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            shape: {
              get: function get2() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            _name: {
              value: shape.nm
            },
            ix: {
              value: shape.ix
            },
            propertyIndex: {
              value: shape.ix
            },
            mn: {
              value: shape.mn
            },
            propertyGroup: {
              value: propertyGroup
            }
          });
          return interfaceFunction;
        };
      }();
      var ShapeExpressionInterface = /* @__PURE__ */ function() {
        function iterateElements(shapes, view, propertyGroup) {
          var arr = [];
          var i2;
          var len = shapes ? shapes.length : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (shapes[i2].ty === "gr") {
              arr.push(groupInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "fl") {
              arr.push(fillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "st") {
              arr.push(strokeInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "tm") {
              arr.push(trimInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "tr") {
            } else if (shapes[i2].ty === "el") {
              arr.push(ellipseInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "sr") {
              arr.push(starInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "sh") {
              arr.push(ShapePathInterface(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rc") {
              arr.push(rectInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rd") {
              arr.push(roundedInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rp") {
              arr.push(repeaterInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "gf") {
              arr.push(gradientFillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else {
              arr.push(defaultInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            }
          }
          return arr;
        }
        function contentsInterfaceFactory(shape, view, propertyGroup) {
          var interfaces2;
          var interfaceFunction = function _interfaceFunction(value2) {
            var i2 = 0;
            var len = interfaces2.length;
            while (i2 < len) {
              if (interfaces2[i2]._name === value2 || interfaces2[i2].mn === value2 || interfaces2[i2].propertyIndex === value2 || interfaces2[i2].ix === value2 || interfaces2[i2].ind === value2) {
                return interfaces2[i2];
              }
              i2 += 1;
            }
            if (typeof value2 === "number") {
              return interfaces2[value2 - 1];
            }
            return null;
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
          interfaceFunction.numProperties = interfaces2.length;
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.transform = transformInterface;
          interfaceFunction.propertyIndex = shape.cix;
          interfaceFunction._name = shape.nm;
          return interfaceFunction;
        }
        function groupInterfaceFactory(shape, view, propertyGroup) {
          var interfaceFunction = function _interfaceFunction(value2) {
            switch (value2) {
              case "ADBE Vectors Group":
              case "Contents":
              case 2:
                return interfaceFunction.content;
              // Not necessary for now. Keeping them here in case a new case appears
              // case 'ADBE Vector Transform Group':
              // case 3:
              default:
                return interfaceFunction.transform;
            }
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.content = content2;
          interfaceFunction.transform = transformInterface;
          Object.defineProperty(interfaceFunction, "_name", {
            get: function get2() {
              return shape.nm;
            }
          });
          interfaceFunction.numProperties = shape.np;
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.nm = shape.nm;
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function fillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Start Point" || val2 === "start point") {
              return interfaceFunction.startPoint;
            }
            if (val2 === "End Point" || val2 === "end point") {
              return interfaceFunction.endPoint;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            startPoint: {
              get: ExpressionPropertyInterface(view.s)
            },
            endPoint: {
              get: ExpressionPropertyInterface(view.e)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            type: {
              get: function get2() {
                return "a";
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function defaultInterfaceFactory() {
          function interfaceFunction() {
            return null;
          }
          return interfaceFunction;
        }
        function strokeInterfaceFactory(shape, view, propertyGroup) {
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
          function addPropertyToDashOb(i3) {
            Object.defineProperty(dashOb, shape.d[i3].nm, {
              get: ExpressionPropertyInterface(view.d.dataProps[i3].p)
            });
          }
          var i2;
          var len = shape.d ? shape.d.length : 0;
          var dashOb = {};
          for (i2 = 0; i2 < len; i2 += 1) {
            addPropertyToDashOb(i2);
            view.d.dataProps[i2].p.setGroupProperty(_dashPropertyGroup);
          }
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            if (val2 === "Stroke Width" || val2 === "stroke width") {
              return interfaceFunction.strokeWidth;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            strokeWidth: {
              get: ExpressionPropertyInterface(view.w)
            },
            dash: {
              get: function get2() {
                return dashOb;
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
          return interfaceFunction;
        }
        function trimInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
              return interfaceFunction.end;
            }
            if (val2 === shape.s.ix) {
              return interfaceFunction.start;
            }
            if (val2 === shape.o.ix) {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.propertyGroup = propertyGroup;
          Object.defineProperties(interfaceFunction, {
            start: {
              get: ExpressionPropertyInterface(view.s)
            },
            end: {
              get: ExpressionPropertyInterface(view.e)
            },
            offset: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function transformInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.a.ix === value2 || value2 === "Anchor Point") {
              return interfaceFunction.anchorPoint;
            }
            if (shape.o.ix === value2 || value2 === "Opacity") {
              return interfaceFunction.opacity;
            }
            if (shape.p.ix === value2 || value2 === "Position") {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
              return interfaceFunction.rotation;
            }
            if (shape.s.ix === value2 || value2 === "Scale") {
              return interfaceFunction.scale;
            }
            if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
              return interfaceFunction.skew;
            }
            if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
              return interfaceFunction.skewAxis;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
          view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
          view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (view.transform.mProps.sk) {
            view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
            view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
          }
          view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            opacity: {
              get: ExpressionPropertyInterface(view.transform.mProps.o)
            },
            position: {
              get: ExpressionPropertyInterface(view.transform.mProps.p)
            },
            anchorPoint: {
              get: ExpressionPropertyInterface(view.transform.mProps.a)
            },
            scale: {
              get: ExpressionPropertyInterface(view.transform.mProps.s)
            },
            rotation: {
              get: ExpressionPropertyInterface(view.transform.mProps.r)
            },
            skew: {
              get: ExpressionPropertyInterface(view.transform.mProps.sk)
            },
            skewAxis: {
              get: ExpressionPropertyInterface(view.transform.mProps.sa)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.ty = "tr";
          interfaceFunction.mn = shape.mn;
          interfaceFunction.propertyGroup = propertyGroup;
          return interfaceFunction;
        }
        function ellipseInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.s.ix === value2) {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function starInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.rotation;
            }
            if (shape.pt.ix === value2) {
              return interfaceFunction.points;
            }
            if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
              return interfaceFunction.outerRadius;
            }
            if (shape.os.ix === value2) {
              return interfaceFunction.outerRoundness;
            }
            if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
              return interfaceFunction.innerRadius;
            }
            if (shape.is && shape.is.ix === value2) {
              return interfaceFunction.innerRoundness;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
          prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
          prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (shape.ir) {
            prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
            prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
          }
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            rotation: {
              get: ExpressionPropertyInterface(prop.r)
            },
            points: {
              get: ExpressionPropertyInterface(prop.pt)
            },
            outerRadius: {
              get: ExpressionPropertyInterface(prop.or)
            },
            outerRoundness: {
              get: ExpressionPropertyInterface(prop.os)
            },
            innerRadius: {
              get: ExpressionPropertyInterface(prop.ir)
            },
            innerRoundness: {
              get: ExpressionPropertyInterface(prop.is)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function rectInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.roundness;
            }
            if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            roundness: {
              get: ExpressionPropertyInterface(prop.r)
            },
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function roundedInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.r.ix === value2 || value2 === "Round Corners 1") {
              return interfaceFunction.radius;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            radius: {
              get: ExpressionPropertyInterface(prop.rd)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function repeaterInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.c.ix === value2 || value2 === "Copies") {
              return interfaceFunction.copies;
            }
            if (shape.o.ix === value2 || value2 === "Offset") {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
          prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            copies: {
              get: ExpressionPropertyInterface(prop.c)
            },
            offset: {
              get: ExpressionPropertyInterface(prop.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        return function(shapes, view, propertyGroup) {
          var interfaces2;
          function _interfaceFunction(value2) {
            if (typeof value2 === "number") {
              value2 = value2 === void 0 ? 1 : value2;
              if (value2 === 0) {
                return propertyGroup;
              }
              return interfaces2[value2 - 1];
            }
            var i2 = 0;
            var len = interfaces2.length;
            while (i2 < len) {
              if (interfaces2[i2]._name === value2) {
                return interfaces2[i2];
              }
              i2 += 1;
            }
            return null;
          }
          function parentGroupWrapper() {
            return propertyGroup;
          }
          _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
          interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
          _interfaceFunction.numProperties = interfaces2.length;
          _interfaceFunction._name = "Contents";
          return _interfaceFunction;
        };
      }();
      var TextExpressionInterface = /* @__PURE__ */ function() {
        return function(elem2) {
          var _sourceText;
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Text Document":
                return _thisLayerFunction.sourceText;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisLayerFunction, "sourceText", {
            get: function get2() {
              elem2.textProperty.getValue();
              var stringValue = elem2.textProperty.currentData.t;
              if (!_sourceText || stringValue !== _sourceText.value) {
                _sourceText = new String(stringValue);
                _sourceText.value = stringValue || new String(stringValue);
                Object.defineProperty(_sourceText, "style", {
                  get: function get3() {
                    return {
                      fillColor: elem2.textProperty.currentData.fc
                    };
                  }
                });
              }
              return _sourceText;
            }
          });
          return _thisLayerFunction;
        };
      }();
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var FootageInterface = /* @__PURE__ */ function() {
        var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
          var currentPropertyName = "";
          var currentProperty = elem2.getFootageData();
          function init() {
            currentPropertyName = "";
            currentProperty = elem2.getFootageData();
            return searchProperty;
          }
          function searchProperty(value2) {
            if (currentProperty[value2]) {
              currentPropertyName = value2;
              currentProperty = currentProperty[value2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            var propertyNameIndex = value2.indexOf(currentPropertyName);
            if (propertyNameIndex !== -1) {
              var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
              currentProperty = currentProperty[index2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            return "";
          }
          return init;
        };
        var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
          function interfaceFunction(value2) {
            if (value2 === "Outline") {
              return interfaceFunction.outlineInterface();
            }
            return null;
          }
          interfaceFunction._name = "Outline";
          interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
          return interfaceFunction;
        };
        return function(elem2) {
          function _interfaceFunction(value2) {
            if (value2 === "Data") {
              return _interfaceFunction.dataInterface;
            }
            return null;
          }
          _interfaceFunction._name = "Data";
          _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
          return _interfaceFunction;
        };
      }();
      var interfaces = {
        layer: LayerExpressionInterface,
        effects: EffectsExpressionInterface,
        comp: CompExpressionInterface,
        shape: ShapeExpressionInterface,
        text: TextExpressionInterface,
        footage: FootageInterface
      };
      function getInterface(type) {
        return interfaces[type] || null;
      }
      var expressionHelpers = /* @__PURE__ */ function() {
        function searchExpressions(elem2, data2, prop) {
          if (data2.x) {
            prop.k = true;
            prop.x = true;
            prop.initiateExpression = ExpressionManager.initiateExpression;
            prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
          }
        }
        function getValueAtTime(frameNum) {
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastFrame) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
            this._cachingAtTime.lastFrame = frameNum;
          }
          return this._cachingAtTime.value;
        }
        function getSpeedAtTime(frameNum) {
          var delta = -0.01;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var speed = 0;
          if (v1.length) {
            var i2;
            for (i2 = 0; i2 < v1.length; i2 += 1) {
              speed += Math.pow(v2[i2] - v1[i2], 2);
            }
            speed = Math.sqrt(speed) * 100;
          } else {
            speed = 0;
          }
          return speed;
        }
        function getVelocityAtTime(frameNum) {
          if (this.vel !== void 0) {
            return this.vel;
          }
          var delta = -1e-3;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var velocity2;
          if (v1.length) {
            velocity2 = createTypedArray("float32", v1.length);
            var i2;
            for (i2 = 0; i2 < v1.length; i2 += 1) {
              velocity2[i2] = (v2[i2] - v1[i2]) / delta;
            }
          } else {
            velocity2 = (v2 - v1) / delta;
          }
          return velocity2;
        }
        function getStaticValueAtTime() {
          return this.pv;
        }
        function setGroupProperty(propertyGroup) {
          this.propertyGroup = propertyGroup;
        }
        return {
          searchExpressions,
          getSpeedAtTime,
          getVelocityAtTime,
          getValueAtTime,
          getStaticValueAtTime,
          setGroupProperty
        };
      }();
      function addPropertyDecorator() {
        function loopOut2(type, duration, durationFlag) {
          if (!this.k || !this.keyframes) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var lastKeyFrame = keyframes[keyframes.length - 1].t;
          if (currentFrame <= lastKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var firstKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
            } else {
              cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
            }
            firstKeyFrame = lastKeyFrame - cycleDuration;
          }
          var i2;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations2 = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (iterations2 % 2 !== 0) {
              return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = (endV[i2] - initV[i2]) * repeats + current[i2];
              }
              return ret;
            }
            return (endV - initV) * repeats + current;
          } else if (type === "continue") {
            var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(lastValue.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = lastValue[i2] + (lastValue[i2] - nextLastValue[i2]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
              }
              return ret;
            }
            return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
          }
          return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
        }
        function loopIn2(type, duration, durationFlag) {
          if (!this.k) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var firstKeyFrame = keyframes[0].t;
          if (currentFrame >= firstKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var lastKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            lastKeyFrame = keyframes[duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
            } else {
              cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
            }
            lastKeyFrame = firstKeyFrame + cycleDuration;
          }
          var i2;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations2 = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
            if (iterations2 % 2 === 0) {
              return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = current[i2] - (endV[i2] - initV[i2]) * repeats;
              }
              return ret;
            }
            return current - (endV - initV) * repeats;
          } else if (type === "continue") {
            var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(firstValue.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = firstValue[i2] + (firstValue[i2] - nextFirstValue[i2]) * (firstKeyFrame - currentFrame) / 1e-3;
              }
              return ret;
            }
            return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
          }
          return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
        }
        function smooth2(width2, samples) {
          if (!this.k) {
            return this.pv;
          }
          width2 = (width2 || 0.4) * 0.5;
          samples = Math.floor(samples || 5);
          if (samples <= 1) {
            return this.pv;
          }
          var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
          var initFrame2 = currentTime - width2;
          var endFrame = currentTime + width2;
          var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
          var i2 = 0;
          var j2 = 0;
          var value2;
          if (this.pv.length) {
            value2 = createTypedArray("float32", this.pv.length);
          } else {
            value2 = 0;
          }
          var sampleValue;
          while (i2 < samples) {
            sampleValue = this.getValueAtTime(initFrame2 + i2 * sampleFrequency);
            if (this.pv.length) {
              for (j2 = 0; j2 < this.pv.length; j2 += 1) {
                value2[j2] += sampleValue[j2];
              }
            } else {
              value2 += sampleValue;
            }
            i2 += 1;
          }
          if (this.pv.length) {
            for (j2 = 0; j2 < this.pv.length; j2 += 1) {
              value2[j2] /= samples;
            }
          } else {
            value2 /= samples;
          }
          return value2;
        }
        function getTransformValueAtTime(time2) {
          if (!this._transformCachingAtTime) {
            this._transformCachingAtTime = {
              v: new Matrix()
            };
          }
          var matrix = this._transformCachingAtTime.v;
          matrix.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            var anchor = this.a.getValueAtTime(time2);
            matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
          }
          if (this.appliedTransformations < 2) {
            var scale3 = this.s.getValueAtTime(time2);
            matrix.scale(scale3[0] * this.s.mult, scale3[1] * this.s.mult, scale3[2] * this.s.mult);
          }
          if (this.sk && this.appliedTransformations < 3) {
            var skew = this.sk.getValueAtTime(time2);
            var skewAxis = this.sa.getValueAtTime(time2);
            matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var rotation2 = this.r.getValueAtTime(time2);
            matrix.rotate(-rotation2 * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var rotationZ = this.rz.getValueAtTime(time2);
            var rotationY = this.ry.getValueAtTime(time2);
            var rotationX = this.rx.getValueAtTime(time2);
            var orientation = this.or.getValueAtTime(time2);
            matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var positionX = this.px.getValueAtTime(time2);
            var positionY = this.py.getValueAtTime(time2);
            if (this.data.p.z) {
              var positionZ = this.pz.getValueAtTime(time2);
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
            } else {
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            }
          } else {
            var position2 = this.p.getValueAtTime(time2);
            matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
          }
          return matrix;
        }
        function getTransformStaticValueAtTime() {
          return this.v.clone(new Matrix());
        }
        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
          var prop = getTransformProperty(elem2, data2, container);
          if (prop.dynamicProperties.length) {
            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          return prop;
        };
        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem2, data2, type, mult, container) {
          var prop = propertyGetProp(elem2, data2, type, mult, container);
          if (prop.kf) {
            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          prop.loopOut = loopOut2;
          prop.loopIn = loopIn2;
          prop.smooth = smooth2;
          prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
          prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
          prop.numKeys = data2.a === 1 ? data2.k.length : 0;
          prop.propertyIndex = data2.ix;
          var value2 = 0;
          if (type !== 0) {
            value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
          }
          prop._cachingAtTime = {
            lastFrame: initialDefaultFrame,
            lastIndex: 0,
            value: value2
          };
          expressionHelpers.searchExpressions(elem2, data2, prop);
          if (prop.k) {
            container.addDynamicProperty(prop);
          }
          return prop;
        };
        function getShapeValueAtTime(frameNum) {
          if (!this._cachingAtTime) {
            this._cachingAtTime = {
              shapeValue: shapePool.clone(this.pv),
              lastIndex: 0,
              lastTime: initialDefaultFrame
            };
          }
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastTime) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
            this._cachingAtTime.lastTime = frameNum;
            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
          }
          return this._cachingAtTime.shapeValue;
        }
        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ShapeExpressions() {
        }
        ShapeExpressions.prototype = {
          vertices: function vertices(prop, time2) {
            if (this.k) {
              this.getValue();
            }
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            var i2;
            var len = shapePath._length;
            var vertices2 = shapePath[prop];
            var points = shapePath.v;
            var arr = createSizedArray(len);
            for (i2 = 0; i2 < len; i2 += 1) {
              if (prop === "i" || prop === "o") {
                arr[i2] = [vertices2[i2][0] - points[i2][0], vertices2[i2][1] - points[i2][1]];
              } else {
                arr[i2] = [vertices2[i2][0], vertices2[i2][1]];
              }
            }
            return arr;
          },
          points: function points(time2) {
            return this.vertices("v", time2);
          },
          inTangents: function inTangents(time2) {
            return this.vertices("i", time2);
          },
          outTangents: function outTangents(time2) {
            return this.vertices("o", time2);
          },
          isClosed: function isClosed() {
            return this.v.c;
          },
          pointOnPath: function pointOnPath(perc, time2) {
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            if (!this._segmentsLength) {
              this._segmentsLength = bez.getSegmentsLength(shapePath);
            }
            var segmentsLength = this._segmentsLength;
            var lengths = segmentsLength.lengths;
            var lengthPos = segmentsLength.totalLength * perc;
            var i2 = 0;
            var len = lengths.length;
            var accumulatedLength = 0;
            var pt;
            while (i2 < len) {
              if (accumulatedLength + lengths[i2].addedLength > lengthPos) {
                var initIndex = i2;
                var endIndex = shapePath.c && i2 === len - 1 ? 0 : i2 + 1;
                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i2].addedLength;
                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i2]);
                break;
              } else {
                accumulatedLength += lengths[i2].addedLength;
              }
              i2 += 1;
            }
            if (!pt) {
              pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
            }
            return pt;
          },
          vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
            if (perc == 1) {
              perc = this.v.c;
            } else if (perc == 0) {
              perc = 0.999;
            }
            var pt1 = this.pointOnPath(perc, time2);
            var pt2 = this.pointOnPath(perc + 1e-3, time2);
            var xLength = pt2[0] - pt1[0];
            var yLength = pt2[1] - pt1[1];
            var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
            if (magnitude === 0) {
              return [0, 0];
            }
            var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
            return unitVector;
          },
          tangentOnPath: function tangentOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "tangent");
          },
          normalOnPath: function normalOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr, trims) {
          var prop = propertyGetShapeProp(elem2, data2, type, arr, trims);
          prop.propertyIndex = data2.ix;
          prop.lock = false;
          if (type === 3) {
            expressionHelpers.searchExpressions(elem2, data2.pt, prop);
          } else if (type === 4) {
            expressionHelpers.searchExpressions(elem2, data2.ks, prop);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function searchExpressions() {
          if (this.data.d.x) {
            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
            this.addEffect(this.getExpressionValue.bind(this));
            return true;
          }
          return null;
        }
        TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
          var newValue = this.calculateExpression(text2);
          if (currentValue.t !== newValue) {
            var newData = {};
            this.copyData(newData, currentValue);
            newData.t = newValue.toString();
            newData.__complete = false;
            return newData;
          }
          return currentValue;
        };
        TextProperty.prototype.searchProperty = function() {
          var isKeyframed = this.searchKeyframes();
          var hasExpressions = this.searchExpressions();
          this.kf = isKeyframed || hasExpressions;
          return this.kf;
        };
        TextProperty.prototype.searchExpressions = searchExpressions;
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {
      }
      SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
          var feMerge = createNS("feMerge");
          feMerge.setAttribute("result", resultId);
          var feMergeNode;
          var i2;
          for (i2 = 0; i2 < ins.length; i2 += 1) {
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", ins[i2]);
            feMerge.appendChild(feMergeNode);
            feMerge.appendChild(feMergeNode);
          }
          return feMerge;
        }
      };
      var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(filter, filterManager, elem2, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
        this.linearFilter = feColorMatrix;
        feColorMatrix.setAttribute("result", id + "_tint_1");
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_2");
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter);
      SVGTintFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var colorBlack = this.filterManager.effectElements[0].p.v;
          var colorWhite = this.filterManager.effectElements[1].p.v;
          var opacity = this.filterManager.effectElements[2].p.v / 100;
          this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
          this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
        }
      };
      function SVGFillFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
      }
      SVGFillFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color = this.filterManager.effectElements[2].p.v;
          var opacity = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
        }
      };
      function SVGStrokeEffect(fil, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem2;
        this.paths = [];
      }
      SVGStrokeEffect.prototype.initialize = function() {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i2;
        var len;
        if (this.filterManager.effectElements[1].p.v === 1) {
          len = this.elem.maskManager.masksProperties.length;
          i2 = 0;
        } else {
          i2 = this.filterManager.effectElements[0].p.v - 1;
          len = i2 + 1;
        }
        groupPath = createNS("g");
        groupPath.setAttribute("fill", "none");
        groupPath.setAttribute("stroke-linecap", "round");
        groupPath.setAttribute("stroke-dashoffset", 1);
        for (i2; i2 < len; i2 += 1) {
          path = createNS("path");
          groupPath.appendChild(path);
          this.paths.push({
            p: path,
            m: i2
          });
        }
        if (this.filterManager.effectElements[10].p.v === 3) {
          var mask2 = createNS("mask");
          var id = createElementID();
          mask2.setAttribute("id", id);
          mask2.setAttribute("mask-type", "alpha");
          mask2.appendChild(groupPath);
          this.elem.globalData.defs.appendChild(mask2);
          var g3 = createNS("g");
          g3.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
          while (elemChildren[0]) {
            g3.appendChild(elemChildren[0]);
          }
          this.elem.layerElement.appendChild(g3);
          this.masker = mask2;
          groupPath.setAttribute("stroke", "#fff");
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (this.filterManager.effectElements[10].p.v === 2) {
            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            while (elemChildren.length) {
              this.elem.layerElement.removeChild(elemChildren[0]);
            }
          }
          this.elem.layerElement.appendChild(groupPath);
          this.elem.layerElement.removeAttribute("mask");
          groupPath.setAttribute("stroke", "#fff");
        }
        this.initialized = true;
        this.pathMasker = groupPath;
      };
      SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
        if (!this.initialized) {
          this.initialize();
        }
        var i2;
        var len = this.paths.length;
        var mask2;
        var path;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.paths[i2].m !== -1) {
            mask2 = this.elem.maskManager.viewData[this.paths[i2].m];
            path = this.paths[i2].p;
            if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
              path.setAttribute("d", mask2.lastPath);
            }
            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
              var dasharrayValue;
              if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                var s2 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var e3 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var l2 = path.getTotalLength();
                dasharrayValue = "0 0 0 " + l2 * s2 + " ";
                var lineLength = l2 * (e3 - s2);
                var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                var units = Math.floor(lineLength / segment);
                var j2;
                for (j2 = 0; j2 < units; j2 += 1) {
                  dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                }
                dasharrayValue += "0 " + l2 * 10 + " 0 0";
              } else {
                dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              }
              path.setAttribute("stroke-dasharray", dasharrayValue);
            }
          }
        }
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
        }
        if (forceRender || this.filterManager.effectElements[6].p._mdf) {
          this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
        }
        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (forceRender || this.filterManager.effectElements[3].p._mdf) {
            var color = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
          }
        }
      };
      function SVGTritoneFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS("feFuncR");
        feFuncR.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS("feFuncG");
        feFuncG.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS("feFuncB");
        feFuncB.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
      }
      SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color1 = this.filterManager.effectElements[0].p.v;
          var color2 = this.filterManager.effectElements[1].p.v;
          var color3 = this.filterManager.effectElements[2].p.v;
          var tableR = color3[0] + " " + color2[0] + " " + color1[0];
          var tableG = color3[1] + " " + color2[1] + " " + color1[1];
          var tableB = color3[2] + " " + color2[2] + " " + color1[2];
          this.feFuncR.setAttribute("tableValues", tableR);
          this.feFuncG.setAttribute("tableValues", tableG);
          this.feFuncB.setAttribute("tableValues", tableB);
        }
      };
      function SVGProLevelsFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS("feComponentTransfer");
        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
          this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
        }
        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
          this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
        }
        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
          this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
        }
        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
          this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
        }
        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          filter.appendChild(feComponentTransfer);
        }
        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
          feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id);
          filter.appendChild(feComponentTransfer);
          this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
          this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
          this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
        }
      }
      SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
      };
      SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma2, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min3 = Math.min(inputBlack, inputWhite);
        var max3 = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
          length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;
        while (cnt <= 256) {
          perc = cnt / 256;
          if (perc <= min3) {
            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
          } else if (perc >= max3) {
            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
          } else {
            colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma2);
          }
          table[pos] = colorValue;
          pos += 1;
          cnt += 256 / (segments - 1);
        }
        return table.join(" ");
      };
      SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var val2;
          var effectElements = this.filterManager.effectElements;
          if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
            val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
            this.feFuncRComposed.setAttribute("tableValues", val2);
            this.feFuncGComposed.setAttribute("tableValues", val2);
            this.feFuncBComposed.setAttribute("tableValues", val2);
          }
          if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
            val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
            this.feFuncR.setAttribute("tableValues", val2);
          }
          if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
            val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
            this.feFuncG.setAttribute("tableValues", val2);
          }
          if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
            val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
            this.feFuncB.setAttribute("tableValues", val2);
          }
          if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
            val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
            this.feFuncA.setAttribute("tableValues", val2);
          }
        }
      };
      function SVGDropShadowEffect(filter, filterManager, elem2, id, source) {
        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
        var filterSize = filterManager.data.fs || globalFilterSize;
        filter.setAttribute("x", filterSize.x || globalFilterSize.x);
        filter.setAttribute("y", filterSize.y || globalFilterSize.y);
        filter.setAttribute("width", filterSize.width || globalFilterSize.width);
        filter.setAttribute("height", filterSize.height || globalFilterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("in", "SourceAlpha");
        feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
        feGaussianBlur.setAttribute("stdDeviation", "0");
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS("feOffset");
        feOffset.setAttribute("dx", "25");
        feOffset.setAttribute("dy", "0");
        feOffset.setAttribute("in", id + "_drop_shadow_1");
        feOffset.setAttribute("result", id + "_drop_shadow_2");
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS("feFlood");
        feFlood.setAttribute("flood-color", "#00ff00");
        feFlood.setAttribute("flood-opacity", "1");
        feFlood.setAttribute("result", id + "_drop_shadow_3");
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS("feComposite");
        feComposite.setAttribute("in", id + "_drop_shadow_3");
        feComposite.setAttribute("in2", id + "_drop_shadow_2");
        feComposite.setAttribute("operator", "in");
        feComposite.setAttribute("result", id + "_drop_shadow_4");
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
      SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
          }
          if (forceRender || this.filterManager.effectElements[0].p._mdf) {
            var col = this.filterManager.effectElements[0].p.v;
            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
          }
          if (forceRender || this.filterManager.effectElements[1].p._mdf) {
            this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
          }
          if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
            var distance = this.filterManager.effectElements[3].p.v;
            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
            var x3 = distance * Math.cos(angle);
            var y3 = distance * Math.sin(angle);
            this.feOffset.setAttribute("dx", x3);
            this.feOffset.setAttribute("dy", y3);
          }
        }
      };
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(filterElem, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem2;
        elem2.matteElement = createNS("g");
        elem2.matteElement.appendChild(elem2.layerElement);
        elem2.matteElement.appendChild(elem2.transformedElement);
        elem2.baseElement = elem2.matteElement;
      }
      SVGMatte3Effect.prototype.findSymbol = function(mask2) {
        var i2 = 0;
        var len = _svgMatteSymbols.length;
        while (i2 < len) {
          if (_svgMatteSymbols[i2] === mask2) {
            return _svgMatteSymbols[i2];
          }
          i2 += 1;
        }
        return null;
      };
      SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
        var parentNode = mask2.layerElement.parentNode;
        if (!parentNode) {
          return;
        }
        var children = parentNode.children;
        var i2 = 0;
        var len = children.length;
        while (i2 < len) {
          if (children[i2] === mask2.layerElement) {
            break;
          }
          i2 += 1;
        }
        var nextChild;
        if (i2 <= len - 2) {
          nextChild = children[i2 + 1];
        }
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        if (nextChild) {
          parentNode.insertBefore(useElem, nextChild);
        } else {
          parentNode.appendChild(useElem);
        }
      };
      SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
        if (!this.findSymbol(mask2)) {
          var symbolId = createElementID();
          var masker = createNS("mask");
          masker.setAttribute("id", mask2.layerId);
          masker.setAttribute("mask-type", "alpha");
          _svgMatteSymbols.push(mask2);
          var defs = elem2.globalData.defs;
          defs.appendChild(masker);
          var symbol = createNS("symbol");
          symbol.setAttribute("id", symbolId);
          this.replaceInParent(mask2, symbolId);
          symbol.appendChild(mask2.layerElement);
          defs.appendChild(symbol);
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          masker.appendChild(useElem);
          mask2.data.hd = false;
          mask2.show();
        }
        elem2.setMatte(mask2.layerId);
      };
      SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i2 = 0;
        var len = elements.length;
        while (i2 < len) {
          if (elements[i2] && elements[i2].data.ind === ind) {
            this.setElementAsMask(this.elem, elements[i2]);
          }
          i2 += 1;
        }
        this.initialized = true;
      };
      SVGMatte3Effect.prototype.renderFrame = function() {
        if (!this.initialized) {
          this.initialize();
        }
      };
      function SVGGaussianBlurEffect(filter, filterManager, elem2, id) {
        filter.setAttribute("x", "-100%");
        filter.setAttribute("y", "-100%");
        filter.setAttribute("width", "300%");
        filter.setAttribute("height", "300%");
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("result", id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var kBlurrinessToSigma = 0.3;
          var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
          var dimensions = this.filterManager.effectElements[1].p.v;
          var sigmaX = dimensions == 3 ? 0 : sigma;
          var sigmaY = dimensions == 2 ? 0 : sigma;
          this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
          var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
        }
      };
      function TransformEffect() {
      }
      TransformEffect.prototype.init = function(effectsManager) {
        this.effectsManager = effectsManager;
        this.type = effectTypes.TRANSFORM_EFFECT;
        this.matrix = new Matrix();
        this.opacity = -1;
        this._mdf = false;
        this._opMdf = false;
      };
      TransformEffect.prototype.renderFrame = function(forceFrame) {
        this._opMdf = false;
        this._mdf = false;
        if (forceFrame || this.effectsManager._mdf) {
          var effectElements = this.effectsManager.effectElements;
          var anchor = effectElements[0].p.v;
          var position2 = effectElements[1].p.v;
          var isUniformScale = effectElements[2].p.v === 1;
          var scaleHeight = effectElements[3].p.v;
          var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
          var skew = effectElements[5].p.v;
          var skewAxis = effectElements[6].p.v;
          var rotation2 = effectElements[7].p.v;
          this.matrix.reset();
          this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
          this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
          this.matrix.rotate(-rotation2 * degToRads);
          this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
          this.matrix.translate(position2[0], position2[1], 0);
          this._mdf = true;
          if (this.opacity !== effectElements[8].p.v) {
            this.opacity = effectElements[8].p.v;
            this._opMdf = true;
          }
        }
      };
      function SVGTransformEffect(_2, filterManager) {
        this.init(filterManager);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(effectsManager) {
        this.init(effectsManager);
      }
      extendPrototype([TransformEffect], CVTransformEffect);
      registerRenderer("canvas", CanvasRenderer);
      registerRenderer("html", HybridRenderer);
      registerRenderer("svg", SVGRenderer);
      ShapeModifiers.registerModifier("tm", TrimModifier);
      ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
      ShapeModifiers.registerModifier("rp", RepeaterModifier);
      ShapeModifiers.registerModifier("rd", RoundCornersModifier);
      ShapeModifiers.registerModifier("zz", ZigZagModifier);
      ShapeModifiers.registerModifier("op", OffsetPathModifier);
      setExpressionsPlugin(Expressions);
      setExpressionInterfaces(getInterface);
      initialize$1();
      initialize();
      registerEffect$1(20, SVGTintFilter, true);
      registerEffect$1(21, SVGFillFilter, true);
      registerEffect$1(22, SVGStrokeEffect, false);
      registerEffect$1(23, SVGTritoneFilter, true);
      registerEffect$1(24, SVGProLevelsFilter, true);
      registerEffect$1(25, SVGDropShadowEffect, true);
      registerEffect$1(28, SVGMatte3Effect, false);
      registerEffect$1(29, SVGGaussianBlurEffect, true);
      registerEffect$1(35, SVGTransformEffect, false);
      registerEffect(35, CVTransformEffect);
      return lottie;
    });
  }
});

// node_modules/topojson-client/src/reverse.js
function reverse_default(array3, n2) {
  var t2, j2 = array3.length, i2 = j2 - n2;
  while (i2 < --j2) t2 = array3[i2], array3[i2++] = array3[j2], array3[j2] = t2;
}
var init_reverse = __esm({
  "node_modules/topojson-client/src/reverse.js"() {
  }
});

// node_modules/topojson-client/src/identity.js
function identity_default4(x3) {
  return x3;
}
var init_identity = __esm({
  "node_modules/topojson-client/src/identity.js"() {
  }
});

// node_modules/topojson-client/src/transform.js
function transform_default2(transform2) {
  if (transform2 == null) return identity_default4;
  var x05, y05, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
  return function(input, i2) {
    if (!i2) x05 = y05 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2);
    output[0] = (x05 += input[0]) * kx + dx;
    output[1] = (y05 += input[1]) * ky + dy;
    while (j2 < n2) output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_transform = __esm({
  "node_modules/topojson-client/src/transform.js"() {
    init_identity();
  }
});

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o2) {
  if (typeof o2 === "string") o2 = topology.objects[o2];
  return o2.type === "GeometryCollection" ? { type: "FeatureCollection", features: o2.geometries.map(function(o3) {
    return feature2(topology, o3);
  }) } : feature2(topology, o2);
}
function feature2(topology, o2) {
  var id = o2.id, bbox = o2.bbox, properties = o2.properties == null ? {} : o2.properties, geometry = object(topology, o2);
  return id == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox, properties, geometry };
}
function object(topology, o2) {
  var transformPoint = transform_default2(topology.transform), arcs = topology.arcs;
  function arc(i2, points) {
    if (points.length) points.pop();
    for (var a2 = arcs[i2 < 0 ? ~i2 : i2], k2 = 0, n2 = a2.length; k2 < n2; ++k2) {
      points.push(transformPoint(a2[k2], k2));
    }
    if (i2 < 0) reverse_default(points, n2);
  }
  function point2(p2) {
    return transformPoint(p2);
  }
  function line(arcs2) {
    var points = [];
    for (var i2 = 0, n2 = arcs2.length; i2 < n2; ++i2) arc(arcs2[i2], points);
    if (points.length < 2) points.push(points[0]);
    return points;
  }
  function ring(arcs2) {
    var points = line(arcs2);
    while (points.length < 4) points.push(points[0]);
    return points;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o3) {
    var type = o3.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o3.geometries.map(geometry) };
      case "Point":
        coordinates = point2(o3.coordinates);
        break;
      case "MultiPoint":
        coordinates = o3.coordinates.map(point2);
        break;
      case "LineString":
        coordinates = line(o3.arcs);
        break;
      case "MultiLineString":
        coordinates = o3.arcs.map(line);
        break;
      case "Polygon":
        coordinates = polygon(o3.arcs);
        break;
      case "MultiPolygon":
        coordinates = o3.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry(o2);
}
var init_feature = __esm({
  "node_modules/topojson-client/src/feature.js"() {
    init_reverse();
    init_transform();
  }
});

// node_modules/topojson-client/src/bbox.js
function bbox_default(topology) {
  var t2 = transform_default2(topology.transform), key2, x05 = Infinity, y05 = x05, x13 = -x05, y13 = -x05;
  function bboxPoint(p2) {
    p2 = t2(p2);
    if (p2[0] < x05) x05 = p2[0];
    if (p2[0] > x13) x13 = p2[0];
    if (p2[1] < y05) y05 = p2[1];
    if (p2[1] > y13) y13 = p2[1];
  }
  function bboxGeometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(bboxGeometry);
        break;
      case "Point":
        bboxPoint(o2.coordinates);
        break;
      case "MultiPoint":
        o2.coordinates.forEach(bboxPoint);
        break;
    }
  }
  topology.arcs.forEach(function(arc) {
    var i2 = -1, n2 = arc.length, p2;
    while (++i2 < n2) {
      p2 = t2(arc[i2], i2);
      if (p2[0] < x05) x05 = p2[0];
      if (p2[0] > x13) x13 = p2[0];
      if (p2[1] < y05) y05 = p2[1];
      if (p2[1] > y13) y13 = p2[1];
    }
  });
  for (key2 in topology.objects) {
    bboxGeometry(topology.objects[key2]);
  }
  return [x05, y05, x13, y13];
}
var init_bbox = __esm({
  "node_modules/topojson-client/src/bbox.js"() {
    init_transform();
  }
});

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i2, j2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], t2;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t2 = arcs[++emptyIndex], arcs[emptyIndex] = i2, arcs[j2] = t2;
    }
  });
  arcs.forEach(function(i2) {
    var e3 = ends(i2), start = e3[0], end = e3[1], f2, g3;
    if (f2 = fragmentByEnd[start]) {
      delete fragmentByEnd[f2.end];
      f2.push(i2);
      f2.end = end;
      if (g3 = fragmentByStart[end]) {
        delete fragmentByStart[g3.start];
        var fg = g3 === f2 ? f2 : f2.concat(g3);
        fragmentByStart[fg.start = f2.start] = fragmentByEnd[fg.end = g3.end] = fg;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else if (f2 = fragmentByStart[end]) {
      delete fragmentByStart[f2.start];
      f2.unshift(i2);
      f2.start = start;
      if (g3 = fragmentByEnd[start]) {
        delete fragmentByEnd[g3.end];
        var gf = g3 === f2 ? f2 : g3.concat(f2);
        fragmentByStart[gf.start = g3.start] = fragmentByEnd[gf.end = f2.end] = gf;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else {
      f2 = [i2];
      fragmentByStart[f2.start = start] = fragmentByEnd[f2.end = end] = f2;
    }
  });
  function ends(i2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });
    else p1 = arc[arc.length - 1];
    return i2 < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k2 in fragmentByEnd2) {
      var f2 = fragmentByEnd2[k2];
      delete fragmentByStart2[f2.start];
      delete f2.start;
      delete f2.end;
      f2.forEach(function(i2) {
        stitchedArcs[i2 < 0 ? ~i2 : i2] = 1;
      });
      fragments.push(f2);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i2) {
    if (!stitchedArcs[i2 < 0 ? ~i2 : i2]) fragments.push([i2]);
  });
  return fragments;
}
var init_stitch = __esm({
  "node_modules/topojson-client/src/stitch.js"() {
  }
});

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter) {
  var arcs, i2, n2;
  if (arguments.length > 1) arcs = extractArcs(topology, object2, filter);
  else for (i2 = 0, arcs = new Array(n2 = topology.arcs.length); i2 < n2; ++i2) arcs[i2] = i2;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i2) {
    var j2 = i2 < 0 ? ~i2 : i2;
    (geomsByArc[j2] || (geomsByArc[j2] = [])).push({ i: i2, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o2) {
    switch (geom = o2, o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o2.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o2.arcs);
        break;
      case "MultiPolygon":
        extract3(o2.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}
var init_mesh = __esm({
  "node_modules/topojson-client/src/mesh.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i2 = -1, n2 = ring.length, a2, b2 = ring[n2 - 1], area = 0;
  while (++i2 < n2) a2 = b2, b2 = ring[i2], area += a2[0] * b2[1] - a2[1] * b2[0];
  return Math.abs(area);
}
function merge_default2(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons = [], groups = [];
  objects.forEach(geometry);
  function geometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "Polygon":
        extract(o2.arcs);
        break;
      case "MultiPolygon":
        o2.arcs.forEach(extract);
        break;
    }
  }
  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }
  function area(ring) {
    return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [], neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
              if (!polygon2._) {
                polygon2._ = 1;
                neighbors.push(polygon2);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function(polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons2) {
      var arcs = [], n2;
      polygons2.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default(topology, arcs);
      if ((n2 = arcs.length) > 1) {
        for (var i2 = 1, k2 = area(arcs[0]), ki, t2; i2 < n2; ++i2) {
          if ((ki = area(arcs[i2])) > k2) {
            t2 = arcs[0], arcs[0] = arcs[i2], arcs[i2] = t2, k2 = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}
var init_merge = __esm({
  "node_modules/topojson-client/src/merge.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/topojson-client/src/bisect.js
function bisect_default2(a2, x3) {
  var lo = 0, hi = a2.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a2[mid] < x3) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}
var init_bisect = __esm({
  "node_modules/topojson-client/src/bisect.js"() {
  }
});

// node_modules/topojson-client/src/neighbors.js
function neighbors_default(objects) {
  var indexesByArc = {}, neighbors = objects.map(function() {
    return [];
  });
  function line(arcs, i3) {
    arcs.forEach(function(a2) {
      if (a2 < 0) a2 = ~a2;
      var o2 = indexesByArc[a2];
      if (o2) o2.push(i3);
      else indexesByArc[a2] = [i3];
    });
  }
  function polygon(arcs, i3) {
    arcs.forEach(function(arc) {
      line(arc, i3);
    });
  }
  function geometry(o2, i3) {
    if (o2.type === "GeometryCollection") o2.geometries.forEach(function(o3) {
      geometry(o3, i3);
    });
    else if (o2.type in geometryType) geometryType[o2.type](o2.arcs, i3);
  }
  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i3) {
      arcs.forEach(function(arc) {
        polygon(arc, i3);
      });
    }
  };
  objects.forEach(geometry);
  for (var i2 in indexesByArc) {
    for (var indexes = indexesByArc[i2], m2 = indexes.length, j2 = 0; j2 < m2; ++j2) {
      for (var k2 = j2 + 1; k2 < m2; ++k2) {
        var ij = indexes[j2], ik = indexes[k2], n2;
        if ((n2 = neighbors[ij])[i2 = bisect_default2(n2, ik)] !== ik) n2.splice(i2, 0, ik);
        if ((n2 = neighbors[ik])[i2 = bisect_default2(n2, ij)] !== ij) n2.splice(i2, 0, ij);
      }
    }
  }
  return neighbors;
}
var init_neighbors = __esm({
  "node_modules/topojson-client/src/neighbors.js"() {
    init_bisect();
  }
});

// node_modules/topojson-client/src/untransform.js
function untransform_default(transform2) {
  if (transform2 == null) return identity_default4;
  var x05, y05, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
  return function(input, i2) {
    if (!i2) x05 = y05 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2), x13 = Math.round((input[0] - dx) / kx), y13 = Math.round((input[1] - dy) / ky);
    output[0] = x13 - x05, x05 = x13;
    output[1] = y13 - y05, y05 = y13;
    while (j2 < n2) output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_untransform = __esm({
  "node_modules/topojson-client/src/untransform.js"() {
    init_identity();
  }
});

// node_modules/topojson-client/src/quantize.js
function quantize_default(topology, transform2) {
  if (topology.transform) throw new Error("already quantized");
  if (!transform2 || !transform2.scale) {
    if (!((n2 = Math.floor(transform2)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || bbox_default(topology);
    var x05 = box[0], y05 = box[1], x13 = box[2], y13 = box[3], n2;
    transform2 = { scale: [x13 - x05 ? (x13 - x05) / (n2 - 1) : 1, y13 - y05 ? (y13 - y05) / (n2 - 1) : 1], translate: [x05, y05] };
  } else {
    box = topology.bbox;
  }
  var t2 = untransform_default(transform2), box, key2, inputs = topology.objects, outputs = {};
  function quantizePoint(point2) {
    return t2(point2);
  }
  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection":
        output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
        break;
      case "MultiPoint":
        output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
        break;
      default:
        return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }
  function quantizeArc(input) {
    var i2 = 0, j2 = 1, n3 = input.length, p2, output = new Array(n3);
    output[0] = t2(input[0], 0);
    while (++i2 < n3) if ((p2 = t2(input[i2], i2))[0] || p2[1]) output[j2++] = p2;
    if (j2 === 1) output[j2++] = [0, 0];
    output.length = j2;
    return output;
  }
  for (key2 in inputs) outputs[key2] = quantizeGeometry(inputs[key2]);
  return {
    type: "Topology",
    bbox: box,
    transform: transform2,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}
var init_quantize = __esm({
  "node_modules/topojson-client/src/quantize.js"() {
    init_bbox();
    init_untransform();
  }
});

// node_modules/topojson-client/src/index.js
var src_exports = {};
__export(src_exports, {
  bbox: () => bbox_default,
  feature: () => feature_default,
  merge: () => merge_default2,
  mergeArcs: () => mergeArcs,
  mesh: () => mesh_default,
  meshArcs: () => meshArcs,
  neighbors: () => neighbors_default,
  quantize: () => quantize_default,
  transform: () => transform_default2,
  untransform: () => untransform_default
});
var init_src = __esm({
  "node_modules/topojson-client/src/index.js"() {
    init_bbox();
    init_feature();
    init_mesh();
    init_merge();
    init_neighbors();
    init_quantize();
    init_transform();
    init_untransform();
  }
});

// node_modules/topojson-server/src/object.js
var hasOwnProperty3;
var init_object = __esm({
  "node_modules/topojson-server/src/object.js"() {
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
  }
});

// node_modules/topojson-server/src/bounds.js
function bounds_default3(objects) {
  var x05 = Infinity, y05 = Infinity, x13 = -Infinity, y13 = -Infinity;
  function boundGeometry(geometry) {
    if (geometry != null && hasOwnProperty3.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
  }
  var boundGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(boundGeometry);
    },
    Point: function(o2) {
      boundPoint(o2.coordinates);
    },
    MultiPoint: function(o2) {
      o2.coordinates.forEach(boundPoint);
    },
    LineString: function(o2) {
      boundLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs.forEach(boundLine);
    },
    Polygon: function(o2) {
      o2.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o2) {
      o2.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    if (x3 < x05) x05 = x3;
    if (x3 > x13) x13 = x3;
    if (y3 < y05) y05 = y3;
    if (y3 > y13) y13 = y3;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key2 in objects) {
    boundGeometry(objects[key2]);
  }
  return x13 >= x05 && y13 >= y05 ? [x05, y05, x13, y13] : void 0;
}
var init_bounds = __esm({
  "node_modules/topojson-server/src/bounds.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/hash/hashset.js
function hashset_default(size, hash, equal, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask2 = size - 1;
  for (var i2 = 0; i2 < size; ++i2) {
    store[i2] = empty;
  }
  function add3(value2) {
    var index2 = hash(value2) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal(match, value2)) return true;
      if (++collisions >= size) throw new Error("full hashset");
      match = store[index2 = index2 + 1 & mask2];
    }
    store[index2] = value2;
    return true;
  }
  function has2(value2) {
    var index2 = hash(value2) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal(match, value2)) return true;
      if (++collisions >= size) break;
      match = store[index2 = index2 + 1 & mask2];
    }
    return false;
  }
  function values() {
    var values2 = [];
    for (var i3 = 0, n2 = store.length; i3 < n2; ++i3) {
      var match = store[i3];
      if (match != empty) values2.push(match);
    }
    return values2;
  }
  return {
    add: add3,
    has: has2,
    values
  };
}
var init_hashset = __esm({
  "node_modules/topojson-server/src/hash/hashset.js"() {
  }
});

// node_modules/topojson-server/src/hash/hashmap.js
function hashmap_default(size, hash, equal, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask2 = size - 1;
  for (var i2 = 0; i2 < size; ++i2) {
    keystore[i2] = keyEmpty;
  }
  function set(key2, value2) {
    var index2 = hash(key2) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key2)) return valstore[index2] = value2;
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key2;
    valstore[index2] = value2;
    return value2;
  }
  function maybeSet(key2, value2) {
    var index2 = hash(key2) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key2)) return valstore[index2];
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key2;
    valstore[index2] = value2;
    return value2;
  }
  function get2(key2, missingValue) {
    var index2 = hash(key2) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key2)) return valstore[index2];
      if (++collisions >= size) break;
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    return missingValue;
  }
  function keys2() {
    var keys3 = [];
    for (var i3 = 0, n2 = keystore.length; i3 < n2; ++i3) {
      var matchKey = keystore[i3];
      if (matchKey != keyEmpty) keys3.push(matchKey);
    }
    return keys3;
  }
  return {
    set,
    maybeSet,
    // set if unset
    get: get2,
    keys: keys2
  };
}
var init_hashmap = __esm({
  "node_modules/topojson-server/src/hash/hashmap.js"() {
  }
});

// node_modules/topojson-server/src/hash/point-equal.js
function point_equal_default(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}
var init_point_equal = __esm({
  "node_modules/topojson-server/src/hash/point-equal.js"() {
  }
});

// node_modules/topojson-server/src/hash/point-hash.js
function point_hash_default(point2) {
  floats[0] = point2[0];
  floats[1] = point2[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}
var buffer, floats, uints;
var init_point_hash = __esm({
  "node_modules/topojson-server/src/hash/point-hash.js"() {
    buffer = new ArrayBuffer(16);
    floats = new Float64Array(buffer);
    uints = new Uint32Array(buffer);
  }
});

// node_modules/topojson-server/src/join.js
function join_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index2(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i2, n2, previousIndex, currentIndex, nextIndex;
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    visitedByIndex[i2] = leftByIndex[i2] = rightByIndex[i2] = -1;
  }
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    var line = lines[i2], lineStart = line[0], lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i2, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    visitedByIndex[i2] = -1;
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    var ring = rings[i2], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i2, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i2, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i3, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i3) return;
    visitedByIndex[currentIndex2] = i3;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index2() {
    var indexByPoint = hashmap_default(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i3 = 0, n3 = coordinates.length; i3 < n3; ++i3) {
      indexes2[i3] = indexByPoint.maybeSet(i3, i3);
    }
    return indexes2;
  }
  function hashIndex(i3) {
    return point_hash_default(coordinates[i3]);
  }
  function equalIndex(i3, j3) {
    return point_equal_default(coordinates[i3], coordinates[j3]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset_default(junctionCount * 1.4, point_hash_default, point_equal_default), j2;
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    if (junctionByIndex[j2 = indexes[i2]]) {
      junctionByPoint.add(coordinates[j2]);
    }
  }
  return junctionByPoint;
}
var init_join = __esm({
  "node_modules/topojson-server/src/join.js"() {
    init_hashset();
    init_hashmap();
    init_point_equal();
    init_point_hash();
  }
});

// node_modules/topojson-server/src/cut.js
function cut_default(topology) {
  var junctions = join_default(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next, i2, n2;
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    var line = lines[i2], lineMid = line[0], lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next = { 0: lineMid, 1: line[1] };
        line[1] = lineMid;
        line = line.next = next;
      }
    }
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    var ring = rings[i2], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology;
}
function rotateArray(array3, start, end, offset) {
  reverse(array3, start, end);
  reverse(array3, start, start + offset);
  reverse(array3, start + offset, end);
}
function reverse(array3, start, end) {
  for (var mid = start + (end-- - start >> 1), t2; start < mid; ++start, --end) {
    t2 = array3[start], array3[start] = array3[end], array3[end] = t2;
  }
}
var init_cut = __esm({
  "node_modules/topojson-server/src/cut.js"() {
    init_join();
  }
});

// node_modules/topojson-server/src/dedup.js
function dedup_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, line, rings = topology.rings, ring, arcCount = lines.length + rings.length, i2, n2;
  delete topology.lines;
  delete topology.rings;
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    line = lines[i2];
    while (line = line.next) ++arcCount;
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    ring = rings[i2];
    while (ring = ring.next) ++arcCount;
  }
  var arcsByEnd = hashmap_default(arcCount * 2 * 1.4, point_hash_default, point_equal_default), arcs = topology.arcs = [];
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    line = lines[i2];
    do {
      dedupLine(line);
    } while (line = line.next);
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    ring = rings[i2];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i3, n3;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i3 = 0, n3 = startArcs.length; i3 < n3; ++i3) {
        startArc = startArcs[i3];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs) startArcs.push(arc);
    else arcsByEnd.set(startPoint, [arc]);
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i3, n3;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, ++ib) if (!point_equal_default(coordinates[ia], coordinates[ib])) return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, --jb) if (!point_equal_default(coordinates[ia], coordinates[jb])) return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n3 = ja - ia;
    if (n3 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i3 = 0; i3 < n3; ++i3) {
      if (!point_equal_default(coordinates[ia + (i3 + ka) % n3], coordinates[ib + (i3 + kb) % n3])) return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n3 = ja - ia;
    if (n3 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = n3 - findMinimumOffset(arcB);
    for (var i3 = 0; i3 < n3; ++i3) {
      if (!point_equal_default(coordinates[ia + (i3 + ka) % n3], coordinates[jb - (i3 + kb) % n3])) return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point2 = coordinates[mid];
      if (point2[0] < minimumPoint[0] || point2[0] === minimumPoint[0] && point2[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point2;
      }
    }
    return minimum - start;
  }
  return topology;
}
var init_dedup = __esm({
  "node_modules/topojson-server/src/dedup.js"() {
    init_hashmap();
    init_point_equal();
    init_point_hash();
  }
});

// node_modules/topojson-server/src/delta.js
function delta_default(arcs) {
  var i2 = -1, n2 = arcs.length;
  while (++i2 < n2) {
    var arc = arcs[i2], j2 = 0, k2 = 1, m2 = arc.length, point2 = arc[0], x05 = point2[0], y05 = point2[1], x13, y13;
    while (++j2 < m2) {
      point2 = arc[j2], x13 = point2[0], y13 = point2[1];
      if (x13 !== x05 || y13 !== y05) arc[k2++] = [x13 - x05, y13 - y05], x05 = x13, y05 = y13;
    }
    if (k2 === 1) arc[k2++] = [0, 0];
    arc.length = k2;
  }
  return arcs;
}
var init_delta = __esm({
  "node_modules/topojson-server/src/delta.js"() {
  }
});

// node_modules/topojson-server/src/extract.js
function extract_default(objects) {
  var index2 = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry(geometry) {
    if (geometry && hasOwnProperty3.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
  }
  var extractGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(extractGeometry);
    },
    LineString: function(o2) {
      o2.arcs = extractLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(extractLine);
    },
    Polygon: function(o2) {
      o2.arcs = o2.arcs.map(extractRing);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line) {
    for (var i2 = 0, n2 = line.length; i2 < n2; ++i2) coordinates[++index2] = line[i2];
    var arc = { 0: index2 - n2 + 1, 1: index2 };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i2 = 0, n2 = ring.length; i2 < n2; ++i2) coordinates[++index2] = ring[i2];
    var arc = { 0: index2 - n2 + 1, 1: index2 };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key2 in objects) {
    extractGeometry(objects[key2]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}
var init_extract = __esm({
  "node_modules/topojson-server/src/extract.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/geometry.js
function geometry_default(inputs) {
  var outputs = {}, key2;
  for (key2 in inputs) outputs[key2] = geomifyObject(inputs[key2]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key2;
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  for (key2 in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null) return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
var init_geometry = __esm({
  "node_modules/topojson-server/src/geometry.js"() {
  }
});

// node_modules/topojson-server/src/prequantize.js
function prequantize_default(objects, bbox, n2) {
  var x05 = bbox[0], y05 = bbox[1], x13 = bbox[2], y13 = bbox[3], kx = x13 - x05 ? (n2 - 1) / (x13 - x05) : 1, ky = y13 - y05 ? (n2 - 1) / (y13 - y05) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x05) * kx), Math.round((input[1] - y05) * ky)];
  }
  function quantizePoints(input, m2) {
    var i2 = -1, j2 = 0, n3 = input.length, output = new Array(n3), pi4, px, py, x3, y3;
    while (++i2 < n3) {
      pi4 = input[i2];
      x3 = Math.round((pi4[0] - x05) * kx);
      y3 = Math.round((pi4[1] - y05) * ky);
      if (x3 !== px || y3 !== py) output[j2++] = [px = x3, py = y3];
    }
    output.length = j2;
    while (j2 < m2) j2 = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o2) {
    if (o2 != null && hasOwnProperty3.call(quantizeGeometryType, o2.type)) quantizeGeometryType[o2.type](o2);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(quantizeGeometry);
    },
    Point: function(o2) {
      o2.coordinates = quantizePoint(o2.coordinates);
    },
    MultiPoint: function(o2) {
      o2.coordinates = o2.coordinates.map(quantizePoint);
    },
    LineString: function(o2) {
      o2.arcs = quantizeLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(quantizeLine);
    },
    Polygon: function(o2) {
      o2.arcs = quantizePolygon(o2.arcs);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(quantizePolygon);
    }
  };
  for (var key2 in objects) {
    quantizeGeometry(objects[key2]);
  }
  return {
    scale: [1 / kx, 1 / ky],
    translate: [x05, y05]
  };
}
var init_prequantize = __esm({
  "node_modules/topojson-server/src/prequantize.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/topology.js
function topology_default(objects, quantization) {
  var bbox = bounds_default3(objects = geometry_default(objects)), transform2 = quantization > 0 && bbox && prequantize_default(objects, bbox, quantization), topology = dedup_default(cut_default(extract_default(objects))), coordinates = topology.coordinates, indexByArc = hashmap_default(topology.arcs.length * 1.4, hashArc, equalArc);
  objects = topology.objects;
  topology.bbox = bbox;
  topology.arcs = topology.arcs.map(function(arc, i2) {
    indexByArc.set(arc, i2);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology.coordinates;
  coordinates = null;
  function indexGeometry(geometry) {
    if (geometry && hasOwnProperty3.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
  }
  var indexGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(indexGeometry);
    },
    LineString: function(o2) {
      o2.arcs = indexArcs(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(indexArcs);
    },
    Polygon: function(o2) {
      o2.arcs = o2.arcs.map(indexArcs);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index2 = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index2 : ~index2);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key2 in objects) {
    indexGeometry(objects[key2]);
  }
  if (transform2) {
    topology.transform = transform2;
    topology.arcs = delta_default(topology.arcs);
  }
  return topology;
}
function hashArc(arc) {
  var i2 = arc[0], j2 = arc[1], t2;
  if (j2 < i2) t2 = i2, i2 = j2, j2 = t2;
  return i2 + 31 * j2;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t2;
  if (ja < ia) t2 = ia, ia = ja, ja = t2;
  if (jb < ib) t2 = ib, ib = jb, jb = t2;
  return ia === ib && ja === jb;
}
var init_topology = __esm({
  "node_modules/topojson-server/src/topology.js"() {
    init_bounds();
    init_cut();
    init_dedup();
    init_delta();
    init_extract();
    init_geometry();
    init_hashmap();
    init_object();
    init_prequantize();
  }
});

// node_modules/topojson-server/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  topology: () => topology_default
});
var init_src2 = __esm({
  "node_modules/topojson-server/src/index.js"() {
    init_topology();
  }
});

// node_modules/geojson-linestring-dissolve/index.js
var require_geojson_linestring_dissolve = __commonJS({
  "node_modules/geojson-linestring-dissolve/index.js"(exports2, module2) {
    module2.exports = mergeViableLineStrings;
    function coordId(coord) {
      return coord[0].toString() + "," + coord[1].toString();
    }
    function mergeLineStrings(a2, b2) {
      var s1 = coordId(a2.coordinates[0]);
      var e1 = coordId(a2.coordinates[a2.coordinates.length - 1]);
      var s2 = coordId(b2.coordinates[0]);
      var e23 = coordId(b2.coordinates[b2.coordinates.length - 1]);
      var coords;
      if (s1 === e23) {
        coords = b2.coordinates.concat(a2.coordinates.slice(1));
      } else if (s2 === e1) {
        coords = a2.coordinates.concat(b2.coordinates.slice(1));
      } else if (s1 === s2) {
        coords = a2.coordinates.slice(1).reverse().concat(b2.coordinates);
      } else if (e1 === e23) {
        coords = a2.coordinates.concat(b2.coordinates.reverse().slice(1));
      } else {
        return null;
      }
      return {
        type: "LineString",
        coordinates: coords
      };
    }
    function mergeViableLineStrings(geoms) {
      var lineStrings = geoms.slice();
      var result = [];
      while (lineStrings.length > 0) {
        var ls = lineStrings.shift();
        lineStrings = lineStrings.reduce(function(accum, cur) {
          var merged = mergeLineStrings(ls, cur);
          if (merged) {
            ls = merged;
          } else {
            accum.push(cur);
          }
          return accum;
        }, []);
        result.push(ls);
      }
      if (result.length === 1) {
        result = result[0];
      } else {
        result = {
          type: "MultiLineString",
          coordinates: result.map(function(ls2) {
            return ls2.coordinates;
          })
        };
      }
      return result;
    }
  }
});

// node_modules/geojson-dissolve/node_modules/@turf/meta/index.js
var require_meta = __commonJS({
  "node_modules/geojson-dissolve/node_modules/@turf/meta/index.js"(exports2, module2) {
    function coordEach(layer, callback, excludeWrapCoord) {
      var i2, j2, k2, g3, l2, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, currentIndex = 0, isGeometryCollection, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
      for (i2 = 0; i2 < stop; i2++) {
        geometryMaybeCollection = isFeatureCollection ? layer.features[i2].geometry : isFeature ? layer.geometry : layer;
        isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g3 = 0; g3 < stopG; g3++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
          coords = geometry.coordinates;
          wrapShrink = excludeWrapCoord && (geometry.type === "Polygon" || geometry.type === "MultiPolygon") ? 1 : 0;
          if (geometry.type === "Point") {
            callback(coords, currentIndex);
            currentIndex++;
          } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
            for (j2 = 0; j2 < coords.length; j2++) {
              callback(coords[j2], currentIndex);
              currentIndex++;
            }
          } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
            for (j2 = 0; j2 < coords.length; j2++)
              for (k2 = 0; k2 < coords[j2].length - wrapShrink; k2++) {
                callback(coords[j2][k2], currentIndex);
                currentIndex++;
              }
          } else if (geometry.type === "MultiPolygon") {
            for (j2 = 0; j2 < coords.length; j2++)
              for (k2 = 0; k2 < coords[j2].length; k2++)
                for (l2 = 0; l2 < coords[j2][k2].length - wrapShrink; l2++) {
                  callback(coords[j2][k2][l2], currentIndex);
                  currentIndex++;
                }
          } else if (geometry.type === "GeometryCollection") {
            for (j2 = 0; j2 < geometry.geometries.length; j2++)
              coordEach(geometry.geometries[j2], callback, excludeWrapCoord);
          } else {
            throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    module2.exports.coordEach = coordEach;
    function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(layer, function(currentCoords, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentCoords;
        } else {
          previousValue = callback(previousValue, currentCoords, currentIndex);
        }
      }, excludeWrapCoord);
      return previousValue;
    }
    module2.exports.coordReduce = coordReduce;
    function propEach(layer, callback) {
      var i2;
      switch (layer.type) {
        case "FeatureCollection":
          for (i2 = 0; i2 < layer.features.length; i2++) {
            callback(layer.features[i2].properties, i2);
          }
          break;
        case "Feature":
          callback(layer.properties, 0);
          break;
      }
    }
    module2.exports.propEach = propEach;
    function propReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      propEach(layer, function(currentProperties, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentProperties;
        } else {
          previousValue = callback(previousValue, currentProperties, currentIndex);
        }
      });
      return previousValue;
    }
    module2.exports.propReduce = propReduce;
    function featureEach2(layer, callback) {
      if (layer.type === "Feature") {
        callback(layer, 0);
      } else if (layer.type === "FeatureCollection") {
        for (var i2 = 0; i2 < layer.features.length; i2++) {
          callback(layer.features[i2], i2);
        }
      }
    }
    module2.exports.featureEach = featureEach2;
    function featureReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      featureEach2(layer, function(currentFeature, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentFeature;
        } else {
          previousValue = callback(previousValue, currentFeature, currentIndex);
        }
      });
      return previousValue;
    }
    module2.exports.featureReduce = featureReduce;
    function coordAll(layer) {
      var coords = [];
      coordEach(layer, function(coord) {
        coords.push(coord);
      });
      return coords;
    }
    module2.exports.coordAll = coordAll;
    function geomEach2(layer, callback) {
      var i2, j2, g3, geometry, stopG, geometryMaybeCollection, isGeometryCollection, currentIndex = 0, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
      for (i2 = 0; i2 < stop; i2++) {
        geometryMaybeCollection = isFeatureCollection ? layer.features[i2].geometry : isFeature ? layer.geometry : layer;
        isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g3 = 0; g3 < stopG; g3++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
          if (geometry.type === "Point" || geometry.type === "LineString" || geometry.type === "MultiPoint" || geometry.type === "Polygon" || geometry.type === "MultiLineString" || geometry.type === "MultiPolygon") {
            callback(geometry, currentIndex);
            currentIndex++;
          } else if (geometry.type === "GeometryCollection") {
            for (j2 = 0; j2 < geometry.geometries.length; j2++) {
              callback(geometry.geometries[j2], currentIndex);
              currentIndex++;
            }
          } else {
            throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    module2.exports.geomEach = geomEach2;
    function geomReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      geomEach2(layer, function(currentGeometry, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentGeometry;
        } else {
          previousValue = callback(previousValue, currentGeometry, currentIndex);
        }
      });
      return previousValue;
    }
    module2.exports.geomReduce = geomReduce;
  }
});

// node_modules/geojson-flatten/dist/index.js
var require_dist = __commonJS({
  "node_modules/geojson-flatten/dist/index.js"(exports2, module2) {
    module2.exports = function e3(t2) {
      switch (t2 && t2.type || null) {
        case "FeatureCollection":
          return t2.features = t2.features.reduce(function(t3, r2) {
            return t3.concat(e3(r2));
          }, []), t2;
        case "Feature":
          return t2.geometry ? e3(t2.geometry).map(function(e4) {
            var r2 = { type: "Feature", properties: JSON.parse(JSON.stringify(t2.properties)), geometry: e4 };
            return void 0 !== t2.id && (r2.id = t2.id), r2;
          }) : t2;
        case "MultiPoint":
          return t2.coordinates.map(function(e4) {
            return { type: "Point", coordinates: e4 };
          });
        case "MultiPolygon":
          return t2.coordinates.map(function(e4) {
            return { type: "Polygon", coordinates: e4 };
          });
        case "MultiLineString":
          return t2.coordinates.map(function(e4) {
            return { type: "LineString", coordinates: e4 };
          });
        case "GeometryCollection":
          return t2.geometries.map(e3).reduce(function(e4, t3) {
            return e4.concat(t3);
          }, []);
        case "Point":
        case "Polygon":
        case "LineString":
          return [t2];
      }
    };
  }
});

// node_modules/geojson-dissolve/index.js
var require_geojson_dissolve = __commonJS({
  "node_modules/geojson-dissolve/index.js"(exports2, module2) {
    var createTopology = (init_src2(), __toCommonJS(src_exports2)).topology;
    var mergeTopology = (init_src(), __toCommonJS(src_exports)).merge;
    var dissolveLineStrings = require_geojson_linestring_dissolve();
    var geomEach2 = require_meta().geomEach;
    var flatten2 = require_dist();
    module2.exports = dissolve;
    function toArray(args) {
      if (!args.length) return [];
      return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args);
    }
    function dissolvePolygons(geoms) {
      var objects = {
        geoms: {
          type: "GeometryCollection",
          geometries: JSON.parse(JSON.stringify(geoms))
        }
      };
      var topo = createTopology(objects);
      return mergeTopology(topo, topo.objects.geoms.geometries);
    }
    function getHomogenousType(geoms) {
      var type = null;
      for (var i2 = 0; i2 < geoms.length; i2++) {
        if (!type) {
          type = geoms[i2].type;
        } else if (type !== geoms[i2].type) {
          return null;
        }
      }
      return type;
    }
    function dissolve() {
      var objects = toArray(arguments);
      var geoms = objects.reduce(function(acc, o2) {
        var flat = flatten2(o2);
        if (!Array.isArray(flat)) flat = [flat];
        for (var i2 = 0; i2 < flat.length; i2++) {
          geomEach2(flat[i2], function(geom) {
            acc.push(geom);
          });
        }
        return acc;
      }, []);
      var type = getHomogenousType(geoms);
      if (!type) {
        throw new Error("List does not contain only homoegenous GeoJSON");
      }
      switch (type) {
        case "LineString":
          return dissolveLineStrings(geoms);
        case "Polygon":
          return dissolvePolygons(geoms);
        default:
          return geoms;
      }
    }
  }
});

// node_modules/simplify-geometry/lib/line.js
var require_line = __commonJS({
  "node_modules/simplify-geometry/lib/line.js"(exports2, module2) {
    var Line = function(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
    };
    Line.prototype.rise = function() {
      return this.p2[1] - this.p1[1];
    };
    Line.prototype.run = function() {
      return this.p2[0] - this.p1[0];
    };
    Line.prototype.slope = function() {
      return this.rise() / this.run();
    };
    Line.prototype.yIntercept = function() {
      return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
    };
    Line.prototype.isVertical = function() {
      return !isFinite(this.slope());
    };
    Line.prototype.isHorizontal = function() {
      return this.p1[1] == this.p2[1];
    };
    Line.prototype._perpendicularDistanceHorizontal = function(point2) {
      return Math.abs(this.p1[1] - point2[1]);
    };
    Line.prototype._perpendicularDistanceVertical = function(point2) {
      return Math.abs(this.p1[0] - point2[0]);
    };
    Line.prototype._perpendicularDistanceHasSlope = function(point2) {
      var slope = this.slope();
      var y_intercept = this.yIntercept();
      return Math.abs(slope * point2[0] - point2[1] + y_intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
    };
    Line.prototype.perpendicularDistance = function(point2) {
      if (this.isVertical()) {
        return this._perpendicularDistanceVertical(point2);
      } else if (this.isHorizontal()) {
        return this._perpendicularDistanceHorizontal(point2);
      } else {
        return this._perpendicularDistanceHasSlope(point2);
      }
    };
    module2.exports = Line;
  }
});

// node_modules/simplify-geometry/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/simplify-geometry/lib/index.js"(exports2, module2) {
    var Line = require_line();
    var simplifyGeometry = function(points, tolerance) {
      var dmax = 0;
      var index2 = 0;
      for (var i2 = 1; i2 <= points.length - 2; i2++) {
        var d2 = new Line(points[0], points[points.length - 1]).perpendicularDistance(points[i2]);
        if (d2 > dmax) {
          index2 = i2;
          dmax = d2;
        }
      }
      if (dmax > tolerance) {
        var results_one = simplifyGeometry(points.slice(0, index2), tolerance);
        var results_two = simplifyGeometry(points.slice(index2, points.length), tolerance);
        var results = results_one.concat(results_two);
      } else if (points.length > 1) {
        results = [points[0], points[points.length - 1]];
      } else {
        results = [points[0]];
      }
      return results;
    };
    module2.exports = simplifyGeometry;
  }
});

// node_modules/simplify-geojson/index.js
var require_simplify_geojson = __commonJS({
  "node_modules/simplify-geojson/index.js"(exports2, module2) {
    var simplify = require_lib3();
    module2.exports = function(geojson, tolerance, dontClone) {
      if (!dontClone) geojson = JSON.parse(JSON.stringify(geojson));
      if (geojson.features) return simplifyFeatureCollection(geojson, tolerance);
      else if (geojson.type && geojson.type === "Feature") return simplifyFeature(geojson, tolerance);
      else return new Error("FeatureCollection or individual Feature required");
    };
    module2.exports.simplify = function(coordinates, tolerance) {
      return simplify(coordinates, tolerance);
    };
    function simplifyFeature(feat, tolerance) {
      var geom = feat.geometry;
      var type = geom.type;
      if (type === "LineString") {
        geom.coordinates = module2.exports.simplify(geom.coordinates, tolerance);
      } else if (type === "Polygon" || type === "MultiLineString") {
        for (var j2 = 0; j2 < geom.coordinates.length; j2++) {
          geom.coordinates[j2] = module2.exports.simplify(geom.coordinates[j2], tolerance);
        }
      } else if (type === "MultiPolygon") {
        for (var k2 = 0; k2 < geom.coordinates.length; k2++) {
          for (var l2 = 0; l2 < geom.coordinates[k2].length; l2++) {
            geom.coordinates[k2][l2] = module2.exports.simplify(geom.coordinates[k2][l2], tolerance);
          }
        }
      }
      return feat;
    }
    function simplifyFeatureCollection(fc, tolerance) {
      for (var i2 = 0; i2 < fc.features.length; i2++) {
        fc.features[i2] = simplifyFeature(fc.features[i2], tolerance);
      }
      return fc;
    }
  }
});

// node_modules/geobuf/encode.js
var require_encode = __commonJS({
  "node_modules/geobuf/encode.js"(exports2, module2) {
    "use strict";
    module2.exports = encode;
    var keys2;
    var keysNum;
    var keysArr;
    var dim;
    var e3;
    var maxPrecision = 1e6;
    var geometryTypes = {
      "Point": 0,
      "MultiPoint": 1,
      "LineString": 2,
      "MultiLineString": 3,
      "Polygon": 4,
      "MultiPolygon": 5,
      "GeometryCollection": 6
    };
    function encode(obj, pbf) {
      keys2 = {};
      keysArr = [];
      keysNum = 0;
      dim = 0;
      e3 = 1;
      analyze(obj);
      e3 = Math.min(e3, maxPrecision);
      var precision = Math.ceil(Math.log(e3) / Math.LN10);
      for (var i2 = 0; i2 < keysArr.length; i2++) pbf.writeStringField(1, keysArr[i2]);
      if (dim !== 2) pbf.writeVarintField(2, dim);
      if (precision !== 6) pbf.writeVarintField(3, precision);
      if (obj.type === "FeatureCollection") pbf.writeMessage(4, writeFeatureCollection, obj);
      else if (obj.type === "Feature") pbf.writeMessage(5, writeFeature, obj);
      else pbf.writeMessage(6, writeGeometry, obj);
      keys2 = null;
      return pbf.finish();
    }
    function analyze(obj) {
      var i2, key2;
      if (obj.type === "FeatureCollection") {
        for (i2 = 0; i2 < obj.features.length; i2++) analyze(obj.features[i2]);
      } else if (obj.type === "Feature") {
        if (obj.geometry !== null) analyze(obj.geometry);
        for (key2 in obj.properties) saveKey(key2);
      } else if (obj.type === "Point") analyzePoint(obj.coordinates);
      else if (obj.type === "MultiPoint") analyzePoints(obj.coordinates);
      else if (obj.type === "GeometryCollection") {
        for (i2 = 0; i2 < obj.geometries.length; i2++) analyze(obj.geometries[i2]);
      } else if (obj.type === "LineString") analyzePoints(obj.coordinates);
      else if (obj.type === "Polygon" || obj.type === "MultiLineString") analyzeMultiLine(obj.coordinates);
      else if (obj.type === "MultiPolygon") {
        for (i2 = 0; i2 < obj.coordinates.length; i2++) analyzeMultiLine(obj.coordinates[i2]);
      }
      for (key2 in obj) {
        if (!isSpecialKey(key2, obj.type)) saveKey(key2);
      }
    }
    function analyzeMultiLine(coords) {
      for (var i2 = 0; i2 < coords.length; i2++) analyzePoints(coords[i2]);
    }
    function analyzePoints(coords) {
      for (var i2 = 0; i2 < coords.length; i2++) analyzePoint(coords[i2]);
    }
    function analyzePoint(point2) {
      dim = Math.max(dim, point2.length);
      for (var i2 = 0; i2 < point2.length; i2++) {
        while (Math.round(point2[i2] * e3) / e3 !== point2[i2] && e3 < maxPrecision) e3 *= 10;
      }
    }
    function saveKey(key2) {
      if (keys2[key2] === void 0) {
        keysArr.push(key2);
        keys2[key2] = keysNum++;
      }
    }
    function writeFeatureCollection(obj, pbf) {
      for (var i2 = 0; i2 < obj.features.length; i2++) {
        pbf.writeMessage(1, writeFeature, obj.features[i2]);
      }
      writeProps(obj, pbf, true);
    }
    function writeFeature(feature3, pbf) {
      if (feature3.geometry !== null) pbf.writeMessage(1, writeGeometry, feature3.geometry);
      if (feature3.id !== void 0) {
        if (typeof feature3.id === "number" && feature3.id % 1 === 0) pbf.writeSVarintField(12, feature3.id);
        else pbf.writeStringField(11, feature3.id);
      }
      if (feature3.properties) writeProps(feature3.properties, pbf);
      writeProps(feature3, pbf, true);
    }
    function writeGeometry(geom, pbf) {
      pbf.writeVarintField(1, geometryTypes[geom.type]);
      var coords = geom.coordinates;
      if (geom.type === "Point") writePoint(coords, pbf);
      else if (geom.type === "MultiPoint") writeLine(coords, pbf, true);
      else if (geom.type === "LineString") writeLine(coords, pbf);
      else if (geom.type === "MultiLineString") writeMultiLine(coords, pbf);
      else if (geom.type === "Polygon") writeMultiLine(coords, pbf, true);
      else if (geom.type === "MultiPolygon") writeMultiPolygon(coords, pbf);
      else if (geom.type === "GeometryCollection") {
        for (var i2 = 0; i2 < geom.geometries.length; i2++) pbf.writeMessage(4, writeGeometry, geom.geometries[i2]);
      }
      writeProps(geom, pbf, true);
    }
    function writeProps(props, pbf, isCustom) {
      var indexes = [], valueIndex = 0;
      for (var key2 in props) {
        if (isCustom && isSpecialKey(key2, props.type)) {
          continue;
        }
        pbf.writeMessage(13, writeValue, props[key2]);
        indexes.push(keys2[key2]);
        indexes.push(valueIndex++);
      }
      pbf.writePackedVarint(isCustom ? 15 : 14, indexes);
    }
    function writeValue(value2, pbf) {
      if (value2 === null) return;
      var type = typeof value2;
      if (type === "string") pbf.writeStringField(1, value2);
      else if (type === "boolean") pbf.writeBooleanField(5, value2);
      else if (type === "object") pbf.writeStringField(6, JSON.stringify(value2));
      else if (type === "number") {
        if (value2 % 1 !== 0) pbf.writeDoubleField(2, value2);
        else if (value2 >= 0) pbf.writeVarintField(3, value2);
        else pbf.writeVarintField(4, -value2);
      }
    }
    function writePoint(point2, pbf) {
      var coords = [];
      for (var i2 = 0; i2 < dim; i2++) coords.push(Math.round(point2[i2] * e3));
      pbf.writePackedSVarint(3, coords);
    }
    function writeLine(line, pbf) {
      var coords = [];
      populateLine(coords, line);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiLine(lines, pbf, closed) {
      var len = lines.length, i2;
      if (len !== 1) {
        var lengths = [];
        for (i2 = 0; i2 < len; i2++) lengths.push(lines[i2].length - (closed ? 1 : 0));
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i2 = 0; i2 < len; i2++) populateLine(coords, lines[i2], closed);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiPolygon(polygons, pbf) {
      var len = polygons.length, i2, j2;
      if (len !== 1 || polygons[0].length !== 1) {
        var lengths = [len];
        for (i2 = 0; i2 < len; i2++) {
          lengths.push(polygons[i2].length);
          for (j2 = 0; j2 < polygons[i2].length; j2++) lengths.push(polygons[i2][j2].length - 1);
        }
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i2 = 0; i2 < len; i2++) {
        for (j2 = 0; j2 < polygons[i2].length; j2++) populateLine(coords, polygons[i2][j2], true);
      }
      pbf.writePackedSVarint(3, coords);
    }
    function populateLine(coords, line, closed) {
      var i2, j2, len = line.length - (closed ? 1 : 0), sum4 = new Array(dim);
      for (j2 = 0; j2 < dim; j2++) sum4[j2] = 0;
      for (i2 = 0; i2 < len; i2++) {
        for (j2 = 0; j2 < dim; j2++) {
          var n2 = Math.round(line[i2][j2] * e3) - sum4[j2];
          coords.push(n2);
          sum4[j2] += n2;
        }
      }
    }
    function isSpecialKey(key2, type) {
      if (key2 === "type") return true;
      else if (type === "FeatureCollection") {
        if (key2 === "features") return true;
      } else if (type === "Feature") {
        if (key2 === "id" || key2 === "properties" || key2 === "geometry") return true;
      } else if (type === "GeometryCollection") {
        if (key2 === "geometries") return true;
      } else if (key2 === "coordinates") return true;
      return false;
    }
  }
});

// node_modules/geobuf/decode.js
var require_decode = __commonJS({
  "node_modules/geobuf/decode.js"(exports2, module2) {
    "use strict";
    module2.exports = decode;
    var keys2;
    var values;
    var lengths;
    var dim;
    var e3;
    var geometryTypes = [
      "Point",
      "MultiPoint",
      "LineString",
      "MultiLineString",
      "Polygon",
      "MultiPolygon",
      "GeometryCollection"
    ];
    function decode(pbf) {
      dim = 2;
      e3 = Math.pow(10, 6);
      lengths = null;
      keys2 = [];
      values = [];
      var obj = pbf.readFields(readDataField, {});
      keys2 = null;
      return obj;
    }
    function readDataField(tag, obj, pbf) {
      if (tag === 1) keys2.push(pbf.readString());
      else if (tag === 2) dim = pbf.readVarint();
      else if (tag === 3) e3 = Math.pow(10, pbf.readVarint());
      else if (tag === 4) readFeatureCollection(pbf, obj);
      else if (tag === 5) readFeature(pbf, obj);
      else if (tag === 6) readGeometry(pbf, obj);
    }
    function readFeatureCollection(pbf, obj) {
      obj.type = "FeatureCollection";
      obj.features = [];
      return pbf.readMessage(readFeatureCollectionField, obj);
    }
    function readFeature(pbf, feature3) {
      feature3.type = "Feature";
      var f2 = pbf.readMessage(readFeatureField, feature3);
      if (!("geometry" in f2)) f2.geometry = null;
      return f2;
    }
    function readGeometry(pbf, geom) {
      geom.type = "Point";
      return pbf.readMessage(readGeometryField, geom);
    }
    function readFeatureCollectionField(tag, obj, pbf) {
      if (tag === 1) obj.features.push(readFeature(pbf, {}));
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, obj);
    }
    function readFeatureField(tag, feature3, pbf) {
      if (tag === 1) feature3.geometry = readGeometry(pbf, {});
      else if (tag === 11) feature3.id = pbf.readString();
      else if (tag === 12) feature3.id = pbf.readSVarint();
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 14) feature3.properties = readProps(pbf, {});
      else if (tag === 15) readProps(pbf, feature3);
    }
    function readGeometryField(tag, geom, pbf) {
      if (tag === 1) geom.type = geometryTypes[pbf.readVarint()];
      else if (tag === 2) lengths = pbf.readPackedVarint();
      else if (tag === 3) readCoords(geom, pbf, geom.type);
      else if (tag === 4) {
        geom.geometries = geom.geometries || [];
        geom.geometries.push(readGeometry(pbf, {}));
      } else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, geom);
    }
    function readCoords(geom, pbf, type) {
      if (type === "Point") geom.coordinates = readPoint(pbf);
      else if (type === "MultiPoint") geom.coordinates = readLine(pbf, true);
      else if (type === "LineString") geom.coordinates = readLine(pbf);
      else if (type === "MultiLineString") geom.coordinates = readMultiLine(pbf);
      else if (type === "Polygon") geom.coordinates = readMultiLine(pbf, true);
      else if (type === "MultiPolygon") geom.coordinates = readMultiPolygon(pbf);
    }
    function readValue(pbf) {
      var end = pbf.readVarint() + pbf.pos, value2 = null;
      while (pbf.pos < end) {
        var val2 = pbf.readVarint(), tag = val2 >> 3;
        if (tag === 1) value2 = pbf.readString();
        else if (tag === 2) value2 = pbf.readDouble();
        else if (tag === 3) value2 = pbf.readVarint();
        else if (tag === 4) value2 = -pbf.readVarint();
        else if (tag === 5) value2 = pbf.readBoolean();
        else if (tag === 6) value2 = JSON.parse(pbf.readString());
      }
      return value2;
    }
    function readProps(pbf, props) {
      var end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) props[keys2[pbf.readVarint()]] = values[pbf.readVarint()];
      values = [];
      return props;
    }
    function readPoint(pbf) {
      var end = pbf.readVarint() + pbf.pos, coords = [];
      while (pbf.pos < end) coords.push(pbf.readSVarint() / e3);
      return coords;
    }
    function readLinePart(pbf, end, len, closed) {
      var i2 = 0, coords = [], p2, d2;
      var prevP = [];
      for (d2 = 0; d2 < dim; d2++) prevP[d2] = 0;
      while (len ? i2 < len : pbf.pos < end) {
        p2 = [];
        for (d2 = 0; d2 < dim; d2++) {
          prevP[d2] += pbf.readSVarint();
          p2[d2] = prevP[d2] / e3;
        }
        coords.push(p2);
        i2++;
      }
      if (closed) coords.push(coords[0]);
      return coords;
    }
    function readLine(pbf) {
      return readLinePart(pbf, pbf.readVarint() + pbf.pos);
    }
    function readMultiLine(pbf, closed) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [readLinePart(pbf, end, null, closed)];
      var coords = [];
      for (var i2 = 0; i2 < lengths.length; i2++) coords.push(readLinePart(pbf, end, lengths[i2], closed));
      lengths = null;
      return coords;
    }
    function readMultiPolygon(pbf) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [[readLinePart(pbf, end, null, true)]];
      var coords = [];
      var j2 = 1;
      for (var i2 = 0; i2 < lengths[0]; i2++) {
        var rings = [];
        for (var k2 = 0; k2 < lengths[j2]; k2++) rings.push(readLinePart(pbf, end, lengths[j2 + 1 + k2], true));
        j2 += lengths[j2] + 1;
        coords.push(rings);
      }
      lengths = null;
      return coords;
    }
  }
});

// node_modules/geobuf/index.js
var require_geobuf = __commonJS({
  "node_modules/geobuf/index.js"(exports2) {
    "use strict";
    exports2.encode = require_encode();
    exports2.decode = require_decode();
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e3, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer2[offset + i2];
      i2 += d2;
      e3 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e3 & (1 << -nBits) - 1;
      e3 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e3 === 0) {
        e3 = 1 - eBias;
      } else if (e3 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e3 = e3 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
    };
    exports2.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
      var e3, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m2 = isNaN(value2) ? 1 : 0;
        e3 = eMax;
      } else {
        e3 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c2 = Math.pow(2, -e3)) < 1) {
          e3--;
          c2 *= 2;
        }
        if (e3 + eBias >= 1) {
          value2 += rt / c2;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c2 >= 2) {
          e3++;
          c2 /= 2;
        }
        if (e3 + eBias >= eMax) {
          m2 = 0;
          e3 = eMax;
        } else if (e3 + eBias >= 1) {
          m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
          e3 = e3 + eBias;
        } else {
          m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e3 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e3 = e3 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d2] |= s2 * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
          this.type = val2 & 7;
          readField(tag, result, this);
          if (this.pos === startPos) this.skip(val2);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val2 = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      readSFixed32: function() {
        var val2 = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readSFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readFloat: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val2;
      },
      readDouble: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val2;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val2, b2;
        b2 = buf[this.pos++];
        val2 = b2 & 127;
        if (b2 < 128) return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 7;
        if (b2 < 128) return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 14;
        if (b2 < 128) return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 21;
        if (b2 < 128) return val2;
        b2 = buf[this.pos];
        val2 |= (b2 & 15) << 28;
        return readVarintRemainder(val2, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer2;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val2) {
        var type = val2 & 7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 127) {
        }
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min3) {
        var length2 = this.length || 16;
        while (length2 < this.pos + min3) length2 *= 2;
        if (length2 !== this.length) {
          var buf = new Uint8Array(length2);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length2;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val2) {
        val2 = +val2 || 0;
        if (val2 > 268435455 || val2 < 0) {
          writeBigVarint(val2, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127) return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127) return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127) return;
        this.buf[this.pos++] = val2 >>> 7 & 127;
      },
      writeSVarint: function(val2) {
        this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
      },
      writeBoolean: function(val2) {
        this.writeVarint(Boolean(val2));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128) makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val2) {
        this.realloc(4);
        ieee754.write(this.buf, val2, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val2) {
        this.realloc(8);
        ieee754.write(this.buf, val2, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer2) {
        var len = buffer2.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i2 = 0; i2 < len; i2++) this.buf[this.pos++] = buffer2[i2];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128) makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer2) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer2);
      },
      writeFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val2);
      },
      writeSFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val2);
      },
      writeFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val2);
      },
      writeSFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val2);
      },
      writeVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val2);
      },
      writeSVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val2);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val2);
      },
      writeDoubleField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val2);
      },
      writeBooleanField: function(tag, val2) {
        this.writeVarintField(tag, Boolean(val2));
      }
    };
    function readVarintRemainder(l2, s2, p2) {
      var buf = p2.buf, h2, b2;
      b2 = buf[p2.pos++];
      h2 = (b2 & 112) >> 4;
      if (b2 < 128) return toNum(l2, h2, s2);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 3;
      if (b2 < 128) return toNum(l2, h2, s2);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 10;
      if (b2 < 128) return toNum(l2, h2, s2);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 17;
      if (b2 < 128) return toNum(l2, h2, s2);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 24;
      if (b2 < 128) return toNum(l2, h2, s2);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 1) << 31;
      if (b2 < 128) return toNum(l2, h2, s2);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val2, pbf) {
      var low, high;
      if (val2 >= 0) {
        low = val2 % 4294967296 | 0;
        high = val2 / 4294967296 | 0;
      } else {
        low = ~(-val2 % 4294967296);
        high = ~(-val2 / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i2 = pbf.pos - 1; i2 >= startPos; i2--) pbf.buf[i2 + extraLen] = pbf.buf[i2];
    }
    function writePackedVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeVarint(arr[i2]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSVarint(arr[i2]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFloat(arr[i2]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeDouble(arr[i2]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeBoolean(arr[i2]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFixed32(arr[i2]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSFixed32(arr[i2]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFixed64(arr[i2]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSFixed64(arr[i2]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val2, pos) {
      buf[pos] = val2;
      buf[pos + 1] = val2 >>> 8;
      buf[pos + 2] = val2 >>> 16;
      buf[pos + 3] = val2 >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i2 = pos;
      while (i2 < end) {
        var b0 = buf[i2];
        var c2 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i2 + bytesPerSequence > end) break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c2 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i2 + 1];
          if ((b1 & 192) === 128) {
            c2 = (b0 & 31) << 6 | b1 & 63;
            if (c2 <= 127) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          b3 = buf[i2 + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c2 <= 65535 || c2 >= 1114112) {
              c2 = null;
            }
          }
        }
        if (c2 === null) {
          c2 = 65533;
          bytesPerSequence = 1;
        } else if (c2 > 65535) {
          c2 -= 65536;
          str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
          c2 = 56320 | c2 & 1023;
        }
        str += String.fromCharCode(c2);
        i2 += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i2 = 0, c2, lead; i2 < str.length; i2++) {
        c2 = str.charCodeAt(i2);
        if (c2 > 55295 && c2 < 57344) {
          if (lead) {
            if (c2 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c2;
              continue;
            } else {
              c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c2 > 56319 || i2 + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c2;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c2 < 128) {
          buf[pos++] = c2;
        } else {
          if (c2 < 2048) {
            buf[pos++] = c2 >> 6 | 192;
          } else {
            if (c2 < 65536) {
              buf[pos++] = c2 >> 12 | 224;
            } else {
              buf[pos++] = c2 >> 18 | 240;
              buf[pos++] = c2 >> 12 & 63 | 128;
            }
            buf[pos++] = c2 >> 6 & 63 | 128;
          }
          buf[pos++] = c2 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@visactor/vutils/es/common/isType.js
var isType = (value2, type) => Object.prototype.toString.call(value2) === `[object ${type}]`;
var isType_default = isType;

// node_modules/@visactor/vutils/es/common/isBoolean.js
var isBoolean = (value2, fuzzy = false) => fuzzy ? "boolean" == typeof value2 : true === value2 || false === value2 || isType_default(value2, "Boolean");
var isBoolean_default = isBoolean;

// node_modules/@visactor/vutils/es/common/isFunction.js
var isFunction = (value2) => "function" == typeof value2;
var isFunction_default = isFunction;

// node_modules/@visactor/vutils/es/common/isNil.js
var isNil = (value2) => null == value2;
var isNil_default = isNil;

// node_modules/@visactor/vutils/es/common/isValid.js
var isValid = (value2) => null != value2;
var isValid_default = isValid;

// node_modules/@visactor/vutils/es/common/isObject.js
var isObject = (value2) => {
  const type = typeof value2;
  return null !== value2 && "object" === type || "function" === type;
};
var isObject_default = isObject;

// node_modules/@visactor/vutils/es/common/isObjectLike.js
var isObjectLike = (value2) => "object" == typeof value2 && null !== value2;
var isObjectLike_default = isObjectLike;

// node_modules/@visactor/vutils/es/common/isPlainObject.js
var isPlainObject = function(value2) {
  if (!isObjectLike_default(value2) || !isType_default(value2, "Object")) return false;
  if (null === Object.getPrototypeOf(value2)) return true;
  let proto = value2;
  for (; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value2) === proto;
};
var isPlainObject_default = isPlainObject;

// node_modules/@visactor/vutils/es/common/isUndefined.js
var isUndefined = (value2) => void 0 === value2;
var isUndefined_default = isUndefined;

// node_modules/@visactor/vutils/es/common/isString.js
var isString = (value2, fuzzy = false) => {
  const type = typeof value2;
  return fuzzy ? "string" === type : "string" === type || isType_default(value2, "String");
};
var isString_default = isString;

// node_modules/@visactor/vutils/es/common/isArray.js
var isArray = (value2) => Array.isArray ? Array.isArray(value2) : isType_default(value2, "Array");
var isArray_default = isArray;

// node_modules/@visactor/vutils/es/common/isNumber.js
var isNumber = (value2, fuzzy = false) => {
  const type = typeof value2;
  return fuzzy ? "number" === type : "number" === type || isType_default(value2, "Number");
};
var isNumber_default = isNumber;

// node_modules/@visactor/vutils/es/common/isNumeric.js
var isNumeric = (value2) => "string" == typeof value2 && (!isNaN(Number(value2)) && !isNaN(parseFloat(value2)));
var isNumeric_default = isNumeric;

// node_modules/@visactor/vutils/es/common/isValidNumber.js
var isValidNumber = (value2) => isNumber_default(value2) && Number.isFinite(value2);
var isValidNumber_default = isValidNumber;

// node_modules/@visactor/vutils/es/common/isArrayLike.js
var isArrayLike = function(value2) {
  return null !== value2 && "function" != typeof value2 && Number.isFinite(value2.length);
};
var isArrayLike_default = isArrayLike;

// node_modules/@visactor/vutils/es/common/getType.js
var getType = (value2) => ({}).toString.call(value2).replace(/^\[object /, "").replace(/]$/, "");
var getType_default = getType;

// node_modules/@visactor/vutils/es/common/isPrototype.js
var objectProto = Object.prototype;
var isPrototype = function(value2) {
  const Ctor = value2 && value2.constructor;
  return value2 === ("function" == typeof Ctor && Ctor.prototype || objectProto);
};
var isPrototype_default = isPrototype;

// node_modules/@visactor/vutils/es/common/isEmpty.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmpty(value2) {
  if (isNil_default(value2)) return true;
  if (isArrayLike_default(value2)) return !value2.length;
  const type = getType_default(value2);
  if ("Map" === type || "Set" === type) return !value2.size;
  if (isPrototype_default(value2)) return !Object.keys(value2).length;
  for (const key2 in value2) if (hasOwnProperty.call(value2, key2)) return false;
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/@visactor/vutils/es/common/get.js
var get = (obj, path, defaultValue) => {
  const paths = isString_default(path) ? path.split(".") : path;
  for (let p2 = 0; p2 < paths.length; p2++) obj = obj ? obj[paths[p2]] : void 0;
  return void 0 === obj ? defaultValue : obj;
};
var get_default = get;

// node_modules/@visactor/vutils/es/common/isDate.js
var isDate = (value2) => isType_default(value2, "Date");
var isDate_default = isDate;

// node_modules/@visactor/vutils/es/common/cloneDeep.js
function cloneDeep(value2, ignoreWhen, excludeKeys) {
  let result;
  if (!isValid_default(value2) || "object" != typeof value2 || ignoreWhen && ignoreWhen(value2)) return value2;
  const isArr = isArray_default(value2), length2 = value2.length;
  result = isArr ? new Array(length2) : "object" == typeof value2 ? {} : isBoolean_default(value2) || isNumber_default(value2) || isString_default(value2) ? value2 : isDate_default(value2) ? /* @__PURE__ */ new Date(+value2) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value2));
  let index2 = -1;
  if (result) for (; ++index2 < (props || value2).length; ) {
    const key2 = props ? props[index2] : index2, subValue = value2[key2];
    excludeKeys && excludeKeys.includes(key2.toString()) ? result[key2] = subValue : result[key2] = cloneDeep(subValue, ignoreWhen, excludeKeys);
  }
  return result;
}

// node_modules/@visactor/vutils/es/common/merge.js
function baseMerge(target, source, shallowArray = false, skipTargetArray = false) {
  if (source) {
    if (target === source) return;
    if (isValid_default(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key2 in iterable) props.push(key2);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key2 = props[++propIndex];
        !isValid_default(iterable[key2]) || "object" != typeof iterable[key2] || skipTargetArray && isArray_default(target[key2]) ? assignMergeValue(target, key2, iterable[key2]) : baseMergeDeep(target, source, key2, shallowArray, skipTargetArray);
      }
    }
  }
}
function baseMergeDeep(target, source, key2, shallowArray = false, skipTargetArray = false) {
  const objValue = target[key2], srcValue = source[key2];
  let newValue = source[key2], isCommon = true;
  if (isArray_default(srcValue)) {
    if (shallowArray) newValue = [];
    else if (isArray_default(objValue)) newValue = objValue;
    else if (isArrayLike_default(objValue)) {
      newValue = new Array(objValue.length);
      let index2 = -1;
      const length2 = objValue.length;
      for (; ++index2 < length2; ) newValue[index2] = objValue[index2];
    }
  } else isPlainObject_default(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key2, newValue);
}
function assignMergeValue(target, key2, value2) {
  (void 0 !== value2 && !eq(target[key2], value2) || void 0 === value2 && !(key2 in target)) && (target[key2] = value2);
}
function eq(value2, other) {
  return value2 === other || Number.isNaN(value2) && Number.isNaN(other);
}
function merge(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge(target, sources[sourceIndex], true);
  }
  return target;
}

// node_modules/@visactor/vutils/es/common/pickWithout.js
function pickWithout(obj, keys2) {
  if (!obj || !isPlainObject_default(obj)) return obj;
  const result = {};
  return Object.keys(obj).forEach((k2) => {
    const v2 = obj[k2];
    let match = false;
    keys2.forEach((itKey) => {
      (isString_default(itKey) && itKey === k2 || itKey instanceof RegExp && k2.match(itKey)) && (match = true);
    }), match || (result[k2] = v2);
  }), result;
}

// node_modules/@visactor/vutils/es/common/isEqual.js
function objToString(obj) {
  return Object.prototype.toString.call(obj);
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function isEqual(a2, b2, options) {
  if (a2 === b2) return true;
  if (typeof a2 != typeof b2) return false;
  if (null == a2 || null == b2) return false;
  if (Number.isNaN(a2) && Number.isNaN(b2)) return true;
  if (objToString(a2) !== objToString(b2)) return false;
  if (isFunction_default(a2)) return !!(null == options ? void 0 : options.skipFunction);
  if ("object" != typeof a2) return false;
  if (isArray_default(a2)) {
    if (a2.length !== b2.length) return false;
    for (let i2 = a2.length - 1; i2 >= 0; i2--) if (!isEqual(a2[i2], b2[i2], options)) return false;
    return true;
  }
  if (!isPlainObject_default(a2)) return false;
  const ka = objectKeys(a2), kb = objectKeys(b2);
  if (ka.length !== kb.length) return false;
  ka.sort(), kb.sort();
  for (let i2 = ka.length - 1; i2 >= 0; i2--) if (ka[i2] != kb[i2]) return false;
  for (let i2 = ka.length - 1; i2 >= 0; i2--) {
    const key2 = ka[i2];
    if (!isEqual(a2[key2], b2[key2], options)) return false;
  }
  return true;
}

// node_modules/@visactor/vutils/es/common/mixin.js
function keys(obj) {
  if (!obj) return [];
  if (Object.keys) return Object.keys(obj);
  const keyList = [];
  for (const key2 in obj) obj.hasOwnProperty(key2) && keyList.push(key2);
  return keyList;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i2 = 0; i2 < keysArr.length; i2++) {
    const key2 = keysArr[i2];
    (overlay ? null != source[key2] : null == target[key2]) && (target[key2] = source[key2]);
  }
  return target;
}
function mixin(target, source, override = true) {
  if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i2 = 0; i2 < keyList.length; i2++) {
      const key2 = keyList[i2];
      "constructor" !== key2 && (override ? null != source[key2] : null == target[key2]) && (target[key2] = source[key2]);
    }
  } else defaults(target, source, override);
}

// node_modules/@visactor/vutils/es/common/array.js
function array(arr) {
  return isValid_default(arr) ? isArray_default(arr) ? arr : [arr] : [];
}
function last(val2) {
  if (isArrayLike_default(val2)) {
    return val2[val2.length - 1];
  }
}
var maxInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length) return;
  let max3 = arr[0];
  for (let i2 = 1; i2 < arr.length; i2++) {
    const value2 = arr[i2];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value2, max3)) && void 0 !== _a ? _a : value2 - max3) > 0 && (max3 = value2);
  }
  return max3;
};
var minInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length) return;
  let min3 = arr[0];
  for (let i2 = 1; i2 < arr.length; i2++) {
    const value2 = arr[i2];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value2, min3)) && void 0 !== _a ? _a : value2 - min3) < 0 && (min3 = value2);
  }
  return min3;
};
function arrayEqual(a2, b2) {
  if (!isArray_default(a2) || !isArray_default(b2)) return false;
  if (a2.length !== b2.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) if (a2[i2] !== b2[i2]) return false;
  return true;
}
function uniqArray(arr) {
  return arr && isArray_default(arr) ? Array.from(new Set(array(arr))) : arr;
}
function shuffleArray(arr, random2 = Math.random) {
  let j2, x3, i2 = arr.length;
  for (; i2; ) j2 = Math.floor(random2() * i2), x3 = arr[--i2], arr[i2] = arr[j2], arr[j2] = x3;
  return arr;
}
function flattenArray(arr) {
  if (!isArray_default(arr)) return [arr];
  const result = [];
  for (const value2 of arr) result.push(...flattenArray(value2));
  return result;
}

// node_modules/@visactor/vutils/es/logger.js
var hasConsole = "undefined" != typeof console;
function log(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole && console[method].apply(console, args);
}
var LoggerLevel;
!function(LoggerLevel2) {
  LoggerLevel2[LoggerLevel2.None = 0] = "None", LoggerLevel2[LoggerLevel2.Error = 1] = "Error", LoggerLevel2[LoggerLevel2.Warn = 2] = "Warn", LoggerLevel2[LoggerLevel2.Info = 3] = "Info", LoggerLevel2[LoggerLevel2.Debug = 4] = "Debug";
}(LoggerLevel || (LoggerLevel = {}));
var Logger = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h2) => h2 === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index2 = this._onErrorHandler.findIndex((h2) => h2 === handler);
    index2 < 0 || this._onErrorHandler.splice(index2, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h2) => h2(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
  }
};
Logger._instance = null;

// node_modules/@visactor/vutils/es/common/ascending.js
function ascending(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}

// node_modules/@visactor/vutils/es/common/bisect.js
function bisect(a2, x3, lo = 0, hi) {
  for (isNil_default(hi) && (hi = a2.length); lo < hi; ) {
    const mid = lo + hi >>> 1;
    ascending(a2[mid], x3) > 0 ? hi = mid : lo = mid + 1;
  }
  return lo;
}
function findZeroOfFunction(f2, a2, b2, parameters) {
  var _a, _b;
  const maxIterations = null !== (_a = null == parameters ? void 0 : parameters.maxIterations) && void 0 !== _a ? _a : 100, tolerance = null !== (_b = null == parameters ? void 0 : parameters.tolerance) && void 0 !== _b ? _b : 1e-10, fA = f2(a2), fB = f2(b2);
  let delta = b2 - a2;
  if (fA * fB > 0) {
    return Logger.getInstance().error("Initial bisect points must have opposite signs"), NaN;
  }
  if (0 === fA) return a2;
  if (0 === fB) return b2;
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    delta /= 2;
    const mid = a2 + delta, fMid = f2(mid);
    if (fMid * fA >= 0 && (a2 = mid), Math.abs(delta) < tolerance || 0 === fMid) return mid;
  }
  return a2 + delta;
}
var binaryFuzzySearch = (arr, compareFn) => binaryFuzzySearchInNumberRange(0, arr.length, (value2) => compareFn(arr[value2]));
var binaryFuzzySearchInNumberRange = (x13, x22, compareFn) => {
  let left = x13, right = x22;
  for (; left < right; ) {
    const mid = Math.floor((left + right) / 2);
    compareFn(mid) >= 0 ? right = mid : left = mid + 1;
  }
  return left;
};

// node_modules/@visactor/vutils/es/common/clamp.js
var clamp2 = function(input, min3, max3) {
  return input < min3 ? min3 : input > max3 ? max3 : input;
};
var clamp_default = clamp2;

// node_modules/@visactor/vutils/es/common/clamper.js
function clamper(a2, b2) {
  let t2;
  return a2 > b2 && (t2 = a2, a2 = b2, b2 = t2), (x3) => Math.max(a2, Math.min(b2, x3));
}

// node_modules/@visactor/vutils/es/common/debounce.js
var hasRaf = false;
try {
  hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf = false;
}
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  const useRAF = !wait && 0 !== wait && hasRaf;
  if ("function" != typeof func) throw new TypeError("Expected a function");
  function invokeFunc(time2) {
    const args = lastArgs, thisArg = lastThis;
    return lastArgs = lastThis = void 0, lastInvokeTime = time2, result = func.apply(thisArg, args), result;
  }
  function startTimer(pendingFunc, wait2) {
    return useRAF ? (cancelAnimationFrame(timerId), requestAnimationFrame(pendingFunc)) : setTimeout(pendingFunc, wait2);
  }
  function shouldInvoke(time2) {
    const timeSinceLastCall = time2 - lastCallTime;
    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time2 - lastInvokeTime >= maxWait;
  }
  function timerExpired() {
    const time2 = Date.now();
    if (shouldInvoke(time2)) return trailingEdge(time2);
    timerId = startTimer(timerExpired, function(time3) {
      const timeSinceLastInvoke = time3 - lastInvokeTime, timeWaiting = wait - (time3 - lastCallTime);
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }(time2));
  }
  function trailingEdge(time2) {
    return timerId = void 0, trailing && lastArgs ? invokeFunc(time2) : (lastArgs = lastThis = void 0, result);
  }
  function debounced(...args) {
    const time2 = Date.now(), isInvoking = shouldInvoke(time2);
    if (lastArgs = args, lastThis = this, lastCallTime = time2, isInvoking) {
      if (void 0 === timerId) return function(time3) {
        return lastInvokeTime = time3, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time3) : result;
      }(lastCallTime);
      if (maxing) return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
    }
    return void 0 === timerId && (timerId = startTimer(timerExpired, wait)), result;
  }
  return wait = +wait || 0, isObject_default(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxing && (maxWait = Math.max(isValidNumber_default(options.maxWait) ? options.maxWait : 0, wait)), trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
    void 0 !== timerId && function(id) {
      if (useRAF) return cancelAnimationFrame(id);
      clearTimeout(id);
    }(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
  }, debounced.flush = function() {
    return void 0 === timerId ? result : trailingEdge(Date.now());
  }, debounced.pending = function() {
    return void 0 !== timerId;
  }, debounced;
}
hasRaf = false;
var debounce_default = debounce;

// node_modules/@visactor/vutils/es/common/throttle.js
function throttle(func, wait, options) {
  let leading = true, trailing = true;
  if ("function" != typeof func) throw new TypeError("Expected a function");
  return isObject_default(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce_default(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
}
var throttle_default = throttle;

// node_modules/@visactor/vutils/es/common/isValidUrl.js
var isValidUrl = (value2) => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value2);
var isValidUrl_default = isValidUrl;

// node_modules/@visactor/vutils/es/common/isBase64.js
var isBase64 = (value2) => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value2);
var isBase64_default = isBase64;

// node_modules/@visactor/vutils/es/common/has.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var has = (object2, key2) => null != object2 && hasOwnProperty2.call(object2, key2);
var has_default = has;

// node_modules/@visactor/vutils/es/common/range.js
function range(start, stop, step) {
  isValid_default(stop) || (stop = start, start = 0), isValid_default(step) || (step = 1);
  let i2 = -1;
  const n2 = 0 | Math.max(0, Math.ceil((stop - start) / step)), range2 = new Array(n2);
  for (; ++i2 < n2; ) range2[i2] = start + i2 * step;
  return range2;
}

// node_modules/@visactor/vutils/es/common/toNumber.js
function toNumber(a2) {
  return Number(a2);
}

// node_modules/@visactor/vutils/es/common/quantileSorted.js
function quantileSorted(values, percent, valueof = toNumber) {
  const n2 = values.length;
  if (!n2) return;
  if (percent <= 0 || n2 < 2) return valueof(values[0], 0, values);
  if (percent >= 1) return valueof(values[n2 - 1], n2 - 1, values);
  const i2 = (n2 - 1) * percent, i0 = Math.floor(i2), value0 = valueof(values[i0], i0, values);
  return value0 + (valueof(values[i0 + 1], i0 + 1, values) - value0) * (i2 - i0);
}

// node_modules/@visactor/vutils/es/common/median.js
var median = (values, isSorted) => {
  let sorted = values;
  return true !== isSorted && (sorted = values.sort(ascending)), quantileSorted(sorted, 0.5);
};

// node_modules/@visactor/vutils/es/common/tickStep.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/@visactor/vutils/es/common/number.js
var DEFAULT_ABSOLUTE_TOLERATE = 1e-10;
var DEFAULT_RELATIVE_TOLERATE = 1e-10;
function isNumberClose(a2, b2, relTol = DEFAULT_RELATIVE_TOLERATE, absTol = DEFAULT_ABSOLUTE_TOLERATE) {
  const abs3 = absTol, rel = relTol * Math.max(a2, b2);
  return Math.abs(a2 - b2) <= Math.max(abs3, rel);
}
function isGreater(a2, b2, relTol, absTol) {
  return a2 > b2 && !isNumberClose(a2, b2, relTol, absTol);
}
function isLess(a2, b2, relTol, absTol) {
  return a2 < b2 && !isNumberClose(a2, b2, relTol, absTol);
}

// node_modules/@visactor/vutils/es/common/memoize.js
var memoize = (func) => {
  let lastArgs = null, lastResult = null;
  return (...args) => (lastArgs && args.every((val2, i2) => val2 === lastArgs[i2]) || (lastArgs = args, lastResult = func(...args)), lastResult);
};

// node_modules/@visactor/vutils/es/common/clampRange.js
var clampRange = (range2, min3, max3) => {
  let [lowValue, highValue] = range2;
  highValue < lowValue && (lowValue = range2[1], highValue = range2[0]);
  const span = highValue - lowValue;
  return span >= max3 - min3 ? [min3, max3] : (lowValue = Math.min(Math.max(lowValue, min3), max3 - span), [lowValue, lowValue + span]);
};
var clampRange_default = clampRange;

// node_modules/@visactor/vutils/es/common/interpolate.js
function interpolateNumber(a2, b2) {
  return (t2) => a2 * (1 - t2) + b2 * t2;
}
function interpolateNumberRound(a2, b2) {
  return function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function interpolateDate(a2, b2) {
  const aVal = a2.valueOf(), bVal = b2.valueOf(), d2 = /* @__PURE__ */ new Date();
  return (t2) => (d2.setTime(aVal * (1 - t2) + bVal * t2), d2);
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  let am, bm, bs, bi = reA.lastIndex = reB.lastIndex = 0, i2 = -1;
  const s2 = [], q2 = [];
  for (a2 += "", b2 += ""; (am = reA.exec(a2)) && (bm = reB.exec(b2)); ) (bs = bm.index) > bi && (bs = b2.slice(bi, bs), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s2[i2] ? s2[i2] += bm : s2[++i2] = bm : (s2[++i2] = null, q2.push({
    i: i2,
    x: interpolateNumber(am, bm)
  })), bi = reB.lastIndex;
  return bi < b2.length && (bs = b2.slice(bi), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (let o2, i3 = 0; i3 < b2; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}

// node_modules/@visactor/vutils/es/common/toValidNumber.js
function toValidNumber(v2) {
  if (isValidNumber_default(v2)) return v2;
  const value2 = +v2;
  return isValidNumber_default(value2) ? value2 : 0;
}

// node_modules/@visactor/vutils/es/common/random.js
function seedRandom2(seed) {
  return parseFloat("0." + Math.sin(seed).toString().substring(6));
}

// node_modules/@visactor/vutils/es/math.js
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
var pi2 = 2 * Math.PI;
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var pow = Math.pow;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}
function pointAt(x13, y13, x22, y22, t2) {
  let x3 = x22, y3 = y22;
  return "number" == typeof x13 && "number" == typeof x22 && (x3 = (1 - t2) * x13 + t2 * x22), "number" == typeof y13 && "number" == typeof y22 && (y3 = (1 - t2) * y13 + t2 * y22), {
    x: x3,
    y: y3
  };
}
function crossProduct2(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
function dotProduct(a2, b2) {
  let ret = 0;
  for (let i2 = 0; i2 < a2.length; ++i2) ret += a2[i2] * b2[i2];
  return ret;
}
function fuzzyEqualVec(a2, b2) {
  return abs(a2[0] - b2[0]) + abs(a2[1] - b2[1]) < 1e-12;
}
function fixPrecision(num, precision = 10) {
  return Math.round(num * precision) / precision;
}
function getDecimalPlaces(n2) {
  const dStr = n2.toString().split(/[eE]/), s2 = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
  return s2 > 0 ? s2 : 0;
}
function precisionAdd(a2, b2) {
  return fixPrecision(a2 + b2, 10 ** Math.max(getDecimalPlaces(a2), getDecimalPlaces(b2)));
}
function precisionSub(a2, b2) {
  return fixPrecision(a2 - b2, 10 ** Math.max(getDecimalPlaces(a2), getDecimalPlaces(b2)));
}

// node_modules/@visactor/vutils/es/data-structure/point.js
var Point = class _Point {
  constructor(x3 = 0, y3 = 0, x13, y13) {
    this.x = 0, this.y = 0, this.x = x3, this.y = y3, this.x1 = x13, this.y1 = y13;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  copyFrom(p2) {
    return this.x = p2.x, this.y = p2.y, this.x1 = p2.x1, this.y1 = p2.y1, this.defined = p2.defined, this.context = p2.context, this;
  }
  set(x3, y3) {
    return this.x = x3, this.y = y3, this;
  }
  add(point2) {
    return isNumber_default(point2) ? (this.x += point2, void (this.y += point2)) : (this.x += point2.x, this.y += point2.y, this);
  }
  sub(point2) {
    return isNumber_default(point2) ? (this.x -= point2, void (this.y -= point2)) : (this.x -= point2.x, this.y -= point2.y, this);
  }
  multi(point2) {
    throw new Error("暂不支持");
  }
  div(point2) {
    throw new Error("暂不支持");
  }
};
var PointService = class {
  static distancePP(p1, p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
  }
  static distanceNN(x3, y3, x13, y13) {
    return sqrt(pow(x3 - x13, 2) + pow(y3 - y13, 2));
  }
  static distancePN(point2, x3, y3) {
    return sqrt(pow(x3 - point2.x, 2) + pow(y3 - point2.y, 2));
  }
  static pointAtPP(p1, p2, t2) {
    return new Point((p2.x - p1.x) * t2 + p1.x, (p2.y - p1.y) * t2 + p1.y);
  }
};

// node_modules/@visactor/vutils/es/angle.js
function degreeToRadian(degree) {
  return degree * (Math.PI / 180);
}
function radianToDegree(radian) {
  return 180 * radian / Math.PI;
}
var clampRadian = (angle = 0) => {
  if (angle < 0) for (; angle < -tau; ) angle += tau;
  else if (angle > 0) for (; angle > tau; ) angle -= tau;
  return angle;
};
var clampAngleByRadian = clampRadian;
function polarToCartesian(center, radius, angleInRadian) {
  return radius ? {
    x: center.x + radius * Math.cos(angleInRadian),
    y: center.y + radius * Math.sin(angleInRadian)
  } : {
    x: center.x,
    y: center.y
  };
}
function cartesianToPolar(point2, center = {
  x: 0,
  y: 0
}, startAngle = 0, endAngle = 2 * Math.PI) {
  const { x: x3, y: y3 } = point2, { x: centerX, y: centerY } = center;
  let dx = x3 - centerX, dy = y3 - centerY;
  const radius = Math.sqrt(dx * dx + dy * dy);
  if (0 === radius) return {
    radius: 0,
    angle: 0
  };
  dx /= radius, dy /= radius;
  let radian = Math.atan2(dy, dx);
  if (radian < startAngle) for (; radian <= startAngle; ) radian += 2 * Math.PI;
  if (radian > endAngle) for (; radian >= endAngle; ) radian -= 2 * Math.PI;
  return {
    radius,
    angle: radian
  };
}
function getAngleByPoint(center, point2) {
  return Math.atan2(point2.y - center.y, point2.x - center.x);
}
function normalizeAngle(angle) {
  for (; angle < 0; ) angle += 2 * Math.PI;
  for (; angle >= 2 * Math.PI; ) angle -= 2 * Math.PI;
  return angle;
}
function findBoundaryAngles(startAngle, endAngle) {
  const deltaAngle = Math.abs(endAngle - startAngle);
  if (deltaAngle >= 2 * Math.PI || 2 * Math.PI - deltaAngle < 1e-6) return [0, Math.PI / 2, Math.PI, 1.5 * Math.PI];
  const normalMin = normalizeAngle(Math.min(startAngle, endAngle)), normalMax = normalMin + deltaAngle, steps = [normalMin, normalMax];
  let directionAngle = Math.floor(normalMin / Math.PI) * Math.PI / 2;
  for (; directionAngle < normalMax; ) directionAngle > normalMin && steps.push(directionAngle), directionAngle += Math.PI / 2;
  return steps;
}
function calculateMaxRadius(rect, center, startAngle, endAngle) {
  const { x: x3, y: y3 } = center, steps = findBoundaryAngles(startAngle, endAngle), { width: width2, height: height2 } = rect, radiusList = [];
  return steps.forEach((step) => {
    const sin3 = Math.sin(step), cos3 = Math.cos(step);
    1 === sin3 ? radiusList.push(height2 - y3) : -1 === sin3 ? radiusList.push(y3) : 1 === cos3 ? radiusList.push(width2 - x3) : -1 === cos3 ? radiusList.push(x3) : (sin3 > 0 ? radiusList.push(Math.abs((height2 - y3) / sin3)) : radiusList.push(Math.abs(y3 / sin3)), cos3 > 0 ? radiusList.push(Math.abs((width2 - x3) / cos3)) : radiusList.push(Math.abs(x3 / cos3)));
  }), Math.min.apply(null, radiusList);
}
function computeQuadrant(angle) {
  return (angle = normalizeAngle(angle)) > 0 && angle <= Math.PI / 2 ? 2 : angle > Math.PI / 2 && angle <= Math.PI ? 3 : angle > Math.PI && angle <= 3 * Math.PI / 2 ? 4 : 1;
}

// node_modules/@visactor/vutils/es/graphics/algorithm/intersect.js
function sub2(out, v1, v2) {
  out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
}
function isIntersect(left1, right1, left2, right2) {
  let min1 = left1[0], max1 = right1[0], min22 = left2[0], max22 = right2[0];
  return max1 < min1 && ([min1, max1] = [max1, min1]), max22 < min22 && ([max22, min22] = [min22, max22]), !(max1 < min22 || max22 < min1) && (min1 = left1[1], max1 = right1[1], min22 = left2[1], max22 = right2[1], max1 < min1 && ([min1, max1] = [max1, min1]), max22 < min22 && ([max22, min22] = [min22, max22]), !(max1 < min22 || max22 < min1));
}
function getIntersectPoint(left1, right1, left2, right2) {
  if (!isIntersect(left1, right1, left2, right2)) return false;
  const dir1 = [0, 0], dir2 = [0, 0], tempVec = [0, 0];
  if (sub2(dir1, right1, left1), sub2(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return true;
  sub2(tempVec, left2, left1);
  const t2 = crossProduct2(tempVec, dir2) / crossProduct2(dir1, dir2);
  return t2 >= 0 && t2 <= 1 && [left1[0] + dir1[0] * t2, left1[1] + dir1[1] * t2];
}
function getRectIntersect(bbox1, bbox2, format) {
  if (null === bbox1) return bbox2;
  if (null === bbox2) return bbox1;
  const { x11, x12: x122, y11, y12: y122, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, format);
  return x11 >= x22 || x122 <= x21 || y11 >= y22 || y122 <= y21 ? {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0
  } : {
    x1: Math.max(x11, x21),
    y1: Math.max(y11, y21),
    x2: Math.min(x122, x22),
    y2: Math.min(y122, y22)
  };
}
var InnerBBox;
!function(InnerBBox2) {
  InnerBBox2[InnerBBox2.NONE = 0] = "NONE", InnerBBox2[InnerBBox2.BBOX1 = 1] = "BBOX1", InnerBBox2[InnerBBox2.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));
var formatTwoBBox = (bbox1, bbox2, format) => {
  let x11 = bbox1.x1, x122 = bbox1.x2, y11 = bbox1.y1, y122 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2;
  return format && (x11 > x122 && ([x11, x122] = [x122, x11]), y11 > y122 && ([y11, y122] = [y122, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), {
    x11,
    x12: x122,
    y11,
    y12: y122,
    x21,
    x22,
    y21,
    y22
  };
};
function rectInsideAnotherRect(bbox1, bbox2, format) {
  if (!bbox1 || !bbox2) return InnerBBox.NONE;
  const { x11, x12: x122, y11, y12: y122, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, format);
  return x11 > x21 && x122 < x22 && y11 > y21 && y122 < y22 ? InnerBBox.BBOX1 : x21 > x11 && x22 < x122 && y21 > y11 && y22 < y122 ? InnerBBox.BBOX2 : InnerBBox.NONE;
}
function isRectIntersect(bbox1, bbox2, format) {
  if (bbox1 && bbox2) {
    if (!format) return !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1);
    const { x11, x12: x122, y11, y12: y122, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, true);
    return !(x11 > x22 || x122 < x21 || y11 > y22 || y122 < y21);
  }
  return true;
}
function pointInRect(point2, bbox, format) {
  if (!bbox) return true;
  if (!format) return point2.x >= bbox.x1 && point2.x <= bbox.x2 && point2.y >= bbox.y1 && point2.y <= bbox.y2;
  let x11 = bbox.x1, x122 = bbox.x2, y11 = bbox.y1, y122 = bbox.y2;
  return x11 > x122 && ([x11, x122] = [x122, x11]), y11 > y122 && ([y11, y122] = [y122, y11]), point2.x >= x11 && point2.x <= x122 && point2.y >= y11 && point2.y <= y122;
}
function getProjectionRadius(checkAxis, axis) {
  return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);
}
function rotatePoint({ x: x3, y: y3 }, rad, origin = {
  x: 0,
  y: 0
}) {
  return {
    x: (x3 - origin.x) * Math.cos(rad) - (y3 - origin.y) * Math.sin(rad) + origin.x,
    y: (x3 - origin.x) * Math.sin(rad) + (y3 - origin.y) * Math.cos(rad) + origin.y
  };
}
function getCenterPoint(box) {
  return {
    x: (box.x1 + box.x2) / 2,
    y: (box.y1 + box.y2) / 2
  };
}
function toRect(box, isDeg) {
  const deg = isDeg ? degreeToRadian(box.angle) : box.angle, cp = getCenterPoint(box);
  return [rotatePoint({
    x: box.x1,
    y: box.y1
  }, deg, cp), rotatePoint({
    x: box.x2,
    y: box.y1
  }, deg, cp), rotatePoint({
    x: box.x2,
    y: box.y2
  }, deg, cp), rotatePoint({
    x: box.x1,
    y: box.y2
  }, deg, cp)];
}
function isRotateAABBIntersect(box1, box2, isDeg = false) {
  const rect1 = toRect(box1, isDeg), rect2 = toRect(box2, isDeg), vector = (start, end) => [end.x - start.x, end.y - start.y], vp1p2 = vector(getCenterPoint(box1), getCenterPoint(box2)), AB = vector(rect1[0], rect1[1]), BC = vector(rect1[1], rect1[2]), A1B1 = vector(rect2[0], rect2[1]), B1C1 = vector(rect2[1], rect2[2]), deg11 = isDeg ? degreeToRadian(box1.angle) : box1.angle;
  let deg12 = isDeg ? degreeToRadian(90 - box1.angle) : box1.angle + halfPi;
  const deg21 = isDeg ? degreeToRadian(box2.angle) : box2.angle;
  let deg22 = isDeg ? degreeToRadian(90 - box2.angle) : box2.angle + halfPi;
  deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
  const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
    const checkAxis = [Math.cos(deg), Math.sin(deg)];
    return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
  };
  return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
}

// node_modules/@visactor/vutils/es/graphics/algorithm/aabb.js
var x1;
var y1;
var x2;
var y2;
function getAABBFromPoints(points) {
  return x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0, points.forEach((point2) => {
    x1 > point2.x && (x1 = point2.x), x2 < point2.x && (x2 = point2.x), y1 > point2.y && (y1 = point2.y), y2 < point2.y && (y2 = point2.y);
  }), {
    x1,
    y1,
    x2,
    y2
  };
}

// node_modules/@visactor/vutils/es/graphics/polygon.js
var EPSILON = 1e-8;
function lineIntersectPolygon(a1x, a1y, a2x, a2y, points) {
  for (let i2 = 0, p2 = points[points.length - 1]; i2 < points.length; i2++) {
    const p3 = points[i2];
    if (isIntersect([a1x, a1y], [a2x, a2y], [p3.x, p3.y], [p2.x, p2.y])) return true;
    p2 = p3;
  }
  return false;
}
function polygonContainPoint(points, x3, y3) {
  let w2 = 0, p2 = points[0];
  if (!p2) return false;
  for (let i2 = 1; i2 < points.length; i2++) {
    const p22 = points[i2];
    w2 += isPointInLine(p2.x, p2.y, p22.x, p22.y, x3, y3), p2 = p22;
  }
  const p0 = points[0];
  return isAroundEqual(p2.x, p0.x) && isAroundEqual(p2.y, p0.y) || (w2 += isPointInLine(p2.x, p2.y, p0.x, p0.y, x3, y3)), 0 !== w2;
}
function isPointInLine(x05, y05, x13, y13, x3, y3) {
  if (y3 > y05 && y3 > y13 || y3 < y05 && y3 < y13) return 0;
  if (y13 === y05) return 0;
  const t2 = (y3 - y05) / (y13 - y05);
  let dir = y13 < y05 ? 1 : -1;
  1 !== t2 && 0 !== t2 || (dir = y13 < y05 ? 0.5 : -0.5);
  const x_ = t2 * (x13 - x05) + x05;
  return x_ === x3 ? 1 / 0 : x_ > x3 ? dir : 0;
}
function isAroundEqual(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON;
}
function polygonIntersectPolygon(pointsA, pointsB) {
  for (let i2 = 0; i2 < pointsB.length; i2++) {
    if (polygonContainPoint(pointsA, pointsB[i2].x, pointsB[i2].y)) return true;
    if (i2 > 0 && lineIntersectPolygon(pointsB[i2 - 1].x, pointsB[i2 - 1].y, pointsB[i2].x, pointsB[i2].y, pointsA)) return true;
  }
  return false;
}

// node_modules/@visactor/vutils/es/graphics/text/measure/util.js
function getContextFont(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

// node_modules/@visactor/vutils/es/graphics/text/stringWidth.js
var eastAsianCharacterInfo = (character) => {
  let x3 = character.charCodeAt(0), y3 = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x3;
  return 55296 <= x3 && x3 <= 56319 && 56320 <= y3 && y3 <= 57343 && (x3 &= 1023, y3 &= 1023, codePoint = x3 << 10 | y3, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// node_modules/@visactor/vutils/es/graphics/text/measure/textMeasure.js
var TextMeasure = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return false;
    if (isNil_default(this._canvas) && (isValid_default(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default(this._context) && isValid_default(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale3 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale3;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default(text2)) return {
      width: 0,
      height: 0
    };
    if (isNil_default(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e3) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
      fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
      fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i2 = 0; i2 < text2.length; i2++) {
      const char = text2[i2];
      let size = this._measureSpecialChar(char);
      isNil_default(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil_default(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height), !isNil_default(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), !isNil_default(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i2 = 0; i2 < text2.length; i2++) {
      const char = text2[i2], size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default(text2)) return defaultResult;
    if (isArray_default(text2)) {
      const textArr = text2.filter(isValid_default).map((s2) => s2.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height,
        fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
        fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height,
        fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
        fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default(this._canvas) && (this._canvas = null), isValid_default(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

// node_modules/@visactor/vutils/es/graphics/bounds-util.js
var calculateAnchorOfBounds = (bounds, anchorType) => {
  const { x1: x13, x2: x22, y1: y13, y2: y22 } = bounds, rectWidth = Math.abs(x22 - x13), rectHeight = Math.abs(y22 - y13);
  let anchorX = (x13 + x22) / 2, anchorY = (y13 + y22) / 2, sx = 0, sy = 0;
  switch (anchorType) {
    case "top":
    case "inside-top":
      sy = -0.5;
      break;
    case "bottom":
    case "inside-bottom":
      sy = 0.5;
      break;
    case "left":
    case "inside-left":
      sx = -0.5;
      break;
    case "right":
    case "inside-right":
      sx = 0.5;
      break;
    case "top-right":
      sx = 0.5, sy = -0.5;
      break;
    case "top-left":
      sx = -0.5, sy = -0.5;
      break;
    case "bottom-right":
      sx = 0.5, sy = 0.5;
      break;
    case "bottom-left":
      sx = -0.5, sy = 0.5;
  }
  return anchorX += sx * rectWidth, anchorY += sy * rectHeight, {
    x: anchorX,
    y: anchorY
  };
};
var aabbSeparation = (a2, b2) => Math.max(b2.x1 - a2.x2, a2.x1 - b2.x2, b2.y1 - a2.y2, a2.y1 - b2.y2);
var obbSeparation = (a2, b2) => {
  const axes = [{
    x: Math.cos(a2.angle),
    y: Math.sin(a2.angle)
  }, {
    x: -Math.sin(a2.angle),
    y: Math.cos(a2.angle)
  }, {
    x: Math.cos(b2.angle),
    y: Math.sin(a2.angle)
  }, {
    x: -Math.sin(b2.angle),
    y: Math.cos(a2.angle)
  }];
  function getProjectionRange(obb, axisX, axisY) {
    const projections = obb.getRotatedCorners().map((p2) => p2.x * axisX + p2.y * axisY);
    return {
      min: Math.min(...projections),
      max: Math.max(...projections)
    };
  }
  let maxDistance = 0;
  for (const axis of axes) {
    const rangeA = getProjectionRange(a2, axis.x, axis.y), rangeB = getProjectionRange(b2, axis.x, axis.y);
    let distance;
    distance = rangeA.max < rangeB.min ? rangeB.min - rangeA.max : rangeB.max < rangeA.min ? rangeA.min - rangeB.max : 0, maxDistance = Math.max(maxDistance, distance);
  }
  return maxDistance;
};

// node_modules/@visactor/vutils/es/data-structure/bounds.js
function transformBoundsWithMatrix(out, bounds, matrix) {
  const { x1: x13, y1: y13, x2: x22, y2: y22 } = bounds;
  return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x13 + matrix.c * y13 + matrix.e, matrix.b * x13 + matrix.d * y13 + matrix.f), out.add(matrix.a * x22 + matrix.c * y13 + matrix.e, matrix.b * x22 + matrix.d * y13 + matrix.f), out.add(matrix.a * x22 + matrix.c * y22 + matrix.e, matrix.b * x22 + matrix.d * y22 + matrix.f), out.add(matrix.a * x13 + matrix.c * y22 + matrix.e, matrix.b * x13 + matrix.d * y22 + matrix.f), bounds);
}
var Bounds = class _Bounds {
  constructor(bounds) {
    bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
  }
  clone() {
    return new _Bounds(this);
  }
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  }
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  }
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  }
  setValue(x13 = 0, y13 = 0, x22 = 0, y22 = 0) {
    return this.x1 = x13, this.y1 = y13, this.x2 = x22, this.y2 = y22, this;
  }
  set(x13 = 0, y13 = 0, x22 = 0, y22 = 0) {
    return x22 < x13 ? (this.x2 = x13, this.x1 = x22) : (this.x1 = x13, this.x2 = x22), y22 < y13 ? (this.y2 = y13, this.y1 = y22) : (this.y1 = y13, this.y2 = y22), this;
  }
  add(x3 = 0, y3 = 0) {
    return x3 < this.x1 && (this.x1 = x3), y3 < this.y1 && (this.y1 = y3), x3 > this.x2 && (this.x2 = x3), y3 > this.y2 && (this.y2 = y3), this;
  }
  expand(d2 = 0) {
    return isArray_default(d2) ? (this.y1 -= d2[0], this.x2 += d2[1], this.y2 += d2[2], this.x1 -= d2[3]) : (this.x1 -= d2, this.y1 -= d2, this.x2 += d2, this.y2 += d2), this;
  }
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  }
  translate(dx = 0, dy = 0) {
    return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
  }
  rotate(angle = 0, x3 = 0, y3 = 0) {
    const p2 = this.rotatedPoints(angle, x3, y3);
    return this.clear().add(p2[0], p2[1]).add(p2[2], p2[3]).add(p2[4], p2[5]).add(p2[6], p2[7]);
  }
  scale(sx = 0, sy = 0, x3 = 0, y3 = 0) {
    const p2 = this.scalePoints(sx, sy, x3, y3);
    return this.clear().add(p2[0], p2[1]).add(p2[2], p2[3]);
  }
  union(b2) {
    return b2.x1 < this.x1 && (this.x1 = b2.x1), b2.y1 < this.y1 && (this.y1 = b2.y1), b2.x2 > this.x2 && (this.x2 = b2.x2), b2.y2 > this.y2 && (this.y2 = b2.y2), this;
  }
  intersect(b2) {
    return b2.x1 > this.x1 && (this.x1 = b2.x1), b2.y1 > this.y1 && (this.y1 = b2.y1), b2.x2 < this.x2 && (this.x2 = b2.x2), b2.y2 < this.y2 && (this.y2 = b2.y2), this;
  }
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  }
  alignsWith(b2) {
    return b2 && (this.x1 === b2.x1 || this.x2 === b2.x2 || this.y1 === b2.y1 || this.y2 === b2.y2);
  }
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  }
  contains(x3 = 0, y3 = 0) {
    return !(x3 < this.x1 || x3 > this.x2 || y3 < this.y1 || y3 > this.y2);
  }
  containsPoint(p2) {
    return !(p2.x < this.x1 || p2.x > this.x2 || p2.y < this.y1 || p2.y > this.y2);
  }
  width() {
    return this.empty() ? 0 : this.x2 - this.x1;
  }
  height() {
    return this.empty() ? 0 : this.y2 - this.y1;
  }
  scaleX(s2 = 0) {
    return this.x1 *= s2, this.x2 *= s2, this;
  }
  scaleY(s2 = 0) {
    return this.y1 *= s2, this.y2 *= s2, this;
  }
  transformWithMatrix(matrix) {
    return transformBoundsWithMatrix(this, this, matrix), this;
  }
  copy(b2) {
    return this.x1 = b2.x1, this.y1 = b2.y1, this.x2 = b2.x2, this.y2 = b2.y2, this;
  }
  rotatedPoints(angle, x3, y3) {
    const { x1: x13, y1: y13, x2: x22, y2: y22 } = this, cos3 = Math.cos(angle), sin3 = Math.sin(angle), cx = x3 - x3 * cos3 + y3 * sin3, cy = y3 - x3 * sin3 - y3 * cos3;
    return [cos3 * x13 - sin3 * y13 + cx, sin3 * x13 + cos3 * y13 + cy, cos3 * x13 - sin3 * y22 + cx, sin3 * x13 + cos3 * y22 + cy, cos3 * x22 - sin3 * y13 + cx, sin3 * x22 + cos3 * y13 + cy, cos3 * x22 - sin3 * y22 + cx, sin3 * x22 + cos3 * y22 + cy];
  }
  scalePoints(sx, sy, x3, y3) {
    const { x1: x13, y1: y13, x2: x22, y2: y22 } = this;
    return [sx * x13 + (1 - sx) * x3, sy * y13 + (1 - sy) * y3, sx * x22 + (1 - sx) * x3, sy * y22 + (1 - sy) * y3];
  }
};
var AABBBounds = class extends Bounds {
};
var OBBBounds = class _OBBBounds extends Bounds {
  constructor(bounds, angle = 0) {
    var _a;
    super(bounds), bounds && (this.angle = null !== (_a = bounds.angle) && void 0 !== _a ? _a : angle);
  }
  intersects(b2) {
    return isRotateAABBIntersect(this, b2);
  }
  setValue(x13 = 0, y13 = 0, x22 = 0, y22 = 0, angle = 0) {
    return super.setValue(x13, y13, x22, y22), this.angle = angle, this;
  }
  clone() {
    return new _OBBBounds(this);
  }
  getRotatedCorners() {
    const originPoint = {
      x: (this.x1 + this.x2) / 2,
      y: (this.y1 + this.y2) / 2
    };
    return [rotatePoint({
      x: this.x1,
      y: this.y1
    }, this.angle, originPoint), rotatePoint({
      x: this.x2,
      y: this.y1
    }, this.angle, originPoint), rotatePoint({
      x: this.x1,
      y: this.y2
    }, this.angle, originPoint), rotatePoint({
      x: this.x2,
      y: this.y2
    }, this.angle, originPoint)];
  }
};

// node_modules/@visactor/vutils/es/data-structure/matrix.js
var Matrix2 = class _Matrix {
  constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, e3 = 0, f2 = 0) {
    this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.e = e3, this.f = f2;
  }
  equalToMatrix(m2) {
    return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
  }
  equalTo(a2, b2, c2, d2, e3, f2) {
    return !(this.e !== e3 || this.f !== f2 || this.a !== a2 || this.d !== d2 || this.b !== b2 || this.c !== c2);
  }
  setValue(a2, b2, c2, d2, e3, f2) {
    return this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.e = e3, this.f = f2, this;
  }
  reset() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  getInverse() {
    const a2 = this.a, b2 = this.b, c2 = this.c, d2 = this.d, e3 = this.e, f2 = this.f, m2 = new _Matrix(), dt = a2 * d2 - b2 * c2;
    return m2.a = d2 / dt, m2.b = -b2 / dt, m2.c = -c2 / dt, m2.d = a2 / dt, m2.e = (c2 * f2 - d2 * e3) / dt, m2.f = -(a2 * f2 - b2 * e3) / dt, m2;
  }
  rotate(rad) {
    const c2 = Math.cos(rad), s2 = Math.sin(rad), m11 = this.a * c2 + this.c * s2, m12 = this.b * c2 + this.d * s2, m21 = this.a * -s2 + this.c * c2, m22 = this.b * -s2 + this.d * c2;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
  }
  rotateByCenter(rad, cx, cy) {
    const cos3 = Math.cos(rad), sin3 = Math.sin(rad), rotateM13 = (1 - cos3) * cx + sin3 * cy, rotateM23 = (1 - cos3) * cy - sin3 * cx, m11 = cos3 * this.a - sin3 * this.b, m21 = sin3 * this.a + cos3 * this.b, m12 = cos3 * this.c - sin3 * this.d, m22 = sin3 * this.c + cos3 * this.d, m13 = cos3 * this.e - sin3 * this.f + rotateM13, m23 = sin3 * this.e + cos3 * this.f + rotateM23;
    return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
  }
  scale(sx, sy) {
    return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
  }
  setScale(sx, sy) {
    return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
  }
  transform(a2, b2, c2, d2, e3, f2) {
    return this.multiply(a2, b2, c2, d2, e3, f2), this;
  }
  translate(x3, y3) {
    return this.e += this.a * x3 + this.c * y3, this.f += this.b * x3 + this.d * y3, this;
  }
  transpose() {
    const { a: a2, b: b2, c: c2, d: d2, e: e3, f: f2 } = this;
    return this.a = b2, this.b = a2, this.c = d2, this.d = c2, this.e = f2, this.f = e3, this;
  }
  multiply(a2, b2, c2, d2, e23, f2) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, m11 = a1 * a2 + c1 * b2, m12 = b1 * a2 + d1 * b2, m21 = a1 * c2 + c1 * d2, m22 = b1 * c2 + d1 * d2, dx = a1 * e23 + c1 * f2 + this.e, dy = b1 * e23 + d1 * f2 + this.f;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
  }
  interpolate(m2, t2) {
    const m3 = new _Matrix();
    return m3.a = this.a + (m2.a - this.a) * t2, m3.b = this.b + (m2.b - this.b) * t2, m3.c = this.c + (m2.c - this.c) * t2, m3.d = this.d + (m2.d - this.d) * t2, m3.e = this.e + (m2.e - this.e) * t2, m3.f = this.f + (m2.f - this.f) * t2, m3;
  }
  transformPoint(source, target) {
    const { a: a2, b: b2, c: c2, d: d2, e: e3, f: f2 } = this, dt = a2 * d2 - b2 * c2, nextA = d2 / dt, nextB = -b2 / dt, nextC = -c2 / dt, nextD = a2 / dt, nextE = (c2 * f2 - d2 * e3) / dt, nextF = -(a2 * f2 - b2 * e3) / dt, { x: x3, y: y3 } = source;
    target.x = x3 * nextA + y3 * nextC + nextE, target.y = x3 * nextB + y3 * nextD + nextF;
  }
  onlyTranslate(scale3 = 1) {
    return this.a === scale3 && 0 === this.b && 0 === this.c && this.d === scale3;
  }
  clone() {
    return new _Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  toTransformAttrs() {
    const a2 = this.a, b2 = this.b, c2 = this.c, d2 = this.d, delta = a2 * d2 - b2 * c2, result = {
      x: this.e,
      y: this.f,
      rotateDeg: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (0 !== a2 || 0 !== b2) {
      const r2 = Math.sqrt(a2 * a2 + b2 * b2);
      result.rotateDeg = b2 > 0 ? Math.acos(a2 / r2) : -Math.acos(a2 / r2), result.scaleX = r2, result.scaleY = delta / r2, result.skewX = (a2 * c2 + b2 * d2) / delta, result.skewY = 0;
    } else if (0 !== c2 || 0 !== d2) {
      const s2 = Math.sqrt(c2 * c2 + d2 * d2);
      result.rotateDeg = Math.PI / 2 - (d2 > 0 ? Math.acos(-c2 / s2) : -Math.acos(c2 / s2)), result.scaleX = delta / s2, result.scaleY = s2, result.skewX = 0, result.skewY = (a2 * c2 + b2 * d2) / delta;
    }
    return result.rotateDeg = radianToDegree(result.rotateDeg), result;
  }
};
function normalTransform(out, origin, x3, y3, scaleX, scaleY, angle, rotateCenter) {
  const oa = origin.a, ob2 = origin.b, oc = origin.c, od = origin.d, oe = origin.e, of = origin.f, cosTheta = cos(angle), sinTheta = sin(angle);
  let rotateCenterX, rotateCenterY;
  rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x3, rotateCenterY = y3);
  const offsetX = rotateCenterX - x3, offsetY = rotateCenterY - y3, a1 = oa * cosTheta + oc * sinTheta, b1 = ob2 * cosTheta + od * sinTheta, c1 = oc * cosTheta - oa * sinTheta, d1 = od * cosTheta - ob2 * sinTheta;
  out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob2 * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
}

// node_modules/@visactor/vutils/es/color/hslToRgb.js
function hslToRgb2(h2, s2, l2) {
  s2 /= 100, l2 /= 100;
  const c2 = (1 - Math.abs(2 * l2 - 1)) * s2, x3 = c2 * (1 - Math.abs(h2 / 60 % 2 - 1)), m2 = l2 - c2 / 2;
  let r2 = 0, g3 = 0, b2 = 0;
  return 0 <= h2 && h2 < 60 ? (r2 = c2, g3 = x3, b2 = 0) : 60 <= h2 && h2 < 120 ? (r2 = x3, g3 = c2, b2 = 0) : 120 <= h2 && h2 < 180 ? (r2 = 0, g3 = c2, b2 = x3) : 180 <= h2 && h2 < 240 ? (r2 = 0, g3 = x3, b2 = c2) : 240 <= h2 && h2 < 300 ? (r2 = x3, g3 = 0, b2 = c2) : 300 <= h2 && h2 < 360 && (r2 = c2, g3 = 0, b2 = x3), r2 = Math.round(255 * (r2 + m2)), g3 = Math.round(255 * (g3 + m2)), b2 = Math.round(255 * (b2 + m2)), {
    r: r2,
    g: g3,
    b: b2
  };
}

// node_modules/@visactor/vutils/es/color/rgbToHsl.js
function rgbToHsl2(r2, g3, b2) {
  r2 /= 255, g3 /= 255, b2 /= 255;
  const cMin = Math.min(r2, g3, b2), cMax = Math.max(r2, g3, b2), delta = cMax - cMin;
  let h2 = 0, s2 = 0, l2 = 0;
  return h2 = 0 === delta ? 0 : cMax === r2 ? (g3 - b2) / delta % 6 : cMax === g3 ? (b2 - r2) / delta + 2 : (r2 - g3) / delta + 4, h2 = Math.round(60 * h2), h2 < 0 && (h2 += 360), l2 = (cMax + cMin) / 2, s2 = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l2 - 1)), s2 = +(100 * s2).toFixed(1), l2 = +(100 * l2).toFixed(1), {
    h: h2,
    s: s2,
    l: l2
  };
}

// node_modules/@visactor/vutils/es/color/Color.js
var REG_HEX = /^#([0-9a-f]{3,8})$/;
var DEFAULT_COLORS_OPACITY = {
  transparent: 4294967040
};
var DEFAULT_COLORS = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function hex(value2) {
  return ((value2 = Math.max(0, Math.min(255, Math.round(value2) || 0))) < 16 ? "0" : "") + value2.toString(16);
}
function rgb(value2) {
  return isNumber_default(value2) ? new RGB(value2 >> 16, value2 >> 8 & 255, 255 & value2, 1) : isArray_default(value2) ? new RGB(value2[0], value2[1], value2[2]) : new RGB(255, 255, 255);
}
function rgba(value2) {
  return isNumber_default(value2) ? new RGB(value2 >>> 24, value2 >>> 16 & 255, value2 >>> 8 & 255, 255 & value2) : isArray_default(value2) ? new RGB(value2[0], value2[1], value2[2], value2[3]) : new RGB(255, 255, 255, 1);
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? 0.0773993808 * c2 : Math.pow(0.9478672986 * c2 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? 12.92 * c2 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var setHex = (formatValue, forceHex) => {
  const isHex = REG_HEX.exec(formatValue);
  if (forceHex || isHex) {
    const hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
    return 3 === hexLength ? new RGB((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : null;
  }
};
var Color = class _Color {
  static Brighter(source, b2 = 1) {
    return 1 === b2 ? source : new _Color(source).brighter(b2).toRGBA();
  }
  static SetOpacity(source, o2 = 1) {
    return 1 === o2 ? source : new _Color(source).setOpacity(o2).toRGBA();
  }
  static getColorBrightness(source, model = "hsl") {
    const color = source instanceof _Color ? source : new _Color(source);
    switch (model) {
      case "hsv":
      default:
        return color.getHSVBrightness();
      case "hsl":
        return color.getHSLBrightness();
      case "lum":
        return color.getLuminance();
      case "lum2":
        return color.getLuminance2();
      case "lum3":
        return color.getLuminance3();
      case "wcag":
        return color.getLuminanceWCAG();
    }
  }
  static parseColorString(value2) {
    if (isValid_default(DEFAULT_COLORS_OPACITY[value2])) return rgba(DEFAULT_COLORS_OPACITY[value2]);
    if (isValid_default(DEFAULT_COLORS[value2])) return rgb(DEFAULT_COLORS[value2]);
    const formatValue = `${value2}`.trim().toLowerCase(), hexRes = setHex(formatValue);
    if (void 0 !== hexRes) return hexRes;
    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","), rgb2 = hslToRgb2(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
      return new RGB(rgb2.r, rgb2.g, rgb2.b, parseFloat(aColor[3]));
    }
  }
  constructor(value2) {
    const color = _Color.parseColorString(value2);
    color ? this.color = color : (console.warn(`Warn: 传入${value2}无法解析为Color`), this.color = new RGB(255, 255, 255));
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(k2) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r2 * k2))), this.color.g = Math.max(0, Math.min(255, Math.floor(g3 * k2))), this.color.b = Math.max(0, Math.min(255, Math.floor(b2 * k2))), this;
  }
  add(color) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r += Math.min(255, r2 + color.color.r), this.color.g += Math.min(255, g3 + color.color.g), this.color.b += Math.min(255, b2 + color.color.b), this;
  }
  sub(color) {
    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
  }
  multiply(color) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r2 * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g3 * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b2 * color.color.b))), this;
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return 0.5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
  }
  setHsl(h2, s2, l2) {
    const opacity = this.color.opacity, hsl = rgbToHsl2(this.color.r, this.color.g, this.color.b), rgb2 = hslToRgb2(isNil_default(h2) ? hsl.h : clamp_default(h2, 0, 360), isNil_default(s2) ? hsl.s : s2 >= 0 && s2 <= 1 ? 100 * s2 : s2, isNil_default(l2) ? hsl.l : l2 <= 1 && l2 >= 0 ? 100 * l2 : l2);
    return this.color = new RGB(rgb2.r, rgb2.g, rgb2.b, opacity), this;
  }
  setRGB(r2, g3, b2) {
    return !isNil_default(r2) && (this.color.r = r2), !isNil_default(g3) && (this.color.g = g3), !isNil_default(b2) && (this.color.b = b2), this;
  }
  setHex(value2) {
    const formatValue = `${value2}`.trim().toLowerCase(), res = setHex(formatValue, true);
    return null != res ? res : this;
  }
  setColorName(name2) {
    const hex2 = DEFAULT_COLORS[name2.toLowerCase()];
    return void 0 !== hex2 ? this.setHex(hex2) : console.warn("THREE.Color: Unknown color " + name2), this;
  }
  setScalar(scalar) {
    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
  }
  setOpacity(o2 = 1) {
    return this.color.opacity = o2, this;
  }
  getLuminance() {
    return (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) / 255;
  }
  getLuminance2() {
    return (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) / 255;
  }
  getLuminance3() {
    return (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255;
  }
  getLuminanceWCAG() {
    const RsRGB = this.color.r / 255, GsRGB = this.color.g / 255, BsRGB = this.color.b / 255;
    let R2, G2, B2;
    R2 = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4), G2 = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4), B2 = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  }
  clone() {
    return new _Color(this.color.toString());
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  copySRGBToLinear(color) {
    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
  }
  copyLinearToSRGB(color) {
    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
};
var RGB = class {
  constructor(r2, g3, b2, opacity) {
    this.r = isNaN(+r2) ? 255 : Math.max(0, Math.min(255, +r2)), this.g = isNaN(+g3) ? 255 : Math.max(0, Math.min(255, +g3)), this.b = isNaN(+b2) ? 255 : Math.max(0, Math.min(255, +b2)), isValid_default(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
  }
  formatHex() {
    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
  }
  formatRgb() {
    const opacity = this.opacity;
    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
  }
  formatHsl() {
    const opacity = this.opacity, { h: h2, s: s2, l: l2 } = rgbToHsl2(this.r, this.g, this.b);
    return `${1 === opacity ? "hsl(" : "hsla("}${h2},${s2}%,${l2}%${1 === opacity ? ")" : `,${opacity})`}`;
  }
  toString() {
    return this.formatHex();
  }
};

// node_modules/@visactor/vutils/es/color/index.js
var color_exports = {};
__export(color_exports, {
  Color: () => Color,
  DEFAULT_COLORS: () => DEFAULT_COLORS,
  RGB: () => RGB,
  hexToRgb: () => hexToRgb,
  hslToRgb: () => hslToRgb2,
  interpolateRgb: () => interpolateRgb,
  rgbToHex: () => rgbToHex2,
  rgbToHsl: () => rgbToHsl2
});

// node_modules/@visactor/vutils/es/color/hexToRgb.js
function hexToRgb(str) {
  let r2 = "", g3 = "", b2 = "";
  const strtIndex = "#" === str[0] ? 1 : 0;
  for (let i2 = strtIndex; i2 < str.length; i2++) "#" !== str[i2] && (i2 < strtIndex + 2 ? r2 += str[i2] : i2 < strtIndex + 4 ? g3 += str[i2] : i2 < strtIndex + 6 && (b2 += str[i2]));
  return [parseInt(r2, 16), parseInt(g3, 16), parseInt(b2, 16)];
}

// node_modules/@visactor/vutils/es/color/rgbToHex.js
function rgbToHex2(r2, g3, b2) {
  return Number((1 << 24) + (r2 << 16) + (g3 << 8) + b2).toString(16).slice(1);
}

// node_modules/@visactor/vutils/es/color/interpolate.js
function interpolateRgb(colorA, colorB) {
  const redA = colorA.r, redB = colorB.r, greenA = colorA.g, greenB = colorB.g, blueA = colorA.b, blueB = colorB.b, opacityA = colorA.opacity, opacityB = colorB.opacity;
  return (t2) => {
    const r2 = Math.round(redA * (1 - t2) + redB * t2), g3 = Math.round(greenA * (1 - t2) + greenB * t2), b2 = Math.round(blueA * (1 - t2) + blueB * t2);
    return new RGB(r2, g3, b2, opacityA * (1 - t2) + opacityB * t2);
  };
}

// node_modules/@visactor/vutils/es/padding.js
function normalizePadding(padding) {
  if (isValidNumber_default(padding)) return [padding, padding, padding, padding];
  if (isArray_default(padding)) {
    const length2 = padding.length;
    if (1 === length2) {
      const paddingValue = padding[0];
      return [paddingValue, paddingValue, paddingValue, paddingValue];
    }
    if (2 === length2) {
      const [vertical, horizontal] = padding;
      return [vertical, horizontal, vertical, horizontal];
    }
    if (3 === length2) {
      const [top, horizontal, bottom] = padding;
      return [top, horizontal, bottom, horizontal];
    }
    if (4 === length2) return padding;
  }
  if (isObject_default(padding)) {
    const { top = 0, right = 0, bottom = 0, left = 0 } = padding;
    return [top, right, bottom, left];
  }
  return [0, 0, 0, 0];
}

// node_modules/@visactor/vutils/es/dom.js
function getContainerSize(el, defaultWidth = 0, defaultHeight = 0) {
  if (!el) return {
    width: defaultWidth,
    height: defaultHeight
  };
  let getComputedStyle;
  try {
    getComputedStyle = null === window || void 0 === window ? void 0 : window.getComputedStyle;
  } catch (e3) {
    getComputedStyle = () => ({});
  }
  const style = getComputedStyle(el);
  if (/^(\d*\.?\d+)(px)$/.exec(style.width)) {
    const computedWidth = parseFloat(style.width) - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight) || el.clientWidth - 1, computedHeight = parseFloat(style.height) - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom) || el.clientHeight - 1;
    return {
      width: computedWidth <= 0 ? defaultWidth : computedWidth,
      height: computedHeight <= 0 ? defaultHeight : computedHeight
    };
  }
  return {
    width: defaultWidth,
    height: defaultHeight
  };
}
function getElementAbsolutePosition(element) {
  const { x: x3, y: y3 } = element.getBoundingClientRect();
  return {
    x: x3,
    y: y3
  };
}
var styleStringToObject = (styleStr = "") => {
  const res = {};
  return styleStr.split(";").forEach((item) => {
    if (item) {
      const arr = item.split(":");
      if (2 === arr.length) {
        const key2 = arr[0].trim(), value2 = arr[1].trim();
        key2 && value2 && (res[key2] = value2);
      }
    }
  }), res;
};
var lowerCamelCaseToMiddle = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase();
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_2, letter) => letter.toUpperCase());
}
function isHTMLElement(obj) {
  try {
    return obj instanceof Element;
  } catch (_a) {
    const htmlElementKeys = ["children", "innerHTML", "classList", "setAttribute", "tagName", "getBoundingClientRect"], keys2 = Object.keys(obj);
    return htmlElementKeys.every((key2) => keys2.includes(key2));
  }
}

// node_modules/@visactor/vutils/es/format/time.js
var TimeUtil = class _TimeUtil {
  static getInstance() {
    return _TimeUtil.instance || (_TimeUtil.instance = new _TimeUtil()), _TimeUtil.instance;
  }
  constructor() {
    this.locale_shortWeekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], this.locale_periods = ["AM", "PM"], this.locale_weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], this.locale_shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], this.numberRe = /^\s*\d+/, this.pads = {
      "-": "",
      _: " ",
      0: "0"
    }, this.requoteRe = /[\\^$*+?|[\]().{}]/g, this.locale_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], this.formatShortWeekday = (d2) => this.locale_shortWeekdays[d2.getDay()], this.formatWeekday = (d2) => this.locale_weekdays[d2.getDay()], this.formatShortMonth = (d2) => this.locale_shortMonths[d2.getMonth()], this.formatMonth = (d2) => this.locale_months[d2.getMonth()], this.formatDayOfMonth = (d2, p2) => this.pad(d2.getDate(), p2, 2), this.formatHour24 = (d2, p2) => this.pad(d2.getHours(), p2, 2), this.formatHour12 = (d2, p2) => this.pad(d2.getHours() % 12 || 12, p2, 2), this.formatMilliseconds = (d2, p2) => this.pad(d2.getMilliseconds(), p2, 3), this.formatMonthNumber = (d2, p2) => this.pad(d2.getMonth() + 1, p2, 2), this.formatMinutes = (d2, p2) => this.pad(d2.getMinutes(), p2, 2), this.formatPeriod = (d2) => this.locale_periods[+(d2.getHours() >= 12)], this.formatSeconds = (d2, p2) => this.pad(d2.getSeconds(), p2, 2), this.formatFullYear = (d2, p2) => this.pad(d2.getFullYear() % 1e4, p2, 4), this.formatUTCShortWeekday = (d2) => this.locale_shortWeekdays[d2.getUTCDay()], this.formatUTCWeekday = (d2) => this.locale_weekdays[d2.getUTCDay()], this.formatUTCShortMonth = (d2) => this.locale_shortMonths[d2.getUTCMonth()], this.formatUTCMonth = (d2) => this.locale_months[d2.getUTCMonth()], this.formatUTCDayOfMonth = (d2, p2) => this.pad(d2.getUTCDate(), p2, 2), this.formatUTCHour24 = (d2, p2) => this.pad(d2.getUTCHours(), p2, 2), this.formatUTCHour12 = (d2, p2) => this.pad(d2.getUTCHours() % 12 || 12, p2, 2), this.formatUTCMilliseconds = (d2, p2) => this.pad(d2.getUTCMilliseconds(), p2, 3), this.formatUTCMonthNumber = (d2, p2) => this.pad(d2.getUTCMonth() + 1, p2, 2), this.formatUTCMinutes = (d2, p2) => this.pad(d2.getUTCMinutes(), p2, 2), this.formatUTCPeriod = (d2) => this.locale_periods[+(d2.getUTCHours() >= 12)], this.formatUTCSeconds = (d2, p2) => this.pad(d2.getUTCSeconds(), p2, 2), this.formatUTCFullYear = (d2, p2) => this.pad(d2.getUTCFullYear() % 1e4, p2, 4), this.formats = {
      a: this.formatShortWeekday,
      A: this.formatWeekday,
      b: this.formatShortMonth,
      B: this.formatMonth,
      d: this.formatDayOfMonth,
      e: this.formatDayOfMonth,
      H: this.formatHour24,
      I: this.formatHour12,
      L: this.formatMilliseconds,
      m: this.formatMonthNumber,
      M: this.formatMinutes,
      p: this.formatPeriod,
      S: this.formatSeconds,
      Y: this.formatFullYear
    }, this.utcFormats = {
      a: this.formatUTCShortWeekday,
      A: this.formatUTCWeekday,
      b: this.formatUTCShortMonth,
      B: this.formatUTCMonth,
      d: this.formatUTCDayOfMonth,
      e: this.formatUTCDayOfMonth,
      H: this.formatUTCHour24,
      I: this.formatUTCHour12,
      L: this.formatUTCMilliseconds,
      m: this.formatUTCMonthNumber,
      M: this.formatUTCMinutes,
      p: this.formatUTCPeriod,
      S: this.formatUTCSeconds,
      Y: this.formatUTCFullYear
    }, this.parseShortWeekday = (d2, string, i2) => {
      const n2 = this.shortWeekdayRe.exec(string.slice(i2));
      return n2 ? (d2.w = this.shortWeekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseWeekday = (d2, string, i2) => {
      const n2 = this.weekdayRe.exec(string.slice(i2));
      return n2 ? (d2.w = this.weekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseShortMonth = (d2, string, i2) => {
      const n2 = this.shortMonthRe.exec(string.slice(i2));
      return n2 ? (d2.m = this.shortMonthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseMonth = (d2, string, i2) => {
      const n2 = this.monthRe.exec(string.slice(i2));
      return n2 ? (d2.m = this.monthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseDayOfMonth = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.d = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseHour24 = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.H = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseMilliseconds = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 3));
      return n2 ? (d2.L = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseMonthNumber = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.m = n2 - 1, i2 + n2[0].length) : -1;
    }, this.parseMinutes = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.M = +n2[0], i2 + n2[0].length) : -1;
    }, this.parsePeriod = (d2, string, i2) => {
      const n2 = this.periodRe.exec(string.slice(i2));
      return n2 ? (d2.p = this.periodLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseSeconds = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.S = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseFullYear = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 4));
      return n2 ? (d2.y = +n2[0], i2 + n2[0].length) : -1;
    }, this.parses = {
      a: this.parseShortWeekday,
      A: this.parseWeekday,
      b: this.parseShortMonth,
      B: this.parseMonth,
      d: this.parseDayOfMonth,
      e: this.parseDayOfMonth,
      H: this.parseHour24,
      I: this.parseHour24,
      L: this.parseMilliseconds,
      m: this.parseMonthNumber,
      M: this.parseMinutes,
      p: this.parsePeriod,
      S: this.parseSeconds,
      Y: this.parseFullYear
    }, this.timeFormat = (specifier, timeText) => this.newFormat(specifier, this.formats)(new Date(this.getFullTimeStamp(timeText))), this.timeUTCFormat = (specifier, timeText) => this.newFormat(specifier, this.utcFormats)(new Date(this.getFullTimeStamp(timeText))), this.timeParse = (specifier, timeText) => this.newParse(specifier, false)(timeText + ""), this.requoteF = this.requote.bind(this), this.periodRe = this.formatRe(this.locale_periods), this.periodLookup = this.formatLookup(this.locale_periods), this.weekdayRe = this.formatRe(this.locale_weekdays), this.weekdayLookup = this.formatLookup(this.locale_weekdays), this.shortWeekdayRe = this.formatRe(this.locale_shortWeekdays), this.shortWeekdayLookup = this.formatLookup(this.locale_shortWeekdays), this.monthRe = this.formatRe(this.locale_months), this.monthLookup = this.formatLookup(this.locale_months), this.shortMonthRe = this.formatRe(this.locale_shortMonths), this.shortMonthLookup = this.formatLookup(this.locale_shortMonths);
  }
  requote(s2) {
    return s2.replace(this.requoteRe, "\\$&");
  }
  localDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      const date = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
      return date.setFullYear(d2.y), date;
    }
    return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
  }
  utcDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      const date = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
      return date.setUTCFullYear(d2.y), date;
    }
    return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
  }
  newDate(y3, m2, d2) {
    return {
      y: y3,
      m: m2,
      d: d2,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }
  formatRe(names) {
    return new RegExp("^(?:" + names.map(this.requoteF).join("|") + ")", "i");
  }
  formatLookup(names) {
    return new Map(names.map((name2, i2) => [name2.toLowerCase(), i2]));
  }
  pad(value2, fill, width2) {
    const sign3 = value2 < 0 ? "-" : "", string = (sign3 ? -value2 : value2) + "", length2 = string.length;
    return sign3 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
  }
  parseSpecifier(d2, specifier, string, j2) {
    let i2 = 0;
    const n2 = specifier.length, m2 = string.length;
    let c2, parse;
    for (; i2 < n2; ) {
      if (j2 >= m2) return -1;
      if (c2 = specifier.charCodeAt(i2++), 37 === c2) {
        if (c2 = specifier.charAt(i2++), parse = this.parses[c2 in this.pads ? specifier.charAt(i2++) : c2], !parse || (j2 = parse(d2, string, j2)) < 0) return -1;
      } else if (c2 !== string.charCodeAt(j2++)) return -1;
    }
    return j2;
  }
  newParse(specifier, Z3) {
    const that = this;
    return function(string) {
      const d2 = that.newDate(1900, void 0, 1);
      return that.parseSpecifier(d2, specifier, string += "", 0) !== string.length ? null : "Q" in d2 ? new Date(d2.Q) : "s" in d2 ? new Date(1e3 * d2.s + ("L" in d2 ? d2.L : 0)) : (Z3 && !("Z" in d2) && (d2.Z = 0), "p" in d2 && (d2.H = d2.H % 12 + 12 * d2.p), void 0 === d2.m && (d2.m = "q" in d2 ? d2.q : 0), "Z" in d2 ? (d2.H += d2.Z / 100 | 0, d2.M += d2.Z % 100, that.utcDate(d2)) : that.localDate(d2));
    };
  }
  newFormat(specifier, formats) {
    const that = this;
    return function(date) {
      const string = [];
      let i2 = -1, j2 = 0;
      const n2 = specifier.length;
      let c2, pad2, format;
      for (date instanceof Date || (date = /* @__PURE__ */ new Date(+date)); ++i2 < n2; ) 37 === specifier.charCodeAt(i2) && (string.push(specifier.slice(j2, i2)), (pad2 = that.pads[c2 = specifier.charAt(++i2)]) ? c2 = specifier.charAt(++i2) : pad2 = "e" === c2 ? " " : "0", format = formats[c2], c2 = format(date, pad2), string.push(c2), j2 = i2 + 1);
      return string.push(specifier.slice(j2, i2)), string.join("");
    };
  }
  getFullTimeStamp(timeText) {
    const timeOriStamp = parseInt(timeText + "", 10);
    return 10 === String(timeOriStamp).length ? 1e3 * timeOriStamp : timeOriStamp;
  }
};

// node_modules/@visactor/vutils/es/format/number/specifier.js
var FormatSpecifier = class {
  constructor(specifier = {}) {
    this.fill = void 0 === specifier.fill ? " " : specifier.fill + "", this.align = void 0 === specifier.align ? ">" : specifier.align + "", this.sign = void 0 === specifier.sign ? "-" : specifier.sign + "", this.symbol = void 0 === specifier.symbol ? "" : specifier.symbol + "", this.zero = !!specifier.zero, this.width = void 0 === specifier.width ? void 0 : +specifier.width, this.comma = !!specifier.comma, this.precision = void 0 === specifier.precision ? void 0 : +specifier.precision, this.trim = !!specifier.trim, this.type = void 0 === specifier.type ? "" : specifier.type + "";
  }
  toString() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
  }
};
var numberSpecifierReg = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  let match;
  if (match = numberSpecifierReg.exec(specifier)) return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
  Logger.getInstance().error("invalid format: " + specifier);
}

// node_modules/@visactor/vutils/es/format/number/formatDecimal.js
function formatDecimal(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p2) {
  const _x = p2 ? x3.toExponential(p2 - 1) : x3.toExponential(), i2 = _x.indexOf("e");
  if (i2 < 0) return null;
  const coefficient = _x.slice(0, i2);
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +_x.slice(i2 + 1)];
}

// node_modules/@visactor/vutils/es/format/number/formatGroup.js
function formatGroup(grouping, thousands) {
  return function(value2, width2) {
    let i2 = value2.length;
    const t2 = [];
    let j2 = 0, g3 = grouping[0], length2 = 0;
    for (; i2 > 0 && g3 > 0 && (length2 + g3 + 1 > width2 && (g3 = Math.max(1, width2 - length2)), t2.push(value2.substring(i2 -= g3, i2 + g3)), !((length2 += g3 + 1) > width2)); ) g3 = grouping[j2 = (j2 + 1) % grouping.length];
    return t2.reverse().join(thousands);
  };
}

// node_modules/@visactor/vutils/es/format/number/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto(x3, p2) {
  const d2 = formatDecimalParts(x3, p2);
  if (!d2) return x3 + "";
  const coefficient = d2[0], exponent2 = d2[1], i2 = exponent2 - (prefixExponent = 3 * Math.max(-8, Math.min(8, Math.floor(exponent2 / 3)))) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i2 - 1))[0];
}

// node_modules/@visactor/vutils/es/format/number/formatRounded.js
function formatRounded(x3, p2) {
  const d2 = formatDecimalParts(x3, p2);
  if (!d2) return x3 + "";
  const coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}

// node_modules/@visactor/vutils/es/format/number/formatTrim.js
function formatTrim(s2) {
  const n2 = s2.length;
  let i1, i0 = -1;
  out: for (let i2 = 1; i2 < n2; ++i2) switch (s2[i2]) {
    case ".":
      i0 = i1 = i2;
      break;
    case "0":
      0 === i0 && (i0 = i2), i1 = i2;
      break;
    default:
      if (!+s2[i2]) break out;
      i0 > 0 && (i0 = 0);
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/@visactor/vutils/es/format/number/number.js
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
var NumberUtil = class _NumberUtil {
  constructor() {
    this.locale = {
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    }, this.group = void 0 === this.locale.grouping || void 0 === this.locale.thousands ? (group) => group : formatGroup([...this.locale.grouping].map(Number), `${this.locale.thousands}`), this.currencyPrefix = void 0 === this.locale.currency ? "" : this.locale.currency[0] + "", this.currencySuffix = void 0 === this.locale.currency ? "" : this.locale.currency[1] + "", this.decimal = void 0 === this.locale.decimal ? "." : this.locale.decimal + "", this.numerals = void 0 === this.locale.numerals ? (numerals) => numerals : formatNumerals([...this.locale.numerals].map(String)), this.percent = void 0 === this.locale.percent ? "%" : this.locale.percent + "", this.minus = void 0 === this.locale.minus ? "−" : this.locale.minus + "", this.nan = void 0 === this.locale.nan ? "NaN" : this.locale.nan + "", this.formatter = (specifier) => this.newFormat(specifier), this.format = (specifier, value2) => this.formatter(specifier)(value2), this.formatPrefix = (specifier, value2) => this._formatPrefix(specifier, value2);
  }
  static getInstance() {
    return _NumberUtil.instance || (_NumberUtil.instance = new _NumberUtil()), _NumberUtil.instance;
  }
  newFormat(specifier) {
    const specifierIns = formatSpecifier(specifier);
    let fill = specifierIns.fill, align = specifierIns.align;
    const sign3 = specifierIns.sign, symbol = specifierIns.symbol;
    let zero2 = specifierIns.zero;
    const width2 = specifierIns.width;
    let comma = specifierIns.comma, precision = specifierIns.precision, trim = specifierIns.trim, type = specifierIns.type;
    "n" === type ? (comma = true, type = "g") : formatTypes[type] || (void 0 === precision && (precision = 12), trim = true, type = "g"), (zero2 || "0" === fill && "=" === align) && (zero2 = true, fill = "0", align = "=");
    const prefix = "$" === symbol ? this.currencyPrefix : "#" === symbol && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = "$" === symbol ? this.currencySuffix : /[%p]/.test(type) ? this.percent : "", formatType = formatTypes[type], maybeSuffix = /[defgprstz%]/.test(type);
    precision = void 0 === precision ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    const { nan, minus, decimal, group, numerals } = this;
    function format(value2) {
      let i2, n2, c2, valuePrefix = prefix, valueSuffix = suffix, _value = value2;
      if ("c" === type) valueSuffix = formatType(_value) + valueSuffix, _value = "";
      else {
        _value = +_value;
        let valueNegative = _value < 0 || 1 / _value < 0;
        if (_value = isNaN(_value) ? nan : formatType(Math.abs(_value), precision), trim && (_value = formatTrim(_value)), valueNegative && 0 == +_value && "+" !== sign3 && (valueNegative = false), valuePrefix = (valueNegative ? "(" === sign3 ? sign3 : minus : "-" === sign3 || "(" === sign3 ? "" : sign3) + valuePrefix, valueSuffix = ("s" === type ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && "(" === sign3 ? ")" : ""), maybeSuffix) {
          for (i2 = -1, n2 = _value.length; ++i2 < n2; ) if (c2 = _value.charCodeAt(i2), 48 > c2 || c2 > 57) {
            valueSuffix = (46 === c2 ? decimal + _value.slice(i2 + 1) : _value.slice(i2)) + valueSuffix, _value = _value.slice(0, i2);
            break;
          }
        }
      }
      comma && !zero2 && (_value = group(_value, 1 / 0));
      let length2 = valuePrefix.length + _value.length + valueSuffix.length, padding = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      switch (comma && zero2 && (_value = group(padding + _value, padding.length ? width2 - valueSuffix.length : 1 / 0), padding = ""), align) {
        case "<":
          _value = valuePrefix + _value + valueSuffix + padding;
          break;
        case "=":
          _value = valuePrefix + padding + _value + valueSuffix;
          break;
        case "^":
          _value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + _value + valueSuffix + padding.slice(length2);
          break;
        default:
          _value = padding + valuePrefix + _value + valueSuffix;
      }
      return numerals(_value);
    }
    return format.toString = function() {
      return specifier + "";
    }, format;
  }
  _formatPrefix(specifier, value2) {
    const _specifier = formatSpecifier(specifier);
    _specifier.type = "f";
    const f2 = this.newFormat(_specifier.toString()), e3 = 3 * Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))), k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value3) {
      return f2(k2 * value3) + prefix;
    };
  }
};
var formatTypes = {
  "%": (x3, p2) => (100 * x3).toFixed(p2),
  b: (x3) => Math.round(x3).toString(2),
  c: (x3) => x3 + "",
  d: formatDecimal,
  f: (x3, p2) => x3.toFixed(p2),
  e: (x3, p2) => x3.toExponential(p2),
  g: (x3, p2) => x3.toPrecision(p2),
  o: (x3) => Math.round(x3).toString(8),
  p: (x3, p2) => formatRounded(100 * x3, p2),
  r: formatRounded,
  s: formatPrefixAuto,
  X: (x3) => Math.round(x3).toString(16).toUpperCase(),
  x: (x3) => Math.round(x3).toString(16),
  t: (x3, p2) => Number.isInteger(x3) ? x3.toFixed(2) : Math.floor(x3 * Math.pow(10, p2)) / Math.pow(10, p2) + "",
  z: (x3, p2) => x3 % 1 == 0 ? x3 + "" : x3.toFixed(p2)
};
function exponent(x3) {
  const _x = formatDecimalParts(Math.abs(x3));
  return _x ? _x[1] : NaN;
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, (i2) => numerals[+i2]);
  };
}

// node_modules/@visactor/vutils/es/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/@visactor/vutils/es/lru.js
var LRU = class {
  constructor() {
    this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
  }
  clearCache(cache, params) {
    const { CLEAN_THRESHOLD = this.CLEAN_THRESHOLD, L_TIME = this.L_TIME, R_COUNT = this.R_COUNT } = params;
    if (cache.size < CLEAN_THRESHOLD) return 0;
    let clearNum = 0;
    const clear = (key2) => {
      clearNum++, cache.delete(key2);
    }, now = Date.now();
    return cache.forEach((item, key2) => {
      if (item.timestamp.length < R_COUNT) return clear(key2);
      let useCount = 0;
      for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)); ) ;
      if (useCount < R_COUNT) return clear(key2);
      for (; now - item.timestamp[0] > L_TIME; ) item.timestamp.shift();
    }), clearNum;
  }
  addLimitedTimestamp(cacheItem, t2, params) {
    const { R_TIMESTAMP_MAX_SIZE = this.R_TIMESTAMP_MAX_SIZE } = params;
    cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t2);
  }
  clearTimeStamp(cache, params) {
    const { L_TIME = this.L_TIME } = params, now = Date.now();
    cache.forEach((item) => {
      for (; now - item.timestamp[0] > L_TIME; ) item.timestamp.shift();
    });
  }
  clearItemTimestamp(cacheItem, params) {
    const { L_TIME = this.L_TIME } = params, now = Date.now();
    for (; now - cacheItem.timestamp[0] > L_TIME; ) cacheItem.timestamp.shift();
  }
};

// node_modules/@visactor/vutils/es/time/interval.js
var SECOND = 1e3;
var MINUTE = 6e4;
var HOUR = 36e5;
var DAY = 24 * HOUR;
var MONTH = 31 * DAY;
var YEAR = 365 * DAY;

// node_modules/@turf/helpers/dist/es/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function lengthToRadians(distance, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance / factor;
}
function isObject2(input) {
  return !!input && input.constructor === Object;
}

// node_modules/@visactor/vutils/es/geo/invariant.js
function getGeom(geojson) {
  return "Feature" === geojson.type ? geojson.geometry : geojson;
}
function isPointInPolygon(point2, polygon) {
  if (!point2) return false;
  if (!polygon) return false;
  const geom = getGeom(polygon), type = geom.type, bbox = polygon.bbox;
  let polys = geom.coordinates;
  if (bbox && true === pointInRect(point2, {
    x1: bbox[0],
    x2: bbox[1],
    y1: bbox[1],
    y2: bbox[3]
  }, true)) return false;
  "Polygon" === type && (polys = [polys]);
  let result = false;
  for (let i2 = 0; i2 < polys.length; ++i2) for (let j2 = 0; j2 < polys[i2].length; ++j2) {
    if (polygonContainPoint(polys[i2][j2].map((p2) => ({
      x: p2[0],
      y: p2[1]
    })), point2.x, point2.y)) return result = true, result;
  }
  return result;
}
function destination(point2, distance, bearing, options = {}) {
  const longitude1 = degreeToRadian(point2[0]), latitude1 = degreeToRadian(point2[1]), bearingRad = degreeToRadian(bearing), radians2 = lengthToRadians(distance, options.units), latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad)), longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
  return {
    x: radianToDegree(longitude2),
    y: radianToDegree(latitude2)
  };
}

// node_modules/@visactor/vutils/es/geo/constant.js
var SMALL = 1e-10;

// node_modules/@visactor/vutils/es/geo/circle-intersection.js
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles), innerPoints = intersectionPoints.filter(function(p2) {
    return containedInCircles(p2, circles);
  });
  let arcArea = 0, polygonArea = 0;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center = getCenter(innerPoints);
    for (let i2 = 0; i2 < innerPoints.length; ++i2) {
      const p3 = innerPoints[i2];
      p3.angle = Math.atan2(p3.x - center.x, p3.y - center.y);
    }
    innerPoints.sort(function(a2, b2) {
      return b2.angle - a2.angle;
    });
    let p2 = innerPoints[innerPoints.length - 1];
    for (let i2 = 0; i2 < innerPoints.length; ++i2) {
      const p1 = innerPoints[i2];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      const midPoint = {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      };
      let arc = null;
      for (let j2 = 0; j2 < p1.parentIndex.length; ++j2) if (p2.parentIndex.indexOf(p1.parentIndex[j2]) > -1) {
        const circle2 = circles[p1.parentIndex[j2]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a2 = Math.atan2(p2.x - circle2.x, p2.y - circle2.y);
        let angleDiff = a2 - a1;
        angleDiff < 0 && (angleDiff += 2 * Math.PI);
        const a3 = a2 - angleDiff / 2;
        let width2 = PointService.distancePP(midPoint, {
          x: circle2.x + circle2.radius * Math.sin(a3),
          y: circle2.y + circle2.radius * Math.cos(a3)
        });
        width2 > 2 * circle2.radius && (width2 = 2 * circle2.radius), (null === arc || arc.width > width2) && (arc = {
          circle: circle2,
          width: width2,
          p1,
          p2
        });
      }
      null !== arc && (arcs.push(arc), arcArea += circleArea(arc.circle.radius, arc.width), p2 = p1);
    }
  } else {
    let smallest = circles[0];
    for (let i2 = 1; i2 < circles.length; ++i2) circles[i2].radius < smallest.radius && (smallest = circles[i2]);
    let disjoint = false;
    for (let i2 = 0; i2 < circles.length; ++i2) if (PointService.distancePP(circles[i2], smallest) > Math.abs(smallest.radius - circles[i2].radius)) {
      disjoint = true;
      break;
    }
    disjoint ? arcArea = polygonArea = 0 : (arcArea = smallest.radius * smallest.radius * Math.PI, arcs.push({
      circle: smallest,
      p1: {
        x: smallest.x,
        y: smallest.y + smallest.radius
      },
      p2: {
        x: smallest.x - SMALL,
        y: smallest.y + smallest.radius
      },
      width: 2 * smallest.radius
    }));
  }
  return polygonArea /= 2, stats && (stats.area = arcArea + polygonArea, stats.arcArea = arcArea, stats.polygonArea = polygonArea, stats.arcs = arcs, stats.innerPoints = innerPoints, stats.intersectionPoints = intersectionPoints), arcArea + polygonArea;
}
function containedInCircles(point2, circles) {
  for (let i2 = 0; i2 < circles.length; ++i2) if (PointService.distancePP(point2, circles[i2]) > circles[i2].radius + SMALL) return false;
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i2 = 0; i2 < circles.length; ++i2) for (let j2 = i2 + 1; j2 < circles.length; ++j2) {
    const intersect = circleCircleIntersection(circles[i2], circles[j2]);
    for (let k2 = 0; k2 < intersect.length; ++k2) {
      const p2 = intersect[k2];
      p2.parentIndex = [i2, j2], ret.push(p2);
    }
  }
  return ret;
}
function circleArea(r2, width2) {
  return r2 * r2 * Math.acos(1 - width2 / r2) - (r2 - width2) * Math.sqrt(width2 * (2 * r2 - width2));
}
function circleOverlap(r1, r2, d2) {
  if (d2 >= r1 + r2) return 0;
  if (d2 <= Math.abs(r1 - r2)) return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  const w2 = r2 - (d2 * d2 - r1 * r1 + r2 * r2) / (2 * d2);
  return circleArea(r1, r1 - (d2 * d2 - r2 * r2 + r1 * r1) / (2 * d2)) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  const d2 = PointService.distancePP(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d2 >= r1 + r2 || d2 <= Math.abs(r1 - r2)) return [];
  const a2 = (r1 * r1 - r2 * r2 + d2 * d2) / (2 * d2), h2 = Math.sqrt(r1 * r1 - a2 * a2), x05 = p1.x + a2 * (p2.x - p1.x) / d2, y05 = p1.y + a2 * (p2.y - p1.y) / d2, rx = -(p2.y - p1.y) * (h2 / d2), ry = -(p2.x - p1.x) * (h2 / d2);
  return [{
    x: x05 + rx,
    y: y05 - ry
  }, {
    x: x05 - rx,
    y: y05 + ry
  }];
}
function getCenter(points) {
  const center = {
    x: 0,
    y: 0
  };
  for (let i2 = 0; i2 < points.length; ++i2) center.x += points[i2].x, center.y += points[i2].y;
  return center.x /= points.length, center.y /= points.length, center;
}

// node_modules/@visactor/vutils/es/fmin/blas1.js
function zeros(x3) {
  const r2 = new Array(x3);
  for (let i2 = 0; i2 < x3; ++i2) r2[i2] = 0;
  return r2;
}
function zerosM(x3, y3) {
  return zeros(x3).map(function() {
    return zeros(y3);
  });
}
function norm2(a2) {
  return Math.sqrt(dotProduct(a2, a2));
}
function scale2(ret, value2, c2) {
  for (let i2 = 0; i2 < value2.length; ++i2) ret[i2] = value2[i2] * c2;
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (let j2 = 0; j2 < ret.length; ++j2) ret[j2] = w1 * v1[j2] + w2 * v2[j2];
}

// node_modules/@visactor/vutils/es/fmin/nelder-mead.js
function nelderMead(f2, x05, parameters) {
  const maxIterations = (parameters = parameters || {}).maxIterations || 200 * x05.length, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = void 0 !== parameters.rho ? parameters.rho : 1, chi = void 0 !== parameters.chi ? parameters.chi : 2, psi = void 0 !== parameters.psi ? parameters.psi : -0.5, sigma = void 0 !== parameters.sigma ? parameters.sigma : 0.5;
  let maxDiff;
  const N2 = x05.length, simplex = new Array(N2 + 1);
  simplex[0] = x05, simplex[0].fx = f2(x05), simplex[0].id = 0;
  for (let i2 = 0; i2 < N2; ++i2) {
    const point2 = x05.slice();
    point2[i2] = point2[i2] ? point2[i2] * nonZeroDelta : zeroDelta, simplex[i2 + 1] = point2, simplex[i2 + 1].fx = f2(point2), simplex[i2 + 1].id = i2 + 1;
  }
  function updateSimplex(value2) {
    for (let i2 = 0; i2 < value2.length; i2++) simplex[N2][i2] = value2[i2];
    simplex[N2].fx = value2.fx;
  }
  const sortOrder = function(a2, b2) {
    return a2.fx - b2.fx;
  }, centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
  for (let iteration = 0; iteration < maxIterations; ++iteration) {
    if (simplex.sort(sortOrder), parameters.history) {
      const sortedSimplex = simplex.map(function(x3) {
        const state = x3.slice();
        return state.fx = x3.fx, state.id = x3.id, state;
      });
      sortedSimplex.sort(function(a2, b2) {
        return a2.id - b2.id;
      }), parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (let i2 = 0; i2 < N2; ++i2) maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i2] - simplex[1][i2]));
    if (Math.abs(simplex[0].fx - simplex[N2].fx) < minErrorDelta && maxDiff < minTolerance) break;
    for (let i2 = 0; i2 < N2; ++i2) {
      centroid[i2] = 0;
      for (let j2 = 0; j2 < N2; ++j2) centroid[i2] += simplex[j2][i2];
      centroid[i2] /= N2;
    }
    const worst = simplex[N2];
    if (weightedSum(reflected, 1 + rho, centroid, -rho, worst), reflected.fx = f2(reflected), reflected.fx < simplex[0].fx) weightedSum(expanded, 1 + chi, centroid, -chi, worst), expanded.fx = f2(expanded), expanded.fx < reflected.fx ? updateSimplex(expanded) : updateSimplex(reflected);
    else if (reflected.fx >= simplex[N2 - 1].fx) {
      let shouldReduce = false;
      if (reflected.fx > worst.fx ? (weightedSum(contracted, 1 + psi, centroid, -psi, worst), contracted.fx = f2(contracted), contracted.fx < worst.fx ? updateSimplex(contracted) : shouldReduce = true) : (weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst), contracted.fx = f2(contracted), contracted.fx < reflected.fx ? updateSimplex(contracted) : shouldReduce = true), shouldReduce) {
        if (sigma >= 1) break;
        for (let i2 = 1; i2 < simplex.length; ++i2) weightedSum(simplex[i2], 1 - sigma, simplex[0], sigma, simplex[i2]), simplex[i2].fx = f2(simplex[i2]);
      }
    } else updateSimplex(reflected);
  }
  return simplex.sort(sortOrder), {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}

// node_modules/@visactor/vutils/es/fmin/linesearch.js
function wolfeLineSearch(f2, pk, current, next, a2, c1, c2) {
  const phi0 = current.fx, phiPrime0 = dotProduct(current.fxprime, pk);
  let phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  function zoom(a_lo, a_high, phi_lo) {
    for (let iteration = 0; iteration < 16; ++iteration) if (a2 = (a_lo + a_high) / 2, weightedSum(next.x, 1, current.x, a2, pk), phi2 = next.fx = f2(next.x, next.fxprime), phiPrime = dotProduct(next.fxprime, pk), phi2 > phi0 + c1 * a2 * phiPrime0 || phi2 >= phi_lo) a_high = a2;
    else {
      if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a2;
      phiPrime * (a_high - a_lo) >= 0 && (a_high = a_lo), a_lo = a2, phi_lo = phi2;
    }
    return 0;
  }
  a2 = a2 || 1, c1 = c1 || 1e-6, c2 = c2 || 0.1;
  for (let iteration = 0; iteration < 10; ++iteration) {
    if (weightedSum(next.x, 1, current.x, a2, pk), phi2 = next.fx = f2(next.x, next.fxprime), phiPrime = dotProduct(next.fxprime, pk), phi2 > phi0 + c1 * a2 * phiPrime0 || iteration && phi2 >= phi_old) return zoom(a0, a2, phi_old);
    if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a2;
    if (phiPrime >= 0) return zoom(a2, a0, phi2);
    phi_old = phi2, a0 = a2, a2 *= 2;
  }
  return a2;
}

// node_modules/@visactor/vutils/es/fmin/conjugate-gradient.js
function conjugateGradient(f2, initial, params) {
  let current = {
    x: initial.slice(),
    fx: 0,
    fxprime: initial.slice()
  }, next = {
    x: initial.slice(),
    fx: 0,
    fxprime: initial.slice()
  };
  const yk = initial.slice();
  let temp2, a2 = 1;
  const maxIterations = (params = params || {}).maxIterations || 20 * initial.length;
  current.fx = f2(current.x, current.fxprime);
  const pk = current.fxprime.slice();
  scale2(pk, current.fxprime, -1);
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    if (a2 = wolfeLineSearch(f2, pk, current, next, a2), params.history && params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a2
    }), a2) {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      const delta_k = dotProduct(current.fxprime, current.fxprime), beta_k = Math.max(0, dotProduct(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime), temp2 = current, current = next, next = temp2;
    } else scale2(pk, current.fxprime, -1);
    if (norm2(current.fxprime) <= 1e-5) break;
  }
  return params.history && params.history.push({
    x: current.x.slice(),
    fx: current.fx,
    fxprime: current.fxprime.slice(),
    alpha: a2
  }), current;
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i2) {
    return JSON.stringify(name2) + ": d[" + i2 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object2 = objectConverter(columns);
  return function(row, i2) {
    return f2(object2(row), i2, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value2, width2) {
  var s2 = value2 + "", length2 = s2.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text2, f2) {
    var convert, columns, rows = parseRows(text2, function(row, i2) {
      if (convert) return convert(row, i2 - 1);
      columns = row, convert = f2 ? customConverter(row, f2) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f2) {
    var rows = [], N2 = text2.length, I2 = 0, n2 = 0, t2, eof = N2 <= 0, eol = false;
    if (text2.charCodeAt(N2 - 1) === NEWLINE) --N2;
    if (text2.charCodeAt(N2 - 1) === RETURN) --N2;
    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i2, j2 = I2, c2;
      if (text2.charCodeAt(j2) === QUOTE) {
        while (I2++ < N2 && text2.charCodeAt(I2) !== QUOTE || text2.charCodeAt(++I2) === QUOTE) ;
        if ((i2 = I2) >= N2) eof = true;
        else if ((c2 = text2.charCodeAt(I2++)) === NEWLINE) eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I2) === NEWLINE) ++I2;
        }
        return text2.slice(j2 + 1, i2 - 1).replace(/""/g, '"');
      }
      while (I2 < N2) {
        if ((c2 = text2.charCodeAt(i2 = I2++)) === NEWLINE) eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I2) === NEWLINE) ++I2;
        } else if (c2 !== DELIMITER) continue;
        return text2.slice(j2, i2);
      }
      return eof = true, text2.slice(j2, N2);
    }
    while ((t2 = token()) !== EOF) {
      var row = [];
      while (t2 !== EOL && t2 !== EOF) row.push(t2), t2 = token();
      if (f2 && (row = f2(row, n2++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/d3-hexbin/src/hexbin.js
var thirdPi = Math.PI / 3;
var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

// node_modules/d3-geo/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i2 = -1, n2 = features.length;
    while (++i2 < n2) streamGeometry(features[i2].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) object2 = coordinates[i2], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamLine(coordinates[i2], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamPolygon(coordinates[i2], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i2 = -1, n2 = geometries.length;
    while (++i2 < n2) streamGeometry(geometries[i2], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i2 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2) coordinate = coordinates[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i2 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i2 < n2) streamLine(coordinates[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// node_modules/d3-geo/src/adder.js
function adder_default() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(y3) {
    add2(temp, y3, this.t);
    add2(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add2(adder, a2, b2) {
  var x3 = adder.s = a2 + b2, bv = x3 - a2, av = x3 - bv;
  adder.t = a2 - av + (b2 - bv);
}

// node_modules/d3-geo/src/math.js
var epsilon2 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau2 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log2 = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
}
function asin2(x3) {
  return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/path/area.js
var areaSum = adder_default();
var areaRingSum = adder_default();
var x00;
var y00;
var x0;
var y0;
var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;
    areaSum.add(abs2(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x3, y3) {
  areaStream.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y3;
}
function areaPoint(x3, y3) {
  areaRingSum.add(y0 * x3 - x0 * y3);
  x0 = x3, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x12 = -x02;
var y12 = x12;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x12, y12]];
    x12 = y12 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y3) {
  if (x3 < x02) x02 = x3;
  if (x3 > x12) x12 = x3;
  if (y3 < y02) y02 = y3;
  if (y3 > y12) y12 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y3) {
  X0 += x3;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidPointLine(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z2 = sqrt2(dx * dx + dy * dy);
  X1 += z2 * (x03 + x3) / 2;
  Y1 += z2 * (y03 + y3) / 2;
  Z1 += z2;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
}
function centroidPointRing(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z2 = sqrt2(dx * dx + dy * dy);
  X1 += z2 * (x03 + x3) / 2;
  Y1 += z2 * (y03 + y3) / 2;
  Z1 += z2;
  z2 = y03 * x3 - x03 * y3;
  X2 += z2 * (x03 + x3);
  Y2 += z2 * (y03 + y3);
  Z2 += z2 * 3;
  centroidPoint(x03 = x3, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y3);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y3);
        this._context.arc(x3, y3, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = adder_default();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum.reset();
    return length2;
  }
};
function lengthPointFirst(x3, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y3;
}
function lengthPoint(x3, y3) {
  x04 -= x3, y04 -= y3;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_2) {
    if ((_2 = +_2) !== this._radius) this._radius = _2, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x3, ",", y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x3, ",", y3);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x3, ",", y3, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection2, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path(object2) {
    if (object2) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path.area = function(object2) {
    stream_default(object2, projectionStream(area_default));
    return area_default.result();
  };
  path.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path.projection = function(_2) {
    return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity_default) : (projection2 = _2).stream, path) : projection2;
  };
  path.context = function(_2) {
    if (!arguments.length) return context;
    contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };
  path.pointRadius = function(_2) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path;
  };
  return path.projection(projection2).context(context);
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x3, y3, m2) {
      line.push([x3, y3, m2]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a2, b2) {
  return abs2(a2[0] - b2[0]) < epsilon2 && abs2(a2[1] - b2[1]) < epsilon2;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0) return;
    var n3, p0 = segment[0], p1 = segment[n3], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2) stream.point((p0 = segment[i2])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon2;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points, point2;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points.length; i2 < n2; ++i2) stream.point((point2 = points[i2])[0], point2[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i2 = points.length - 1; i2 >= 0; --i2) stream.point((point2 = points[i2])[0], point2[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array3) {
  if (!(n2 = array3.length)) return;
  var n2, i2 = 0, a2 = array3[0], b2;
  while (++i2 < n2) {
    a2.n = b2 = array3[i2];
    b2.p = a2;
    a2 = b2;
  }
  a2.n = b2 = array3[0];
  b2.p = a2;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cartesianCross(a2, b2) {
  return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
}
function cartesianAddInPlace(a2, b2) {
  a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d2) {
  var l2 = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
}

// node_modules/d3-geo/src/polygonContains.js
var sum2 = adder_default();
function longitude(point2) {
  if (abs2(point2[0]) <= pi3)
    return point2[0];
  else
    return sign(point2[0]) * ((abs2(point2[0]) + pi3) % tau2 - pi3);
}
function polygonContains_default(polygon, point2) {
  var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle = 0, winding = 0;
  sum2.reset();
  if (sinPhi === 1) phi2 = halfPi2 + epsilon2;
  else if (sinPhi === -1) phi2 = -halfPi2 - epsilon2;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m2 = (ring = polygon[i2]).length)) continue;
    var ring, m2, point0 = ring[m2 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j2 = 0; j2 < m2; ++j2, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum2.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle += antimeridian ? delta + sign3 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon2 || angle < epsilon2 && sum2 < -epsilon2) ^ winding & 1;
}

// node_modules/d3-array/src/ascending.js
function ascending_default(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(compare2) {
  if (compare2.length === 1) compare2 = ascendingComparator(compare2);
  return {
    left: function(a2, x3, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a2[mid], x3) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a2, x3, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a2[mid], x3) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f2) {
  return function(d2, x3) {
    return ascending_default(f2(d2), x3);
  };
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

// node_modules/d3-array/src/array.js
var array2 = Array.prototype;
var slice = array2.slice;
var map = array2.map;

// node_modules/d3-array/src/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);

// node_modules/d3-array/src/merge.js
function merge_default(arrays) {
  var n2 = arrays.length, m2, i2 = -1, j2 = 0, merged, array3;
  while (++i2 < n2) j2 += arrays[i2].length;
  merged = new Array(j2);
  while (--n2 >= 0) {
    array3 = arrays[n2];
    m2 = array3.length;
    while (--m2 >= 0) {
      merged[--j2] = array3[m2];
    }
  }
  return merged;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point2;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge_default(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point2;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m2, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m2; ++i2) sink.point((point3 = segment[i2])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b2) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi2 - epsilon2 : halfPi2 - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi2 - epsilon2 : halfPi2 - b2[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon2) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon2) lambda0 -= sign0 * epsilon2;
        if (abs2(lambda1 - sign1) < epsilon2) lambda1 -= sign1 * epsilon2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon2 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon2) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/compose.js
function compose_default(a2, b2) {
  function compose(x3, y3) {
    return x3 = a2(x3, y3), b2(x3[0], x3[1]);
  }
  if (a2.invert && b2.invert) compose.invert = function(x3, y3) {
    return x3 = b2.invert(x3, y3), x3 && a2.invert(x3[0], x3[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau2) * tau2 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau2 : lambda < -pi3 ? lambda + tau2 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation2 = forwardRotationLambda(deltaLambda);
  rotation2.invert = forwardRotationLambda(-deltaLambda);
  return rotation2;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation2(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k2 = z2 * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan22(y3 * cosDeltaGamma - k2 * sinDeltaGamma, x3 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation2.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k2 = z2 * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan22(y3 * cosDeltaGamma + z2 * sinDeltaGamma, x3 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation2;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau2;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau2;
  }
  for (var point2, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
    point2 = spherical([cosRadius, -sinRadius * cos2(t2), -sinRadius * sin2(t2)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos2(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau2 - epsilon2) % tau2;
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default(radius) {
  var cr = cos2(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon2;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point2, v2 = visible(lambda, phi2), c2 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t2;
          if (!(c2 & c0) && (t2 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c2;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a2, b2, two) {
    var pa = cartesian(a2), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a2;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t2 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t2 < 0) return;
    var t3 = sqrt2(t2), q2 = cartesianScale(u2, (-w2 - t3) / uu);
    cartesianAddInPlace(q2, A5);
    q2 = spherical(q2);
    if (!two) return q2;
    var lambda0 = a2[0], lambda1 = b2[0], phi0 = a2[1], phi1 = b2[1], z2;
    if (lambda1 < lambda0) z2 = lambda0, lambda0 = lambda1, lambda1 = z2;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon2, meridian = polar || delta2 < epsilon2;
    if (!polar && phi1 < phi0) z2 = phi0, phi0 = phi1, phi1 = z2;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q2[1] < (abs2(q2[0] - lambda0) < epsilon2 ? phi0 : phi1) : phi0 <= q2[1] && q2[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q2[0] && q2[0] <= lambda1)) {
      var q1 = cartesianScale(u2, (-w2 + t3) / uu);
      cartesianAddInPlace(q1, A5);
      return [q2, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r2) code2 |= 1;
    else if (lambda > r2) code2 |= 2;
    if (phi2 < -r2) code2 |= 4;
    else if (phi2 > r2) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a2, b2, x05, y05, x13, y13) {
  var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x05 - ax;
  if (!dx && r2 > 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = x13 - ax;
  if (!dx && r2 < 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  r2 = y05 - ay;
  if (!dy && r2 > 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = y13 - ay;
  if (!dy && r2 < 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  if (t0 > 0) a2[0] = ax + t0 * dx, a2[1] = ay + t0 * dy;
  if (t1 < 1) b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x13, y13) {
  function visible(x3, y3) {
    return x05 <= x3 && x3 <= x13 && y05 <= y3 && y3 <= y13;
  }
  function interpolate(from, to, direction, stream) {
    var a2 = 0, a1 = 0;
    if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a2 === 0 || a2 === 3 ? x05 : x13, a2 > 1 ? y13 : y05);
      while ((a2 = (a2 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs2(p2[0] - x05) < epsilon2 ? direction > 0 ? 0 : 3 : abs2(p2[0] - x13) < epsilon2 ? direction > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon2 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b2) {
    return comparePoint(a2.x, b2.x);
  }
  function comparePoint(a2, b2) {
    var ca = corner(a2, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x3, y3) {
      if (visible(x3, y3)) activeStream.point(x3, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j2 = 1, m2 = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j2 < m2; ++j2) {
          a0 = b0, a1 = b1, point3 = ring2[j2], b0 = point3[0], b1 = point3[1];
          if (a1 <= y13) {
            if (b1 > y13 && (b0 - a0) * (y13 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
          } else {
            if (b1 <= y13 && (b0 - a0) * (y13 - a1) < (b1 - a1) * (x05 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge_default(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x3, y3) {
      var v2 = visible(x3, y3);
      if (polygon) ring.push([x3, y3]);
      if (first) {
        x__ = x3, y__ = y3, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x3, y3);
        }
      } else {
        if (v2 && v_) activeStream.point(x3, y3);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default(a2, b2, x05, y05, x13, y13)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y3, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key2 in methods) s2[key2] = methods[key2];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y3) {
    this.stream.point(x3, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object2) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b2) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x3 = +extent2[0][0] + (w2 - k2 * (b2[1][0] + b2[0][0])) / 2, y3 = +extent2[0][1] + (h2 - k2 * (b2[1][1] + b2[0][1])) / 2;
    projection2.scale(150 * k2).translate([x3, y3]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width2, object2) {
  return fit(projection2, function(b2) {
    var w2 = +width2, k2 = w2 / (b2[1][0] - b2[0][0]), x3 = (w2 - k2 * (b2[1][0] + b2[0][0])) / 2, y3 = -k2 * b2[0][1];
    projection2.scale(150 * k2).translate([x3, y3]);
  }, object2);
}
function fitHeight(projection2, height2, object2) {
  return fit(projection2, function(b2) {
    var h2 = +height2, k2 = h2 / (b2[1][1] - b2[0][1]), x3 = -k2 * b2[0][0], y3 = (h2 - k2 * (b2[1][1] + b2[0][1])) / 2;
    projection2.scale(150 * k2).translate([x3, y3]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x3, y3) {
      x3 = project(x3, y3);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x13, y13, lambda1, a1, b1, c1, depth, stream) {
    var dx = x13 - x05, dy = y13 - y05, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt2(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin2(c2 /= m2), lambda2 = abs2(abs2(c2) - 1) < epsilon2 || abs2(lambda0 - lambda1) < epsilon2 ? (lambda0 + lambda1) / 2 : atan22(b2, a2), p2 = project(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a2 /= m2, b2 /= m2, c2, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a2, b2, c2, x13, y13, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x3, y3) {
      x3 = project(x3, y3);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y3) {
    this.stream.point(x3 * radians, y3 * radians);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x3, y3) {
      var r2 = rotate(x3, y3);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [dx + k2 * x3, dy - k2 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [(x3 - dx) / k2 * sx, (dy - y3) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a2 = cosAlpha * k2, b2 = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [a2 * x3 - b2 * y3 + dx, dy - b2 * x3 - a2 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x3 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x13, y13, postclip = identity_default, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point2) {
    return projectRotateTransform(point2[0] * radians, point2[1] * radians);
  }
  function invert(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x13 = y13 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x13 = y13 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x13 = +_2[1][0], y13 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x13, y13]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
  };
  projection2.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = (alpha ? scaleTranslateRotate : scaleTranslate)(k2, x3 - center[0], y3 - center[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m2 = projectionMutator(projectAt), p2 = m2(phi0, phi1);
  p2.parallels = function(_2) {
    return arguments.length ? m2(phi0 = _2[0] * radians, phi1 = _2[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p2;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x3, y3) {
    return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y13) {
  var sy0 = sin2(y05), n2 = (sy0 + sin2(y13)) / 2;
  if (abs2(n2) < epsilon2) return cylindricalEqualAreaRaw(y05);
  var c2 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c2) / n2;
  function project(x3, y3) {
    var r2 = sqrt2(c2 - 2 * n2 * sin2(y3)) / n2;
    return [r2 * sin2(x3 *= n2), r0 - r2 * cos2(x3)];
  }
  project.invert = function(x3, y3) {
    var r0y = r0 - y3, l2 = atan22(x3, abs2(r0y)) * sign(r0y);
    if (r0y * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(r0y);
    return [l2 / n2, asin2((c2 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x3, y3) {
      var i2 = -1;
      while (++i2 < n2) streams[i2].point(x3, y3);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x3, y3) {
    point2 = [x3, y3];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    return point2 = null, (lower48Point.point(x3, y3), point2) || (alaskaPoint.point(x3, y3), point2) || (hawaiiPoint.point(x3, y3), point2);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t2 = lower48.translate(), x3 = (coordinates[0] - t2[0]) / k2, y3 = (coordinates[1] - t2[1]) / k2;
    return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k2, y3 - 0.238 * k2], [x3 + 0.455 * k2, y3 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k2, y3 + 0.201 * k2]).clipExtent([[x3 - 0.425 * k2 + epsilon2, y3 + 0.12 * k2 + epsilon2], [x3 - 0.214 * k2 - epsilon2, y3 + 0.234 * k2 - epsilon2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k2, y3 + 0.212 * k2]).clipExtent([[x3 - 0.214 * k2 + epsilon2, y3 + 0.166 * k2 + epsilon2], [x3 - 0.115 * k2 - epsilon2, y3 + 0.234 * k2 - epsilon2]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale3) {
  return function(x3, y3) {
    var cx = cos2(x3), cy = cos2(y3), k2 = scale3(cx * cy);
    return [
      k2 * cy * sin2(x3),
      k2 * sin2(y3)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x3, y3) {
    var z2 = sqrt2(x3 * x3 + y3 * y3), c2 = angle(z2), sc = sin2(c2), cc = cos2(c2);
    return [
      atan22(x3 * sc, z2 * cc),
      asin2(z2 && y3 * sc / z2)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
  return 2 * asin2(z2 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos2(c2)) && c2 / sin2(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
  return z2;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log2(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x3, y3) {
  return [x3, 2 * atan(exp(y3)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project) {
  var m2 = projection(project), center = m2.center, scale3 = m2.scale, translate = m2.translate, clipExtent = m2.clipExtent, x05 = null, y05, x13, y13;
  m2.scale = function(_2) {
    return arguments.length ? (scale3(_2), reclip()) : scale3();
  };
  m2.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m2.center = function(_2) {
    return arguments.length ? (center(_2), reclip()) : center();
  };
  m2.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x13 = y13 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x13 = +_2[1][0], y13 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x13, y13]];
  };
  function reclip() {
    var k2 = pi3 * scale3(), t2 = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t2[0] - k2, t2[1] - k2], [t2[0] + k2, t2[1] + k2]] : project === mercatorRaw ? [[Math.max(t2[0] - k2, x05), y05], [Math.min(t2[0] + k2, x13), y13]] : [[x05, Math.max(t2[1] - k2, y05)], [x13, Math.min(t2[1] + k2, y13)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi2 + y3) / 2);
}
function conicConformalRaw(y05, y13) {
  var cy0 = cos2(y05), n2 = y05 === y13 ? sin2(y05) : log2(cy0 / cos2(y13)) / log2(tany(y13) / tany(y05)), f2 = cy0 * pow2(tany(y05), n2) / n2;
  if (!n2) return mercatorRaw;
  function project(x3, y3) {
    if (f2 > 0) {
      if (y3 < -halfPi2 + epsilon2) y3 = -halfPi2 + epsilon2;
    } else {
      if (y3 > halfPi2 - epsilon2) y3 = halfPi2 - epsilon2;
    }
    var r2 = f2 / pow2(tany(y3), n2);
    return [r2 * sin2(n2 * x3), f2 - r2 * cos2(n2 * x3)];
  }
  project.invert = function(x3, y3) {
    var fy = f2 - y3, r2 = sign(n2) * sqrt2(x3 * x3 + fy * fy), l2 = atan22(x3, abs2(fy)) * sign(fy);
    if (fy * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(fy);
    return [l2 / n2, 2 * atan(pow2(f2 / r2, 1 / n2)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y13) {
  var cy0 = cos2(y05), n2 = y05 === y13 ? sin2(y05) : (cy0 - cos2(y13)) / (y13 - y05), g3 = cy0 / n2 + y05;
  if (abs2(n2) < epsilon2) return equirectangularRaw;
  function project(x3, y3) {
    var gy = g3 - y3, nx = n2 * x3;
    return [gy * sin2(nx), g3 - gy * cos2(nx)];
  }
  project.invert = function(x3, y3) {
    var gy = g3 - y3, l2 = atan22(x3, abs2(gy)) * sign(gy);
    if (gy * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(gy);
    return [l2 / n2, g3 - sign(n2) * sqrt2(x3 * x3 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos2(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x3, y3) {
  var l2 = y3, l22 = l2 * l2, l6 = l22 * l22 * l22;
  for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
    fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y3;
    fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
    l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x3 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
    asin2(sin2(l2) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y3) {
  var cy = cos2(y3), k2 = cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default3() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x13, y13, kx = 1, ky = 1, transform2 = transformer({
    point: function(x3, y3) {
      var p2 = projection2([x3, y3]);
      this.stream.point(p2[0], p2[1]);
    }
  }), postclip = identity_default, cache, cacheStream;
  function reset() {
    kx = k2 * sx;
    ky = k2 * sy;
    cache = cacheStream = null;
    return projection2;
  }
  function projection2(p2) {
    var x3 = p2[0] * kx, y3 = p2[1] * ky;
    if (alpha) {
      var t2 = y3 * ca - x3 * sa;
      x3 = x3 * ca + y3 * sa;
      y3 = t2;
    }
    return [x3 + tx, y3 + ty];
  }
  projection2.invert = function(p2) {
    var x3 = p2[0] - tx, y3 = p2[1] - ty;
    if (alpha) {
      var t2 = y3 * ca + x3 * sa;
      x3 = x3 * ca - y3 * sa;
      y3 = t2;
    }
    return [x3 / kx, y3 / ky];
  };
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x13 = y13 = null, reset()) : postclip;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x13 = y13 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x13 = +_2[1][0], y13 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x13, y13]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  return projection2;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x3, y3) {
  var phi2 = y3, i2 = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon2 && --i2 > 0);
  return [
    x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y3) {
  return [cos2(y3) * sin2(x3), sin2(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon2);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y3) {
  var cy = cos2(y3), k2 = 1 + cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z2) {
  return 2 * atan(z2);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log2(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y3) {
  return [-y3, 2 * atan(exp(x3)) - halfPi2];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center = m2.center, rotate = m2.rotate;
  m2.center = function(_2) {
    return arguments.length ? center([-_2[1], _2[0]]) : (_2 = center(), [_2[1], -_2[0]]);
  };
  m2.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/d3-geo/src/area.js
var areaRingSum2 = adder_default();
var areaSum2 = adder_default();

// node_modules/d3-geo/src/bounds.js
var deltaSum = adder_default();

// node_modules/d3-geo/src/length.js
var lengthSum2 = adder_default();

// node_modules/simple-statistics/dist/simple-statistics.mjs
var simple_statistics_exports = {};
__export(simple_statistics_exports, {
  BayesianClassifier: () => BayesianClassifier,
  PerceptronModel: () => PerceptronModel,
  addToMean: () => addToMean,
  approxEqual: () => approxEqual,
  average: () => mean,
  averageSimple: () => meanSimple,
  bayesian: () => BayesianClassifier,
  bernoulliDistribution: () => bernoulliDistribution,
  binomialDistribution: () => binomialDistribution,
  bisect: () => bisect2,
  chiSquaredDistributionTable: () => chiSquaredDistributionTable,
  chiSquaredGoodnessOfFit: () => chiSquaredGoodnessOfFit,
  chunk: () => chunk,
  ckmeans: () => ckmeans,
  coefficientOfVariation: () => coefficientOfVariation,
  combinations: () => combinations,
  combinationsReplacement: () => combinationsReplacement,
  combineMeans: () => combineMeans,
  combineVariances: () => combineVariances,
  cumulativeStdLogisticProbability: () => cumulativeStdLogisticProbability,
  cumulativeStdNormalProbability: () => cumulativeStdNormalProbability,
  epsilon: () => epsilon3,
  equalIntervalBreaks: () => equalIntervalBreaks,
  erf: () => errorFunction,
  errorFunction: () => errorFunction,
  extent: () => extent,
  extentSorted: () => extentSorted,
  factorial: () => factorial,
  gamma: () => gamma,
  gammaln: () => gammaln,
  geometricMean: () => geometricMean,
  harmonicMean: () => harmonicMean,
  interquartileRange: () => interquartileRange,
  inverseErrorFunction: () => inverseErrorFunction,
  iqr: () => interquartileRange,
  jenks: () => jenks,
  kMeansCluster: () => kMeansCluster,
  kde: () => kernelDensityEstimation,
  kernelDensityEstimation: () => kernelDensityEstimation,
  linearRegression: () => linearRegression,
  linearRegressionLine: () => linearRegressionLine,
  logAverage: () => logAverage,
  logit: () => logit,
  mad: () => medianAbsoluteDeviation,
  max: () => max2,
  maxSorted: () => maxSorted,
  mean: () => mean,
  meanSimple: () => meanSimple,
  median: () => median2,
  medianAbsoluteDeviation: () => medianAbsoluteDeviation,
  medianSorted: () => medianSorted,
  min: () => min2,
  minSorted: () => minSorted,
  mode: () => mode,
  modeFast: () => modeFast,
  modeSorted: () => modeSorted,
  numericSort: () => numericSort,
  perceptron: () => PerceptronModel,
  permutationTest: () => permutationTest,
  permutationsHeap: () => permutationsHeap,
  poissonDistribution: () => poissonDistribution,
  probit: () => probit,
  product: () => product,
  quantile: () => quantile,
  quantileRank: () => quantileRank,
  quantileRankSorted: () => quantileRankSorted,
  quantileSorted: () => quantileSorted2,
  quickselect: () => quickselect,
  rSquared: () => rSquared,
  relativeError: () => relativeError,
  rms: () => rootMeanSquare,
  rootMeanSquare: () => rootMeanSquare,
  sample: () => sample,
  sampleCorrelation: () => sampleCorrelation,
  sampleCovariance: () => sampleCovariance,
  sampleKurtosis: () => sampleKurtosis,
  sampleRankCorrelation: () => sampleRankCorrelation,
  sampleSkewness: () => sampleSkewness,
  sampleStandardDeviation: () => sampleStandardDeviation,
  sampleVariance: () => sampleVariance,
  sampleWithReplacement: () => sampleWithReplacement,
  shuffle: () => shuffle,
  shuffleInPlace: () => shuffleInPlace,
  sign: () => sign2,
  silhouette: () => silhouette,
  silhouetteMetric: () => silhouetteMetric,
  standardDeviation: () => standardDeviation,
  standardNormalTable: () => standardNormalTable,
  subtractFromMean: () => subtractFromMean,
  sum: () => sum3,
  sumNthPowerDeviations: () => sumNthPowerDeviations,
  sumSimple: () => sumSimple,
  tTest: () => tTest,
  tTestTwoSample: () => tTestTwoSample,
  uniqueCountSorted: () => uniqueCountSorted,
  variance: () => variance2,
  wilcoxonRankSum: () => wilcoxonRankSum,
  zScore: () => zScore
});
function linearRegression(data2) {
  var m2;
  var b2;
  var dataLength = data2.length;
  if (dataLength === 1) {
    m2 = 0;
    b2 = data2[0][1];
  } else {
    var sumX = 0;
    var sumY = 0;
    var sumXX = 0;
    var sumXY = 0;
    var point2;
    var x3;
    var y3;
    for (var i2 = 0; i2 < dataLength; i2++) {
      point2 = data2[i2];
      x3 = point2[0];
      y3 = point2[1];
      sumX += x3;
      sumY += y3;
      sumXX += x3 * x3;
      sumXY += x3 * y3;
    }
    m2 = (dataLength * sumXY - sumX * sumY) / (dataLength * sumXX - sumX * sumX);
    b2 = sumY / dataLength - m2 * sumX / dataLength;
  }
  return {
    m: m2,
    b: b2
  };
}
function linearRegressionLine(mb) {
  return function(x3) {
    return mb.b + mb.m * x3;
  };
}
function sum3(x3) {
  if (x3.length === 0) {
    return 0;
  }
  var sum4 = x3[0];
  var correction = 0;
  var transition;
  if (typeof sum4 !== "number") {
    return Number.NaN;
  }
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (typeof x3[i2] !== "number") {
      return Number.NaN;
    }
    transition = sum4 + x3[i2];
    if (Math.abs(sum4) >= Math.abs(x3[i2])) {
      correction += sum4 - transition + x3[i2];
    } else {
      correction += x3[i2] - transition + sum4;
    }
    sum4 = transition;
  }
  return sum4 + correction;
}
function mean(x3) {
  if (x3.length === 0) {
    throw new Error("mean requires at least one data point");
  }
  return sum3(x3) / x3.length;
}
function sumNthPowerDeviations(x3, n2) {
  var meanValue = mean(x3);
  var sum4 = 0;
  var tempValue;
  var i2;
  if (n2 === 2) {
    for (i2 = 0; i2 < x3.length; i2++) {
      tempValue = x3[i2] - meanValue;
      sum4 += tempValue * tempValue;
    }
  } else {
    for (i2 = 0; i2 < x3.length; i2++) {
      sum4 += Math.pow(x3[i2] - meanValue, n2);
    }
  }
  return sum4;
}
function variance2(x3) {
  if (x3.length === 0) {
    throw new Error("variance requires at least one data point");
  }
  return sumNthPowerDeviations(x3, 2) / x3.length;
}
function standardDeviation(x3) {
  if (x3.length === 1) {
    return 0;
  }
  var v2 = variance2(x3);
  return Math.sqrt(v2);
}
function rSquared(x3, func) {
  if (x3.length < 2) {
    return 1;
  }
  var sum4 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sum4 += x3[i2][1];
  }
  var average = sum4 / x3.length;
  var sumOfSquares = 0;
  for (var j2 = 0; j2 < x3.length; j2++) {
    sumOfSquares += Math.pow(average - x3[j2][1], 2);
  }
  var err = 0;
  for (var k2 = 0; k2 < x3.length; k2++) {
    err += Math.pow(x3[k2][1] - func(x3[k2][0]), 2);
  }
  return 1 - err / sumOfSquares;
}
function modeSorted(sorted) {
  if (sorted.length === 0) {
    throw new Error("mode requires at least one data point");
  }
  if (sorted.length === 1) {
    return sorted[0];
  }
  var last2 = sorted[0];
  var value2 = Number.NaN;
  var maxSeen = 0;
  var seenThis = 1;
  for (var i2 = 1; i2 < sorted.length + 1; i2++) {
    if (sorted[i2] !== last2) {
      if (seenThis > maxSeen) {
        maxSeen = seenThis;
        value2 = last2;
      }
      seenThis = 1;
      last2 = sorted[i2];
    } else {
      seenThis++;
    }
  }
  return value2;
}
function numericSort(x3) {
  return x3.slice().sort(function(a2, b2) {
    return a2 - b2;
  });
}
function mode(x3) {
  return modeSorted(numericSort(x3));
}
function modeFast(x3) {
  var index2 = /* @__PURE__ */ new Map();
  var mode2;
  var modeCount = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    var newCount = index2.get(x3[i2]);
    if (newCount === void 0) {
      newCount = 1;
    } else {
      newCount++;
    }
    if (newCount > modeCount) {
      mode2 = x3[i2];
      modeCount = newCount;
    }
    index2.set(x3[i2], newCount);
  }
  if (modeCount === 0) {
    throw new Error("mode requires at last one data point");
  }
  return mode2;
}
function min2(x3) {
  if (x3.length === 0) {
    throw new Error("min requires at least one data point");
  }
  var value2 = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] < value2) {
      value2 = x3[i2];
    }
  }
  return value2;
}
function max2(x3) {
  if (x3.length === 0) {
    throw new Error("max requires at least one data point");
  }
  var value2 = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] > value2) {
      value2 = x3[i2];
    }
  }
  return value2;
}
function extent(x3) {
  if (x3.length === 0) {
    throw new Error("extent requires at least one data point");
  }
  var min3 = x3[0];
  var max3 = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] > max3) {
      max3 = x3[i2];
    }
    if (x3[i2] < min3) {
      min3 = x3[i2];
    }
  }
  return [min3, max3];
}
function minSorted(x3) {
  return x3[0];
}
function maxSorted(x3) {
  return x3[x3.length - 1];
}
function extentSorted(x3) {
  return [x3[0], x3[x3.length - 1]];
}
function sumSimple(x3) {
  var value2 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (typeof x3[i2] !== "number") {
      return Number.NaN;
    }
    value2 += x3[i2];
  }
  return value2;
}
function product(x3) {
  var value2 = 1;
  for (var i2 = 0; i2 < x3.length; i2++) {
    value2 *= x3[i2];
  }
  return value2;
}
function quantileSorted2(x3, p2) {
  var idx = x3.length * p2;
  if (x3.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p2 < 0 || p2 > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p2 === 1) {
    return x3[x3.length - 1];
  } else if (p2 === 0) {
    return x3[0];
  } else if (idx % 1 !== 0) {
    return x3[Math.ceil(idx) - 1];
  } else if (x3.length % 2 === 0) {
    return (x3[idx - 1] + x3[idx]) / 2;
  } else {
    return x3[idx];
  }
}
function quickselect(arr, k2, left, right) {
  left = left || 0;
  right = right || arr.length - 1;
  while (right > left) {
    if (right - left > 600) {
      var n2 = right - left + 1;
      var m2 = k2 - left + 1;
      var z2 = Math.log(n2);
      var s2 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2);
      if (m2 - n2 / 2 < 0) {
        sd *= -1;
      }
      var newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));
      var newRight = Math.min(
        right,
        Math.floor(k2 + (n2 - m2) * s2 / n2 + sd)
      );
      quickselect(arr, k2, newLeft, newRight);
    }
    var t2 = arr[k2];
    var i2 = left;
    var j2 = right;
    swap(arr, left, k2);
    if (arr[right] > t2) {
      swap(arr, left, right);
    }
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (arr[i2] < t2) {
        i2++;
      }
      while (arr[j2] > t2) {
        j2--;
      }
    }
    if (arr[left] === t2) {
      swap(arr, left, j2);
    } else {
      j2++;
      swap(arr, j2, right);
    }
    if (j2 <= k2) {
      left = j2 + 1;
    }
    if (k2 <= j2) {
      right = j2 - 1;
    }
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function quantile(x3, p2) {
  var copy = x3.slice();
  if (Array.isArray(p2)) {
    multiQuantileSelect(copy, p2);
    var results = [];
    for (var i2 = 0; i2 < p2.length; i2++) {
      results[i2] = quantileSorted2(copy, p2[i2]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy.length, p2);
    quantileSelect(copy, idx, 0, copy.length - 1);
    return quantileSorted2(copy, p2);
  }
}
function quantileSelect(arr, k2, left, right) {
  if (k2 % 1 === 0) {
    quickselect(arr, k2, left, right);
  } else {
    k2 = Math.floor(k2);
    quickselect(arr, k2, left, right);
    quickselect(arr, k2 + 1, k2 + 1, right);
  }
}
function multiQuantileSelect(arr, p2) {
  var indices = [0];
  for (var i2 = 0; i2 < p2.length; i2++) {
    indices.push(quantileIndex(arr.length, p2[i2]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack = [0, indices.length - 1];
  while (stack.length) {
    var r2 = Math.ceil(stack.pop());
    var l2 = Math.floor(stack.pop());
    if (r2 - l2 <= 1) {
      continue;
    }
    var m2 = Math.floor((l2 + r2) / 2);
    quantileSelect(
      arr,
      indices[m2],
      Math.floor(indices[l2]),
      Math.ceil(indices[r2])
    );
    stack.push(l2, m2, m2, r2);
  }
}
function compare(a2, b2) {
  return a2 - b2;
}
function quantileIndex(len, p2) {
  var idx = len * p2;
  if (p2 === 1) {
    return len - 1;
  } else if (p2 === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}
function quantileRankSorted(x3, value2) {
  if (value2 < x3[0]) {
    return 0;
  }
  if (value2 > x3[x3.length - 1]) {
    return 1;
  }
  var l2 = lowerBound(x3, value2);
  if (x3[l2] !== value2) {
    return l2 / x3.length;
  }
  l2++;
  var u2 = upperBound(x3, value2);
  if (u2 === l2) {
    return l2 / x3.length;
  }
  var r2 = u2 - l2 + 1;
  var sum4 = r2 * (u2 + l2) / 2;
  var mean2 = sum4 / r2;
  return mean2 / x3.length;
}
function lowerBound(x3, value2) {
  var mid = 0;
  var lo = 0;
  var hi = x3.length;
  while (lo < hi) {
    mid = lo + hi >>> 1;
    if (value2 <= x3[mid]) {
      hi = mid;
    } else {
      lo = -~mid;
    }
  }
  return lo;
}
function upperBound(x3, value2) {
  var mid = 0;
  var lo = 0;
  var hi = x3.length;
  while (lo < hi) {
    mid = lo + hi >>> 1;
    if (value2 >= x3[mid]) {
      lo = -~mid;
    } else {
      hi = mid;
    }
  }
  return lo;
}
function quantileRank(x3, value2) {
  var sortedCopy = numericSort(x3);
  return quantileRankSorted(sortedCopy, value2);
}
function interquartileRange(x3) {
  var q1 = quantile(x3, 0.75);
  var q2 = quantile(x3, 0.25);
  if (typeof q1 === "number" && typeof q2 === "number") {
    return q1 - q2;
  }
}
function median2(x3) {
  return +quantile(x3, 0.5);
}
function medianAbsoluteDeviation(x3) {
  var medianValue = median2(x3);
  var medianAbsoluteDeviations = [];
  for (var i2 = 0; i2 < x3.length; i2++) {
    medianAbsoluteDeviations.push(Math.abs(x3[i2] - medianValue));
  }
  return median2(medianAbsoluteDeviations);
}
function chunk(x3, chunkSize) {
  var output = [];
  if (chunkSize < 1) {
    throw new Error("chunk size must be a positive number");
  }
  if (Math.floor(chunkSize) !== chunkSize) {
    throw new Error("chunk size must be an integer");
  }
  for (var start = 0; start < x3.length; start += chunkSize) {
    output.push(x3.slice(start, start + chunkSize));
  }
  return output;
}
function sampleWithReplacement(x3, n2, randomSource) {
  if (x3.length === 0) {
    return [];
  }
  randomSource = randomSource || Math.random;
  var length2 = x3.length;
  var sample2 = [];
  for (var i2 = 0; i2 < n2; i2++) {
    var index2 = Math.floor(randomSource() * length2);
    sample2.push(x3[index2]);
  }
  return sample2;
}
function shuffleInPlace(x3, randomSource) {
  randomSource = randomSource || Math.random;
  var length2 = x3.length;
  var temporary;
  var index2;
  while (length2 > 0) {
    index2 = Math.floor(randomSource() * length2--);
    temporary = x3[length2];
    x3[length2] = x3[index2];
    x3[index2] = temporary;
  }
  return x3;
}
function shuffle(x3, randomSource) {
  var sample2 = x3.slice();
  return shuffleInPlace(sample2, randomSource);
}
function sample(x3, n2, randomSource) {
  var shuffled = shuffle(x3, randomSource);
  return shuffled.slice(0, n2);
}
function makeMatrix(columns, rows) {
  var matrix = [];
  for (var i2 = 0; i2 < columns; i2++) {
    var column = [];
    for (var j2 = 0; j2 < rows; j2++) {
      column.push(0);
    }
    matrix.push(column);
  }
  return matrix;
}
function uniqueCountSorted(x3) {
  var uniqueValueCount = 0;
  var lastSeenValue;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (i2 === 0 || x3[i2] !== lastSeenValue) {
      lastSeenValue = x3[i2];
      uniqueValueCount++;
    }
  }
  return uniqueValueCount;
}
function ssq(j2, i2, sums, sumsOfSquares) {
  var sji;
  if (j2 > 0) {
    var muji = (sums[i2] - sums[j2 - 1]) / (i2 - j2 + 1);
    sji = sumsOfSquares[i2] - sumsOfSquares[j2 - 1] - (i2 - j2 + 1) * muji * muji;
  } else {
    sji = sumsOfSquares[i2] - sums[i2] * sums[i2] / (i2 + 1);
  }
  if (sji < 0) {
    return 0;
  }
  return sji;
}
function fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {
  if (iMin > iMax) {
    return;
  }
  var i2 = Math.floor((iMin + iMax) / 2);
  matrix[cluster][i2] = matrix[cluster - 1][i2 - 1];
  backtrackMatrix[cluster][i2] = i2;
  var jlow = cluster;
  if (iMin > cluster) {
    jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
  }
  jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i2] || 0);
  var jhigh = i2 - 1;
  if (iMax < matrix[0].length - 1) {
    jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
  }
  var sji;
  var sjlowi;
  var ssqjlow;
  var ssqj;
  for (var j2 = jhigh; j2 >= jlow; --j2) {
    sji = ssq(j2, i2, sums, sumsOfSquares);
    if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i2]) {
      break;
    }
    sjlowi = ssq(jlow, i2, sums, sumsOfSquares);
    ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];
    if (ssqjlow < matrix[cluster][i2]) {
      matrix[cluster][i2] = ssqjlow;
      backtrackMatrix[cluster][i2] = jlow;
    }
    jlow++;
    ssqj = sji + matrix[cluster - 1][j2 - 1];
    if (ssqj < matrix[cluster][i2]) {
      matrix[cluster][i2] = ssqj;
      backtrackMatrix[cluster][i2] = j2;
    }
  }
  fillMatrixColumn(
    iMin,
    i2 - 1,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
  );
  fillMatrixColumn(
    i2 + 1,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
  );
}
function fillMatrices(data2, matrix, backtrackMatrix) {
  var nValues = matrix[0].length;
  var shift = data2[Math.floor(nValues / 2)];
  var sums = [];
  var sumsOfSquares = [];
  for (var i2 = 0, shiftedValue = void 0; i2 < nValues; ++i2) {
    shiftedValue = data2[i2] - shift;
    if (i2 === 0) {
      sums.push(shiftedValue);
      sumsOfSquares.push(shiftedValue * shiftedValue);
    } else {
      sums.push(sums[i2 - 1] + shiftedValue);
      sumsOfSquares.push(
        sumsOfSquares[i2 - 1] + shiftedValue * shiftedValue
      );
    }
    matrix[0][i2] = ssq(0, i2, sums, sumsOfSquares);
    backtrackMatrix[0][i2] = 0;
  }
  var iMin;
  for (var cluster = 1; cluster < matrix.length; ++cluster) {
    if (cluster < matrix.length - 1) {
      iMin = cluster;
    } else {
      iMin = nValues - 1;
    }
    fillMatrixColumn(
      iMin,
      nValues - 1,
      cluster,
      matrix,
      backtrackMatrix,
      sums,
      sumsOfSquares
    );
  }
}
function ckmeans(x3, nClusters) {
  if (nClusters > x3.length) {
    throw new Error(
      "cannot generate more classes than there are data values"
    );
  }
  var sorted = numericSort(x3);
  var uniqueCount = uniqueCountSorted(sorted);
  if (uniqueCount === 1) {
    return [sorted];
  }
  var matrix = makeMatrix(nClusters, sorted.length);
  var backtrackMatrix = makeMatrix(nClusters, sorted.length);
  fillMatrices(sorted, matrix, backtrackMatrix);
  var clusters = [];
  var clusterRight = backtrackMatrix[0].length - 1;
  for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
    var clusterLeft = backtrackMatrix[cluster][clusterRight];
    clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);
    if (cluster > 0) {
      clusterRight = clusterLeft - 1;
    }
  }
  return clusters;
}
function jenksBreaks(data2, lowerClassLimits, nClasses) {
  var k2 = data2.length;
  var kclass = [];
  var countNum = nClasses;
  kclass[nClasses] = data2[data2.length - 1];
  while (countNum > 0) {
    kclass[countNum - 1] = data2[lowerClassLimits[k2][countNum] - 1];
    k2 = lowerClassLimits[k2][countNum] - 1;
    countNum--;
  }
  return kclass;
}
function jenksMatrices(data2, nClasses) {
  var lowerClassLimits = [];
  var varianceCombinations = [];
  var i2;
  var j2;
  var variance3 = 0;
  for (i2 = 0; i2 < data2.length + 1; i2++) {
    var tmp1 = [];
    var tmp2 = [];
    for (j2 = 0; j2 < nClasses + 1; j2++) {
      tmp1.push(0);
      tmp2.push(0);
    }
    lowerClassLimits.push(tmp1);
    varianceCombinations.push(tmp2);
  }
  for (i2 = 1; i2 < nClasses + 1; i2++) {
    lowerClassLimits[1][i2] = 1;
    varianceCombinations[1][i2] = 0;
    for (j2 = 2; j2 < data2.length + 1; j2++) {
      varianceCombinations[j2][i2] = Number.POSITIVE_INFINITY;
    }
  }
  for (var l2 = 2; l2 < data2.length + 1; l2++) {
    var sum4 = 0;
    var sumSquares = 0;
    var w2 = 0;
    var i4 = 0;
    for (var m2 = 1; m2 < l2 + 1; m2++) {
      var lowerClassLimit = l2 - m2 + 1;
      var val2 = data2[lowerClassLimit - 1];
      w2++;
      sum4 += val2;
      sumSquares += val2 * val2;
      variance3 = sumSquares - sum4 * sum4 / w2;
      i4 = lowerClassLimit - 1;
      if (i4 !== 0) {
        for (j2 = 2; j2 < nClasses + 1; j2++) {
          if (varianceCombinations[l2][j2] >= variance3 + varianceCombinations[i4][j2 - 1]) {
            lowerClassLimits[l2][j2] = lowerClassLimit;
            varianceCombinations[l2][j2] = variance3 + varianceCombinations[i4][j2 - 1];
          }
        }
      }
    }
    lowerClassLimits[l2][1] = 1;
    varianceCombinations[l2][1] = variance3;
  }
  return {
    lowerClassLimits,
    varianceCombinations
  };
}
function jenks(data2, nClasses) {
  if (nClasses > data2.length) {
    return null;
  }
  data2 = data2.slice().sort(function(a2, b2) {
    return a2 - b2;
  });
  var matrices = jenksMatrices(data2, nClasses);
  var lowerClassLimits = matrices.lowerClassLimits;
  return jenksBreaks(data2, lowerClassLimits, nClasses);
}
function equalIntervalBreaks(x3, nClasses) {
  if (x3.length < 2) {
    return x3;
  }
  var theMin = min2(x3);
  var theMax = max2(x3);
  var breaks = [theMin];
  var breakSize = (theMax - theMin) / nClasses;
  for (var i2 = 1; i2 < nClasses; i2++) {
    breaks.push(breaks[0] + breakSize * i2);
  }
  breaks.push(theMax);
  return breaks;
}
function sampleCovariance(x3, y3) {
  if (x3.length !== y3.length) {
    throw new Error("sampleCovariance requires samples with equal lengths");
  }
  if (x3.length < 2) {
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  }
  var xmean = mean(x3);
  var ymean = mean(y3);
  var sum4 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sum4 += (x3[i2] - xmean) * (y3[i2] - ymean);
  }
  var besselsCorrection = x3.length - 1;
  return sum4 / besselsCorrection;
}
function sampleVariance(x3) {
  if (x3.length < 2) {
    throw new Error("sampleVariance requires at least two data points");
  }
  var sumSquaredDeviationsValue = sumNthPowerDeviations(x3, 2);
  var besselsCorrection = x3.length - 1;
  return sumSquaredDeviationsValue / besselsCorrection;
}
function sampleStandardDeviation(x3) {
  var sampleVarianceX = sampleVariance(x3);
  return Math.sqrt(sampleVarianceX);
}
function sampleCorrelation(x3, y3) {
  var cov = sampleCovariance(x3, y3);
  var xstd = sampleStandardDeviation(x3);
  var ystd = sampleStandardDeviation(y3);
  return cov / xstd / ystd;
}
function sampleRankCorrelation(x3, y3) {
  var xIndexes = x3.map(function(value2, index2) {
    return [value2, index2];
  }).sort(function(a2, b2) {
    return a2[0] - b2[0];
  }).map(function(pair2) {
    return pair2[1];
  });
  var yIndexes = y3.map(function(value2, index2) {
    return [value2, index2];
  }).sort(function(a2, b2) {
    return a2[0] - b2[0];
  }).map(function(pair2) {
    return pair2[1];
  });
  var xRanks = Array(xIndexes.length);
  var yRanks = Array(xIndexes.length);
  for (var i2 = 0; i2 < xIndexes.length; i2++) {
    xRanks[xIndexes[i2]] = i2;
    yRanks[yIndexes[i2]] = i2;
  }
  return sampleCorrelation(xRanks, yRanks);
}
function sampleSkewness(x3) {
  if (x3.length < 3) {
    throw new Error("sampleSkewness requires at least three data points");
  }
  var meanValue = mean(x3);
  var tempValue;
  var sumSquaredDeviations = 0;
  var sumCubedDeviations = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    tempValue = x3[i2] - meanValue;
    sumSquaredDeviations += tempValue * tempValue;
    sumCubedDeviations += tempValue * tempValue * tempValue;
  }
  var besselsCorrection = x3.length - 1;
  var theSampleStandardDeviation = Math.sqrt(
    sumSquaredDeviations / besselsCorrection
  );
  var n2 = x3.length;
  var cubedS = Math.pow(theSampleStandardDeviation, 3);
  return n2 * sumCubedDeviations / ((n2 - 1) * (n2 - 2) * cubedS);
}
function sampleKurtosis(x3) {
  var n2 = x3.length;
  if (n2 < 4) {
    throw new Error("sampleKurtosis requires at least four data points");
  }
  var meanValue = mean(x3);
  var tempValue;
  var secondCentralMoment = 0;
  var fourthCentralMoment = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    tempValue = x3[i2] - meanValue;
    secondCentralMoment += tempValue * tempValue;
    fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
  }
  return (n2 - 1) / ((n2 - 2) * (n2 - 3)) * (n2 * (n2 + 1) * fourthCentralMoment / (secondCentralMoment * secondCentralMoment) - 3 * (n2 - 1));
}
function permutationsHeap(elements) {
  var indexes = new Array(elements.length);
  var permutations = [elements.slice()];
  for (var i2 = 0; i2 < elements.length; i2++) {
    indexes[i2] = 0;
  }
  for (var i$1 = 0; i$1 < elements.length; ) {
    if (indexes[i$1] < i$1) {
      var swapFrom = 0;
      if (i$1 % 2 !== 0) {
        swapFrom = indexes[i$1];
      }
      var temp2 = elements[swapFrom];
      elements[swapFrom] = elements[i$1];
      elements[i$1] = temp2;
      permutations.push(elements.slice());
      indexes[i$1]++;
      i$1 = 0;
    } else {
      indexes[i$1] = 0;
      i$1++;
    }
  }
  return permutations;
}
function combinations(x3, k2) {
  var i2;
  var subI;
  var combinationList = [];
  var subsetCombinations;
  var next;
  for (i2 = 0; i2 < x3.length; i2++) {
    if (k2 === 1) {
      combinationList.push([x3[i2]]);
    } else {
      subsetCombinations = combinations(x3.slice(i2 + 1, x3.length), k2 - 1);
      for (subI = 0; subI < subsetCombinations.length; subI++) {
        next = subsetCombinations[subI];
        next.unshift(x3[i2]);
        combinationList.push(next);
      }
    }
  }
  return combinationList;
}
function combinationsReplacement(x3, k2) {
  var combinationList = [];
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (k2 === 1) {
      combinationList.push([x3[i2]]);
    } else {
      var subsetCombinations = combinationsReplacement(
        x3.slice(i2, x3.length),
        k2 - 1
      );
      for (var j2 = 0; j2 < subsetCombinations.length; j2++) {
        combinationList.push([x3[i2]].concat(subsetCombinations[j2]));
      }
    }
  }
  return combinationList;
}
function addToMean(mean2, n2, newValue) {
  return mean2 + (newValue - mean2) / (n2 + 1);
}
function combineMeans(mean1, n1, mean2, n2) {
  return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}
function combineVariances(variance1, mean1, n1, variance22, mean2, n2) {
  var newMean = combineMeans(mean1, n1, mean2, n2);
  return (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) + n2 * (variance22 + Math.pow(mean2 - newMean, 2))) / (n1 + n2);
}
function geometricMean(x3) {
  if (x3.length === 0) {
    throw new Error("geometricMean requires at least one data point");
  }
  var value2 = 1;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] < 0) {
      throw new Error(
        "geometricMean requires only non-negative numbers as input"
      );
    }
    value2 *= x3[i2];
  }
  return Math.pow(value2, 1 / x3.length);
}
function logAverage(x3) {
  if (x3.length === 0) {
    throw new Error("logAverage requires at least one data point");
  }
  var value2 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] < 0) {
      throw new Error(
        "logAverage requires only non-negative numbers as input"
      );
    }
    value2 += Math.log(x3[i2]);
  }
  return Math.exp(value2 / x3.length);
}
function harmonicMean(x3) {
  if (x3.length === 0) {
    throw new Error("harmonicMean requires at least one data point");
  }
  var reciprocalSum = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] <= 0) {
      throw new Error(
        "harmonicMean requires only positive numbers as input"
      );
    }
    reciprocalSum += 1 / x3[i2];
  }
  return x3.length / reciprocalSum;
}
function meanSimple(x3) {
  if (x3.length === 0) {
    throw new Error("meanSimple requires at least one data point");
  }
  return sumSimple(x3) / x3.length;
}
function medianSorted(sorted) {
  return quantileSorted2(sorted, 0.5);
}
function subtractFromMean(mean2, n2, value2) {
  return (mean2 * n2 - value2) / (n2 - 1);
}
function rootMeanSquare(x3) {
  if (x3.length === 0) {
    throw new Error("rootMeanSquare requires at least one data point");
  }
  var sumOfSquares = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sumOfSquares += Math.pow(x3[i2], 2);
  }
  return Math.sqrt(sumOfSquares / x3.length);
}
function coefficientOfVariation(x3) {
  return sampleStandardDeviation(x3) / mean(x3);
}
function tTest(x3, expectedValue) {
  var sampleMean = mean(x3);
  var sd = standardDeviation(x3);
  var rootN = Math.sqrt(x3.length);
  return (sampleMean - expectedValue) / (sd / rootN);
}
function tTestTwoSample(sampleX, sampleY, difference) {
  var n2 = sampleX.length;
  var m2 = sampleY.length;
  if (!n2 || !m2) {
    return null;
  }
  if (!difference) {
    difference = 0;
  }
  var meanX = mean(sampleX);
  var meanY = mean(sampleY);
  var sampleVarianceX = sampleVariance(sampleX);
  var sampleVarianceY = sampleVariance(sampleY);
  if (typeof meanX === "number" && typeof meanY === "number" && typeof sampleVarianceX === "number" && typeof sampleVarianceY === "number") {
    var weightedVariance = ((n2 - 1) * sampleVarianceX + (m2 - 1) * sampleVarianceY) / (n2 + m2 - 2);
    return (meanX - meanY - difference) / Math.sqrt(weightedVariance * (1 / n2 + 1 / m2));
  }
}
function wilcoxonRankSum(sampleX, sampleY) {
  if (!sampleX.length || !sampleY.length) {
    throw new Error("Neither sample can be empty");
  }
  var pooledSamples = sampleX.map(function(x3) {
    return { label: "x", value: x3 };
  }).concat(sampleY.map(function(y3) {
    return { label: "y", value: y3 };
  })).sort(function(a2, b2) {
    return a2.value - b2.value;
  });
  for (var rank = 0; rank < pooledSamples.length; rank++) {
    pooledSamples[rank].rank = rank;
  }
  var tiedRanks = [pooledSamples[0].rank];
  for (var i2 = 1; i2 < pooledSamples.length; i2++) {
    if (pooledSamples[i2].value === pooledSamples[i2 - 1].value) {
      tiedRanks.push(pooledSamples[i2].rank);
      if (i2 === pooledSamples.length - 1) {
        replaceRanksInPlace(pooledSamples, tiedRanks);
      }
    } else if (tiedRanks.length > 1) {
      replaceRanksInPlace(pooledSamples, tiedRanks);
    } else {
      tiedRanks = [pooledSamples[i2].rank];
    }
  }
  function replaceRanksInPlace(pooledSamples2, tiedRanks2) {
    var average = (tiedRanks2[0] + tiedRanks2[tiedRanks2.length - 1]) / 2;
    for (var i3 = 0; i3 < tiedRanks2.length; i3++) {
      pooledSamples2[tiedRanks2[i3]].rank = average;
    }
  }
  var rankSum = 0;
  for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
    var sample2 = pooledSamples[i$1];
    if (sample2.label === "x") {
      rankSum += sample2.rank + 1;
    }
  }
  return rankSum;
}
var BayesianClassifier = function BayesianClassifier2() {
  this.totalCount = 0;
  this.data = {};
};
BayesianClassifier.prototype.train = function train(item, category) {
  if (!this.data[category]) {
    this.data[category] = {};
  }
  for (var k2 in item) {
    var v2 = item[k2];
    if (this.data[category][k2] === void 0) {
      this.data[category][k2] = {};
    }
    if (this.data[category][k2][v2] === void 0) {
      this.data[category][k2][v2] = 0;
    }
    this.data[category][k2][v2]++;
  }
  this.totalCount++;
};
BayesianClassifier.prototype.score = function score(item) {
  var odds = {};
  var category;
  for (var k2 in item) {
    var v2 = item[k2];
    for (category in this.data) {
      odds[category] = {};
      if (this.data[category][k2]) {
        odds[category][k2 + "_" + v2] = (this.data[category][k2][v2] || 0) / this.totalCount;
      } else {
        odds[category][k2 + "_" + v2] = 0;
      }
    }
  }
  var oddsSums = {};
  for (category in odds) {
    oddsSums[category] = 0;
    for (var combination in odds[category]) {
      oddsSums[category] += odds[category][combination];
    }
  }
  return oddsSums;
};
var PerceptronModel = function PerceptronModel2() {
  this.weights = [];
  this.bias = 0;
};
PerceptronModel.prototype.predict = function predict(features) {
  if (features.length !== this.weights.length) {
    return null;
  }
  var score2 = 0;
  for (var i2 = 0; i2 < this.weights.length; i2++) {
    score2 += this.weights[i2] * features[i2];
  }
  score2 += this.bias;
  if (score2 > 0) {
    return 1;
  } else {
    return 0;
  }
};
PerceptronModel.prototype.train = function train2(features, label) {
  if (label !== 0 && label !== 1) {
    return null;
  }
  if (features.length !== this.weights.length) {
    this.weights = features;
    this.bias = 1;
  }
  var prediction = this.predict(features);
  if (typeof prediction === "number" && prediction !== label) {
    var gradient = label - prediction;
    for (var i2 = 0; i2 < this.weights.length; i2++) {
      this.weights[i2] += gradient * features[i2];
    }
    this.bias += gradient;
  }
  return this;
};
var epsilon3 = 1e-4;
function factorial(n2) {
  if (n2 < 0) {
    throw new Error("factorial requires a non-negative value");
  }
  if (Math.floor(n2) !== n2) {
    throw new Error("factorial requires an integer input");
  }
  var accumulator = 1;
  for (var i2 = 2; i2 <= n2; i2++) {
    accumulator *= i2;
  }
  return accumulator;
}
function gamma(n2) {
  if (Number.isInteger(n2)) {
    if (n2 <= 0) {
      return Number.NaN;
    } else {
      return factorial(n2 - 1);
    }
  }
  n2--;
  if (n2 < 0) {
    return Math.PI / (Math.sin(Math.PI * -n2) * gamma(-n2));
  } else {
    var seriesCoefficient = Math.pow(n2 / Math.E, n2) * Math.sqrt(2 * Math.PI * (n2 + 1 / 6));
    var seriesDenom = n2 + 1 / 4;
    var seriesExpansion = 1 + 1 / 144 / Math.pow(seriesDenom, 2) - 1 / 12960 / Math.pow(seriesDenom, 3) - 257 / 207360 / Math.pow(seriesDenom, 4) - 52 / 2612736 / Math.pow(seriesDenom, 5) + 5741173 / 9405849600 / Math.pow(seriesDenom, 6) + 37529 / 18811699200 / Math.pow(seriesDenom, 7);
    return seriesCoefficient * seriesExpansion;
  }
}
var COEFFICIENTS = [
  0.9999999999999971,
  57.15623566586292,
  -59.59796035547549,
  14.136097974741746,
  -0.4919138160976202,
  3399464998481189e-20,
  4652362892704858e-20,
  -9837447530487956e-20,
  1580887032249125e-19,
  -21026444172410488e-20,
  21743961811521265e-20,
  -1643181065367639e-19,
  8441822398385275e-20,
  -26190838401581408e-21,
  36899182659531625e-22
];
var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));
function gammaln(n2) {
  if (n2 <= 0) {
    return Number.POSITIVE_INFINITY;
  }
  n2--;
  var a2 = COEFFICIENTS[0];
  for (var i2 = 1; i2 < 15; i2++) {
    a2 += COEFFICIENTS[i2] / (n2 + i2);
  }
  var tmp = g + 0.5 + n2;
  return LOGSQRT2PI + Math.log(a2) - tmp + (n2 + 0.5) * Math.log(tmp);
}
function bernoulliDistribution(p2) {
  if (p2 < 0 || p2 > 1) {
    throw new Error(
      "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
    );
  }
  return [1 - p2, p2];
}
function binomialDistribution(trials, probability) {
  if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
    return void 0;
  }
  var x3 = 0;
  var cumulativeProbability = 0;
  var cells = [];
  var binomialCoefficient = 1;
  do {
    cells[x3] = binomialCoefficient * Math.pow(probability, x3) * Math.pow(1 - probability, trials - x3);
    cumulativeProbability += cells[x3];
    x3++;
    binomialCoefficient = binomialCoefficient * (trials - x3 + 1) / x3;
  } while (cumulativeProbability < 1 - epsilon3);
  return cells;
}
function poissonDistribution(lambda) {
  if (lambda <= 0) {
    return void 0;
  }
  var x3 = 0;
  var cumulativeProbability = 0;
  var cells = [];
  var factorialX = 1;
  do {
    cells[x3] = Math.exp(-lambda) * Math.pow(lambda, x3) / factorialX;
    cumulativeProbability += cells[x3];
    x3++;
    factorialX *= x3;
  } while (cumulativeProbability < 1 - epsilon3);
  return cells;
}
var chiSquaredDistributionTable = {
  1: {
    0.995: 0,
    0.99: 0,
    0.975: 0,
    0.95: 0,
    0.9: 0.02,
    0.5: 0.45,
    0.1: 2.71,
    0.05: 3.84,
    0.025: 5.02,
    0.01: 6.63,
    5e-3: 7.88
  },
  2: {
    0.995: 0.01,
    0.99: 0.02,
    0.975: 0.05,
    0.95: 0.1,
    0.9: 0.21,
    0.5: 1.39,
    0.1: 4.61,
    0.05: 5.99,
    0.025: 7.38,
    0.01: 9.21,
    5e-3: 10.6
  },
  3: {
    0.995: 0.07,
    0.99: 0.11,
    0.975: 0.22,
    0.95: 0.35,
    0.9: 0.58,
    0.5: 2.37,
    0.1: 6.25,
    0.05: 7.81,
    0.025: 9.35,
    0.01: 11.34,
    5e-3: 12.84
  },
  4: {
    0.995: 0.21,
    0.99: 0.3,
    0.975: 0.48,
    0.95: 0.71,
    0.9: 1.06,
    0.5: 3.36,
    0.1: 7.78,
    0.05: 9.49,
    0.025: 11.14,
    0.01: 13.28,
    5e-3: 14.86
  },
  5: {
    0.995: 0.41,
    0.99: 0.55,
    0.975: 0.83,
    0.95: 1.15,
    0.9: 1.61,
    0.5: 4.35,
    0.1: 9.24,
    0.05: 11.07,
    0.025: 12.83,
    0.01: 15.09,
    5e-3: 16.75
  },
  6: {
    0.995: 0.68,
    0.99: 0.87,
    0.975: 1.24,
    0.95: 1.64,
    0.9: 2.2,
    0.5: 5.35,
    0.1: 10.65,
    0.05: 12.59,
    0.025: 14.45,
    0.01: 16.81,
    5e-3: 18.55
  },
  7: {
    0.995: 0.99,
    0.99: 1.25,
    0.975: 1.69,
    0.95: 2.17,
    0.9: 2.83,
    0.5: 6.35,
    0.1: 12.02,
    0.05: 14.07,
    0.025: 16.01,
    0.01: 18.48,
    5e-3: 20.28
  },
  8: {
    0.995: 1.34,
    0.99: 1.65,
    0.975: 2.18,
    0.95: 2.73,
    0.9: 3.49,
    0.5: 7.34,
    0.1: 13.36,
    0.05: 15.51,
    0.025: 17.53,
    0.01: 20.09,
    5e-3: 21.96
  },
  9: {
    0.995: 1.73,
    0.99: 2.09,
    0.975: 2.7,
    0.95: 3.33,
    0.9: 4.17,
    0.5: 8.34,
    0.1: 14.68,
    0.05: 16.92,
    0.025: 19.02,
    0.01: 21.67,
    5e-3: 23.59
  },
  10: {
    0.995: 2.16,
    0.99: 2.56,
    0.975: 3.25,
    0.95: 3.94,
    0.9: 4.87,
    0.5: 9.34,
    0.1: 15.99,
    0.05: 18.31,
    0.025: 20.48,
    0.01: 23.21,
    5e-3: 25.19
  },
  11: {
    0.995: 2.6,
    0.99: 3.05,
    0.975: 3.82,
    0.95: 4.57,
    0.9: 5.58,
    0.5: 10.34,
    0.1: 17.28,
    0.05: 19.68,
    0.025: 21.92,
    0.01: 24.72,
    5e-3: 26.76
  },
  12: {
    0.995: 3.07,
    0.99: 3.57,
    0.975: 4.4,
    0.95: 5.23,
    0.9: 6.3,
    0.5: 11.34,
    0.1: 18.55,
    0.05: 21.03,
    0.025: 23.34,
    0.01: 26.22,
    5e-3: 28.3
  },
  13: {
    0.995: 3.57,
    0.99: 4.11,
    0.975: 5.01,
    0.95: 5.89,
    0.9: 7.04,
    0.5: 12.34,
    0.1: 19.81,
    0.05: 22.36,
    0.025: 24.74,
    0.01: 27.69,
    5e-3: 29.82
  },
  14: {
    0.995: 4.07,
    0.99: 4.66,
    0.975: 5.63,
    0.95: 6.57,
    0.9: 7.79,
    0.5: 13.34,
    0.1: 21.06,
    0.05: 23.68,
    0.025: 26.12,
    0.01: 29.14,
    5e-3: 31.32
  },
  15: {
    0.995: 4.6,
    0.99: 5.23,
    0.975: 6.27,
    0.95: 7.26,
    0.9: 8.55,
    0.5: 14.34,
    0.1: 22.31,
    0.05: 25,
    0.025: 27.49,
    0.01: 30.58,
    5e-3: 32.8
  },
  16: {
    0.995: 5.14,
    0.99: 5.81,
    0.975: 6.91,
    0.95: 7.96,
    0.9: 9.31,
    0.5: 15.34,
    0.1: 23.54,
    0.05: 26.3,
    0.025: 28.85,
    0.01: 32,
    5e-3: 34.27
  },
  17: {
    0.995: 5.7,
    0.99: 6.41,
    0.975: 7.56,
    0.95: 8.67,
    0.9: 10.09,
    0.5: 16.34,
    0.1: 24.77,
    0.05: 27.59,
    0.025: 30.19,
    0.01: 33.41,
    5e-3: 35.72
  },
  18: {
    0.995: 6.26,
    0.99: 7.01,
    0.975: 8.23,
    0.95: 9.39,
    0.9: 10.87,
    0.5: 17.34,
    0.1: 25.99,
    0.05: 28.87,
    0.025: 31.53,
    0.01: 34.81,
    5e-3: 37.16
  },
  19: {
    0.995: 6.84,
    0.99: 7.63,
    0.975: 8.91,
    0.95: 10.12,
    0.9: 11.65,
    0.5: 18.34,
    0.1: 27.2,
    0.05: 30.14,
    0.025: 32.85,
    0.01: 36.19,
    5e-3: 38.58
  },
  20: {
    0.995: 7.43,
    0.99: 8.26,
    0.975: 9.59,
    0.95: 10.85,
    0.9: 12.44,
    0.5: 19.34,
    0.1: 28.41,
    0.05: 31.41,
    0.025: 34.17,
    0.01: 37.57,
    5e-3: 40
  },
  21: {
    0.995: 8.03,
    0.99: 8.9,
    0.975: 10.28,
    0.95: 11.59,
    0.9: 13.24,
    0.5: 20.34,
    0.1: 29.62,
    0.05: 32.67,
    0.025: 35.48,
    0.01: 38.93,
    5e-3: 41.4
  },
  22: {
    0.995: 8.64,
    0.99: 9.54,
    0.975: 10.98,
    0.95: 12.34,
    0.9: 14.04,
    0.5: 21.34,
    0.1: 30.81,
    0.05: 33.92,
    0.025: 36.78,
    0.01: 40.29,
    5e-3: 42.8
  },
  23: {
    0.995: 9.26,
    0.99: 10.2,
    0.975: 11.69,
    0.95: 13.09,
    0.9: 14.85,
    0.5: 22.34,
    0.1: 32.01,
    0.05: 35.17,
    0.025: 38.08,
    0.01: 41.64,
    5e-3: 44.18
  },
  24: {
    0.995: 9.89,
    0.99: 10.86,
    0.975: 12.4,
    0.95: 13.85,
    0.9: 15.66,
    0.5: 23.34,
    0.1: 33.2,
    0.05: 36.42,
    0.025: 39.36,
    0.01: 42.98,
    5e-3: 45.56
  },
  25: {
    0.995: 10.52,
    0.99: 11.52,
    0.975: 13.12,
    0.95: 14.61,
    0.9: 16.47,
    0.5: 24.34,
    0.1: 34.28,
    0.05: 37.65,
    0.025: 40.65,
    0.01: 44.31,
    5e-3: 46.93
  },
  26: {
    0.995: 11.16,
    0.99: 12.2,
    0.975: 13.84,
    0.95: 15.38,
    0.9: 17.29,
    0.5: 25.34,
    0.1: 35.56,
    0.05: 38.89,
    0.025: 41.92,
    0.01: 45.64,
    5e-3: 48.29
  },
  27: {
    0.995: 11.81,
    0.99: 12.88,
    0.975: 14.57,
    0.95: 16.15,
    0.9: 18.11,
    0.5: 26.34,
    0.1: 36.74,
    0.05: 40.11,
    0.025: 43.19,
    0.01: 46.96,
    5e-3: 49.65
  },
  28: {
    0.995: 12.46,
    0.99: 13.57,
    0.975: 15.31,
    0.95: 16.93,
    0.9: 18.94,
    0.5: 27.34,
    0.1: 37.92,
    0.05: 41.34,
    0.025: 44.46,
    0.01: 48.28,
    5e-3: 50.99
  },
  29: {
    0.995: 13.12,
    0.99: 14.26,
    0.975: 16.05,
    0.95: 17.71,
    0.9: 19.77,
    0.5: 28.34,
    0.1: 39.09,
    0.05: 42.56,
    0.025: 45.72,
    0.01: 49.59,
    5e-3: 52.34
  },
  30: {
    0.995: 13.79,
    0.99: 14.95,
    0.975: 16.79,
    0.95: 18.49,
    0.9: 20.6,
    0.5: 29.34,
    0.1: 40.26,
    0.05: 43.77,
    0.025: 46.98,
    0.01: 50.89,
    5e-3: 53.67
  },
  40: {
    0.995: 20.71,
    0.99: 22.16,
    0.975: 24.43,
    0.95: 26.51,
    0.9: 29.05,
    0.5: 39.34,
    0.1: 51.81,
    0.05: 55.76,
    0.025: 59.34,
    0.01: 63.69,
    5e-3: 66.77
  },
  50: {
    0.995: 27.99,
    0.99: 29.71,
    0.975: 32.36,
    0.95: 34.76,
    0.9: 37.69,
    0.5: 49.33,
    0.1: 63.17,
    0.05: 67.5,
    0.025: 71.42,
    0.01: 76.15,
    5e-3: 79.49
  },
  60: {
    0.995: 35.53,
    0.99: 37.48,
    0.975: 40.48,
    0.95: 43.19,
    0.9: 46.46,
    0.5: 59.33,
    0.1: 74.4,
    0.05: 79.08,
    0.025: 83.3,
    0.01: 88.38,
    5e-3: 91.95
  },
  70: {
    0.995: 43.28,
    0.99: 45.44,
    0.975: 48.76,
    0.95: 51.74,
    0.9: 55.33,
    0.5: 69.33,
    0.1: 85.53,
    0.05: 90.53,
    0.025: 95.02,
    0.01: 100.42,
    5e-3: 104.22
  },
  80: {
    0.995: 51.17,
    0.99: 53.54,
    0.975: 57.15,
    0.95: 60.39,
    0.9: 64.28,
    0.5: 79.33,
    0.1: 96.58,
    0.05: 101.88,
    0.025: 106.63,
    0.01: 112.33,
    5e-3: 116.32
  },
  90: {
    0.995: 59.2,
    0.99: 61.75,
    0.975: 65.65,
    0.95: 69.13,
    0.9: 73.29,
    0.5: 89.33,
    0.1: 107.57,
    0.05: 113.14,
    0.025: 118.14,
    0.01: 124.12,
    5e-3: 128.3
  },
  100: {
    0.995: 67.33,
    0.99: 70.06,
    0.975: 74.22,
    0.95: 77.93,
    0.9: 82.36,
    0.5: 99.33,
    0.1: 118.5,
    0.05: 124.34,
    0.025: 129.56,
    0.01: 135.81,
    5e-3: 140.17
  }
};
function chiSquaredGoodnessOfFit(data2, distributionType, significance) {
  var inputMean = mean(data2);
  var chiSquared = 0;
  var c2 = 1;
  var hypothesizedDistribution = distributionType(inputMean);
  var observedFrequencies = [];
  var expectedFrequencies = [];
  for (var i2 = 0; i2 < data2.length; i2++) {
    if (observedFrequencies[data2[i2]] === void 0) {
      observedFrequencies[data2[i2]] = 0;
    }
    observedFrequencies[data2[i2]]++;
  }
  for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
    if (observedFrequencies[i$1] === void 0) {
      observedFrequencies[i$1] = 0;
    }
  }
  for (var k2 in hypothesizedDistribution) {
    if (k2 in observedFrequencies) {
      expectedFrequencies[+k2] = hypothesizedDistribution[k2] * data2.length;
    }
  }
  for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
    if (expectedFrequencies[k$1] < 3) {
      expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
      expectedFrequencies.pop();
      observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
      observedFrequencies.pop();
    }
  }
  for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
    chiSquared += Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) / expectedFrequencies[k$2];
  }
  var degreesOfFreedom = observedFrequencies.length - c2 - 1;
  return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared;
}
var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);
var kernels = {
  /**
   * The gaussian kernel.
   * @private
   */
  gaussian: function(u2) {
    return Math.exp(-0.5 * u2 * u2) / SQRT_2PI$1;
  }
};
var bandwidthMethods = {
  /**
   * The ["normal reference distribution"
   * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
   * a commonly used version of [Silverman's
   * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
   * @private
   */
  nrd: function(x3) {
    var s2 = sampleStandardDeviation(x3);
    var iqr = interquartileRange(x3);
    if (typeof iqr === "number") {
      s2 = Math.min(s2, iqr / 1.34);
    }
    return 1.06 * s2 * Math.pow(x3.length, -0.2);
  }
};
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
  var kernelFn;
  if (kernel === void 0) {
    kernelFn = kernels.gaussian;
  } else if (typeof kernel === "string") {
    if (!kernels[kernel]) {
      throw new Error('Unknown kernel "' + kernel + '"');
    }
    kernelFn = kernels[kernel];
  } else {
    kernelFn = kernel;
  }
  var bandwidth;
  if (typeof bandwidthMethod === "undefined") {
    bandwidth = bandwidthMethods.nrd(X);
  } else if (typeof bandwidthMethod === "string") {
    if (!bandwidthMethods[bandwidthMethod]) {
      throw new Error(
        'Unknown bandwidth method "' + bandwidthMethod + '"'
      );
    }
    bandwidth = bandwidthMethods[bandwidthMethod](X);
  } else {
    bandwidth = bandwidthMethod;
  }
  return function(x3) {
    var i2 = 0;
    var sum4 = 0;
    for (i2 = 0; i2 < X.length; i2++) {
      sum4 += kernelFn((x3 - X[i2]) / bandwidth);
    }
    return sum4 / bandwidth / X.length;
  };
}
function zScore(x3, mean2, standardDeviation2) {
  return (x3 - mean2) / standardDeviation2;
}
var SQRT_2PI = Math.sqrt(2 * Math.PI);
function cumulativeDistribution(z2) {
  var sum4 = z2;
  var tmp = z2;
  for (var i2 = 1; i2 < 15; i2++) {
    tmp *= z2 * z2 / (2 * i2 + 1);
    sum4 += tmp;
  }
  return Math.round((0.5 + sum4 / SQRT_2PI * Math.exp(-z2 * z2 / 2)) * 1e4) / 1e4;
}
var standardNormalTable = [];
for (z2 = 0; z2 <= 3.09; z2 += 0.01) {
  standardNormalTable.push(cumulativeDistribution(z2));
}
var z2;
function cumulativeStdNormalProbability(z2) {
  var absZ = Math.abs(z2);
  var index2 = Math.min(
    Math.round(absZ * 100),
    standardNormalTable.length - 1
  );
  if (z2 >= 0) {
    return standardNormalTable[index2];
  } else {
    return Math.round((1 - standardNormalTable[index2]) * 1e4) / 1e4;
  }
}
function cumulativeStdLogisticProbability(x3) {
  return 1 / (Math.exp(-x3) + 1);
}
function errorFunction(x3) {
  var t2 = 1 / (1 + 0.5 * Math.abs(x3));
  var tau3 = t2 * Math.exp(
    -x3 * x3 + ((((((((0.17087277 * t2 - 0.82215223) * t2 + 1.48851587) * t2 - 1.13520398) * t2 + 0.27886807) * t2 - 0.18628806) * t2 + 0.09678418) * t2 + 0.37409196) * t2 + 1.00002368) * t2 - 1.26551223
  );
  if (x3 >= 0) {
    return 1 - tau3;
  } else {
    return tau3 - 1;
  }
}
function inverseErrorFunction(x3) {
  var a2 = 8 * (Math.PI - 3) / (3 * Math.PI * (4 - Math.PI));
  var inv = Math.sqrt(
    Math.sqrt(
      Math.pow(2 / (Math.PI * a2) + Math.log(1 - x3 * x3) / 2, 2) - Math.log(1 - x3 * x3) / a2
    ) - (2 / (Math.PI * a2) + Math.log(1 - x3 * x3) / 2)
  );
  if (x3 >= 0) {
    return inv;
  } else {
    return -inv;
  }
}
function probit(p2) {
  if (p2 === 0) {
    p2 = epsilon3;
  } else if (p2 >= 1) {
    p2 = 1 - epsilon3;
  }
  return Math.sqrt(2) * inverseErrorFunction(2 * p2 - 1);
}
function logit(p2) {
  if (p2 <= 0 || p2 >= 1) {
    throw new Error("p must be strictly between zero and one");
  }
  return Math.log(p2 / (1 - p2));
}
function permutationTest(sampleX, sampleY, alternative, k2, randomSource) {
  if (k2 === void 0) {
    k2 = 1e4;
  }
  if (alternative === void 0) {
    alternative = "two_side";
  }
  if (alternative !== "two_side" && alternative !== "greater" && alternative !== "less") {
    throw new Error(
      "`alternative` must be either 'two_side', 'greater', or 'less'."
    );
  }
  var meanX = mean(sampleX);
  var meanY = mean(sampleY);
  var testStatistic = meanX - meanY;
  var testStatDsn = new Array(k2);
  var allData = sampleX.concat(sampleY);
  var midIndex = Math.floor(allData.length / 2);
  for (var i2 = 0; i2 < k2; i2++) {
    shuffleInPlace(allData, randomSource);
    var permLeft = allData.slice(0, midIndex);
    var permRight = allData.slice(midIndex, allData.length);
    var permTestStatistic = mean(permLeft) - mean(permRight);
    testStatDsn[i2] = permTestStatistic;
  }
  var numExtremeTStats = 0;
  if (alternative === "two_side") {
    for (var i$1 = 0; i$1 <= k2; i$1++) {
      if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
        numExtremeTStats += 1;
      }
    }
  } else if (alternative === "greater") {
    for (var i$2 = 0; i$2 <= k2; i$2++) {
      if (testStatDsn[i$2] >= testStatistic) {
        numExtremeTStats += 1;
      }
    }
  } else {
    for (var i$3 = 0; i$3 <= k2; i$3++) {
      if (testStatDsn[i$3] <= testStatistic) {
        numExtremeTStats += 1;
      }
    }
  }
  return numExtremeTStats / k2;
}
function sign2(x3) {
  if (typeof x3 === "number") {
    if (x3 < 0) {
      return -1;
    } else if (x3 === 0) {
      return 0;
    } else {
      return 1;
    }
  } else {
    throw new TypeError("not a number");
  }
}
function bisect2(func, start, end, maxIterations, errorTolerance) {
  if (typeof func !== "function") {
    throw new TypeError("func must be a function");
  }
  for (var i2 = 0; i2 < maxIterations; i2++) {
    var output = (start + end) / 2;
    if (func(output) === 0 || Math.abs((end - start) / 2) < errorTolerance) {
      return output;
    }
    if (sign2(func(output)) === sign2(func(start))) {
      start = output;
    } else {
      end = output;
    }
  }
  throw new Error("maximum number of iterations exceeded");
}
function euclideanDistance(left, right) {
  var sum4 = 0;
  for (var i2 = 0; i2 < left.length; i2++) {
    var diff = left[i2] - right[i2];
    sum4 += diff * diff;
  }
  return Math.sqrt(sum4);
}
function kMeansCluster(points, numCluster, randomSource) {
  if (randomSource === void 0) randomSource = Math.random;
  var oldCentroids = null;
  var newCentroids = sample(points, numCluster, randomSource);
  var labels = null;
  var change = Number.MAX_VALUE;
  while (change !== 0) {
    labels = labelPoints(points, newCentroids);
    oldCentroids = newCentroids;
    newCentroids = calculateCentroids(points, labels, numCluster);
    change = calculateChange(newCentroids, oldCentroids);
  }
  return {
    labels,
    centroids: newCentroids
  };
}
function labelPoints(points, centroids) {
  return points.map(function(p2) {
    var minDist = Number.MAX_VALUE;
    var label = -1;
    for (var i2 = 0; i2 < centroids.length; i2++) {
      var dist = euclideanDistance(p2, centroids[i2]);
      if (dist < minDist) {
        minDist = dist;
        label = i2;
      }
    }
    return label;
  });
}
function calculateCentroids(points, labels, numCluster) {
  var dimension = points[0].length;
  var centroids = makeMatrix(numCluster, dimension);
  var counts = Array(numCluster).fill(0);
  var numPoints = points.length;
  for (var i2 = 0; i2 < numPoints; i2++) {
    var point2 = points[i2];
    var label = labels[i2];
    var current = centroids[label];
    for (var j2 = 0; j2 < dimension; j2++) {
      current[j2] += point2[j2];
    }
    counts[label] += 1;
  }
  for (var i$1 = 0; i$1 < numCluster; i$1++) {
    if (counts[i$1] === 0) {
      throw new Error("Centroid " + i$1 + " has no friends");
    }
    var centroid = centroids[i$1];
    for (var j$1 = 0; j$1 < dimension; j$1++) {
      centroid[j$1] /= counts[i$1];
    }
  }
  return centroids;
}
function calculateChange(left, right) {
  var total = 0;
  for (var i2 = 0; i2 < left.length; i2++) {
    total += euclideanDistance(left[i2], right[i2]);
  }
  return total;
}
function silhouette(points, labels) {
  if (points.length !== labels.length) {
    throw new Error("must have exactly as many labels as points");
  }
  var groupings = createGroups(labels);
  var distances = calculateAllDistances(points);
  var result = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var s2 = 0;
    if (groupings[labels[i2]].length > 1) {
      var a2 = meanDistanceFromPointToGroup(
        i2,
        groupings[labels[i2]],
        distances
      );
      var b2 = meanDistanceToNearestGroup(
        i2,
        labels,
        groupings,
        distances
      );
      s2 = (b2 - a2) / Math.max(a2, b2);
    }
    result.push(s2);
  }
  return result;
}
function createGroups(labels) {
  var numGroups = 1 + max2(labels);
  var result = Array(numGroups);
  for (var i2 = 0; i2 < labels.length; i2++) {
    var label = labels[i2];
    if (result[label] === void 0) {
      result[label] = [];
    }
    result[label].push(i2);
  }
  return result;
}
function calculateAllDistances(points) {
  var numPoints = points.length;
  var result = makeMatrix(numPoints, numPoints);
  for (var i2 = 0; i2 < numPoints; i2++) {
    for (var j2 = 0; j2 < i2; j2++) {
      result[i2][j2] = euclideanDistance(points[i2], points[j2]);
      result[j2][i2] = result[i2][j2];
    }
  }
  return result;
}
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
  var label = labels[which];
  var result = Number.MAX_VALUE;
  for (var i2 = 0; i2 < groupings.length; i2++) {
    if (i2 !== label) {
      var d2 = meanDistanceFromPointToGroup(
        which,
        groupings[i2],
        distances
      );
      if (d2 < result) {
        result = d2;
      }
    }
  }
  return result;
}
function meanDistanceFromPointToGroup(which, group, distances) {
  var total = 0;
  for (var i2 = 0; i2 < group.length; i2++) {
    total += distances[which][group[i2]];
  }
  return total / group.length;
}
function silhouetteMetric(points, labels) {
  var values = silhouette(points, labels);
  return max2(values);
}
function relativeError(actual, expected) {
  if (actual === 0 && expected === 0) {
    return 0;
  }
  return Math.abs((actual - expected) / expected);
}
function approxEqual(actual, expected, tolerance) {
  if (tolerance === void 0) tolerance = epsilon3;
  return relativeError(actual, expected) <= tolerance;
}

// node_modules/@turf/clone/dist/es/index.js
function clone2(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key2) {
    switch (key2) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key2] = geojson[key2];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key2) {
    var value2 = properties[key2];
    if (typeof value2 === "object") {
      if (value2 === null) {
        cloned[key2] = null;
      } else if (Array.isArray(value2)) {
        cloned[key2] = value2.map(function(item) {
          return item;
        });
      } else {
        cloned[key2] = cloneProperties(value2);
      }
    } else {
      cloned[key2] = value2;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key2) {
    switch (key2) {
      case "type":
      case "features":
        return;
      default:
        cloned[key2] = geojson[key2];
    }
  });
  cloned.features = geojson.features.map(function(feature3) {
    return cloneFeature(feature3);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  var geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map(function(g3) {
      return cloneGeometry(g3);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
}
var es_default = clone2;

// node_modules/@turf/invariant/dist/es/index.js
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}

// node_modules/@turf/boolean-clockwise/dist/es/index.js
function booleanClockwise(line) {
  var ring = getCoords(line);
  var sum4 = 0;
  var i2 = 1;
  var prev;
  var cur;
  while (i2 < ring.length) {
    prev = cur || ring[0];
    cur = ring[i2];
    sum4 += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i2++;
  }
  return sum4 > 0;
}

// node_modules/@turf/meta/dist/es/index.js
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i2 = 0; i2 < geojson.features.length; i2++) {
      if (callback(geojson.features[i2], i2) === false) break;
    }
  }
}
function geomEach(geojson, callback) {
  var i2, j2, g3, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i2 = 0; i2 < stop; i2++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i2].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i2].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i2].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i2].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g3 = 0; g3 < stopG; g3++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j2 = 0; j2 < geometry.geometries.length; j2++) {
            if (callback(
              geometry.geometries[j2],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}

// node_modules/@turf/rewind/dist/es/index.js
function rewind(geojson, options) {
  options = options || {};
  if (!isObject2(options)) throw new Error("options is invalid");
  var reverse2 = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson) throw new Error("<geojson> is required");
  if (typeof reverse2 !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false) geojson = es_default(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse2);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature3) {
        featureEach(rewindFeature(feature3, reverse2), function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse2);
}
function rewindFeature(geojson, reverse2) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse2);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse2);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse2);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse2);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse2);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse2) {
  if (booleanClockwise(coords) === reverse2) coords.reverse();
}
function rewindPolygon(coords, reverse2) {
  if (booleanClockwise(coords[0]) !== reverse2) {
    coords[0].reverse();
  }
  for (var i2 = 1; i2 < coords.length; i2++) {
    if (booleanClockwise(coords[i2]) === reverse2) {
      coords[i2].reverse();
    }
  }
}
var es_default2 = rewind;

// node_modules/@turf/flatten/dist/es/index.js
function flatten(geojson) {
  if (!geojson) throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature3) {
    results.push(feature3);
  });
  return featureCollection(results);
}
var es_default3 = flatten;

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum4 = 0, children = node.children, i2 = children && children.length;
  if (!i2) sum4 = 1;
  else while (--i2 >= 0) sum4 += children[i2].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i2, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i2 = children.length - 1; i2 >= 0; --i2) {
        nodes.push(children[i2]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i2, n2, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        nodes.push(children[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default2(value2) {
  return this.eachAfter(function(node) {
    var sum4 = +value2(node.data) || 0, children = node.children, i2 = children && children.length;
    while (--i2 >= 0) sum4 += children[i2].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b2) {
  if (a2 === b2) return a2;
  var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b2 = bNodes.pop();
  while (a2 === b2) {
    c2 = a2;
    a2 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c2;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i2, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          next.push(children[i2]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node(data2), node, nodes = [root], child, childs, i2, n2;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d2) {
  return d2.children;
}
function mapChildren(d2) {
  return Array.isArray(d2) ? d2[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default2,
  sort: sort_default,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent2, x05, y05, x13, y13) {
  var nodes = parent2.children, node, i2 = -1, n2 = nodes.length, k2 = parent2.value && (x13 - x05) / parent2.value;
  while (++i2 < n2) {
    node = nodes[i2], node.y0 = y05, node.y1 = y13;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/tree.js
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
TreeNode.prototype = Object.create(Node.prototype);

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent2, x05, y05, x13, y13) {
  var nodes = parent2.children, node, i2 = -1, n2 = nodes.length, k2 = parent2.value && (y13 - y05) / parent2.value;
  while (++i2 < n2) {
    node = nodes[i2], node.x0 = x05, node.x1 = x13;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent2, x05, y05, x13, y13) {
  var rows = [], nodes = parent2.children, row, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent2.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x13 - x05, dy = y13 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) dice_default(row, x05, y05, x13, value2 ? y05 += dy * sumValue / value2 : y13);
    else slice_default(row, x05, y05, value2 ? x05 += dx * sumValue / value2 : x13, y13);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent2, x05, y05, x13, y13) {
    squarifyRatio(ratio, parent2, x05, y05, x13, y13);
  }
  squarify.ratio = function(x3) {
    return custom((x3 = +x3) > 1 ? x3 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom2(ratio) {
  function resquarify(parent2, x05, y05, x13, y13) {
    if ((rows = parent2._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i2, j2 = -1, n2, m2 = rows.length, value2 = parent2.value;
      while (++j2 < m2) {
        row = rows[j2], nodes = row.children;
        for (i2 = row.value = 0, n2 = nodes.length; i2 < n2; ++i2) row.value += nodes[i2].value;
        if (row.dice) dice_default(row, x05, y05, x13, value2 ? y05 += (y13 - y05) * row.value / value2 : y13);
        else slice_default(row, x05, y05, value2 ? x05 += (x13 - x05) * row.value / value2 : x13, y13);
        value2 -= row.value;
      }
    } else {
      parent2._squarify = rows = squarifyRatio(ratio, parent2, x05, y05, x13, y13);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x3) {
    return custom2((x3 = +x3) > 1 ? x3 : 1);
  };
  return resquarify;
}(phi);

// node_modules/roughjs/bundled/rough.esm.js
function t(t2, e3, s2) {
  if (t2 && t2.length) {
    const [n2, a2] = e3, o2 = Math.PI / 180 * s2, h2 = Math.cos(o2), r2 = Math.sin(o2);
    t2.forEach((t3) => {
      const [e4, s3] = t3;
      t3[0] = (e4 - n2) * h2 - (s3 - a2) * r2 + n2, t3[1] = (e4 - n2) * r2 + (s3 - a2) * h2 + a2;
    });
  }
}
function e(t2) {
  const e3 = t2[0], s2 = t2[1];
  return Math.sqrt(Math.pow(e3[0] - s2[0], 2) + Math.pow(e3[1] - s2[1], 2));
}
function s(e3, s2) {
  const n2 = s2.hachureAngle + 90;
  let a2 = s2.hachureGap;
  a2 < 0 && (a2 = 4 * s2.strokeWidth), a2 = Math.max(a2, 0.1);
  const o2 = [0, 0];
  if (n2) for (const s3 of e3) t(s3, o2, n2);
  const h2 = function(t2, e4) {
    const s3 = [];
    for (const e6 of t2) {
      const t3 = [...e6];
      t3[0].join(",") !== t3[t3.length - 1].join(",") && t3.push([t3[0][0], t3[0][1]]), t3.length > 2 && s3.push(t3);
    }
    const n3 = [];
    e4 = Math.max(e4, 0.1);
    const a3 = [];
    for (const t3 of s3) for (let e6 = 0; e6 < t3.length - 1; e6++) {
      const s4 = t3[e6], n4 = t3[e6 + 1];
      if (s4[1] !== n4[1]) {
        const t4 = Math.min(s4[1], n4[1]);
        a3.push({ ymin: t4, ymax: Math.max(s4[1], n4[1]), x: t4 === s4[1] ? s4[0] : n4[0], islope: (n4[0] - s4[0]) / (n4[1] - s4[1]) });
      }
    }
    if (a3.sort((t3, e6) => t3.ymin < e6.ymin ? -1 : t3.ymin > e6.ymin ? 1 : t3.x < e6.x ? -1 : t3.x > e6.x ? 1 : t3.ymax === e6.ymax ? 0 : (t3.ymax - e6.ymax) / Math.abs(t3.ymax - e6.ymax)), !a3.length) return n3;
    let o3 = [], h3 = a3[0].ymin;
    for (; o3.length || a3.length; ) {
      if (a3.length) {
        let t3 = -1;
        for (let e6 = 0; e6 < a3.length && !(a3[e6].ymin > h3); e6++) t3 = e6;
        a3.splice(0, t3 + 1).forEach((t4) => {
          o3.push({ s: h3, edge: t4 });
        });
      }
      if (o3 = o3.filter((t3) => !(t3.edge.ymax <= h3)), o3.sort((t3, e6) => t3.edge.x === e6.edge.x ? 0 : (t3.edge.x - e6.edge.x) / Math.abs(t3.edge.x - e6.edge.x)), o3.length > 1) for (let t3 = 0; t3 < o3.length; t3 += 2) {
        const e6 = t3 + 1;
        if (e6 >= o3.length) break;
        const s4 = o3[t3].edge, a4 = o3[e6].edge;
        n3.push([[Math.round(s4.x), h3], [Math.round(a4.x), h3]]);
      }
      h3 += e4, o3.forEach((t3) => {
        t3.edge.x = t3.edge.x + e4 * t3.edge.islope;
      });
    }
    return n3;
  }(e3, a2);
  if (n2) {
    for (const s3 of e3) t(s3, o2, -n2);
    !function(e4, s3, n3) {
      const a3 = [];
      e4.forEach((t2) => a3.push(...t2)), t(a3, s3, n3);
    }(h2, o2, -n2);
  }
  return h2;
}
var n = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    return this._fillPolygons(t2, e3);
  }
  _fillPolygons(t2, e3) {
    const n2 = s(t2, e3);
    return { type: "fillSketch", ops: this.renderLines(n2, e3) };
  }
  renderLines(t2, e3) {
    const s2 = [];
    for (const n2 of t2) s2.push(...this.helper.doubleLineOps(n2[0][0], n2[0][1], n2[1][0], n2[1][1], e3));
    return s2;
  }
};
var a = class extends n {
  fillPolygons(t2, n2) {
    let a2 = n2.hachureGap;
    a2 < 0 && (a2 = 4 * n2.strokeWidth), a2 = Math.max(a2, 0.1);
    const o2 = s(t2, Object.assign({}, n2, { hachureGap: a2 })), h2 = Math.PI / 180 * n2.hachureAngle, r2 = [], i2 = 0.5 * a2 * Math.cos(h2), c2 = 0.5 * a2 * Math.sin(h2);
    for (const [t3, s2] of o2) e([t3, s2]) && r2.push([[t3[0] - i2, t3[1] + c2], [...s2]], [[t3[0] + i2, t3[1] - c2], [...s2]]);
    return { type: "fillSketch", ops: this.renderLines(r2, n2) };
  }
};
var o = class extends n {
  fillPolygons(t2, e3) {
    const s2 = this._fillPolygons(t2, e3), n2 = Object.assign({}, e3, { hachureAngle: e3.hachureAngle + 90 }), a2 = this._fillPolygons(t2, n2);
    return s2.ops = s2.ops.concat(a2.ops), s2;
  }
};
var h = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = s(t2, e3 = Object.assign({}, e3, { hachureAngle: 0 }));
    return this.dotsOnLines(n2, e3);
  }
  dotsOnLines(t2, s2) {
    const n2 = [];
    let a2 = s2.hachureGap;
    a2 < 0 && (a2 = 4 * s2.strokeWidth), a2 = Math.max(a2, 0.1);
    let o2 = s2.fillWeight;
    o2 < 0 && (o2 = s2.strokeWidth / 2);
    const h2 = a2 / 4;
    for (const r2 of t2) {
      const t3 = e(r2), i2 = t3 / a2, c2 = Math.ceil(i2) - 1, l2 = t3 - c2 * a2, u2 = (r2[0][0] + r2[1][0]) / 2 - a2 / 4, p2 = Math.min(r2[0][1], r2[1][1]);
      for (let t4 = 0; t4 < c2; t4++) {
        const e3 = p2 + l2 + t4 * a2, r3 = u2 - h2 + 2 * Math.random() * h2, i3 = e3 - h2 + 2 * Math.random() * h2, c3 = this.helper.ellipse(r3, i3, o2, o2, s2);
        n2.push(...c3.ops);
      }
    }
    return { type: "fillSketch", ops: n2 };
  }
};
var r = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = s(t2, e3);
    return { type: "fillSketch", ops: this.dashedLine(n2, e3) };
  }
  dashedLine(t2, s2) {
    const n2 = s2.dashOffset < 0 ? s2.hachureGap < 0 ? 4 * s2.strokeWidth : s2.hachureGap : s2.dashOffset, a2 = s2.dashGap < 0 ? s2.hachureGap < 0 ? 4 * s2.strokeWidth : s2.hachureGap : s2.dashGap, o2 = [];
    return t2.forEach((t3) => {
      const h2 = e(t3), r2 = Math.floor(h2 / (n2 + a2)), i2 = (h2 + a2 - r2 * (n2 + a2)) / 2;
      let c2 = t3[0], l2 = t3[1];
      c2[0] > l2[0] && (c2 = t3[1], l2 = t3[0]);
      const u2 = Math.atan((l2[1] - c2[1]) / (l2[0] - c2[0]));
      for (let t4 = 0; t4 < r2; t4++) {
        const e3 = t4 * (n2 + a2), h3 = e3 + n2, r3 = [c2[0] + e3 * Math.cos(u2) + i2 * Math.cos(u2), c2[1] + e3 * Math.sin(u2) + i2 * Math.sin(u2)], l3 = [c2[0] + h3 * Math.cos(u2) + i2 * Math.cos(u2), c2[1] + h3 * Math.sin(u2) + i2 * Math.sin(u2)];
        o2.push(...this.helper.doubleLineOps(r3[0], r3[1], l3[0], l3[1], s2));
      }
    }), o2;
  }
};
var i = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = e3.hachureGap < 0 ? 4 * e3.strokeWidth : e3.hachureGap, a2 = e3.zigzagOffset < 0 ? n2 : e3.zigzagOffset, o2 = s(t2, e3 = Object.assign({}, e3, { hachureGap: n2 + a2 }));
    return { type: "fillSketch", ops: this.zigzagLines(o2, a2, e3) };
  }
  zigzagLines(t2, s2, n2) {
    const a2 = [];
    return t2.forEach((t3) => {
      const o2 = e(t3), h2 = Math.round(o2 / (2 * s2));
      let r2 = t3[0], i2 = t3[1];
      r2[0] > i2[0] && (r2 = t3[1], i2 = t3[0]);
      const c2 = Math.atan((i2[1] - r2[1]) / (i2[0] - r2[0]));
      for (let t4 = 0; t4 < h2; t4++) {
        const e3 = 2 * t4 * s2, o3 = 2 * (t4 + 1) * s2, h3 = Math.sqrt(2 * Math.pow(s2, 2)), i3 = [r2[0] + e3 * Math.cos(c2), r2[1] + e3 * Math.sin(c2)], l2 = [r2[0] + o3 * Math.cos(c2), r2[1] + o3 * Math.sin(c2)], u2 = [i3[0] + h3 * Math.cos(c2 + Math.PI / 4), i3[1] + h3 * Math.sin(c2 + Math.PI / 4)];
        a2.push(...this.helper.doubleLineOps(i3[0], i3[1], u2[0], u2[1], n2), ...this.helper.doubleLineOps(u2[0], u2[1], l2[0], l2[1], n2));
      }
    }), a2;
  }
};
var c = {};
var l = class {
  constructor(t2) {
    this.seed = t2;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
var u = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function p(t2, e3) {
  return t2.type === e3;
}
function f(t2) {
  const e3 = [], s2 = function(t3) {
    const e4 = new Array();
    for (; "" !== t3; ) if (t3.match(/^([ \t\r\n,]+)/)) t3 = t3.substr(RegExp.$1.length);
    else if (t3.match(/^([aAcChHlLmMqQsStTvVzZ])/)) e4[e4.length] = { type: 0, text: RegExp.$1 }, t3 = t3.substr(RegExp.$1.length);
    else {
      if (!t3.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      e4[e4.length] = { type: 1, text: `${parseFloat(RegExp.$1)}` }, t3 = t3.substr(RegExp.$1.length);
    }
    return e4[e4.length] = { type: 2, text: "" }, e4;
  }(t2);
  let n2 = "BOD", a2 = 0, o2 = s2[a2];
  for (; !p(o2, 2); ) {
    let h2 = 0;
    const r2 = [];
    if ("BOD" === n2) {
      if ("M" !== o2.text && "m" !== o2.text) return f("M0,0" + t2);
      a2++, h2 = u[o2.text], n2 = o2.text;
    } else p(o2, 1) ? h2 = u[n2] : (a2++, h2 = u[o2.text], n2 = o2.text);
    if (!(a2 + h2 < s2.length)) throw new Error("Path data ended short");
    for (let t3 = a2; t3 < a2 + h2; t3++) {
      const e4 = s2[t3];
      if (!p(e4, 1)) throw new Error("Param not a number: " + n2 + "," + e4.text);
      r2[r2.length] = +e4.text;
    }
    if ("number" != typeof u[n2]) throw new Error("Bad segment: " + n2);
    {
      const t3 = { key: n2, data: r2 };
      e3.push(t3), a2 += h2, o2 = s2[a2], "M" === n2 && (n2 = "L"), "m" === n2 && (n2 = "l");
    }
  }
  return e3;
}
function d(t2) {
  let e3 = 0, s2 = 0, n2 = 0, a2 = 0;
  const o2 = [];
  for (const { key: h2, data: r2 } of t2) switch (h2) {
    case "M":
      o2.push({ key: "M", data: [...r2] }), [e3, s2] = r2, [n2, a2] = r2;
      break;
    case "m":
      e3 += r2[0], s2 += r2[1], o2.push({ key: "M", data: [e3, s2] }), n2 = e3, a2 = s2;
      break;
    case "L":
      o2.push({ key: "L", data: [...r2] }), [e3, s2] = r2;
      break;
    case "l":
      e3 += r2[0], s2 += r2[1], o2.push({ key: "L", data: [e3, s2] });
      break;
    case "C":
      o2.push({ key: "C", data: [...r2] }), e3 = r2[4], s2 = r2[5];
      break;
    case "c": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s2 : t4 + e3);
      o2.push({ key: "C", data: t3 }), e3 = t3[4], s2 = t3[5];
      break;
    }
    case "Q":
      o2.push({ key: "Q", data: [...r2] }), e3 = r2[2], s2 = r2[3];
      break;
    case "q": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s2 : t4 + e3);
      o2.push({ key: "Q", data: t3 }), e3 = t3[2], s2 = t3[3];
      break;
    }
    case "A":
      o2.push({ key: "A", data: [...r2] }), e3 = r2[5], s2 = r2[6];
      break;
    case "a":
      e3 += r2[5], s2 += r2[6], o2.push({ key: "A", data: [r2[0], r2[1], r2[2], r2[3], r2[4], e3, s2] });
      break;
    case "H":
      o2.push({ key: "H", data: [...r2] }), e3 = r2[0];
      break;
    case "h":
      e3 += r2[0], o2.push({ key: "H", data: [e3] });
      break;
    case "V":
      o2.push({ key: "V", data: [...r2] }), s2 = r2[0];
      break;
    case "v":
      s2 += r2[0], o2.push({ key: "V", data: [s2] });
      break;
    case "S":
      o2.push({ key: "S", data: [...r2] }), e3 = r2[2], s2 = r2[3];
      break;
    case "s": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s2 : t4 + e3);
      o2.push({ key: "S", data: t3 }), e3 = t3[2], s2 = t3[3];
      break;
    }
    case "T":
      o2.push({ key: "T", data: [...r2] }), e3 = r2[0], s2 = r2[1];
      break;
    case "t":
      e3 += r2[0], s2 += r2[1], o2.push({ key: "T", data: [e3, s2] });
      break;
    case "Z":
    case "z":
      o2.push({ key: "Z", data: [] }), e3 = n2, s2 = a2;
  }
  return o2;
}
function g2(t2) {
  const e3 = [];
  let s2 = "", n2 = 0, a2 = 0, o2 = 0, h2 = 0, r2 = 0, i2 = 0;
  for (const { key: c2, data: l2 } of t2) {
    switch (c2) {
      case "M":
        e3.push({ key: "M", data: [...l2] }), [n2, a2] = l2, [o2, h2] = l2;
        break;
      case "C":
        e3.push({ key: "C", data: [...l2] }), n2 = l2[4], a2 = l2[5], r2 = l2[2], i2 = l2[3];
        break;
      case "L":
        e3.push({ key: "L", data: [...l2] }), [n2, a2] = l2;
        break;
      case "H":
        n2 = l2[0], e3.push({ key: "L", data: [n2, a2] });
        break;
      case "V":
        a2 = l2[0], e3.push({ key: "L", data: [n2, a2] });
        break;
      case "S": {
        let t3 = 0, o3 = 0;
        "C" === s2 || "S" === s2 ? (t3 = n2 + (n2 - r2), o3 = a2 + (a2 - i2)) : (t3 = n2, o3 = a2), e3.push({ key: "C", data: [t3, o3, ...l2] }), r2 = l2[0], i2 = l2[1], n2 = l2[2], a2 = l2[3];
        break;
      }
      case "T": {
        const [t3, o3] = l2;
        let h3 = 0, c3 = 0;
        "Q" === s2 || "T" === s2 ? (h3 = n2 + (n2 - r2), c3 = a2 + (a2 - i2)) : (h3 = n2, c3 = a2);
        const u2 = n2 + 2 * (h3 - n2) / 3, p2 = a2 + 2 * (c3 - a2) / 3, f2 = t3 + 2 * (h3 - t3) / 3, d2 = o3 + 2 * (c3 - o3) / 3;
        e3.push({ key: "C", data: [u2, p2, f2, d2, t3, o3] }), r2 = h3, i2 = c3, n2 = t3, a2 = o3;
        break;
      }
      case "Q": {
        const [t3, s3, o3, h3] = l2, c3 = n2 + 2 * (t3 - n2) / 3, u2 = a2 + 2 * (s3 - a2) / 3, p2 = o3 + 2 * (t3 - o3) / 3, f2 = h3 + 2 * (s3 - h3) / 3;
        e3.push({ key: "C", data: [c3, u2, p2, f2, o3, h3] }), r2 = t3, i2 = s3, n2 = o3, a2 = h3;
        break;
      }
      case "A": {
        const t3 = Math.abs(l2[0]), s3 = Math.abs(l2[1]), o3 = l2[2], h3 = l2[3], r3 = l2[4], i3 = l2[5], c3 = l2[6];
        if (0 === t3 || 0 === s3) e3.push({ key: "C", data: [n2, a2, i3, c3, i3, c3] }), n2 = i3, a2 = c3;
        else if (n2 !== i3 || a2 !== c3) {
          k(n2, a2, i3, c3, t3, s3, o3, h3, r3).forEach(function(t4) {
            e3.push({ key: "C", data: t4 });
          }), n2 = i3, a2 = c3;
        }
        break;
      }
      case "Z":
        e3.push({ key: "Z", data: [] }), n2 = o2, a2 = h2;
    }
    s2 = c2;
  }
  return e3;
}
function M2(t2, e3, s2) {
  return [t2 * Math.cos(s2) - e3 * Math.sin(s2), t2 * Math.sin(s2) + e3 * Math.cos(s2)];
}
function k(t2, e3, s2, n2, a2, o2, h2, r2, i2, c2) {
  const l2 = (u2 = h2, Math.PI * u2 / 180);
  var u2;
  let p2 = [], f2 = 0, d2 = 0, g3 = 0, b2 = 0;
  if (c2) [f2, d2, g3, b2] = c2;
  else {
    [t2, e3] = M2(t2, e3, -l2), [s2, n2] = M2(s2, n2, -l2);
    const h3 = (t2 - s2) / 2, c3 = (e3 - n2) / 2;
    let u3 = h3 * h3 / (a2 * a2) + c3 * c3 / (o2 * o2);
    u3 > 1 && (u3 = Math.sqrt(u3), a2 *= u3, o2 *= u3);
    const p3 = a2 * a2, k2 = o2 * o2, y4 = p3 * k2 - p3 * c3 * c3 - k2 * h3 * h3, m3 = p3 * c3 * c3 + k2 * h3 * h3, w3 = (r2 === i2 ? -1 : 1) * Math.sqrt(Math.abs(y4 / m3));
    g3 = w3 * a2 * c3 / o2 + (t2 + s2) / 2, b2 = w3 * -o2 * h3 / a2 + (e3 + n2) / 2, f2 = Math.asin(parseFloat(((e3 - b2) / o2).toFixed(9))), d2 = Math.asin(parseFloat(((n2 - b2) / o2).toFixed(9))), t2 < g3 && (f2 = Math.PI - f2), s2 < g3 && (d2 = Math.PI - d2), f2 < 0 && (f2 = 2 * Math.PI + f2), d2 < 0 && (d2 = 2 * Math.PI + d2), i2 && f2 > d2 && (f2 -= 2 * Math.PI), !i2 && d2 > f2 && (d2 -= 2 * Math.PI);
  }
  let y3 = d2 - f2;
  if (Math.abs(y3) > 120 * Math.PI / 180) {
    const t3 = d2, e4 = s2, r3 = n2;
    d2 = i2 && d2 > f2 ? f2 + 120 * Math.PI / 180 * 1 : f2 + 120 * Math.PI / 180 * -1, p2 = k(s2 = g3 + a2 * Math.cos(d2), n2 = b2 + o2 * Math.sin(d2), e4, r3, a2, o2, h2, 0, i2, [d2, t3, g3, b2]);
  }
  y3 = d2 - f2;
  const m2 = Math.cos(f2), w2 = Math.sin(f2), x3 = Math.cos(d2), P2 = Math.sin(d2), v2 = Math.tan(y3 / 4), O2 = 4 / 3 * a2 * v2, S2 = 4 / 3 * o2 * v2, L2 = [t2, e3], T2 = [t2 + O2 * w2, e3 - S2 * m2], D2 = [s2 + O2 * P2, n2 - S2 * x3], A5 = [s2, n2];
  if (T2[0] = 2 * L2[0] - T2[0], T2[1] = 2 * L2[1] - T2[1], c2) return [T2, D2, A5].concat(p2);
  {
    p2 = [T2, D2, A5].concat(p2);
    const t3 = [];
    for (let e4 = 0; e4 < p2.length; e4 += 3) {
      const s3 = M2(p2[e4][0], p2[e4][1], l2), n3 = M2(p2[e4 + 1][0], p2[e4 + 1][1], l2), a3 = M2(p2[e4 + 2][0], p2[e4 + 2][1], l2);
      t3.push([s3[0], s3[1], n3[0], n3[1], a3[0], a3[1]]);
    }
    return t3;
  }
}
var b = { randOffset: function(t2, e3) {
  return A(t2, e3);
}, randOffsetWithRange: function(t2, e3, s2) {
  return D(t2, e3, s2);
}, ellipse: function(t2, e3, s2, n2, a2) {
  const o2 = P(s2, n2, a2);
  return v(t2, e3, a2, o2).opset;
}, doubleLineOps: function(t2, e3, s2, n2, a2) {
  return I(t2, e3, s2, n2, a2, true);
} };
function y(t2, e3, s2, n2, a2) {
  return { type: "path", ops: I(t2, e3, s2, n2, a2) };
}
function m(t2, e3, s2) {
  const n2 = (t2 || []).length;
  if (n2 > 2) {
    const a2 = [];
    for (let e4 = 0; e4 < n2 - 1; e4++) a2.push(...I(t2[e4][0], t2[e4][1], t2[e4 + 1][0], t2[e4 + 1][1], s2));
    return e3 && a2.push(...I(t2[n2 - 1][0], t2[n2 - 1][1], t2[0][0], t2[0][1], s2)), { type: "path", ops: a2 };
  }
  return 2 === n2 ? y(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s2) : { type: "path", ops: [] };
}
function w(t2, e3, s2, n2, a2) {
  return function(t3, e4) {
    return m(t3, true, e4);
  }([[t2, e3], [t2 + s2, e3], [t2 + s2, e3 + n2], [t2, e3 + n2]], a2);
}
function x(t2, e3) {
  let s2 = _(t2, 1 * (1 + 0.2 * e3.roughness), e3);
  if (!e3.disableMultiStroke) {
    const n2 = _(t2, 1.5 * (1 + 0.22 * e3.roughness), function(t3) {
      const e4 = Object.assign({}, t3);
      e4.randomizer = void 0, t3.seed && (e4.seed = t3.seed + 1);
      return e4;
    }(e3));
    s2 = s2.concat(n2);
  }
  return { type: "path", ops: s2 };
}
function P(t2, e3, s2) {
  const n2 = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t2 / 2, 2) + Math.pow(e3 / 2, 2)) / 2)), a2 = Math.ceil(Math.max(s2.curveStepCount, s2.curveStepCount / Math.sqrt(200) * n2)), o2 = 2 * Math.PI / a2;
  let h2 = Math.abs(t2 / 2), r2 = Math.abs(e3 / 2);
  const i2 = 1 - s2.curveFitting;
  return h2 += A(h2 * i2, s2), r2 += A(r2 * i2, s2), { increment: o2, rx: h2, ry: r2 };
}
function v(t2, e3, s2, n2) {
  const [a2, o2] = z(n2.increment, t2, e3, n2.rx, n2.ry, 1, n2.increment * D(0.1, D(0.4, 1, s2), s2), s2);
  let h2 = W(a2, null, s2);
  if (!s2.disableMultiStroke && 0 !== s2.roughness) {
    const [a3] = z(n2.increment, t2, e3, n2.rx, n2.ry, 1.5, 0, s2), o3 = W(a3, null, s2);
    h2 = h2.concat(o3);
  }
  return { estimatedPoints: o2, opset: { type: "path", ops: h2 } };
}
function O(t2, e3, s2, n2, a2, o2, h2, r2, i2) {
  const c2 = t2, l2 = e3;
  let u2 = Math.abs(s2 / 2), p2 = Math.abs(n2 / 2);
  u2 += A(0.01 * u2, i2), p2 += A(0.01 * p2, i2);
  let f2 = a2, d2 = o2;
  for (; f2 < 0; ) f2 += 2 * Math.PI, d2 += 2 * Math.PI;
  d2 - f2 > 2 * Math.PI && (f2 = 0, d2 = 2 * Math.PI);
  const g3 = 2 * Math.PI / i2.curveStepCount, M3 = Math.min(g3 / 2, (d2 - f2) / 2), k2 = E(M3, c2, l2, u2, p2, f2, d2, 1, i2);
  if (!i2.disableMultiStroke) {
    const t3 = E(M3, c2, l2, u2, p2, f2, d2, 1.5, i2);
    k2.push(...t3);
  }
  return h2 && (r2 ? k2.push(...I(c2, l2, c2 + u2 * Math.cos(f2), l2 + p2 * Math.sin(f2), i2), ...I(c2, l2, c2 + u2 * Math.cos(d2), l2 + p2 * Math.sin(d2), i2)) : k2.push({ op: "lineTo", data: [c2, l2] }, { op: "lineTo", data: [c2 + u2 * Math.cos(f2), l2 + p2 * Math.sin(f2)] })), { type: "path", ops: k2 };
}
function S(t2, e3) {
  const s2 = [];
  for (const n2 of t2) if (n2.length) {
    const t3 = e3.maxRandomnessOffset || 0, a2 = n2.length;
    if (a2 > 2) {
      s2.push({ op: "move", data: [n2[0][0] + A(t3, e3), n2[0][1] + A(t3, e3)] });
      for (let o2 = 1; o2 < a2; o2++) s2.push({ op: "lineTo", data: [n2[o2][0] + A(t3, e3), n2[o2][1] + A(t3, e3)] });
    }
  }
  return { type: "fillPath", ops: s2 };
}
function L(t2, e3) {
  return function(t3, e4) {
    let s2 = t3.fillStyle || "hachure";
    if (!c[s2]) switch (s2) {
      case "zigzag":
        c[s2] || (c[s2] = new a(e4));
        break;
      case "cross-hatch":
        c[s2] || (c[s2] = new o(e4));
        break;
      case "dots":
        c[s2] || (c[s2] = new h(e4));
        break;
      case "dashed":
        c[s2] || (c[s2] = new r(e4));
        break;
      case "zigzag-line":
        c[s2] || (c[s2] = new i(e4));
        break;
      case "hachure":
      default:
        s2 = "hachure", c[s2] || (c[s2] = new n(e4));
    }
    return c[s2];
  }(e3, b).fillPolygons(t2, e3);
}
function T(t2) {
  return t2.randomizer || (t2.randomizer = new l(t2.seed || 0)), t2.randomizer.next();
}
function D(t2, e3, s2, n2 = 1) {
  return s2.roughness * n2 * (T(s2) * (e3 - t2) + t2);
}
function A(t2, e3, s2 = 1) {
  return D(-t2, t2, e3, s2);
}
function I(t2, e3, s2, n2, a2, o2 = false) {
  const h2 = o2 ? a2.disableMultiStrokeFill : a2.disableMultiStroke, r2 = C(t2, e3, s2, n2, a2, true, false);
  if (h2) return r2;
  const i2 = C(t2, e3, s2, n2, a2, true, true);
  return r2.concat(i2);
}
function C(t2, e3, s2, n2, a2, o2, h2) {
  const r2 = Math.pow(t2 - s2, 2) + Math.pow(e3 - n2, 2), i2 = Math.sqrt(r2);
  let c2 = 1;
  c2 = i2 < 200 ? 1 : i2 > 500 ? 0.4 : -16668e-7 * i2 + 1.233334;
  let l2 = a2.maxRandomnessOffset || 0;
  l2 * l2 * 100 > r2 && (l2 = i2 / 10);
  const u2 = l2 / 2, p2 = 0.2 + 0.2 * T(a2);
  let f2 = a2.bowing * a2.maxRandomnessOffset * (n2 - e3) / 200, d2 = a2.bowing * a2.maxRandomnessOffset * (t2 - s2) / 200;
  f2 = A(f2, a2, c2), d2 = A(d2, a2, c2);
  const g3 = [], M3 = () => A(u2, a2, c2), k2 = () => A(l2, a2, c2), b2 = a2.preserveVertices;
  return o2 && (h2 ? g3.push({ op: "move", data: [t2 + (b2 ? 0 : M3()), e3 + (b2 ? 0 : M3())] }) : g3.push({ op: "move", data: [t2 + (b2 ? 0 : A(l2, a2, c2)), e3 + (b2 ? 0 : A(l2, a2, c2))] })), h2 ? g3.push({ op: "bcurveTo", data: [f2 + t2 + (s2 - t2) * p2 + M3(), d2 + e3 + (n2 - e3) * p2 + M3(), f2 + t2 + 2 * (s2 - t2) * p2 + M3(), d2 + e3 + 2 * (n2 - e3) * p2 + M3(), s2 + (b2 ? 0 : M3()), n2 + (b2 ? 0 : M3())] }) : g3.push({ op: "bcurveTo", data: [f2 + t2 + (s2 - t2) * p2 + k2(), d2 + e3 + (n2 - e3) * p2 + k2(), f2 + t2 + 2 * (s2 - t2) * p2 + k2(), d2 + e3 + 2 * (n2 - e3) * p2 + k2(), s2 + (b2 ? 0 : k2()), n2 + (b2 ? 0 : k2())] }), g3;
}
function _(t2, e3, s2) {
  const n2 = [];
  n2.push([t2[0][0] + A(e3, s2), t2[0][1] + A(e3, s2)]), n2.push([t2[0][0] + A(e3, s2), t2[0][1] + A(e3, s2)]);
  for (let a2 = 1; a2 < t2.length; a2++) n2.push([t2[a2][0] + A(e3, s2), t2[a2][1] + A(e3, s2)]), a2 === t2.length - 1 && n2.push([t2[a2][0] + A(e3, s2), t2[a2][1] + A(e3, s2)]);
  return W(n2, null, s2);
}
function W(t2, e3, s2) {
  const n2 = t2.length, a2 = [];
  if (n2 > 3) {
    const o2 = [], h2 = 1 - s2.curveTightness;
    a2.push({ op: "move", data: [t2[1][0], t2[1][1]] });
    for (let e4 = 1; e4 + 2 < n2; e4++) {
      const s3 = t2[e4];
      o2[0] = [s3[0], s3[1]], o2[1] = [s3[0] + (h2 * t2[e4 + 1][0] - h2 * t2[e4 - 1][0]) / 6, s3[1] + (h2 * t2[e4 + 1][1] - h2 * t2[e4 - 1][1]) / 6], o2[2] = [t2[e4 + 1][0] + (h2 * t2[e4][0] - h2 * t2[e4 + 2][0]) / 6, t2[e4 + 1][1] + (h2 * t2[e4][1] - h2 * t2[e4 + 2][1]) / 6], o2[3] = [t2[e4 + 1][0], t2[e4 + 1][1]], a2.push({ op: "bcurveTo", data: [o2[1][0], o2[1][1], o2[2][0], o2[2][1], o2[3][0], o2[3][1]] });
    }
    if (e3 && 2 === e3.length) {
      const t3 = s2.maxRandomnessOffset;
      a2.push({ op: "lineTo", data: [e3[0] + A(t3, s2), e3[1] + A(t3, s2)] });
    }
  } else 3 === n2 ? (a2.push({ op: "move", data: [t2[1][0], t2[1][1]] }), a2.push({ op: "bcurveTo", data: [t2[1][0], t2[1][1], t2[2][0], t2[2][1], t2[2][0], t2[2][1]] })) : 2 === n2 && a2.push(...I(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s2));
  return a2;
}
function z(t2, e3, s2, n2, a2, o2, h2, r2) {
  const i2 = [], c2 = [];
  if (0 === r2.roughness) {
    t2 /= 4, c2.push([e3 + n2 * Math.cos(-t2), s2 + a2 * Math.sin(-t2)]);
    for (let o3 = 0; o3 <= 2 * Math.PI; o3 += t2) {
      const t3 = [e3 + n2 * Math.cos(o3), s2 + a2 * Math.sin(o3)];
      i2.push(t3), c2.push(t3);
    }
    c2.push([e3 + n2 * Math.cos(0), s2 + a2 * Math.sin(0)]), c2.push([e3 + n2 * Math.cos(t2), s2 + a2 * Math.sin(t2)]);
  } else {
    const l2 = A(0.5, r2) - Math.PI / 2;
    c2.push([A(o2, r2) + e3 + 0.9 * n2 * Math.cos(l2 - t2), A(o2, r2) + s2 + 0.9 * a2 * Math.sin(l2 - t2)]);
    const u2 = 2 * Math.PI + l2 - 0.01;
    for (let h3 = l2; h3 < u2; h3 += t2) {
      const t3 = [A(o2, r2) + e3 + n2 * Math.cos(h3), A(o2, r2) + s2 + a2 * Math.sin(h3)];
      i2.push(t3), c2.push(t3);
    }
    c2.push([A(o2, r2) + e3 + n2 * Math.cos(l2 + 2 * Math.PI + 0.5 * h2), A(o2, r2) + s2 + a2 * Math.sin(l2 + 2 * Math.PI + 0.5 * h2)]), c2.push([A(o2, r2) + e3 + 0.98 * n2 * Math.cos(l2 + h2), A(o2, r2) + s2 + 0.98 * a2 * Math.sin(l2 + h2)]), c2.push([A(o2, r2) + e3 + 0.9 * n2 * Math.cos(l2 + 0.5 * h2), A(o2, r2) + s2 + 0.9 * a2 * Math.sin(l2 + 0.5 * h2)]);
  }
  return [c2, i2];
}
function E(t2, e3, s2, n2, a2, o2, h2, r2, i2) {
  const c2 = o2 + A(0.1, i2), l2 = [];
  l2.push([A(r2, i2) + e3 + 0.9 * n2 * Math.cos(c2 - t2), A(r2, i2) + s2 + 0.9 * a2 * Math.sin(c2 - t2)]);
  for (let o3 = c2; o3 <= h2; o3 += t2) l2.push([A(r2, i2) + e3 + n2 * Math.cos(o3), A(r2, i2) + s2 + a2 * Math.sin(o3)]);
  return l2.push([e3 + n2 * Math.cos(h2), s2 + a2 * Math.sin(h2)]), l2.push([e3 + n2 * Math.cos(h2), s2 + a2 * Math.sin(h2)]), W(l2, null, i2);
}
function $(t2, e3, s2, n2, a2, o2, h2, r2) {
  const i2 = [], c2 = [r2.maxRandomnessOffset || 1, (r2.maxRandomnessOffset || 1) + 0.3];
  let l2 = [0, 0];
  const u2 = r2.disableMultiStroke ? 1 : 2, p2 = r2.preserveVertices;
  for (let f2 = 0; f2 < u2; f2++) 0 === f2 ? i2.push({ op: "move", data: [h2[0], h2[1]] }) : i2.push({ op: "move", data: [h2[0] + (p2 ? 0 : A(c2[0], r2)), h2[1] + (p2 ? 0 : A(c2[0], r2))] }), l2 = p2 ? [a2, o2] : [a2 + A(c2[f2], r2), o2 + A(c2[f2], r2)], i2.push({ op: "bcurveTo", data: [t2 + A(c2[f2], r2), e3 + A(c2[f2], r2), s2 + A(c2[f2], r2), n2 + A(c2[f2], r2), l2[0], l2[1]] });
  return i2;
}
function G(t2) {
  return [...t2];
}
function R(t2, e3) {
  return Math.pow(t2[0] - e3[0], 2) + Math.pow(t2[1] - e3[1], 2);
}
function q(t2, e3, s2) {
  const n2 = R(e3, s2);
  if (0 === n2) return R(t2, e3);
  let a2 = ((t2[0] - e3[0]) * (s2[0] - e3[0]) + (t2[1] - e3[1]) * (s2[1] - e3[1])) / n2;
  return a2 = Math.max(0, Math.min(1, a2)), R(t2, j(e3, s2, a2));
}
function j(t2, e3, s2) {
  return [t2[0] + (e3[0] - t2[0]) * s2, t2[1] + (e3[1] - t2[1]) * s2];
}
function F(t2, e3, s2, n2) {
  const a2 = n2 || [];
  if (function(t3, e4) {
    const s3 = t3[e4 + 0], n3 = t3[e4 + 1], a3 = t3[e4 + 2], o3 = t3[e4 + 3];
    let h3 = 3 * n3[0] - 2 * s3[0] - o3[0];
    h3 *= h3;
    let r2 = 3 * n3[1] - 2 * s3[1] - o3[1];
    r2 *= r2;
    let i2 = 3 * a3[0] - 2 * o3[0] - s3[0];
    i2 *= i2;
    let c2 = 3 * a3[1] - 2 * o3[1] - s3[1];
    return c2 *= c2, h3 < i2 && (h3 = i2), r2 < c2 && (r2 = c2), h3 + r2;
  }(t2, e3) < s2) {
    const s3 = t2[e3 + 0];
    if (a2.length) {
      (o2 = a2[a2.length - 1], h2 = s3, Math.sqrt(R(o2, h2))) > 1 && a2.push(s3);
    } else a2.push(s3);
    a2.push(t2[e3 + 3]);
  } else {
    const n3 = 0.5, o3 = t2[e3 + 0], h3 = t2[e3 + 1], r2 = t2[e3 + 2], i2 = t2[e3 + 3], c2 = j(o3, h3, n3), l2 = j(h3, r2, n3), u2 = j(r2, i2, n3), p2 = j(c2, l2, n3), f2 = j(l2, u2, n3), d2 = j(p2, f2, n3);
    F([o3, c2, p2, d2], 0, s2, a2), F([d2, f2, u2, i2], 0, s2, a2);
  }
  var o2, h2;
  return a2;
}
function V(t2, e3) {
  return Z(t2, 0, t2.length, e3);
}
function Z(t2, e3, s2, n2, a2) {
  const o2 = a2 || [], h2 = t2[e3], r2 = t2[s2 - 1];
  let i2 = 0, c2 = 1;
  for (let n3 = e3 + 1; n3 < s2 - 1; ++n3) {
    const e4 = q(t2[n3], h2, r2);
    e4 > i2 && (i2 = e4, c2 = n3);
  }
  return Math.sqrt(i2) > n2 ? (Z(t2, e3, c2 + 1, n2, o2), Z(t2, c2, s2, n2, o2)) : (o2.length || o2.push(h2), o2.push(r2)), o2;
}
function Q(t2, e3 = 0.15, s2) {
  const n2 = [], a2 = (t2.length - 1) / 3;
  for (let s3 = 0; s3 < a2; s3++) {
    F(t2, 3 * s3, e3, n2);
  }
  return s2 && s2 > 0 ? Z(n2, 0, n2.length, s2) : n2;
}
var H = "none";
var N = class {
  constructor(t2) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: false, disableMultiStrokeFill: false, preserveVertices: false }, this.config = t2 || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(t2) {
    return t2 ? Object.assign({}, this.defaultOptions, t2) : this.defaultOptions;
  }
  _d(t2, e3, s2) {
    return { shape: t2, sets: e3 || [], options: s2 || this.defaultOptions };
  }
  line(t2, e3, s2, n2, a2) {
    const o2 = this._o(a2);
    return this._d("line", [y(t2, e3, s2, n2, o2)], o2);
  }
  rectangle(t2, e3, s2, n2, a2) {
    const o2 = this._o(a2), h2 = [], r2 = w(t2, e3, s2, n2, o2);
    if (o2.fill) {
      const a3 = [[t2, e3], [t2 + s2, e3], [t2 + s2, e3 + n2], [t2, e3 + n2]];
      "solid" === o2.fillStyle ? h2.push(S([a3], o2)) : h2.push(L([a3], o2));
    }
    return o2.stroke !== H && h2.push(r2), this._d("rectangle", h2, o2);
  }
  ellipse(t2, e3, s2, n2, a2) {
    const o2 = this._o(a2), h2 = [], r2 = P(s2, n2, o2), i2 = v(t2, e3, o2, r2);
    if (o2.fill) if ("solid" === o2.fillStyle) {
      const s3 = v(t2, e3, o2, r2).opset;
      s3.type = "fillPath", h2.push(s3);
    } else h2.push(L([i2.estimatedPoints], o2));
    return o2.stroke !== H && h2.push(i2.opset), this._d("ellipse", h2, o2);
  }
  circle(t2, e3, s2, n2) {
    const a2 = this.ellipse(t2, e3, s2, s2, n2);
    return a2.shape = "circle", a2;
  }
  linearPath(t2, e3) {
    const s2 = this._o(e3);
    return this._d("linearPath", [m(t2, false, s2)], s2);
  }
  arc(t2, e3, s2, n2, a2, o2, h2 = false, r2) {
    const i2 = this._o(r2), c2 = [], l2 = O(t2, e3, s2, n2, a2, o2, h2, true, i2);
    if (h2 && i2.fill) if ("solid" === i2.fillStyle) {
      const h3 = Object.assign({}, i2);
      h3.disableMultiStroke = true;
      const r3 = O(t2, e3, s2, n2, a2, o2, true, false, h3);
      r3.type = "fillPath", c2.push(r3);
    } else c2.push(function(t3, e4, s3, n3, a3, o3, h3) {
      const r3 = t3, i3 = e4;
      let c3 = Math.abs(s3 / 2), l3 = Math.abs(n3 / 2);
      c3 += A(0.01 * c3, h3), l3 += A(0.01 * l3, h3);
      let u2 = a3, p2 = o3;
      for (; u2 < 0; ) u2 += 2 * Math.PI, p2 += 2 * Math.PI;
      p2 - u2 > 2 * Math.PI && (u2 = 0, p2 = 2 * Math.PI);
      const f2 = (p2 - u2) / h3.curveStepCount, d2 = [];
      for (let t4 = u2; t4 <= p2; t4 += f2) d2.push([r3 + c3 * Math.cos(t4), i3 + l3 * Math.sin(t4)]);
      return d2.push([r3 + c3 * Math.cos(p2), i3 + l3 * Math.sin(p2)]), d2.push([r3, i3]), L([d2], h3);
    }(t2, e3, s2, n2, a2, o2, i2));
    return i2.stroke !== H && c2.push(l2), this._d("arc", c2, i2);
  }
  curve(t2, e3) {
    const s2 = this._o(e3), n2 = [], a2 = x(t2, s2);
    if (s2.fill && s2.fill !== H && t2.length >= 3) {
      const e4 = Q(function(t3, e6 = 0) {
        const s3 = t3.length;
        if (s3 < 3) throw new Error("A curve must have at least three points.");
        const n3 = [];
        if (3 === s3) n3.push(G(t3[0]), G(t3[1]), G(t3[2]), G(t3[2]));
        else {
          const s4 = [];
          s4.push(t3[0], t3[0]);
          for (let e7 = 1; e7 < t3.length; e7++) s4.push(t3[e7]), e7 === t3.length - 1 && s4.push(t3[e7]);
          const a3 = [], o2 = 1 - e6;
          n3.push(G(s4[0]));
          for (let t4 = 1; t4 + 2 < s4.length; t4++) {
            const e7 = s4[t4];
            a3[0] = [e7[0], e7[1]], a3[1] = [e7[0] + (o2 * s4[t4 + 1][0] - o2 * s4[t4 - 1][0]) / 6, e7[1] + (o2 * s4[t4 + 1][1] - o2 * s4[t4 - 1][1]) / 6], a3[2] = [s4[t4 + 1][0] + (o2 * s4[t4][0] - o2 * s4[t4 + 2][0]) / 6, s4[t4 + 1][1] + (o2 * s4[t4][1] - o2 * s4[t4 + 2][1]) / 6], a3[3] = [s4[t4 + 1][0], s4[t4 + 1][1]], n3.push(a3[1], a3[2], a3[3]);
          }
        }
        return n3;
      }(t2), 10, (1 + s2.roughness) / 2);
      "solid" === s2.fillStyle ? n2.push(S([e4], s2)) : n2.push(L([e4], s2));
    }
    return s2.stroke !== H && n2.push(a2), this._d("curve", n2, s2);
  }
  polygon(t2, e3) {
    const s2 = this._o(e3), n2 = [], a2 = m(t2, true, s2);
    return s2.fill && ("solid" === s2.fillStyle ? n2.push(S([t2], s2)) : n2.push(L([t2], s2))), s2.stroke !== H && n2.push(a2), this._d("polygon", n2, s2);
  }
  path(t2, e3) {
    const s2 = this._o(e3), n2 = [];
    if (!t2) return this._d("path", n2, s2);
    t2 = (t2 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a2 = s2.fill && "transparent" !== s2.fill && s2.fill !== H, o2 = s2.stroke !== H, h2 = !!(s2.simplification && s2.simplification < 1), r2 = function(t3, e4, s3) {
      const n3 = g2(d(f(t3))), a3 = [];
      let o3 = [], h3 = [0, 0], r3 = [];
      const i2 = () => {
        r3.length >= 4 && o3.push(...Q(r3, e4)), r3 = [];
      }, c2 = () => {
        i2(), o3.length && (a3.push(o3), o3 = []);
      };
      for (const { key: t4, data: e6 } of n3) switch (t4) {
        case "M":
          c2(), h3 = [e6[0], e6[1]], o3.push(h3);
          break;
        case "L":
          i2(), o3.push([e6[0], e6[1]]);
          break;
        case "C":
          if (!r3.length) {
            const t5 = o3.length ? o3[o3.length - 1] : h3;
            r3.push([t5[0], t5[1]]);
          }
          r3.push([e6[0], e6[1]]), r3.push([e6[2], e6[3]]), r3.push([e6[4], e6[5]]);
          break;
        case "Z":
          i2(), o3.push([h3[0], h3[1]]);
      }
      if (c2(), !s3) return a3;
      const l2 = [];
      for (const t4 of a3) {
        const e6 = V(t4, s3);
        e6.length && l2.push(e6);
      }
      return l2;
    }(t2, 1, h2 ? 4 - 4 * s2.simplification : (1 + s2.roughness) / 2);
    return a2 && ("solid" === s2.fillStyle ? n2.push(S(r2, s2)) : n2.push(L(r2, s2))), o2 && (h2 ? r2.forEach((t3) => {
      n2.push(m(t3, false, s2));
    }) : n2.push(function(t3, e4) {
      const s3 = g2(d(f(t3))), n3 = [];
      let a3 = [0, 0], o3 = [0, 0];
      for (const { key: t4, data: h3 } of s3) switch (t4) {
        case "M": {
          const t5 = 1 * (e4.maxRandomnessOffset || 0), s4 = e4.preserveVertices;
          n3.push({ op: "move", data: h3.map((n4) => n4 + (s4 ? 0 : A(t5, e4))) }), o3 = [h3[0], h3[1]], a3 = [h3[0], h3[1]];
          break;
        }
        case "L":
          n3.push(...I(o3[0], o3[1], h3[0], h3[1], e4)), o3 = [h3[0], h3[1]];
          break;
        case "C": {
          const [t5, s4, a4, r3, i2, c2] = h3;
          n3.push(...$(t5, s4, a4, r3, i2, c2, o3, e4)), o3 = [i2, c2];
          break;
        }
        case "Z":
          n3.push(...I(o3[0], o3[1], a3[0], a3[1], e4)), o3 = [a3[0], a3[1]];
      }
      return { type: "path", ops: n3 };
    }(t2, s2))), this._d("path", n2, s2);
  }
  opsToPath(t2, e3) {
    let s2 = "";
    for (const n2 of t2.ops) {
      const t3 = "number" == typeof e3 && e3 >= 0 ? n2.data.map((t4) => +t4.toFixed(e3)) : n2.data;
      switch (n2.op) {
        case "move":
          s2 += `M${t3[0]} ${t3[1]} `;
          break;
        case "bcurveTo":
          s2 += `C${t3[0]} ${t3[1]}, ${t3[2]} ${t3[3]}, ${t3[4]} ${t3[5]} `;
          break;
        case "lineTo":
          s2 += `L${t3[0]} ${t3[1]} `;
      }
    }
    return s2.trim();
  }
  toPaths(t2) {
    const e3 = t2.sets || [], s2 = t2.options || this.defaultOptions, n2 = [];
    for (const t3 of e3) {
      let e4 = null;
      switch (t3.type) {
        case "path":
          e4 = { d: this.opsToPath(t3), stroke: s2.stroke, strokeWidth: s2.strokeWidth, fill: H };
          break;
        case "fillPath":
          e4 = { d: this.opsToPath(t3), stroke: H, strokeWidth: 0, fill: s2.fill || H };
          break;
        case "fillSketch":
          e4 = this.fillSketch(t3, s2);
      }
      e4 && n2.push(e4);
    }
    return n2;
  }
  fillSketch(t2, e3) {
    let s2 = e3.fillWeight;
    return s2 < 0 && (s2 = e3.strokeWidth / 2), { d: this.opsToPath(t2), stroke: e3.fill || H, strokeWidth: s2, fill: H };
  }
};
var B = class {
  constructor(t2, e3) {
    this.canvas = t2, this.ctx = this.canvas.getContext("2d"), this.gen = new N(e3);
  }
  draw(t2) {
    const e3 = t2.sets || [], s2 = t2.options || this.getDefaultOptions(), n2 = this.ctx, a2 = t2.options.fixedDecimalPlaceDigits;
    for (const o2 of e3) switch (o2.type) {
      case "path":
        n2.save(), n2.strokeStyle = "none" === s2.stroke ? "transparent" : s2.stroke, n2.lineWidth = s2.strokeWidth, s2.strokeLineDash && n2.setLineDash(s2.strokeLineDash), s2.strokeLineDashOffset && (n2.lineDashOffset = s2.strokeLineDashOffset), this._drawToContext(n2, o2, a2), n2.restore();
        break;
      case "fillPath": {
        n2.save(), n2.fillStyle = s2.fill || "";
        const e4 = "curve" === t2.shape || "polygon" === t2.shape || "path" === t2.shape ? "evenodd" : "nonzero";
        this._drawToContext(n2, o2, a2, e4), n2.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(n2, o2, s2);
    }
  }
  fillSketch(t2, e3, s2) {
    let n2 = s2.fillWeight;
    n2 < 0 && (n2 = s2.strokeWidth / 2), t2.save(), s2.fillLineDash && t2.setLineDash(s2.fillLineDash), s2.fillLineDashOffset && (t2.lineDashOffset = s2.fillLineDashOffset), t2.strokeStyle = s2.fill || "", t2.lineWidth = n2, this._drawToContext(t2, e3, s2.fixedDecimalPlaceDigits), t2.restore();
  }
  _drawToContext(t2, e3, s2, n2 = "nonzero") {
    t2.beginPath();
    for (const n3 of e3.ops) {
      const e4 = "number" == typeof s2 && s2 >= 0 ? n3.data.map((t3) => +t3.toFixed(s2)) : n3.data;
      switch (n3.op) {
        case "move":
          t2.moveTo(e4[0], e4[1]);
          break;
        case "bcurveTo":
          t2.bezierCurveTo(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]);
          break;
        case "lineTo":
          t2.lineTo(e4[0], e4[1]);
      }
    }
    "fillPath" === e3.type ? t2.fill(n2) : t2.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(t2, e3, s2, n2, a2) {
    const o2 = this.gen.line(t2, e3, s2, n2, a2);
    return this.draw(o2), o2;
  }
  rectangle(t2, e3, s2, n2, a2) {
    const o2 = this.gen.rectangle(t2, e3, s2, n2, a2);
    return this.draw(o2), o2;
  }
  ellipse(t2, e3, s2, n2, a2) {
    const o2 = this.gen.ellipse(t2, e3, s2, n2, a2);
    return this.draw(o2), o2;
  }
  circle(t2, e3, s2, n2) {
    const a2 = this.gen.circle(t2, e3, s2, n2);
    return this.draw(a2), a2;
  }
  linearPath(t2, e3) {
    const s2 = this.gen.linearPath(t2, e3);
    return this.draw(s2), s2;
  }
  polygon(t2, e3) {
    const s2 = this.gen.polygon(t2, e3);
    return this.draw(s2), s2;
  }
  arc(t2, e3, s2, n2, a2, o2, h2 = false, r2) {
    const i2 = this.gen.arc(t2, e3, s2, n2, a2, o2, h2, r2);
    return this.draw(i2), i2;
  }
  curve(t2, e3) {
    const s2 = this.gen.curve(t2, e3);
    return this.draw(s2), s2;
  }
  path(t2, e3) {
    const s2 = this.gen.path(t2, e3);
    return this.draw(s2), s2;
  }
};
var J = "http://www.w3.org/2000/svg";
var K = class {
  constructor(t2, e3) {
    this.svg = t2, this.gen = new N(e3);
  }
  draw(t2) {
    const e3 = t2.sets || [], s2 = t2.options || this.getDefaultOptions(), n2 = this.svg.ownerDocument || window.document, a2 = n2.createElementNS(J, "g"), o2 = t2.options.fixedDecimalPlaceDigits;
    for (const h2 of e3) {
      let e4 = null;
      switch (h2.type) {
        case "path":
          e4 = n2.createElementNS(J, "path"), e4.setAttribute("d", this.opsToPath(h2, o2)), e4.setAttribute("stroke", s2.stroke), e4.setAttribute("stroke-width", s2.strokeWidth + ""), e4.setAttribute("fill", "none"), s2.strokeLineDash && e4.setAttribute("stroke-dasharray", s2.strokeLineDash.join(" ").trim()), s2.strokeLineDashOffset && e4.setAttribute("stroke-dashoffset", `${s2.strokeLineDashOffset}`);
          break;
        case "fillPath":
          e4 = n2.createElementNS(J, "path"), e4.setAttribute("d", this.opsToPath(h2, o2)), e4.setAttribute("stroke", "none"), e4.setAttribute("stroke-width", "0"), e4.setAttribute("fill", s2.fill || ""), "curve" !== t2.shape && "polygon" !== t2.shape || e4.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          e4 = this.fillSketch(n2, h2, s2);
      }
      e4 && a2.appendChild(e4);
    }
    return a2;
  }
  fillSketch(t2, e3, s2) {
    let n2 = s2.fillWeight;
    n2 < 0 && (n2 = s2.strokeWidth / 2);
    const a2 = t2.createElementNS(J, "path");
    return a2.setAttribute("d", this.opsToPath(e3, s2.fixedDecimalPlaceDigits)), a2.setAttribute("stroke", s2.fill || ""), a2.setAttribute("stroke-width", n2 + ""), a2.setAttribute("fill", "none"), s2.fillLineDash && a2.setAttribute("stroke-dasharray", s2.fillLineDash.join(" ").trim()), s2.fillLineDashOffset && a2.setAttribute("stroke-dashoffset", `${s2.fillLineDashOffset}`), a2;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(t2, e3) {
    return this.gen.opsToPath(t2, e3);
  }
  line(t2, e3, s2, n2, a2) {
    const o2 = this.gen.line(t2, e3, s2, n2, a2);
    return this.draw(o2);
  }
  rectangle(t2, e3, s2, n2, a2) {
    const o2 = this.gen.rectangle(t2, e3, s2, n2, a2);
    return this.draw(o2);
  }
  ellipse(t2, e3, s2, n2, a2) {
    const o2 = this.gen.ellipse(t2, e3, s2, n2, a2);
    return this.draw(o2);
  }
  circle(t2, e3, s2, n2) {
    const a2 = this.gen.circle(t2, e3, s2, n2);
    return this.draw(a2);
  }
  linearPath(t2, e3) {
    const s2 = this.gen.linearPath(t2, e3);
    return this.draw(s2);
  }
  polygon(t2, e3) {
    const s2 = this.gen.polygon(t2, e3);
    return this.draw(s2);
  }
  arc(t2, e3, s2, n2, a2, o2, h2 = false, r2) {
    const i2 = this.gen.arc(t2, e3, s2, n2, a2, o2, h2, r2);
    return this.draw(i2);
  }
  curve(t2, e3) {
    const s2 = this.gen.curve(t2, e3);
    return this.draw(s2);
  }
  path(t2, e3) {
    const s2 = this.gen.path(t2, e3);
    return this.draw(s2);
  }
};
var U = { canvas: (t2, e3) => new B(t2, e3), svg: (t2, e3) => new K(t2, e3), generator: (t2) => new N(t2), newSeed: () => N.newSeed() };

export {
  require_eventemitter3,
  isBoolean_default,
  isFunction_default,
  isNil_default,
  isValid_default,
  isObject_default,
  isObjectLike_default,
  isPlainObject_default,
  isUndefined_default,
  isString_default,
  isArray_default,
  isNumber_default,
  isNumeric_default,
  isValidNumber_default,
  isValidUrl_default,
  isBase64_default,
  isEmpty_default,
  get_default,
  has_default,
  cloneDeep,
  baseMerge,
  merge,
  pickWithout,
  isEqual,
  mixin,
  array,
  last,
  maxInArray,
  minInArray,
  arrayEqual,
  uniqArray,
  shuffleArray,
  flattenArray,
  range,
  toNumber,
  LoggerLevel,
  Logger,
  bisect,
  findZeroOfFunction,
  binaryFuzzySearch,
  binaryFuzzySearchInNumberRange,
  median,
  isNumberClose,
  isGreater,
  isLess,
  memoize,
  clamp_default,
  clampRange_default,
  clamper,
  debounce_default,
  throttle_default,
  interpolateNumber,
  interpolateNumberRound,
  interpolateDate,
  interpolateString,
  toValidNumber,
  seedRandom2 as seedRandom,
  epsilon,
  pi,
  halfPi,
  tau,
  pi2,
  abs,
  atan2,
  cos,
  max,
  min,
  sin,
  sqrt,
  acos,
  asin,
  pointAt,
  crossProduct2 as crossProduct,
  getDecimalPlaces,
  precisionAdd,
  precisionSub,
  Point,
  PointService,
  degreeToRadian,
  radianToDegree,
  clampRadian,
  clampAngleByRadian,
  polarToCartesian,
  cartesianToPolar,
  getAngleByPoint,
  normalizeAngle,
  calculateMaxRadius,
  computeQuadrant,
  getIntersectPoint,
  getRectIntersect,
  rectInsideAnotherRect,
  isRectIntersect,
  pointInRect,
  rotatePoint,
  isRotateAABBIntersect,
  getAABBFromPoints,
  polygonContainPoint,
  isPointInLine,
  polygonIntersectPolygon,
  getContextFont,
  TextMeasure,
  calculateAnchorOfBounds,
  aabbSeparation,
  obbSeparation,
  transformBoundsWithMatrix,
  Bounds,
  AABBBounds,
  OBBBounds,
  Matrix2 as Matrix,
  normalTransform,
  LRU,
  hslToRgb2 as hslToRgb,
  rgbToHsl2 as rgbToHsl,
  DEFAULT_COLORS,
  Color,
  hexToRgb,
  color_exports,
  normalizePadding,
  SECOND,
  MINUTE,
  HOUR,
  DAY,
  MONTH,
  getContainerSize,
  getElementAbsolutePosition,
  styleStringToObject,
  lowerCamelCaseToMiddle,
  toCamelCase,
  isHTMLElement,
  isPointInPolygon,
  destination,
  SMALL,
  intersectionArea,
  circleOverlap,
  circleCircleIntersection,
  getCenter,
  TimeUtil,
  numberSpecifierReg,
  NumberUtil,
  zeros,
  zerosM,
  norm2,
  scale2 as scale,
  nelderMead,
  conjugateGradient,
  import_eventemitter3,
  path_default,
  conicEqualArea_default,
  albers_default,
  albersUsa_default,
  azimuthalEqualArea_default,
  azimuthalEquidistant_default,
  mercator_default,
  conicConformal_default,
  equirectangular_default,
  conicEquidistant_default,
  equalEarth_default,
  gnomonic_default,
  identity_default3 as identity_default,
  naturalEarth1_default,
  orthographic_default,
  stereographic_default,
  transverseMercator_default,
  feature_default,
  init_src,
  require_geojson_dissolve,
  require_simplify_geojson,
  simple_statistics_exports,
  dsv_default,
  csvParse,
  tsvParse,
  require_geobuf,
  require_pbf,
  es_default2 as es_default,
  es_default3 as es_default2,
  U,
  require_lib2 as require_lib,
  require_lottie
};
/*! Bundled license information:

lottie-web/build/player/lottie.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-OFTBKGPI.js.map
