import { cloneDeep, EventEmitter, merge, isNil } from "@visactor/vutils";

import { getUUID } from "./utils/uuid";

import { fields } from "./transform/fields";

export const DataViewDiffRank = "_data-view-diff-rank";

export class DataView {
    constructor(dataSet, options) {
        let name;
        this.dataSet = dataSet, this.options = options, this.isDataView = !0, this.target = new EventEmitter, 
        this.parseOption = null, this.transformsArr = [], this.isRunning = !1, this.rawData = {}, 
        this.history = !1, this.parserData = {}, this.latestData = {}, this._fields = null, 
        this.reRunAllTransform = (opt = {
            pushHistory: !0,
            emitMessage: !0
        }) => (this.isRunning = !0, this.resetTransformData(), this.transformsArr.forEach((t => {
            this.executeTransform(t, {
                pushHistory: opt.pushHistory,
                emitMessage: !1
            }), this.isLastTransform(t) && this.diffLastData();
        })), this.isRunning = !1, !1 !== opt.emitMessage && this.target.emit("change", []), 
        this), this.markRunning = () => {
            this.isRunning = !0, this.target.emit("markRunning", []);
        }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), 
        this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, 
        this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
    }
    parse(data, options, emit = !1) {
        var _a;
        this.isRunning = !0, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
        const cloneData = this.cloneParseData(data, options);
        if (null == options ? void 0 : options.type) {
            const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
            this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), 
            this.latestData = parserData;
        } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), 
        this.latestData = cloneData;
        return this.isRunning = !1, emit && this.target.emit("afterParse", []), this;
    }
    transform(options, execute = !0) {
        if (this.isRunning = !0, options && options.type) {
            let pushOption = !0;
            if ("fields" === options.type) {
                this._fields = options.options.fields;
                const index = this.transformsArr.findIndex((_op => _op.type === options.type));
                index >= 0 && (pushOption = !1, this.transformsArr[index].options.fields = this._fields);
            }
            if (pushOption && this.transformsArr.push(options), execute) {
                const lastTag = this.isLastTransform(options);
                this.executeTransform(options), lastTag && this.diffLastData();
            }
        }
        return this.sortTransform(), this.isRunning = !1, this;
    }
    isLastTransform(options) {
        return this.transformsArr[this.transformsArr.length - 1] === options;
    }
    sortTransform() {
        this.transformsArr.length >= 2 && this.transformsArr.sort(((a, b) => {
            var _a, _b;
            return (null !== (_a = a.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
        }));
    }
    executeTransform(options, opt = {
        pushHistory: !0,
        emitMessage: !0
    }) {
        const {pushHistory: pushHistory, emitMessage: emitMessage} = opt, transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
        this.history && !1 !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, 
        !1 !== emitMessage && this.target.emit("change", []);
    }
    resetTransformData() {
        this.latestData = this.parserData, this.history && (this.historyData.length = 0, 
        this.historyData.push(this.rawData, this.parserData));
    }
    enableDiff(keys) {
        this._diffData = !0, this._diffKeys = keys, this._diffMap = new Map, this._diffRank = 0;
    }
    disableDiff() {
        this._diffData = !1, this._diffMap = null, this._diffRank = null;
    }
    resetDiff() {
        this._diffMap = new Map, this._diffRank = 0;
    }
    diffLastData() {
        var _a;
        if (!this._diffData) return;
        if (!this.latestData.forEach) return;
        if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length)) return;
        const next = this._diffRank + 1;
        if (0 === this._diffRank) this.latestData.forEach((d => {
            d[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce(((pre, k) => pre + d[k]), ""), d);
        })), this.latestDataAUD = {
            add: Array.from(this.latestData),
            del: [],
            update: []
        }; else {
            let tempKey;
            this.latestDataAUD = {
                add: [],
                del: [],
                update: []
            }, this.latestData.forEach((d => {
                d[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce(((pre, k) => pre + d[k]), ""), 
                this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d) : this.latestDataAUD.add.push(d), 
                this._diffMap.set(tempKey, d);
            })), this._diffMap.forEach(((v, k) => {
                v[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v), this._diffMap.delete(k));
            }));
        }
        this._diffRank = next;
    }
    cloneParseData(data, options) {
        let clone = !1;
        return data instanceof DataView || !0 !== (null == options ? void 0 : options.clone) || (clone = !0), 
        clone ? cloneDeep(data) : data;
    }
    parseNewData(data, options) {
        this.parse(data, options || this.parseOption), this.reRunAllTransform();
    }
    updateRawData(data, options) {
        const cloneData = this.cloneParseData(data, options);
        this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, 
        this.reRunAllTransform();
    }
    getFields() {
        var _a;
        return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
    }
    setFields(f, foreMerge = !1) {
        this._fields = f && foreMerge ? merge({}, this._fields, f) : f;
        const fieldsOption = this.transformsArr.find((_op => "fields" === _op.type));
        !isNil(this._fields) && isNil(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), 
        this.transform({
            type: "fields",
            options: {
                fields: this._fields
            }
        }, !1)) : fieldsOption && (fieldsOption.options.fields = this._fields);
    }
    destroy() {
        this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, 
        this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, 
        this.target = null;
    }
}

export function isDataView(obj) {
    return obj instanceof DataView;
}
//# sourceMappingURL=data-view.js.map