{"version":3,"sources":["../src/animation.ts"],"names":[],"mappings":";;;AAAA,yDAAwD;AAExD,uCAAuF;AAEvF,MAAa,oBAAqB,SAAQ,6BAAyD;IAIjG,MAAM;QACJ,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,IAAA,yBAAkB,EAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YAC7C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAA,yBAAkB,EAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YAC3C,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,QAAQ,CAAC,GAAY,EAAE,KAAa,EAAE,GAAwB;QAC5D,MAAM,OAAO,GAAkB,EAAE,CAAC;QAClC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YACpC,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,KAAK,IAAI,GAAG,EAAE;gBAChB,OAAO,CAAC,IAAI,CAAC;oBACX,MAAM,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,KAAK;oBAC1D,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK;oBACtC,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK;oBACtC,KAAK,EAAE,GAAG;iBACI,CAAC,CAAC;aACnB;QACH,CAAC,CAAC,CAAC;QACH,MAAM,IAAI,GAAG,IAAA,yBAAkB,EAAC,OAAO,CAAC,CAAC;QACzC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;QAChB,GAAG,CAAC,IAAI,GAAG,IAAA,sBAAe,EAAC,IAAI,CAAC,CAAC;IACnC,CAAC;CACF;AAjCD,oDAiCC","file":"animation.js","sourcesContent":["import { ACustomAnimate } from '@visactor/vrender-core';\nimport type { IVennCircle, IVennOverlapArc, VennCircleName } from './utils/interface';\nimport { getArcsFromCircles, getCirclesFromArcs, getPathFromArcs } from './utils/path';\n\nexport class VennOverlapAnimation extends ACustomAnimate<{ path: string; arcs: IVennOverlapArc[] }> {\n  protected fromCircles: Record<VennCircleName, IVennCircle>;\n  protected toCircles: Record<VennCircleName, IVennCircle>;\n\n  onBind(): void {\n    this.fromCircles = {};\n    getCirclesFromArcs(this.from.arcs).forEach(c => {\n      this.fromCircles[c.setId] = c;\n    });\n    this.toCircles = {};\n    getCirclesFromArcs(this.to.arcs).forEach(c => {\n      this.toCircles[c.setId] = c;\n    });\n  }\n\n  onUpdate(end: boolean, ratio: number, out: Record<string, any>): void {\n    const circles: IVennCircle[] = [];\n    Object.keys(this.fromCircles).forEach(key => {\n      const fromC = this.fromCircles[key];\n      const toC = this.toCircles[key];\n      if (fromC && toC) {\n        circles.push({\n          radius: fromC.radius + (toC.radius - fromC.radius) * ratio,\n          x: fromC.x + (toC.x - fromC.x) * ratio,\n          y: fromC.y + (toC.y - fromC.y) * ratio,\n          setId: key\n        } as IVennCircle);\n      }\n    });\n    const arcs = getArcsFromCircles(circles);\n    out.arcs = arcs;\n    out.path = getPathFromArcs(arcs);\n  }\n}\n"]}