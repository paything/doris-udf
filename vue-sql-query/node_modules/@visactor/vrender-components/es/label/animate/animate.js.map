{"version":3,"sources":["../src/label/animate/animate.ts"],"names":[],"mappings":"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","file":"animate.js","sourcesContent":["import type { IText, ITextGraphicAttribute, EasingType } from '@visactor/vrender-core';\nimport { IncreaseCount } from '@visactor/vrender-core';\nimport type { ILabelAnimation, ILabelUpdateAnimation, ILabelUpdateChannelAnimation, LabelContent } from '../type';\nimport { array, isArray, isEmpty, isValidNumber } from '@visactor/vutils';\n\nconst fadeIn = (textAttribute: ITextGraphicAttribute = {}) => {\n  return {\n    from: {\n      opacity: 0,\n      fillOpacity: 0,\n      strokeOpacity: 0\n    },\n    to: {\n      opacity: textAttribute.opacity ?? 1,\n      fillOpacity: textAttribute.fillOpacity ?? 1,\n      strokeOpacity: textAttribute.strokeOpacity ?? 1\n    }\n  };\n};\n\nconst fadeOut = (textAttribute: ITextGraphicAttribute = {}) => {\n  return {\n    from: {\n      opacity: textAttribute.opacity ?? 1,\n      fillOpacity: textAttribute.fillOpacity ?? 1,\n      strokeOpacity: textAttribute.strokeOpacity ?? 1\n    },\n    to: {\n      opacity: 0,\n      fillOpacity: 0,\n      strokeOpacity: 0\n    }\n  };\n};\n\nconst animationEffects = { fadeIn, fadeOut };\n\nexport function getAnimationAttributes(\n  textAttribute: ITextGraphicAttribute,\n  type: 'fadeIn' | 'fadeOut'\n): {\n  from: any;\n  to: any;\n} {\n  return animationEffects[type]?.(textAttribute) ?? { from: {}, to: {} };\n}\n\nexport function updateAnimation(\n  prev: LabelContent['text'],\n  next: LabelContent['text'],\n  animationConfig: ILabelUpdateAnimation | ILabelUpdateChannelAnimation[]\n) {\n  const changeAttributes = (prev: LabelContent['text'], next: LabelContent['text']) => {\n    const changed = {};\n    for (const key in next.attribute) {\n      if (prev.attribute[key] !== next.attribute[key]) {\n        changed[key] = next.attribute[key];\n      }\n    }\n    return changed;\n  };\n\n  if (!isArray(animationConfig)) {\n    const { duration, easing, increaseEffect = true } = animationConfig;\n\n    prev.animate().to(changeAttributes(prev, next), duration, easing);\n    if (increaseEffect && prev.type === 'text' && next.type === 'text') {\n      playIncreaseCount(prev as IText, next as IText, duration, easing);\n    }\n    return;\n  }\n\n  animationConfig.forEach(cfg => {\n    const { duration, easing, increaseEffect = true, channel } = cfg;\n    const { to } = update(prev, next, channel, cfg.options);\n    if (!isEmpty(to)) {\n      prev.animate().to(changeAttributes(prev, next), duration, easing);\n    }\n\n    if (increaseEffect && prev.type === 'text' && next.type === 'text') {\n      playIncreaseCount(prev as IText, next as IText, duration, easing);\n    }\n  });\n}\n\nexport const update = (\n  prev: LabelContent['text'],\n  next: LabelContent['text'],\n  channel?: string[],\n  options?: ILabelUpdateChannelAnimation['options']\n) => {\n  const from = Object.assign({}, prev.attribute);\n  const to = Object.assign({}, next.attribute);\n  array(options?.excludeChannels).forEach(key => {\n    delete to[key];\n  });\n  Object.keys(to).forEach(key => {\n    if (channel && !channel.includes(key)) {\n      delete to[key];\n    }\n  });\n  return { from, to };\n};\n\nexport function playIncreaseCount(prev: IText, next: IText, duration: number, easing: EasingType) {\n  if (\n    prev.attribute.text !== next.attribute.text &&\n    isValidNumber(Number(prev.attribute.text) * Number(next.attribute.text))\n  ) {\n    prev\n      .animate()\n      .play(\n        new IncreaseCount(\n          { text: prev.attribute.text as string },\n          { text: next.attribute.text as string },\n          duration,\n          easing\n        )\n      );\n  }\n}\n\nexport const DefaultLabelAnimation: ILabelAnimation = {\n  mode: 'same-time',\n  duration: 300,\n  easing: 'linear' as EasingType\n};\n"]}