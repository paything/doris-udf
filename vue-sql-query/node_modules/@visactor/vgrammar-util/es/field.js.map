{"version":3,"sources":["../src/field.ts"],"names":[],"mappings":"AASA,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AACvD,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAGpD,MAAM,WAAW,GAAG,CAAC,QAAsC,EAAE,IAAa,EAAE,MAAmC,EAAE,EAAE,EAAE;IACnH,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,QAAQ,CAAC;KACjB;IAED,MAAM,IAAI,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;IACvC,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IAE3D,OAAO,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,EAAE,IAAI,IAAI,WAAW,CAAC,CAAC;AAC1F,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,KAAK,GAAG,CACnB,QAAyE,EACzE,IAAa,EACb,MAAmC,EAAE,EACrC,EAAE;IACF,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;QACrB,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;QAEnE,OAAO,CAAC,KAAU,EAAE,EAAE;YACpB,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACxC,CAAC,CAAC;KACH;IAED,OAAO,WAAW,CAAC,QAAQ,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AAC1C,CAAC,CAAC","file":"field.js","sourcesContent":["/* Adapted from vega by University of Washington Interactive Data Lab\n * https://vega.github.io/vega/\n * Licensed under the BSD-3-Clause\n\n * url: https://github.com/vega/vega/blob/main/packages/vega-util/src/field.js\n * License: https://github.com/vega/vega/blob/main/LICENSE\n * @license\n */\n\nimport { isArray, isFunction } from '@visactor/vutils';\nimport { accessor } from './accessor';\nimport { getter } from './getter';\nimport { splitAccessPath } from './splitAccessPath';\nimport type { FieldGetterFunction, FieldGetterGeneratorOptions } from './types';\n\nconst fieldSingle = (fieldStr: string | FieldGetterFunction, name?: string, opt: FieldGetterGeneratorOptions = {}) => {\n  if (isFunction(fieldStr)) {\n    return fieldStr;\n  }\n\n  const path = splitAccessPath(fieldStr);\n  const parsedField = path.length === 1 ? path[0] : fieldStr;\n\n  return accessor(((opt && opt.get) || getter)(path), [parsedField], name || parsedField);\n};\n\nexport const field = (\n  fieldStr: string | string[] | FieldGetterFunction | FieldGetterFunction[],\n  name?: string,\n  opt: FieldGetterGeneratorOptions = {}\n) => {\n  if (isArray(fieldStr)) {\n    const funcs = fieldStr.map(entry => fieldSingle(entry, name, opt));\n\n    return (datum: any) => {\n      return funcs.map(func => func(datum));\n    };\n  }\n\n  return fieldSingle(fieldStr, name, opt);\n};\n"]}