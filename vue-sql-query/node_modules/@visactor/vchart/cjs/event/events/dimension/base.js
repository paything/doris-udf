"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DimensionEvent = void 0;

const debug_1 = require("../../../util/debug"), polar_1 = require("./util/polar"), cartesian_1 = require("./util/cartesian"), vscale_1 = require("@visactor/vscale"), util_1 = require("../../../component/axis/cartesian/util");

class DimensionEvent {
    constructor(eventDispatcher, mode) {
        this._eventDispatcher = eventDispatcher, this._mode = mode;
    }
    get chart() {
        var _a, _b;
        return this._chart || (this._chart = null === (_b = (_a = this._eventDispatcher.globalInstance).getChart) || void 0 === _b ? void 0 : _b.call(_a)), 
        this._chart;
    }
    register(eType, handler) {
        var _a, _b;
        (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : debug_1.error)("Method not implemented.");
    }
    unregister() {
        var _a, _b;
        (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : debug_1.error)("Method not implemented.");
    }
    getTargetDimensionInfo(x, y) {
        var _a, _b;
        const cartesianInfo = null !== (_a = (0, cartesian_1.getCartesianDimensionInfo)(this.chart, {
            x: x,
            y: y
        })) && void 0 !== _a ? _a : [], polarInfo = null !== (_b = (0, polar_1.getPolarDimensionInfo)(this.chart, {
            x: x,
            y: y
        })) && void 0 !== _b ? _b : [], result = [].concat(cartesianInfo, polarInfo);
        return 0 === result.length ? null : result;
    }
    dispatch(v, opt) {
        var _a;
        const axes = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c => "axes" === c.specKey && (!(null == opt ? void 0 : opt.filter) || opt.filter(c)))), discreteAxes = axes.filter((axis => {
            const scale = axis.getScale();
            return (0, vscale_1.isDiscrete)(scale.type);
        })), dimAxes = discreteAxes.length ? discreteAxes : axes.filter((axis => {
            const orient = axis.getOrient();
            return (0, util_1.isXAxis)(orient) || "angle" === orient;
        })), dimensionInfo = [];
        return dimAxes.forEach((a => {
            const info = (0, cartesian_1.getDimensionInfoByValue)(a, v);
            info && dimensionInfo.push(info);
        })), this._callback.call(null, {
            action: "enter",
            dimensionInfo: dimensionInfo
        }), dimensionInfo;
    }
}

exports.DimensionEvent = DimensionEvent;
//# sourceMappingURL=base.js.map
