"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Interaction = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../compile/mark/util");

class Interaction {
    constructor() {
        this._stateMarks = new Map, this._stateElements = new Map, this._vgrammarInteractions = new Map, 
        this._disableTriggerEvent = !1;
    }
    addVgrammarInteraction(state, i) {
        state && (this._vgrammarInteractions.get(state) ? this._vgrammarInteractions.get(state).push(i) : this._vgrammarInteractions.set(state, [ i ]));
    }
    static markStateEnable(mark, state) {
        return !(0, vutils_1.isEmpty)(mark.stateStyle[state]);
    }
    setDisableActiveEffect(disable) {
        this._disableTriggerEvent = disable;
    }
    registerMark(state, mark) {
        var _a;
        this._stateMarks.has(state) || this._stateMarks.set(state, []), null === (_a = this._stateMarks.get(state)) || void 0 === _a || _a.push(mark);
    }
    getStateMark(state) {
        return this._stateMarks.get(state);
    }
    filterEventMark(params, state) {
        var _a;
        return !(!params.mark || !(null === (_a = this._stateMarks.get(state)) || void 0 === _a ? void 0 : _a.includes(params.mark)));
    }
    getEventElement(stateValue) {
        var _a;
        return null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
    }
    getEventElementData(stateValue) {
        return this.getEventElement(stateValue).map((e => e.getDatum()));
    }
    exchangeEventElement(stateValue, element) {
        var _a;
        if (this._disableTriggerEvent) return;
        const reState = (0, util_1.stateToReverse)(stateValue);
        null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e => {
            e.removeState(stateValue), reState && this.addEventElement(reState, e);
        })), element.getStates().includes(stateValue) || (element.addState(stateValue), 
        reState && element.removeState(reState)), this._stateElements.set(stateValue, [ element ]);
    }
    removeEventElement(stateValue, element) {
        var _a, _b;
        if (this._disableTriggerEvent) return;
        element.removeState(stateValue);
        const list = null !== (_b = null === (_a = this._stateElements.get(stateValue)) || void 0 === _a ? void 0 : _a.filter((e => e !== element))) && void 0 !== _b ? _b : [];
        this._stateElements.set(stateValue, list);
        const reState = (0, util_1.stateToReverse)(stateValue);
        reState && (0 === list.length ? this.clearEventElement(reState, !1) : this.addEventElement(reState, element));
    }
    addEventElement(stateValue, element) {
        var _a;
        if (this._disableTriggerEvent) return;
        element.getStates().includes(stateValue) || element.addState(stateValue);
        const list = null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
        list.push(element), this._stateElements.set(stateValue, list);
    }
    clearEventElement(stateValue, clearReverse) {
        var _a;
        if (!this._disableTriggerEvent && (null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e => {
            e.removeState(stateValue);
        })), this._stateElements.set(stateValue, []), clearReverse)) {
            const reState = (0, util_1.stateToReverse)(stateValue);
            reState && this.clearEventElement(reState, !1);
        }
    }
    clearAllEventElement() {
        if (!this._disableTriggerEvent) for (const [stateValue, elements] of this._stateElements) elements.forEach((e => {
            e.clearStates();
        })), this._stateElements.set(stateValue, []);
    }
    reverseEventElement(stateValue) {
        if (this._disableTriggerEvent) return;
        const state = (0, util_1.stateToReverse)(stateValue);
        if (!state) return;
        const marks = this.getStateMark(state);
        if (!marks) return;
        const activeElements = this.getEventElement(stateValue);
        if (!activeElements.length) return;
        this.getEventElement(state).length || (1 === activeElements.length ? marks.forEach((m => {
            m.getProduct().elements.filter((e => e !== activeElements[0])).forEach((e => {
                this.addEventElement(state, e);
            }));
        })) : marks.forEach((m => {
            m.getProduct().elements.filter((e => !activeElements.includes(e))).forEach((e => {
                this.addEventElement(state, e);
            }));
        })));
    }
    startInteraction(stateValue, element) {
        const interactions = this._vgrammarInteractions.get(stateValue);
        interactions && interactions.forEach((vgInteraction => {
            vgInteraction.start(element);
        }));
    }
    resetInteraction(stateValue, element) {
        const interactions = this._vgrammarInteractions.get(stateValue);
        interactions && interactions.forEach((vgInteraction => {
            vgInteraction.reset(element);
        }));
    }
    resetAllInteraction() {
        for (const [stateValue, interactions] of this._vgrammarInteractions) interactions && interactions.forEach((vgInteraction => {
            vgInteraction.reset(null);
        }));
    }
}

exports.Interaction = Interaction;
//# sourceMappingURL=interaction.js.map
