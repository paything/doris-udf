"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.AnimateManager = void 0;

const state_manager_1 = require("../compile/signal/state-manager"), base_1 = require("../constant/base"), id_1 = require("../util/id"), interface_1 = require("./interface");

class AnimateManager extends state_manager_1.StateManager {
    constructor() {
        super(...arguments), this.id = (0, id_1.createID)(), this.stateKeyToSignalName = key => `${base_1.PREFIX}_animate_${this.id}_${key}`;
    }
    getAnimationStateSignalName() {
        return this.stateKeyToSignalName("animationState");
    }
    updateAnimateState(state, noRender) {
        state === interface_1.AnimationStateEnum.update ? this.updateState({
            animationState: {
                callback: (datum, element) => element.diffState
            }
        }, noRender) : state === interface_1.AnimationStateEnum.appear ? this.updateState({
            animationState: {
                callback: (datum, element) => "exit" === element.diffState ? interface_1.AnimationStateEnum.none : interface_1.AnimationStateEnum.appear
            }
        }, noRender) : this.updateState({
            animationState: {
                callback: (datum, element) => state
            }
        }, noRender);
    }
    _getDefaultStateMap() {
        return {
            animationState: {
                callback: (datum, element) => "exit" === element.diffState ? interface_1.AnimationStateEnum.exit : "update" === element.diffState ? interface_1.AnimationStateEnum.update : interface_1.AnimationStateEnum.appear
            }
        };
    }
}

exports.AnimateManager = AnimateManager;
//# sourceMappingURL=animate-manager.js.map