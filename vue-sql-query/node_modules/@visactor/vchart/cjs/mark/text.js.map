{"version":3,"sources":["../src/mark/text.ts"],"names":[],"mappings":";;;AAAA,+CAA4C;AAE5C,gDAA4C;AAI5C,2DAAuF;AAGvF,MAAa,QAAS,SAAQ,oBAA+B;IAK3D,WAAW;QACT,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,YAAY,IAAY,EAAE,MAAmB;QAC3C,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QARb,SAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;QAEpB,cAAS,GAAoB,MAAM,CAAC;IAO9C,CAAC;IAES,gBAAgB;QACxB,MAAM,YAAY,mCACb,KAAK,CAAC,gBAAgB,EAAE,KAE3B,KAAK,EAAE,CAAC,EACR,SAAS,EAAE,QAAQ,EACnB,SAAS,EAAE,CAAC,EACZ,UAAU,EAAE,EAAE,GACf,CAAC;QACF,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,iBAAiB,CAAC,IAAsC,EAAE,GAAY;QACpE,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QACnC,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;SAChC;IACH,CAAC;IAED,aAAa;QACX,KAAK,CAAC,aAAa,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;SAClE;IACH,CAAC;;AArCH,4BAsCC;AArCiB,aAAI,UAAqB;AAuCpC,MAAM,gBAAgB,GAAG,GAAG,EAAE;IACnC,iBAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC9C,IAAA,mCAAmB,GAAE,CAAC;IACtB,IAAA,uCAAuB,GAAE,CAAC;AAC5B,CAAC,CAAC;AAJW,QAAA,gBAAgB,oBAI3B","file":"text.js","sourcesContent":["import { Factory } from './../core/factory';\nimport type { IComposedTextMarkSpec } from '../typings/visual';\nimport { BaseMark } from './base/base-mark';\nimport type { IMarkOption, IMarkStyle } from './interface';\n// eslint-disable-next-line no-duplicate-imports\nimport { MarkTypeEnum } from './interface';\nimport { registerRichTextGraphic, registerTextGraphic } from '@visactor/vgrammar-core';\nimport type { ITextMark, ITextSpec } from './interface/mark';\n\nexport class TextMark extends BaseMark<IComposedTextMarkSpec> implements ITextMark {\n  static readonly type = MarkTypeEnum.text;\n  readonly type = TextMark.type;\n\n  protected _textType: 'text' | 'rich' = 'text';\n  getTextType() {\n    return this._textType;\n  }\n\n  constructor(name: string, option: IMarkOption) {\n    super(name, option);\n  }\n\n  protected _getDefaultStyle() {\n    const defaultStyle: IMarkStyle<IComposedTextMarkSpec> = {\n      ...super._getDefaultStyle(),\n      // TODO: 删除后会有显示问题，待排查\n      angle: 0,\n      textAlign: 'center',\n      lineWidth: 0,\n      textConfig: []\n    };\n    return defaultStyle;\n  }\n\n  initStyleWithSpec(spec: ITextSpec<IComposedTextMarkSpec>, key?: string) {\n    super.initStyleWithSpec(spec, key);\n    if (spec.textType) {\n      this._textType = spec.textType;\n    }\n  }\n\n  compileEncode() {\n    super.compileEncode();\n    if (this._textType === 'rich') {\n      this._product.encodeState('group', { textType: this._textType });\n    }\n  }\n}\n\nexport const registerTextMark = () => {\n  Factory.registerMark(TextMark.type, TextMark);\n  registerTextGraphic();\n  registerRichTextGraphic();\n};\n"]}