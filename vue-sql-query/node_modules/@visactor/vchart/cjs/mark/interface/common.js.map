{"version":3,"sources":["../src/mark/interface/common.ts"],"names":[],"mappings":"","file":"common.js","sourcesContent":["import type { IGlobalScale } from '../../scale/interface';\nimport type { ICommonSpec, VisualType, ValueType, FunctionType } from '../../typings/visual';\nimport type { IModel } from '../../model/interface';\nimport type { IBaseScale } from '@visactor/vscale';\nimport type { MarkType } from './type';\nimport type {\n  ICompilableMark,\n  ICompilableMarkOption,\n  IModelMarkAttributeContext,\n  StateValueType\n} from '../../compile/mark/interface';\nimport type { StringOrNumber } from '../../typings';\nimport type { IMarkConfig } from '@visactor/vgrammar-core';\nimport type { ICustomPath2D } from '@visactor/vrender-core';\n\nexport interface VisualScaleType {\n  scale: IBaseScale;\n  field: StringOrNumber;\n  changeDomain?: 'none' | 'replace' | 'expand'; //default 'none'\n}\n\nexport type MarkInputStyle<T> = StyleConvert<T> | VisualType<T>;\n\n/** 用户将属性类型转化为 mark-style 中某个属性的 style */\nexport type StyleConvert<T> = ValueType<T> | FunctionType<T> | VisualScaleType;\n\n/** mark-style 中某个属性的样式信息，包含层级等信息 */\nexport interface IAttrConfig<A, R extends ICommonSpec> {\n  level: number;\n  style: StyleConvert<A>;\n  referer?: IMarkRaw<R>;\n  postProcess?: (result: A, ...args: Parameters<FunctionType<A>>) => A;\n}\n/** mark-style 中某状态下的一组样式信息 */\nexport type IAttrs<T extends ICommonSpec> = {\n  [K in keyof T]: IAttrConfig<T[K], T>;\n};\n\nexport type IMarkProgressiveConfig = {\n  /** 是否开启大数据渲染模式，开启后会降低渲染的精度 */\n  large?: boolean;\n  /** 开启大数据渲染优化的阀值，对应的是data的长度;推荐 largeThreshold < progressiveThreshold  */\n  largeThreshold?: number;\n  /** 分片长度 */\n  progressiveStep?: number;\n  /** 开启分片渲染的阀值，对应的是单系列data的长度 */\n  progressiveThreshold?: number;\n};\n\n/** mark-state-style */\nexport type IMarkStateStyle<T extends ICommonSpec> = Record<StateValueType, Partial<IAttrs<T>>>;\n\n/** mark-style 一组style */\nexport type IMarkStyle<T extends ICommonSpec> = {\n  [key in keyof T]: MarkInputStyle<T[key]>;\n};\n/**********   mark  ***************/\nexport interface IMarkRaw<T extends ICommonSpec> extends ICompilableMark {\n  readonly stateStyle: IMarkStateStyle<T>;\n\n  getAttribute: <U extends keyof T>(key: U, datum: any, state?: StateValueType, opt?: any) => unknown;\n  setAttribute: <U extends keyof T>(attr: U, style: StyleConvert<T[U]>, state?: StateValueType, level?: number) => void;\n\n  // 需要支持优先级并且可以使用优先级覆盖\n  /** @deprecated VChart 层尽量使用 IModel.setMarkStyle() */\n  setStyle: (style: Partial<IMarkStyle<T>>, state?: StateValueType, level?: number) => void;\n\n  setReferer: (mark: IMarkRaw<T>, styleKey?: string, state?: StateValueType, stateStyle?: IMarkStateStyle<T>) => void;\n\n  /** @deprecated VChart 层尽量使用 IModel.initMarkStyleWithSpec() */\n  initStyleWithSpec: (spec: any, key?: string) => void;\n\n  created: () => void;\n\n  setPostProcess: <U extends keyof T, A>(\n    key: U,\n    postProcessFunc: IAttrConfig<A, T>['postProcess'],\n    state?: StateValueType\n  ) => void;\n}\n\nexport type IMark = IMarkRaw<ICommonSpec>;\n\nexport interface ICompileMarkConfig extends IMarkConfig {\n  /** morph 配置开关 */\n  morph?: boolean;\n\n  /** morph元素的唯一key */\n  morphElementKey?: string;\n  /**\n   * 是否支持 3d\n   */\n  support3d?: boolean;\n  /* customized shape of mark  */\n  setCustomizedShape?: (datum: any[], attrs: any, path: ICustomPath2D) => ICustomPath2D;\n  /**\n   * 裁剪配置\n   * @since 1.10.0\n   */\n  clip?: boolean;\n  /** skip theme of vgrammar or not */\n  skipTheme?: boolean;\n}\n\nexport interface IMarkOption extends ICompilableMarkOption {\n  model: IModel;\n  map: Map<StringOrNumber, IModel | IMark>;\n\n  globalScale: IGlobalScale;\n  seriesId?: number;\n\n  /** 组件 mark 的具体类型 */\n  componentType?: string;\n  attributeContext?: IModelMarkAttributeContext;\n}\nexport interface IMarkConstructor {\n  type: MarkType;\n  constructorType?: MarkType;\n  new (name: string, options: IMarkOption): IMark;\n}\n\nexport interface IComponentMarkConstructor {\n  type: MarkType;\n  constructorType?: MarkType;\n  new (componentType: string, name: string, options: IMarkOption): IMark;\n}\n\nexport type MarkConstructor = IMarkConstructor | IComponentMarkConstructor;\n\nexport interface IMarkDataInitOption extends IMarkOption {\n  mark: IMark;\n}\n\nexport type ISamplingMethod = 'lttb' | 'min' | 'max' | 'sum' | 'average';\n\nexport interface IDataSamping {\n  /**\n   * 是否使用额外的 activePoint 显示交互点，可以在点隐藏时显示被交互的点\n   * @default false\n   * @since 1.3.0\n   */\n  activePoint?: boolean;\n  /**\n   * 数据采样 - 采样方法\n   * @since 1.6.0\n   */\n  sampling?: ISamplingMethod;\n  /**\n   * 数据采样 - 采样系数\n   * @since 1.6.0\n   * @default 1\n   */\n  samplingFactor?: number;\n}\n\nexport interface IMarkOverlap {\n  /**\n   * 标记点之间的距离，px\n   * @since 1.6.0\n   */\n  pointDis?: number;\n  /**\n   * 标记点之间的距离， pointSize 的倍数\n   * @since 1.6.0\n   * @default 1\n   */\n  pointDisMul?: number;\n  /**\n   * 是否允许标记图形相互覆盖\n   * @since 1.6.0\n   * @default false\n   */\n  markOverlap?: boolean;\n}\n"]}