{"version":3,"sources":["../src/compile/signal/compilable-signal.ts"],"names":[],"mappings":";;;AACA,kDAA8C;AAE9C,0CAA0C;AAG1C,kEAA2D;AAG3D,MAAa,gBAAoB,SAAQ,0BAAW;IASlD,QAAQ;QACN,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAGD,aAAa;QACX,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,YAAY,MAA6B,EAAE,IAAY,EAAE,KAAS,EAAE,UAAkC;QACpG,KAAK,CAAC,MAAM,CAAC,CAAC;QAlBP,gBAAW,GAAG,6BAAW,CAAC,MAAM,CAAC;QAmBxC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;IAChC,CAAC;IAGD,YAAY,CAAC,KAAS,EAAE,UAAkC;QACxD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAES,eAAe;QACvB,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACpC,IAAI,CAAC,IAAI,EAAE;YACT,OAAO;SACR;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;QAClC,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YAC/B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,EAAK,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YACxC,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;SAC9B;QACD,IAAI,IAAA,cAAO,EAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YACxB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAClC;QACD,IAAI,IAAA,cAAO,EAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SACxC;IACH,CAAC;IAED,iBAAiB;QACf,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAES,cAAc,CAAC,EAAU;;QACjC,OAAO,MAAA,IAAI,CAAC,WAAW,EAAE,CAAC,eAAe,EAAE,0CAAE,aAAa,CAAC,EAAE,CAAC,CAAC;IACjE,CAAC;CACF;AA3DD,4CA2DC","file":"compilable-signal.js","sourcesContent":["import type { ISignal, SignalFunctionType } from '@visactor/vgrammar-core';\nimport { GrammarItem } from '../grammar-item';\nimport type { Maybe } from '../../typings';\nimport { isValid } from '../../util/type';\nimport type { GrammarItemInitOption } from '../interface';\n// eslint-disable-next-line no-duplicate-imports\nimport { GrammarType } from '../interface/compilable-item';\nimport type { ICompilableSignal } from './interface';\n\nexport class CompilableSignal<T> extends GrammarItem implements ICompilableSignal<T> {\n  readonly grammarType = GrammarType.signal;\n  protected declare _product: Maybe<ISignal<T>>;\n  declare getProduct: () => Maybe<ISignal<T>>;\n\n  readonly name: string;\n\n  /** signal 的值 */\n  protected _value: Maybe<T>;\n  getValue() {\n    return this._value;\n  }\n  /** signal 的值回调 */\n  protected _updateFunc: Maybe<SignalFunctionType<T>>;\n  getUpdateFunc() {\n    return this._updateFunc;\n  }\n\n  constructor(option: GrammarItemInitOption, name: string, value?: T, updateFunc?: SignalFunctionType<T>) {\n    super(option);\n    this.name = name;\n    this._value = value;\n    this._updateFunc = updateFunc;\n  }\n\n  /** 更新 signal */\n  updateSignal(value?: T, updateFunc?: SignalFunctionType<T>) {\n    this._value = value;\n    this._updateFunc = updateFunc;\n    this.compile();\n  }\n\n  protected _compileProduct() {\n    const view = this.getVGrammarView();\n    if (!view) {\n      return;\n    }\n\n    const product = this.getProduct();\n    if (!product) {\n      const id = this.getProductId();\n      this._product = view.signal<T>().id(id);\n      this._compiledProductId = id;\n    }\n    if (isValid(this._value)) {\n      this._product.value(this._value);\n    }\n    if (isValid(this._updateFunc)) {\n      this._product.update(this._updateFunc);\n    }\n  }\n\n  generateProductId(): string {\n    return this.name;\n  }\n\n  protected _lookupGrammar(id: string) {\n    return this.getCompiler().getVGrammarView()?.getSignalById(id);\n  }\n}\n"]}