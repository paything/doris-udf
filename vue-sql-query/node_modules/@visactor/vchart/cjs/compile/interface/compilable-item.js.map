{"version":3,"sources":["../src/compile/interface/compilable-item.ts"],"names":[],"mappings":";;;AAqGA,IAAY,WAIX;AAJD,WAAY,WAAW;IACrB,4BAAa,CAAA;IACb,gCAAiB,CAAA;IACjB,4BAAa,CAAA;AACf,CAAC,EAJW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAItB","file":"compilable-item.js","sourcesContent":["import type { IGroupMark, IGrammarBase, IView, IRenderer, InteractionSpec } from '@visactor/vgrammar-core';\nimport type { Maybe, IPerformanceHook, StringOrNumber } from '../../typings';\nimport type { IColor, IStage } from '@visactor/vrender-core';\nimport type { IChart } from '../../chart/interface/chart';\nimport type { IVChart } from '../../core/interface';\nimport type { IMorphConfig } from '../../animation/spec';\nimport type { IBoundsLike } from '@visactor/vutils';\nimport type { EventSourceType, EventType } from '../../event/interface';\n\nexport type CompilerListenerParameters = {\n  type: EventType;\n  event: Event;\n  source: EventSourceType;\n  // FIXME: 这里 item 应当为场景树的 Item 类型\n  item: any | null;\n  datum: any | null;\n  markId: number | null;\n  modelId: number | null;\n  markUserId: StringOrNumber | null;\n  modelUserId: StringOrNumber | null;\n};\n\nexport interface IProductMap<T extends IGrammarItem> {\n  /** 编译产物 id 和对应的在 vchart 中的 GrammarItem */\n  [productId: string]: IGrammarItemMap<T>;\n}\n\nexport interface IGrammarItemMap<T extends IGrammarItem> {\n  /** GrammarItem id 和 对应的引用 */\n  [id: number]: T;\n}\n\nexport type ICompilerModel = Record<GrammarType, IProductMap<IGrammarItem>>;\n\nexport interface ICompiler {\n  isInited?: boolean;\n  getVGrammarView: () => IView;\n  getModel: () => ICompilerModel;\n  getRenderer: () => IRenderer;\n  getCanvas: () => HTMLCanvasElement | undefined;\n  getStage: () => IStage | undefined;\n  compile: (ctx: { chart: IChart; vChart: IVChart }, option: any) => void;\n  clear: (ctx: { chart: IChart; vChart: IVChart }, removeGraphicItems?: boolean) => void;\n  renderNextTick: (morphConfig?: IMorphConfig) => void;\n  render: (morphConfig?: IMorphConfig) => void;\n  updateViewBox: (viewBox: IBoundsLike, reRender?: boolean) => void;\n  resize: (width: number, height: number, reRender?: boolean) => void;\n  setBackground: (color: IColor) => void;\n  setSize: (width: number, height: number) => void;\n  setViewBox: (viewBox: IBoundsLike, reRender?: boolean) => void;\n  addEventListener: (\n    source: EventSourceType,\n    type: string,\n    callback: (params: CompilerListenerParameters) => void\n  ) => void;\n  removeEventListener: (\n    source: EventSourceType,\n    type: string,\n    callback: (params: CompilerListenerParameters) => void\n  ) => void;\n  release: () => void;\n  releaseGrammar: (removeGraphicItems: boolean) => void;\n  addGrammarItem: (grammarItem: IGrammarItem) => void;\n  removeGrammarItem: (grammarItem: IGrammarItem, reserveVGrammarModel?: boolean) => void;\n  addInteraction: (interaction: InteractionSpec & { seriesId?: number; regionId?: number }) => void;\n  removeInteraction: (seriesId: number) => void;\n  updateDepend: (items?: IGrammarItem[]) => boolean;\n}\n\nexport interface ICompilable {\n  /** 获取 compile 对象 */\n  getCompiler: () => ICompiler;\n  /** 获取 vgrammar view */\n  getVGrammarView: () => IView;\n\n  /** 编译总入口 */\n  compile: () => void;\n  /** 编译所有 mark */\n  compileMarks?: (group?: string | IGroupMark) => void;\n  /** 编译所有 data */\n  compileData?: () => void;\n  /** 编译所有 signal */\n  compileSignal?: () => void;\n\n  /** 清除compile 内容入口 */\n  clear?: () => void;\n\n  /** 全部编译完成 lift circle */\n  afterCompile?: () => void;\n\n  /** 释放总入口 */\n  release: () => void;\n}\n\nexport interface ICompilableInitOption {\n  /** 编译对象 应当由外部提供 */\n  getCompiler: () => ICompiler;\n  /** 性能测试钩子 */\n  performanceHook?: IPerformanceHook;\n}\n\nexport enum GrammarType {\n  data = 'data',\n  signal = 'signal',\n  mark = 'mark'\n}\n\nexport interface IGrammarItem extends ICompilable {\n  id: number;\n  /** 语法元素类型 */\n  grammarType: GrammarType;\n  /** 获取语法元素 */\n  getProduct: () => Maybe<IGrammarBase>;\n  /** 生成语法元素名称 */\n  generateProductId: () => string;\n  /** 获取语法元素名称 */\n  getProductId: () => string;\n  /** 删除已编译的语法元素 */\n  removeProduct: (reserveVGrammarModel?: boolean) => void;\n  /** 获取该语法元素依赖的语法元素 */\n  getDepend: () => IGrammarItem[];\n  /** 设置该语法元素依赖的语法元素 */\n  setDepend: (...depend: IGrammarItem[]) => void;\n  /** 更新语法元素的依赖，返回是否全部成功更新 */\n  updateDepend: () => boolean;\n}\n\nexport type GrammarItemInitOption = ICompilableInitOption;\n\nexport type GrammarItemCompileOption = Record<string, any>;\n"]}