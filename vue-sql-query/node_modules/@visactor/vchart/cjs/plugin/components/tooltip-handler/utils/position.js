"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isFixedTooltipPositionPattern = exports.isGlobalTooltipPositionPattern = exports.getCartesianCrosshairRect = exports.getPositionType = exports.positionType = exports.getActualTooltipPositionValue = void 0;

const cartesian_1 = require("../../../../component/crosshair/utils/cartesian"), vutils_1 = require("@visactor/vutils"), getActualTooltipPositionValue = (position, event) => {
    let result;
    if ((0, vutils_1.isValid)(position)) if ((0, vutils_1.isNumber)(position)) result = position; else if ((0, 
    vutils_1.isFunction)(position)) {
        const tooltipPosition = position(event);
        (0, vutils_1.isNumber)(tooltipPosition) && (result = tooltipPosition);
    }
    return result;
};

exports.getActualTooltipPositionValue = getActualTooltipPositionValue, exports.positionType = {
    left: [ -2, 0 ],
    right: [ 2, 0 ],
    top: [ 0, -2 ],
    lt: [ -2, -2 ],
    tl: [ -2, -2 ],
    rt: [ 2, -2 ],
    tr: [ 2, -2 ],
    bottom: [ 0, 2 ],
    bl: [ -2, 2 ],
    lb: [ -2, 2 ],
    br: [ 2, 2 ],
    rb: [ 2, 2 ],
    inside: [ 0, 0 ],
    center: [ 0, 0 ],
    centerBottom: [ 0, 1 ],
    centerTop: [ 0, -1 ],
    centerLeft: [ -1, 0 ],
    centerRight: [ 1, 0 ]
};

const getPositionType = (position, dim, defaultCase = 2) => {
    var _a, _b;
    return null !== (_b = null === (_a = exports.positionType[position]) || void 0 === _a ? void 0 : _a["x" === dim ? 0 : 1]) && void 0 !== _b ? _b : defaultCase;
};

exports.getPositionType = getPositionType;

const getCartesianCrosshairRect = (dimensionData, layoutStartPoint) => {
    var _a;
    const currValueX = new Map, currValueY = new Map, {series: series, datum: datum} = dimensionData, isHorizontal = "horizontal" === series.direction, axisId = (isHorizontal ? series.getYAxisHelper() : series.getXAxisHelper()).getAxisId(), axis = series.getChart().getComponentsByKey("axes").find((axis => axis.id === axisId));
    if (!axis) return;
    (isHorizontal ? currValueY : currValueX).set(axis.getSpecIndex(), {
        datum: null === (_a = series.getDatumPositionValues(datum[0], series.getDimensionField())) || void 0 === _a ? void 0 : _a[0],
        axis: axis
    });
    const state = {
        xField: {
            coordKey: "x",
            anotherAxisKey: "y",
            currentValue: currValueX,
            attributes: {
                visible: !!currValueX.size,
                type: "rect"
            }
        },
        yField: {
            coordKey: "y",
            anotherAxisKey: "x",
            currentValue: currValueY,
            attributes: {
                visible: !!currValueY.size,
                type: "rect"
            }
        }
    };
    return (0, cartesian_1.layoutByValue)(state, series, layoutStartPoint), state.xField.cacheInfo ? (0, 
    cartesian_1.layoutCrosshair)(state.xField) : state.yField.cacheInfo ? (0, cartesian_1.layoutCrosshair)(state.yField) : void 0;
};

exports.getCartesianCrosshairRect = getCartesianCrosshairRect;

const isGlobalTooltipPositionPattern = obj => (0, vutils_1.isObject)(obj) && ((0, 
vutils_1.isValid)(obj.left) || (0, vutils_1.isValid)(obj.right) || (0, vutils_1.isValid)(obj.top) || (0, 
vutils_1.isValid)(obj.bottom));

exports.isGlobalTooltipPositionPattern = isGlobalTooltipPositionPattern;

const isFixedTooltipPositionPattern = obj => (0, vutils_1.isObject)(obj) && ((0, 
vutils_1.isValid)(obj.x) || (0, vutils_1.isValid)(obj.y));

exports.isFixedTooltipPositionPattern = isFixedTooltipPositionPattern;
//# sourceMappingURL=position.js.map
