{"version":3,"sources":["../src/mark/interface/mark.ts"],"names":[],"mappings":"","file":"mark.js","sourcesContent":["import type { IMarkSpec } from '../../typings';\nimport type {\n  IArc3dMarkSpec,\n  IArcMarkSpec,\n  IAreaMarkSpec,\n  IBoxPlotMarkSpec,\n  ICellMarkSpec,\n  ICommonSpec,\n  IComposedTextMarkSpec,\n  IGroupMarkSpec,\n  IImageMarkSpec,\n  ILineMarkSpec,\n  ILinkPathMarkSpec,\n  IPathMarkSpec,\n  IPolygonMarkSpec,\n  IPyramid3dMarkSpec,\n  IRect3dMarkSpec,\n  IRectMarkSpec,\n  IRippleMarkSpec,\n  IRuleMarkSpec,\n  ISymbolMarkSpec\n} from '../../typings/visual';\nimport type { IMark, IMarkRaw } from './common';\nimport type { MarkType } from './type';\n\nexport type IComponentMark = IMarkRaw<ICommonSpec>;\n\nexport interface ILabelMark extends ITextMark {\n  skipEncode: boolean;\n\n  getRule: () => string;\n  setRule: (rule: string) => void;\n\n  getTarget: () => IMark;\n  setTarget: (target: IMark) => void;\n\n  getComponent: () => IComponentMark;\n  setComponent: (component: IComponentMark) => void;\n}\n\nexport type ITextMark = IMarkRaw<IComposedTextMarkSpec> & { getTextType: () => 'text' | 'rich' };\n\nexport type ITextSpec<T> = IMarkSpec<T> & { textType?: 'rich' | 'text' };\n\nexport type IArc3dMark = IMarkRaw<IArc3dMarkSpec>;\n\nexport type IPolygonMark = IMarkRaw<IPolygonMarkSpec>;\n\nexport type IPyramid3dMark = IMarkRaw<IPyramid3dMarkSpec>;\n\nexport type IArcMark = IMarkRaw<IArcMarkSpec>;\n\nexport type IAreaMark = IMarkRaw<IAreaMarkSpec>;\n\nexport type IBoxPlotMark = IMarkRaw<IBoxPlotMarkSpec>;\n\nexport type ICellMark = IMarkRaw<ICellMarkSpec>;\n\nexport type IImageMark = IMarkRaw<IImageMarkSpec>;\n\nexport type ILineMark = IMarkRaw<ILineMarkSpec>;\n\nexport type ILinkPathMark = IMarkRaw<ILinkPathMarkSpec>;\n\nexport type IPathMark = IMarkRaw<IPathMarkSpec>;\n\nexport type IRect3dMark = IMarkRaw<IRect3dMarkSpec>;\n\nexport type IRectMark = IMarkRaw<IRectMarkSpec>;\n\nexport type IRippleMark = IMarkRaw<IRippleMarkSpec>;\n\nexport type IRuleMark = IMarkRaw<IRuleMarkSpec>;\n\nexport type ISymbolMark = IMarkRaw<ISymbolMarkSpec>;\n\nexport interface IGroupMark extends IMarkRaw<IGroupMarkSpec> {\n  // groupMark的zIndex只能配在外层，encode里不生效，且无法写成signal\n  // {type:'group', zIndex: 100} ✅\n  // {type:'group', encode:{enter:{zIndex:{value:100}}}} ❌\n  // {type:'group', zIndex: {signal: }} ❌\n\n  addMark: (m: IMark) => boolean;\n  removeMark: (m: IMark) => boolean;\n  // TODO: 这里可能会出现mark嵌套的问题\n  getMarks: () => IMark[];\n  getMarkInType: (type: MarkType) => IMark[];\n  getMarkInId: (id: number) => IMark | undefined;\n  getMarkInName: (name: string) => IMark[] | undefined;\n}\n"]}