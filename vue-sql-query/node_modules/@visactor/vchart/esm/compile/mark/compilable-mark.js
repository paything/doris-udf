var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { GrammarItem } from "../grammar-item";

import { isNil, isValid } from "@visactor/vutils";

import { VGRAMMAR_HOOK_EVENT } from "../../constant/event";

import { PREFIX } from "../../constant/base";

import { LayoutZIndex } from "../../constant/layout";

import { isStateAttrChangeable } from "./util";

import { MarkStateManager } from "./mark-state-manager";

import { STATE_VALUE_ENUM } from "./interface";

import { MarkData } from "./mark-data";

import { GrammarType } from "../interface/compilable-item";

import { Event } from "../../event/event";

import { AnimationStateEnum } from "../../animation/interface";

export class CompilableMark extends GrammarItem {
    getMarkConfig() {
        return this._markConfig;
    }
    setMarkConfig(config) {
        Object.keys(config).forEach((key => {
            this._markConfig[key] = config[key];
        }));
    }
    getVisible() {
        return this._visible;
    }
    setVisible(visible) {
        this._visible = visible;
    }
    getUserId() {
        return this._userId;
    }
    setUserId(userId) {
        isValid(userId) && (this._userId = userId);
    }
    getDataView() {
        var _a;
        return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
    }
    setDataView(d, productId) {
        isNil(this._data) && this.initMarkData(Object.assign(Object.assign({}, this._option), {
            mark: this
        })), isValid(productId) && this._data.setCompiledProductId(productId), this._data.setDataView(d);
    }
    getData() {
        return this._data;
    }
    setData(d) {
        this._data = d;
    }
    hasState(state) {
        return state in this.state.getStateMap();
    }
    getState(state) {
        return this.state.getStateMap()[state];
    }
    getAnimationConfig() {
        return this._animationConfig;
    }
    setAnimationConfig(config) {
        this._animationConfig = config;
    }
    setSkipBeforeLayouted(skip) {
        this._skipBeforeLayouted = skip;
    }
    getSkipBeforeLayouted() {
        return this._skipBeforeLayouted;
    }
    getGroupKey() {
        return this._groupKey;
    }
    setGroupKey(groupKey) {
        this._groupKey = groupKey;
    }
    setStateSortCallback(stateSort) {
        this._stateSort = stateSort;
    }
    constructor(option, name, model) {
        super(option), this.grammarType = GrammarType.mark, this.type = void 0, this.name = "mark", 
        this._markConfig = {
            zIndex: LayoutZIndex.Mark,
            morph: !1
        }, this._visible = !0, this.stateStyle = {}, this._unCompileChannel = {}, this._skipBeforeLayouted = !1, 
        this.name = name, this.model = model, this.key = option.key, this.state = new MarkStateManager(Object.assign(Object.assign({}, option), {
            stateKeyToSignalName: this.stateKeyToSignalName.bind(this)
        }), this), this._event = new Event(model.getOption().eventDispatcher, model.getOption().mode);
    }
    setTransform(transform) {
        this._transform = transform;
    }
    initMarkData(option) {
        this._data = new MarkData(option);
    }
    stateKeyToSignalName(key) {
        return `${PREFIX}_${this.type}_${this.id}_${key}`;
    }
    getAttribute(key, datum, state, opt) {}
    _compileProduct(option) {
        const product = this.getProduct();
        if (!this.getVisible()) return void (isValid(product) && this.removeProduct());
        if (isValid(product)) return;
        this.getCompiler().isInited && (this._initProduct(null == option ? void 0 : option.group), 
        isNil(this._product) || (this.compileSignal(), this.compileData(), this.compileState(), 
        this.compileEncode(), this.compileAnimation(), this.compileContext(null == option ? void 0 : option.context), 
        this.compileTransform()));
    }
    _initProduct(group) {
        const view = this.getVGrammarView(), id = this.getProductId();
        this._product = view.mark(this.type, null != group ? group : view.rootMark).id(id), 
        this.name && this._product && this._product.name(this.name), this._compiledProductId = id;
    }
    generateProductId() {
        return this._userId ? `${this._userId}` : `${this.name}_${this.id}`;
    }
    compileData() {
        if (isNil(this._data)) return;
        this._data.compile();
        const dataProduct = this._data.getProduct();
        isValid(this._product) && isValid(dataProduct) && this._product.join(dataProduct, this.key, void 0, this.getGroupKey());
    }
    updateStaticEncode() {
        if (!this._product) return;
        const {enterStyles: enterStyles, updateStyles: updateStyles} = this._separateStyle();
        this._product.encodeState("group", enterStyles, !0), this._product.encode(updateStyles, !0);
    }
    _separateStyle() {
        const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, normalStyle = _a[_b], enterStyles = (__rest(_a, [ "symbol" == typeof _b ? _b : _b + "" ]), 
        this._option.noSeparateStyle ? null : {}), updateStyles = {};
        return Object.keys(normalStyle).forEach((key => {
            this._unCompileChannel[key] || (this._option.noSeparateStyle || isStateAttrChangeable(key, normalStyle, this.getGroupKey()) ? updateStyles[key] = {
                callback: this.compileCommonAttributeCallback(key, "normal"),
                dependency: [ this.stateKeyToSignalName("markUpdateRank") ]
            } : enterStyles[key] = this.compileCommonAttributeCallback(key, "normal"));
        })), {
            enterStyles: enterStyles,
            updateStyles: updateStyles
        };
    }
    compileEncode() {
        const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, temp = (_a[_b], 
        __rest(_a, [ "symbol" == typeof _b ? _b : _b + "" ])), {enterStyles: enterStyles, updateStyles: updateStyles} = this._separateStyle();
        this._product.encode(updateStyles, !0), this._product.encodeState("group", enterStyles, !0), 
        Object.keys(temp).forEach((state => {
            const styles = {};
            Object.keys(temp[state]).forEach((key => {
                this._unCompileChannel[key] || (styles[key] = {
                    callback: this.compileCommonAttributeCallback(key, state),
                    dependency: [ this.stateKeyToSignalName("markUpdateRank") ]
                });
            })), this._product.encodeState(state, styles, !0);
        })), this._skipBeforeLayouted && this._product.layout({
            skipBeforeLayouted: this._skipBeforeLayouted
        });
    }
    compileState() {
        this.state.compileState(this._product, this._stateSort);
    }
    compileAnimation() {
        var _a, _b, _c, _d;
        if (this._animationConfig) {
            let stateSignal;
            if ("component" === this.type) stateSignal = null === (_a = this.model.animate) || void 0 === _a ? void 0 : _a.getAnimationStateSignalName(); else {
                const region = null === (_c = (_b = this.model).getRegion) || void 0 === _c ? void 0 : _c.call(_b);
                stateSignal = null === (_d = null == region ? void 0 : region.animate) || void 0 === _d ? void 0 : _d.getAnimationStateSignalName();
            }
            this._product.animation(this._animationConfig), this._product.animationState({
                callback: (datum, element, parameters) => {
                    var _a;
                    return null === (_a = parameters[stateSignal]) || void 0 === _a ? void 0 : _a.callback(datum, element);
                },
                dependency: stateSignal
            }), this._animationConfig.normal && (this._animationConfig.appear ? this._event.on(VGRAMMAR_HOOK_EVENT.ANIMATION_END, (({event: event}) => {
                event.mark === this.getProduct() && event.animationState === AnimationStateEnum.appear && this.runAnimationByState(AnimationStateEnum.normal);
            })) : this._event.on(VGRAMMAR_HOOK_EVENT.AFTER_DO_RENDER, (() => {
                this.runAnimationByState(AnimationStateEnum.normal);
            })));
        }
    }
    compileContext(extraContext) {
        const config = Object.assign(Object.assign({}, this._markConfig), {
            context: Object.assign({
                markId: this.id,
                modelId: this.model.id,
                markUserId: this._userId,
                modelUserId: this.model.userId
            }, extraContext)
        });
        this._product.configure(config);
    }
    compileSignal() {
        this.state.compile();
    }
    _computeAttribute(key, state) {
        return (datum, opt) => {};
    }
    compileCommonAttributeCallback(key, state) {
        const attributeFunctor = this._computeAttribute(key, state), opt = {
            mark: null,
            parent: null,
            element: null
        };
        return (datum, element) => (opt.mark = element.mark, opt.parent = element.mark.group, 
        opt.element = element, attributeFunctor(datum, opt));
    }
    compileTransform() {
        var _a;
        (null === (_a = this._transform) || void 0 === _a ? void 0 : _a.length) && this.getProduct().transform(this._transform);
    }
    _lookupGrammar(id) {
        var _a;
        return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getMarkById(id);
    }
    updateState(newState, noRender) {
        return this.state.updateState(newState, noRender);
    }
    updateLayoutState(noRender, recursion) {
        return recursion && this.getMarks().length > 0 && this.getMarks().forEach((m => m.state.updateLayoutState(!0))), 
        this.state.updateLayoutState(noRender);
    }
    updateMarkState(key) {
        if (!this._product) return;
        const stateInfo = this.state.getStateInfo(key);
        this._product.elements.forEach((e => {
            "in" === this.state.checkOneState(e, e.getDatum(), stateInfo) ? e.addState(key) : e.removeState(key);
        }));
    }
    getMarks() {
        return [];
    }
    runAnimationByState(state) {
        var _a, _b;
        return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.runAnimationByState(state);
    }
    stopAnimationByState(state) {
        var _a, _b;
        return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.stopAnimationByState(state);
    }
    pauseAnimationByState(state) {
        var _a, _b;
        return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.pauseAnimationByState(state);
    }
    resumeAnimationByState(state) {
        var _a, _b;
        return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.resumeAnimationByState(state);
    }
    getProductElements() {
        const product = this.getProduct();
        if (product) return product.elements;
    }
    clear() {
        this._event.off(VGRAMMAR_HOOK_EVENT.AFTER_DO_RENDER);
    }
    release() {
        super.release(), this.state.release();
    }
}
//# sourceMappingURL=compilable-mark.js.map
