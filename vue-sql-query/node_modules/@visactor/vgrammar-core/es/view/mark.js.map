{"version":3,"sources":["../src/view/mark.ts"],"names":[],"mappings":"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","file":"mark.js","sourcesContent":["import type { IGroup } from '@visactor/vrender-core';\nimport type { IBounds } from '@visactor/vutils';\nimport { isArray, isNil, isString, isValid } from '@visactor/vutils';\nimport { CollectionMarkType, DefaultKey, DefaultMarkData, Mark3DType } from '../graph/constants';\nimport {\n  DiffState,\n  GrammarMarkType,\n  LayoutState,\n  HOOK_EVENT,\n  GrammarTypeEnum,\n  BuiltInEncodeNames\n} from '../graph/enums';\nimport type { GroupedData } from '../graph/mark/differ';\nimport { Differ, groupData } from '../graph/mark/differ';\nimport { createGraphicItem, removeGraphicItem } from '../graph/util/graphic';\nimport { GrammarBase } from './grammar-base';\nimport type {\n  GrammarType,\n  ICoordinate,\n  IData,\n  IElement,\n  IGrammarBase,\n  IGroupMark,\n  IMark,\n  IMarkConfig,\n  IView,\n  MarkAnimationSpec,\n  MarkBaseLayoutSpec,\n  MarkFunctionType,\n  MarkKeySpec,\n  MarkLayoutCallback,\n  MarkLayoutSpec,\n  MarkSortSpec,\n  MarkSpec,\n  MarkStateSpec,\n  MarkType,\n  TransformSpec,\n  ProgressiveContext,\n  IProgressiveTransformResult,\n  Nil,\n  IAnimate,\n  MarkStateSortSpec,\n  BaseSingleEncodeSpec\n} from '../types';\nimport { isFieldEncode, isScaleEncode, parseEncodeType } from '../parse/mark';\nimport { getGrammarOutput, parseField, isFunctionType } from '../parse/util';\nimport { parseTransformSpec } from '../parse/transform';\nimport { invokeEncoder } from '../graph/mark/encode';\nimport { transformsByType } from '../graph/attributes';\nimport getExtendedEvents from '../graph/util/events-extend';\nimport type { IBaseScale } from '@visactor/vscale';\nimport { EVENT_SOURCE_VIEW } from './constants';\nimport { Element } from '../graph/element';\n\nexport class Mark extends GrammarBase implements IMark {\n  readonly grammarType: GrammarType = 'mark';\n\n  protected declare spec: MarkSpec;\n\n  /**\n   * only need to clear elements after join and render\n   * but `handleRenderEnd` will be call after every render\n   */\n  protected needClear?: boolean;\n\n  coord: ICoordinate;\n\n  disableCoordinateTransform: boolean;\n\n  // mark properties\n  markType: MarkType;\n\n  group: IGroupMark | undefined;\n  /** 非group mark，对应的容器节点 */\n  graphicItem?: IGroup;\n  graphicIndex: number;\n  /** mark下的element，对应的父节点 */\n  graphicParent?: IGroup;\n\n  elements: IElement[] = [];\n  elementMap: Map<string, IElement> = new Map();\n\n  isUpdated: boolean = true;\n\n  protected _groupEncodeResult: Record<string, any>;\n  private _groupedData: GroupedData<any>;\n\n  /** whether mark enter encode is updated  */\n  protected _isReentered: boolean = false;\n\n  private _context: any;\n\n  private renderContext?: {\n    large: boolean;\n    parameters?: any;\n    progressive?: ProgressiveContext;\n    beforeTransformProgressive?: IProgressiveTransformResult;\n  };\n  animate: IAnimate;\n\n  protected differ = new Differ([]);\n\n  private _delegateEvent: (event: any, type: string) => void;\n\n  private _finalParameters: any;\n\n  constructor(view: IView, markType: MarkType, group?: IGroupMark) {\n    super(view);\n    this.markType = markType;\n    this.spec.type = markType;\n    this.spec.encode = { update: {} };\n    this.spec.group = group;\n    if (group) {\n      this.group = group;\n      this.attach(group);\n      group.appendChild(this);\n    }\n  }\n\n  parse(spec: MarkSpec) {\n    super.parse(spec);\n\n    // TODO: add group api\n    if (this.spec.group) {\n      const groupMark = isString(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;\n      this.detach(groupMark);\n    }\n    const groupMark = isString(spec.group) ? this.view.getMarkById(spec.group) : spec.group;\n    this.attach(groupMark);\n\n    this.join(spec.from?.data, spec.key, spec.sort, spec.groupBy, spec.groupSort);\n    this.coordinate(spec.coordinate);\n    this.state(spec.state, this.spec.stateSort);\n\n    // remove old encode\n    Object.keys(this.spec.encode ?? {}).forEach(state => {\n      this.encodeState(state, {}, true);\n    });\n\n    // add new encode\n    Object.keys(spec.encode ?? {}).forEach(state => {\n      this.encodeState(state, (spec.encode as any)[state]);\n    });\n    this.animation(spec.animation);\n    this.animationState(spec.animationState);\n    this.morph(spec.morph, spec.morphKey, spec.morphElementKey);\n    this.layout(spec.layout);\n    this.configure(spec);\n    this.transform(spec.transform);\n\n    this.parseAddition(spec);\n\n    this.spec = spec;\n    this.markType = spec.type as MarkType;\n\n    this.commit();\n    return this;\n  }\n\n  parameters() {\n    // apply last parameters after prepareRelease\n    return this._finalParameters ?? super.parameters();\n  }\n\n  protected parseAddition(spec: MarkSpec) {\n    return this;\n  }\n\n  reuse(grammar: IGrammarBase) {\n    if (grammar.grammarType !== this.grammarType) {\n      return this;\n    }\n    const mark = grammar as Mark;\n    this.markType = mark.markType;\n    this.coord = mark.coord;\n\n    this.elementMap = mark.elementMap;\n    this.elements = mark.elements;\n    this.elementMap.forEach(element => (element.mark = this));\n\n    this.differ = mark.differ;\n\n    (this as any).reuseAnimate?.(mark);\n\n    this._context = mark._context;\n    // set group in later evaluate progress\n    this.graphicItem = mark.graphicItem;\n    this.graphicIndex = mark.graphicIndex;\n    this.graphicParent = mark.graphicParent;\n\n    this.needClear = mark.needClear;\n    this.isUpdated = mark.isUpdated;\n\n    return this;\n  }\n\n  needLayout() {\n    // 后续可以加上Visible 判断等\n    return !isNil(this.spec.layout);\n  }\n\n  handleLayoutEnd() {\n    // if ((this.spec?.layout as MarkBaseLayoutSpec)?.skipBeforeLayouted) {\n    //   this.run();\n    // }\n  }\n\n  handleRenderEnd() {\n    /**\n     * only need to clear elements after join and render\n     * but `handleRenderEnd` will be call after every render\n     */\n    if (!this.needClear) {\n      return;\n    }\n    // clear exit elements\n    this.cleanExitElements();\n    // clear element channels\n    this.elementMap.forEach(element => {\n      if (element.diffState === DiffState.exit) {\n        element.clearGraphicAttributes();\n      } else {\n        element.clearChangedGraphicAttributes();\n      }\n    });\n    this.differ.updateToCurrent();\n    this.needClear = false;\n  }\n\n  evaluateMainTasks(data: any[], parameters: any) {\n    if (this.needSkipBeforeLayout() && this.view.getLayoutState() === LayoutState.before) {\n      return this;\n    }\n\n    const stage = this.view.renderer?.stage();\n\n    this.init(stage, parameters);\n    const transformData = this.evaluateTransform(this._getTransformsBeforeJoin(), data ?? DefaultMarkData, parameters);\n    const progressiveTransform = transformData?.progressive;\n\n    if (!progressiveTransform) {\n      this.evaluateGroup(transformData);\n      this.renderContext = this.parseRenderContext(transformData, parameters);\n    } else {\n      this.renderContext = { large: false };\n    }\n\n    if (this.renderContext?.progressive) {\n      this.differ.reset();\n      this.elementMap.clear();\n      this.evaluateProgressive();\n    } else {\n      let inputData: any[] = null;\n      if (progressiveTransform) {\n        this.renderContext.parameters = parameters;\n        this.renderContext.beforeTransformProgressive = transformData.progressive;\n        inputData = transformData.progressive.output();\n\n        if (transformData.progressive.canAnimate && transformData.progressive.unfinished()) {\n          this.update(this.spec);\n          return this;\n        }\n      } else {\n        inputData = transformData;\n      }\n      this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);\n      // FIXME: better default upstream\n      this.evaluateJoin(inputData);\n      this.emit(HOOK_EVENT.AFTER_MARK_JOIN);\n\n      this.emit(HOOK_EVENT.BEFORE_MARK_STATE);\n      this.evaluateState(this.elements, this.spec.state, parameters);\n      this.emit(HOOK_EVENT.AFTER_MARK_STATE);\n\n      this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE);\n      this.evaluateEncode(this.elements, this._getEncoders(), parameters);\n      this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);\n    }\n\n    this.update(this.spec);\n\n    return this;\n  }\n\n  protected evaluateGroup(data: any[]) {\n    if (this.markType === GrammarMarkType.group) {\n      return;\n    }\n    const currentData = data ?? DefaultMarkData;\n    const res = groupData(currentData, this.spec.groupBy, this.spec.groupSort);\n\n    this._groupEncodeResult = null;\n    this._groupedData = res;\n  }\n\n  protected _getTransformsAfterEncodeItems() {\n    return this.transforms && this.transforms.filter(entry => entry.markPhase === 'afterEncodeItems');\n  }\n\n  private _getTransformsAfterEncode() {\n    return (\n      this.transforms && this.transforms.filter(entry => isNil(entry.markPhase) || entry.markPhase === 'afterEncode')\n    );\n  }\n\n  private _getTransformsBeforeJoin() {\n    return this.transforms ? this.transforms.filter(entry => entry.markPhase === 'beforeJoin') : [];\n  }\n\n  evaluate(data: any[], parameters: any) {\n    this.evaluateMainTasks(data, parameters);\n    if (!this.renderContext?.progressive) {\n      this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, parameters);\n    }\n\n    return this;\n  }\n\n  output() {\n    return this;\n  }\n\n  join(\n    data: IData | string | Nil,\n    key?: MarkKeySpec,\n    sort?: MarkSortSpec,\n    groupBy?: MarkKeySpec,\n    groupSort?: MarkSortSpec\n  ) {\n    // set data source\n    if (this.grammarSource) {\n      this.detach(this.grammarSource);\n      this.grammarSource = null;\n    }\n    this.spec.from = null;\n    if (!isNil(data)) {\n      if (isString(data)) {\n        this.grammarSource = this.view.getDataById(data);\n      } else {\n        this.grammarSource = data;\n      }\n      this.spec.from = { data };\n      this.attach(this.grammarSource);\n    }\n\n    // set key & sort\n    this.spec.key = key;\n    this.spec.sort = sort;\n    this.spec.groupBy = groupBy;\n    this.spec.groupSort = groupSort;\n\n    this.commit();\n    return this;\n  }\n\n  coordinate(coordinate: ICoordinate | string | Nil) {\n    if (isString(coordinate)) {\n      this.coord = this.view.getCoordinateById(coordinate);\n    } else {\n      this.coord = coordinate;\n    }\n    this.attach(this.coord);\n    this.commit();\n    return this;\n  }\n\n  state(state: MarkFunctionType<string | string[]> | Nil, stateSort?: MarkStateSortSpec) {\n    this.spec.stateSort = stateSort;\n\n    return this.setFunctionSpec(state, 'state');\n  }\n\n  encode(channel: string | BaseSingleEncodeSpec, value?: MarkFunctionType<any> | boolean, clear?: boolean): this {\n    return this.encodeState(DiffState.update, channel, value, clear);\n  }\n\n  encodeState(\n    state: string,\n    channel: string | BaseSingleEncodeSpec,\n    value?: MarkFunctionType<any> | boolean,\n    clear?: boolean\n  ): this {\n    if (state === DiffState.enter) {\n      this._isReentered = true;\n    }\n\n    if ((this.spec.encode as any)[state]) {\n      const lastEncoder = (this.spec.encode as any)[state];\n      // detach last dependencies\n      if (isFunctionType(lastEncoder)) {\n        this.detach(parseEncodeType(lastEncoder, this.view));\n      } else {\n        const isSingleChannel = isString(channel);\n        const clearAll = (isSingleChannel && clear) || (!isSingleChannel && value);\n\n        if (clearAll) {\n          Object.keys(lastEncoder).forEach(c => {\n            this.detach(parseEncodeType(lastEncoder[c], this.view));\n          });\n\n          (this.spec.encode as any)[state] = {};\n        } else if (isSingleChannel) {\n          this.detach(parseEncodeType(lastEncoder[channel], this.view));\n        } else {\n          Object.keys(channel).forEach(c => {\n            this.detach(parseEncodeType(lastEncoder[c], this.view));\n          });\n        }\n      }\n    }\n\n    if (channel) {\n      if (!(this.spec.encode as any)[state]) {\n        (this.spec.encode as any)[state] = {};\n      }\n\n      // update encode & append new dependencies\n      if (isString(channel)) {\n        (this.spec.encode as any)[state][channel] = value;\n        this.attach(parseEncodeType(value, this.view));\n      } else if (isFunctionType(channel)) {\n        (this.spec.encode as any)[state] = channel;\n        this.attach(parseEncodeType(channel, this.view));\n      } else if (channel) {\n        Object.assign((this.spec.encode as any)[state], channel);\n        Object.values(channel).forEach(channelEncoder => {\n          this.attach(parseEncodeType(channelEncoder, this.view));\n        });\n      }\n    }\n\n    this.commit();\n    return this;\n  }\n\n  protected _getEncoders() {\n    return this.spec.encode ?? {};\n  }\n\n  animation(animationConfig: MarkAnimationSpec | Nil): this {\n    this.spec.animation = animationConfig;\n    return this;\n  }\n\n  animationState(animationState: MarkFunctionType<string> | Nil): this {\n    return this.setFunctionSpec(animationState, 'animationState');\n  }\n\n  layout(layout: MarkLayoutSpec | MarkLayoutCallback | Nil): this {\n    this.spec.layout = layout;\n    this.commit();\n    return this;\n  }\n\n  morph(enableMorph: boolean, morphKey?: string, morphElementKey?: string): this {\n    this.spec.morph = enableMorph;\n    this.spec.morphKey = morphKey;\n    this.spec.morphElementKey = morphElementKey;\n    return this;\n  }\n\n  transform(transforms: TransformSpec[] | Nil): this {\n    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);\n    if (prevTransforms) {\n      this.detach(prevTransforms.refs);\n      this.transforms = [];\n    }\n\n    const nextTransforms = parseTransformSpec(transforms, this.view);\n    if (nextTransforms) {\n      this.attach(nextTransforms.refs);\n      this.transforms = nextTransforms.transforms;\n    }\n\n    this.spec.transform = transforms;\n    this.commit();\n    return this;\n  }\n\n  configure(config: IMarkConfig | Nil): this {\n    const keys = [\n      'clip',\n      'clipPath',\n      'zIndex',\n      'interactive',\n      'context',\n      'setCustomizedShape',\n      'large',\n      'largeThreshold',\n      'progressiveStep',\n      'progressiveThreshold',\n      'support3d',\n      'morph',\n      'morphKey',\n      'morphElementKey',\n      'attributeTransforms',\n      'skipTheme',\n      'enableSegments',\n      'stateSort',\n      'graphicName',\n      'overflow'\n    ];\n    if (config === null) {\n      keys.forEach(key => {\n        if (!isNil((this.spec as any)[key])) {\n          (this.spec as any)[key] = undefined;\n        }\n      });\n      return this;\n    }\n\n    keys.forEach(key => {\n      if (!isNil((config as any)[key])) {\n        (this.spec as any)[key] = (config as any)[key];\n      }\n    });\n\n    return this;\n  }\n\n  context(context: any): this {\n    this.spec.context = context;\n    this._context = context;\n    return this;\n  }\n\n  isCollectionMark(): boolean {\n    return (CollectionMarkType as string[]).includes(this.markType);\n  }\n\n  needAnimate(): boolean {\n    return !this.renderContext?.progressive && !isNil(this.spec.animation);\n  }\n\n  getAllElements(): IElement[] {\n    const elements = this.elements.slice();\n    this.elementMap.forEach(element => {\n      // For most of time, exit elements will not be included in this.elements.\n      // After prepareRelease is invoked, elements will all be marked as exited.\n      if (element.diffState === DiffState.exit && !elements.includes(element)) {\n        elements.push(element);\n      }\n    });\n    if (this.spec.sort) {\n      elements.sort((elementA, elementB) => {\n        return this.spec.sort(elementA.getDatum(), elementB.getDatum());\n      });\n    }\n    return elements;\n  }\n\n  getScales() {\n    const scales = {};\n\n    this.references.forEach((count, ref) => {\n      if (ref.grammarType === GrammarTypeEnum.scale) {\n        (scales as any)[ref.id() as string] = ref.output();\n      }\n    });\n\n    return scales;\n  }\n\n  getScalesByChannel() {\n    const encoders = this.spec.encode;\n\n    if (!encoders) {\n      return {};\n    }\n\n    const res: Record<string, IBaseScale> = {};\n    const params = this.parameters();\n\n    Object.keys(encoders).forEach((state: string) => {\n      const useEncoders = (encoders as any)[state];\n\n      if (useEncoders && !isFunctionType(useEncoders)) {\n        Object.keys(useEncoders).forEach(channel => {\n          if (isScaleEncode(useEncoders[channel])) {\n            res[channel] = getGrammarOutput(useEncoders[channel].scale, params);\n          }\n        });\n      }\n    });\n\n    return res;\n  }\n\n  getFieldsByChannel() {\n    const encoders = this.spec.encode;\n\n    if (!encoders) {\n      return {};\n    }\n\n    const res: Record<string, string> = {};\n    Object.keys(encoders).forEach((state: string) => {\n      const useEncoders = (encoders as any)[state];\n\n      if (!isFunctionType(useEncoders)) {\n        Object.keys(useEncoders).forEach(channel => {\n          if (isFieldEncode(useEncoders[channel])) {\n            res[channel] = useEncoders[channel].field as string;\n          }\n        });\n      }\n    });\n\n    return res;\n  }\n\n  protected init(stage: any, parameters: any) {\n    if (!this._delegateEvent) {\n      this._delegateEvent = (event: any, type: string) => {\n        const extendedEvt = getExtendedEvents(this.view, event, type, EVENT_SOURCE_VIEW);\n        const activeElement = event.element as IElement;\n        if (activeElement?.mark === this) {\n          this.emitGrammarEvent(type, extendedEvt, activeElement);\n        }\n      };\n      this.initEvent();\n    }\n\n    (this as any).initAnimate?.(this.spec);\n\n    if (!this.group) {\n      // root mark will not be reused\n      const group = getGrammarOutput(this.spec.group, parameters) as IGroupMark;\n      this.group = group;\n      if (group) {\n        group.appendChild(this);\n      }\n    }\n\n    const groupGraphicItem = this.group ? this.group.getGroupGraphicItem() : stage.defaultLayer;\n    const markIndex = this.group?.children?.indexOf(this) ?? 0;\n    if (this.markType !== GrammarMarkType.group) {\n      if (!this.graphicItem) {\n        const graphicItem = createGraphicItem(this, GrammarMarkType.group, {\n          pickable: false,\n          zIndex: this.spec.zIndex ?? 0,\n          overflow: this.spec.overflow\n        }) as IGroup;\n        if (this.spec.support3d || (Mark3DType as string[]).includes(this.markType)) {\n          graphicItem.setMode('3d');\n        }\n        graphicItem.name = `${this.id() || this.markType}`;\n        this.graphicItem = graphicItem;\n      }\n      this.graphicParent = this.graphicItem;\n      if (groupGraphicItem && (this.graphicIndex !== markIndex || this.graphicItem.parent !== groupGraphicItem)) {\n        groupGraphicItem.insertIntoKeepIdx(this.graphicItem, markIndex);\n      }\n    } else {\n      this.graphicParent = groupGraphicItem;\n\n      this.graphicParent.setAttributes({\n        overflow: this.spec.overflow\n      });\n    }\n    this.graphicIndex = markIndex;\n  }\n\n  protected update(spec: MarkSpec) {\n    this.emit(HOOK_EVENT.BEFORE_MARK_UPDATE);\n    this._context = this.spec.context;\n    this.isUpdated = true;\n\n    if (!this.renderContext.progressive) {\n      (this as any).updateAnimate?.(spec);\n    }\n\n    if (this.markType !== GrammarMarkType.group) {\n      if (!isNil(spec.zIndex)) {\n        this.graphicItem.setAttribute('zIndex', spec.zIndex);\n      }\n      if (!isNil(spec.clip)) {\n        this.graphicItem.setAttribute('clip', spec.clip);\n      }\n      if (!isNil(spec.clipPath)) {\n        const paths = isArray(spec.clipPath) ? spec.clipPath : spec.clipPath(this.elements);\n\n        if (paths && paths.length) {\n          this.graphicItem.setAttribute('path', paths);\n        } else {\n          this.graphicItem.setAttributes({\n            path: paths,\n            clip: false\n          });\n        }\n      }\n\n      if (!isNil(spec.overflow)) {\n        this.graphicItem.setAttribute('overflow', spec.overflow);\n      }\n\n      // only update interactive\n      this.elementMap.forEach(element => {\n        element.updateGraphicItem();\n      });\n    } else {\n      // update group element graphic item attributes\n      this.elementMap.forEach(element => {\n        element.updateGraphicItem();\n      });\n    }\n    this.emit(HOOK_EVENT.AFTER_MARK_UPDATE);\n  }\n\n  createElement() {\n    return new Element(this);\n  }\n\n  protected evaluateJoin(data: any[]) {\n    this.needClear = true;\n    const keyGetter = parseField(this.spec.key ?? (this.grammarSource as IData)?.getDataIDKey() ?? (() => DefaultKey));\n    const groupKeyGetter = parseField(this.spec.groupBy ?? (() => DefaultKey));\n    const sort = this.spec.sort;\n    const isCollectionMark = this.isCollectionMark();\n\n    const enterElements = new Set<IElement>(this.elements.filter(element => element.diffState === DiffState.enter));\n    const elements: IElement[] = [];\n    this.differ.setCallback((key, data, prevData) => {\n      const elementKey: string = key as string;\n      let element: IElement;\n      if (isNil(data)) {\n        // exit\n        element = this.elementMap.get(elementKey);\n        if (element) {\n          element.diffState = DiffState.exit;\n        }\n      } else if (isNil(prevData)) {\n        // enter\n        element = this.elementMap.has(elementKey) ? this.elementMap.get(elementKey) : this.createElement();\n        if (element.diffState === DiffState.exit) {\n          // force element to stop exit animation if it is reentered\n          element.diffState = DiffState.enter;\n          const animators = this.animate?.getElementAnimators(element, DiffState.exit);\n          animators && animators.forEach(animator => animator.stop('start'));\n        }\n\n        element.diffState = DiffState.enter;\n        const groupKey: string = isCollectionMark ? key : groupKeyGetter(data[0]);\n        element.updateData(groupKey, data, keyGetter);\n        this.elementMap.set(elementKey, element);\n        elements.push(element);\n      } else {\n        // update\n        element = this.elementMap.get(elementKey);\n        if (element) {\n          element.diffState = DiffState.update;\n          const groupKey: string = isCollectionMark ? key : groupKeyGetter(data[0]);\n          element.updateData(groupKey, data, keyGetter);\n          elements.push(element);\n        }\n      }\n      enterElements.delete(element);\n    });\n\n    const currentData = data ?? DefaultMarkData;\n\n    if (!isCollectionMark) {\n      this.differ.setCurrentData(\n        groupData(\n          currentData,\n          (datum: any) => {\n            return `${groupKeyGetter(datum)}-${keyGetter(datum)}`;\n          },\n          undefined\n        )\n      );\n    } else {\n      this.differ.setCurrentData(this._groupedData);\n    }\n    this.differ.doDiff();\n\n    // Enter elements between dataflow start data and end data should be removed directly.\n    enterElements.forEach(element => {\n      this.elementMap.delete(isCollectionMark ? element.groupKey : `${element.groupKey}-${element.key}`);\n      element.remove();\n      element.release();\n    });\n\n    this.elements = elements;\n    if (sort && this.elements.length >= 2) {\n      this.elements.sort((elementA, elementB) => {\n        return sort(elementA.getDatum(), elementB.getDatum());\n      });\n    }\n  }\n\n  protected evaluateState(elements: IElement[], stateSpec: MarkStateSpec, parameters: any): void {\n    if (!stateSpec) {\n      return;\n    }\n\n    elements.forEach(element => {\n      element.state(stateSpec, parameters);\n    });\n  }\n\n  protected evaluateGroupEncode(elements: IElement[], groupEncode: any, parameters: any) {\n    if (!this._groupedData || !groupEncode) {\n      return;\n    }\n\n    const res = {};\n\n    this._groupedData.keys.forEach(key => {\n      const el = elements.find(el => el.groupKey === key);\n\n      if (!el) {\n        return;\n      }\n\n      (res as any)[key] = invokeEncoder(groupEncode, el.items && el.items[0] && el.items[0].datum, el, parameters);\n    });\n\n    this._groupEncodeResult = res;\n\n    return res;\n  }\n\n  protected getChannelsFromConfig(element?: IElement) {\n    const spec = this.spec;\n\n    return !isNil(spec.interactive) ? { pickable: spec.interactive } : null;\n  }\n\n  protected evaluateEncode(elements: IElement[], encoders: any, parameters: any, noGroupEncode?: boolean) {\n    const initAttrs = this.getChannelsFromConfig();\n\n    if (encoders) {\n      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, { encoders, parameters }, this);\n\n      const groupEncodeAttrs = noGroupEncode\n        ? null\n        : this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);\n\n      elements.forEach(element => {\n        if (this.markType === GrammarMarkType.glyph && this._groupEncodeResult) {\n          element.items.forEach(item => {\n            item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, this._groupEncodeResult[element.groupKey]);\n          });\n        } else if ((groupEncodeAttrs as any)?.[element.groupKey] && !this.isCollectionMark()) {\n          element.items.forEach(item => {\n            item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, (groupEncodeAttrs as any)[element.groupKey]);\n          });\n        } else if (initAttrs) {\n          element.items.forEach(item => {\n            item.nextAttrs = Object.assign(item.nextAttrs, initAttrs);\n          });\n        }\n\n        element.encodeItems(element.items, encoders, this._isReentered, parameters);\n\n        if (\n          this.isCollectionMark() &&\n          (groupEncodeAttrs as any)?.[element.groupKey] &&\n          isValid((groupEncodeAttrs as any)[element.groupKey].defined)\n        ) {\n          element.items.forEach(item => {\n            item.nextAttrs.defined = (groupEncodeAttrs as any)[element.groupKey].defined;\n          });\n          delete (groupEncodeAttrs as any)[element.groupKey].defined;\n        }\n      });\n\n      this._isReentered = false;\n\n      this.evaluateTransform(this._getTransformsAfterEncodeItems(), elements, parameters);\n\n      elements.forEach(element => {\n        element.encodeGraphic(this.isCollectionMark() ? (groupEncodeAttrs as any)?.[element.groupKey] : null);\n      });\n      this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, { encoders, parameters }, this);\n    } else {\n      elements.forEach(element => {\n        element.initGraphicItem(initAttrs);\n      });\n    }\n  }\n\n  addGraphicItem(attrs: any, groupKey?: string, newGraphicItem?: any) {\n    const graphicItem: any = newGraphicItem ?? createGraphicItem(this, this.markType, attrs);\n\n    if (!graphicItem) {\n      return;\n    }\n\n    if (this.renderContext?.progressive) {\n      let group: IGroup;\n\n      if (this._groupedData) {\n        const index = this._groupedData.keys.indexOf(groupKey);\n\n        if (index >= 0) {\n          group = this.graphicParent.getChildAt(index) as IGroup;\n        }\n      } else {\n        group = this.graphicParent.at(0) as IGroup;\n      }\n\n      if (this.isCollectionMark()) {\n        graphicItem.incremental = 1;\n        group.appendChild(graphicItem);\n      } else {\n        group.incrementalAppendChild(graphicItem);\n      }\n    } else {\n      (this.graphicParent as any).appendChild(graphicItem);\n    }\n    return graphicItem;\n  }\n\n  parseRenderContext(data: any[], parameters: any) {\n    const enableProgressive =\n      this.markType !== GrammarMarkType.group &&\n      this.spec.progressiveStep > 0 &&\n      this.spec.progressiveThreshold > 0 &&\n      this.spec.progressiveStep < this.spec.progressiveThreshold;\n    const large = this.spec.large && this.spec.largeThreshold > 0 && data.length >= this.spec.largeThreshold;\n\n    if (enableProgressive) {\n      const groupedData = this._groupedData;\n\n      if (\n        groupedData &&\n        groupedData.keys &&\n        groupedData.keys.some(key => groupedData.data.get(key).length > this.spec.progressiveThreshold)\n      ) {\n        return {\n          large,\n          parameters,\n          progressive: {\n            data,\n            step: this.spec.progressiveStep,\n            currentIndex: 0,\n            totalStep: groupedData.keys.reduce((total, key) => {\n              return Math.max(Math.ceil(groupedData.data.get(key).length / this.spec.progressiveStep), total);\n            }, 1),\n            groupedData: groupedData.data as Map<string, any[]>\n          }\n        };\n      }\n\n      return { large };\n    }\n\n    return {\n      large\n    };\n  }\n\n  isProgressive() {\n    return this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive);\n  }\n\n  canAnimateAfterProgressive() {\n    return (\n      this.renderContext &&\n      this.renderContext.beforeTransformProgressive &&\n      this.renderContext.beforeTransformProgressive.canAnimate()\n    );\n  }\n\n  isDoingProgressive() {\n    return (\n      this.renderContext &&\n      ((this.renderContext.progressive &&\n        this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep) ||\n        (this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished()))\n    );\n  }\n\n  clearProgressive() {\n    if (this.renderContext && this.renderContext.progressive) {\n      this.elements = [];\n\n      (this.graphicParent as any).children.forEach((group: IGroup) => {\n        group.incrementalClearChild();\n      });\n      (this.graphicParent as any).removeAllChild();\n    }\n\n    if (this.renderContext && this.renderContext.beforeTransformProgressive) {\n      this.renderContext.beforeTransformProgressive.release();\n    }\n\n    this.renderContext = null;\n  }\n\n  restartProgressive() {\n    if (this.renderContext && this.renderContext.progressive) {\n      this.renderContext.progressive.currentIndex = 0;\n    }\n  }\n\n  evaluateJoinProgressive() {\n    const currentIndex = this.renderContext.progressive.currentIndex;\n    const keyGetter = parseField(this.spec.key ?? (this.grammarSource as IData)?.getDataIDKey() ?? (() => DefaultKey));\n\n    const elements: IElement[] = [];\n\n    if (this.isCollectionMark()) {\n      this._groupedData.keys.forEach((key, index) => {\n        const data = this.renderContext.progressive.groupedData.get(key as string);\n        const groupStep = this.renderContext.progressive.step;\n        const dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);\n\n        if (currentIndex === 0) {\n          const element = this.createElement();\n          element.diffState = DiffState.enter;\n          element.updateData(key as string, dataSlice, keyGetter);\n          elements.push(element);\n        } else {\n          const element = this.elements[index];\n          element.updateData(key as string, dataSlice, keyGetter);\n          elements.push(element);\n        }\n      });\n\n      return elements;\n    }\n\n    const groupElements: Record<string, IElement[]> = {};\n    this._groupedData.keys.forEach(key => {\n      const data = this.renderContext.progressive.groupedData.get(key as string);\n      const groupStep = this.renderContext.progressive.step;\n      const dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);\n      const group: IElement[] = [];\n\n      dataSlice.forEach(entry => {\n        const element = this.createElement();\n        element.diffState = DiffState.enter;\n        element.updateData(key as string, [entry], keyGetter);\n        group.push(element);\n        elements.push(element);\n      });\n\n      groupElements[key as string] = group;\n    });\n\n    return { groupElements, elements };\n  }\n\n  protected evaluateEncodeProgressive(elements: IElement[], encoders: any, parameters: any) {\n    const progressiveIndex = this.renderContext.progressive.currentIndex;\n\n    if (progressiveIndex === 0) {\n      this.evaluateEncode(elements, encoders, parameters);\n\n      if (\n        progressiveIndex === 0 &&\n        this._groupEncodeResult &&\n        !this.isCollectionMark() &&\n        this.markType !== GrammarMarkType.glyph\n      ) {\n        const firstElement = elements[0];\n        const firstChild = firstElement.getGraphicItem();\n        const group = firstChild?.parent;\n\n        if (group) {\n          if (this._groupEncodeResult[firstElement.groupKey]) {\n            (group as IGroup).setTheme({ common: this._groupEncodeResult[firstElement.groupKey] });\n          }\n        }\n      }\n    } else {\n      this.evaluateEncode(elements, encoders, parameters, true);\n    }\n  }\n\n  evaluateProgressive() {\n    if (this.renderContext?.beforeTransformProgressive) {\n      const transform = this.renderContext.beforeTransformProgressive;\n      transform.progressiveRun();\n      const output = transform.output();\n\n      if (transform.canAnimate) {\n        if (transform.unfinished()) {\n          return;\n        }\n        this.evaluateGroup(output);\n      }\n\n      this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);\n      // FIXME: better default upstream\n      this.evaluateJoin(output);\n      this.emit(HOOK_EVENT.AFTER_MARK_JOIN);\n\n      this.emit(HOOK_EVENT.BEFORE_MARK_STATE);\n      this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters);\n      this.emit(HOOK_EVENT.AFTER_MARK_STATE);\n\n      this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE);\n      this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters);\n      this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);\n      return;\n    }\n\n    if (!this.renderContext?.progressive) {\n      return;\n    }\n    const parameters = this.renderContext.parameters;\n\n    this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);\n    const result = this.evaluateJoinProgressive();\n    const elements = Array.isArray(result) ? result : result.elements;\n    this.emit(HOOK_EVENT.AFTER_MARK_JOIN);\n\n    if (this.renderContext.progressive.currentIndex === 0) {\n      (this.graphicParent as any).removeAllChild();\n\n      this._groupedData.keys.forEach(key => {\n        const graphicItem = createGraphicItem(this, GrammarMarkType.group, {\n          pickable: false,\n          zIndex: this.spec.zIndex\n        });\n        graphicItem.incremental = this.renderContext.progressive.step;\n        (this.graphicParent as any).appendChild(graphicItem);\n      });\n\n      this.elements = elements;\n    } else {\n      this.elements = this.elements.concat(elements);\n    }\n\n    this.emit(HOOK_EVENT.BEFORE_MARK_STATE);\n    this.evaluateState(elements, this.spec.state, parameters);\n    this.emit(HOOK_EVENT.AFTER_MARK_STATE);\n\n    this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE);\n    if (Array.isArray(result)) {\n      this.evaluateEncodeProgressive(elements, this._getEncoders(), parameters);\n    } else {\n      const groupElements = result.groupElements;\n      Object.keys(groupElements).forEach(key => {\n        this.evaluateEncodeProgressive(groupElements[key], this._getEncoders(), parameters);\n      });\n    }\n    this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);\n\n    const progressiveTransforms = this._getTransformsAfterEncode()?.filter(entry => entry.canProgressive === true);\n\n    if (progressiveTransforms?.length) {\n      this.evaluateTransform(progressiveTransforms, this.elements, parameters);\n    }\n\n    this.renderContext.progressive.currentIndex += 1;\n  }\n\n  isLargeMode() {\n    return this.renderContext && this.renderContext.large;\n  }\n\n  cleanExitElements() {\n    this.elementMap.forEach((element, key) => {\n      if (element.diffState === DiffState.exit && !element.isReserved) {\n        this.elementMap.delete(key);\n        element.remove();\n        element.release();\n      }\n    });\n  }\n\n  getGroupGraphicItem() {\n    if (this.elements && this.elements[0] && this.elements[0].getGraphicItem) {\n      return this.elements[0].getGraphicItem();\n    }\n  }\n\n  getBounds() {\n    return (this.graphicItem ? this.graphicItem.AABBBounds : this.getGroupGraphicItem()?.AABBBounds) as IBounds;\n  }\n\n  getMorphConfig(): { morph: boolean; morphKey: string; morphElementKey: string } {\n    return {\n      morph: this.spec.morph ?? false,\n      morphKey: this.spec.morphKey,\n      morphElementKey: this.spec.morphElementKey\n    };\n  }\n\n  getAttributeTransforms() {\n    return this.spec.attributeTransforms ?? transformsByType[this.markType];\n  }\n\n  getContext() {\n    return this._context;\n  }\n\n  protected needSkipBeforeLayout(): boolean {\n    if ((this.spec.layout as MarkBaseLayoutSpec)?.skipBeforeLayouted === true) {\n      return true;\n    }\n    let group = this.group;\n    // if parent mark has been skipped, child marks should skip\n    while (group) {\n      if (group.getSpec().layout?.skipBeforeLayouted === true) {\n        return true;\n      }\n      group = group.group;\n    }\n    return false;\n  }\n\n  private initEvent() {\n    if (this._delegateEvent) {\n      const stage = this.view.renderer.stage();\n      stage && stage.on('*', this._delegateEvent);\n    }\n  }\n\n  private releaseEvent() {\n    if (this._delegateEvent) {\n      const stage = this.view.renderer.stage();\n      stage && stage.off('*', this._delegateEvent);\n    }\n  }\n\n  clear() {\n    this.releaseEvent();\n    this.transforms = null;\n\n    this.elementMap = null;\n    this.elements = null;\n\n    this.graphicItem = null;\n    this.animate = null;\n\n    this.group?.removeChild(this);\n    this.group = null;\n    super.clear();\n  }\n\n  prepareRelease() {\n    // 清除数据，防止数据比对失败\n    this.differ.setCurrentData(null);\n    this.animate?.stop();\n    this.elementMap.forEach(element => (element.diffState = DiffState.exit));\n    this._finalParameters = this.parameters();\n  }\n\n  release() {\n    this.releaseEvent();\n    this.elements.forEach(element => element.release());\n    this.differ = null;\n    this.elements = [];\n    this.elementMap.clear();\n    this._finalParameters = null;\n\n    if (this.animate) {\n      this.animate.release();\n    }\n\n    if (this.graphicItem) {\n      removeGraphicItem(this.graphicItem);\n    }\n\n    this.detachAll();\n\n    super.release();\n  }\n}\n"]}