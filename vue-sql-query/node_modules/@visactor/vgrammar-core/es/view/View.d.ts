import type { IBounds, ILogger } from '@visactor/vutils';
import { EventEmitter } from '@visactor/vutils';
import type { IColor } from '@visactor/vrender-core';
import type { CoordinateType } from '@visactor/vgrammar-coordinate';
import type { IData, ISignal, ViewSpec, IView, IViewOptions, IViewThemeConfig, Hooks, IMark, MarkType, GrammarScaleType, SignalFunctionType, IScale, IGrammarBase, IGroupMark, IGlyphMark, ICoordinate, BaseEventHandler, IRecordedGrammars, IComponent, IRunningConfig, IViewAnimate, ITheme, InteractionSpec, IInteraction } from '../types/';
import type { IRenderer } from '../types/renderer';
import { LayoutState } from '../graph/enums';
import type { IAxis, IDatazoom, IGrid, ILabel, ILegend, IPlayer, IScrollbar, ISlider, ITitle } from '../types/component';
export default class View extends EventEmitter implements IView {
    container: HTMLElement;
    renderer: IRenderer;
    animate: IViewAnimate;
    rootMark: IGroupMark;
    hooks: Hooks;
    logger: ILogger;
    grammars: IRecordedGrammars;
    private _spec;
    private _config;
    private _options;
    private _cachedGrammars;
    private _differ;
    private _eventConfig;
    private _eventListeners;
    private _theme;
    private _dataflow;
    private _needBuildLayoutTree?;
    private _layoutState?;
    private _layoutMarks?;
    private _background?;
    private _progressiveMarks?;
    private _progressiveRafId?;
    private _observer;
    private _boundInteractions?;
    static useRegisters(comps: (() => void)[]): void;
    constructor(options?: IViewOptions, config?: IViewThemeConfig);
    getGrammarById(id: string): IGrammarBase;
    getSignalById<T>(id: string): ISignal<T> | null;
    getDataById(id: string): IData | null;
    getScaleById(id: string): IScale | null;
    getCoordinateById(id: string): ICoordinate;
    getMarkById(id: string): IMark | null;
    getCustomizedById(id: string): IGrammarBase | null;
    getGrammarsByName(name: string): IGrammarBase[];
    getGrammarsByType(grammarType: string): IGrammarBase[];
    getMarksByType(markType: string): IMark[];
    getMarksByName(name: string): IMark[] | null;
    getMarksBySelector(selector: string | string[] | IMark | IMark[]): IMark[] | null;
    private updateSignal;
    signal<T>(value?: T, update?: SignalFunctionType<T>): ISignal<T>;
    data(values?: any[]): IData;
    scale(type: GrammarScaleType): IScale;
    coordinate(type: CoordinateType): ICoordinate;
    mark(type: MarkType, group?: IGroupMark | string, markOptions?: {
        glyphType?: string;
        componentType?: string;
        mode?: '2d' | '3d';
    }): IMark;
    group(group?: IGroupMark | string): IGroupMark;
    glyph(glyphType: string, group: IGroupMark | string): IGlyphMark;
    component(componentType: string, group: IGroupMark | string, mode?: '2d' | '3d'): IComponent;
    axis(group: IGroupMark | string, mode?: '2d' | '3d'): IAxis;
    grid(group: IGroupMark | string, mode?: '2d' | '3d'): IGrid;
    legend(group: IGroupMark | string): ILegend;
    slider(group: IGroupMark | string): ISlider;
    label(group: IGroupMark | string): ILabel;
    datazoom(group: IGroupMark | string): IDatazoom;
    player(group: IGroupMark | string): IPlayer;
    title(group: IGroupMark | string): ITitle;
    scrollbar(group: IGroupMark | string): IScrollbar;
    customized(type: string, spec: any): IGrammarBase;
    addGrammar(grammar: IGrammarBase): this;
    removeGrammar(grammar: string | IGrammarBase): this;
    removeAllGrammars(): this;
    removeAllGraphicItems(): this;
    parseSpec(spec: ViewSpec): this;
    updateSpec(spec: ViewSpec): this;
    private parseBuiltIn;
    private parseMarkSpec;
    theme(theme: ITheme | string): this;
    getCurrentTheme(): ITheme;
    setCurrentTheme(theme: ITheme | string, render?: boolean): this;
    background(value?: IColor): IColor;
    width(value?: number): number;
    height(value?: number): number;
    viewWidth(value?: number): number;
    viewHeight(value?: number): number;
    padding(value?: number | {
        top?: number;
        left?: number;
        right?: number;
        bottom?: number;
    }): {
        top: number;
        left: number;
        right: number;
        bottom: number;
    };
    autoFit(value?: boolean): boolean;
    getViewBox(): IBounds;
    updateLayoutTag(): this;
    getLayoutState(): LayoutState;
    private buildLayoutTree;
    private doLayout;
    private handleLayoutEnd;
    private handleRenderEnd;
    commit(grammar: IGrammarBase): this;
    run(runningConfig?: IRunningConfig): this;
    private doRender;
    private evaluate;
    private reuseCachedGrammars;
    private detachCachedGrammar;
    private releaseCachedGrammars;
    runAfter(callback: (view: IView) => void): this;
    runBefore(callback: (view: IView) => void): this;
    getImageBuffer(): any;
    traverseMarkTree(apply: (mark: IMark) => any, filter?: (mark: IMark) => boolean, leafFirst?: boolean): this;
    private _bindResizeEvent;
    private _unBindResizeEvent;
    private _getContainerSize;
    private _onResize;
    resize(width: number, height: number, render?: boolean): this;
    private _resizeRenderer;
    interaction(type: string, spec: Partial<InteractionSpec>): IInteraction<any>;
    removeInteraction(type: string | IInteraction, id?: string): this;
    removeAllInteractions(): this;
    initializeEventConfig(config: any): any;
    private initEvent;
    private releaseStageEvent;
    private delegateEvent;
    addEventListener(type: string, handler: BaseEventHandler, options?: any): this;
    removeEventListener(type: string, handler?: BaseEventHandler): this;
    private initializeRenderer;
    private initialize;
    pauseProgressive(): boolean;
    resumeProgressive(): boolean;
    restartProgressive(): boolean;
    private findProgressiveMarks;
    private doPreProgressive;
    private handleProgressiveFrame;
    private clearProgressive;
    release(): void;
}
