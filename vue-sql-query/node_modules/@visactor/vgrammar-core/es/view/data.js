import { array, isNil } from "@visactor/vutils";

import { GrammarBase } from "./grammar-base";

import { invokeParameterFunctionType, isGrammar, parseFunctionType } from "../parse/util";

import { parseTransformSpec } from "../parse/transform";

import { HOOK_EVENT } from "../graph/enums";

import { parseFormat } from "../util/data";

export class Data extends GrammarBase {
    constructor(view, values, format) {
        super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, 
        this._loadTasks = [], this._postFilters = [], this.ingest = options => {
            const format = invokeParameterFunctionType(options.format, this.parameters());
            return this._input = parseFormat(options.values, format), this._input;
        }, this.load = options => {
            if (options.values) return this.ingest(options);
        }, this.relay = options => options[0], this._loadTasks = [], isNil(values) || this.values(values, format);
    }
    parse(spec) {
        return super.parse(spec), this._isLoaded = !1, this.source(spec.source, spec.format, !1), 
        this.url(spec.url, spec.format, !1), this.values(spec.values, spec.format, !1), 
        this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
    }
    parseDataSource(spec) {
        const refs = [], transforms = [], formatRef = spec.format ? parseFunctionType(spec.format, this.view)[0] : null;
        if (formatRef && refs.push(formatRef), spec.values) {
            const valuesRef = parseFunctionType(spec.values, this.view)[0];
            valuesRef && refs.push(valuesRef), transforms.push({
                type: "ingest",
                transform: this.ingest,
                isRawOptions: !0,
                options: {
                    values: spec.values,
                    format: spec.format
                }
            });
        } else if (spec.url) {
            const urlRef = parseFunctionType(spec.url, this.view)[0];
            urlRef && refs.push(urlRef), transforms.push({
                type: "load",
                transform: this.load,
                options: {
                    url: null != urlRef ? urlRef : spec.url,
                    format: null != formatRef ? formatRef : spec.format
                }
            });
        } else if (spec.source) {
            const upstreamData = [];
            array(spec.source).forEach((sourceId => {
                const sourceData = isGrammar(sourceId) ? sourceId : this.view.getDataById(sourceId);
                sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
            })), upstreamData.length && (transforms.push({
                type: "relay",
                transform: this.relay,
                options: upstreamData
            }), this.grammarSource = upstreamData[0]);
        }
        return {
            transforms: transforms,
            refs: refs
        };
    }
    evaluate(upstream, parameters) {
        this.view.emit(HOOK_EVENT.BEFORE_EVALUATE_DATA);
        const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
        this.grammarSource && (this._input = upstream);
        const values = this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
        return this.setValues(filteredValues), this._isLoaded = !0, this.view.emit(HOOK_EVENT.AFTER_EVALUATE_DATA), 
        this;
    }
    output() {
        return this._values;
    }
    getDataIDKey() {
        return this._dataIDKey;
    }
    values(values, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            values: values,
            format: format
        });
        return isNil(values) || (spec.url = void 0, spec.source = void 0), load ? this.parseLoad(spec) : this;
    }
    url(url, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            url: url,
            format: format
        });
        return isNil(url) || (spec.values = void 0, spec.source = void 0), load ? this.parseLoad(spec) : this;
    }
    source(source, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            source: source,
            format: format
        });
        return isNil(source) || (spec.values = void 0, spec.url = void 0), load ? this.parseLoad(spec) : this;
    }
    parseLoad(spec) {
        this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
        const dataSourceResult = this.parseDataSource(this.spec);
        return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, 
        this._isLoaded = !1, this.commit(), this;
    }
    setValues(data) {
        this._values = array(data).map(((entry, index) => {
            const datum = entry === Object(entry) ? entry : {
                data: entry
            };
            return datum[this._dataIDKey] = index, datum;
        }));
    }
    field(field) {
        return this._values.map((value => value[field]));
    }
    transform(transforms) {
        const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
        prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
        const nextTransforms = parseTransformSpec(this.spec.transform, this.view);
        return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), 
        this.commit(), this;
    }
    getValue() {
        return this._values;
    }
    getInput() {
        return this._input;
    }
    addDataFilter(filter) {
        return this._postFilters = this._postFilters.concat(array(filter)), this._postFilters.sort(((filterA, filterB) => {
            var _a, _b;
            return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
        })), this;
    }
    removeDataFilter(filter) {
        const filters = array(filter);
        return this._postFilters = this._postFilters.filter((filter => !filters.includes(filter))), 
        this;
    }
    _evaluateFilter(value, parameters) {
        return this._postFilters.reduce(((result, filter) => filter.filter(result, parameters)), value);
    }
    reuse(grammar) {
        return grammar.grammarType !== this.grammarType || (this._isLoaded = !1, this._values = grammar.output()), 
        this;
    }
    clear() {
        super.clear(), this._input = null, this._values = null;
    }
}
//# sourceMappingURL=data.js.map
