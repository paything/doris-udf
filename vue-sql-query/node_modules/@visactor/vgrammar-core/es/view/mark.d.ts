import type { IGroup } from '@visactor/vrender-core';
import type { IBounds } from '@visactor/vutils';
import { Differ } from '../graph/mark/differ';
import { GrammarBase } from './grammar-base';
import type { GrammarType, ICoordinate, IData, IElement, IGrammarBase, IGroupMark, IMark, IMarkConfig, IView, MarkAnimationSpec, MarkFunctionType, MarkKeySpec, MarkLayoutCallback, MarkLayoutSpec, MarkSortSpec, MarkSpec, MarkStateSpec, MarkType, TransformSpec, Nil, IAnimate, MarkStateSortSpec, BaseSingleEncodeSpec } from '../types';
import type { IBaseScale } from '@visactor/vscale';
import { Element } from '../graph/element';
export declare class Mark extends GrammarBase implements IMark {
    readonly grammarType: GrammarType;
    protected spec: MarkSpec;
    protected needClear?: boolean;
    coord: ICoordinate;
    disableCoordinateTransform: boolean;
    markType: MarkType;
    group: IGroupMark | undefined;
    graphicItem?: IGroup;
    graphicIndex: number;
    graphicParent?: IGroup;
    elements: IElement[];
    elementMap: Map<string, IElement>;
    isUpdated: boolean;
    protected _groupEncodeResult: Record<string, any>;
    private _groupedData;
    protected _isReentered: boolean;
    private _context;
    private renderContext?;
    animate: IAnimate;
    protected differ: Differ<any>;
    private _delegateEvent;
    private _finalParameters;
    constructor(view: IView, markType: MarkType, group?: IGroupMark);
    parse(spec: MarkSpec): this;
    parameters(): any;
    protected parseAddition(spec: MarkSpec): this;
    reuse(grammar: IGrammarBase): this;
    needLayout(): boolean;
    handleLayoutEnd(): void;
    handleRenderEnd(): void;
    evaluateMainTasks(data: any[], parameters: any): this;
    protected evaluateGroup(data: any[]): void;
    protected _getTransformsAfterEncodeItems(): import("../types").IGrammarTask[];
    private _getTransformsAfterEncode;
    private _getTransformsBeforeJoin;
    evaluate(data: any[], parameters: any): this;
    output(): this;
    join(data: IData | string | Nil, key?: MarkKeySpec, sort?: MarkSortSpec, groupBy?: MarkKeySpec, groupSort?: MarkSortSpec): this;
    coordinate(coordinate: ICoordinate | string | Nil): this;
    state(state: MarkFunctionType<string | string[]> | Nil, stateSort?: MarkStateSortSpec): this;
    encode(channel: string | BaseSingleEncodeSpec, value?: MarkFunctionType<any> | boolean, clear?: boolean): this;
    encodeState(state: string, channel: string | BaseSingleEncodeSpec, value?: MarkFunctionType<any> | boolean, clear?: boolean): this;
    protected _getEncoders(): {
        [state: string]: import("../types").GenerateEncoderSpec<Partial<Omit<any, "strokeSeg" | "boundsPadding" | "pickMode" | "boundsMode" | "customPickShape" | "pickable" | "childrenPickable" | "visible" | "zIndex" | "layout" | "keepDirIn3d" | "postMatrix" | "anchor" | "anchor3d">>> | import("../types").StateProxyEncodeSpec<Partial<Omit<any, "strokeSeg" | "boundsPadding" | "pickMode" | "boundsMode" | "customPickShape" | "pickable" | "childrenPickable" | "visible" | "zIndex" | "layout" | "keepDirIn3d" | "postMatrix" | "anchor" | "anchor3d">>>;
    };
    animation(animationConfig: MarkAnimationSpec | Nil): this;
    animationState(animationState: MarkFunctionType<string> | Nil): this;
    layout(layout: MarkLayoutSpec | MarkLayoutCallback | Nil): this;
    morph(enableMorph: boolean, morphKey?: string, morphElementKey?: string): this;
    transform(transforms: TransformSpec[] | Nil): this;
    configure(config: IMarkConfig | Nil): this;
    context(context: any): this;
    isCollectionMark(): boolean;
    needAnimate(): boolean;
    getAllElements(): IElement[];
    getScales(): {};
    getScalesByChannel(): Record<string, IBaseScale>;
    getFieldsByChannel(): Record<string, string>;
    protected init(stage: any, parameters: any): void;
    protected update(spec: MarkSpec): void;
    createElement(): Element;
    protected evaluateJoin(data: any[]): void;
    protected evaluateState(elements: IElement[], stateSpec: MarkStateSpec, parameters: any): void;
    protected evaluateGroupEncode(elements: IElement[], groupEncode: any, parameters: any): {};
    protected getChannelsFromConfig(element?: IElement): {
        pickable: boolean;
    };
    protected evaluateEncode(elements: IElement[], encoders: any, parameters: any, noGroupEncode?: boolean): void;
    addGraphicItem(attrs: any, groupKey?: string, newGraphicItem?: any): any;
    parseRenderContext(data: any[], parameters: any): {
        large: boolean;
        parameters: any;
        progressive: {
            data: any[];
            step: number;
            currentIndex: number;
            totalStep: number;
            groupedData: Map<string, any[]>;
        };
    } | {
        large: boolean;
        parameters?: undefined;
        progressive?: undefined;
    };
    isProgressive(): boolean;
    canAnimateAfterProgressive(): boolean;
    isDoingProgressive(): boolean;
    clearProgressive(): void;
    restartProgressive(): void;
    evaluateJoinProgressive(): IElement[] | {
        groupElements: Record<string, IElement[]>;
        elements: IElement[];
    };
    protected evaluateEncodeProgressive(elements: IElement[], encoders: any, parameters: any): void;
    evaluateProgressive(): void;
    isLargeMode(): boolean;
    cleanExitElements(): void;
    getGroupGraphicItem(): import("@visactor/vrender-core").IGraphic<Partial<import("@visactor/vrender-core").IGraphicAttribute>>;
    getBounds(): IBounds;
    getMorphConfig(): {
        morph: boolean;
        morphKey: string;
        morphElementKey: string;
    };
    getAttributeTransforms(): import("../types").AttributeTransform[];
    getContext(): any;
    protected needSkipBeforeLayout(): boolean;
    private initEvent;
    private releaseEvent;
    clear(): void;
    prepareRelease(): void;
    release(): void;
}
