import { isNil, isString } from "@visactor/vutils";

import { GrammarMarkType } from "../graph/enums";

export class RecordedGrammars {
    constructor(mapKey, warningWhenDuplicated) {
        this._grammars = {
            signal: [],
            data: [],
            scale: [],
            coordinate: [],
            mark: [],
            customized: []
        }, this._grammarMap = {
            signal: {},
            data: {},
            scale: {},
            coordinate: {},
            mark: {},
            customized: {}
        }, this._size = 0, this._mapKey = isString(mapKey) ? grammar => grammar[mapKey] : mapKey, 
        this._warning = warningWhenDuplicated;
    }
    record(grammar) {
        var _a, _b;
        const grammarType = grammar.grammarType, key = this._mapKey(grammar);
        return this._grammarMap[grammarType] ? (this._grammars[grammarType].push(grammar), 
        isNil(key) || (this._grammarMap[grammarType][key] ? null === (_a = this._warning) || void 0 === _a || _a.call(this, key, grammar) : this._grammarMap[grammarType][key] = grammar)) : (this._grammars.customized.push(grammar), 
        isNil(key) || (this._grammarMap.customized[key] ? null === (_b = this._warning) || void 0 === _b || _b.call(this, key, grammar) : this._grammarMap.customized[key] = grammar)), 
        this._size += 1, this;
    }
    unrecord(grammar) {
        const grammarType = grammar.grammarType, key = this._mapKey(grammar);
        return this._grammarMap[grammarType] ? (this._grammars[grammarType] = this._grammars[grammarType].filter((storedGrammar => storedGrammar !== grammar)), 
        isNil(key) || this._grammarMap[grammarType][key] !== grammar || delete this._grammarMap[grammarType][key]) : (this._grammars.customized = this._grammars.customized.filter((storedGrammar => storedGrammar !== grammar)), 
        isNil(key) || this._grammarMap.customized[key] !== grammar || delete this._grammarMap.customized[key]), 
        this._size -= 1, this;
    }
    size() {
        return this._size;
    }
    getSignal(key) {
        var _a;
        return null !== (_a = this._grammarMap.signal[key]) && void 0 !== _a ? _a : null;
    }
    getData(key) {
        var _a;
        return null !== (_a = this._grammarMap.data[key]) && void 0 !== _a ? _a : null;
    }
    getScale(key) {
        var _a;
        return null !== (_a = this._grammarMap.scale[key]) && void 0 !== _a ? _a : null;
    }
    getCoordinate(key) {
        var _a;
        return null !== (_a = this._grammarMap.coordinate[key]) && void 0 !== _a ? _a : null;
    }
    getMark(key) {
        var _a;
        return null !== (_a = this._grammarMap.mark[key]) && void 0 !== _a ? _a : null;
    }
    getCustomized(key) {
        var _a;
        return null !== (_a = this._grammarMap.customized[key]) && void 0 !== _a ? _a : null;
    }
    getGrammar(key) {
        return this._grammarMap.data[key] ? this._grammarMap.data[key] : this._grammarMap.signal[key] ? this._grammarMap.signal[key] : this._grammarMap.scale[key] ? this._grammarMap.scale[key] : this._grammarMap.coordinate[key] ? this._grammarMap.coordinate[key] : this._grammarMap.mark[key] ? this._grammarMap.mark[key] : this._grammarMap.customized[key] ? this._grammarMap.customized[key] : null;
    }
    getAllSignals() {
        return this._grammars.signal;
    }
    getAllData() {
        return this._grammars.data;
    }
    getAllScales() {
        return this._grammars.scale;
    }
    getAllCoordinates() {
        return this._grammars.coordinate;
    }
    getAllMarks() {
        return this._grammars.mark;
    }
    getAllCustomized() {
        return this._grammars.customized;
    }
    traverse(func) {
        var _a;
        Object.values(null !== (_a = this._grammars) && void 0 !== _a ? _a : {}).forEach((grammars => (null != grammars ? grammars : []).forEach((grammar => {
            func.call(null, grammar);
        }))));
    }
    find(func) {
        let targetGrammar = null;
        return this.traverse((grammar => !0 === func.call(null, grammar) && (targetGrammar = grammar, 
        !0))), targetGrammar;
    }
    filter(func) {
        const targetGrammars = [];
        return this.traverse((grammar => {
            !0 === func.call(null, grammar) && targetGrammars.push(grammar);
        })), targetGrammars;
    }
    clear() {
        this._size = 0, this._grammars = {
            signal: [],
            data: [],
            scale: [],
            coordinate: [],
            mark: [],
            customized: []
        }, this._grammarMap = {
            signal: {},
            data: {},
            scale: {},
            coordinate: {},
            mark: {},
            customized: {}
        };
    }
    release() {
        this._size = 0, this._grammars = null, this._grammarMap = null;
    }
}

export class RecordedTreeGrammars extends RecordedGrammars {
    constructor() {
        super(...arguments), this._markNodes = [];
    }
    record(grammar) {
        if (super.record(grammar), "mark" === grammar.grammarType) {
            const mark = grammar, currentNode = {
                mark: mark,
                parent: null,
                children: []
            };
            this._markNodes.forEach((node => {
                const targetMark = node.mark;
                targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, !1) ? (node.children.push(currentNode), 
                currentNode.parent = node) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, !1) && (currentNode.children.push(node), 
                node.parent = currentNode);
            })), this._markNodes.push(currentNode);
        }
        return this;
    }
    unrecord(grammar) {
        if (super.unrecord(grammar), "mark" === grammar.grammarType) {
            const mark = grammar, currentNode = this._markNodes.find((node => node.mark === mark));
            this._markNodes.forEach((node => {
                node.mark.markType === GrammarMarkType.group && node.children.includes(currentNode) ? (node.children = node.children.filter((n => n !== currentNode)), 
                currentNode.parent = null) : mark.markType === GrammarMarkType.group && currentNode.children.includes(node) && (currentNode.children = currentNode.children.filter((n => n !== node)), 
                node.parent = null);
            })), this._markNodes = this._markNodes.filter((n => n !== currentNode));
        }
        return this;
    }
    getAllMarkNodes() {
        return this._markNodes;
    }
    clear() {
        super.clear(), this._markNodes = [];
    }
    release() {
        super.release(), this._markNodes = null;
    }
}

export const releaseUpMarkNode = node => {};
//# sourceMappingURL=grammar-record.js.map
