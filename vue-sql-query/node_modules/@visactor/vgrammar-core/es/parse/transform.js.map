{"version":3,"sources":["../src/parse/transform.ts"],"names":[],"mappings":"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","file":"transform.js","sourcesContent":["import { isArray, isFunction, isNil } from '@visactor/vutils';\nimport { Factory } from '../core/factory';\nimport type { IGrammarBase, IGrammarTask, IView, TransformSpec, TransformSpecValue } from '../types';\nimport { isSignal, parseFunctionType, parseReference } from './util';\n\nconst parseSimpleOptionValue = (key: string, transformSpecValue: TransformSpecValue, view: IView) => {\n  if (key === 'callback' && isFunction(transformSpecValue)) {\n    return {\n      references: [],\n      value: {\n        callback: transformSpecValue,\n        dependency: []\n      }\n    };\n  }\n\n  if (!isNil((transformSpecValue as TransformSpecValue).data)) {\n    // { data: 'someData' }\n    const grammarInstance = view.getDataById((transformSpecValue as TransformSpecValue).data);\n    return {\n      references: [grammarInstance],\n      value: grammarInstance\n    };\n  }\n\n  if (!isNil((transformSpecValue as TransformSpecValue).customized)) {\n    // { customized: 'proj' }\n    const grammarInstance = view.getCustomizedById((transformSpecValue as TransformSpecValue).customized);\n    return {\n      references: [grammarInstance],\n      value: grammarInstance\n    };\n  }\n\n  if (!isNil((transformSpecValue as TransformSpecValue).scale)) {\n    // { scale: 'scaleX' }\n    const grammarInstance = view.getScaleById((transformSpecValue as TransformSpecValue).scale);\n    return {\n      references: [grammarInstance],\n      value: grammarInstance\n    };\n  }\n\n  if (isSignal(transformSpecValue)) {\n    const references = parseFunctionType(transformSpecValue, view);\n\n    return {\n      references,\n      value: transformSpecValue.callback\n        ? {\n            value: transformSpecValue.callback,\n            dependency: references\n          }\n        : references?.[0] ?? transformSpecValue\n    };\n  }\n\n  return { value: transformSpecValue };\n};\n\nconst parseTransformOption = (key: string, transformSpecValue: TransformSpecValue, view: IView) => {\n  if (isNil(transformSpecValue)) {\n    return { value: transformSpecValue };\n  }\n\n  if (isArray(transformSpecValue)) {\n    const values = transformSpecValue.map((v: any) => parseSimpleOptionValue(key, v, view));\n\n    return {\n      references: values.reduce((res: any[], val: any) => {\n        if (val.references) {\n          res.concat(val.references);\n        }\n\n        return res;\n      }, []),\n      value: values.map((entry: any) => entry.value)\n    };\n  }\n\n  return parseSimpleOptionValue(key, transformSpecValue, view);\n};\n\nconst parseTransform = (transformSpec: TransformSpec, view: IView) => {\n  const transformDef = Factory.getTransform(transformSpec.type);\n\n  if (!transformDef) {\n    return;\n  }\n\n  const options = {};\n  let references: IGrammarBase[] = [];\n\n  Object.keys(transformSpec).forEach(specKey => {\n    // we dont need to parse type\n    if (specKey === 'type') {\n      return;\n    }\n\n    const specValue = transformSpec[specKey];\n    if (specKey === 'dependency') {\n      if (specValue?.length) {\n        references = references.concat(parseReference(specValue, view));\n      }\n      return;\n    }\n    const res = parseTransformOption(specKey, specValue, view);\n\n    if (res) {\n      if (res.references?.length) {\n        references = references.concat(res.references);\n      }\n\n      options[specKey] = res.value;\n    }\n  });\n\n  return {\n    markPhase: transformDef.markPhase,\n    transform: transformDef.transform,\n    canProgressive: transformDef.canProgressive,\n    type: transformDef.type,\n    options,\n    references\n  };\n};\n\nexport const parseTransformSpec = (spec: TransformSpec[], view: IView) => {\n  if (spec?.length) {\n    const transforms: IGrammarTask[] = [];\n    let refs: IGrammarBase[] = [];\n    spec.forEach(transformSpec => {\n      const transform = parseTransform(transformSpec, view);\n\n      if (transform) {\n        if (transform.references?.length) {\n          refs = refs.concat(transform.references);\n        }\n\n        transforms.push(transform);\n      }\n    });\n    return { transforms, refs };\n  }\n\n  return null;\n};\n"]}