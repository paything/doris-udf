import { DataFilterRank, GrammarMarkType } from "../graph/enums";

import { isString } from "@visactor/vutils";

import { Filter } from "./filter";

export class ScrollbarFilter extends Filter {
    constructor(view, options) {
        super(view, options), this.type = ScrollbarFilter.type, this.options = Object.assign({}, ScrollbarFilter.defaultOptions, options), 
        this._marks = view.getMarksBySelector(this.options.source).filter((mark => mark.markType === GrammarMarkType.component && "scrollbar" === mark.componentType)), 
        this._data = isString(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
    }
    getEvents() {
        if (!this._marks || 0 === this._marks.length) return [];
        const scrollbar = this._marks[0];
        if (!this._data || !scrollbar) return [];
        const filter = this.options.target.filter, transform = this.options.target.transform, dataFilter = isString(filter) ? (datum, filterValue) => {
            const scale = scrollbar.getScale().getScale(), range = scale.range(), datumRatio = (scale.scale(datum[filter]) - range[0]) / (range[range.length - 1] - range[0]);
            return filterValue.startRatio <= datumRatio && filterValue.endRatio >= datumRatio;
        } : filter;
        return this._filterData(this._data, scrollbar, DataFilterRank.scrollbar, (event => {
            if (isString(filter)) {
                const range = event.detail.value, scaleGrammar = scrollbar.getScale();
                if (scaleGrammar) {
                    const scale = scaleGrammar.getScale(), scaleRange = scale.range();
                    return {
                        start: scale.invert(range[0] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
                        end: scale.invert(range[1] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
                        startRatio: range[0],
                        endRatio: range[1]
                    };
                }
                return {
                    startRatio: range[0],
                    endRatio: range[1]
                };
            }
            return {
                startRatio: event.detail.value[0],
                endRatio: event.detail.value[1]
            };
        }), dataFilter, transform), [ {
            type: "scrollUp",
            handler: this.handleFilter
        }, {
            type: "scrollDrag",
            handler: this.handleFilter
        } ];
    }
}

ScrollbarFilter.type = "scrollbar-filter", ScrollbarFilter.defaultOptions = {};
//# sourceMappingURL=scrollbar-filter.js.map