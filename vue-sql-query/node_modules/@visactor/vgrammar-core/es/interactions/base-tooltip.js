import { Tooltip as TooltipComponent } from "@visactor/vrender-components";

import { array, isArray, isFunction, isNil, isObjectLike, isString, isValid, merge } from "@visactor/vutils";

import { field as getFieldAccessor } from "@visactor/vgrammar-util";

import { BaseInteraction } from "./base";

import { isFieldEncode } from "../parse/mark";

import { invokeFunctionType } from "../parse/util";

export const generateTooltipAttributes = (point, title, content, bounds, theme, addition) => {
    var _a;
    const tooltipTheme = null === (_a = null == theme ? void 0 : theme.components) || void 0 === _a ? void 0 : _a.tooltip;
    return merge({}, tooltipTheme, {
        visible: !0,
        pointerX: point.x,
        pointerY: point.y,
        title: title,
        content: content,
        parentBounds: bounds
    }, null != addition ? addition : {});
};

export class BaseTooltip extends BaseInteraction {
    constructor(view, options) {
        super(view, options), this._marks = view.getMarksBySelector(options.selector);
    }
    bind() {
        super.bind();
        const stage = this.view.renderer.stage();
        !this._tooltipComponent && stage && (this._tooltipComponent = new TooltipComponent({}), 
        stage.defaultLayer.appendChild(this._tooltipComponent));
    }
    unbind() {
        super.unbind();
        const stage = this.view.renderer.stage();
        this._tooltipComponent && stage && (stage.defaultLayer.removeChild(this._tooltipComponent), 
        this._tooltipComponent.release(), this._tooltipComponent = null);
    }
    _computeTooltipRow(row, datum) {
        let key, value, symbol, visible = invokeFunctionType(row.visible, this.parameters(), datum);
        if (visible = !!isNil(visible) || !!visible, isFieldEncode(row.key)) {
            key = getFieldAccessor(row.key.field)(datum);
        } else key = invokeFunctionType(row.key, this.parameters(), datum);
        if (key = isNil(key) ? void 0 : isObjectLike(key) ? key : {
            text: key
        }, isFieldEncode(row.value)) {
            value = getFieldAccessor(row.value.field)(datum);
        } else value = invokeFunctionType(row.value, this.parameters(), datum);
        if (value = isNil(value) ? void 0 : isObjectLike(value) ? value : {
            text: value
        }, isFieldEncode(row.symbol)) {
            symbol = getFieldAccessor(row.symbol.field)(datum);
        } else symbol = invokeFunctionType(row.symbol, this.parameters(), datum);
        return symbol = isNil(symbol) ? void 0 : isObjectLike(symbol) ? symbol : {
            symbolType: symbol
        }, {
            visible: visible,
            key: key,
            value: value,
            shape: symbol
        };
    }
    _computeTitleContent(datum) {
        const title = isValid(this.options.title) ? isFunction(this.options.title) ? this.options.title.call(null, datum, null, {}) : this._computeTooltipRow(isString(this.options.title) ? {
            value: this.options.title
        } : this.options.title, datum) : void 0, content = isValid(this.options.content) ? isFunction(this.options.content) ? array(this.options.content.call(null, datum, null, {})) : array(datum).reduce(((content, datumRow) => content.concat(array(this.options.content).map((row => this._computeTooltipRow(row, datumRow))))), []) : void 0;
        return {
            title: isArray(title) ? title[0] : title,
            content: content
        };
    }
}
//# sourceMappingURL=base-tooltip.js.map