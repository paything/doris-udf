{"version":3,"sources":["../src/transforms/mark/symmetry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,aAAa,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAGhF,MAAM,iBAAiB,GAAG,CAAC,YAAwB,EAAE,OAAkB,EAAE,KAAqB,EAAE,EAAE;IAChG,MAAM,WAAW,GAAG,GAAG,OAAO,GAAG,CAAC;IAClC,MAAM,aAAa,GAAG,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IACxF,MAAM,YAAY,GAAG,aAAa;QAChC,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,gBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QAC/F,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC;IACzD,MAAM,MAAM,GAAG,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;IAErF,IAAI,aAAa,CAAC,MAAM,CAAC,EAAE;QACzB,YAAY,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE;YACjC,MAAM,MAAM,GAAG,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;YAC5C,IAAI,aAAa,EAAE;gBACjB,EAAE,CAAC,iBAAiB,CAAC;oBACnB,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,WAAW,CAAC,GAAG,MAAM;oBACxD,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,MAAM;iBACjD,CAAC,CAAC;aACJ;iBAAM;gBACL,EAAE,CAAC,iBAAiB,CAAC;oBACnB,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,MAAM;iBACjD,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC;AAKF,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,OAAiC,EAAE,YAAwB,EAAE,EAAE;;IACtF,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAA,MAAA,YAAY,CAAC,CAAC,CAAC,0CAAE,IAAI,CAAA,EAAE;QACxE,OAAO,YAAY,CAAC;KACrB;IAED,OAAO,iBAAiB,CAAC,YAAY,EAAE,MAAA,OAAO,CAAC,OAAO,mCAAI,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;AAChF,CAAC,CAAC","file":"symmetry.js","sourcesContent":["import { isNil, isValidNumber, maxInArray, minInArray } from '@visactor/vutils';\nimport type { IElement, SymmetryTransformOptions } from '../../types';\n\nconst symmetryByChannel = (upstreamData: IElement[], channel: 'x' | 'y', align?: 'min' | 'max') => {\n  const baseChannel = `${channel}1`;\n  const hasRangeValue = upstreamData.some(el => !isNil(el.getItemAttribute(baseChannel)));\n  const middleValues = hasRangeValue\n    ? upstreamData.map(el => (el.getItemAttribute(baseChannel) + el.getItemAttribute(channel)) / 2)\n    : upstreamData.map(el => el.getItemAttribute(channel));\n  const maxMid = align === 'min' ? minInArray(middleValues) : maxInArray(middleValues);\n\n  if (isValidNumber(maxMid)) {\n    upstreamData.forEach((el, index) => {\n      const offset = maxMid - middleValues[index];\n      if (hasRangeValue) {\n        el.setItemAttributes({\n          [baseChannel]: el.getItemAttribute(baseChannel) + offset,\n          [channel]: el.getItemAttribute(channel) + offset\n        });\n      } else {\n        el.setItemAttributes({\n          [channel]: el.getItemAttribute(channel) + offset\n        });\n      }\n    });\n  }\n\n  return upstreamData;\n};\n\n/**\n * 针对mark的symmetry变换，支持x、y方向\n */\nexport const symmetry = (options: SymmetryTransformOptions, upstreamData: IElement[]) => {\n  if (!upstreamData || upstreamData.length === 0 || !upstreamData[0]?.mark) {\n    return upstreamData;\n  }\n\n  return symmetryByChannel(upstreamData, options.channel ?? 'y', options.align);\n};\n"]}