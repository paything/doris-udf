import { isNil } from "@visactor/vutils";

import { MARK_OVERLAP_HIDE_KEY } from "../../graph/constants";

function reset(elements) {
    return elements.forEach((element => {
        element.getGraphicAttribute(MARK_OVERLAP_HIDE_KEY) && (element.setGraphicAttribute("visible", !0), 
        element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, !1));
    })), elements;
}

function overlapX(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        let lastX = -1 / 0, lastR = 0;
        const useDeltaMul = isNil(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastX = currentX, lastR = r;
        }));
    }
}

function overlapY(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        let lastY = -1 / 0, lastR = 0;
        const useDeltaMul = isNil(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentY = element.getGraphicAttribute("y");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastY = currentY, lastR = r;
        }));
    }
}

function overlapXY(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        const lastX = -1 / 0;
        let lastY = -1 / 0, lastR = 0, dis = 0;
        const useDeltaMul = isNil(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x"), currentY = element.getGraphicAttribute("y");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (lastX - currentX) ** 2 + (lastY - currentY) ** 2, 
            dis < (itemDelta + lastR + r) ** 2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(MARK_OVERLAP_HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastY = currentY, lastR = r;
        }));
    }
}

export const transform = (options, upstreamData) => {
    if (!upstreamData || 0 === upstreamData.length) return;
    let {radius: radius} = options;
    isNil(radius) && "symbol" === upstreamData[0].mark.markType && (radius = !0);
    const {direction: direction, delta: delta, deltaMul: deltaMul = 1, groupBy: groupBy} = options, handleOverlap = elements => {
        reset(elements);
        const sortedElements = options.sort ? elements.slice().sort(((a, b) => a.getGraphicAttribute("x") - b.getGraphicAttribute("x"))) : elements;
        0 === direction ? overlapXY(sortedElements, delta, deltaMul, radius) : 1 === direction ? overlapX(sortedElements, delta, deltaMul, radius) : overlapY(sortedElements, delta, deltaMul, radius);
    };
    if (groupBy) {
        const map = upstreamData.reduce(((res, element) => {
            const groupName = element.getDatum()[groupBy];
            return res[groupName] ? res[groupName].push(element) : res[groupName] = [ element ], 
            res;
        }), {});
        Object.keys(map).forEach((key => {
            handleOverlap(map[key]);
        }));
    } else handleOverlap(upstreamData);
    return upstreamData;
};
//# sourceMappingURL=mark-overlap.js.map
