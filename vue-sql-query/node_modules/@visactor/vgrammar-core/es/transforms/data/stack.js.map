{"version":3,"sources":["../src/transforms/data/stack.ts"],"names":[],"mappings":"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","file":"stack.js","sourcesContent":["import { field } from '@visactor/vgrammar-util';\nimport { groupData } from '../../graph/mark/differ';\nimport type { StackTransformOptions } from '../../types';\n\nconst stack = (options: StackTransformOptions, data: any[]) => {\n  const positiveValues = new Map<string, number>();\n  const negativeValues = new Map<string, number>();\n\n  const offset = options.offset ?? 'diverging';\n\n  return data.map(datum => {\n    const dimension = datum[options.dimensionField];\n    const stackValue = offset === 'diverging' ? datum[options.stackField] : Math.abs(datum[options.stackField]);\n\n    const map = stackValue >= 0 ? positiveValues : negativeValues;\n    const lastValue = map.get(dimension) ?? 0;\n    const value = stackValue + lastValue;\n    map.set(dimension, value);\n\n    return {\n      dimension,\n      value: stackValue,\n      stack: value,\n      prevStack: lastValue,\n      datum\n    };\n  });\n};\n\nconst silhouetteOffset = (options: StackTransformOptions, data: any[]) => {\n  if (!data || data.length === 0) {\n    return data;\n  }\n  const groupedData = groupData(data, field('dimension'));\n  groupedData.keys.forEach(key => {\n    const dimensionData = groupedData.data.get(key);\n    if (!dimensionData || dimensionData.length <= 0) {\n      return 0;\n    }\n    // refer to Stacked Graphs – Geometry & Aesthetics by Lee Byron & Martin Wattenberg, http://leebyron.com/streamgraph/\n    const g0 = -dimensionData.reduce((sum, entry) => sum + entry.value, 0) / 2;\n    dimensionData.forEach(datum => {\n      datum.stack = datum.stack + g0;\n      datum.prevStack = datum.prevStack + g0;\n    });\n  });\n\n  return data;\n};\n\nconst wiggleOffset = (options: StackTransformOptions, data: any[]) => {\n  if (!data || data.length === 0) {\n    return data;\n  }\n  const groupedData = groupData(data, field('dimension'));\n  groupedData.keys.forEach(key => {\n    const dimensionData = groupedData.data.get(key);\n    if (!dimensionData || dimensionData.length <= 0) {\n      return 0;\n    }\n    // refer to Stacked Graphs – Geometry & Aesthetics by Lee Byron & Martin Wattenberg, http://leebyron.com/streamgraph/\n    const n = dimensionData.length;\n    const g0 = -(1 / (n + 1)) * dimensionData.reduce((sum, entry, i) => entry.value * (n - i + 1), 0);\n    dimensionData.forEach(datum => {\n      datum.stack = datum.stack + g0;\n      datum.prevStack = datum.prevStack + g0;\n    });\n  });\n\n  return data;\n};\n\nconst setFields = (options: StackTransformOptions, data: any[]) => {\n  const needPercent = options.asPercentStack || options.asPrevPercentStack || options.asPercent || options.asSum;\n  if (!needPercent) {\n    return data.map(entry => {\n      const { stack, prevStack, datum } = entry;\n      const newDatum = Object.assign({}, datum);\n\n      newDatum[options.asStack ?? options.stackField] = stack;\n      if (options.asPrevStack) {\n        newDatum[options.asPrevStack] = prevStack;\n      }\n\n      return newDatum;\n    });\n  }\n\n  const positiveSums = new Map<string, number>();\n  const negativeSums = new Map<string, number>();\n  data.forEach(entry => {\n    const { dimension, value } = entry;\n    const map = value >= 0 ? positiveSums : negativeSums;\n    map.set(dimension, (map.get(dimension) ?? 0) + value);\n  });\n\n  return data.map(entry => {\n    const { dimension, value, stack, prevStack, datum } = entry;\n    const newDatum = Object.assign({}, datum);\n    const map = value >= 0 ? positiveSums : negativeSums;\n    const sum = map.get(dimension) ?? 0;\n\n    newDatum[options.asStack ?? options.stackField] = stack;\n    if (options.asPrevStack) {\n      newDatum[options.asPrevStack] = prevStack;\n    }\n\n    if (options.asSum) {\n      newDatum[options.asSum] = sum;\n    }\n    if (options.asPercent) {\n      newDatum[options.asPercent] = sum === 0 ? 0 : value / sum;\n    }\n    if (options.asPercentStack) {\n      newDatum[options.asPercentStack] = sum === 0 ? 0 : stack / sum;\n    }\n    if (options.asPrevPercentStack) {\n      newDatum[options.asPrevPercentStack] = sum === 0 ? 0 : prevStack / sum;\n    }\n\n    return newDatum;\n  });\n};\n\nexport const transform = (options: StackTransformOptions, upstreamData: any[]) => {\n  const offset = options.offset ?? 'diverging';\n  const data = options.order === 'negative' ? upstreamData.slice().reverse() : upstreamData;\n\n  const stackedValues = stack(options, data);\n\n  if (offset === 'silhouette') {\n    silhouetteOffset(options, stackedValues);\n  } else if (offset === 'wiggle') {\n    wiggleOffset(options, stackedValues);\n  }\n\n  const output = setFields(options, stackedValues);\n\n  return options.order === 'negative' ? output.reverse() : output;\n};\n"]}