{"version":3,"sources":["../src/graph/attributes/line.ts"],"names":[],"mappings":"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","file":"line.js","sourcesContent":["import type { IColor, IColorStop, ISegment } from '@visactor/vrender-core';\nimport type { IPointLike } from '@visactor/vutils';\nimport { isNil, isString } from '@visactor/vutils';\nimport type { IElement } from '../../types';\n\nconst isStopsEqual = (prev: IColorStop[], next: IColorStop[]) => {\n  if (prev === next) {\n    return true;\n  }\n  const prevLength = (prev && prev.length) ?? 0;\n  const nextLength = (next && next.length) ?? 0;\n\n  if (prevLength !== nextLength || prevLength === 0) {\n    return false;\n  }\n\n  return prev.every((prevEntry, prevIndex) => {\n    return (\n      (!prevEntry && !next[prevIndex]) ||\n      (prevEntry &&\n        next[prevIndex] &&\n        prevEntry.color === next[prevIndex].color &&\n        prevEntry.offset === next[prevIndex].offset)\n    );\n  });\n};\n\nconst isColorAttrEqual = (prev: IColor, next: IColor) => {\n  if (prev === next) {\n    return true;\n  }\n\n  if (typeof prev !== typeof next) {\n    return false;\n  }\n\n  if (isString(prev)) {\n    return false;\n  }\n\n  if (prev.gradient !== (next as any).gradient) {\n    return false;\n  }\n\n  const prevKeys = Object.keys(prev);\n  const nextKeys = Object.keys(next);\n\n  if (prevKeys.length !== nextKeys.length) {\n    return false;\n  }\n\n  return prevKeys.every(key => {\n    if (key === 'stops') {\n      return isStopsEqual(prev[key], next[key]);\n    }\n\n    return prev[key] === next[key];\n  });\n};\n\nconst isLineDashEqual = (prev: number[], next: number[]) => {\n  if (prev.length !== next.length) {\n    return false;\n  }\n\n  if (prev.join('-') === next.join('-')) {\n    return true;\n  }\n\n  return false;\n};\n\nconst isSegmentAttrEqual = (prev: any, next: any, key: string) => {\n  if (isNil(prev) && isNil(next)) {\n    return true;\n  }\n\n  if (isNil(prev)) {\n    return false;\n  }\n\n  if (isNil(next)) {\n    return false;\n  }\n\n  if (key === 'lineDash') {\n    return isLineDashEqual(prev, next);\n  }\n\n  if (key === 'stroke' || key === 'fill') {\n    return isColorAttrEqual(prev, next);\n  }\n\n  return prev === next;\n};\n\nconst fillAttrs = ['fill', 'fillOpacity', 'background', 'texture', 'texturePadding', 'textureSize', 'textureColor'];\nconst strokeAttrs = [\n  'stroke',\n  'strokeOpacity',\n  'lineDash',\n  'lineDashOffset',\n  'lineCap',\n  'lineJoin',\n  'lineWidth',\n  'miterLimit'\n];\nconst areaAttrs = fillAttrs.concat(strokeAttrs);\n\n/**\n * 生成用于渲染的点数组\n * @param {*} item\n * @returns {IPointLike[]}\n */\nexport function getLineSegmentConfigs(items: any[], points: any[], element?: IElement) {\n  if (!items || items.length <= 1) {\n    return null;\n  }\n\n  const checkAttributes = element?.mark?.markType === 'area' ? areaAttrs : strokeAttrs;\n\n  const segments: any[] = [];\n  let prevSegmentAttrs: any = null;\n\n  items.forEach((item, index) => {\n    if (\n      !prevSegmentAttrs ||\n      !checkAttributes.every(key => {\n        return isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key);\n      })\n    ) {\n      if (segments.length) {\n        segments[segments.length - 1].endIndex = index;\n      }\n\n      prevSegmentAttrs = item;\n      segments.push({\n        attrs: prevSegmentAttrs,\n        startIndex: index\n      });\n    }\n  });\n\n  if (segments.length >= 2) {\n    return segments.map(entry => {\n      const res = parseCollectionMarkAttributes(entry.attrs) as any;\n\n      res.points = points.slice(entry.startIndex, isNil(entry.endIndex) ? points.length : entry.endIndex);\n      return res;\n    });\n  }\n\n  return null;\n}\n\n/**\n * get the segments for connectNulls\n * @param {*} item\n * @returns {IPointLike[]}\n */\nexport function getConnectLineSegmentConfigs(items: any[], points: IPointLike[], element?: IElement) {\n  if (!items || items.length <= 1) {\n    return null;\n  }\n  const enableSegments = element ? element.mark.getSpec().enableSegments : false;\n  let segments: { isConnect?: boolean; points: any[]; items: any[] }[] = [];\n  let point: IPointLike = null;\n  let isPrevDefined: boolean;\n  let curSegment: { isConnect?: boolean; points: any[]; items: any[] };\n\n  items.forEach((item, index) => {\n    point = points[index];\n\n    if (point && point.defined !== false) {\n      if (!isPrevDefined) {\n        // start a segment\n        curSegment = {\n          items: [],\n          points: []\n        };\n        segments.push(curSegment);\n      }\n\n      curSegment.points.push(point);\n      curSegment.items.push(item);\n\n      if (isPrevDefined === false) {\n        curSegment.isConnect = true;\n\n        curSegment = {\n          items: [],\n          points: []\n        };\n        segments.push(curSegment);\n      }\n\n      isPrevDefined = true;\n    } else {\n      isPrevDefined = false;\n    }\n  });\n\n  segments = segments.filter(seg => seg.points.length > 0);\n\n  if (segments.length >= 2) {\n    const res: ISegment[] = [];\n\n    segments.forEach(entry => {\n      if (entry.isConnect) {\n        res.push({\n          points: entry.points,\n          isConnect: true\n        } as ISegment);\n        return;\n      } else if (enableSegments) {\n        const subSegments = getLineSegmentConfigs(entry.items, entry.points, element);\n\n        if (subSegments) {\n          subSegments.forEach(subSeg => {\n            res.push(subSeg);\n          });\n\n          return;\n        }\n      }\n\n      const seg = parseCollectionMarkAttributes(entry.items[0]) as any;\n      seg.points = entry.points;\n\n      res.push(seg);\n    });\n\n    return res;\n  } else if (enableSegments) {\n    return getLineSegmentConfigs(items, points, element);\n  }\n\n  return null;\n}\n\nexport function getLinePointsFromSegments(segments: any[]) {\n  if (!segments) {\n    return null;\n  }\n  return segments.reduce((points, segment) => {\n    return points.concat(segment.points);\n  }, []);\n}\n\nexport function parseCollectionMarkAttributes(itemNextAttrs: any) {\n  const result = {};\n\n  if (!itemNextAttrs) {\n    return result;\n  }\n\n  const skipKeys = ['x', 'y', 'x1', 'y1', 'defined', 'size', 'width', 'height', 'context'];\n\n  Object.keys(itemNextAttrs).forEach(key => {\n    if (skipKeys.includes(key)) {\n      return;\n    }\n    result[key] = itemNextAttrs[key];\n  });\n\n  return result;\n}\n\nexport function removeSegmentAttrs(itemNextAttrs: any, element?: IElement) {\n  if (!itemNextAttrs || !itemNextAttrs.segments || !itemNextAttrs.segments.length) {\n    return itemNextAttrs;\n  }\n\n  // TODO 现在非常hack\n  const segmentKeys = element?.mark?.markType === 'area' ? ['fillOpacity', 'strokeOpacity'] : ['strokeOpacity'];\n  const result = {};\n  Object.keys(itemNextAttrs).forEach(key => {\n    if (segmentKeys.includes(key)) {\n      return;\n    }\n    result[key] = itemNextAttrs[key];\n  });\n\n  return result;\n}\n"]}