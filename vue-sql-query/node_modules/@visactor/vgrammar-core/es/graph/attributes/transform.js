import { has, isNil, isPlainObject, isString, isValidNumber } from "@visactor/vutils";

import { GrammarMarkType } from "../enums";

import { getRulePoints } from "./helpers";

import { commonAttributes, transformCommonAttribute } from "./common";

function storeOriginAttributes(name, channels, graphicAttributes, nextAttrs, element, markName) {
    const prevStoredAttrs = element.getGraphicAttribute(name, !1, markName);
    if (prevStoredAttrs) return channels.forEach((channel => {
        channel in nextAttrs && (prevStoredAttrs[channel] = nextAttrs[channel]);
    })), prevStoredAttrs;
    const storedAttrs = {};
    return channels.forEach((channel => {
        storedAttrs[channel] = nextAttrs[channel];
    })), graphicAttributes[name] = storedAttrs, storedAttrs;
}

export const transformsByType = {
    rect3d: [ {
        channels: [ "x", "y", "z", "x1", "y1", "width", "height", "length" ],
        transform: (graphicAttributes, nextAttrs, storedAttrs) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            isValidNumber(nextAttrs.width) || !isValidNumber(nextAttrs.x1) && isValidNumber(storedAttrs.width) ? (graphicAttributes.x = Math.min(null !== (_a = storedAttrs.x) && void 0 !== _a ? _a : 0, null !== (_b = storedAttrs.x1) && void 0 !== _b ? _b : 1 / 0), 
            graphicAttributes.width = storedAttrs.width) : isValidNumber(nextAttrs.x1) || !isValidNumber(nextAttrs.width) && isValidNumber(storedAttrs.x1) ? (graphicAttributes.x = Math.min(storedAttrs.x, storedAttrs.x1), 
            graphicAttributes.width = Math.abs(storedAttrs.x1 - storedAttrs.x)) : (graphicAttributes.x = Math.min(null !== (_c = storedAttrs.x) && void 0 !== _c ? _c : 0, null !== (_d = storedAttrs.x1) && void 0 !== _d ? _d : 1 / 0), 
            graphicAttributes.width = storedAttrs.width), isValidNumber(nextAttrs.height) || !isValidNumber(nextAttrs.y1) && isValidNumber(storedAttrs.height) ? (graphicAttributes.y = Math.min(null !== (_e = storedAttrs.y) && void 0 !== _e ? _e : 0, null !== (_f = storedAttrs.y1) && void 0 !== _f ? _f : 1 / 0), 
            graphicAttributes.height = storedAttrs.height) : isValidNumber(nextAttrs.y1) || !isValidNumber(nextAttrs.height) && isValidNumber(storedAttrs.y1) ? (graphicAttributes.y = Math.min(storedAttrs.y, storedAttrs.y1), 
            graphicAttributes.height = Math.abs(storedAttrs.y1 - storedAttrs.y)) : (graphicAttributes.y = Math.min(null !== (_g = storedAttrs.y) && void 0 !== _g ? _g : 0, null !== (_h = storedAttrs.y1) && void 0 !== _h ? _h : 1 / 0), 
            graphicAttributes.height = storedAttrs.height), isValidNumber(nextAttrs.length) || !isValidNumber(nextAttrs.z1) && isValidNumber(storedAttrs.length) ? (graphicAttributes.z = Math.min(null !== (_j = storedAttrs.z) && void 0 !== _j ? _j : 0, null !== (_k = storedAttrs.z1) && void 0 !== _k ? _k : 1 / 0), 
            graphicAttributes.length = storedAttrs.length) : isValidNumber(nextAttrs.z1) || !isValidNumber(nextAttrs.length) && isValidNumber(storedAttrs.z1) ? (graphicAttributes.z = Math.min(storedAttrs.z, storedAttrs.z1), 
            graphicAttributes.length = Math.abs(storedAttrs.z1 - storedAttrs.z)) : (graphicAttributes.z = Math.min(null !== (_l = storedAttrs.z) && void 0 !== _l ? _l : 0, null !== (_m = storedAttrs.z1) && void 0 !== _m ? _m : 1 / 0), 
            graphicAttributes.length = storedAttrs.length);
        },
        storedAttrs: "sizeAttrs"
    } ],
    [GrammarMarkType.text]: [ {
        channels: [ "text", "limit", "autoLimit", "maxLineWidth", "textType", "_originText" ],
        transform: (graphicAttributes, nextAttrs, storedAttrs) => {
            var _a, _b, _c, _d;
            const limit = null !== (_a = storedAttrs.limit) && void 0 !== _a ? _a : 1 / 0, autoLimit = null !== (_b = storedAttrs.autoLimit) && void 0 !== _b ? _b : 1 / 0, maxWidth = Math.min(limit, autoLimit), isTextConfig = isPlainObject(storedAttrs.text) && !isNil(storedAttrs.text.text), text = isTextConfig ? storedAttrs.text.text : storedAttrs.text;
            Array.isArray(text), graphicAttributes.maxLineWidth = maxWidth === 1 / 0 ? storedAttrs.maxLineWidth : maxWidth, 
            isTextConfig || storedAttrs.textType ? "rich" === storedAttrs.text.type || "rich" === storedAttrs.textType ? graphicAttributes.textConfig = text : "html" === storedAttrs.text.type ? (graphicAttributes.html = text, 
            graphicAttributes.text = null !== (_c = storedAttrs._originText) && void 0 !== _c ? _c : "", 
            graphicAttributes.renderable = !1) : "react" === storedAttrs.text.type ? (graphicAttributes.react = text, 
            graphicAttributes.text = null !== (_d = storedAttrs._originText) && void 0 !== _d ? _d : "", 
            graphicAttributes.renderable = !1) : graphicAttributes.text = text : graphicAttributes.text = text;
        },
        storedAttrs: "limitAttrs"
    } ],
    [GrammarMarkType.rule]: [ {
        channels: [ "x", "y", "x1", "y1" ],
        transform: (graphicAttributes, nextAttrs, storedAttrs) => {
            const points = getRulePoints(storedAttrs);
            graphicAttributes.points = points, graphicAttributes.x = 0, graphicAttributes.y = 0;
        },
        storedAttrs: "pointAttrs"
    } ],
    [GrammarMarkType.symbol]: [ {
        channels: [ "shape", "symbolType" ],
        transform: (graphicAttributes, nextAttrs, storedAttrs) => {
            var _a;
            graphicAttributes.symbolType = null !== (_a = nextAttrs.shape) && void 0 !== _a ? _a : nextAttrs.symbolType;
        }
    }, {
        channels: [ "image", "fill", "background" ],
        transform: (graphicAttributes, nextAttrs, storedAttrs) => {
            nextAttrs.image ? (graphicAttributes.background = nextAttrs.image, graphicAttributes.fill = !1) : storedAttrs.image ? (graphicAttributes.background = storedAttrs.image, 
            graphicAttributes.fill = !1) : (graphicAttributes.fill = storedAttrs.fill, graphicAttributes.background = storedAttrs.background);
        },
        storedAttrs: "imageAttrs"
    } ]
};

export function cloneTransformAttributes(markType, attributes) {
    var _a;
    return (null !== (_a = transformsByType[markType]) && void 0 !== _a ? _a : []).reduce(((clonedAttributes, transform) => (transform.channels.forEach((channel => {
        has(attributes, channel) && (clonedAttributes[channel] = attributes[channel]);
    })), clonedAttributes)), {});
}

export const transformAttributes = (markType, nextAttrs, element, markName) => {
    const graphicAttributes = {}, changedKeys = nextAttrs ? Object.keys(nextAttrs) : [], transforms = isString(markType) ? transformsByType[markType] : markType;
    if (transforms && transforms.length) {
        const tags = [];
        changedKeys.forEach((key => {
            let isTransformed = !1;
            transforms.forEach(((transform, index) => {
                if (transform.channels.includes(key)) {
                    if (!tags[index]) if (transform.storedAttrs) {
                        const storedAttrs = storeOriginAttributes(transform.storedAttrs, transform.channels, graphicAttributes, nextAttrs, element, markName);
                        transform.transform(graphicAttributes, nextAttrs, storedAttrs);
                    } else transform.transform(graphicAttributes, nextAttrs, null);
                    tags[index] = !0, isTransformed = !0;
                }
            })), isTransformed || (commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key]);
        }));
    } else changedKeys.forEach((key => {
        commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key];
    }));
    return graphicAttributes;
};
//# sourceMappingURL=transform.js.map
