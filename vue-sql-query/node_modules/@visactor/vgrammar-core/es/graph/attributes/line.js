import { isNil, isString } from "@visactor/vutils";

const isStopsEqual = (prev, next) => {
    var _a, _b;
    if (prev === next) return !0;
    const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
    return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every(((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset));
}, isColorAttrEqual = (prev, next) => {
    if (prev === next) return !0;
    if (typeof prev != typeof next) return !1;
    if (isString(prev)) return !1;
    if (prev.gradient !== next.gradient) return !1;
    const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
    return prevKeys.length === nextKeys.length && prevKeys.every((key => "stops" === key ? isStopsEqual(prev[key], next[key]) : prev[key] === next[key]));
}, isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-"), isSegmentAttrEqual = (prev, next, key) => !(!isNil(prev) || !isNil(next)) || !isNil(prev) && (!isNil(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next)), fillAttrs = [ "fill", "fillOpacity", "background", "texture", "texturePadding", "textureSize", "textureColor" ], strokeAttrs = [ "stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit" ], areaAttrs = fillAttrs.concat(strokeAttrs);

export function getLineSegmentConfigs(items, points, element) {
    var _a;
    if (!items || items.length <= 1) return null;
    const checkAttributes = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? areaAttrs : strokeAttrs, segments = [];
    let prevSegmentAttrs = null;
    return items.forEach(((item, index) => {
        prevSegmentAttrs && checkAttributes.every((key => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key))) || (segments.length && (segments[segments.length - 1].endIndex = index), 
        prevSegmentAttrs = item, segments.push({
            attrs: prevSegmentAttrs,
            startIndex: index
        }));
    })), segments.length >= 2 ? segments.map((entry => {
        const res = parseCollectionMarkAttributes(entry.attrs);
        return res.points = points.slice(entry.startIndex, isNil(entry.endIndex) ? points.length : entry.endIndex), 
        res;
    })) : null;
}

export function getConnectLineSegmentConfigs(items, points, element) {
    if (!items || items.length <= 1) return null;
    const enableSegments = !!element && element.mark.getSpec().enableSegments;
    let isPrevDefined, curSegment, segments = [], point = null;
    if (items.forEach(((item, index) => {
        point = points[index], point && !1 !== point.defined ? (isPrevDefined || (curSegment = {
            items: [],
            points: []
        }, segments.push(curSegment)), curSegment.points.push(point), curSegment.items.push(item), 
        !1 === isPrevDefined && (curSegment.isConnect = !0, curSegment = {
            items: [],
            points: []
        }, segments.push(curSegment)), isPrevDefined = !0) : isPrevDefined = !1;
    })), segments = segments.filter((seg => seg.points.length > 0)), segments.length >= 2) {
        const res = [];
        return segments.forEach((entry => {
            if (entry.isConnect) return void res.push({
                points: entry.points,
                isConnect: !0
            });
            if (enableSegments) {
                const subSegments = getLineSegmentConfigs(entry.items, entry.points, element);
                if (subSegments) return void subSegments.forEach((subSeg => {
                    res.push(subSeg);
                }));
            }
            const seg = parseCollectionMarkAttributes(entry.items[0]);
            seg.points = entry.points, res.push(seg);
        })), res;
    }
    return enableSegments ? getLineSegmentConfigs(items, points, element) : null;
}

export function getLinePointsFromSegments(segments) {
    return segments ? segments.reduce(((points, segment) => points.concat(segment.points)), []) : null;
}

export function parseCollectionMarkAttributes(itemNextAttrs) {
    const result = {};
    if (!itemNextAttrs) return result;
    const skipKeys = [ "x", "y", "x1", "y1", "defined", "size", "width", "height", "context" ];
    return Object.keys(itemNextAttrs).forEach((key => {
        skipKeys.includes(key) || (result[key] = itemNextAttrs[key]);
    })), result;
}

export function removeSegmentAttrs(itemNextAttrs, element) {
    var _a;
    if (!itemNextAttrs || !itemNextAttrs.segments || !itemNextAttrs.segments.length) return itemNextAttrs;
    const segmentKeys = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? [ "fillOpacity", "strokeOpacity" ] : [ "strokeOpacity" ], result = {};
    return Object.keys(itemNextAttrs).forEach((key => {
        segmentKeys.includes(key) || (result[key] = itemNextAttrs[key]);
    })), result;
}
//# sourceMappingURL=line.js.map
