import { isNil, isValidNumber } from "@visactor/vutils";

import { GrammarMarkType } from "../enums";

export function isValidPointsChannel(channels, markType) {
    switch (markType) {
      case "line":
        return channels.some((channel => [ "x", "y", "defined" ].includes(channel)));

      case "area":
        return channels.some((channel => [ "x", "y", "x1", "y1", "defined" ].includes(channel)));

      case "largeRects":
        return channels.some((channel => [ "x", "y", "width", "y1" ].includes(channel)));

      case "largeSymbols":
        return channels.some((channel => [ "x", "y" ].includes(channel)));
    }
    return !1;
}

export function getRulePoints(nextAttrs) {
    const {x: x, y: y, x1: x1, y1: y1} = nextAttrs;
    return isValidNumber(x) && isValidNumber(y) && isValidNumber(x1) && isValidNumber(y1) ? [ {
        x: x,
        y: y
    }, {
        x: x1,
        y: y1
    } ] : [];
}

export function getLinePoints(items, includeOnePoint, lastPoints, isArea) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    return items.some((item => isValidPointsChannel(Object.keys(item.nextAttrs), "line"))) ? items.map(((item, index) => {
        var _a;
        const attrs = item.nextAttrs, {x: x, y: y, x1: x1, y1: y1, defined: defined} = null !== (_a = null == lastPoints ? void 0 : lastPoints[index]) && void 0 !== _a ? _a : {};
        return isNil(attrs.x) && (attrs.x = x), isNil(attrs.y) && (attrs.y = y), isNil(attrs.defined) && !1 === defined && (attrs.defined = !1), 
        attrs.context = item.key, isArea && (isNil(attrs.x1) && (attrs.x1 = x1), isNil(attrs.y1) && (attrs.y1 = y1)), 
        attrs;
    })) : null != lastPoints ? lastPoints : [];
}

export function getLargeRectsPoints(items, includeOnePoint, lastPoints = []) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    const arr = new Float32Array(4 * items.length);
    return items.forEach(((item, index) => {
        var _a, _b, _c, _d;
        const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[4 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[4 * index + 1], width = null !== (_c = attrs.width) && void 0 !== _c ? _c : lastPoints[4 * index + 2], y1 = null !== (_d = attrs.y1) && void 0 !== _d ? _d : lastPoints[4 * index + 3];
        arr[4 * index] = x, arr[4 * index + 1] = y, arr[4 * index + 2] = width, arr[4 * index + 3] = y1 - y;
    })), arr;
}

export function getLargeSymbolsPoints(items, includeOnePoint, lastPoints = []) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    const arr = new Float32Array(2 * items.length);
    return items.forEach(((item, index) => {
        var _a, _b;
        const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[2 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[2 * index + 1];
        arr[2 * index] = x, arr[2 * index + 1] = y;
    })), arr;
}

export function isPositionOrSizeChannel(type, channel) {
    if ([ "x", "y", "dx", "dy" ].includes(channel)) return !0;
    switch (type) {
      case GrammarMarkType.arc:
        return [ "innerRadius", "outerRadius", "startAngle", "endAngle" ].includes(channel);

      case GrammarMarkType.group:
      case GrammarMarkType.rect:
      case GrammarMarkType.image:
        return [ "width", "height", "y1" ].includes(channel);

      case GrammarMarkType.path:
      case GrammarMarkType.shape:
        return [ "path", "customPath" ].includes(channel);

      case GrammarMarkType.line:
        return "defined" === channel;

      case GrammarMarkType.area:
        return [ "x1", "y1", "defined" ].includes(channel);

      case GrammarMarkType.rule:
        return [ "x1", "y1" ].includes(channel);

      case GrammarMarkType.symbol:
        return "size" === channel;

      case GrammarMarkType.polygon:
        return "points" === channel;

      case GrammarMarkType.text:
        return "text" === channel;
    }
    return !1;
}

export function isPointsMarkType(markType) {
    return [ GrammarMarkType.line, GrammarMarkType.area, GrammarMarkType.largeRects, GrammarMarkType.largeSymbols ].includes(markType);
}
//# sourceMappingURL=helpers.js.map
