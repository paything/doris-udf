{"version":3,"sources":["../src/graph/animation/animate.ts"],"names":[],"mappings":"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","file":"animate.js","sourcesContent":["import { array, isNil, isNumber } from '@visactor/vutils';\nimport type {\n  IAnimate,\n  IAnimationConfig,\n  IAnimationParameters,\n  IAnimationTimeline,\n  IAnimationTimeSlice,\n  IAnimationUnit,\n  IAnimator,\n  IParsedAnimationConfig\n} from '../../types/animate';\nimport { Animator } from './animator';\nimport { invokeAnimateSpec, normalizeAnimationConfig, normalizeStateAnimationConfig } from './config';\nimport { DefaultAnimationParameters, ImmediateAnimationState } from '../constants';\nimport type { AnimationEvent, IElement, IMark, MarkFunctionType } from '../../types';\nimport { invokeFunctionType } from '../../parse/util';\nimport { Arranger } from './arranger';\nimport { DiffState, HOOK_EVENT } from '../enums';\n\nexport class Animate implements IAnimate {\n  mark: IMark;\n  state: MarkFunctionType<string> | null = null;\n  configs: Array<IParsedAnimationConfig>;\n  immediateConfigs: Array<IParsedAnimationConfig> = [];\n\n  private isEnabled: boolean = true;\n  private disabledStates: string[] = [];\n  // store animator by animation state\n  private animators: Map<string, IAnimator[]> = new Map();\n  // count animation for each elements\n  private elementRecorder: WeakMap<\n    IElement,\n    {\n      prevState: string;\n      count: { [state: string]: number };\n    }\n  > = new WeakMap();\n  private timelineCount: Record<string, number> = {};\n  // record: IAnimationRecord;\n\n  constructor(mark: IMark, config: Record<string, IAnimationConfig | IAnimationConfig[]>) {\n    this.mark = mark;\n    this.configs = normalizeAnimationConfig(config ?? {});\n  }\n\n  getAnimationConfigs(animationState: string) {\n    if (!this.isEnabled) {\n      return [];\n    }\n    return (this.configs ?? []).filter(config => config.state === animationState);\n  }\n\n  updateConfig(config: Record<string, IAnimationConfig | IAnimationConfig[]>) {\n    this.configs = normalizeAnimationConfig(config ?? {});\n  }\n\n  updateState(state: MarkFunctionType<string> | null) {\n    this.state = state;\n  }\n\n  animate() {\n    if (!this.isEnabled || !this.configs || !this.configs.length) {\n      return;\n    }\n\n    const elements = this.mark.getAllElements();\n    const parameters = this.mark.parameters();\n\n    elements.forEach(element => {\n      // TODO: if element is restored, clear isReserved flag\n      if (element.isReserved && element.diffState !== DiffState.exit) {\n        element.isReserved = false;\n      }\n      // clear previous animation when animation state changed\n      const prevElementState = this.elementRecorder.get(element)?.prevState;\n      const needStopAnimation = this.configs.some(config => {\n        return (\n          prevElementState !== element.diffState &&\n          config.state === prevElementState &&\n          config.timeline.controlOptions.stopWhenStateChange\n        );\n      });\n      if (needStopAnimation) {\n        this.clearElementAnimation(element, false);\n      }\n      // clear animations for exit elements\n      else if (element.diffState === DiffState.exit && prevElementState !== element.diffState) {\n        this.clearElementAnimation(element, false);\n      }\n    });\n\n    this.configs.forEach(config => {\n      this.animateByTimeline(config, elements, parameters);\n    });\n\n    this.mark.cleanExitElements();\n\n    return this;\n  }\n\n  runAnimationByState(animationState: string) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    // FIXME: maybe do nothing if state animation is already running\n    // if (this.animators.get(animationState)?.length > 0) { return; }\n\n    const stateConfigs = this.configs.filter(config => config.state === animationState);\n    const elements = this.mark.getAllElements();\n    const parameters = this.mark.parameters();\n\n    const animators = stateConfigs.reduce((animators, config) => {\n      return animators.concat(this.animateByTimeline(config, elements, parameters, true));\n    }, [] as IAnimator[]);\n\n    return new Arranger(animators);\n  }\n  stopAnimationByState(animationState: string) {\n    const animators = this.animators.get(animationState);\n    if (animators) {\n      animators.forEach(animator => animator.stop('end'));\n    }\n    return this;\n  }\n  pauseAnimationByState(animationState: string) {\n    const animators = this.animators.get(animationState);\n    if (animators) {\n      animators.forEach(animator => animator.pause());\n    }\n    return this;\n  }\n  resumeAnimationByState(animationState: string) {\n    const animators = this.animators.get(animationState);\n    if (animators) {\n      animators.forEach(animator => animator.resume());\n    }\n    return this;\n  }\n\n  run(config: IAnimationConfig | IAnimationConfig[]) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const parsedConfigs = normalizeStateAnimationConfig(ImmediateAnimationState, config, this.immediateConfigs.length);\n    this.immediateConfigs = this.immediateConfigs.concat(parsedConfigs);\n    const elements = this.mark.getAllElements();\n    const parameters = this.mark.parameters();\n\n    const animators = parsedConfigs.reduce((animators, config) => {\n      return animators.concat(this.animateByTimeline(config, elements, parameters, true));\n    }, [] as IAnimator[]);\n\n    return new Arranger(animators);\n  }\n  stop() {\n    // map will be cleared in animator callback\n    this.animators.forEach(animators => {\n      animators.forEach(animator => animator.stop('end'));\n    });\n    return this;\n  }\n  pause() {\n    this.animators.forEach(stateAnimators => stateAnimators.forEach(animator => animator.pause()));\n    return this;\n  }\n  resume() {\n    this.animators.forEach(stateAnimators => stateAnimators.forEach(animator => animator.resume()));\n    return this;\n  }\n  reverse() {\n    /** Animation scheduler api, resume the recorded animations */\n    return this;\n  }\n  restart() {\n    /** Animation scheduler api, resume current animations */\n    return this;\n  }\n  record() {\n    /** Animation scheduler api, start to record a timestamp */\n    return this;\n  }\n  recordEnd() {\n    /** Animation scheduler api, end to record a timestamp */\n    return this;\n  }\n\n  isAnimating() {\n    let isAnimating = false;\n    this.animators.forEach(animators => {\n      isAnimating = isAnimating || animators.some(animator => animator.isAnimating);\n    });\n    return isAnimating;\n  }\n\n  isElementAnimating(element: IElement) {\n    const stateAnimationCounts = this.elementRecorder.get(element)?.count;\n    return isNil(stateAnimationCounts) || Object.values(stateAnimationCounts).every(count => count === 0);\n  }\n\n  getAnimatorCount() {\n    let count = 0;\n    this.animators.forEach(animators => (count += animators.length));\n    return count;\n  }\n\n  getAllAnimators() {\n    const allAnimators: IAnimator[] = [];\n    this.animators.forEach(animators => {\n      allAnimators.push(...animators);\n    });\n    return allAnimators;\n  }\n\n  getElementAnimators(element: IElement | IElement[], animationState?: string) {\n    const elements = array(element);\n    let animators: IAnimator[] = [];\n    if (animationState) {\n      animators = this.animators.get(animationState) ?? [];\n    } else {\n      this.animators.forEach(stateAnimators => {\n        animators = animators.concat(stateAnimators);\n      });\n    }\n    return animators.filter(animator => elements.includes(animator.element));\n  }\n\n  enable() {\n    this.isEnabled = true;\n    return this;\n  }\n  disable() {\n    this.isEnabled = false;\n    this.stop();\n    this.animators.clear();\n    return this;\n  }\n  enableAnimationState(state: string | string[]) {\n    const states = array(state);\n    this.disabledStates = this.disabledStates.filter(state => !states.includes(state));\n    return this;\n  }\n  disableAnimationState(state: string | string[]) {\n    const states = array(state);\n    this.disabledStates = this.disabledStates.concat(states);\n    return this;\n  }\n\n  release() {\n    this.stop();\n    // we need to clear map\n    this.animators.clear();\n\n    this.configs = null;\n    this.animators = null;\n    this.elementRecorder = null;\n    this.timelineCount = null;\n  }\n\n  private animateByTimeline(\n    config: IParsedAnimationConfig,\n    elements: IElement[],\n    parameters: any,\n    forceState: boolean = false\n  ) {\n    const animators: IAnimator[] = [];\n    const animatedElements = elements.filter(element => {\n      // do not animate on element which is running exit animation\n      // if an element is reserved, it should be set for exit animation and will be removed\n      const checkExit = !(element.isReserved && element.diffState === DiffState.exit);\n      // do not check animation state if forceState is set\n      const state = this.getAnimationState(element);\n      const checkDisabled = !this.disabledStates.includes(state);\n      const checkState = forceState || state === config.state;\n      // filter elements by partitioner config\n      const checkPartitioner =\n        !config.timeline.partitioner || config.timeline.partitioner(element.getDatum(), element, parameters);\n      return checkExit && checkDisabled && checkState && checkPartitioner;\n    });\n\n    if (animatedElements.length) {\n      if (isNil(this.timelineCount[config.id])) {\n        this.timelineCount[config.id] = 0;\n      }\n\n      if (config.timeline.sort) {\n        animatedElements.sort((elementA, elementB) => {\n          return config.timeline.sort(elementA.getDatum(), elementB.getDatum(), elementA, elementB, parameters);\n        });\n      }\n      const width = this.mark.view.width();\n      const height = this.mark.view.height();\n      const animationParameters = {\n        width,\n        height,\n        group: this.mark.group ?? null,\n        mark: this.mark,\n        view: this.mark.view,\n        elementCount: animatedElements.length,\n        elementIndex: 0\n      };\n      // clear animator with same state\n      animatedElements.forEach(element => {\n        (this.animators.get(config.state) ?? [])\n          .filter(animator => animator.element === element && animator.animationOptions.id === config.id)\n          .forEach(animator => {\n            animator.stop(null, false);\n            this.handleAnimatorEnd(animator, false);\n          });\n      });\n      // run animator\n      animatedElements.forEach((element, index) => {\n        animationParameters.elementIndex = index;\n        // add animation parameter into parameters\n        const mergedParameters = Object.assign({ [DefaultAnimationParameters]: animationParameters }, parameters);\n        const animationUnit = this.getAnimationUnit(\n          config.timeline,\n          element,\n          index,\n          animatedElements.length,\n          mergedParameters\n        );\n        animators.push(this.animateElement(config, animationUnit, element, animationParameters, mergedParameters));\n      });\n    }\n    return animators;\n  }\n\n  private animateElement(\n    config: IParsedAnimationConfig,\n    animationUnit: IAnimationUnit,\n    element: IElement,\n    animationParameters: IAnimationParameters,\n    parameters: any\n  ) {\n    // create animator\n    const animator = new Animator(element, animationUnit, config);\n\n    // start animating\n    animator.animate(animationParameters, parameters);\n    // return when animator has no valid animation\n    if (!animator.isAnimating) {\n      return;\n    }\n    if (element.diffState === DiffState.exit) {\n      element.isReserved = true;\n    }\n\n    const isFirstAnimator = this.timelineCount[config.id] === 0;\n\n    this.timelineCount[config.id] += 1;\n    const elementRecord = this.elementRecorder.get(element) ?? { prevState: config.state, count: {} };\n    elementRecord.prevState = config.state;\n    elementRecord.count[config.state] = (elementRecord.count[config.state] ?? 0) + 1;\n    this.elementRecorder.set(element, elementRecord);\n    const stateData = this.animators.get(config.state);\n    if (!stateData) {\n      this.animators.set(config.state, [animator]);\n    } else {\n      stateData.push(animator);\n    }\n    // this.animators.set(config.state, (this.animators.get(config.state) ?? []).concat(animator));\n    // invoke callback when animation finish\n    animator.callback(() => {\n      this.handleAnimatorEnd(animator);\n    });\n\n    // FIXME: handle multiple timelines with same animation state\n    // emit animation start event\n    const animationEvent: AnimationEvent = {\n      mark: this.mark,\n      animationState: config.state,\n      animationConfig: config.originConfig\n    };\n    if (isFirstAnimator) {\n      this.mark.emit(HOOK_EVENT.ANIMATION_START, animationEvent);\n    }\n    this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_START, animationEvent, element);\n\n    return animator;\n  }\n\n  private getAnimationState(element: IElement): string {\n    const customState = invokeFunctionType(this.state, this.mark.parameters(), element.getDatum(), element);\n    return customState ?? element.diffState;\n  }\n\n  private getAnimationUnit(\n    timeline: IAnimationTimeline,\n    element: IElement,\n    index: number,\n    elementCount: number,\n    parameters: any\n  ): IAnimationUnit {\n    const timeSlices: IAnimationTimeSlice[] = [];\n    const startTime = invokeAnimateSpec(timeline.startTime, element, parameters);\n    const totalTime = invokeAnimateSpec(timeline.totalTime, element, parameters);\n    const oneByOne = invokeAnimateSpec(timeline.oneByOne, element, parameters);\n    const loop = invokeAnimateSpec(timeline.loop, element, parameters);\n\n    let loopTime = 0;\n    (timeline.timeSlices as IAnimationTimeSlice[]).forEach(timeSlice => {\n      const delay = invokeAnimateSpec(timeSlice.delay, element, parameters);\n      const delayAfter = invokeAnimateSpec(timeSlice.delayAfter, element, parameters);\n      const duration = invokeAnimateSpec(timeSlice.duration, element, parameters) ?? totalTime / elementCount;\n      const effects = array(timeSlice.effects).map(effect =>\n        Object.assign({}, effect, {\n          customParameters: invokeAnimateSpec(effect.customParameters, element, parameters)\n        })\n      );\n      timeSlices.push({\n        effects,\n        duration,\n        delay,\n        delayAfter\n      });\n      loopTime += delay + duration + delayAfter;\n    });\n\n    const oneByOneDelay = isNumber(oneByOne) ? oneByOne : oneByOne === true ? loopTime : 0;\n    return {\n      initialDelay: startTime,\n      loopCount: isNumber(loop) ? loop : loop === true ? Infinity : 1,\n      loopDelay: oneByOneDelay * index,\n      loopDelayAfter: oneByOneDelay * (elementCount - index - 1),\n      loopAnimateDuration: loopTime,\n      loopDuration: loopTime + oneByOneDelay * (elementCount - 1),\n      totalTime,\n      timeSlices\n    };\n  }\n\n  private clearElementAnimation(element: IElement, clearElement: boolean = true) {\n    this.animators.forEach(animators => {\n      animators.forEach(animator => {\n        if (animator.element === element) {\n          // if previous animation state is exit, modify graphic item channel to start\n          if (animator.animationOptions.state === DiffState.exit) {\n            animator.stop('start', false);\n          } else {\n            animator.stop('end', false);\n          }\n          this.handleAnimatorEnd(animator, clearElement);\n        }\n      });\n    });\n    this.elementRecorder.delete(element);\n  }\n\n  private clearAllElements() {\n    const elements = this.mark.getAllElements();\n    if (elements) {\n      elements.forEach((element, i) => {\n        // only update mark in previous invocation\n        this.clearElement(element, i === elements.length - 1);\n      });\n    }\n  }\n\n  private clearElement(element: IElement, updateMark: boolean = true) {\n    this.clearElementAnimation(element);\n    // element might already be released\n    if (element.getGraphicItem()) {\n      // if element stops animating or needs to be removed, clear all cached attributes\n      element.clearGraphicAttributes();\n      // remove element from mark if exit animation is finished\n      if (element.diffState === DiffState.exit) {\n        element.isReserved = false;\n      }\n      if (updateMark) {\n        this.mark.cleanExitElements();\n      }\n      // TODO: waiting for vRender to optimize bound cache logic, otherwise this line\n      //  will cause huge performance waste in multiple animation like appear & disappear.\n      // if (updateMark) mark.updateBounds();\n    }\n  }\n\n  private handleAnimatorEnd(animator: IAnimator, clearElement: boolean = true) {\n    const element = animator.element;\n    const animationOptions = animator.animationOptions;\n    const animationState = animationOptions.state;\n    const isImmediateAnimation = animationState === ImmediateAnimationState;\n\n    // sub element animation count\n    const stateAnimationCounts = this.elementRecorder.get(element).count;\n    stateAnimationCounts[animationState] -= 1;\n    // FIXME: maybe delete zero animationState\n    // if (stateAnimationCounts[animationState] === 0) {\n    //   delete stateAnimationCounts[animationState];\n    // }\n\n    this.animators.set(\n      animationState,\n      this.animators.get(animationState).filter(ani => ani !== animator)\n    );\n    if (this.animators.get(animationState).length === 0) {\n      this.animators.delete(animationState);\n    }\n    this.timelineCount[animationOptions.id] -= 1;\n    const isLastAnimator = this.timelineCount[animationOptions.id] === 0;\n\n    const originAnimationConfig = isImmediateAnimation\n      ? this.immediateConfigs.find(config => config.id === animationOptions.id).originConfig\n      : this.configs.find(config => config.id === animationOptions.id).originConfig;\n    if (isLastAnimator) {\n      delete this.timelineCount[animationOptions.id];\n      // delete config when immediate executed animation is finished\n      if (isImmediateAnimation) {\n        this.immediateConfigs = this.immediateConfigs.filter(config => config.id !== animationOptions.id);\n      }\n    }\n\n    if (clearElement) {\n      if (Object.keys(this.timelineCount).length === 0) {\n        this.clearAllElements();\n      } else if (animationState === DiffState.exit && stateAnimationCounts[DiffState.exit] === 0) {\n        // if all exit animations are finished\n        this.clearElement(element);\n      }\n    }\n\n    // emit animation end event\n    const animationEvent: AnimationEvent = {\n      mark: this.mark,\n      animationState,\n      animationConfig: originAnimationConfig\n    };\n    if (isLastAnimator) {\n      this.mark.emit(HOOK_EVENT.ANIMATION_END, animationEvent);\n    }\n    this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_END, animationEvent, element);\n  }\n}\n"]}