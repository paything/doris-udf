import { isValidNumber } from "@visactor/vutils";

const getCenterPoints = (element, options, animationParameters) => {
    const points = element.getGraphicAttribute("points", !1), center = {
        x: 0,
        y: 0
    };
    return points.forEach((point => {
        center.x += point.x, center.y += point.y;
    })), center.x /= points.length, center.y /= points.length, options && options.center && (isValidNumber(options.center.x) && (center.x = options.center.x), 
    isValidNumber(options.center.y) && (center.y = options.center.y)), "area" === element.mark.markType && (center.x1 = center.x, 
    center.y1 = center.y), points.map((point => Object.assign({}, point, center)));
};

export const growPointsIn = (element, options, animationParameters) => ({
    from: {
        points: getCenterPoints(element, options)
    },
    to: {
        points: element.getGraphicAttribute("points", !1)
    }
});

export const growPointsOut = (element, options, animationParameters) => ({
    from: {
        points: element.getGraphicAttribute("points", !0)
    },
    to: {
        points: getCenterPoints(element, options)
    }
});

const changePointsX = (element, options, animationParameters) => element.getGraphicAttribute("points", !1).map((point => {
    var _a;
    if (options && "negative" === options.orient) {
        let groupRight = animationParameters.width;
        return animationParameters.group && (groupRight = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
        animationParameters.groupWidth = groupRight), Object.assign(Object.assign({}, point), {
            x: groupRight,
            y: point.y,
            x1: groupRight,
            y1: point.y1,
            defined: !1 !== point.defined
        });
    }
    return Object.assign(Object.assign({}, point), {
        x: 0,
        y: point.y,
        x1: 0,
        y1: point.y1,
        defined: !1 !== point.defined
    });
}));

export const growPointsXIn = (element, options, animationParameters) => ({
    from: {
        points: changePointsX(element, options, animationParameters)
    },
    to: {
        points: element.getGraphicAttribute("points", !1)
    }
});

export const growPointsXOut = (element, options, animationParameters) => ({
    from: {
        points: element.getGraphicAttribute("points", !0)
    },
    to: {
        points: changePointsX(element, options, animationParameters)
    }
});

const changePointsY = (element, options, animationParameters) => element.getGraphicAttribute("points", !1).map((point => {
    var _a;
    if (options && "negative" === options.orient) {
        let groupBottom = animationParameters.height;
        return animationParameters.group && (groupBottom = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), 
        animationParameters.groupHeight = groupBottom), Object.assign(Object.assign({}, point), {
            x: point.x,
            y: groupBottom,
            x1: point.x1,
            y1: groupBottom,
            defined: !1 !== point.defined
        });
    }
    return Object.assign(Object.assign({}, point), {
        x: point.x,
        y: 0,
        x1: point.x1,
        y1: 0,
        defined: !1 !== point.defined
    });
}));

export const growPointsYIn = (element, options, animationParameters) => ({
    from: {
        points: changePointsY(element, options, animationParameters)
    },
    to: {
        points: element.getGraphicAttribute("points", !1)
    }
});

export const growPointsYOut = (element, options, animationParameters) => ({
    from: {
        points: element.getGraphicAttribute("points", !0)
    },
    to: {
        points: changePointsY(element, options, animationParameters)
    }
});
//# sourceMappingURL=grow-points.js.map
