import { isNumber } from "@visactor/vutils";

function growIntervalInIndividual(element, options, animationParameters) {
    const attrs = element.getFinalAnimationAttributes();
    if (options && "x" === options.direction) {
        const x = null == attrs ? void 0 : attrs.x, x1 = null == attrs ? void 0 : attrs.x1;
        return "negative" === options.orient ? {
            from: {
                x: x1,
                x1: x1
            },
            to: {
                x: x,
                x1: x1
            }
        } : {
            from: {
                x: x,
                x1: x
            },
            to: {
                x: x,
                y1: x1
            }
        };
    }
    const y = null == attrs ? void 0 : attrs.y, y1 = null == attrs ? void 0 : attrs.y1;
    return options && "negative" === options.orient ? {
        from: {
            y: y1,
            y1: y1
        },
        to: {
            y: y,
            y1: y1
        }
    } : {
        from: {
            y: y,
            y1: y
        },
        to: {
            y: y,
            y1: y1
        }
    };
}

function growIntervalInOverall(element, options, animationParameters) {
    var _a, _b;
    const attrs = element.getFinalAnimationAttributes();
    if (options && "x" === options.direction) {
        const x = null == attrs ? void 0 : attrs.x, x1 = null == attrs ? void 0 : attrs.x1;
        let overallValue;
        return "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
        animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
        {
            from: {
                x: overallValue,
                x1: overallValue
            },
            to: {
                x: x,
                y1: x1
            }
        };
    }
    const y = null == attrs ? void 0 : attrs.y, y1 = null == attrs ? void 0 : attrs.y1;
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        from: {
            y: overallValue,
            y1: overallValue
        },
        to: {
            y: y,
            y1: y1
        }
    };
}

export const growIntervalIn = (element, options, animationParameters) => {
    var _a, _b;
    const coord = null === (_b = null === (_a = element.mark) || void 0 === _a ? void 0 : _a.coord) || void 0 === _b ? void 0 : _b.output(), isTransposed = coord.isTransposed(), isPolar = "polar" === coord.type, newOptions = {
        orient: "negative",
        direction: isTransposed && !isPolar ? "x" : "y"
    };
    return options && !0 !== options.overall ? growIntervalInIndividual(element, newOptions, animationParameters) : growIntervalInOverall(element, newOptions, animationParameters);
};

function growIntervalOutIndividual(element, options, animationParameters) {
    const attrs = element.getFinalAnimationAttributes();
    if (options && "x" === options.direction) {
        const x = null == attrs ? void 0 : attrs.x, x1 = null == attrs ? void 0 : attrs.x1, prevX = element.getGraphicAttribute("x", !0), prevX1 = element.getGraphicAttribute("x1", !0);
        return "negative" === options.orient ? {
            from: {
                x: prevX,
                x1: prevX1
            },
            to: {
                x: x1,
                x1: x1
            }
        } : {
            from: {
                x: prevX,
                x1: prevX1
            },
            to: {
                x: x,
                x1: x
            }
        };
    }
    const y = null == attrs ? void 0 : attrs.y, y1 = null == attrs ? void 0 : attrs.y1, prevY = element.getGraphicAttribute("y", !0), prevY1 = element.getGraphicAttribute("y1", !0);
    return options && "negative" === options.orient ? {
        from: {
            y: prevY,
            y1: prevY1
        },
        to: {
            y: y1,
            y1: y1
        }
    } : {
        from: {
            y: prevY,
            y1: prevY1
        },
        to: {
            y: y,
            y1: y
        }
    };
}

function growIntervalOutOverall(element, options, animationParameters) {
    var _a, _b;
    if (options && "x" === options.direction) {
        const prevX = element.getGraphicAttribute("x", !0), prevX1 = element.getGraphicAttribute("x1", !0);
        let overallValue;
        return "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
        animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
        {
            from: {
                x: prevX,
                x1: prevX1
            },
            to: {
                x: overallValue,
                x1: overallValue
            }
        };
    }
    const prevY = element.getGraphicAttribute("y", !0), prevY1 = element.getGraphicAttribute("y1", !0);
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        from: {
            y: prevY,
            y1: prevY1
        },
        to: {
            y: overallValue,
            y1: overallValue
        }
    };
}

export const growIntervalOut = (element, options, animationParameters) => {
    var _a, _b;
    const coord = null === (_b = null === (_a = element.mark) || void 0 === _a ? void 0 : _a.coord) || void 0 === _b ? void 0 : _b.output(), isTransposed = coord.isTransposed(), isPolar = "polar" === coord.type, newOptions = {
        orient: "negative",
        direction: isTransposed && !isPolar ? "x" : "y"
    };
    return options && !0 !== options.overall ? growIntervalOutIndividual(element, newOptions, animationParameters) : growIntervalOutOverall(element, newOptions, animationParameters);
};
//# sourceMappingURL=grow-interval.js.map
