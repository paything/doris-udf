import { isNil, isNumber, isValid } from "@visactor/vutils";

export const growCenterIn = (element, options, animationParameters) => {
    switch (null == options ? void 0 : options.direction) {
      case "x":
        {
            const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
            return {
                from: isValid(width) ? {
                    x: x + width / 2,
                    x1: void 0,
                    width: 0
                } : {
                    x: (x + x1) / 2,
                    x1: (x + x1) / 2,
                    width: void 0
                },
                to: {
                    x: x,
                    x1: x1,
                    width: width
                }
            };
        }

      case "y":
        {
            const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
            return {
                from: isValid(height) ? {
                    y: y + height / 2,
                    y1: void 0,
                    height: 0
                } : {
                    y: (y + y1) / 2,
                    y1: (y + y1) / 2,
                    height: void 0
                },
                to: {
                    y: y,
                    y1: y1,
                    height: height
                }
            };
        }

      default:
        {
            const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width"), y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height"), from = {};
            return isValid(width) ? (from.x = x + width / 2, from.width = 0, from.x1 = void 0) : (from.x = (x + x1) / 2, 
            from.x1 = (x + x1) / 2, from.width = void 0), isValid(height) ? (from.y = y + height / 2, 
            from.height = 0, from.y1 = void 0) : (from.y = (y + y1) / 2, from.y1 = (y + y1) / 2, 
            from.height = void 0), {
                from: from,
                to: {
                    x: x,
                    y: y,
                    x1: x1,
                    y1: y1,
                    width: width,
                    height: height
                }
            };
        }
    }
};

export const growCenterOut = (element, options, animationParameters) => {
    switch (null == options ? void 0 : options.direction) {
      case "x":
        {
            const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
            return {
                to: isValid(width) ? {
                    x: x + width / 2,
                    x1: void 0,
                    width: 0
                } : {
                    x: (x + x1) / 2,
                    x1: (x + x1) / 2,
                    width: void 0
                }
            };
        }

      case "y":
        {
            const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
            return {
                to: isValid(height) ? {
                    y: y + height / 2,
                    y1: void 0,
                    height: 0
                } : {
                    y: (y + y1) / 2,
                    y1: (y + y1) / 2,
                    height: void 0
                }
            };
        }

      default:
        {
            const x = element.getFinalAnimationAttribute("x"), y = element.getFinalAnimationAttribute("y"), x1 = element.getFinalAnimationAttribute("x1"), y1 = element.getFinalAnimationAttribute("y1"), width = element.getFinalAnimationAttribute("width"), height = element.getFinalAnimationAttribute("height"), to = {};
            return isValid(width) ? (to.x = x + width / 2, to.width = 0, to.x1 = void 0) : (to.x = (x + x1) / 2, 
            to.x1 = (x + x1) / 2, to.width = void 0), isValid(height) ? (to.y = y + height / 2, 
            to.height = 0, to.y1 = void 0) : (to.y = (y + y1) / 2, to.y1 = (y + y1) / 2, to.height = void 0), 
            {
                to: to
            };
        }
    }
};

function growWidthInIndividual(element, options, animationParameters) {
    const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
    if (options && "negative" === options.orient) {
        const computedX1 = isValid(width) ? Math.max(x, x + width) : Math.max(x, x1);
        return {
            from: {
                x: computedX1,
                x1: isNil(x1) ? void 0 : computedX1,
                width: isNil(width) ? void 0 : 0
            },
            to: {
                x: x,
                x1: x1,
                width: width
            }
        };
    }
    const computedX = isValid(width) ? Math.min(x, x + width) : Math.min(x, x1);
    return {
        from: {
            x: computedX,
            x1: isNil(x1) ? void 0 : computedX,
            width: isNil(width) ? void 0 : 0
        },
        to: {
            x: x,
            x1: x1,
            width: width
        }
    };
}

function growWidthInOverall(element, options, animationParameters) {
    var _a;
    const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
    animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber(null == options ? void 0 : options.overall) ? null == options ? void 0 : options.overall : 0, 
    {
        from: {
            x: overallValue,
            x1: isNil(x1) ? void 0 : overallValue,
            width: isNil(width) ? void 0 : 0
        },
        to: {
            x: x,
            x1: x1,
            width: width
        }
    };
}

export const growWidthIn = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthInOverall(element, options, animationParameters) : growWidthInIndividual(element, options, animationParameters);
};

function growWidthOutIndividual(element, options, animationParameters) {
    const x = element.getFinalAnimationAttribute("x"), x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
    if (options && "negative" === options.orient) {
        const computedX1 = isValid(width) ? Math.max(x, x + width) : Math.max(x, x1);
        return {
            to: {
                x: computedX1,
                x1: isNil(x1) ? void 0 : computedX1,
                width: isNil(width) ? void 0 : 0
            }
        };
    }
    const computedX = isValid(width) ? Math.min(x, x + width) : Math.min(x, x1);
    return {
        to: {
            x: computedX,
            x1: isNil(x1) ? void 0 : computedX,
            width: isNil(width) ? void 0 : 0
        }
    };
}

function growWidthOutOverall(element, options, animationParameters) {
    var _a;
    const x1 = element.getFinalAnimationAttribute("x1"), width = element.getFinalAnimationAttribute("width");
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
    animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        to: {
            x: overallValue,
            x1: isNil(x1) ? void 0 : overallValue,
            width: isNil(width) ? void 0 : 0
        }
    };
}

export const growWidthOut = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthOutOverall(element, options, animationParameters) : growWidthOutIndividual(element, options, animationParameters);
};

function growHeightInIndividual(element, options, animationParameters) {
    const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
    if (options && "negative" === options.orient) {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            from: {
                y: computedY1,
                y1: isNil(y1) ? void 0 : computedY1,
                height: isNil(height) ? void 0 : 0
            },
            to: {
                y: y,
                y1: y1,
                height: height
            }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        from: {
            y: computedY,
            y1: isNil(y1) ? void 0 : computedY,
            height: isNil(height) ? void 0 : 0
        },
        to: {
            y: y,
            y1: y1,
            height: height
        }
    };
}

function growHeightInOverall(element, options, animationParameters) {
    var _a;
    const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        from: {
            y: overallValue,
            y1: isNil(y1) ? void 0 : overallValue,
            height: isNil(height) ? void 0 : 0
        },
        to: {
            y: y,
            y1: y1,
            height: height
        }
    };
}

export const growHeightIn = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightInOverall(element, options, animationParameters) : growHeightInIndividual(element, options, animationParameters);
};

function growHeightOutIndividual(element, options, animationParameters) {
    const y = element.getFinalAnimationAttribute("y"), y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
    if (options && "negative" === options.orient) {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            to: {
                y: computedY1,
                y1: isNil(y1) ? void 0 : computedY1,
                height: isNil(height) ? void 0 : 0
            }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        to: {
            y: computedY,
            y1: isNil(y1) ? void 0 : computedY,
            height: isNil(height) ? void 0 : 0
        }
    };
}

function growHeightOutOverall(element, options, animationParameters) {
    var _a;
    const y1 = element.getFinalAnimationAttribute("y1"), height = element.getFinalAnimationAttribute("height");
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        to: {
            y: overallValue,
            y1: isNil(y1) ? void 0 : overallValue,
            height: isNil(height) ? void 0 : 0
        }
    };
}

export const growHeightOut = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(element, options, animationParameters) : growHeightOutIndividual(element, options, animationParameters);
};
//# sourceMappingURL=grow-cartesian.js.map
