import type { IAnimate, IAnimationConfig, IAnimator, IParsedAnimationConfig } from '../../types/animate';
import type { IElement, IMark, MarkFunctionType } from '../../types';
import { Arranger } from './arranger';
export declare class Animate implements IAnimate {
    mark: IMark;
    state: MarkFunctionType<string> | null;
    configs: Array<IParsedAnimationConfig>;
    immediateConfigs: Array<IParsedAnimationConfig>;
    private isEnabled;
    private disabledStates;
    private animators;
    private elementRecorder;
    private timelineCount;
    constructor(mark: IMark, config: Record<string, IAnimationConfig | IAnimationConfig[]>);
    getAnimationConfigs(animationState: string): IParsedAnimationConfig[];
    updateConfig(config: Record<string, IAnimationConfig | IAnimationConfig[]>): void;
    updateState(state: MarkFunctionType<string> | null): void;
    animate(): this;
    runAnimationByState(animationState: string): Arranger;
    stopAnimationByState(animationState: string): this;
    pauseAnimationByState(animationState: string): this;
    resumeAnimationByState(animationState: string): this;
    run(config: IAnimationConfig | IAnimationConfig[]): Arranger;
    stop(): this;
    pause(): this;
    resume(): this;
    reverse(): this;
    restart(): this;
    record(): this;
    recordEnd(): this;
    isAnimating(): boolean;
    isElementAnimating(element: IElement): boolean;
    getAnimatorCount(): number;
    getAllAnimators(): IAnimator[];
    getElementAnimators(element: IElement | IElement[], animationState?: string): IAnimator[];
    enable(): this;
    disable(): this;
    enableAnimationState(state: string | string[]): this;
    disableAnimationState(state: string | string[]): this;
    release(): void;
    private animateByTimeline;
    private animateElement;
    private getAnimationState;
    private getAnimationUnit;
    private clearElementAnimation;
    private clearAllElements;
    private clearElement;
    private handleAnimatorEnd;
}
