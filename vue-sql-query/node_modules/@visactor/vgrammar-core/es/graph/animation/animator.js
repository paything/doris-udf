import { isNil, isValidNumber } from "@visactor/vutils";

import { ACustomAnimate, Animate, AnimateGroup, AnimateMode } from "@visactor/vrender-core";

import { AttributeAnimate, channelAnimationAttributes, CustomInterpolator, typeAnimationAttributes } from "./attribute";

Animate.mode |= AnimateMode.SET_ATTR_IMMEDIATELY;

let GlobalAnimatorId = 0;

const isCustomAnimateCtor = custom => {
    var _a;
    if (isNil(custom) || isNil(custom.prototype)) return !1;
    const prototype = null !== (_a = custom.prototype) && void 0 !== _a ? _a : {};
    return prototype instanceof ACustomAnimate || "onBind" in prototype && "onStart" in prototype && "onEnd" in prototype && "onUpdate" in prototype;
};

export class Animator {
    constructor(element, unit, animationOptions) {
        this.id = GlobalAnimatorId++, this.isAnimating = !1, this.runnings = [], this.element = element, 
        this.animationOptions = animationOptions, this.unit = unit;
    }
    callback(callbackFunction) {
        return this.callbackFunction = callbackFunction, this;
    }
    animate(animationParameters, parameters) {
        return this.isAnimating = !0, this.animateElement(animationParameters, parameters), 
        0 === this.runnings.length && this.animationEnd(), this;
    }
    stop(stopState = "end", invokeCallback = !0) {
        return this.runnings.forEach((running => running.stop(stopState))), this.animationEnd(invokeCallback), 
        this;
    }
    pause() {
        return this.runnings.forEach((running => running.pause())), this;
    }
    resume() {
        return this.runnings.forEach((running => running.resume())), this;
    }
    startAt(startTime) {
        return this.runnings.forEach((running => {
            const initialDelay = this.unit.initialDelay;
            running.startAt(initialDelay + startTime);
        })), this;
    }
    getTotalAnimationTime() {
        var _a;
        const timeLineDuration = this.unit.initialDelay + this.unit.loopDuration * this.unit.loopCount;
        return null !== (_a = this.unit.totalTime) && void 0 !== _a ? _a : timeLineDuration;
    }
    getEndAttributes() {
        return this.runnings.reduce(((attributes, running) => Object.assign(attributes, running.getEndProps())), {});
    }
    animationEnd(invokeCallback = !0) {
        var _a;
        this.isAnimating = !1, this.runnings = null, invokeCallback && (null === (_a = this.callbackFunction) || void 0 === _a || _a.call(null));
    }
    animateElement(animationParameters, parameters) {
        const graphicItem = this.element.getGraphicItem();
        if (!graphicItem) return;
        const graphicAnimate = graphicItem.animate();
        this.runnings.push(graphicAnimate), graphicAnimate.startAt(this.unit.initialDelay), 
        graphicAnimate.wait(this.unit.loopDelay), this.unit.timeSlices.forEach((timeSlice => {
            this.animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters);
        })), graphicAnimate.wait(this.unit.loopDelayAfter), graphicAnimate.loop(this.unit.loopCount - 1), 
        isValidNumber(this.unit.totalTime) && setTimeout((() => {
            graphicAnimate && graphicAnimate.stop("end");
        }), this.unit.totalTime), graphicAnimate.onEnd((() => {
            this.runnings = this.runnings.filter((running => running !== graphicAnimate)), 0 === this.runnings.length && this.animationEnd();
        }));
    }
    animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters) {
        const delay = timeSlice.delay, delayAfter = timeSlice.delayAfter, duration = timeSlice.duration, effects = timeSlice.effects;
        if (delay > 0 && graphicAnimate.wait(delay), effects.length < 0) graphicAnimate.wait(duration); else {
            const customAnimates = effects.map(((effect, index) => {
                var _a;
                const attributes = null !== (_a = effect.type ? typeAnimationAttributes(this.element, effect, animationParameters, parameters) : effect.channel ? channelAnimationAttributes(this.element, effect, animationParameters, parameters) : void 0) && void 0 !== _a ? _a : {}, customOption = attributes.custom || (null == effect ? void 0 : effect.custom), customParametersOption = (null == attributes ? void 0 : attributes.customParameters) || (null == effect ? void 0 : effect.customParameters);
                attributes.from && Object.keys(attributes.from).length && this.unit && this.animationOptions.timeline.controlOptions.immediatelyApply && "component" !== this.element.mark.markType && this.element.getGraphicItem().setAttributes(attributes.from);
                const isCustomAnimate = isCustomAnimateCtor(customOption);
                return !isNil(customOption) && !isCustomAnimateCtor(customOption) ? new CustomInterpolator(attributes.from, attributes.to, duration, effect.easing, {
                    interpolator: customOption,
                    element: this.element,
                    parameters: customParametersOption
                }) : isCustomAnimate ? new customOption(attributes.from, attributes.to, duration, effect.easing, customParametersOption) : attributes.to ? new AttributeAnimate(attributes.from, attributes.to, duration, effect.easing) : void 0;
            })).filter((animate => !isNil(animate)));
            1 === customAnimates.length ? graphicAnimate.play(customAnimates[0]) : customAnimates.length > 1 && graphicAnimate.play(new AnimateGroup(duration, customAnimates));
        }
        delayAfter > 0 && graphicAnimate.wait(delayAfter);
    }
}
//# sourceMappingURL=animator.js.map
