{"version":3,"sources":["../src/types/scale.ts"],"names":[],"mappings":"","file":"scale.js","sourcesContent":["import type { IBaseScale, ScaleType } from '@visactor/vscale';\nimport type { DistributiveOmit } from './base';\nimport type { GrammarSpec, IData } from './grammar';\nimport type { GenericFunctionType, SimpleSignalType } from './signal';\nimport type { IDimensionType } from '@visactor/vgrammar-coordinate';\n\nexport type ScaleFunctionCallback<T> = (scale: IBaseScale, parameters: any) => T;\n\nexport type ScaleFunctionType<T> = GenericFunctionType<ScaleFunctionCallback<T>, T>;\n\nexport type ScaleData = { data: string | IData; field: string | string[]; sort?: (datumA: any, datumB: any) => number };\nexport type MultiScaleData = {\n  datas: {\n    data: string | IData;\n    field: string | string[];\n  }[];\n  sort?: (datumA: any, datumB: any) => number;\n};\n\nexport type ScaleCoordinate = {\n  coordinate: string;\n  dimension: IDimensionType;\n  isSubshaft?: boolean;\n  reversed?: boolean;\n};\n\nexport type GrammarScaleType = ScaleType | 'utc';\n\nexport interface BaseScaleSpec extends GrammarSpec {\n  name?: string;\n  type: GrammarScaleType;\n  domain?: ScaleData | MultiScaleData | ScaleFunctionType<any[]>;\n  unknown?: ScaleFunctionType<any>;\n}\n\nexport interface ScaleTicksSpec {\n  nice?: ScaleFunctionType<boolean | number>;\n  niceMax?: ScaleFunctionType<boolean | number>;\n  niceMin?: ScaleFunctionType<boolean | number>;\n}\n\nexport interface ScaleDomainSpec {\n  min?: ScaleFunctionType<number>;\n  max?: ScaleFunctionType<number>;\n  zero?: ScaleFunctionType<boolean>;\n}\n/** Discrete Scale */\n\nexport interface DiscreteScaleSpec extends BaseScaleSpec {\n  range?: ScaleFunctionType<any[]> | ScaleData | MultiScaleData | ScaleCoordinate;\n}\n\nexport interface OrdinalScaleSpec extends DiscreteScaleSpec {\n  type: 'ordinal';\n}\n\nexport interface BaseBandScaleSpec extends DiscreteScaleSpec {\n  round?: ScaleFunctionType<boolean>;\n  padding?: ScaleFunctionType<number>;\n  paddingInner?: ScaleFunctionType<number>;\n  paddingOuter?: ScaleFunctionType<number>;\n  align?: ScaleFunctionType<number>;\n}\n\nexport interface BandScaleSpec extends BaseBandScaleSpec {\n  type: 'band';\n}\n\nexport interface PointScaleSpec extends BaseBandScaleSpec {\n  type: 'point';\n}\n\n/** Continuous Scale */\n\nexport interface ContinuousScaleSpec extends BaseScaleSpec, ScaleDomainSpec {\n  tickCount?: SimpleSignalType<number>;\n  range?: ScaleFunctionType<number[]> | ScaleData | MultiScaleData | ScaleCoordinate;\n  roundRange?: ScaleFunctionType<boolean>;\n  config?: {\n    clamp?: boolean | ((x: number) => any);\n    interpolate?: (t: number) => any;\n  };\n}\n\nexport interface LinearScaleSpec extends ContinuousScaleSpec, ScaleTicksSpec {\n  type: 'linear';\n}\n\nexport interface PowScaleSpec extends ContinuousScaleSpec, ScaleTicksSpec {\n  type: 'pow';\n  /**\n   * the exponent of the power\n   */\n  exponent?: ScaleFunctionType<number>;\n}\n\nexport interface LogScaleSpec extends ContinuousScaleSpec, Pick<ScaleTicksSpec, 'nice'> {\n  type: 'log';\n  /**\n   * the base of the log, e.g. 10,the number shoudl be greater than 0\n   */\n  base?: ScaleFunctionType<number>;\n}\n\nexport interface SqrtScaleSpec extends ContinuousScaleSpec, ScaleTicksSpec {\n  type: 'sqrt';\n}\n\nexport interface SymlogScaleSpec extends ContinuousScaleSpec, ScaleTicksSpec {\n  type: 'symlog';\n  constant?: ScaleFunctionType<number>;\n}\n\nexport interface TimeScaleSpec extends ContinuousScaleSpec, Pick<ScaleTicksSpec, 'nice'> {\n  type: 'time';\n}\n\nexport interface UtcTimeScaleSpec extends ContinuousScaleSpec, Pick<ScaleTicksSpec, 'nice'> {\n  type: 'utc';\n}\n\nexport interface QuantizeScaleSpec extends BaseScaleSpec, ScaleTicksSpec, ScaleDomainSpec {\n  type: 'quantize';\n  range?: ScaleFunctionType<any[]> | ScaleData | MultiScaleData;\n}\n\n/**\n * quantile scale adopts a different method to evaluate the thresholds,\n * by slicing the domain into intervals of (roughly) equal absolute frequency (i.e. number of individuals)\n */\nexport interface QuantileScaleSpec extends BaseScaleSpec {\n  type: 'quantile';\n  range?: ScaleFunctionType<any[]> | ScaleData | MultiScaleData;\n}\n\n/**\n * the threshold scale\n */\nexport interface ThresholdScaleSpec extends BaseScaleSpec {\n  type: 'threshold';\n  range?: ScaleFunctionType<any[]> | ScaleData | MultiScaleData;\n}\n\n/**\n * the threshold scale\n */\nexport interface IdentityScaleSpec extends BaseScaleSpec {\n  type: 'identity';\n  range?: ScaleFunctionType<any[]> | ScaleData | MultiScaleData;\n}\n\nexport type ScaleSpec =\n  | OrdinalScaleSpec\n  | BandScaleSpec\n  | PointScaleSpec\n  | LinearScaleSpec\n  | PowScaleSpec\n  | LogScaleSpec\n  | SqrtScaleSpec\n  | SymlogScaleSpec\n  | TimeScaleSpec\n  | UtcTimeScaleSpec\n  | QuantizeScaleSpec\n  | QuantileScaleSpec\n  | ThresholdScaleSpec\n  | IdentityScaleSpec;\n\nexport type ScaleConfigureSpec = DistributiveOmit<ScaleSpec, 'type'>;\n"]}