import type { IGraphic, ACustomAnimate, EasingType } from '@visactor/vrender-core';
import type { IPointLike } from '@visactor/vutils';
import type { MarkFunctionCallback, MarkFunctionType } from './mark';
import type { IMark } from './grammar';
import type { IElement } from './element';
import type { FunctionCallback } from './signal';
export type TypeAnimation<T extends IElement> = (element: T, options: any, animationParameters: IAnimationParameters) => {
    from?: {
        [channel: string]: any;
    };
    to?: {
        [channel: string]: any;
    };
};
export interface IClipAnimationOptions {
    clipDimension?: 'x' | 'y' | 'auto' | 'default';
}
export interface IGrowCartesianAnimationOptions {
    orient?: 'positive' | 'negative';
    overall?: boolean | number;
    direction?: 'x' | 'y' | 'xy';
}
export interface IGrowAngleAnimationOptions {
    orient?: 'clockwise' | 'anticlockwise';
    overall?: boolean | number;
}
export interface IGrowRadiusAnimationOptions {
    orient?: 'inside' | 'outside';
    overall?: boolean | number;
}
export interface IGrowPointsAnimationOptions {
    orient?: 'positive' | 'negative';
}
export interface IGrowPointsOverallAnimationOptions extends IGrowPointsAnimationOptions {
    center?: IPointLike;
}
export interface IScaleAnimationOptions {
    direction?: 'x' | 'y' | 'xy';
}
export interface IMoveAnimationOptions {
    direction?: 'x' | 'y' | 'xy';
    orient?: 'positive' | 'negative';
    offset?: number;
    point?: {
        x?: number;
        y?: number;
    } | FunctionCallback<{
        x?: number;
        y?: number;
    }>;
    excludeChannels?: string[];
}
export interface IRotateAnimationOptions {
    orient?: 'clockwise' | 'anticlockwise';
    angle?: number;
}
export interface TextItemAttributes {
    fontSize?: number;
    lineHeight?: number;
    font?: string;
    fontStyle?: string;
    fontVariant?: string;
    fontWeight?: string | number;
    lineBreak?: string;
    text?: string | string[];
    limit?: number;
    align?: string;
    baseline?: string;
    ellipsis?: string | boolean;
    dir?: string;
}
export type MarkFunctionValueType<T> = MarkFunctionCallback<T> | T;
export type IAnimationConfig = IAnimationTimeline | IAnimationTypeConfig;
export interface IStateAnimationConfig {
    duration?: number;
    easing?: EasingType;
}
export interface IAnimationTypeConfig {
    type?: string;
    channel?: IAnimationChannelAttrs | IAnimationChannelAttributes;
    custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;
    customParameters?: MarkFunctionValueType<any>;
    easing?: EasingType;
    delay?: MarkFunctionValueType<number>;
    delayAfter?: MarkFunctionValueType<number>;
    duration?: MarkFunctionValueType<number>;
    oneByOne?: MarkFunctionValueType<boolean | number>;
    startTime?: MarkFunctionValueType<number>;
    totalTime?: MarkFunctionValueType<number>;
    loop?: boolean | number;
    options?: MarkFunctionValueType<any>;
    controlOptions?: IAnimationControlOptions;
}
export interface IAnimationTimeline {
    id?: string;
    timeSlices: IAnimationTimeSlice | IAnimationTimeSlice[];
    startTime?: MarkFunctionValueType<number>;
    totalTime?: MarkFunctionValueType<number>;
    oneByOne?: MarkFunctionValueType<number | boolean>;
    loop?: MarkFunctionValueType<number | boolean>;
    partitioner?: MarkFunctionCallback<boolean>;
    sort?: (datumA: any, datumB: any, elementA: IElement, elementB: IElement, parameters: any) => number;
    controlOptions?: IAnimationControlOptions;
}
export interface IAnimationTimeSlice {
    effects: IAnimationEffect | IAnimationEffect[];
    duration?: MarkFunctionValueType<number>;
    delay?: MarkFunctionValueType<number>;
    delayAfter?: MarkFunctionValueType<number>;
}
export type IAnimationChannelFunction = (datum: any, element: IElement, parameters: IAnimationParameters) => any;
export type IAnimationChannelAttrs = Record<string, {
    from?: any | IAnimationChannelFunction;
    to?: any | IAnimationChannelFunction;
}>;
export type IAnimationChannelAttributes = string[];
export type IAnimationChannelInterpolator = (ratio: number, from: any, to: any, nextAttributes: any, datum: any, element: IElement, parameters: IAnimationParameters) => boolean | void;
export interface IAnimationCustomConstructor {
    new (from: any, to: any, duration: number, ease: EasingType, parameters?: any): ACustomAnimate<any>;
}
export interface IAnimationEffect {
    type?: string;
    channel?: IAnimationChannelAttrs | IAnimationChannelAttributes;
    custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;
    customParameters?: MarkFunctionValueType<any>;
    easing?: EasingType;
    options?: MarkFunctionValueType<any>;
}
export interface IAnimationControlOptions {
    stopWhenStateChange?: boolean;
    immediatelyApply?: boolean;
    ignoreLoopFinalAttributes?: boolean;
}
export interface IAnimationUnit {
    initialDelay: number;
    loopDuration: number;
    loopDelay: number;
    loopDelayAfter: number;
    loopAnimateDuration: number;
    loopCount: number;
    totalTime: number;
    timeSlices: IAnimationTimeSlice[];
}
export interface IAnimationRecord {
    start: IGraphic;
    end: IGraphic;
    changes: any[];
}
export interface IAnimationParameters {
    width: number;
    height: number;
    mark: IMark;
    group: IMark | null;
    elementIndex: number;
    elementCount: number;
    view: any;
}
export interface IParsedAnimationConfig {
    state: string;
    timeline: IAnimationTimeline;
    originConfig: IAnimationConfig;
    id: string;
}
export interface IParsedAnimationAttrs {
    from?: any;
    to?: any;
    custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;
    customParameters?: any;
}
export interface IAnimatorOptions {
    state: string;
    timeline: IAnimationTimeline;
    id: string;
}
export interface IAnimator {
    id: number;
    element: IElement;
    animationOptions: IAnimatorOptions;
    isAnimating: boolean;
    animate: (animationParameters: IAnimationParameters, parameters: any) => this;
    callback: (callbackFunction: (...args: any[]) => void) => this;
    stop: (stopState: 'start' | 'end' | null, invokeCallback?: boolean) => this;
    pause: () => this;
    resume: () => this;
    startAt: (startTime: number) => this;
    getTotalAnimationTime: () => number;
    getEndAttributes: () => Record<string, any>;
}
export interface IAnimateArranger {
    parallel: (arranger: IAnimateArranger) => this;
    after: (arranger: IAnimateArranger) => this;
    afterArranger: IAnimateArranger;
    parallelArrangers: IAnimateArranger[];
    animators: IAnimator[];
    totalTime: number;
    startTime: number;
    endTime: number;
    arrangeTime: () => void;
}
export interface IBaseAnimate {
    stop: () => this;
    pause: () => this;
    resume: () => this;
    animate: () => this;
    enable: () => this;
    disable: () => this;
    enableAnimationState: (state: string | string[]) => this;
    disableAnimationState: (state: string | string[]) => this;
    isAnimating: () => boolean;
    release: () => void;
}
export interface IViewAnimate extends IBaseAnimate {
    animateAddition: (mark: IMark) => this;
}
export interface IAnimate extends IBaseAnimate {
    mark: IMark;
    run: (config: IAnimationConfig | IAnimationConfig[]) => IAnimateArranger;
    runAnimationByState: (animationState: string) => IAnimateArranger;
    stopAnimationByState: (animationState: string) => this;
    pauseAnimationByState: (animationState: string) => this;
    resumeAnimationByState: (animationState: string) => this;
    reverse: () => this;
    restart: () => this;
    record: () => this;
    recordEnd: () => this;
    getAnimationConfigs: (animationState: string) => IParsedAnimationConfig[];
    updateConfig: (config: Record<string, IAnimationConfig | IAnimationConfig[]>) => void;
    updateState: (state: MarkFunctionType<string> | null) => void;
    isElementAnimating: (element: IElement) => boolean;
    getAnimatorCount: () => number;
    getElementAnimators: (element: IElement | IElement[], animationState?: string) => IAnimator[];
    release: () => void;
}
