{"version":3,"sources":["../src/types/component.ts"],"names":[],"mappings":"","file":"component.js","sourcesContent":["import type { IGraphicAttribute, IRichTextCharacter, ITextAttribute } from '@visactor/vrender-core';\nimport type {\n  AxisBaseAttributes,\n  BaseLabelAttrs,\n  DataLabelAttrs,\n  DataZoomAttributes,\n  Direction,\n  GridBaseAttributes,\n  LegendBaseAttributes,\n  OrientType,\n  PlayerAttributes,\n  ScrollBarAttributes,\n  SliderAttributes,\n  TitleAttrs\n} from '@visactor/vrender-components';\nimport type { AxisEnum, ComponentEnum } from '../graph';\nimport type { Nil } from './base';\nimport type { IComponent, IData, IGroupMark, IMark, IScale } from './grammar';\nimport type {\n  ChannelEncodeType,\n  ComponentSpec,\n  GenerateBasicEncoderSpec,\n  MarkFunctionType,\n  ScaleEncodeType\n} from './mark';\nimport type { IView } from './view';\nimport type { IBaseScale } from '@visactor/vscale';\nimport type { SimpleSignalType } from './signal';\n\n// scale component\n\nexport interface IScaleComponent extends IComponent {\n  scale: (scale?: IScale | string | Nil) => this;\n\n  // internal interface\n  getScale: () => IScale;\n}\n\nexport interface ScaleComponentSpec<\n  BasicEncoderSpec extends GenerateBasicEncoderSpec<IGraphicAttribute> = GenerateBasicEncoderSpec<IGraphicAttribute>\n> extends ComponentSpec<BasicEncoderSpec> {\n  scale?: IScale | string;\n}\n\n// axis component\n\nexport type AxisType = 'line' | 'circle';\n\nexport interface IAxis extends IScaleComponent {\n  axisType: (axisType: AxisType | Nil) => this;\n  tickCount: (tickCount: SimpleSignalType<number> | Nil) => this;\n  inside: (inside: MarkFunctionType<boolean> | Nil) => this;\n  baseValue: (baseValue: MarkFunctionType<number> | Nil) => this;\n\n  // internal interface\n  getAxisComponentType: () => keyof typeof AxisEnum;\n}\n\nexport interface AxisSpec extends ScaleComponentSpec<Partial<AxisBaseAttributes>> {\n  componentType: ComponentEnum.axis;\n  axisType?: AxisType;\n  tickCount?: SimpleSignalType<number>;\n  inside?: MarkFunctionType<boolean>;\n  baseValue?: MarkFunctionType<number>;\n}\n\n// grid component\n\nexport type GridShape = 'line' | 'circle' | 'polygon';\n\nexport interface IGrid extends IScaleComponent {\n  gridType: (gridType: AxisType | Nil) => this;\n  gridShape: (gridShape: GridShape | Nil) => this;\n  target: (axis: IAxis | string | Nil) => this;\n  tickCount: (tickCount: SimpleSignalType<number> | Nil) => this;\n  inside: (inside: MarkFunctionType<boolean> | Nil) => this;\n  baseValue: (baseValue: MarkFunctionType<number> | Nil) => this;\n}\n\nexport interface GridSpec extends ScaleComponentSpec<Partial<GridBaseAttributes>> {\n  componentType: ComponentEnum.grid;\n  gridType?: AxisType;\n  gridShape?: GridShape;\n  target?: IAxis | string;\n  tickCount?: MarkFunctionType<number>;\n  inside?: MarkFunctionType<boolean>;\n  baseValue?: MarkFunctionType<number>;\n}\n\n// legend component\n\nexport type LegendType = 'auto' | 'discrete' | 'color' | 'size';\n\nexport interface ILegend extends IScaleComponent {\n  legendType: (legendType: LegendType | Nil) => this;\n\n  // immediate functions\n  setSelected: (selectedValues: any[]) => this;\n\n  // internal interface\n  isContinuousLegend: () => boolean;\n}\n\nexport interface LegendSpec extends ScaleComponentSpec<LegendBaseAttributes> {\n  componentType: ComponentEnum.legend;\n  legendType?: LegendType;\n  shapeScale?: IScale | string;\n}\n\n// slider component\n\nexport type SliderFilterValue = { start: number; end: number };\n\nexport interface ISlider extends IComponent {\n  min: (min: MarkFunctionType<number> | Nil) => this;\n  max: (max: MarkFunctionType<number> | Nil) => this;\n\n  // immediate functions\n  setStartEndValue: (start?: number, end?: number) => this;\n}\n\nexport interface SliderSpec extends ComponentSpec<Partial<SliderAttributes>> {\n  componentType: ComponentEnum.slider;\n  min?: MarkFunctionType<number>;\n  max?: MarkFunctionType<number>;\n}\n\n// datazoom component\n\nexport type DatazoomFilterValue = { start: number; end: number; startRatio: number; endRatio: number };\n\nexport interface IDatazoom extends IComponent {\n  preview: (\n    data: IData | string | Nil,\n    x: ScaleEncodeType | Nil,\n    y: ScaleEncodeType | Nil,\n    x1?: ChannelEncodeType | Nil,\n    y1?: ChannelEncodeType | Nil\n  ) => this;\n\n  // immediate functions\n  setStartEndValue: (start?: number, end?: number) => this;\n  getStartEndValue: () => { start: number; end: number } | Nil;\n\n  // internal interface\n  invertDatazoomRatio: (ratio: number) => any;\n  getDatazoomMainScale: () => IBaseScale;\n}\n\nexport type DataZoomEncoderSpec = GenerateBasicEncoderSpec<Partial<DataZoomAttributes> & { x1?: number; y1?: number }>;\nexport interface DatazoomSpec extends ComponentSpec<DataZoomEncoderSpec> {\n  componentType: ComponentEnum.datazoom;\n  preview?: {\n    data: IData | string;\n    x?: ScaleEncodeType;\n    y?: ScaleEncodeType;\n    x1?: ChannelEncodeType;\n    y1?: ChannelEncodeType;\n  };\n}\n\n// label component\n\nexport interface ILabel extends IComponent {\n  labelStyle: (attributes: MarkFunctionType<Partial<BaseLabelAttrs>>) => this;\n  size: (attributes: MarkFunctionType<DataLabelAttrs['size']>) => this;\n  target: (mark: IMark | IMark[] | string | string[] | Nil) => this;\n}\n\nexport type LabelEncoderSpec = GenerateBasicEncoderSpec<Partial<BaseLabelAttrs> & { text?: ITextAttribute['text'] }>;\nexport interface LabelSpec extends ComponentSpec<LabelEncoderSpec> {\n  componentType: ComponentEnum.label;\n  labelStyle?: MarkFunctionType<Partial<BaseLabelAttrs>>;\n  size?: MarkFunctionType<DataLabelAttrs['size']>;\n  target?: IMark | IMark[] | string | string[];\n}\n\n// player component\n\nexport type PlayerType = 'auto' | 'discrete' | 'continuous';\n\nexport type PlayerFilterValue = { index: number; value: any };\n\nexport interface IPlayer extends IComponent {\n  playerType: (playerType: PlayerType) => this;\n  source: (source: IData | string | any[] | Nil) => this;\n\n  // immediate functions\n  play: () => this;\n  pause: () => this;\n  backward: () => this;\n  forward: () => this;\n}\n\nexport interface PlayerSpec extends ComponentSpec<Partial<PlayerAttributes>> {\n  componentType: ComponentEnum.player;\n  playerType?: PlayerType;\n  source?: IData | string | any[];\n}\n\n// title component\n\nexport interface ITitle extends IComponent {\n  title: (text: MarkFunctionType<string | number | number[] | string[] | IRichTextCharacter[]> | Nil) => this;\n  subTitle: (text: MarkFunctionType<string | number | number[] | string[] | IRichTextCharacter[]> | Nil) => this;\n}\n\nexport interface TitleSpec extends ComponentSpec<Partial<TitleAttrs>> {\n  componentType: ComponentEnum.title;\n  title?: MarkFunctionType<string | number | number[] | string[] | IRichTextCharacter[]>;\n  subTitle?: MarkFunctionType<string | number | number[] | string[] | IRichTextCharacter[]>;\n}\n\n// scrollbar component\n\nexport type ScrollbarFilterValue = { start?: number; end?: number; startRatio: number; endRatio: number };\n\nexport interface IScrollbar extends IScaleComponent {\n  container: (container: IGroupMark | string | Nil) => this;\n  direction: (direction: MarkFunctionType<Direction> | Nil) => this;\n  position: (position: MarkFunctionType<OrientType> | Nil) => this;\n\n  // immediate functions\n  setScrollStart: (start: number) => this;\n  getScrollRange: () => [number, number] | Nil;\n}\n\nexport interface ScrollbarSpec extends ScaleComponentSpec<Partial<ScrollBarAttributes>> {\n  componentType: ComponentEnum.scrollbar;\n  container?: IGroupMark | string;\n  direction?: MarkFunctionType<Direction>;\n  position?: MarkFunctionType<OrientType>;\n}\n\n// built-in components\n\nexport type BuiltInComponentSpec =\n  | AxisSpec\n  | LegendSpec\n  | SliderSpec\n  | DatazoomSpec\n  | LabelSpec\n  | PlayerSpec\n  | TitleSpec\n  | ScrollbarSpec;\n\nexport interface IComponentConstructor {\n  readonly componentType: string;\n\n  new (view: IView, group?: IGroupMark, mode?: '2d' | '3d'): IComponent;\n}\n"]}