{"version":3,"sources":["../src/types/projection.ts"],"names":[],"mappings":"","file":"projection.js","sourcesContent":["import type { GrammarSpec, IGrammarBase } from './grammar';\nimport type { GenericFunctionType } from './signal';\nimport type { Nil } from './base';\n\nexport type GeoJsonFeatureSpec = any; // TODO\nexport type GeoJsonFeatureCollectionSpec = any; // TODO\nexport type FitSpec = GeoJsonFeatureSpec | GeoJsonFeatureCollectionSpec | GeoJsonFeatureSpec[];\nexport type ProjectionType =\n  | 'albers'\n  | 'albersUsa'\n  | 'azimuthalEqualArea'\n  | 'azimuthalEquidistant'\n  | 'conicConformal'\n  | 'conicEqualArea'\n  | 'conicEquidistant'\n  | 'equalEarth'\n  | 'equirectangular'\n  | 'gnomonic'\n  | 'identity'\n  | 'mercator'\n  | 'naturalEarth1'\n  | 'orthographic'\n  | 'stereographic'\n  | 'transverseMercator';\n\nexport interface BaseProjectionSpec extends GrammarSpec {\n  type: string;\n  pointRadius?: ProjectionFunctionType<number>;\n  extent?: ProjectionFunctionType<[[number, number], [number, number]]>;\n  fit?: ProjectionFunctionType<\n    FeatureCollectionData | FeatureCollectionData[] | FeatureData | FeatureData[] | GeometryData | GeometryData[]\n  >;\n  size?: ProjectionFunctionType<[number, number]>;\n\n  // standard properties in d3-geo\n\n  clipAngle?: ProjectionFunctionType<number>;\n  clipExtent?: ProjectionFunctionType<[number, number]>;\n  scale?: ProjectionFunctionType<number>;\n  translate?: ProjectionFunctionType<[number, number]>;\n  center?: ProjectionFunctionType<[number, number]>;\n  rotate?: ProjectionFunctionType<[number, number] | [number, number, number]>;\n  parallels?: ProjectionFunctionType<[number, number]>;\n  precision?: ProjectionFunctionType<number>;\n  reflectX?: ProjectionFunctionType<boolean>;\n  reflectY?: ProjectionFunctionType<number>;\n\n  // extended properties in d3-geo-projections\n\n  coefficient?: ProjectionFunctionType<number>;\n  distance?: ProjectionFunctionType<number>;\n  fraction?: ProjectionFunctionType<number>;\n  lobes?: ProjectionFunctionType<number>;\n  parallel?: ProjectionFunctionType<number>;\n  radius?: ProjectionFunctionType<number>;\n  ratio?: ProjectionFunctionType<number>;\n  spacing?: ProjectionFunctionType<number>;\n  tilt?: ProjectionFunctionType<number>;\n}\nexport interface ProjectionSpec extends BaseProjectionSpec {\n  /*\n   * The name of the projection.\n   */\n  name?: string;\n}\n\nexport interface IProjection extends IGrammarBase {\n  grammarType: 'projection';\n  parse: (spec: ProjectionSpec) => this;\n  pointRadius: (spec: ProjectionSpec['pointRadius']) => this;\n  size: (spec: ProjectionSpec['size']) => this;\n  fit: (spec: ProjectionSpec['fit']) => this;\n  extent: (spec: ProjectionSpec['extent']) => this;\n  configure: (spec: Omit<ProjectionSpec, 'fit' | 'extent' | 'size' | 'pointRadius'> | Nil) => this;\n}\n\nexport interface GeometryData {\n  type: 'Point' | 'MultiPoint' | 'LineString' | 'MultiLineString' | 'Polygon' | 'MultiPolygon' | 'GeometryCollection';\n  coordinates?: [number, number] | [number, number][] | [number, number][][] | [number, number][][][];\n  arcs?: number[][];\n}\n\nexport interface FeatureData {\n  type: 'Feature';\n  geometry: GeometryData;\n  properties?: Record<string, any>;\n}\n\nexport interface FeatureCollectionData {\n  type: 'FeatureCollection';\n  features: FeatureData[];\n}\n\nexport type ProjectionFunctionCallback<T> = (projection: any, parameters: any) => T;\n\nexport type ProjectionFunctionType<T> = GenericFunctionType<ProjectionFunctionCallback<T>, T>;\n"]}