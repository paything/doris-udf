{"version":3,"sources":["../src/types/plot.ts"],"names":[],"mappings":"","file":"plot.js","sourcesContent":["import type {\n  AxisBaseAttributes,\n  BaseCrosshairAttrs,\n  BaseLabelAttrs,\n  ColorLegendAttributes,\n  DataZoomAttributes,\n  DiscreteLegendAttrs,\n  GridBaseAttributes,\n  PlayerAttributes,\n  SizeLegendAttributes,\n  SliderAttributes,\n  TitleAttrs\n} from '@visactor/vrender-components';\nimport type { CoordinateType } from '@visactor/vgrammar-coordinate';\nimport type { IColor } from '@visactor/vrender-core';\nimport type { IEnvironmentOptions, IRendererOptions, IRunningConfig, ViewSpec, srIOption3DType, IView } from './view';\nimport type { CommonPaddingSpec, ValueOf } from './base';\nimport type { BasicEncoderSpecMap, LinkPathEncoderSpec, MarkRelativeItemSpec } from './mark';\nimport type { BaseEventHandler } from './event';\nimport type { TransformSpec } from './transform';\nimport type { IAnimationConfig } from './animate';\nimport type { ScaleSpec } from './scale';\nimport type { DataSpec } from './data';\nimport type { GridShape } from './component';\n\nexport interface IPlotOptions extends IEnvironmentOptions, IRendererOptions {\n  width?: number;\n  height?: number;\n  padding?: CommonPaddingSpec;\n  autoFit?: boolean;\n  options3d?: srIOption3DType;\n  theme?: string;\n  logLevel?: number;\n}\n\nexport interface CartesianCoordinateOption {\n  id?: string;\n  type: 'cartesian';\n  transpose?: boolean;\n}\n\nexport interface PolarCoordinateOption {\n  id?: string;\n  type: 'polar';\n  origin?: [string | number, string | number];\n  transpose?: boolean;\n}\n\nexport type PlotIntervalEncoderSpec = Omit<BasicEncoderSpecMap['interval'], 'y'> & {\n  y?: number | number[];\n  y1?: number;\n  x1?: number;\n};\n\nexport type PlotRectEncoderSpec = Omit<BasicEncoderSpecMap['rect'], 'y' | 'x'> & {\n  y?: number | number[];\n  x?: number | number[];\n  y1?: number;\n  x1?: number;\n};\n\nexport type PlotRectXEncoderSpec = Omit<BasicEncoderSpecMap['rect'], 'x'> & {\n  x?: number | number[];\n  y1?: number;\n  x1?: number;\n};\n\nexport type PlotRectYEncoderSpec = Omit<BasicEncoderSpecMap['rect'], 'y'> & {\n  y?: number | number[];\n  y1?: number;\n  x1?: number;\n};\n\nexport type PlotAreaEncoderSpec = Omit<BasicEncoderSpecMap['area'], 'x' | 'y'> & {\n  x?: number | number[];\n  y?: number | number[];\n};\n\nexport type PlotRuleEncoderSpec = Omit<BasicEncoderSpecMap['rule'], 'x' | 'y'> & {\n  x?: number | number[];\n  y?: number | number[];\n};\n\nexport type PlotImageEncoderSpec = Omit<BasicEncoderSpecMap['image'], 'x' | 'y'> & {\n  x?: number | number[];\n  y?: number | number[];\n};\nexport type PlotPolygonEncoderSpec = Omit<BasicEncoderSpecMap['polygon'], 'x' | 'y'> & {\n  x?: number[];\n  y?: number[];\n};\n\nexport type PlotSankeyEncoderSpec = Partial<LinkPathEncoderSpec>;\nexport type PlotSunburstEncodeSpec = BasicEncoderSpecMap['arc'];\nexport type PlotTreeEncodeSpec = BasicEncoderSpecMap['symbol'];\nexport type PlotTreemapEncodeSpec = BasicEncoderSpecMap['rect'];\nexport type PlotCirclePackingEncodeSpec = BasicEncoderSpecMap['circle'];\nexport type PlotWordcloudEncodeSpec = BasicEncoderSpecMap['text'];\nexport type PlotWordcloudShapeEncodeSpec = BasicEncoderSpecMap['text'];\n\nexport type CoordinateOption = CartesianCoordinateOption | PolarCoordinateOption;\nexport type PlotIntervalSpec = Partial<ISemanticMarkSpec<PlotIntervalEncoderSpec, IntervalEncodeChannels>> & {\n  type: 'interval';\n};\nexport type PlotLineSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['line'], LineEncodeChannels>> & {\n  type: 'line';\n};\nexport type PlotCellSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['cell'], CellEncodeChannels>> & {\n  type: 'cell';\n};\nexport type PlotRuleXSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['rule'], RuleXEncodeChannels>> & {\n  type: 'ruleX';\n};\nexport type PlotRuleYSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['rule'], RuleYEncodeChannels>> & {\n  type: 'ruleY';\n};\nexport type PlotAreaSpec = Partial<ISemanticMarkSpec<PlotAreaEncoderSpec, AreaEncodeChannels>> & {\n  type: 'area';\n};\nexport type PlotSymbolSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['symbol'], SymbolEncodeChannels>> & {\n  type: 'symbol';\n};\nexport type PlotTextSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['text'], TextEncodeChannels>> & {\n  type: 'text';\n};\nexport type PlotRectSpec = Partial<ISemanticMarkSpec<PlotRectEncoderSpec, RectEncodeChannels>> & {\n  type: 'rect';\n};\nexport type PlotRectXSpec = Partial<ISemanticMarkSpec<PlotRectXEncoderSpec, RectXEncodeChannels>> & {\n  type: 'rectX';\n};\nexport type PlotRectYSpec = Partial<ISemanticMarkSpec<PlotRectYEncoderSpec, RectYEncodeChannels>> & {\n  type: 'rectY';\n};\nexport type PlotPolygonSpec = Partial<ISemanticMarkSpec<PlotPolygonEncoderSpec, PolygonEncodeChannels>> & {\n  type: 'polygon';\n};\nexport type PlotRuleSpec = Partial<ISemanticMarkSpec<PlotRuleEncoderSpec, RuleEncodeChannels>> & {\n  type: 'rule';\n};\nexport type PlotImageSpec = Partial<ISemanticMarkSpec<PlotImageEncoderSpec, ImageEncodeChannels>> & {\n  type: 'image';\n};\nexport type PlotPathSpec = Partial<ISemanticMarkSpec<BasicEncoderSpecMap['path'], PathEncodeChannels>> & {\n  type: 'path';\n};\n\nexport interface PlotSpec {\n  background?: IColor;\n  width?: number;\n  height?: number;\n  padding?: number;\n  coordinate?: CoordinateOption;\n  marks?: Array<\n    | PlotIntervalSpec\n    | PlotLineSpec\n    | PlotCellSpec\n    | PlotRuleXSpec\n    | PlotRuleYSpec\n    | PlotAreaSpec\n    | PlotSymbolSpec\n    | PlotTextSpec\n    | PlotRectSpec\n    | PlotRectXSpec\n    | PlotRectYSpec\n    | PlotPolygonSpec\n    | PlotRuleSpec\n    | PlotImageSpec\n    | PlotPathSpec\n  >;\n}\n\nexport interface IPlot {\n  readonly view: IView;\n\n  theme: (theme: string) => this;\n  /**\n   * todo: 直接接text图元还是title组件\n   */\n  // title: (text: ITextAttribute['text'], style: Omit<ITextAttribute, 'text'>) => this;\n  coordinate: (type: CoordinateType, option?: Omit<CoordinateOption, 'type'>) => this;\n  // interaction: (type: string, options: boolean | any) => this;\n\n  // facet: (type: string, options: any) => this;\n\n  ///--------- life cycle ---------///\n\n  run: (runningConfig?: IRunningConfig) => this;\n  release: () => this;\n  parseSpec: (spec: PlotSpec) => this;\n  updateSpec: (spec: PlotSpec) => this;\n  getImageBuffer: () => Buffer;\n\n  ///--------- events api ---------///\n  on: (type: string, handler: BaseEventHandler) => this;\n  off: (type: string, handler?: BaseEventHandler) => this;\n\n  ///--------- marks ---------///\n\n  interval: () => IInterval;\n  cell: () => ICell;\n  area: () => IArea;\n  image: () => IImage;\n  line: () => ILine;\n  ruleX: () => IRuleX;\n  ruleY: () => IRectY;\n  symbol: () => ISymbol;\n  polygon: () => IPolygon;\n  text: () => IText;\n  rect: () => IRect;\n  rectX: () => IRectX;\n  rectY: () => IRectY;\n  rule: () => IRule;\n\n  // wordcloud 包如果没注册，会存在问题\n  wordcloud: () => IWordcloud;\n  wordcloudShape: () => IWordcloudShape;\n  circlePacking: () => ICirclePacking;\n  treemap: () => ITreemap;\n  tree: () => ITree;\n  sunburst: () => ISunburst;\n  sankey: () => ISankey;\n\n  // P2\n  // forceGraph: () => ISemanticMark;\n  // geoPath: () => ISemanticMark;\n  // vector: () => ISemanticMark;\n  // shape: () => ISemanticMark;\n  // gauge: () => ISemanticMark;\n  // heatmap: () => ISemanticMark;\n  // density: () => ISemanticMark;\n  // boxplot: () => ISemanticMark;\n  // box: () => ISemanticMark;\n  // contour: () => ISemanticMark;\n\n  // observable auto define type by data\n  // auto: () => ISemanticMark;\n}\n\nexport interface IPlotConstructor {\n  new (options?: IPlotOptions): IPlot;\n}\n\nexport type WithDefaultEncode<T, K extends string> = {\n  [Key in K]?: Key extends keyof T ? ISemanticEncodeValue<T[Key]> : ISemanticEncodeValue<string | number>;\n};\nexport type ISemanticEncodeValue<T> = T extends any[]\n  ? string[] | ((datum: any) => any)[]\n  : string | ((datum: any) => T);\nexport type ISemanticEncodeSpec<T> = {\n  [Key in keyof T]?: ISemanticEncodeValue<T[Key]>;\n};\nexport type ISemanticStyle<T, K extends string> = Omit<T, K>;\n\nexport interface SemanticTooltipContentItem {\n  key?: ISemanticEncodeValue<string | number>;\n  value?: ISemanticEncodeValue<string | number>;\n  symbol?: ISemanticEncodeValue<string>;\n}\nexport type SemanticTooltipOption = {\n  disableGraphicTooltip?: boolean;\n  disableDimensionTooltip?: boolean;\n  staticTitle?: string;\n  staticContentKey?: string | string[];\n  title?: ISemanticEncodeValue<string | number>;\n  dimensionTooltipChannel?: 'x' | 'y';\n  content?: SemanticTooltipContentItem[];\n};\n\nexport interface SemanticAxisOption extends Partial<AxisBaseAttributes> {\n  tickCount?: number;\n}\n\nexport interface SemanticGridOption extends Partial<GridBaseAttributes> {\n  type?: GridShape;\n  tickCount?: number;\n  inside?: boolean;\n  baseValue?: number;\n  sides?: number;\n}\nexport type SemanticDataZoomOption = Partial<DataZoomAttributes>;\nexport type SemanticSliderOption = Partial<SliderAttributes>;\nexport type SemanticLegendOption = Partial<ColorLegendAttributes | DiscreteLegendAttrs | SizeLegendAttributes>;\nexport type SemanticCrosshairOption = Partial<BaseCrosshairAttrs>;\nexport type SemanticLabelOption = Partial<BaseLabelAttrs>;\nexport type SemanticPlayerOption = Partial<PlayerAttributes>;\nexport type SemanticTitleOption = Partial<TitleAttrs>;\n\nexport interface ISemanticMark<EncodeSpec, K extends string> {\n  readonly uid: number;\n  readonly type: string;\n  data: (values: any, transform?: TransformSpec[], id?: string) => this;\n  style: (style: Partial<EncodeSpec & any>) => this;\n  encode: (channel: K, option: ValueOf<WithDefaultEncode<EncodeSpec, K>, K>) => this;\n  scale: (channel: K, option: Partial<ScaleSpec>) => this;\n  transform: (option: TransformSpec[]) => this;\n  animate: (state: string, option: IAnimationConfig | IAnimationConfig[]) => this;\n  state: (state: string, option: Partial<EncodeSpec>) => this;\n\n  axis: (channel: string, option?: SemanticAxisOption | boolean, layout?: MarkRelativeItemSpec) => this;\n  legend: (channel: string, option?: SemanticLegendOption | boolean, layout?: MarkRelativeItemSpec) => this;\n  crosshair: (channel: string, option?: SemanticCrosshairOption | boolean) => this;\n  tooltip: (option: SemanticTooltipOption | boolean) => this;\n  coordinate: (option: CoordinateOption) => this;\n  grid: (channel: string, option?: SemanticGridOption | boolean) => this;\n  title: (option: SemanticTitleOption, layout?: MarkRelativeItemSpec) => this;\n\n  slider: (channel: string, option?: SemanticSliderOption | boolean, layout?: MarkRelativeItemSpec) => this;\n  datazoom: (channel: string, option?: SemanticDataZoomOption | boolean, layout?: MarkRelativeItemSpec) => this;\n  label: (channel: string, option?: SemanticLabelOption | boolean) => this;\n  player: (data?: any[], option?: SemanticPlayerOption | boolean, layout?: MarkRelativeItemSpec) => this;\n\n  toViewSpec: () => ViewSpec;\n  parseSpec: (spec: Partial<ISemanticMarkSpec<EncodeSpec, K>>) => this;\n}\n\nexport interface ISemanticMarkSpec<EncodeSpec, K extends string> {\n  id: string | number;\n  data?: DataSpec;\n  encode?: WithDefaultEncode<EncodeSpec, K>;\n  scale?: Partial<Record<K, ScaleSpec>>;\n  style?: Partial<EncodeSpec & any>;\n  axis?: Partial<\n    Record<K, { option?: SemanticAxisOption | boolean; layout?: MarkRelativeItemSpec } | SemanticAxisOption | boolean>\n  >;\n  grid?: Partial<Record<K, SemanticGridOption | boolean>>;\n  transform?: TransformSpec[];\n  state?: Record<string, Partial<EncodeSpec>>;\n  animation?: Record<string, IAnimationConfig | IAnimationConfig[]>;\n  legend?: Record<\n    string,\n    { option: SemanticLegendOption | boolean; layout?: MarkRelativeItemSpec } | SemanticLegendOption | boolean\n  >;\n  crosshair?: Record<string, SemanticCrosshairOption | boolean>;\n  tooltip?: SemanticTooltipOption | boolean;\n  slider?: Record<\n    string,\n    { option: SemanticSliderOption | boolean; layout?: MarkRelativeItemSpec } | SemanticSliderOption | boolean\n  >;\n  datazoom?: Record<\n    string,\n    { option: SemanticDataZoomOption | boolean; layout?: MarkRelativeItemSpec } | SemanticDataZoomOption | boolean\n  >;\n  label?: Record<string, SemanticLabelOption | boolean>;\n  player?: { data?: any[]; option?: SemanticPlayerOption | boolean; layout?: MarkRelativeItemSpec };\n  title?: { option?: SemanticTitleOption; layout?: MarkRelativeItemSpec } | SemanticTitleOption;\n}\n\nexport type ParsedSimpleEncode<T, K extends string> = {\n  [Key in K]?: {\n    field: Key extends keyof T ? ISemanticEncodeValue<T[Key]> : ISemanticEncodeValue<string>;\n    scale: string;\n  };\n};\n\nexport type SemanticEncodeChannels = 'x' | 'y' | 'group' | 'color';\nexport type IntervalEncodeChannels = 'x' | 'y' | 'group' | 'color' | 'stroke';\nexport type CellEncodeChannels = 'x' | 'y' | 'group' | 'color' | 'stroke';\nexport type LineEncodeChannels = 'x' | 'y' | 'group' | 'color';\nexport type AreaEncodeChannels = 'x' | 'y' | 'group' | 'color' | 'stroke';\nexport type RuleXEncodeChannels = 'x' | 'x' | 'color' | 'group';\nexport type RuleYEncodeChannels = 'x' | 'y' | 'color' | 'group';\nexport type SymbolEncodeChannels = 'x' | 'y' | 'color' | 'group' | 'size' | 'shape' | 'stroke';\nexport type TextEncodeChannels = 'x' | 'y' | 'color' | 'group' | 'text' | 'stroke';\nexport type RectEncodeChannels = 'x' | 'y' | 'color' | 'group' | 'stroke';\nexport type RectXEncodeChannels = 'x' | 'color' | 'group' | 'stroke';\nexport type RectYEncodeChannels = 'y' | 'color' | 'group' | 'stroke';\nexport type PolygonEncodeChannels = 'x' | 'y' | 'color' | 'group' | 'stroke';\nexport type RuleEncodeChannels = 'x' | 'y' | 'color' | 'group';\nexport type ImageEncodeChannels = 'x' | 'y' | 'color' | 'group' | 'src' | 'stroke';\nexport type PathEncodeChannels = 'color' | 'stroke';\nexport type SankeyEncodeChannels = 'node' | 'value' | 'color' | 'stroke';\nexport type SunburstEncodeChannels = 'node' | 'value' | 'color' | 'stroke';\nexport type TreeEncodeChannels = 'node' | 'value' | 'color' | 'stroke';\nexport type TreemapEncodeChannels = 'node' | 'value' | 'color' | 'stroke';\nexport type CirclepackingEncodeChannels = 'node' | 'value' | 'color' | 'stroke';\nexport type WordcloudEncodeChannels = 'text' | 'color' | 'stroke';\nexport type WordcloudShapeEncodeChannels = 'text' | 'color' | 'stroke';\n\nexport type IInterval = ISemanticMark<PlotIntervalEncoderSpec, IntervalEncodeChannels>;\nexport type ILine = ISemanticMark<BasicEncoderSpecMap['line'], LineEncodeChannels>;\nexport type ICell = ISemanticMark<BasicEncoderSpecMap['cell'], CellEncodeChannels>;\nexport type IRuleX = ISemanticMark<BasicEncoderSpecMap['rule'], RuleXEncodeChannels>;\nexport type IRuleY = ISemanticMark<BasicEncoderSpecMap['rule'], RuleYEncodeChannels>;\nexport type IArea = ISemanticMark<PlotAreaEncoderSpec, AreaEncodeChannels>;\nexport type ISymbol = ISemanticMark<BasicEncoderSpecMap['symbol'], SymbolEncodeChannels>;\nexport type IText = ISemanticMark<BasicEncoderSpecMap['text'], TextEncodeChannels>;\nexport type IRect = ISemanticMark<PlotRectEncoderSpec, RectEncodeChannels>;\nexport type IRectX = ISemanticMark<BasicEncoderSpecMap['rect'], RectXEncodeChannels>;\nexport type IRectY = ISemanticMark<BasicEncoderSpecMap['rect'], RectYEncodeChannels>;\nexport type IPolygon = ISemanticMark<PlotPolygonEncoderSpec, PolygonEncodeChannels>;\nexport type IRule = ISemanticMark<BasicEncoderSpecMap['rule'], RuleEncodeChannels>;\nexport type IImage = ISemanticMark<PlotImageEncoderSpec, ImageEncodeChannels>;\nexport type IPath = ISemanticMark<BasicEncoderSpecMap['path'], PathEncodeChannels>;\nexport type ISankey = ISemanticMark<PlotSankeyEncoderSpec, SankeyEncodeChannels>;\nexport type ISunburst = ISemanticMark<PlotSunburstEncodeSpec, SunburstEncodeChannels>;\nexport type IWordcloud = ISemanticMark<PlotWordcloudEncodeSpec, WordcloudEncodeChannels>;\nexport type IWordcloudShape = ISemanticMark<PlotWordcloudShapeEncodeSpec, WordcloudShapeEncodeChannels>;\nexport type ITree = ISemanticMark<PlotTreeEncodeSpec, TreeEncodeChannels>;\nexport type ITreemap = ISemanticMark<PlotTreemapEncodeSpec, TreemapEncodeChannels>;\nexport type ICirclePacking = ISemanticMark<PlotCirclePackingEncodeSpec, CirclepackingEncodeChannels>;\n\nexport type PlotMark =\n  | IInterval\n  | IRuleX\n  | IRuleY\n  | ICell\n  | ILine\n  | IArea\n  | ISymbol\n  | IText\n  | IRect\n  | IRectX\n  | IRectY\n  | IPolygon\n  | IRule\n  | IImage\n  | IPath\n  | ISankey\n  | ISunburst\n  | ICirclePacking\n  | ITreemap\n  | ITree\n  | IWordcloud\n  | IWordcloudShape;\n\nexport interface IPlotMarkConstructor {\n  readonly type: string;\n\n  new (id?: string): PlotMark;\n}\n"]}