{"version":3,"sources":["../src/types/animate.ts"],"names":[],"mappings":"","file":"animate.js","sourcesContent":["import type { IGraphic, ACustomAnimate, EasingType } from '@visactor/vrender-core';\nimport type { IPointLike } from '@visactor/vutils';\nimport type { MarkFunctionCallback, MarkFunctionType } from './mark';\nimport type { IMark } from './grammar';\nimport type { IElement } from './element';\nimport type { FunctionCallback } from './signal';\n\nexport type TypeAnimation<T extends IElement> = (\n  element: T,\n  options: any,\n  animationParameters: IAnimationParameters\n) => { from?: { [channel: string]: any }; to?: { [channel: string]: any } };\n\nexport interface IClipAnimationOptions {\n  clipDimension?: 'x' | 'y' | 'auto' | 'default';\n}\n\nexport interface IGrowCartesianAnimationOptions {\n  orient?: 'positive' | 'negative';\n  overall?: boolean | number;\n  direction?: 'x' | 'y' | 'xy';\n}\n\nexport interface IGrowAngleAnimationOptions {\n  orient?: 'clockwise' | 'anticlockwise';\n  overall?: boolean | number;\n}\n\nexport interface IGrowRadiusAnimationOptions {\n  orient?: 'inside' | 'outside';\n  overall?: boolean | number;\n}\n\nexport interface IGrowPointsAnimationOptions {\n  orient?: 'positive' | 'negative';\n}\n\nexport interface IGrowPointsOverallAnimationOptions extends IGrowPointsAnimationOptions {\n  center?: IPointLike;\n}\n\nexport interface IScaleAnimationOptions {\n  direction?: 'x' | 'y' | 'xy';\n}\n\nexport interface IMoveAnimationOptions {\n  direction?: 'x' | 'y' | 'xy';\n  orient?: 'positive' | 'negative';\n  offset?: number;\n  point?: { x?: number; y?: number } | FunctionCallback<{ x?: number; y?: number }>;\n  excludeChannels?: string[];\n}\n\nexport interface IRotateAnimationOptions {\n  orient?: 'clockwise' | 'anticlockwise';\n  angle?: number;\n}\n\n/** VGrammar 层提供的图元text上的图形属性，现在暂时会和VRender不一致 */\nexport interface TextItemAttributes {\n  fontSize?: number;\n  lineHeight?: number;\n  font?: string;\n  fontStyle?: string;\n  fontVariant?: string;\n  fontWeight?: string | number;\n  lineBreak?: string;\n  text?: string | string[];\n  limit?: number;\n  align?: string;\n  baseline?: string;\n  ellipsis?: string | boolean;\n  dir?: string;\n}\n\n/** animation */\nexport type MarkFunctionValueType<T> = MarkFunctionCallback<T> | T;\n\nexport type IAnimationConfig = IAnimationTimeline | IAnimationTypeConfig;\n\n/**\n * state动画，暂时只支持简单配置\n */\nexport interface IStateAnimationConfig {\n  /**\n   * 状态动画的动画时长\n   */\n  duration?: number;\n  /**\n   * 状态动画的缓动函数类型\n   */\n  easing?: EasingType;\n}\n\n/**\n * 动画 config 简化配置\n */\nexport interface IAnimationTypeConfig {\n  type?: string;\n  channel?: IAnimationChannelAttrs | IAnimationChannelAttributes;\n  custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;\n  customParameters?: MarkFunctionValueType<any>;\n  easing?: EasingType;\n  delay?: MarkFunctionValueType<number>;\n  delayAfter?: MarkFunctionValueType<number>;\n  duration?: MarkFunctionValueType<number>;\n  oneByOne?: MarkFunctionValueType<boolean | number>;\n  startTime?: MarkFunctionValueType<number>;\n  totalTime?: MarkFunctionValueType<number>;\n  /** loop: true 无限循环; loop: 正整数，表示循环的次数 */\n  loop?: boolean | number;\n  /** 动画 effect 配置项 */\n  options?: MarkFunctionValueType<any>;\n  /** 动画执行相关控制配置项 */\n  controlOptions?: IAnimationControlOptions;\n}\n\n/**\n * 动画 timeline 完整配置，一条时间线内的动画单元只能串行\n * 多个timeline是可以并行的\n * 考虑到同一图元不能在多个timeline上，所以timeline不应该提供数组配置的能力\n */\nexport interface IAnimationTimeline {\n  /** 为了方便动画编排，用户可以设置 id 用于识别时间线 */\n  id?: string;\n  /** 时间切片 */\n  timeSlices: IAnimationTimeSlice | IAnimationTimeSlice[];\n  /** 动画开始的相对时间，可以为负数 */\n  startTime?: MarkFunctionValueType<number>;\n  /** 动画时长 */\n  totalTime?: MarkFunctionValueType<number>;\n  /** 动画依次执行的延迟 */\n  oneByOne?: MarkFunctionValueType<number | boolean>;\n  /** loop: true 无限循环; loop: 正整数，表示循环的次数 */\n  loop?: MarkFunctionValueType<number | boolean>;\n  /** 对图元元素进行划分，和过滤类似，但是不同时间线不能同时作用在相同的元素上 */\n  partitioner?: MarkFunctionCallback<boolean>;\n  /** 对同一时间线上的元素进行排序 */\n  sort?: (datumA: any, datumB: any, elementA: IElement, elementB: IElement, parameters: any) => number;\n  /** 动画执行相关控制配置项 */\n  controlOptions?: IAnimationControlOptions;\n}\n\nexport interface IAnimationTimeSlice {\n  effects: IAnimationEffect | IAnimationEffect[];\n  duration?: MarkFunctionValueType<number>;\n  delay?: MarkFunctionValueType<number>;\n  delayAfter?: MarkFunctionValueType<number>;\n}\n\nexport type IAnimationChannelFunction = (datum: any, element: IElement, parameters: IAnimationParameters) => any;\nexport type IAnimationChannelAttrs = Record<\n  string,\n  {\n    from?: any | IAnimationChannelFunction;\n    to?: any | IAnimationChannelFunction;\n  }\n>;\nexport type IAnimationChannelAttributes = string[];\nexport type IAnimationChannelInterpolator = (\n  ratio: number,\n  from: any,\n  to: any,\n  nextAttributes: any,\n  datum: any,\n  element: IElement,\n  parameters: IAnimationParameters\n) => boolean | void;\n\n// TODO: fix ACustomAnimate<any>\nexport interface IAnimationCustomConstructor {\n  new (from: any, to: any, duration: number, ease: EasingType, parameters?: any): ACustomAnimate<any>;\n}\n\nexport interface IAnimationEffect {\n  type?: string;\n  channel?: IAnimationChannelAttrs | IAnimationChannelAttributes;\n  custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;\n  customParameters?: MarkFunctionValueType<any>;\n  easing?: EasingType;\n  /** options暂时没有处理 */\n  options?: MarkFunctionValueType<any>;\n}\n\nexport interface IAnimationControlOptions {\n  /** 当动画状态变更时清空动画 */\n  stopWhenStateChange?: boolean;\n  /** 是否立即应用动画初始状态 */\n  immediatelyApply?: boolean;\n  /** encode 计算图元最终状态时是否忽略循环动画 */\n  ignoreLoopFinalAttributes?: boolean;\n}\n\n/**\n * Animation timeline should be parsed into animation units,\n * which record all necessary configs for animator to execute animation.\n *\n * animation unit time:\n * |<--initialDelay-->| |<--loopDelay--><--Slices--><--looDelayAfter-->| |<--loopDuration-->|\n *                      |<-----------------loopDuration--------------->|\n */\nexport interface IAnimationUnit {\n  /**\n   * initial delay time before any animation loop\n   */\n  initialDelay: number;\n  /**\n   * total time for one animation loop\n   */\n  loopDuration: number;\n  /**\n   * delay time before time slices\n   */\n  loopDelay: number;\n  /**\n   * delay time after time slices\n   */\n  loopDelayAfter: number;\n  /**\n   * animating time in one animation loop\n   */\n  loopAnimateDuration: number;\n  loopCount: number;\n  totalTime: number;\n  timeSlices: IAnimationTimeSlice[];\n}\n\nexport interface IAnimationRecord {\n  start: IGraphic;\n  end: IGraphic;\n  changes: any[];\n}\n\nexport interface IAnimationParameters {\n  width: number;\n  height: number;\n  mark: IMark;\n  group: IMark | null;\n  elementIndex: number;\n  elementCount: number;\n  view: any;\n}\n\nexport interface IParsedAnimationConfig {\n  state: string;\n  timeline: IAnimationTimeline;\n  originConfig: IAnimationConfig;\n  id: string;\n}\n\nexport interface IParsedAnimationAttrs {\n  from?: any;\n  to?: any;\n  custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;\n  customParameters?: any;\n}\n\n// animate structure\n\nexport interface IAnimatorOptions {\n  state: string;\n  timeline: IAnimationTimeline;\n  id: string;\n}\n\nexport interface IAnimator {\n  id: number;\n  element: IElement;\n  animationOptions: IAnimatorOptions;\n  isAnimating: boolean;\n\n  /** execute animation */\n  animate: (animationParameters: IAnimationParameters, parameters: any) => this;\n  /** set animation callback */\n  callback: (callbackFunction: (...args: any[]) => void) => this;\n\n  // animation control\n  stop: (stopState: 'start' | 'end' | null, invokeCallback?: boolean) => this;\n  pause: () => this;\n  resume: () => this;\n\n  /** set additional initial animation delay */\n  startAt: (startTime: number) => this;\n  /** get total animation execution time */\n  getTotalAnimationTime: () => number;\n\n  getEndAttributes: () => Record<string, any>;\n}\n\nexport interface IAnimateArranger {\n  // animation control api\n  parallel: (arranger: IAnimateArranger) => this;\n  after: (arranger: IAnimateArranger) => this;\n\n  // internal properties\n  afterArranger: IAnimateArranger;\n  parallelArrangers: IAnimateArranger[];\n  animators: IAnimator[];\n  totalTime: number;\n  startTime: number;\n  endTime: number;\n  arrangeTime: () => void;\n}\n\nexport interface IBaseAnimate {\n  // animation control\n  stop: () => this;\n  pause: () => this;\n  resume: () => this;\n\n  // internal animation process api\n  animate: () => this;\n  enable: () => this;\n  disable: () => this;\n  enableAnimationState: (state: string | string[]) => this;\n  disableAnimationState: (state: string | string[]) => this;\n  isAnimating: () => boolean;\n\n  release: () => void;\n}\n\nexport interface IViewAnimate extends IBaseAnimate {\n  animateAddition: (mark: IMark) => this;\n}\n\nexport interface IAnimate extends IBaseAnimate {\n  mark: IMark;\n\n  // additional animation control\n  run: (config: IAnimationConfig | IAnimationConfig[]) => IAnimateArranger;\n  runAnimationByState: (animationState: string) => IAnimateArranger;\n  stopAnimationByState: (animationState: string) => this;\n  pauseAnimationByState: (animationState: string) => this;\n  resumeAnimationByState: (animationState: string) => this;\n  reverse: () => this;\n  restart: () => this;\n  record: () => this;\n  recordEnd: () => this;\n\n  // internal animation process api\n  getAnimationConfigs: (animationState: string) => IParsedAnimationConfig[];\n  updateConfig: (config: Record<string, IAnimationConfig | IAnimationConfig[]>) => void;\n  updateState: (state: MarkFunctionType<string> | null) => void;\n  isElementAnimating: (element: IElement) => boolean;\n  getAnimatorCount: () => number;\n  getElementAnimators: (element: IElement | IElement[], animationState?: string) => IAnimator[];\n  release: () => void;\n}\n"]}