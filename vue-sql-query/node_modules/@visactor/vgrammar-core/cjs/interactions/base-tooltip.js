"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTooltip = exports.generateTooltipAttributes = void 0;

const vrender_components_1 = require("@visactor/vrender-components"), vutils_1 = require("@visactor/vutils"), vgrammar_util_1 = require("@visactor/vgrammar-util"), base_1 = require("./base"), mark_1 = require("../parse/mark"), util_1 = require("../parse/util"), generateTooltipAttributes = (point, title, content, bounds, theme, addition) => {
    var _a;
    const tooltipTheme = null === (_a = null == theme ? void 0 : theme.components) || void 0 === _a ? void 0 : _a.tooltip;
    return (0, vutils_1.merge)({}, tooltipTheme, {
        visible: !0,
        pointerX: point.x,
        pointerY: point.y,
        title: title,
        content: content,
        parentBounds: bounds
    }, null != addition ? addition : {});
};

exports.generateTooltipAttributes = generateTooltipAttributes;

class BaseTooltip extends base_1.BaseInteraction {
    constructor(view, options) {
        super(view, options), this._marks = view.getMarksBySelector(options.selector);
    }
    bind() {
        super.bind();
        const stage = this.view.renderer.stage();
        !this._tooltipComponent && stage && (this._tooltipComponent = new vrender_components_1.Tooltip({}), 
        stage.defaultLayer.appendChild(this._tooltipComponent));
    }
    unbind() {
        super.unbind();
        const stage = this.view.renderer.stage();
        this._tooltipComponent && stage && (stage.defaultLayer.removeChild(this._tooltipComponent), 
        this._tooltipComponent.release(), this._tooltipComponent = null);
    }
    _computeTooltipRow(row, datum) {
        let key, value, symbol, visible = (0, util_1.invokeFunctionType)(row.visible, this.parameters(), datum);
        if (visible = !!(0, vutils_1.isNil)(visible) || !!visible, (0, mark_1.isFieldEncode)(row.key)) {
            key = (0, vgrammar_util_1.field)(row.key.field)(datum);
        } else key = (0, util_1.invokeFunctionType)(row.key, this.parameters(), datum);
        if (key = (0, vutils_1.isNil)(key) ? void 0 : (0, vutils_1.isObjectLike)(key) ? key : {
            text: key
        }, (0, mark_1.isFieldEncode)(row.value)) {
            value = (0, vgrammar_util_1.field)(row.value.field)(datum);
        } else value = (0, util_1.invokeFunctionType)(row.value, this.parameters(), datum);
        if (value = (0, vutils_1.isNil)(value) ? void 0 : (0, vutils_1.isObjectLike)(value) ? value : {
            text: value
        }, (0, mark_1.isFieldEncode)(row.symbol)) {
            symbol = (0, vgrammar_util_1.field)(row.symbol.field)(datum);
        } else symbol = (0, util_1.invokeFunctionType)(row.symbol, this.parameters(), datum);
        return symbol = (0, vutils_1.isNil)(symbol) ? void 0 : (0, vutils_1.isObjectLike)(symbol) ? symbol : {
            symbolType: symbol
        }, {
            visible: visible,
            key: key,
            value: value,
            shape: symbol
        };
    }
    _computeTitleContent(datum) {
        const title = (0, vutils_1.isValid)(this.options.title) ? (0, vutils_1.isFunction)(this.options.title) ? this.options.title.call(null, datum, null, {}) : this._computeTooltipRow((0, 
        vutils_1.isString)(this.options.title) ? {
            value: this.options.title
        } : this.options.title, datum) : void 0, content = (0, vutils_1.isValid)(this.options.content) ? (0, 
        vutils_1.isFunction)(this.options.content) ? (0, vutils_1.array)(this.options.content.call(null, datum, null, {})) : (0, 
        vutils_1.array)(datum).reduce(((content, datumRow) => content.concat((0, vutils_1.array)(this.options.content).map((row => this._computeTooltipRow(row, datumRow))))), []) : void 0;
        return {
            title: (0, vutils_1.isArray)(title) ? title[0] : title,
            content: content
        };
    }
}

exports.BaseTooltip = BaseTooltip;
//# sourceMappingURL=base-tooltip.js.map