"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseInteraction = void 0;

const vutils_1 = require("@visactor/vutils");

class BaseInteraction {
    constructor(view, options) {
        this.references = new Map, this.view = view, this.depend(null == options ? void 0 : options.dependency);
    }
    getStartState() {
        return null;
    }
    depend(grammar) {
        this.references.clear(), (0, vutils_1.array)(grammar).map((grammar => (0, vutils_1.isString)(grammar) ? this.view.getGrammarById(grammar) : grammar)).filter((ref => !(0, 
        vutils_1.isNil)(ref))).forEach((ref => {
            var _a;
            this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + 1);
        }));
    }
    parameters() {
        const params = {};
        return this.references.forEach(((count, ref) => {
            (0, vutils_1.isValid)(ref.id()) && (params[ref.id()] = ref.output());
        })), params;
    }
    bind() {
        const events = this.getEvents();
        (null != events ? events : []).forEach((evt => {
            evt.type && evt.handler && ((0, vutils_1.isArray)(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.view.addEventListener(evtType, evt.handler);
            })) : "none" !== evt.type && this.view.addEventListener(evt.type, evt.handler));
        }));
    }
    unbind() {
        const events = this.getEvents();
        (null != events ? events : []).forEach((evt => {
            evt.type && evt.handler && ((0, vutils_1.isArray)(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.view.removeEventListener(evtType, evt.handler);
            })) : "none" !== evt.type && this.view.removeEventListener(evt.type, evt.handler));
        }));
    }
    start(element) {}
    reset(element) {}
    dispatchEvent(type, params) {
        this.view.emit(`${this.type}:${type}`, params), "start" === type && this.options.onStart ? this.options.onStart(params) : "reset" === type && this.options.onReset ? this.options.onReset(params) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params) : "end" === type && this.options.onEnd && this.options.onEnd(params);
    }
}

exports.BaseInteraction = BaseInteraction;
//# sourceMappingURL=base.js.map