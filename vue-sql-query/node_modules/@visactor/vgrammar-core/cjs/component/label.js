"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerLabel = exports.Label = exports.generateLabelAttributes = void 0;

const vutils_1 = require("@visactor/vutils"), vrender_components_1 = require("@visactor/vrender-components"), enums_1 = require("../graph/enums"), component_1 = require("../view/component"), encode_1 = require("../graph/mark/encode"), util_1 = require("../parse/util"), factory_1 = require("../core/factory"), generateLabelAttributes = (marks, groupSize, encoder, labelStyle, parameters, theme = {}) => {
    var _a;
    const labelTheme = null === (_a = theme.components) || void 0 === _a ? void 0 : _a.dataLabel, dataLabels = marks.map(((mark, index) => {
        var _a, _b, _c, _d, _e;
        const labelParameters = Object.assign(Object.assign({}, parameters), {
            labelIndex: index
        }), addition = null !== (_a = (0, util_1.invokeFunctionType)(labelStyle, labelParameters, mark)) && void 0 !== _a ? _a : {}, {components: components = {}} = theme;
        let currentTheme = {};
        switch (mark.markType) {
          case enums_1.GrammarMarkType.line:
          case enums_1.GrammarMarkType.area:
            currentTheme = "line" === addition.type ? components.lineLabel : "area" === addition.type ? components.areaLabel : components.lineDataLabel;
            break;

          case enums_1.GrammarMarkType.rect:
          case enums_1.GrammarMarkType.rect3d:
          case enums_1.GrammarMarkType.interval:
            currentTheme = components.rectLabel;
            break;

          case enums_1.GrammarMarkType.symbol:
          case enums_1.GrammarMarkType.circle:
          case enums_1.GrammarMarkType.cell:
            currentTheme = components.symbolLabel;
            break;

          case enums_1.GrammarMarkType.arc:
          case enums_1.GrammarMarkType.arc3d:
            currentTheme = components.arcLabel;
            break;

          case enums_1.GrammarMarkType.polygon:
          case enums_1.GrammarMarkType.path:
          default:
            currentTheme = components.pointLabel;
        }
        const data = null !== (_b = addition.data) && void 0 !== _b ? _b : [], themeDatum = null !== (_d = null === (_c = null == currentTheme ? void 0 : currentTheme.data) || void 0 === _c ? void 0 : _c[0]) && void 0 !== _d ? _d : {};
        if (data && data.length > 0) data.forEach(((d, index) => {
            if (mark.elements[index]) {
                const attributes = (0, encode_1.invokeEncoder)(encoder, d, mark.elements[index], labelParameters);
                (0, vutils_1.merge)(d, themeDatum, attributes);
            }
        })); else {
            const mergeAttributes = (attributes, themeDatum) => {
                const {data: labelData} = attributes, restAttribute = __rest(attributes, [ "data" ]);
                return Object.assign(Object.assign({}, (0, vutils_1.merge)({}, themeDatum, restAttribute)), {
                    data: labelData
                });
            };
            mark.elements.forEach((element => {
                if ("willRelease" !== element.getGraphicItem().releaseStatus) if (mark.isCollectionMark()) {
                    element.getDatum().forEach((entry => {
                        const attributes = (0, encode_1.invokeEncoder)(encoder, entry, element, labelParameters);
                        data.push(mergeAttributes(attributes, themeDatum));
                    }));
                } else {
                    const attributes = (0, encode_1.invokeEncoder)(encoder, element.getDatum(), element, labelParameters);
                    data.push(mergeAttributes(attributes, themeDatum));
                }
            }));
        }
        const graphicItemName = null === (_e = mark.graphicItem) || void 0 === _e ? void 0 : _e.name, result = (0, 
        vutils_1.merge)({}, currentTheme, {
            baseMarkGroupName: graphicItemName,
            getBaseMarks: () => mark.elements.map((element => element.getGraphicItem()))
        }, null != addition ? addition : {});
        return result.data = null != data ? data : currentTheme.data, result;
    })).filter((label => !(0, vutils_1.isNil)(label))), result = (0, vutils_1.merge)({}, labelTheme, {
        size: groupSize
    });
    return result.dataLabels = dataLabels, result;
};

exports.generateLabelAttributes = generateLabelAttributes;

class Label extends component_1.Component {
    constructor(view, group) {
        super(view, enums_1.ComponentEnum.label, group), this.spec.componentType = enums_1.ComponentEnum.label;
    }
    parseAddition(spec) {
        return super.parseAddition(spec), this.labelStyle(spec.labelStyle), this.size(spec.size), 
        this.target(spec.target), this;
    }
    labelStyle(style) {
        return this.setFunctionSpec(style, "labelStyle");
    }
    size(size) {
        return this.setFunctionSpec(size, "size");
    }
    target(mark) {
        if (this.spec.target) {
            const prevMarks = (0, vutils_1.array)(this.spec.target).map((m => (0, vutils_1.isString)(m) ? this.view.getMarkById(m) : m));
            this.detach(prevMarks);
        }
        if (this.spec.target = mark, mark) {
            const nextMarks = (0, vutils_1.array)(mark).map((m => (0, vutils_1.isString)(m) ? this.view.getMarkById(m) : m));
            this.attach(nextMarks);
        }
        return this.commit(), this;
    }
    _updateComponentEncoders() {
        const encoders = Object.assign({
            update: {}
        }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce(((res, state) => {
            const encoder = encoders[state];
            return encoder && (res[state] = {
                callback: (datum, element, parameters) => {
                    var _a, _b, _c, _d;
                    const marks = (0, vutils_1.array)(this.spec.target).map((m => (0, vutils_1.isString)(m) ? this.view.getMarkById(m) : m)), groupGraphicItem = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.getGroupGraphicItem) || void 0 === _b ? void 0 : _b.call(_a);
                    let size = (0, util_1.invokeFunctionType)(this.spec.size, parameters);
                    size || (size = groupGraphicItem ? {
                        width: null !== (_c = groupGraphicItem.attribute.width) && void 0 !== _c ? _c : groupGraphicItem.AABBBounds.width(),
                        height: null !== (_d = groupGraphicItem.attribute.height) && void 0 !== _d ? _d : groupGraphicItem.AABBBounds.height()
                    } : {
                        width: 1 / 0,
                        height: 1 / 0
                    });
                    const theme = this.spec.skipTheme ? null : this.view.getCurrentTheme();
                    return (0, exports.generateLabelAttributes)(marks, size, encoder, this.spec.labelStyle, parameters, theme);
                }
            }), res;
        }), {});
        this._encoders = componentEncoders;
    }
}

exports.Label = Label, Label.componentType = enums_1.ComponentEnum.label;

const registerLabel = () => {
    factory_1.Factory.registerGraphicComponent(enums_1.ComponentEnum.label, (attrs => new vrender_components_1.DataLabel(attrs))), 
    factory_1.Factory.registerComponent(enums_1.ComponentEnum.label, Label);
};

exports.registerLabel = registerLabel;
//# sourceMappingURL=label.js.map