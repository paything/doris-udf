{"version":3,"sources":["../src/semantic-marks/cell.ts"],"names":[],"mappings":"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","file":"cell.js","sourcesContent":["import type { IBaseScale } from '@visactor/vscale';\nimport { GrammarMarkType } from '../graph/enums';\nimport { invokeEncoder } from '../graph/mark/encode';\nimport { isScaleEncode } from '../parse/mark';\nimport { getGrammarOutput, isFunctionType } from '../parse/util';\nimport type {\n  StateEncodeSpec,\n  MarkSpec,\n  IElement,\n  MarkFunctionType,\n  AttributeTransform,\n  GetSingleEncodeSpecByType,\n  BaseSingleEncodeSpec\n} from '../types';\nimport { Mark } from '../view/mark';\nimport { isArray, isNil, isNumber } from '@visactor/vutils';\nimport { transformsByType } from '../graph/attributes/transform';\nimport { getBandWidthOfScale } from '../util/scale';\nimport { Factory } from '../core/factory';\n\nexport class Cell extends Mark {\n  static markType = GrammarMarkType.cell;\n  declare markType: GrammarMarkType.cell;\n  protected declare spec: MarkSpec;\n\n  protected _encoders: StateEncodeSpec | null;\n\n  encodeState(state: string, channel: string | BaseSingleEncodeSpec, value?: MarkFunctionType<any>) {\n    super.encodeState(state, channel, value);\n\n    this._updateComponentEncoders(state);\n\n    return this;\n  }\n\n  protected _updateComponentEncoders(state: string) {\n    if (!this._encoders) {\n      this._encoders = {};\n    }\n\n    const userEncoder = this.spec.encode[state] as GetSingleEncodeSpecByType<'cell'>;\n\n    if (userEncoder && state === 'update') {\n      const params = this.parameters();\n      const scales: Record<string, IBaseScale> = isFunctionType(userEncoder)\n        ? null\n        : Object.keys(userEncoder).reduce((res, channel) => {\n            if (isScaleEncode(userEncoder[channel])) {\n              res[channel] = getGrammarOutput(userEncoder[channel].scale, params);\n            }\n            return res;\n          }, {});\n\n      this._encoders[state] = {\n        callback: (datum: any, element: IElement, parameters: any) => {\n          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);\n\n          if (isNil(userEncodeRes.size)) {\n            const sizeX = scales.x ? getBandWidthOfScale(scales.x) : undefined;\n            const sizeY = scales.y ? getBandWidthOfScale(scales.y) : undefined;\n\n            if (isNil(sizeX) && isNil(sizeY)) {\n              userEncodeRes.size = 10;\n            } else if (isNil(sizeX)) {\n              userEncodeRes.size = sizeY;\n            } else if (isNil(sizeY)) {\n              userEncodeRes.size = sizeX;\n            }\n\n            userEncodeRes.size = [sizeX, sizeY];\n          }\n\n          if (isNil(userEncodeRes.shape)) {\n            userEncodeRes.shape = 'rect';\n          }\n\n          return userEncodeRes;\n        }\n      } as GetSingleEncodeSpecByType<'cell'>;\n    } else {\n      this._encoders[state] = userEncoder;\n    }\n  }\n\n  protected _getEncoders() {\n    return this._encoders ?? {};\n  }\n\n  getAttributeTransforms() {\n    return (\n      [\n        {\n          channels: ['size', 'padding'],\n          transform: (graphicAttributes: any, nextAttrs: any, storedAttrs: any) => {\n            if (isNumber(storedAttrs.padding) && storedAttrs.padding > 0) {\n              graphicAttributes.size = isArray(storedAttrs.size)\n                ? storedAttrs.size.map((entry: number) => Math.max(entry - storedAttrs.padding, 1))\n                : Math.max(storedAttrs.size - storedAttrs.padding, 1);\n            } else if (isArray(storedAttrs.padding) && storedAttrs.padding.length === 2) {\n              const arraySize = isArray(storedAttrs.size) ? storedAttrs.size : [storedAttrs.size, storedAttrs.size];\n\n              graphicAttributes.size = [\n                Math.max(arraySize[0] - storedAttrs.padding[0], 1),\n                Math.max(arraySize[1] - storedAttrs.padding[1], 1)\n              ];\n            } else {\n              graphicAttributes.size = storedAttrs.size;\n            }\n          },\n          storedAttrs: 'paddingAttrs'\n        }\n      ] as AttributeTransform[]\n    ).concat(transformsByType.symbol);\n  }\n\n  release(): void {\n    super.release();\n    this._encoders = null;\n  }\n}\n\nexport const registerCellMark = () => {\n  Factory.registerMark(GrammarMarkType.cell, Cell);\n};\n"]}