{"version":3,"sources":["../src/semantic-marks/interval.ts"],"names":[],"mappings":"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","file":"interval.js","sourcesContent":["import type { IBandLikeScale, IBaseScale } from '@visactor/vscale';\n// eslint-disable-next-line no-duplicate-imports\nimport { ScaleEnum } from '@visactor/vscale';\nimport { GrammarMarkType } from '../graph/enums';\nimport { invokeEncoder } from '../graph/mark/encode';\nimport { isScaleEncode } from '../parse/mark';\nimport { getGrammarOutput, isFunctionType } from '../parse/util';\nimport type {\n  StateEncodeSpec,\n  MarkSpec,\n  IElement,\n  MarkFunctionType,\n  AttributeTransform,\n  GetSingleEncodeSpecByType,\n  BaseSingleEncodeSpec\n} from '../types';\nimport { Mark } from '../view/mark';\nimport { isNil, maxInArray, minInArray } from '@visactor/vutils';\nimport { createGraphicItem } from '../graph/util/graphic';\nimport type { IPolarCoordinate } from '@visactor/vgrammar-coordinate';\nimport { transformsByType } from '../graph/attributes/transform';\nimport { Factory } from '../core/factory';\n\nexport class Interval extends Mark {\n  static markType = GrammarMarkType.interval;\n  declare markType: GrammarMarkType.interval;\n  protected declare spec: MarkSpec;\n\n  protected _encoders: StateEncodeSpec;\n\n  encodeState(state: string, channel: string | BaseSingleEncodeSpec, value?: MarkFunctionType<any>) {\n    super.encodeState(state, channel, value);\n\n    this._updateComponentEncoders(state);\n\n    return this;\n  }\n\n  protected _updateComponentEncoders(state: string) {\n    if (!this._encoders) {\n      this._encoders = {};\n    }\n\n    const userEncoder = this.spec.encode[state] as GetSingleEncodeSpecByType<'interval'>;\n\n    if (userEncoder && state === 'update') {\n      const params = this.parameters();\n      const scales: Record<string, IBaseScale> = isFunctionType(userEncoder)\n        ? null\n        : Object.keys(userEncoder).reduce((res, channel) => {\n            if (isScaleEncode(userEncoder[channel])) {\n              res[channel] = getGrammarOutput(userEncoder[channel].scale, params);\n            }\n            return res;\n          }, {});\n\n      this._encoders[state] = {\n        callback: (datum: any, element: IElement, parameters: any) => {\n          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);\n\n          this.disableCoordinateTransform = false;\n          if (scales && scales.x && scales.x.type === ScaleEnum.Band) {\n            if (!isNil(scales.y)) {\n              const domain = scales.y.domain();\n              const min = minInArray<number>(domain);\n              const max = maxInArray<number>(domain);\n              const baseValue = min > 0 ? min : max < 0 ? max : 0;\n\n              userEncodeRes.y1 = scales.y.scale(baseValue);\n            }\n            const bandWidth = (scales.x as IBandLikeScale).bandwidth();\n\n            // TODO: handle bandWidth dynamically\n            userEncodeRes.x = userEncodeRes.x + bandWidth / 4;\n            userEncodeRes.x1 = userEncodeRes.x + bandWidth / 2;\n          } else if (scales && scales.y && scales.y.type === ScaleEnum.Band) {\n            if (!isNil(scales.x)) {\n              const domain = scales.x.domain();\n              const min = minInArray(domain);\n              const max = maxInArray(domain);\n              const baseValue = min > 0 ? min : max < 0 ? max : 0;\n\n              userEncodeRes.x1 = scales.x.scale(baseValue);\n            }\n            const bandWidth = (scales.y as IBandLikeScale).bandwidth();\n\n            userEncodeRes.y = userEncodeRes.y + bandWidth / 4;\n            userEncodeRes.y1 = userEncodeRes.y + bandWidth / 2;\n          }\n\n          if (scales) {\n            const scaleGrammar =\n              this.view.getScaleById((userEncoder as any).x?.scale) ??\n              this.view.getScaleById((userEncoder as any).y?.scale);\n            const coord = scaleGrammar.getCoordinate();\n\n            if (coord && coord.type === 'polar') {\n              this.disableCoordinateTransform = true;\n              const origin = (coord as IPolarCoordinate).origin();\n              userEncodeRes.cx = origin.x;\n              userEncodeRes.cy = origin.y;\n            }\n          }\n\n          return userEncodeRes;\n        }\n      } as GetSingleEncodeSpecByType<'interval'>;\n    } else {\n      this._encoders[state] = userEncoder;\n    }\n  }\n\n  protected _getEncoders() {\n    return this._encoders ?? {};\n  }\n\n  getAttributeTransforms() {\n    if (this.coord && this.coord.output().type === 'polar') {\n      return [\n        {\n          channels: ['x', 'y', 'x1', 'y1', 'cx', 'cy'],\n          transform: (graphicAttributes: any, nextAttrs: any, storedAttrs: any) => {\n            graphicAttributes.x = storedAttrs.cx;\n            graphicAttributes.y = storedAttrs.cy;\n            if (this.coord.output().isTransposed()) {\n              graphicAttributes.startAngle = storedAttrs.y;\n              graphicAttributes.endAngle = storedAttrs.y1;\n              graphicAttributes.innerRadius = storedAttrs.x;\n              graphicAttributes.outerRadius = storedAttrs.x1;\n            } else {\n              //\n              graphicAttributes.startAngle = storedAttrs.x;\n              graphicAttributes.endAngle = storedAttrs.x1;\n              graphicAttributes.innerRadius = storedAttrs.y;\n              graphicAttributes.outerRadius = storedAttrs.y1;\n            }\n          },\n          storedAttrs: 'sizeAttrs'\n        }\n      ] as AttributeTransform[];\n    }\n\n    return transformsByType.rect;\n  }\n\n  addGraphicItem(attrs: any, groupKey?: string) {\n    const graphicItem = createGraphicItem(\n      this,\n      this.coord && this.coord.output().type === 'polar' ? GrammarMarkType.arc : GrammarMarkType.rect,\n      attrs\n    );\n\n    return super.addGraphicItem(attrs, groupKey, graphicItem);\n  }\n\n  release(): void {\n    super.release();\n    this._encoders = null;\n  }\n}\n\nexport const registerIntervalMark = () => {\n  Factory.registerMark(GrammarMarkType.interval, Interval);\n};\n"]}