"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Data = void 0;

const vutils_1 = require("@visactor/vutils"), grammar_base_1 = require("./grammar-base"), util_1 = require("../parse/util"), transform_1 = require("../parse/transform"), enums_1 = require("../graph/enums"), data_1 = require("../util/data");

class Data extends grammar_base_1.GrammarBase {
    constructor(view, values, format) {
        super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, 
        this._loadTasks = [], this._postFilters = [], this.ingest = options => {
            const format = (0, util_1.invokeParameterFunctionType)(options.format, this.parameters());
            return this._input = (0, data_1.parseFormat)(options.values, format), this._input;
        }, this.load = options => {
            if (options.values) return this.ingest(options);
        }, this.relay = options => options[0], this._loadTasks = [], (0, vutils_1.isNil)(values) || this.values(values, format);
    }
    parse(spec) {
        return super.parse(spec), this._isLoaded = !1, this.source(spec.source, spec.format, !1), 
        this.url(spec.url, spec.format, !1), this.values(spec.values, spec.format, !1), 
        this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
    }
    parseDataSource(spec) {
        const refs = [], transforms = [], formatRef = spec.format ? (0, util_1.parseFunctionType)(spec.format, this.view)[0] : null;
        if (formatRef && refs.push(formatRef), spec.values) {
            const valuesRef = (0, util_1.parseFunctionType)(spec.values, this.view)[0];
            valuesRef && refs.push(valuesRef), transforms.push({
                type: "ingest",
                transform: this.ingest,
                isRawOptions: !0,
                options: {
                    values: spec.values,
                    format: spec.format
                }
            });
        } else if (spec.url) {
            const urlRef = (0, util_1.parseFunctionType)(spec.url, this.view)[0];
            urlRef && refs.push(urlRef), transforms.push({
                type: "load",
                transform: this.load,
                options: {
                    url: null != urlRef ? urlRef : spec.url,
                    format: null != formatRef ? formatRef : spec.format
                }
            });
        } else if (spec.source) {
            const upstreamData = [];
            (0, vutils_1.array)(spec.source).forEach((sourceId => {
                const sourceData = (0, util_1.isGrammar)(sourceId) ? sourceId : this.view.getDataById(sourceId);
                sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
            })), upstreamData.length && (transforms.push({
                type: "relay",
                transform: this.relay,
                options: upstreamData
            }), this.grammarSource = upstreamData[0]);
        }
        return {
            transforms: transforms,
            refs: refs
        };
    }
    evaluate(upstream, parameters) {
        this.view.emit(enums_1.HOOK_EVENT.BEFORE_EVALUATE_DATA);
        const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
        this.grammarSource && (this._input = upstream);
        const values = this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
        return this.setValues(filteredValues), this._isLoaded = !0, this.view.emit(enums_1.HOOK_EVENT.AFTER_EVALUATE_DATA), 
        this;
    }
    output() {
        return this._values;
    }
    getDataIDKey() {
        return this._dataIDKey;
    }
    values(values, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            values: values,
            format: format
        });
        return (0, vutils_1.isNil)(values) || (spec.url = void 0, spec.source = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    url(url, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            url: url,
            format: format
        });
        return (0, vutils_1.isNil)(url) || (spec.values = void 0, spec.source = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    source(source, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            source: source,
            format: format
        });
        return (0, vutils_1.isNil)(source) || (spec.values = void 0, spec.url = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    parseLoad(spec) {
        this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
        const dataSourceResult = this.parseDataSource(this.spec);
        return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, 
        this._isLoaded = !1, this.commit(), this;
    }
    setValues(data) {
        this._values = (0, vutils_1.array)(data).map(((entry, index) => {
            const datum = entry === Object(entry) ? entry : {
                data: entry
            };
            return datum[this._dataIDKey] = index, datum;
        }));
    }
    field(field) {
        return this._values.map((value => value[field]));
    }
    transform(transforms) {
        const prevTransforms = (0, transform_1.parseTransformSpec)(this.spec.transform, this.view);
        prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
        const nextTransforms = (0, transform_1.parseTransformSpec)(this.spec.transform, this.view);
        return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), 
        this.commit(), this;
    }
    getValue() {
        return this._values;
    }
    getInput() {
        return this._input;
    }
    addDataFilter(filter) {
        return this._postFilters = this._postFilters.concat((0, vutils_1.array)(filter)), 
        this._postFilters.sort(((filterA, filterB) => {
            var _a, _b;
            return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
        })), this;
    }
    removeDataFilter(filter) {
        const filters = (0, vutils_1.array)(filter);
        return this._postFilters = this._postFilters.filter((filter => !filters.includes(filter))), 
        this;
    }
    _evaluateFilter(value, parameters) {
        return this._postFilters.reduce(((result, filter) => filter.filter(result, parameters)), value);
    }
    reuse(grammar) {
        return grammar.grammarType !== this.grammarType || (this._isLoaded = !1, this._values = grammar.output()), 
        this;
    }
    clear() {
        super.clear(), this._input = null, this._values = null;
    }
}

exports.Data = Data;
//# sourceMappingURL=data.js.map
