{"version":3,"sources":["../src/util/grammar-heap.ts"],"names":[],"mappings":"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","file":"grammar-heap.js","sourcesContent":["type CompareFunc = (a: any, b: any) => number;\n\n/**\n * moveToHead - Moves an element down the array until the target element is `smallar` than all the elements in head\n *\n * @param {any[]} array - The array to sift through\n * @param {number} start - The start index of the element\n * @param {number} idx - The index of the element to sift down\n * @param {CompareFunc} cmp - The function used to compare elements in the array\n * @returns {any[]} - The updated array with the sifted element in the correct position\n */\nfunction moveToHead(array: any[], idx: number, start: number, cmp: CompareFunc) {\n  let parent;\n  let pidx;\n\n  const item = array[idx];\n  // Move the element down the array\n  while (idx > start) {\n    pidx = Math.floor((idx - 1) / 2);\n    parent = array[pidx];\n    if (item && parent && cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\n/**\n * moveToTail - Moves an element up the array until the target element is `greater` than all the elements in tail\n *\n * @param {any[]} array - The array to sift through\n * @param {number} idx - The index of the element to sift up\n * @param {CompareFunc} cmp - The function used to compare elements in the array\n * @returns {any[]} - The updated array with the sifted element in the correct position\n */\nfunction moveToTail(array: any[], idx: number, end: number | undefined, cmp: CompareFunc) {\n  const start = idx;\n  const endIdx = end ?? array.length;\n  const item = array[idx];\n  let cidx = idx * 2 + 1;\n  let ridx;\n\n  // Move the element up the array until it is in the correct position\n  while (cidx < endIdx) {\n    ridx = cidx + 1;\n    if (ridx < endIdx && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = idx * 2 + 1;\n  }\n  array[idx] = item;\n  return moveToHead(array, idx, start, cmp);\n}\n\nexport class Heap {\n  protected compare: CompareFunc;\n\n  protected nodes: any[];\n\n  constructor(compare: CompareFunc) {\n    this.compare = compare;\n    this.nodes = [];\n  }\n\n  size() {\n    return this.nodes.length;\n  }\n\n  last() {\n    return this.nodes[0];\n  }\n\n  validate() {\n    for (let i = this.nodes.length - 1; i > 0; i -= 1) {\n      const parentIndex = Math.floor((i - 1) / 2);\n      if (this.compare(this.nodes[parentIndex], this.nodes[i]) > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  push(node: any) {\n    if (this.nodes.includes(node)) {\n      // node 的排序等级可能变更，需要重新执行 排序\n      const index = this.nodes.indexOf(node);\n      moveToHead(this.nodes, index, 0, this.compare);\n      return moveToTail(this.nodes, index, null, this.compare);\n    }\n    this.nodes.push(node);\n    return moveToHead(this.nodes, this.nodes.length - 1, 0, this.compare);\n  }\n\n  remove(node: any) {\n    if (this.nodes.includes(node)) {\n      const index = this.nodes.indexOf(node);\n\n      this.nodes = this.nodes.slice(0, index).concat(this.nodes.slice(index + 1));\n\n      moveToHead(this.nodes, index, 0, this.compare);\n      moveToTail(this.nodes, index, null, this.compare);\n    }\n  }\n\n  pop() {\n    const last = this.nodes.pop();\n    let item;\n\n    if (this.nodes.length) {\n      item = this.nodes[0];\n      this.nodes[0] = last;\n\n      moveToTail(this.nodes, 0, null, this.compare);\n    } else {\n      item = last;\n    }\n    return item;\n  }\n\n  clear() {\n    this.nodes = [];\n  }\n}\n"]}