"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerTreePathGlyph = exports.getVerticalPath = exports.getHorizontalPath = void 0;

const factory_1 = require("../core/factory"), vutils_1 = require("@visactor/vutils"), graphic_1 = require("../graph/mark/graphic"), glyph_1 = require("../view/glyph"), getHorizontalPath = options => {
    var _a, _b;
    const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : .5;
    let x0 = options.x0, x1 = options.x1, y0 = options.y0, y1 = options.y1, cpx0 = x0 + curvature * (x1 - x0), cpx1 = x1 + curvature * (x0 - x1), formatter = v => v;
    !1 !== options.round && (x0 = Math.round(x0), x1 = Math.round(x1), y0 = Math.round(y0), 
    y1 = Math.round(y1), cpx0 = Math.round(cpx0), cpx1 = Math.round(cpx1), formatter = Math.round);
    const mainPath = "line" === options.pathType ? `M${x0},${y0}L${x1},${y1}` : "polyline" === options.pathType ? `M${x0},${y0}L${cpx0},${y0}L${cpx0},${y1}L${x1},${y1}` : `M${x0},${y0}C${cpx0},${y0},${cpx1},${y1},${x1},${y1}`;
    if (options.startArrow || options.endArrow) {
        const delta = x1 - x0;
        if (Math.abs(delta) > 1e-6) {
            const arrowSize = null !== (_b = options.arrowSize) && void 0 !== _b ? _b : 3, sign = delta > 0 ? 1 : -1, endArrowPath = options.endArrow ? `M${formatter(x1 - sign * arrowSize)},${formatter(y1 - arrowSize)}L${x1},${y1}L${formatter(x1 - sign * arrowSize)},${formatter(y1 + arrowSize)}` : "";
            return [ options.startArrow ? `M${formatter(x0 + sign * arrowSize)},${formatter(y0 - arrowSize)}L${x0},${y0}L${formatter(x0 + sign * arrowSize)},${formatter(y0 + arrowSize)}` : "", mainPath, endArrowPath ];
        }
    }
    return [ "", mainPath, "" ];
};

exports.getHorizontalPath = getHorizontalPath;

const getVerticalPath = options => {
    var _a, _b;
    const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : .5;
    let y0 = options.y0, y1 = options.y1, x0 = options.x0, x1 = options.x1, cpy0 = y0 + curvature * (y1 - y0), cpy1 = y1 + curvature * (y0 - y1), formatter = v => v;
    !1 !== options.round && (formatter = Math.round, y0 = Math.round(y0), y1 = Math.round(y1), 
    x0 = Math.round(x0), x1 = Math.round(x1), cpy0 = Math.round(cpy0), cpy1 = Math.round(cpy1));
    const mainPath = "line" === options.pathType ? `M${x0},${y0}L${x1},${y1}` : "polyline" === options.pathType ? `M${x0},${y0}L${x0},${cpy0}L${x1},${cpy0}L${x1},${y1}` : `M${x0},${y0}C${x0},${cpy0},${x1},${cpy1},${x1},${y1}`;
    if (options.startArrow || options.endArrow) {
        const delta = y1 - y0;
        if (Math.abs(delta) > 1e-6) {
            const arrowSize = null !== (_b = options.arrowSize) && void 0 !== _b ? _b : 3, sign = delta > 0 ? 1 : -1, endArrowPath = options.endArrow ? `M${formatter(x1 - arrowSize)},${formatter(y1 - sign * arrowSize)}L${x1},${formatter(y1)}L${formatter(x1 + arrowSize)},${formatter(y1 - sign * arrowSize)}` : "";
            return [ options.startArrow ? `M${formatter(x0 + arrowSize)},${formatter(y0 + sign * arrowSize)}L${x0},${formatter(y0)}L${formatter(x0 + arrowSize)},${formatter(y0 + sign * arrowSize)}` : "", mainPath, endArrowPath ];
        }
    }
    return [ "", mainPath, "" ];
};

exports.getVerticalPath = getVerticalPath;

const encoder = (encodeValues, datum, element, config) => {
    var _a;
    const direction = null !== (_a = encodeValues.direction) && void 0 !== _a ? _a : null == config ? void 0 : config.direction, parsePath = [ "vertical", "TB", "BT" ].includes(direction) ? exports.getVerticalPath : exports.getHorizontalPath, encodeChannels = Object.keys(encodeValues);
    if ([ "x0", "y0", "x1", "y1" ].every((channel => encodeChannels.includes(channel)))) {
        const [startArrowPath, mainPath, endArrowPath] = parsePath(encodeValues);
        return {
            main: {
                path: mainPath
            },
            startArrow: {
                path: startArrowPath
            },
            endArrow: {
                path: endArrowPath
            }
        };
    }
    return {};
}, treePathGrowIn = (element, options, animationParameters) => {
    const linkValues = {
        x0: element.getGraphicAttribute("x0", !1),
        x1: element.getGraphicAttribute("x1", !1),
        y0: element.getGraphicAttribute("y0", !1),
        y1: element.getGraphicAttribute("y1", !1),
        round: element.getGraphicAttribute("round", !1),
        align: element.getGraphicAttribute("align", !1),
        pathType: element.getGraphicAttribute("pathType", !1),
        endArrow: element.getGraphicAttribute("endArrow", !1),
        startArrow: element.getGraphicAttribute("startArrow", !1)
    };
    return Object.keys(linkValues).forEach((key => {
        (0, vutils_1.isNil)(linkValues[key]) && delete linkValues[key];
    })), {
        from: Object.assign({}, linkValues, {
            x1: linkValues.x0,
            y1: linkValues.y0
        }),
        to: linkValues
    };
}, treePathGrowOut = (element, options, animationParameters) => {
    const linkValues = {
        x0: element.getGraphicAttribute("x0", !0),
        x1: element.getGraphicAttribute("x1", !0),
        y0: element.getGraphicAttribute("y0", !0),
        y1: element.getGraphicAttribute("y1", !0),
        round: element.getGraphicAttribute("round", !0),
        align: element.getGraphicAttribute("align", !0),
        pathType: element.getGraphicAttribute("pathType", !0),
        endArrow: element.getGraphicAttribute("endArrow", !0),
        startArrow: element.getGraphicAttribute("startArrow", !0)
    };
    return Object.keys(linkValues).forEach((key => {
        (0, vutils_1.isNil)(linkValues[key]) && delete linkValues[key];
    })), {
        from: linkValues,
        to: Object.assign({}, linkValues, {
            x1: linkValues.x0,
            y1: linkValues.y0
        })
    };
}, treePathUpdate = (element, options, animationParameters) => {
    const bassLinkValues = {
        thickness: element.getGraphicAttribute("thickness", !1),
        round: element.getGraphicAttribute("round", !1),
        align: element.getGraphicAttribute("align", !1),
        pathType: element.getGraphicAttribute("pathType", !1),
        endArrow: element.getGraphicAttribute("endArrow", !1),
        startArrow: element.getGraphicAttribute("startArrow", !1)
    };
    Object.keys(bassLinkValues).forEach((key => {
        (0, vutils_1.isNil)(bassLinkValues[key]) && delete bassLinkValues[key];
    }));
    return {
        from: Object.assign(Object.assign({
            x0: element.getGraphicAttribute("x0", !0),
            x1: element.getGraphicAttribute("x1", !0),
            y0: element.getGraphicAttribute("y0", !0),
            y1: element.getGraphicAttribute("y1", !0)
        }, bassLinkValues), bassLinkValues),
        to: Object.assign({
            x0: element.getGraphicAttribute("x0", !1),
            x1: element.getGraphicAttribute("x1", !1),
            y0: element.getGraphicAttribute("y0", !1),
            y1: element.getGraphicAttribute("y1", !1)
        }, bassLinkValues)
    };
}, registerTreePathGlyph = () => {
    factory_1.Factory.registerGlyph("treePath", {
        main: "path",
        startArrow: "path",
        endArrow: "path"
    }).registerFunctionEncoder(encoder).registerChannelEncoder("startArrowStyle", ((channel, encodeValue) => ({
        startArrow: encodeValue
    }))).registerChannelEncoder("endArrowStyle", ((channel, encodeValue) => ({
        endArrow: encodeValue
    }))).registerDefaultEncoder((() => ({
        startArrow: {
            zIndex: 1
        },
        endArrow: {
            zIndex: 2
        }
    }))), factory_1.Factory.registerAnimationType("treePathGrowIn", treePathGrowIn), 
    factory_1.Factory.registerAnimationType("treePathGrowOut", treePathGrowOut), factory_1.Factory.registerAnimationType("treePathUpdate", treePathUpdate), 
    (0, glyph_1.registerGlyphMark)(), (0, graphic_1.registerGlyphGraphic)(), (0, graphic_1.registerPathGraphic)();
};

exports.registerTreePathGlyph = registerTreePathGlyph;
//# sourceMappingURL=tree-path.js.map