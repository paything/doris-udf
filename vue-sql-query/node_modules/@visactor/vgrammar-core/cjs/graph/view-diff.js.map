{"version":3,"sources":["../src/graph/view-diff.ts"],"names":[],"mappings":";;;AAGA,0CAAsD;AACtD,mCAA0C;AAE1C,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAEnC,MAAa,QAAQ;IACnB,WAAW,CAAyB,YAAiB,EAAE,YAAiB;QACtE,MAAM,GAAG,GAAG,CAAC,OAAU,EAAE,EAAE,WAAC,OAAA,MAAA,OAAO,CAAC,EAAE,EAAE,mCAAI,MAAM,EAAE,CAAA,EAAA,CAAC;QACrD,OAAO,IAAA,mBAAU,EAAC,YAAY,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;IACrD,CAAC;IAED,QAAQ,CAAC,SAAkB,EAAE,SAAkB,EAAE,aAA6B;QAC5E,MAAM,UAAU,GAAiC;YAC/C,KAAK,EAAE,EAAE;YACT,IAAI,EAAE,EAAE;YACR,MAAM,EAAE,EAAE;SACX,CAAC;QAEF,IAAI,aAAa,GAAY,EAAE,CAAC;QAChC,IAAI,aAAa,GAAY,EAAE,CAAC;QAGhC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACvB,IAEE,IAAI,CAAC,QAAQ,KAAK,uBAAe,CAAC,KAAK;gBACvC,CAAC,CAAC,aAAa,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC,KAAK,CAAC,IAAI,aAAa,CAAC,QAAQ,IAAI,aAAa,CAAC,KAAK,CAAC,EACvG;gBACA,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC1B;iBAAM;gBACL,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACxC;QACH,CAAC,CAAC,CAAC;QACH,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACvB,IACE,IAAI,CAAC,QAAQ,KAAK,uBAAe,CAAC,KAAK;gBACvC,CAAC,CAAC,aAAa,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC,KAAK,CAAC,IAAI,aAAa,CAAC,QAAQ,IAAI,aAAa,CAAC,KAAK,CAAC,EACvG;gBACA,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC1B;iBAAM;gBACL,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACzC;QACH,CAAC,CAAC,CAAC;QAGH,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAC1C,aAAa,EACb,aAAa,EACb,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,QAAQ,EACtC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,QAAQ,CACvC,CAAC;QACF,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;QACnC,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;QACnC,UAAU,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAGnE,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAC3C,aAAa,EACb,aAAa,EACb,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,EACjB,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAClB,CAAC;QACF,aAAa,GAAG,cAAc,CAAC,IAAI,CAAC;QACpC,aAAa,GAAG,cAAc,CAAC,IAAI,CAAC;QACpC,UAAU,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QAKpE,MAAM,eAAe,GAAG,IAAA,kBAAS,EAAC,aAAa,EAAE,IAAI,CAAC,EAAE,eAAC,OAAA,MAAA,MAAA,IAAI,CAAC,KAAK,0CAAE,EAAE,kDAAI,CAAA,EAAA,CAAC,CAAC;QAC7E,MAAM,eAAe,GAAG,IAAA,kBAAS,EAAC,aAAa,EAAE,IAAI,CAAC,EAAE,eAAC,OAAA,MAAA,MAAA,IAAI,CAAC,KAAK,0CAAE,EAAE,kDAAI,CAAA,EAAA,CAAC,CAAC;QAE7E,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;YAC/C,MAAM,YAAY,GAAG,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACzD,MAAM,YAAY,GAAG,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACzD,IAAI,YAAY,IAAI,YAAY,EAAE;gBAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;oBAC9E,MAAM,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;oBAClC,MAAM,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;oBAClC,IAAI,SAAS,IAAI,SAAS,EAAE;wBAC1B,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;qBAClE;yBAAM,IAAI,SAAS,EAAE;wBACpB,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;qBAC7C;yBAAM,IAAI,SAAS,EAAE;wBACpB,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;qBAC9C;iBACF;gBAED,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC3E,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;aAC5E;QACH,CAAC,CAAC,CAAC;QAGH,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QACtE,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QAEvE,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,iBAAiB,CACvB,IAAS,EACT,IAAS,EACT,OAAsC,EACtC,OAAsC;QAEtC,MAAM,SAAS,GAAG,IAAA,kBAAS,EAAC,IAAI,EAAE,KAAK,CAAC,EAAE,WAAC,OAAA,MAAA,OAAO,CAAC,KAAK,CAAC,mCAAI,QAAQ,CAAA,EAAA,CAAC,CAAC;QACvE,MAAM,SAAS,GAAG,IAAA,kBAAS,EAAC,IAAI,EAAE,KAAK,CAAC,EAAE,WAAC,OAAA,MAAA,OAAO,CAAC,KAAK,CAAC,mCAAI,QAAQ,CAAA,EAAA,CAAC,CAAC;QAEvE,IAAI,aAAa,GAAG,IAAI,CAAC;QACzB,IAAI,aAAa,GAAG,IAAI,CAAC;QACzB,MAAM,MAAM,GAA+B,EAAE,CAAC;QAC9C,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAC3B,IAAI,GAAG,KAAK,QAAQ,EAAE;gBACpB,MAAM,WAAW,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC5C,MAAM,WAAW,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC5C,IAAI,WAAW,IAAI,WAAW,EAAE;oBAC9B,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,CAAC,CAAC;oBACtD,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC5E,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC7E;aACF;QACH,CAAC,CAAC,CAAC;QACH,OAAO;YACL,IAAI,EAAE,aAAa;YACnB,IAAI,EAAE,aAAa;YACnB,MAAM;SACP,CAAC;IACJ,CAAC;CACF;AA5HD,4BA4HC","file":"view-diff.js","sourcesContent":["import type { IGrammarBase, IMark, IRunningConfig, MarkSpec } from '../types';\nimport type { DiffResult } from '../types/base';\nimport type { IViewDiff } from '../types/morph';\nimport { diffSingle, groupData } from './mark/differ';\nimport { GrammarMarkType } from './enums';\n\nconst EmptyKey = Symbol.for('key');\n\nexport class ViewDiff implements IViewDiff {\n  diffGrammar<U extends IGrammarBase>(prevGrammars: U[], nextGrammars: U[]): DiffResult<U, U> {\n    const key = (grammar: U) => grammar.id() ?? Symbol();\n    return diffSingle(prevGrammars, nextGrammars, key);\n  }\n\n  diffMark(prevMarks: IMark[], nextMarks: IMark[], runningConfig: IRunningConfig): DiffResult<IMark[], IMark[]> {\n    const diffResult: DiffResult<IMark[], IMark[]> = {\n      enter: [],\n      exit: [],\n      update: []\n    };\n\n    let prevDiffMarks: IMark[] = [];\n    let nextDiffMarks: IMark[] = [];\n\n    // filter out marks & specs which will not morph\n    prevMarks.forEach(mark => {\n      if (\n        // group mark does not support reusing or morphing\n        mark.markType !== GrammarMarkType.group &&\n        ((runningConfig.morph && mark.getMorphConfig().morph) || runningConfig.morphAll || runningConfig.reuse)\n      ) {\n        prevDiffMarks.push(mark);\n      } else {\n        diffResult.exit.push({ prev: [mark] });\n      }\n    });\n    nextMarks.forEach(mark => {\n      if (\n        mark.markType !== GrammarMarkType.group &&\n        ((runningConfig.morph && mark.getMorphConfig().morph) || runningConfig.morphAll || runningConfig.reuse)\n      ) {\n        nextDiffMarks.push(mark);\n      } else {\n        diffResult.enter.push({ next: [mark] });\n      }\n    });\n\n    // 1. match by custom key\n    const keyDiffResult = this.diffUpdateByGroup(\n      prevDiffMarks,\n      nextDiffMarks,\n      mark => mark.getMorphConfig().morphKey,\n      mark => mark.getMorphConfig().morphKey\n    );\n    prevDiffMarks = keyDiffResult.prev;\n    nextDiffMarks = keyDiffResult.next;\n    diffResult.update = diffResult.update.concat(keyDiffResult.update);\n\n    // 2. match by name\n    const nameDiffResult = this.diffUpdateByGroup(\n      prevDiffMarks,\n      nextDiffMarks,\n      mark => mark.id(),\n      mark => mark.id()\n    );\n    prevDiffMarks = nameDiffResult.prev;\n    nextDiffMarks = nameDiffResult.next;\n    diffResult.update = diffResult.update.concat(nameDiffResult.update);\n\n    // 3. match by index\n\n    // FIXME: mark index cannot be get before executing, index is decided by remove/order for now\n    const prevParentGroup = groupData(prevDiffMarks, mark => mark.group?.id?.());\n    const nextParentGroup = groupData(nextDiffMarks, mark => mark.group?.id?.());\n\n    Object.keys(nextParentGroup).forEach(groupName => {\n      const prevChildren = prevParentGroup.data.get(groupName);\n      const nextChildren = nextParentGroup.data.get(groupName);\n      if (prevChildren && nextChildren) {\n        for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {\n          const prevChild = prevChildren[i];\n          const nextChild = nextChildren[i];\n          if (prevChild && nextChild) {\n            diffResult.update.push({ prev: [prevChild], next: [nextChild] });\n          } else if (prevChild) {\n            diffResult.exit.push({ prev: [prevChild] });\n          } else if (nextChild) {\n            diffResult.enter.push({ next: [nextChild] });\n          }\n        }\n\n        prevDiffMarks = prevDiffMarks.filter(mark => !prevChildren.includes(mark));\n        nextDiffMarks = nextDiffMarks.filter(mark => !nextChildren.includes(mark));\n      }\n    });\n\n    // 4. handle unmatched marks\n    prevDiffMarks.forEach(mark => diffResult.exit.push({ prev: [mark] }));\n    nextDiffMarks.forEach(mark => diffResult.enter.push({ next: [mark] }));\n\n    return diffResult;\n  }\n\n  private diffUpdateByGroup<U extends IMark | MarkSpec, V extends IMark | MarkSpec>(\n    prev: U[],\n    next: V[],\n    prevKey: (datum: U) => symbol | string,\n    nextKey: (datum: V) => symbol | string\n  ) {\n    const prevGroup = groupData(prev, datum => prevKey(datum) ?? EmptyKey);\n    const nextGroup = groupData(next, datum => nextKey(datum) ?? EmptyKey);\n\n    let prevAfterDiff = prev;\n    let nextAfterDiff = next;\n    const update: { prev: U[]; next: V[] }[] = [];\n    nextGroup.keys.forEach(key => {\n      if (key !== EmptyKey) {\n        const prevKeyData = prevGroup.data.get(key);\n        const nextKeyData = nextGroup.data.get(key);\n        if (prevKeyData && nextKeyData) {\n          update.push({ prev: prevKeyData, next: nextKeyData });\n          prevAfterDiff = prevAfterDiff.filter(datum => !prevKeyData.includes(datum));\n          nextAfterDiff = nextAfterDiff.filter(datum => !nextKeyData.includes(datum));\n        }\n      }\n    });\n    return {\n      prev: prevAfterDiff,\n      next: nextAfterDiff,\n      update\n    };\n  }\n}\n"]}