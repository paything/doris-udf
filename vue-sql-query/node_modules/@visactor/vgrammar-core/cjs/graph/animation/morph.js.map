{"version":3,"sources":["../src/graph/animation/morph.ts"],"names":[],"mappings":"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","file":"morph.js","sourcesContent":["import { morphPath, multiToOneMorph, oneToMultiMorph } from '@visactor/vrender-core';\nimport { isNil, isNumber, isValidNumber } from '@visactor/vutils';\nimport type { IElement, IMark, IRunningConfig } from '../../types';\nimport type { MorphData, MorphElements } from '../../types/morph';\nimport { invokeFunctionType, parseField } from '../../parse/util';\nimport { diffMultiple } from '../mark/differ';\n\nconst doMorph = (\n  prev: IElement[],\n  next: IElement[],\n  runningConfig: IRunningConfig,\n  onEnd: () => void,\n  parameters: any\n) => {\n  const morphData: MorphData = {\n    prev: prev.map(element => element.getDatum()),\n    next: next.map(element => element.getDatum())\n  };\n  const morphElements: MorphElements = {\n    prev: prev.slice(),\n    next: next.slice()\n  };\n  const easing = runningConfig.animation.easing;\n  const delay = invokeFunctionType(runningConfig.animation.delay, parameters, morphData, morphElements);\n  const duration = invokeFunctionType(runningConfig.animation.duration, parameters, morphData, morphElements);\n  const oneByOne = invokeFunctionType(runningConfig.animation.oneByOne, parameters, morphData, morphElements);\n  const splitPath = invokeFunctionType(runningConfig.animation.splitPath, parameters, morphData, morphElements);\n  const individualDelay =\n    isValidNumber(oneByOne) && (oneByOne as number) > 0\n      ? (index: number) => {\n          if (isNumber(oneByOne)) {\n            return index * (oneByOne as number);\n          } else if (oneByOne === true) {\n            return index * duration;\n          }\n          return 0;\n        }\n      : undefined;\n\n  // if no previous item, still execute morph animation\n  if ((prev.length === 1 || prev.length === 0) && next.length === 1) {\n    morphPath(prev[0]?.getGraphicItem?.(), next[0].getGraphicItem(), { delay, duration, easing, onEnd });\n  } else if (prev.length === 1 && next.length > 1) {\n    oneToMultiMorph(\n      prev[0].getGraphicItem(),\n      next.map(element => element.getGraphicItem()),\n      { delay, duration, easing, onEnd, individualDelay, splitPath }\n    );\n  } else if (prev.length > 1 && next.length === 1) {\n    multiToOneMorph(\n      prev.map(element => element.getGraphicItem()),\n      next[0].getGraphicItem(),\n      { delay, duration, easing, onEnd, individualDelay, splitPath }\n    );\n  }\n};\n\nconst divideElements = (elements: IElement[], count: number) => {\n  const divideLength = Math.floor(elements.length / count);\n  return new Array(count).fill(0).map((i, index) => {\n    return elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1));\n  });\n};\n\nconst appendMorphKeyToElements = (mark: IMark) => {\n  const config = mark.getMorphConfig();\n\n  if (!isNil(config.morphElementKey)) {\n    const getter = parseField(config.morphElementKey);\n\n    if (mark.elements) {\n      mark.elements.forEach(el => {\n        (el as any).morphKey = getter(el.getDatum());\n      });\n    }\n  }\n};\n\nexport const morph = (prevMarks: IMark[], nextMarks: IMark[], runningConfig: IRunningConfig) => {\n  const prevElements = prevMarks.reduce((elements, mark) => {\n    appendMorphKeyToElements(mark);\n\n    return elements.concat(mark.elements);\n  }, [] as IElement[]);\n  const nextElements = nextMarks.reduce((elements, mark) => {\n    appendMorphKeyToElements(mark);\n\n    return elements.concat(mark.elements);\n  }, [] as IElement[]);\n\n  const key = (element: IElement) => (element as any).morphKey ?? element.key;\n  const diffResult = diffMultiple(prevElements, nextElements, key);\n\n  // disable normal animations of previous marks\n  prevMarks.forEach(mark => mark.animate?.disable?.());\n  nextMarks.forEach(mark => mark.animate?.disable?.());\n\n  const parameters = prevMarks.concat(nextMarks).reduce((parameters, mark) => {\n    Object.assign(parameters, mark.parameters());\n    return parameters;\n  }, {});\n\n  let morphCount = 0;\n  const onMorphEnd = () => {\n    morphCount -= 1;\n    if (morphCount === 0) {\n      nextMarks.forEach(mark => {\n        mark.animate?.enable?.();\n      });\n    }\n  };\n  // no animation for exit result\n  diffResult.enter.forEach(diff => {\n    diff.next.forEach(element => {\n      doMorph([], [element], runningConfig, onMorphEnd, parameters);\n    });\n    morphCount += 1;\n  });\n  diffResult.update.forEach(diff => {\n    const divideCount = Math.min(diff.prev.length, diff.next.length);\n    const prevDivide = divideElements(diff.prev, divideCount);\n    const nextDivide = divideElements(diff.next, divideCount);\n    for (let i = 0; i < divideCount; i++) {\n      doMorph(prevDivide[i], nextDivide[i], runningConfig, onMorphEnd, parameters);\n      morphCount += 1;\n    }\n  });\n};\n"]}