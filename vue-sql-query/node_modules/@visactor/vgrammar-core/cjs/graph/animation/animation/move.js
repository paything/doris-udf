"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.moveOut = exports.moveIn = void 0;

const vutils_1 = require("@visactor/vutils"), moveIn = (element, options, animationParameters) => {
    var _a, _b;
    const {offset: offset = 0, orient: orient, direction: direction, point: pointOpt, excludeChannels: excludeChannels = []} = null != options ? options : {};
    let changedX = 0, changedY = 0;
    "negative" === orient && (animationParameters.group ? (changedX = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), 
    changedY = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), 
    animationParameters.groupWidth = changedX, animationParameters.groupHeight = changedY) : (changedX = animationParameters.width, 
    changedY = animationParameters.height)), changedX += offset, changedY += offset;
    const point = (0, vutils_1.isFunction)(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point && (0, 
    vutils_1.isValidNumber)(point.x) ? point.x : changedX, fromY = point && (0, vutils_1.isValidNumber)(point.y) ? point.y : changedY, finalAttrsX = excludeChannels.includes("x") ? element.getGraphicAttribute("x") : element.getFinalAnimationAttribute("x"), finalAttrsY = excludeChannels.includes("y") ? element.getGraphicAttribute("y") : element.getFinalAnimationAttribute("y");
    switch (direction) {
      case "x":
        return {
            from: {
                x: fromX
            },
            to: {
                x: finalAttrsX
            }
        };

      case "y":
        return {
            from: {
                y: fromY
            },
            to: {
                y: finalAttrsY
            }
        };

      default:
        return {
            from: {
                x: fromX,
                y: fromY
            },
            to: {
                x: finalAttrsX,
                y: finalAttrsY
            }
        };
    }
};

exports.moveIn = moveIn;

const moveOut = (element, options, animationParameters) => {
    var _a, _b;
    const {offset: offset = 0, orient: orient, direction: direction, point: pointOpt} = null != options ? options : {}, groupBounds = animationParameters.group ? animationParameters.group.getBounds() : null, groupWidth = null !== (_a = null == groupBounds ? void 0 : groupBounds.width()) && void 0 !== _a ? _a : animationParameters.width, groupHeight = null !== (_b = null == groupBounds ? void 0 : groupBounds.height()) && void 0 !== _b ? _b : animationParameters.height, changedX = ("negative" === orient ? groupWidth : 0) + offset, changedY = ("negative" === orient ? groupHeight : 0) + offset, point = (0, 
    vutils_1.isFunction)(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point && (0, 
    vutils_1.isValidNumber)(point.x) ? point.x : changedX, fromY = point && (0, vutils_1.isValidNumber)(point.y) ? point.y : changedY;
    switch (direction) {
      case "x":
        return {
            from: {
                x: element.getGraphicAttribute("x", !0)
            },
            to: {
                x: fromX
            }
        };

      case "y":
        return {
            from: {
                y: element.getGraphicAttribute("y", !0)
            },
            to: {
                y: fromY
            }
        };

      default:
        return {
            from: {
                x: element.getGraphicAttribute("x", !0),
                y: element.getGraphicAttribute("y", !0)
            },
            to: {
                x: fromX,
                y: fromY
            }
        };
    }
};

exports.moveOut = moveOut;
//# sourceMappingURL=move.js.map
