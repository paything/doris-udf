{"version":3,"sources":["../src/graph/layout/grid.ts"],"names":[],"mappings":"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","file":"grid.js","sourcesContent":["import type { IBounds } from '@visactor/vutils';\nimport { Bounds, isValidNumber } from '@visactor/vutils';\nimport type { IGroupMark, ILayoutOptions, IMark, MarkGridItemSpec, MarkGridContainerSpec } from '../../types';\n\ninterface IGrid {\n  rows: number[];\n  columns: number[];\n  rowGap: number;\n  columnGap: number;\n}\n\nfunction parseTemplate(template: number | string | 'auto', total: number) {\n  if (isValidNumber(template)) {\n    return template;\n  }\n  const trimmedTemplate = template.trim();\n  if (trimmedTemplate === 'auto') {\n    // handle auto later\n    return 0;\n  } else if (trimmedTemplate.endsWith('%')) {\n    const percent = parseFloat(trimmedTemplate.substring(0, trimmedTemplate.length - 1));\n    if (isValidNumber(percent)) {\n      return percent * total;\n    }\n    return 0;\n  }\n  return 0;\n}\n\nfunction computeGrid(layout: MarkGridContainerSpec, width: number, height: number): IGrid {\n  const templateRows = layout.gridTemplateRows ?? [height];\n  const templateColumns = layout.gridTemplateColumns ?? [width];\n  const rowGap = layout.gridRowGap ?? 0;\n  const columnGap = layout.gridColumnGap ?? 0;\n\n  // compute simple cell size\n  const rows = templateRows.map(row => parseTemplate(row, height));\n  const columns = templateColumns.map(column => parseTemplate(column, width));\n\n  // compute auto grid\n  const rowLeftSize = Math.max(0, rows.reduce((left, row) => left - row, height) - rows.length * rowGap);\n  const rowAuto = rowLeftSize / templateRows.filter(row => row === 'auto').length;\n  const columnLeftSize = Math.max(\n    0,\n    columns.reduce((left, column) => left - column, width) - columns.length * columnGap\n  );\n  const columnAuto = columnLeftSize / templateColumns.filter(column => column === 'auto').length;\n  // accumulate grid size\n  let lastRow = 0;\n  const accumulateRows = rows.map((row, index) => {\n    const finalRow = templateRows[index] === 'auto' ? rowAuto : row;\n    const last = lastRow;\n    lastRow += finalRow + rowGap;\n    return last;\n  });\n  accumulateRows.push(lastRow);\n  let lastColumn = 0;\n  const accumulateColumns = columns.map((column, index) => {\n    const finalColumn = templateColumns[index] === 'auto' ? columnAuto : column;\n    const last = lastColumn;\n    lastColumn += finalColumn + columnGap;\n    return last;\n  });\n  accumulateColumns.push(lastColumn);\n\n  return {\n    rows: accumulateRows,\n    columns: accumulateColumns,\n    rowGap,\n    columnGap\n  };\n}\n\nfunction normalizeIndex(index: number, count: number) {\n  return Math.min(index < 0 ? index + count : index - 1, count);\n}\n\nfunction normalizeStartEndIndex(start: number, end: number, count: number) {\n  let finalStart = normalizeIndex(start, count);\n  let finalEnd = normalizeIndex(end, count);\n  if (!isValidNumber(start) && !isValidNumber(end)) {\n    finalStart = 1;\n    finalEnd = 2;\n  } else if (!isValidNumber(start)) {\n    finalEnd = normalizeIndex(finalStart + 1, count);\n  } else if (!isValidNumber(end)) {\n    finalStart = normalizeIndex(Math.max(0, finalEnd - 1), count);\n  }\n  if (finalStart > finalEnd) {\n    const temp = finalEnd;\n    finalEnd = finalStart;\n    finalStart = temp;\n  }\n  return { start: finalStart, end: finalEnd };\n}\n\nfunction getCellBounds(grid: IGrid, rowStart: number, rowEnd: number, columnStart: number, columnEnd: number): Bounds {\n  const rowCount = grid.rows.length;\n  const columnCount = grid.columns.length;\n  const { start: finalRowStart, end: finalRowEnd } = normalizeStartEndIndex(rowStart, rowEnd, rowCount);\n  const { start: finalColumnStart, end: finalColumnEnd } = normalizeStartEndIndex(columnStart, columnEnd, columnCount);\n\n  const x1 = grid.columns[finalRowStart];\n  const x2 = grid.columns[finalRowEnd] - (finalColumnEnd === columnCount ? 0 : grid.columnGap);\n  const y1 = grid.rows[finalColumnStart];\n  const y2 = grid.rows[finalColumnEnd] - (finalRowEnd === rowCount ? 0 : grid.rowGap);\n  return new Bounds().set(x1, y1, x2, y2);\n}\n\nexport const doGridLayout = (\n  group: IGroupMark,\n  children: IMark[],\n  parentLayoutBounds: IBounds,\n  options?: ILayoutOptions\n) => {\n  const layout = group.getSpec().layout as MarkGridContainerSpec;\n  const grid = computeGrid(layout, parentLayoutBounds.width(), parentLayoutBounds.height());\n  if (children) {\n    children.forEach(mark => {\n      const markLayout = mark.getSpec().layout as MarkGridItemSpec;\n      mark.layoutBounds = getCellBounds(\n        grid,\n        markLayout.gridRowStart,\n        markLayout.gridRowEnd,\n        markLayout.gridColumnStart,\n        markLayout.gridColumnEnd\n      );\n      mark.commit();\n    });\n  }\n};\n"]}