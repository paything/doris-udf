"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isPointsMarkType = exports.isPositionOrSizeChannel = exports.getLargeSymbolsPoints = exports.getLargeRectsPoints = exports.getLinePoints = exports.getRulePoints = exports.isValidPointsChannel = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("../enums");

function isValidPointsChannel(channels, markType) {
    switch (markType) {
      case "line":
        return channels.some((channel => [ "x", "y", "defined" ].includes(channel)));

      case "area":
        return channels.some((channel => [ "x", "y", "x1", "y1", "defined" ].includes(channel)));

      case "largeRects":
        return channels.some((channel => [ "x", "y", "width", "y1" ].includes(channel)));

      case "largeSymbols":
        return channels.some((channel => [ "x", "y" ].includes(channel)));
    }
    return !1;
}

function getRulePoints(nextAttrs) {
    const {x: x, y: y, x1: x1, y1: y1} = nextAttrs;
    return (0, vutils_1.isValidNumber)(x) && (0, vutils_1.isValidNumber)(y) && (0, vutils_1.isValidNumber)(x1) && (0, 
    vutils_1.isValidNumber)(y1) ? [ {
        x: x,
        y: y
    }, {
        x: x1,
        y: y1
    } ] : [];
}

function getLinePoints(items, includeOnePoint, lastPoints, isArea) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    return items.some((item => isValidPointsChannel(Object.keys(item.nextAttrs), "line"))) ? items.map(((item, index) => {
        var _a;
        const attrs = item.nextAttrs, {x: x, y: y, x1: x1, y1: y1, defined: defined} = null !== (_a = null == lastPoints ? void 0 : lastPoints[index]) && void 0 !== _a ? _a : {};
        return (0, vutils_1.isNil)(attrs.x) && (attrs.x = x), (0, vutils_1.isNil)(attrs.y) && (attrs.y = y), 
        (0, vutils_1.isNil)(attrs.defined) && !1 === defined && (attrs.defined = !1), attrs.context = item.key, 
        isArea && ((0, vutils_1.isNil)(attrs.x1) && (attrs.x1 = x1), (0, vutils_1.isNil)(attrs.y1) && (attrs.y1 = y1)), 
        attrs;
    })) : null != lastPoints ? lastPoints : [];
}

function getLargeRectsPoints(items, includeOnePoint, lastPoints = []) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    const arr = new Float32Array(4 * items.length);
    return items.forEach(((item, index) => {
        var _a, _b, _c, _d;
        const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[4 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[4 * index + 1], width = null !== (_c = attrs.width) && void 0 !== _c ? _c : lastPoints[4 * index + 2], y1 = null !== (_d = attrs.y1) && void 0 !== _d ? _d : lastPoints[4 * index + 3];
        arr[4 * index] = x, arr[4 * index + 1] = y, arr[4 * index + 2] = width, arr[4 * index + 3] = y1 - y;
    })), arr;
}

function getLargeSymbolsPoints(items, includeOnePoint, lastPoints = []) {
    if (!items || !items.length || 1 === items.length && !includeOnePoint) return [];
    const arr = new Float32Array(2 * items.length);
    return items.forEach(((item, index) => {
        var _a, _b;
        const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[2 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[2 * index + 1];
        arr[2 * index] = x, arr[2 * index + 1] = y;
    })), arr;
}

function isPositionOrSizeChannel(type, channel) {
    if ([ "x", "y", "dx", "dy" ].includes(channel)) return !0;
    switch (type) {
      case enums_1.GrammarMarkType.arc:
        return [ "innerRadius", "outerRadius", "startAngle", "endAngle" ].includes(channel);

      case enums_1.GrammarMarkType.group:
      case enums_1.GrammarMarkType.rect:
      case enums_1.GrammarMarkType.image:
        return [ "width", "height", "y1" ].includes(channel);

      case enums_1.GrammarMarkType.path:
      case enums_1.GrammarMarkType.shape:
        return [ "path", "customPath" ].includes(channel);

      case enums_1.GrammarMarkType.line:
        return "defined" === channel;

      case enums_1.GrammarMarkType.area:
        return [ "x1", "y1", "defined" ].includes(channel);

      case enums_1.GrammarMarkType.rule:
        return [ "x1", "y1" ].includes(channel);

      case enums_1.GrammarMarkType.symbol:
        return "size" === channel;

      case enums_1.GrammarMarkType.polygon:
        return "points" === channel;

      case enums_1.GrammarMarkType.text:
        return "text" === channel;
    }
    return !1;
}

function isPointsMarkType(markType) {
    return [ enums_1.GrammarMarkType.line, enums_1.GrammarMarkType.area, enums_1.GrammarMarkType.largeRects, enums_1.GrammarMarkType.largeSymbols ].includes(markType);
}

exports.isValidPointsChannel = isValidPointsChannel, exports.getRulePoints = getRulePoints, 
exports.getLinePoints = getLinePoints, exports.getLargeRectsPoints = getLargeRectsPoints, 
exports.getLargeSymbolsPoints = getLargeSymbolsPoints, exports.isPositionOrSizeChannel = isPositionOrSizeChannel, 
exports.isPointsMarkType = isPointsMarkType;
//# sourceMappingURL=helpers.js.map
