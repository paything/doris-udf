"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.transform = void 0;

const vutils_1 = require("@visactor/vutils"), transform = (options, upstreamData) => {
    var _a, _b;
    if (!upstreamData || 0 === upstreamData.length) return upstreamData;
    const field = options.field, startAngle = null !== (_a = options.startAngle) && void 0 !== _a ? _a : 0, endAngle = null !== (_b = options.endAngle) && void 0 !== _b ? _b : 2 * Math.PI, {asStartAngle: asStartAngle, asEndAngle: asEndAngle, asMiddleAngle: asMiddleAngle, asRadian: asRadian, asRatio: asRatio, asQuadrant: asQuadrant, asK: asK} = options, total = upstreamData.reduce(((sum, d) => Number.parseFloat(d[field]) + sum), 0), max = upstreamData.reduce(((m, d) => Math.max(m, Number.parseFloat(d[field]))), -1 / 0), intervalAngle = endAngle - startAngle;
    let lastAngle = startAngle;
    const data = upstreamData.map((originDatum => {
        const datum = Object.assign({}, originDatum), ratio = Number.parseFloat(datum[field]) / total, radian = ratio * intervalAngle;
        return asRatio && (datum[asRatio] = ratio), asStartAngle && (datum[asStartAngle] = lastAngle), 
        asEndAngle && (datum[asEndAngle] = lastAngle + radian), asMiddleAngle && (datum[asMiddleAngle] = lastAngle + radian / 2), 
        asRadian && (datum[asRadian] = radian), asQuadrant && (datum[asQuadrant] = (0, vutils_1.computeQuadrant)(lastAngle + radian / 2)), 
        asK && (datum[asK] = Number.parseFloat(datum[field]) / max), lastAngle = datum[asEndAngle], 
        datum;
    }));
    return data[data.length - 1][asEndAngle] = endAngle, data;
};

exports.transform = transform;
//# sourceMappingURL=pie.js.map
