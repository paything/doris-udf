{"version":3,"sources":["../src/transforms/data/join.ts"],"names":[],"mappings":";;;AAAA,6CAAiD;AAEjD,2DAAoE;AAG7D,MAAM,SAAS,GAAG,CAAC,OAA4B,EAAE,IAAW,EAAE,EAAE;IACrE,MAAM,MAAM,GAAG,eAAM,CAAC,WAAW,EAAE,CAAC;IACpC,IAAI,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;IACpB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;IAC9C,MAAM,WAAW,GAAG,IAAA,qBAAgB,EAAC,GAAG,CAAC,CAAC;IAC1C,MAAM,QAAQ,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,KAAU,EAAE,EAAE;QAC5D,GAAG,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC;QAChC,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,EAAE,CAAC,CAAC;IACP,MAAM,YAAY,GAAG,IAAA,cAAK,EAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;IACrE,MAAM,cAAc,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,IAAA,qBAAgB,EAAC,KAAK,CAAC,CAAC,CAAC;IAEpE,IAAI,MAAM,EAAE;QACV,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE;YAC5B,MAAM,CAAC,KAAK,CAAC,sDAAsD,CAAC,CAAC;SACtE;QACD,IAAI,EAAE,IAAI,EAAE,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE;YACrD,MAAM,CAAC,KAAK,CAAC,oDAAoD,CAAC,CAAC;SACpE;QAED,IAAI,IAAA,cAAK,EAAC,EAAE,CAAC,EAAE;YACb,EAAE,GAAG,MAAM,CAAC;SACb;QACD,MAAM,eAAe,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,IAAA,qBAAgB,EAAC,KAAK,CAAC,CAAC,CAAC;QAErE,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,KAAU,EAAE,EAAE;YAC7B,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,aAAkC,EAAE,UAAkB,EAAE,EAAE;gBAChG,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC7C,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC;gBACnC,MAAM,QAAQ,GAAG,IAAA,cAAK,EAAC,KAAK,CAAC;oBAC3B,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,cAAmC,EAAE,EAAE,CAAC,YAAY,CAAC;oBAC5E,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,cAAmC,EAAE,EAAE,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;gBAExF,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,KAAU,EAAE,OAAY,EAAE,OAAe,EAAE,EAAE;oBACnE,KAAK,CAAC,EAAE,CAAC,UAAU,GAAG,YAAY,GAAG,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC;oBAEzD,OAAO,KAAK,CAAC;gBACf,CAAC,EAAE,GAAG,CAAC,CAAC;YACV,CAAC,EAAE,KAAK,CAAC,CAAC;QACZ,CAAC,CAAC,CAAC;KACJ;IACD,IAAI,CAAC,EAAE,EAAE;QACP,MAAM,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;KAC7C;IAED,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,KAAU,EAAE,EAAE;QAC7B,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,aAAkC,EAAE,UAAkB,EAAE,EAAE;YAChG,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;YAE7C,GAAG,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,GAAG,IAAA,cAAK,EAAC,KAAK,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC;YAE1D,OAAO,GAAG,CAAC;QACb,CAAC,EAAE,KAAK,CAAC,CAAC;IACZ,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAtDW,QAAA,SAAS,aAsDpB","file":"join.js","sourcesContent":["import { isNil, Logger } from '@visactor/vutils';\nimport type { FieldGetterFunction } from '@visactor/vgrammar-util';\nimport { field as getFieldAccessor } from '@visactor/vgrammar-util';\nimport type { JoinTransformOption } from '../../types';\n\nexport const transform = (options: JoinTransformOption, data: any[]) => {\n  const logger = Logger.getInstance();\n  let as = options.as;\n  const { fields, from, key, values } = options;\n  const keyAccessor = getFieldAccessor(key);\n  const indexMap = (from || []).reduce((map: any, tuple: any) => {\n    map[keyAccessor(tuple)] = tuple;\n    return map;\n  }, {});\n  const defaultValue = isNil(options.default) ? null : options.default;\n  const fieldAccessors = fields.map(field => getFieldAccessor(field));\n\n  if (values) {\n    if (fields.length > 1 && !as) {\n      logger.error('Multi-field lookup requires explicit \"as\" parameter.');\n    }\n    if (as && as.length !== fields.length * values.length) {\n      logger.error('The \"as\" parameter has too few output field names.');\n    }\n\n    if (isNil(as)) {\n      as = values;\n    }\n    const valuesAccessors = values.map(value => getFieldAccessor(value));\n\n    return data.map((entry: any) => {\n      return fieldAccessors.reduce((res: any, fieldAccessor: FieldGetterFunction, fieldIndex: number) => {\n        const value = indexMap[fieldAccessor(entry)];\n        const valuesLength = values.length;\n        const asValues = isNil(value)\n          ? valuesAccessors.map((valuesAccessor: FieldGetterFunction) => defaultValue)\n          : valuesAccessors.map((valuesAccessor: FieldGetterFunction) => valuesAccessor(value));\n\n        return asValues.reduce((asRes: any, asValue: any, asIndex: number) => {\n          asRes[as[fieldIndex * valuesLength + asIndex]] = asValue;\n\n          return asRes;\n        }, res);\n      }, entry);\n    });\n  }\n  if (!as) {\n    logger.error('Missing output field names.');\n  }\n\n  return data.map((entry: any) => {\n    return fieldAccessors.reduce((res: any, fieldAccessor: FieldGetterFunction, fieldIndex: number) => {\n      const value = indexMap[fieldAccessor(entry)];\n\n      res[as[fieldIndex]] = isNil(value) ? defaultValue : value;\n\n      return res;\n    }, entry);\n  });\n};\n"]}