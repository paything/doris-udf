{"version":3,"sources":["../src/transforms/data/contour.ts"],"names":[],"mappings":"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","file":"contour.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport { isValid, isValidNumber, maxInArray, minInArray } from '@visactor/vutils';\nimport type { ContourTransformOption } from '../../types';\n\ntype InteractionPoint = {\n  id: string;\n  currentCell: number;\n  nextCell: number;\n  point: IPointLike;\n  siblingPoint: InteractionPoint;\n};\n\nconst computeInteractionPoint = (\n  xIndex: number,\n  yIndex: number,\n  cell: [number, number, number, number],\n  cellRow: number,\n  cellColumn: number,\n  threshold: number\n) => {\n  const thresholdCell = [\n    cell[0] >= threshold ? 1 : 0,\n    cell[1] >= threshold ? 1 : 0,\n    cell[2] >= threshold ? 1 : 0,\n    cell[3] >= threshold ? 1 : 0\n  ];\n\n  const points: InteractionPoint[] = [];\n  if (thresholdCell[0] !== thresholdCell[1]) {\n    points.push({\n      id: `${xIndex}-${yIndex - 1}-${xIndex}-${yIndex}`,\n      currentCell: yIndex * cellColumn + xIndex,\n      nextCell: (yIndex - 1) * cellColumn + xIndex,\n      point: {\n        x: xIndex + (threshold - cell[0]) / (cell[1] - cell[0]),\n        y: yIndex\n      },\n      siblingPoint: null\n    });\n  }\n  if (thresholdCell[1] !== thresholdCell[2]) {\n    points.push({\n      id: `${xIndex}-${yIndex}-${xIndex + 1}-${yIndex}`,\n      currentCell: yIndex * cellColumn + xIndex,\n      nextCell: yIndex * cellColumn + xIndex + 1,\n      point: {\n        x: xIndex + 1,\n        y: yIndex + (threshold - cell[1]) / (cell[2] - cell[1])\n      },\n      siblingPoint: null\n    });\n  }\n  if (thresholdCell[2] !== thresholdCell[3]) {\n    points.push({\n      id: `${xIndex}-${yIndex}-${xIndex}-${yIndex + 1}`,\n      currentCell: yIndex * cellColumn + xIndex,\n      nextCell: (yIndex + 1) * cellColumn + xIndex,\n      point: {\n        x: xIndex + (threshold - cell[3]) / (cell[2] - cell[3]),\n        y: yIndex + 1\n      },\n      siblingPoint: null\n    });\n  }\n  if (thresholdCell[3] !== thresholdCell[0]) {\n    points.push({\n      id: `${xIndex - 1}-${yIndex}-${xIndex}-${yIndex}`,\n      currentCell: yIndex * cellColumn + xIndex,\n      nextCell: yIndex * cellColumn + xIndex - 1,\n      point: {\n        x: xIndex,\n        y: yIndex + (threshold - cell[0]) / (cell[3] - cell[0])\n      },\n      siblingPoint: null\n    });\n  }\n\n  const thresholdFlag =\n    (thresholdCell[0] & 0b1000) +\n    (thresholdCell[1] & 0b0100) +\n    (thresholdCell[2] & 0b0010) +\n    (thresholdCell[3] & 0b0001);\n  if (thresholdFlag === 0b0110 || thresholdFlag === 0b1001) {\n    points[0].siblingPoint = points[1];\n    points[1].siblingPoint = points[0];\n    points[2].siblingPoint = points[3];\n    points[3].siblingPoint = points[2];\n  } else if (points.length === 2) {\n    points[0].siblingPoint = points[1];\n    points[1].siblingPoint = points[0];\n  }\n  return points;\n};\n\nconst connectPoints = (point: InteractionPoint, grid: InteractionPoint[][]) => {\n  const siblingPoint = point.siblingPoint;\n\n  const connectResult = connectNextPoints(point, grid);\n  if (connectResult.result === 'loop') {\n    return connectResult.points;\n  }\n  const frontConnect = connectNextPoints(siblingPoint, grid);\n  return frontConnect.points.reverse().concat(connectResult.points);\n};\n\nconst connectNextPoints = (point: InteractionPoint, grid: InteractionPoint[][]) => {\n  const connectedPoints: InteractionPoint[] = [point];\n  let currentPoint: InteractionPoint = point;\n  const find = (p: InteractionPoint) => p.id === currentPoint.id;\n  let result = 'break';\n  do {\n    const nextCell = grid[currentPoint.nextCell];\n    const nextCellPoint = nextCell?.find(find);\n    if (nextCellPoint) {\n      currentPoint = nextCellPoint.siblingPoint;\n      if (connectedPoints.includes(currentPoint)) {\n        result = 'loop';\n        // close the looped line\n        connectedPoints.push(currentPoint);\n        break;\n      } else if (!currentPoint) {\n        break;\n      }\n      connectedPoints.push(currentPoint);\n    } else {\n      currentPoint = null;\n    }\n  } while (currentPoint);\n  return { points: connectedPoints, result };\n};\n\nexport const transform = (options: ContourTransformOption, upstreamData: any[]) => {\n  if (!upstreamData || upstreamData.length === 0) {\n    return upstreamData;\n  }\n\n  const row = options.row;\n  const column = options.column;\n  const cellRow = row - 1;\n  const cellColumn = column - 1;\n\n  const data = upstreamData.map(datum => datum[options.field]);\n  const extent = [minInArray(data), maxInArray(data)];\n  const thresholds = options.thresholds ?? [];\n  if (!isValid(options.thresholds) && isValidNumber(options.levels)) {\n    const step = (extent[1] - extent[0]) / options.levels;\n    for (let i = 1; i < options.levels; i++) {\n      thresholds.push(extent[0] + i * step);\n    }\n  }\n\n  // the cell value is stored like this:\n  //  top-left, top-right, bottom-right, bottom-left\n  //  tl - tr   O - X\n  //  |     |   |\n  //  bl - br   Y\n  // the actually position in canvas does not effect the result of contouring\n  const cells: [number, number, number, number][] = [];\n  // data grid is row*column\n  for (let yIndex = 1; yIndex < row; yIndex++) {\n    for (let xIndex = 1; xIndex < column; xIndex++) {\n      const topLeft = data[(yIndex - 1) * column + xIndex - 1];\n      const topRight = data[(yIndex - 1) * column + xIndex];\n      const bottomRight = data[yIndex * column + xIndex];\n      const bottomLeft = data[yIndex * column + xIndex - 1];\n      cells.push([topLeft, topRight, bottomRight, bottomLeft]);\n    }\n  }\n\n  const contours: any[] = [];\n\n  thresholds.forEach(threshold => {\n    // compute intersection points\n    const points: InteractionPoint[] = [];\n    const gridPoints: InteractionPoint[][] = [];\n    // cell grid is (row-1)*(column-1)\n    for (let yIndex = 0; yIndex < cellRow; yIndex++) {\n      for (let xIndex = 0; xIndex < cellColumn; xIndex++) {\n        const cell = cells[yIndex * cellColumn + xIndex];\n        const gridPoint = computeInteractionPoint(xIndex, yIndex, cell, cellRow, cellColumn, threshold);\n        points.push(...gridPoint);\n        gridPoints.push(gridPoint);\n      }\n    }\n\n    // connect points\n    let processingPoints = points.slice();\n    do {\n      const connectedPoints = connectPoints(processingPoints[0], gridPoints);\n      processingPoints.splice(0, 1);\n      if (connectedPoints.length) {\n        const connectedPointIds = connectedPoints.map(point => point.id);\n        processingPoints = processingPoints.filter(point => !connectedPointIds.includes(point.id));\n\n        const contour = {\n          [options.asThreshold ?? 'threshold']: threshold,\n          [options.asPoints ?? 'points']: connectedPoints.map(point => {\n            // normalize grid index into [0, 1]\n            return {\n              x: point.point.x / row,\n              y: point.point.y / column\n            };\n          })\n        };\n        contours.push(contour);\n      }\n    } while (processingPoints.length > 0);\n  });\n\n  return contours;\n};\n"]}