{"version":3,"sources":["../src/interface.ts"],"names":[],"mappings":"","file":"interface.js","sourcesContent":["import type { ITextGraphicAttribute } from '@visactor/vrender-core';\n\nexport type ViewBoxOptions = { width: number; height: number } | { x0: number; x1: number; y0: number; y1: number };\n\nexport interface TreemapOptions {\n  /**\n   * The gap width between two nodes which has the same depth, two kinds of value are supported\n   * 1. number: set the gapWidth for nodes of every depth\n   * 2. number[]: number[i] means the gapWidth for node which depth = i;\n   */\n  gapWidth?: number | number[];\n  /**\n   * The padding width, two kinds of value are supported\n   * 1. number: set the padding for nodes of every depth\n   * 2. number[]: number[i] means the padding for node which depth = i;\n   */\n  padding?: number | number[];\n  /**\n   * the width / height ratio\n   */\n  aspectRatio?: number;\n  /**\n   * The padding for non-leaf node, we can use this space to display a label\n   * This pading will only works when the node has enough space\n   */\n  labelPadding?: number | number[];\n  /**\n   * The position of label for non-leaf node\n   */\n  labelPosition?: 'top' | 'bottom' | 'left' | 'right';\n  /**\n   * the type of algorithm\n   */\n  splitType?: 'binary' | 'dice' | 'slice' | 'sliceDice' | 'squarify';\n  /** parse the key of node */\n  nodeKey?: string | number | ((datum: TreemapDatum) => string | number);\n  /**\n   *  the max depth to be showed, when the node has depth > maxDepth, the node won't be calculated\n   */\n  maxDepth?: number;\n  /**\n   * when the area (this unit is px * px) of the node is smaller then this value, this node will be hide\n   */\n  minVisibleArea?: number | number[];\n  /**\n   * when the area (this unit is px * px) of the node is smaller then this value, this children of this node will be hide\n   */\n  minChildrenVisibleArea?: number | number[];\n  /**\n   * when the width or height of the node is smaller then this value, this node will be hide\n   */\n  minChildrenVisibleSize?: number | number[];\n  /**\n   * specify treemap node value field, defaults to `value`\n   */\n  valueField?: string;\n}\n\nexport type TreemapTramsformOptions = TreemapOptions & ViewBoxOptions & { flatten?: boolean };\n\nexport interface HierarchicalDatum {\n  value?: number;\n  children?: HierarchicalDatum[];\n}\n\nexport type HierarchicalData = HierarchicalDatum[];\n\nexport type TreemapData = HierarchicalDatum[];\n\nexport type TreemapDatum = HierarchicalDatum;\n\nexport interface HierarchicalNodeElement<Datum> {\n  key: string;\n  parentKey?: string;\n  flattenIndex: number;\n  index: number;\n  /** the depth of node, from source to target */\n  depth: number;\n  maxDepth: number;\n  /** whether or not this node is a leaf node */\n  isLeaf?: boolean;\n  value: number;\n  datum: Datum[];\n\n  children?: HierarchicalNodeElement<Datum>[];\n}\n\n/**\n * The node element after treemap layout\n */\nexport interface TreemapNodeElement extends Omit<HierarchicalNodeElement<TreemapDatum>, 'children'> {\n  x0?: number;\n  y0?: number;\n  x1?: number;\n  y1?: number;\n  width?: number;\n  height?: number;\n  labelRect?: { x0?: number; x1?: number; y0?: number; y1?: number };\n\n  children?: TreemapNodeElement[];\n}\n\ntype PositionType = string | number;\n\nexport interface SunburstLabelConfig {\n  align?: 'start' | 'end' | 'center';\n  rotate?: 'tangential' | 'radial';\n  offset?: number;\n}\nexport type SunburstLabelOptions = boolean | SunburstLabelConfig;\n\n/**\n * The options of sunburst\n */\nexport interface SunburstOptions {\n  startAngle?: number;\n  endAngle?: number;\n  center?: [PositionType, PositionType];\n  innerRadius?: PositionType | PositionType[];\n  outerRadius?: PositionType | PositionType[];\n  gapRadius?: number | number[];\n  /** parse the key of node */\n  nodeKey?: string | number | ((datum: HierarchicalDatum) => string | number);\n  label?: SunburstLabelOptions | SunburstLabelOptions[];\n}\n\nexport type SunburstTramsformOptions = SunburstOptions & ViewBoxOptions & { flatten?: boolean; maxDepth?: number };\n\n/**\n * The node element after sunburst layout\n */\nexport interface SunburstNodeElement extends HierarchicalNodeElement<HierarchicalDatum> {\n  innerRadius?: number;\n  outerRadius?: number;\n  startAngle?: number;\n  endAngle?: number;\n  x?: number;\n  y?: number;\n\n  children?: SunburstNodeElement[];\n  label?: Pick<ITextGraphicAttribute, 'x' | 'y' | 'textAlign' | 'textBaseline' | 'angle' | 'maxLineWidth'>;\n}\n\nexport interface ICircle {\n  x?: number;\n  y?: number;\n  radius?: number;\n}\n\nexport interface CirclePackingOptions {\n  nodeSort?: boolean | ((a: CirclePackingNodeElement, b: CirclePackingNodeElement) => number);\n  padding?: number | number[];\n  /**\n   * set the radius of node, if not specified, we'll set `Math.sqrt(node.value);`.\n   */\n  setRadius?: (datum: CirclePackingNodeElement) => number;\n  /** parse the key of node */\n  nodeKey?: string | number | ((datum: HierarchicalDatum) => string | number);\n  includeRoot?: boolean;\n}\n\nexport type CirclePackingTramsformOptions = CirclePackingOptions &\n  ViewBoxOptions & { flatten?: boolean; maxDepth?: number };\n\n/**\n * The node element after sunburst layout\n */\nexport interface CirclePackingNodeElement extends HierarchicalNodeElement<HierarchicalDatum>, ICircle {\n  children?: CirclePackingNodeElement[];\n  label?: Pick<ITextGraphicAttribute, 'x' | 'y' | 'textAlign' | 'textBaseline' | 'angle' | 'maxLineWidth'>;\n}\n\nexport interface TreeOptions {\n  /**\n   * The layout direction of chart\n   */\n  direction?: 'horizontal' | 'vertical' | 'LR' | 'RL' | 'TB' | 'BT';\n  /**\n   * layout tree in orthogonal | radial coordinate system\n   */\n  layoutType?: 'orthogonal' | 'radial';\n  alignType?: 'leaf' | 'depth';\n  /**\n   * Specify the width of link, if not specified,\n   * Compute the depth-most nodes for extents.\n   */\n  linkWidth?: number | number[];\n  /**\n   * Specify the min gap between two sibling nodes, if not specified, scale nodeGap based on the extent.\n   */\n  minNodeGap?: number;\n  /** parse the key of node */\n  nodeKey?: string | number | ((datum: HierarchicalDatum) => string | number);\n}\n\nexport type TreeTramsformOptions = TreeOptions & ViewBoxOptions & { flatten?: boolean; maxDepth?: number };\n\nexport interface TreeNodeElement extends HierarchicalNodeElement<HierarchicalDatum> {\n  children?: TreeNodeElement[];\n  x?: number;\n  y?: number;\n}\n\nexport interface TreeLinkElement {\n  source: TreeNodeElement;\n  target: TreeNodeElement;\n  x0?: number;\n  y0?: number;\n  x1?: number;\n  y1?: number;\n  key?: string;\n}\n"]}