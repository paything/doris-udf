"use strict";

function updateResizeRow(xInTable, yInTable, state) {
    xInTable = Math.ceil(xInTable), yInTable = Math.ceil(yInTable);
    let detaY = state.rowResize.isBottomFrozen ? state.rowResize.y - yInTable : yInTable - state.rowResize.y;
    if (Math.abs(detaY) < 1) return;
    let height = state.table.getRowHeight(state.rowResize.row);
    height += detaY;
    let afterSize = state.table.getRowHeight(state.rowResize.row) + detaY;
    if (afterSize < state.table.internalProps.limitMinHeight && (afterSize = state.table.internalProps.limitMinHeight, 
    detaY = afterSize - state.table.getRowHeight(state.rowResize.row)), "adaptive" === state.table.heightMode && state.rowResize.row < state.table.rowCount - 1) {
        let bottomRowHeight = state.table.getRowHeight(state.rowResize.row + 1);
        bottomRowHeight -= detaY, bottomRowHeight - detaY < state.table.internalProps.limitMinHeight && (detaY = bottomRowHeight - state.table.internalProps.limitMinHeight);
    }
    detaY = Math.ceil(detaY), state.rowResize.row < state.table.columnHeaderLevelCount || state.rowResize.row >= state.table.rowCount - state.table.bottomFrozenRowCount ? updateResizeColForRow(detaY, state) : "indicator" === state.table.internalProps.rowResizeType ? updateResizeColForIndicator(detaY, state) : "indicatorGroup" === state.table.internalProps.rowResizeType ? updateResizeColForIndicatorGroup(detaY, state) : "all" === state.table.internalProps.rowResizeType ? updateResizeColForAll(detaY, state) : updateResizeColForRow(detaY, state), 
    state.rowResize.y = yInTable, state.table.scenegraph.component.updateResizeRow(state.rowResize.row, xInTable, state.rowResize.isBottomFrozen), 
    state.table.scenegraph.updateNextFrame();
}

function updateResizeColForRow(detaY, state) {
    "adaptive" === state.table.heightMode && state.rowResize.row < state.table.rowCount - 1 ? (state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY), 
    state.table.scenegraph.updateRowHeight(state.rowResize.row + 1, -detaY), state.table.internalProps._heightResizedRowMap.add(state.rowResize.row), 
    state.table.internalProps._heightResizedRowMap.add(state.rowResize.row + 1)) : (state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY), 
    state.table.internalProps._heightResizedRowMap.add(state.rowResize.row));
}

function updateResizeColForAll(detaY, state) {
    for (let row = state.table.frozenRowCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) state.table.scenegraph.updateRowHeight(row, detaY), 
    state.table.internalProps._heightResizedRowMap.add(row);
}

function updateResizeColForIndicator(detaY, state) {
    var _a, _b;
    const layout = state.table.internalProps.layoutMap;
    let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue;
    if (layout.indicatorsAsCol) {
        const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, state.rowResize.row), headerPath = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a[headerPaths.rowHeaderPaths.length - 1];
        resizeDimensionKey = null == headerPath ? void 0 : headerPath.dimensionKey, resizeDimensionValue = null == headerPath ? void 0 : headerPath.value;
    } else resizeIndicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, state.rowResize.row);
    for (let row = state.table.columnHeaderLevelCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) {
        const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, row);
        if (layout.indicatorsAsCol || indicatorKey !== resizeIndicatorKey) {
            if (layout.indicatorsAsCol) {
                const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, row), headerPath = null === (_b = null == headerPaths ? void 0 : headerPaths.rowHeaderPaths) || void 0 === _b ? void 0 : _b[headerPaths.rowHeaderPaths.length - 1];
                headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value && (state.table.scenegraph.updateRowHeight(row, detaY), 
                state.table.internalProps._heightResizedRowMap.add(row));
            }
        } else state.table.scenegraph.updateRowHeight(row, detaY), state.table.internalProps._heightResizedRowMap.add(row);
    }
}

function updateResizeColForIndicatorGroup(detaY, state) {
    const layout = state.table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount, state.rowResize.row), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1)), startRow = node.startInTotal + state.table.frozenRowCount, endRow = node.startInTotal + state.table.frozenRowCount + node.size - 1, totalRowHeight = state.table.getRowsHeight(startRow, endRow), moveY = detaY;
    for (let row = startRow; row <= endRow; row++) {
        let deltaHeight = state.table.getRowHeight(row) / totalRowHeight * moveY;
        deltaHeight > 0 && deltaHeight < .5 ? deltaHeight = .5 : deltaHeight < 0 && deltaHeight >= -.5 && (deltaHeight = -.51), 
        state.table.scenegraph.updateRowHeight(row, deltaHeight), state.table.internalProps._heightResizedRowMap.add(row);
    }
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.updateResizeRow = void 0, exports.updateResizeRow = updateResizeRow;
//# sourceMappingURL=update-resize-row.js.map
