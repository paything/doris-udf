"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.endMoveCol = exports.updateMoveCol = exports.startMoveCol = void 0;

const TABLE_EVENT_TYPE_1 = require("../../core/TABLE_EVENT_TYPE"), adjust_header_1 = require("./adjust-header");

function startMoveCol(col, row, x, y, state, event) {
    var _a;
    if (!("canMoveHeaderPosition" in state.table.internalProps.layoutMap)) return;
    state.columnMove.moving = !0, state.columnMove.colSource = col, state.columnMove.rowSource = row, 
    state.columnMove.x = x - state.table.tableX, state.columnMove.y = y - state.table.tableY;
    const cellLocation = state.table.getCellLocation(col, row), delta = "columnHeader" === cellLocation ? state.columnMove.x : "rowHeader" === cellLocation || state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row) ? state.columnMove.y : 0, {backX: backX, lineX: lineX, backY: backY, lineY: lineY} = state.table.scenegraph.component.showMoveCol(col, row, delta);
    state.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_START, {
        col: col,
        row: row,
        x: x,
        y: y,
        backX: backX,
        lineX: lineX,
        backY: backY,
        lineY: lineY,
        event: event
    });
    const isHasSelected = !!(null === (_a = state.select.ranges) || void 0 === _a ? void 0 : _a.length);
    state.table.stateManager.updateSelectPos(-1, -1), state.table.stateManager.endSelectCells(!0, isHasSelected), 
    state.table.scenegraph.updateNextFrame();
}

function updateMoveCol(col, row, x, y, state, event) {
    if (!("canMoveHeaderPosition" in state.table.internalProps.layoutMap)) return;
    const targetCell = (0, adjust_header_1.adjustMoveHeaderTarget)({
        col: state.columnMove.colSource,
        row: state.columnMove.rowSource
    }, {
        col: col,
        row: row
    }, state.table);
    if (state.table.internalProps.layoutMap.canMoveHeaderPosition({
        col: state.columnMove.colSource,
        row: state.columnMove.rowSource
    }, {
        col: targetCell.col,
        row: targetCell.row
    })) {
        let lineX, backX, lineY, backY;
        state.columnMove.x = x - state.table.tableX, state.columnMove.y = y - state.table.tableY, 
        state.columnMove.colTarget = targetCell.col, state.columnMove.rowTarget = targetCell.row, 
        state.updateCursor("grabbing");
        const cellLocation = state.table.getCellLocation(state.columnMove.colSource, state.columnMove.rowSource);
        "columnHeader" === cellLocation ? (backX = state.columnMove.x, lineX = state.table.isLeftFrozenColumn(col) ? state.columnMove.colTarget >= state.columnMove.colSource ? state.table.getColsWidth(0, state.columnMove.colTarget) : state.table.getColsWidth(0, state.columnMove.colTarget - 1) : state.table.isRightFrozenColumn(col) ? state.table.tableNoFrameWidth - state.table.getColsWidth(targetCell.col + 1, state.table.colCount - 1) : (state.columnMove.colTarget >= state.columnMove.colSource ? state.table.getColsWidth(0, state.columnMove.colTarget) : state.table.getColsWidth(0, state.columnMove.colTarget - 1)) - state.table.stateManager.scroll.horizontalBarPos) : ("rowHeader" === cellLocation || state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) && (backY = state.columnMove.y, 
        lineY = state.table.isFrozenRow(row) ? state.columnMove.rowTarget >= state.columnMove.rowSource ? state.table.getRowsHeight(0, state.columnMove.rowTarget) : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1) : state.table.isBottomFrozenRow(row) ? state.table.tableNoFrameHeight - state.table.getRowsHeight(targetCell.row + 1, state.table.rowCount - 1) : (state.columnMove.rowTarget >= state.columnMove.rowSource ? state.table.getRowsHeight(0, state.columnMove.rowTarget) : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1)) - state.table.stateManager.scroll.verticalBarPos), 
        state.table.scenegraph.component.updateMoveCol(backX, lineX, backY, lineY), state.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CHANGING_HEADER_POSITION, {
            col: col,
            row: row,
            x: x,
            y: y,
            backX: backX,
            lineX: lineX,
            backY: backY,
            lineY: lineY,
            event: event
        }), state.table.scenegraph.updateNextFrame();
    } else state.updateCursor("not-allowed"), state.columnMove.colTarget = state.columnMove.colSource, 
    state.columnMove.rowTarget = state.columnMove.rowSource;
}

function endMoveCol(state) {
    var _a, _b;
    let moveColResult = !1;
    if ("canMoveHeaderPosition" in state.table.internalProps.layoutMap && state.columnMove.moving && state.columnMove.colSource >= 0 && state.columnMove.rowSource >= 0 && state.columnMove.colTarget >= 0 && state.columnMove.rowTarget >= 0 && !0 !== (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a.notUpdateInColumnRowMove)) {
        const oldSourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource), oldTargetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget), moveContext = state.table._moveHeaderPosition({
            col: state.columnMove.colSource,
            row: state.columnMove.rowSource
        }, {
            col: state.columnMove.colTarget,
            row: state.columnMove.rowTarget
        });
        if (!moveContext || moveContext.targetIndex === moveContext.sourceIndex) return state.updateCursor(), 
        state.columnMove.moving = !1, delete state.columnMove.colSource, delete state.columnMove.rowSource, 
        delete state.columnMove.colTarget, delete state.columnMove.rowTarget, state.table.scenegraph.component.hideMoveCol(), 
        state.table.scenegraph.updateNextFrame(), !1;
        {
            state.table.internalProps.useOneRowHeightFillAll = !1, state.table.internalProps.layoutMap.clearCellRangeMap();
            const sourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource), targetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget), colMin = Math.min(sourceMergeInfo.start.col, targetMergeInfo.start.col, oldSourceMergeInfo.start.col, oldTargetMergeInfo.start.col), colMax = Math.max(sourceMergeInfo.end.col, targetMergeInfo.end.col, oldSourceMergeInfo.end.col, oldTargetMergeInfo.end.col), rowMin = Math.min(sourceMergeInfo.start.row, targetMergeInfo.start.row, oldSourceMergeInfo.start.row, oldTargetMergeInfo.start.row);
            let rowMax = Math.max(sourceMergeInfo.end.row, targetMergeInfo.end.row, oldSourceMergeInfo.end.row, oldTargetMergeInfo.end.row);
            "row" === moveContext.moveType && "tree" === state.table.internalProps.layoutMap.rowHierarchyType && (rowMax = moveContext.targetIndex > moveContext.sourceIndex ? rowMax + moveContext.targetSize - 1 : rowMax + moveContext.sourceSize - 1), 
            !state.table.transpose && state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource) && (state.table.changeRecordOrder(moveContext.sourceIndex, moveContext.targetIndex), 
            state.changeCheckboxAndRadioOrder(moveContext.sourceIndex, moveContext.targetIndex)), 
            "column" === moveContext.moveType ? clearWidthsAndHeightsCache(colMin, colMax, 0, -1, state.table) : clearWidthsAndHeightsCache(0, -1, rowMin, rowMax, state.table), 
            state.table.clearCellStyleCache(), state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource) ? state.table.scenegraph.updateHeaderPosition(state.table.scenegraph.proxy.colStart, state.table.scenegraph.proxy.colEnd, state.table.scenegraph.proxy.rowStart, state.table.scenegraph.proxy.rowEnd, moveContext.moveType) : "column" === moveContext.moveType ? state.table.scenegraph.updateHeaderPosition(colMin, colMax, 0, -1, moveContext.moveType) : state.table.scenegraph.updateHeaderPosition(0, -1, rowMin, rowMax, moveContext.moveType), 
            "adjustFrozenCount" === state.table.internalProps.frozenColDragHeaderMode && state.table.isListTable() && (state.table.isLeftFrozenColumn(state.columnMove.colTarget) && !state.table.isLeftFrozenColumn(state.columnMove.colSource) ? state.table.frozenColCount += sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1 : state.table.isLeftFrozenColumn(state.columnMove.colSource) && !state.table.isLeftFrozenColumn(state.columnMove.colTarget) && (state.table.frozenColCount -= sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1), 
            state.table.isRightFrozenColumn(state.columnMove.colTarget) && !state.table.isRightFrozenColumn(state.columnMove.colSource) ? state.table.rightFrozenColCount += sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1 : state.table.isRightFrozenColumn(state.columnMove.colSource) && !state.table.isRightFrozenColumn(state.columnMove.colTarget) && (state.table.rightFrozenColCount -= sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1)), 
            moveColResult = !0;
        }
    }
    return state.columnMove.moving = !1, setTimeout((() => {
        delete state.columnMove.colSource, delete state.columnMove.rowSource, delete state.columnMove.colTarget, 
        delete state.columnMove.rowTarget;
    }), 0), state.table.scenegraph.component.hideMoveCol(), state.columnResize.col < state.table.frozenColCount && !state.table.isPivotTable() && !state.table.transpose ? (state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen), 
    state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount)) : state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount && !state.table.isPivotTable() && !state.table.transpose ? state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount) : state.table.options.frozenColCount ? state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1) : state.table.options.rightFrozenColCount && state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount), 
    state.table.scenegraph.updateNextFrame(), !0 === (null === (_b = state.table.options.customConfig) || void 0 === _b ? void 0 : _b.notUpdateInColumnRowMove) || moveColResult;
}

function clearWidthsAndHeightsCache(colMin, colMax, rowMin, rowMax, table) {
    for (let col = colMin; col <= colMax; col++) table._clearColRangeWidthsMap(col);
    for (let row = rowMin; row <= rowMax; row++) table._clearRowRangeHeightsMap(row);
}

exports.startMoveCol = startMoveCol, exports.updateMoveCol = updateMoveCol, exports.endMoveCol = endMoveCol;
//# sourceMappingURL=index.js.map
