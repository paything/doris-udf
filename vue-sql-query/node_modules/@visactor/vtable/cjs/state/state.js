"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.StateManager = void 0;

const menu_1 = require("../scenegraph/component/menu"), ts_types_1 = require("../ts-types"), ts_types_2 = require("../ts-types"), check_in_select_1 = require("./common/check-in-select"), update_position_1 = require("./hover/update-position"), frozen_1 = require("./frozen"), sort_1 = require("./sort"), update_position_2 = require("./select/update-position"), helper_1 = require("../tools/helper"), PIVOT_TABLE_EVENT_TYPE_1 = require("../ts-types/pivot-table/PIVOT_TABLE_EVENT_TYPE"), TABLE_EVENT_TYPE_1 = require("../core/TABLE_EVENT_TYPE"), vutils_1 = require("@visactor/vutils"), drill_1 = require("./drill"), spark_line_1 = require("./spark-line"), cell_move_1 = require("./cell-move"), icon_1 = require("../scenegraph/utils/icon"), debounce_1 = require("../tools/debounce"), update_resize_column_1 = require("./resize/update-resize-column"), radio_1 = require("./radio/radio"), checkbox_1 = require("./checkbox/checkbox"), update_resize_row_1 = require("./resize/update-resize-row"), delete_select_border_1 = require("../scenegraph/select/delete-select-border"), util_1 = require("../tools/util"), custom_select_1 = require("./select/custom-select"), merge_range_1 = require("../tools/merge-range");

class StateManager {
    constructor(table) {
        this.fastScrolling = !1, this.checkedState = new Map, this.headerCheckedState = {}, 
        this._checkboxCellTypeFields = [], this._headerCheckFuncs = {}, this.radioState = {}, 
        this.resetInteractionState = (0, debounce_1.debounce)((state => {
            this.updateInteractionState(null != state ? state : ts_types_1.InteractionState.default);
        }), 100), this.table = table, this.initState(), this.updateVerticalScrollBar = this.updateVerticalScrollBar.bind(this), 
        this.updateHorizontalScrollBar = this.updateHorizontalScrollBar.bind(this);
    }
    initState() {
        this._initState(), this.setHoverState(), this.setSelectState(), this.setFrozenState();
    }
    updateOptionSetState() {
        this._updateOptionSetState(), this.setHoverState(), this.setSelectState(), this.setFrozenState();
    }
    _updateOptionSetState() {
        this.interactionState = ts_types_1.InteractionState.default, this.hoverIcon = {
            col: -1,
            row: -1,
            icon: null
        }, this.columnResize = {
            col: -1,
            x: 0,
            resizing: !1
        }, this.rowResize = {
            row: -1,
            y: 0,
            resizing: !1
        }, this.columnMove = {
            colSource: -1,
            colTarget: -1,
            rowSource: -1,
            rowTarget: -1,
            x: 0,
            y: 0,
            moving: !1
        }, this.menu = {
            x: -1,
            y: -1,
            isShow: !1,
            itemList: [],
            bounds: new vutils_1.Bounds,
            highlightIndex: -1,
            dropDownMenuHighlight: []
        }, this.sort = [ {
            col: -1,
            row: -1,
            order: "normal"
        } ], this.frozen = {
            col: -1,
            row: -1
        }, this.tablePosition = {
            absoluteX: 0,
            absoluteY: 0
        }, this.drill = {
            col: -1,
            row: -1
        }, this.sparkLine = {
            col: -1,
            row: -1
        };
    }
    _initState() {
        this.interactionState = ts_types_1.InteractionState.default, this.select = {
            highlightScope: ts_types_1.HighlightScope.single,
            ranges: [],
            cellPos: {
                col: -1,
                row: -1
            },
            selecting: !1
        }, this.fillHandle = {
            isFilling: !1,
            startX: void 0,
            startY: void 0
        }, this.hover = {
            highlightScope: ts_types_1.HighlightScope.single,
            cellPos: {
                col: -1,
                row: -1
            }
        }, this.hoverIcon = {
            col: -1,
            row: -1,
            icon: null
        }, this.columnResize = {
            col: -1,
            x: 0,
            resizing: !1
        }, this.rowResize = {
            row: -1,
            y: 0,
            resizing: !1
        }, this.columnMove = {
            colSource: -1,
            colTarget: -1,
            rowSource: -1,
            rowTarget: -1,
            x: 0,
            y: 0,
            moving: !1
        }, this.menu = {
            x: -1,
            y: -1,
            isShow: !1,
            itemList: [],
            bounds: new vutils_1.Bounds,
            highlightIndex: -1,
            dropDownMenuHighlight: []
        }, this.sort = [ {
            col: -1,
            row: -1,
            order: "normal"
        } ], this.frozen = {
            col: -1,
            row: -1
        }, this.scroll = {
            horizontalBarPos: 0,
            verticalBarPos: 0
        }, this.tablePosition = {
            absoluteX: 0,
            absoluteY: 0
        }, this.drill = {
            col: -1,
            row: -1
        }, this.sparkLine = {
            col: -1,
            row: -1
        };
    }
    setHoverState() {
        var _a;
        const {highlightMode: highlightMode, disableHover: disableHover, disableHeaderHover: disableHeaderHover} = null !== (_a = this.table.options.hover) && void 0 !== _a ? _a : {
            highlightMode: "cell"
        };
        disableHover ? this.hover.highlightScope = ts_types_1.HighlightScope.none : "cross" === highlightMode ? this.hover.highlightScope = ts_types_1.HighlightScope.cross : "row" === highlightMode ? this.hover.highlightScope = ts_types_1.HighlightScope.row : "column" === highlightMode ? this.hover.highlightScope = ts_types_1.HighlightScope.column : "cell" === highlightMode && (this.hover.highlightScope = ts_types_1.HighlightScope.single), 
        this.hover.singleStyle = !disableHover, this.hover.disableHeader = disableHeaderHover, 
        (this.hover.highlightScope === ts_types_1.HighlightScope.none || disableHeaderHover) && (this.hover.cellPosContainHeader = {
            col: -1,
            row: -1
        });
    }
    setSelectState() {
        var _a, _b, _c, _d, _e;
        const {headerSelectMode: headerSelectMode, disableSelect: disableSelect, disableHeaderSelect: disableHeaderSelect, highlightMode: highlightMode, highlightInRange: highlightInRange} = Object.assign({}, {
            headerSelectMode: "inline",
            disableSelect: !1,
            disableHeaderSelect: !1,
            highlightMode: "cell",
            highlightInRange: !1
        }, this.table.options.select), cornerHeaderSelectMode = (null === (_a = this.table.options.select) || void 0 === _a ? void 0 : _a.cornerHeaderSelectMode) ? null === (_b = this.table.options.select) || void 0 === _b ? void 0 : _b.cornerHeaderSelectMode : "body" === (null === (_c = this.table.options.select) || void 0 === _c ? void 0 : _c.headerSelectMode) ? null === (_d = this.table.options.select) || void 0 === _d ? void 0 : _d.headerSelectMode : "all";
        this.select.highlightScope = !0 === disableSelect ? ts_types_1.HighlightScope.none : "cross" === highlightMode ? ts_types_1.HighlightScope.cross : "row" === highlightMode ? ts_types_1.HighlightScope.row : "column" === highlightMode ? ts_types_1.HighlightScope.column : ts_types_1.HighlightScope.single, 
        this.select.singleStyle = !disableSelect, this.select.disableHeader = disableHeaderSelect, 
        this.select.headerSelectMode = headerSelectMode, this.select.cornerHeaderSelectMode = cornerHeaderSelectMode, 
        this.select.highlightInRange = highlightInRange, this.select.disableCtrlMultiSelect = !1 === (null === (_e = this.table.options.keyboardOptions) || void 0 === _e ? void 0 : _e.ctrlMultiSelect);
    }
    isSelected(col, row) {
        let seled = !1;
        return this.select.ranges.forEach((range => {
            (0, helper_1.cellInRange)(range, col, row) && (seled = !0);
        })), seled;
    }
    setSortState(sortState) {
        const state = this;
        const sort = (sortState = !sortState || Array.isArray(sortState) ? sortState : [ sortState ]) && sortState.reduce(((prev, item) => {
            var _a, _b, _c;
            const column = null === (_a = function(columns) {
                const result = [];
                return function flatten(cols, parentStartIndex = 0) {
                    cols.forEach((col => {
                        var _a;
                        const startIndex = col.startInTotal ? null !== (_a = col.startInTotal + state.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _a ? _a : 0 : parentStartIndex;
                        col.columns ? flatten(col.columns, startIndex) : result.push(Object.assign(Object.assign({}, col), {
                            startIndex: startIndex
                        }));
                    }));
                }(columns), result;
            }(this.table.internalProps.columns)) || void 0 === _a ? void 0 : _a.find((column => (null == column ? void 0 : column.field) === (null == item ? void 0 : item.field)));
            return this.table.internalProps.transpose ? prev.push({
                field: item.field,
                order: item.order,
                row: null !== (_b = (null == column ? void 0 : column.startInTotal) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _b ? _b : 0,
                col: null == column ? void 0 : column.level
            }) : prev.push({
                field: item.field,
                order: item.order,
                col: null !== (_c = (null == column ? void 0 : column.startInTotal) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _c ? _c : 0,
                row: null == column ? void 0 : column.level
            }), prev;
        }), []);
        this.sort = sort || [];
    }
    setFrozenState() {
        this.frozen.col = this.table.frozenColCount - 1;
    }
    updateInteractionState(mode) {
        if (this.interactionState === mode) return;
        mode === ts_types_1.InteractionState.scrolling && (this.interactionStateBeforeScroll = this.interactionState);
        const oldState = this.interactionState;
        this.interactionState = mode, oldState === ts_types_1.InteractionState.scrolling && ts_types_1.InteractionState.default;
    }
    updateHoverhighlightScope(mode) {
        this.hover.highlightScope !== mode && (this.hover.highlightScope = mode);
    }
    updateHoverPos(col, row) {
        (0, update_position_1.updateHoverPosition)(this, col, row);
    }
    updateSelectPos(col, row, isShift = !1, isCtrl = !1, isSelectAll = !1, makeSelectCellVisible = !0, skipBodyMerge = !1) {
        -1 !== row && -1 !== row && (this.select.selecting = !0), col < 0 && (col = -1), 
        row < 0 && (row = -1), col > this.table.colCount - 1 && (col = this.table.colCount - 1), 
        row > this.table.rowCount - 1 && (row = this.table.rowCount - 1), (0, update_position_2.updateSelectPosition)(this, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible, skipBodyMerge);
    }
    checkCellRangeInSelect(cellPosStart, cellPosEnd) {
        return (0, check_in_select_1.checkMultiCellInSelect)(cellPosStart, cellPosEnd, this.select.ranges, this.select.highlightScope);
    }
    updateHoverIcon(col, row, target, cellGroup) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if ((null === (_a = this.residentHoverIcon) || void 0 === _a ? void 0 : _a.icon) && target === (null === (_b = this.residentHoverIcon) || void 0 === _b ? void 0 : _b.icon)) return;
        const iconInfo = (0, icon_1.getIconAndPositionFromTarget)(target);
        if (iconInfo) if ("richtext-icon" === iconInfo.type) {
            const inlineIcon = iconInfo.icon;
            if (this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_d = this.residentHoverIcon) || void 0 === _d ? void 0 : _d.icon) && (this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), 
            this.hoverIcon.col = -1, this.hoverIcon.col = -1, this.hoverIcon.icon = null, this.table.scenegraph.updateNextFrame()), 
            inlineIcon.attribute.tooltip) {
                const tooltipOptions = {
                    content: inlineIcon.attribute.tooltip.title,
                    referencePosition: {
                        rect: iconInfo.position,
                        placement: inlineIcon.attribute.tooltip.placement
                    },
                    style: Object.assign({}, null === (_e = this.table.internalProps.theme) || void 0 === _e ? void 0 : _e.tooltipStyle, null === (_f = inlineIcon.tooltip) || void 0 === _f ? void 0 : _f.style, null === (_h = null === (_g = inlineIcon.attribute) || void 0 === _g ? void 0 : _g.tooltip) || void 0 === _h ? void 0 : _h.style),
                    disappearDelay: inlineIcon.attribute.tooltip.disappearDelay
                };
                this.table.internalProps.tooltipHandler.isBinded(tooltipOptions) || this.table.showTooltip(col, row, tooltipOptions);
            }
        } else {
            const icon = iconInfo.icon;
            icon !== this.hoverIcon.icon && (this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_j = this.residentHoverIcon) || void 0 === _j ? void 0 : _j.icon) && this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), 
            this.hoverIcon.col = col, this.hoverIcon.row = row, this.hoverIcon.icon = icon, 
            this.table.scenegraph.setIconHoverStyle(icon, col, row, cellGroup), this.table.scenegraph.updateNextFrame());
        } else this.hoverIcon.icon && this.hoverIcon.icon !== (null === (_c = this.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) && (this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row), 
        this.hoverIcon.col = -1, this.hoverIcon.col = -1, this.hoverIcon.icon = null, this.table.scenegraph.updateNextFrame());
    }
    isResizeCol() {
        return this.columnResize.resizing;
    }
    isResizeRow() {
        return this.rowResize.resizing;
    }
    isFillHandle() {
        return this.fillHandle.isFilling;
    }
    isSelecting() {
        return this.select.selecting;
    }
    endSelectCells(fireListener = !0, fireClear = !0) {
        if (this.select.selecting) {
            if (this.select.selecting = !1, 0 === this.select.ranges.length) return;
            const currentRange = this.select.ranges[this.select.ranges.length - 1];
            this.table.isSeriesNumber(this.select.cellPos.col, this.select.cellPos.row) || this.table.isHeader(this.select.cellPos.col, this.select.cellPos.row) || (0, 
            merge_range_1.expendCellRange)(currentRange, this.table);
            let isSame = !1;
            for (let i = 0; i < this.select.ranges.length - 1; i++) {
                const range = this.select.ranges[i];
                if (range && range.start.col === currentRange.start.col && range.start.row === currentRange.start.row && range.end.col === currentRange.end.col && range.end.row === currentRange.end.row) {
                    isSame = !0;
                    break;
                }
            }
            isSame ? (this.select.ranges.pop(), (0, delete_select_border_1.deleteAllSelectingBorder)(this.table.scenegraph), 
            this.table.scenegraph.selectingRangeComponents.clear()) : (0, update_position_2.selectEnd)(this.table.scenegraph);
            const lastCol = this.select.ranges[this.select.ranges.length - 1].end.col, lastRow = this.select.ranges[this.select.ranges.length - 1].end.row;
            fireListener && this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SELECTED_CELL, {
                ranges: this.select.ranges,
                col: lastCol,
                row: lastRow
            });
        } else fireClear && 0 === this.select.ranges.length && this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SELECTED_CLEAR, {});
    }
    endResizeCol() {
        setTimeout((() => {
            this.columnResize.resizing = !1;
        }), 0), this.table.scenegraph.updateChartSizeForResizeColWidth(this.columnResize.col), 
        this.checkFrozen(), this.table.scenegraph.component.hideResizeCol(), this.table.scenegraph.updateNextFrame();
    }
    startResizeCol(col, x, y, isRightFrozen) {
        this.columnResize.resizing = !0, this.columnResize.col = col, this.columnResize.x = x, 
        this.columnResize.isRightFrozen = isRightFrozen, this.table.scenegraph.component.showResizeCol(col, y, isRightFrozen), 
        this.table.scenegraph.updateNextFrame();
    }
    updateResizeCol(xInTable, yInTable) {
        (0, update_resize_column_1.updateResizeColumn)(xInTable, yInTable, this);
    }
    endResizeRow() {
        setTimeout((() => {
            this.rowResize.resizing = !1;
        }), 0), this.table.scenegraph.updateChartSizeForResizeRowHeight(this.rowResize.row), 
        this.table.scenegraph.component.hideResizeRow(), this.table.scenegraph.updateNextFrame();
    }
    startResizeRow(row, x, y, isBottomFrozen) {
        this.rowResize.resizing = !0, this.rowResize.row = row, this.rowResize.y = y, this.rowResize.isBottomFrozen = isBottomFrozen, 
        this.table.scenegraph.component.showResizeRow(row, x, isBottomFrozen), this.table.scenegraph.updateNextFrame();
    }
    updateResizeRow(xInTable, yInTable) {
        (0, update_resize_row_1.updateResizeRow)(xInTable, yInTable, this);
    }
    startFillSelect(x, y) {
        this.fillHandle.isFilling = !0, this.fillHandle.startX = x, this.fillHandle.startY = y;
        const currentRange = this.select.ranges[this.select.ranges.length - 1];
        this.fillHandle.beforeFillMinCol = Math.min(currentRange.start.col, currentRange.end.col), 
        this.fillHandle.beforeFillMinRow = Math.min(currentRange.start.row, currentRange.end.row), 
        this.fillHandle.beforeFillMaxCol = Math.max(currentRange.start.col, currentRange.end.col), 
        this.fillHandle.beforeFillMaxRow = Math.max(currentRange.start.row, currentRange.end.row), 
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.MOUSEDOWN_FILL_HANDLE, {});
    }
    endFillSelect() {
        this.fillHandle.isFilling = !1, this.fillHandle.startX = void 0, this.fillHandle.startY = void 0, 
        this.fillHandle.directionRow = void 0;
        const currentMinCol = Math.min(this.select.ranges[0].start.col, this.select.ranges[0].end.col), currentMinRow = Math.min(this.select.ranges[0].start.row, this.select.ranges[0].end.row), currentMaxCol = Math.max(this.select.ranges[0].start.col, this.select.ranges[0].end.col), currentMaxRow = Math.max(this.select.ranges[0].start.row, this.select.ranges[0].end.row);
        this.fillHandle.beforeFillMinCol === currentMinCol && this.fillHandle.beforeFillMinRow === currentMinRow && this.fillHandle.beforeFillMaxCol === currentMaxCol && this.fillHandle.beforeFillMaxRow === currentMaxRow || this.table.eventManager.isDraging && this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.DRAG_FILL_HANDLE_END, {
            direction: this.fillHandle.direction
        }), this.fillHandle.beforeFillMaxCol = void 0, this.fillHandle.beforeFillMaxRow = void 0, 
        this.fillHandle.beforeFillMinCol = void 0, this.fillHandle.beforeFillMinRow = void 0;
    }
    startMoveCol(col, row, x, y, event) {
        (0, cell_move_1.startMoveCol)(col, row, x, y, this, event);
    }
    updateMoveCol(col, row, x, y, event) {
        (0, cell_move_1.updateMoveCol)(col, row, x, y, this, event);
    }
    isMoveCol() {
        return this.columnMove.moving;
    }
    endMoveCol() {
        return (0, cell_move_1.endMoveCol)(this);
    }
    checkFrozen() {
        var _a;
        let originalFrozenColCount = this.table.options.frozenColCount ? this.table.options.frozenColCount : this.table.isPivotTable() || this.table.isListTable() && this.table.internalProps.transpose ? (null !== (_a = this.table.rowHeaderLevelCount) && void 0 !== _a ? _a : 0) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount : 0;
        if (originalFrozenColCount) {
            originalFrozenColCount > this.table.colCount && (originalFrozenColCount = this.table.colCount);
            const maxFrozenWidth = this.table._getMaxFrozenWidth();
            if (this.table.getColsWidth(0, originalFrozenColCount - 1) > maxFrozenWidth) if (this.table.internalProps.unfreezeAllOnExceedsMaxWidth) this.table._setFrozenColCount(0), 
            this.setFrozenCol(-1); else {
                const computedFrozenColCount = this.table._getComputedFrozenColCount(originalFrozenColCount);
                this.table._setFrozenColCount(computedFrozenColCount), this.setFrozenCol(computedFrozenColCount);
            } else this.table.frozenColCount !== originalFrozenColCount && (this.table._setFrozenColCount(originalFrozenColCount), 
            this.setFrozenCol(originalFrozenColCount));
        }
    }
    setFrozenCol(col) {
        col !== this.frozen.col ? (this.frozen.col = col, this.table.scenegraph.updateFrozen(), 
        this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1)) : this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1);
    }
    setFrozenRow(row) {
        row !== this.frozen.row && (this.frozen.row = row, this.table.scenegraph.updateRowFrozen());
    }
    checkVerticalScrollBarEnd() {
        var _a, _b;
        const totalHeight = this.table.getAllRowsHeight(), scrollTop = this.scroll.verticalBarPos, viewHeight = this.table.tableNoFrameHeight;
        scrollTop + viewHeight >= totalHeight && this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL_VERTICAL_END, {
            scrollTop: scrollTop,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
            scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
            viewHeight: viewHeight,
            viewWidth: this.table.tableNoFrameWidth
        });
    }
    checkHorizontalScrollBarEnd() {
        var _a, _b;
        const totalWidth = this.table.getAllColsWidth(), scrollLeft = this.scroll.horizontalBarPos, viewWidth = this.table.tableNoFrameWidth;
        scrollLeft + viewWidth >= totalWidth && this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL_HORIZONTAL_END, {
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: scrollLeft,
            scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
            scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: viewWidth
        });
    }
    updateVerticalScrollBar(yRatio) {
        var _a, _b, _c, _d;
        const totalHeight = this.table.getAllRowsHeight(), oldVerticalBarPos = this.scroll.verticalBarPos;
        let verticalBarPos = Math.ceil(yRatio * (totalHeight - this.table.scenegraph.height));
        (0, vutils_1.isValid)(verticalBarPos) && !isNaN(verticalBarPos) || (verticalBarPos = 0);
        const dy = verticalBarPos - this.table.scenegraph.proxy.deltaY - oldVerticalBarPos;
        if (this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CAN_SCROLL, {
            event: void 0,
            scrollTop: verticalBarPos - this.table.scenegraph.proxy.deltaY,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
            scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "vertical",
            scrollRatioY: yRatio,
            dy: dy
        }).some((value => !1 === value))) {
            const yRatio = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
            this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
        } else this.scroll.verticalBarPos = verticalBarPos, this.table.scenegraph.setY(-this.scroll.verticalBarPos, 1 === yRatio), 
        this.scroll.verticalBarPos -= this.table.scenegraph.proxy.deltaY, this.table.scenegraph.proxy.deltaY = 0, 
        this.updateHoverPos(-1, -1), this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL, {
            event: void 0,
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_c = this.table.theme.scrollStyle) || void 0 === _c ? void 0 : _c.width,
            scrollWidth: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "vertical",
            scrollRatioY: yRatio,
            dy: dy
        }), oldVerticalBarPos !== this.scroll.verticalBarPos && this.checkVerticalScrollBarEnd();
    }
    updateHorizontalScrollBar(xRatio) {
        var _a, _b, _c, _d;
        const totalWidth = this.table.getAllColsWidth(), oldHorizontalBarPos = this.scroll.horizontalBarPos;
        let horizontalBarPos = Math.ceil(xRatio * (totalWidth - this.table.scenegraph.width));
        (0, vutils_1.isValid)(horizontalBarPos) && !isNaN(horizontalBarPos) || (horizontalBarPos = 0);
        const dx = horizontalBarPos - this.table.scenegraph.proxy.deltaX - oldHorizontalBarPos;
        if (this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CAN_SCROLL, {
            event: void 0,
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: horizontalBarPos - this.table.scenegraph.proxy.deltaX,
            scrollHeight: null === (_a = this.table.theme.scrollStyle) || void 0 === _a ? void 0 : _a.width,
            scrollWidth: null === (_b = this.table.theme.scrollStyle) || void 0 === _b ? void 0 : _b.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "horizontal",
            scrollRatioX: xRatio,
            dx: dx
        }).some((value => !1 === value))) {
            const xRatio = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
            this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
        } else this.scroll.horizontalBarPos = horizontalBarPos, this.table.scenegraph.setX(-this.scroll.horizontalBarPos, 1 === xRatio), 
        this.scroll.horizontalBarPos -= this.table.scenegraph.proxy.deltaX, this.table.scenegraph.proxy.deltaX = 0, 
        this.updateHoverPos(-1, -1), this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL, {
            event: void 0,
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_c = this.table.theme.scrollStyle) || void 0 === _c ? void 0 : _c.width,
            scrollWidth: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "horizontal",
            scrollRatioX: xRatio,
            dx: dx
        }), oldHorizontalBarPos !== this.scroll.horizontalBarPos && this.checkHorizontalScrollBarEnd();
    }
    setScrollTop(top, event, triggerEvent = !0) {
        var _a, _b, _c, _d, _e, _f, _g;
        const totalHeight = this.table.getAllRowsHeight(), sizeTolerance = (null === (_a = this.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0;
        top = Math.max(0, Math.min(top, totalHeight - this.table.scenegraph.height - sizeTolerance)), 
        top = Math.ceil(top);
        const oldVerticalBarPos = this.scroll.verticalBarPos, yRatio = top / (totalHeight - this.table.scenegraph.height);
        if ((oldVerticalBarPos !== top || !0 === (null === (_c = null === (_b = this.table.options) || void 0 === _b ? void 0 : _b.customConfig) || void 0 === _c ? void 0 : _c.scrollEventAlwaysTrigger)) && triggerEvent) {
            let verticalBarPos = top;
            (0, vutils_1.isValid)(verticalBarPos) && !isNaN(verticalBarPos) || (verticalBarPos = 0);
            const dy = verticalBarPos - oldVerticalBarPos;
            if (this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CAN_SCROLL, {
                event: null == event ? void 0 : event.nativeEvent,
                scrollTop: verticalBarPos,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
                scrollWidth: null === (_e = this.table.theme.scrollStyle) || void 0 === _e ? void 0 : _e.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: "vertical",
                scrollRatioY: yRatio,
                dy: dy
            }).some((value => !1 === value))) {
                const yRatio = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
                return void this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
            }
        }
        (top !== this.scroll.verticalBarPos || this.table.isPivotChart()) && this.updateHoverPos(-1, -1), 
        this.scroll.verticalBarPos = top, (0, vutils_1.isValid)(this.scroll.verticalBarPos) && !isNaN(this.scroll.verticalBarPos) || (this.scroll.verticalBarPos = 0), 
        this.table.scenegraph.setY(-top), this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
        const dy = this.scroll.verticalBarPos - oldVerticalBarPos;
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL, {
            event: null == event ? void 0 : event.nativeEvent,
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_f = this.table.theme.scrollStyle) || void 0 === _f ? void 0 : _f.width,
            scrollWidth: null === (_g = this.table.theme.scrollStyle) || void 0 === _g ? void 0 : _g.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "vertical",
            scrollRatioY: yRatio,
            dy: dy
        }), oldVerticalBarPos !== top && triggerEvent && this.checkVerticalScrollBarEnd();
    }
    setScrollLeft(left, event, triggerEvent = !0) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.table.scrollLeft;
        const totalWidth = this.table.getAllColsWidth(), sizeTolerance = (this.table.getFrozenColsWidth(), 
        (null === (_a = this.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0);
        left = Math.max(0, Math.min(left, totalWidth - this.table.scenegraph.width - sizeTolerance)), 
        left = Math.ceil(left);
        const oldHorizontalBarPos = this.scroll.horizontalBarPos, xRatio = left / (totalWidth - this.table.scenegraph.width);
        if ((oldHorizontalBarPos !== left || !0 === (null === (_c = null === (_b = this.table.options) || void 0 === _b ? void 0 : _b.customConfig) || void 0 === _c ? void 0 : _c.scrollEventAlwaysTrigger)) && triggerEvent) {
            let horizontalBarPos = left;
            (0, vutils_1.isValid)(horizontalBarPos) && !isNaN(horizontalBarPos) || (horizontalBarPos = 0);
            const dx = horizontalBarPos - oldHorizontalBarPos;
            if (this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CAN_SCROLL, {
                event: null == event ? void 0 : event.nativeEvent,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: horizontalBarPos,
                scrollHeight: null === (_d = this.table.theme.scrollStyle) || void 0 === _d ? void 0 : _d.width,
                scrollWidth: null === (_e = this.table.theme.scrollStyle) || void 0 === _e ? void 0 : _e.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: "horizontal",
                scrollRatioX: xRatio,
                dx: dx
            }).some((value => !1 === value))) {
                const xRatio = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
                return void this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
            }
        }
        left !== this.scroll.horizontalBarPos && this.updateHoverPos(-1, -1), this.scroll.horizontalBarPos = left, 
        (0, vutils_1.isValid)(this.scroll.horizontalBarPos) && !isNaN(this.scroll.horizontalBarPos) || (this.scroll.horizontalBarPos = 0), 
        this.table.scenegraph.setX(-left), this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
        const dx = this.scroll.horizontalBarPos - oldHorizontalBarPos;
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL, {
            event: null == event ? void 0 : event.nativeEvent,
            scrollTop: this.scroll.verticalBarPos,
            scrollLeft: this.scroll.horizontalBarPos,
            scrollHeight: null === (_f = this.table.theme.scrollStyle) || void 0 === _f ? void 0 : _f.width,
            scrollWidth: null === (_g = this.table.theme.scrollStyle) || void 0 === _g ? void 0 : _g.width,
            viewHeight: this.table.tableNoFrameHeight,
            viewWidth: this.table.tableNoFrameWidth,
            scrollDirection: "horizontal",
            scrollRatioX: xRatio,
            dx: dx
        }), oldHorizontalBarPos !== left && triggerEvent && this.checkHorizontalScrollBarEnd();
    }
    hideVerticalScrollBar() {
        this.table.scenegraph.component.hideVerticalScrollBar();
    }
    showVerticalScrollBar(autoHide) {
        this.table.scenegraph.component.showVerticalScrollBar(), autoHide && (clearTimeout(this._clearVerticalScrollBar), 
        this._clearVerticalScrollBar = setTimeout((() => {
            var _a;
            null === (_a = this.table.scenegraph) || void 0 === _a || _a.component.hideVerticalScrollBar();
        }), 1e3));
    }
    hideHorizontalScrollBar() {
        this.table.scenegraph.component.hideHorizontalScrollBar();
    }
    showHorizontalScrollBar(autoHide) {
        var _a;
        this.table.scenegraph.component.showHorizontalScrollBar(), null === (_a = this.table.scenegraph) || void 0 === _a || _a.component.showFrozenColumnShadow(), 
        autoHide && (clearTimeout(this._clearHorizontalScrollBar), this._clearHorizontalScrollBar = setTimeout((() => {
            var _a, _b;
            null === (_a = this.table.scenegraph) || void 0 === _a || _a.component.hideFrozenColumnShadow(), 
            null === (_b = this.table.scenegraph) || void 0 === _b || _b.component.hideHorizontalScrollBar();
        }), 1e3));
    }
    triggerContextMenu(col, row, x, y) {
        this.menu.isShow && this.menu.x === x && this.menu.y === y ? this.hideMenu() : this.showContextMenu(col, row, x, y);
    }
    showContextMenu(col, row, x, y) {
        var _a;
        (null === (_a = this.table.internalProps.menu) || void 0 === _a ? void 0 : _a.contextMenuItems) && ("html" === this.table.internalProps.menu.renderMode ? this.menu.isShow = !0 : (this.menu.isShow = !0, 
        this.menu.x = x, this.menu.y = y, this.table.scenegraph.component.menu.attach(x, y, col, row, menu_1.MenuType.contextmenu)), 
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SHOW_MENU, {
            x: x,
            y: y,
            col: col,
            row: row,
            type: "contextmenu"
        }));
    }
    triggerDropDownMenu(col, row, x, y, event) {
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.DROPDOWN_ICON_CLICK, {
            col: col,
            row: row,
            event: event
        }), this.menu.isShow ? this.hideMenu() : this.showDropDownMenu(col, row, x, y);
    }
    showDropDownMenu(col, row, x, y) {
        "html" === this.table.internalProps.menu.renderMode ? this.menu.isShow = !0 : (this.menu.isShow = !0, 
        this.table.scenegraph.component.menu.attach(x, y, col, row, menu_1.MenuType.dropDown), 
        this.menu.bounds = this.table.scenegraph.component.menu.bounds), this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SHOW_MENU, {
            x: x,
            y: y,
            col: col,
            row: row,
            type: "dropDown"
        }), this.residentHoverIcon && this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row);
        const cellGroup = this.table.scenegraph.getCell(col, row);
        let icon;
        cellGroup.forEachChildren((child => child.attribute.funcType === ts_types_2.IconFuncTypeEnum.dropDown && (icon = child, 
        !0))), icon && (this.residentHoverIcon = {
            col: col,
            row: row,
            icon: icon
        }, this.table.scenegraph.setIconHoverStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row, cellGroup), 
        this.table.scenegraph.residentHoverIcon(col, row));
    }
    hideMenu() {
        this.menu.isShow && (this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null), 
        this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.HIDE_MENU, null), this.menu.isShow = !1, 
        this.table.scenegraph.component.menu.detach(), this.residentHoverIcon && (this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row), 
        this.table.scenegraph.resetResidentHoverIcon(this.residentHoverIcon.col, this.residentHoverIcon.row), 
        this.residentHoverIcon = null));
    }
    setDropDownMenuHighlight(dropDownMenuInfo) {
        this.menu.dropDownMenuHighlight = dropDownMenuInfo;
        for (let i = 0; i < dropDownMenuInfo.length; i++) {
            const {col: col, row: row} = dropDownMenuInfo[i], range = this.table.getCellRange(col, row);
            if (range) for (let col = range.start.col; col <= range.end.col; col++) for (let row = range.start.row; row <= range.end.row; row++) this.table.scenegraph.updateCellContent(col, row);
        }
    }
    dropDownMenuIsHighlight(colNow, rowNow, index) {
        const highlights = this.menu.dropDownMenuHighlight;
        if (Array.isArray(highlights)) for (let i = 0; i < highlights.length; i++) {
            const highlight = highlights[i];
            let {col: col, row: row} = highlight;
            const {field: field, menuKey: menuKey} = highlight;
            if ("number" != typeof col || "number" != typeof row) if (this.table.isPivotTable() && (Array.isArray(field), 
            1)) {
                const cellAddress = this.table.internalProps.layoutMap.getPivotCellAdress(field);
                if (!cellAddress) continue;
                col = cellAddress.col, row = cellAddress.row;
            } else {
                const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(field);
                if (!cellAddress) continue;
                col = cellAddress.col, row = cellAddress.row;
            }
            if ((0, vutils_1.isValid)(col) && (0, vutils_1.isValid)(row) && this.table.isCellRangeEqual(colNow, rowNow, col, row)) {
                let dropDownMenu = this.table._getHeaderLayoutMap(null != col ? col : colNow, null != row ? row : rowNow).dropDownMenu || this.table.globalDropDownMenu;
                if ("function" == typeof dropDownMenu && (dropDownMenu = dropDownMenu({
                    row: row,
                    col: col,
                    table: this.table
                })), dropDownMenu) for (let i = 0; i < dropDownMenu.length; i++) {
                    const item = dropDownMenu[i];
                    if ((0, vutils_1.isObject)(item) && (item.menuKey || item.text) === (menuKey || "") && i === index) return !0;
                    if ((0, vutils_1.isString)(item) && item === menuKey && i === index) return !0;
                }
            }
        }
        return !1;
    }
    triggerSort(col, row, iconMark, event) {
        if (this.table.isPivotTable()) {
            const sortState = this.table.getPivotSortState(col, row), order = sortState ? sortState.toUpperCase() : "NORMAL", new_order = "ASC" === order ? "DESC" : "DESC" === order ? "NORMAL" : "ASC";
            return this.table.sort(col, row, new_order), void this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.PIVOT_SORT_CLICK, {
                col: col,
                row: row,
                order: order || "normal",
                dimensionInfo: this.table.internalProps.layoutMap.getPivotDimensionInfo(col, row),
                cellLocation: this.table.getCellLocation(col, row),
                event: event
            });
        }
        const previousSort = [ ...this.sort ], previousSortItem = this.table.internalProps.multipleSort || !previousSort.length ? null : this.sort[this.sort.length - 1];
        (0, sort_1.dealSort)(col, row, this.table, event);
        const range = this.table.getCellRange(col, row), currentSortItem = this.sort.find((item => item.col === range.start.col && item.row === range.start.row)), oldSortCol = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.col, oldSortRow = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.row, currentSortItemIndex = previousSort.findIndex((item => item.col === col && item.row === row));
        currentSortItemIndex >= 0 && previousSort.splice(currentSortItemIndex, 1), this.table.scenegraph.updateSortIcon({
            col: col,
            row: row,
            iconMark: iconMark,
            order: null == currentSortItem ? void 0 : currentSortItem.order,
            oldSortCol: oldSortCol,
            oldSortRow: oldSortRow,
            oldIconMark: null == previousSortItem ? void 0 : previousSortItem.icon
        }), currentSortItem && (currentSortItem.icon = iconMark), this.table.internalProps.multipleSort || previousSort.forEach((sortItem => {
            this.table.scenegraph.updateSortIcon({
                col: null,
                row: null,
                iconMark: null,
                order: "normal",
                oldSortCol: sortItem.col,
                oldSortRow: sortItem.row,
                oldIconMark: null
            });
        })), this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.AFTER_SORT, {
            order: null == currentSortItem ? void 0 : currentSortItem.order,
            field: this.table.getHeaderField(col, row),
            event: event
        });
    }
    updateSortState(sortState) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        sortState = Array.isArray(sortState) ? sortState : [ sortState ];
        for (let index = 0; index < sortState.length; index++) {
            if (sortState[index].field === (null === (_a = this.sort[index]) || void 0 === _a ? void 0 : _a.field) && sortState[sortState.length - 1].order === (null === (_b = this.sort[index]) || void 0 === _b ? void 0 : _b.order)) return;
            const oldSortCol = this.table.internalProps.multipleSort ? null : (null === (_c = this.sort[index]) || void 0 === _c ? void 0 : _c.col) || null, oldSortRow = this.table.internalProps.multipleSort ? null : (null === (_d = this.sort[index]) || void 0 === _d ? void 0 : _d.row) || null;
            "asc" === (null === (_e = this.sort[index]) || void 0 === _e ? void 0 : _e.order) || (null === (_f = this.sort[index]) || void 0 === _f || _f.order);
            this.setSortState(sortState.slice(0, index + 1));
            const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(sortState[index].field);
            this.sort[index].col = cellAddress.col, this.sort[index].row = cellAddress.row;
            const cellGroup = this.table.scenegraph.getCell(this.sort[index].col, this.sort[index].row);
            let iconMark;
            (0, util_1.traverseObject)(cellGroup, "children", (mark => "sort" === mark.attribute.funcType && (iconMark = mark, 
            !0))), this.table.scenegraph.updateSortIcon({
                col: this.sort[index].col,
                row: this.sort[index].row,
                iconMark: iconMark,
                order: this.sort[index].order,
                oldSortCol: oldSortCol,
                oldSortRow: oldSortRow,
                oldIconMark: null === (_g = this.sort[index]) || void 0 === _g ? void 0 : _g.icon
            });
        }
        const normalHeaders = [];
        this.table.internalProps.layoutMap.columnTree.tree.children.forEach((item => {
            sortState.some((state => state.field === item.field)) || normalHeaders.push(item);
        }));
        for (let index = 0; index < normalHeaders.length; index++) {
            const column = normalHeaders[index];
            this.table.scenegraph.updateSortIcon({
                col: null,
                row: null,
                iconMark: null,
                order: null,
                oldSortCol: null !== (_h = column.startInTotal + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount) && void 0 !== _h ? _h : 0,
                oldSortRow: column.level,
                oldIconMark: null
            });
        }
    }
    triggerFreeze(col, row, iconMark) {
        if (!this.table.isPivotTable() && !this.table.transpose) {
            if ((0, frozen_1.dealFreeze)(col, row, this.table), this.table.hasListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK)) {
                const fields = this.table.internalProps.layoutMap.columnObjects.slice(0, col + 1);
                this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK, {
                    col: col,
                    row: row,
                    fields: fields.reduce(((pre, cur) => pre.concat(cur.field)), []),
                    colCount: this.table.frozenColCount
                });
            }
            this.frozen.icon = iconMark;
        }
    }
    updateCursor(mode = "default") {
        this.table.getElement().style.cursor = mode;
    }
    updateDrillState(dimensionKey, title, drillDown, drillUp, col, row) {
        this.drill.dimensionKey = dimensionKey, this.drill.title = title, this.drill.drillDown = drillDown, 
        this.drill.drillUp = drillUp, this.drill.col = col, this.drill.row = row, (0, drill_1.updateDrill)(col, row, drillDown, drillUp, this.table);
    }
    updateSparklineHoverPose(col, row, x, y) {
        -1 !== this.sparkLine.col && -1 !== this.sparkLine.row && (0, spark_line_1.clearChartHover)(this.sparkLine.col, this.sparkLine.row, this.table);
        let isUpdated = !1;
        -1 !== col && -1 !== row && (isUpdated = (0, spark_line_1.updateChartHover)(col, row, x, y, this.table)), 
        isUpdated ? (this.sparkLine.col = col, this.sparkLine.row = row) : (this.sparkLine.col = -1, 
        this.sparkLine.row = -1);
    }
    setCheckedState(col, row, field, checked) {
        return (0, checkbox_1.setCheckedState)(col, row, field, checked, this);
    }
    setHeaderCheckedState(field, checked) {
        return (0, checkbox_1.setHeaderCheckedState)(field, checked, this);
    }
    syncCheckedState(col, row, field, checked) {
        return (0, checkbox_1.syncCheckedState)(col, row, field, checked, this);
    }
    initCheckedState(records) {
        return (0, checkbox_1.initCheckedState)(records, this);
    }
    updateHeaderCheckedState(field, col, row) {
        return (0, checkbox_1.updateHeaderCheckedState)(field, this, col, row);
    }
    initLeftRecordsCheckState(records) {
        return (0, checkbox_1.initLeftRecordsCheckState)(records, this);
    }
    setRadioState(col, row, field, radioType, indexInCell) {
        (0, radio_1.setRadioState)(col, row, field, radioType, indexInCell, this);
    }
    syncRadioState(col, row, field, radioType, indexInCell, isChecked) {
        return (0, radio_1.syncRadioState)(col, row, field, radioType, indexInCell, isChecked, this);
    }
    changeCheckboxAndRadioOrder(sourceIndex, targetIndex) {
        this.checkedState.size && (0, checkbox_1.changeCheckboxOrder)(sourceIndex, targetIndex, this), 
        this.radioState.length && (0, radio_1.changeRadioOrder)(sourceIndex, targetIndex, this);
    }
    setCustomSelectRanges(customSelectRanges) {
        (0, custom_select_1.deletaCustomSelectRanges)(this), (0, custom_select_1.addCustomSelectRanges)(customSelectRanges, this);
    }
}

exports.StateManager = StateManager;
//# sourceMappingURL=state.js.map
