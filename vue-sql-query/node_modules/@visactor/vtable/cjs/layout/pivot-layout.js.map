{"version":3,"sources":["../src/layout/pivot-layout.ts"],"names":[],"mappings":"","file":"pivot-layout.js","sourcesContent":["// import type { Dataset } from '../dataset/dataset';\n// import { isValid, transpose } from '../tools/util';\n// import type { HeaderData, IndicatorData, LayoutMapAPI, WidthData } from '../ts-types/list-table/layout-map/api';\n// // import { EmptyDataCache } from './utils';\n// import {\n//   type CellAddress,\n//   type CellRange,\n//   type CellLocation,\n//   type ICornerDefine,\n//   type IDataConfig,\n//   type IDimension,\n//   type IDimensionInfo,\n//   type IHeaderTreeDefine,\n//   type IIndicator,\n//   type IPivotTableCellHeaderPaths,\n//   type ITitleDefine,\n//   type LayoutObjectId,\n//   type ShowColumnRowType,\n//   HierarchyState\n// } from '../ts-types';\n// import type { PivotTable } from '../PivotTable';\n// import { IndicatorDimensionKeyPlaceholder } from '../tools/global';\n// import type { PivotChart } from '../PivotChart';\n// import { cloneDeep, isArray } from '@visactor/vutils';\n// import { getAxisConfigInPivotChart } from './chart-helper/get-axis-config';\n// import { getChartAxes, getChartDataId, getChartSpec, getRawChartSpec } from './chart-helper/get-chart-spec';\n// import type { ITableAxisOption } from '../ts-types/component/axis';\n// import { DimensionTree, type IPivotLayoutHeadNode } from './pivot-layout-helper';\n// import type { ILinkDimension } from '../ts-types/pivot-table/dimension/link-dimension';\n// import type { IImageDimension } from '../ts-types/pivot-table/dimension/image-dimension';\n\n// export const sharedVar = { seqId: 0 };\n// let colIndex = 0;\n\n// import type { TextStyle } from '../body-helper/style';\n// import { getQuadProps } from '../scenegraph/utils/padding';\n// /**\n//  * 简化配置，包含数据处理的 布局辅助计算类\n//  */\n\n// const EMPTY_HEADER: HeaderData = {\n//   isEmpty: true,\n//   id: undefined,\n//   field: undefined,\n//   headerType: undefined,\n//   define: undefined\n// };\n// export class PivotLayoutMap implements LayoutMapAPI {\n//   private _headerObjects: HeaderData[] = [];\n//   private _headerObjectMap: { [key: LayoutObjectId]: HeaderData } = {};\n//   // private _emptyDataCache = new EmptyDataCache();\n//   private _indicatorObjects: IndicatorData[] = [];\n//   private _columnWidths: WidthData[] = [];\n//   rowDimensionTree: DimensionTree;\n//   rowTree: IHeaderTreeDefine[];\n//   columnTree: IHeaderTreeDefine[];\n//   rowsDefine: (IDimension | string)[];\n//   columnsDefine: (IDimension | string)[];\n//   indicatorsDefine: (IIndicator | string)[];\n\n//   indicatorKeys: string[];\n\n//   _showRowHeader = true;\n//   _showColumnHeader = true;\n//   _rowHeaderTitle: ITitleDefine;\n//   _columnHeaderTitle: ITitleDefine;\n//   // transpose: boolean = false;\n//   /**\n//    * 通过indicatorsAsCol和hideIndicatorName判断指标值显示在column还是row 还是根本不显示\n//    */\n//   private _indicatorShowType: ShowColumnRowType = 'column';\n//   indicatorsAsCol = true;\n//   hideIndicatorName = false;\n//   indicatorDimensionKey: string = IndicatorDimensionKeyPlaceholder;\n//   indicatorTitle: string;\n//   /**\n//    * 对应dataset中的rowKeys，行表头的每行表头键值，包含小计总计\n//    */\n//   private rowKeysPath: string[][];\n//   /**\n//    * 对应dataset中的colKeys，列表头的每列表头键值，包含小计总计\n//    */\n//   private colKeysPath: string[][];\n//   /**\n//    * 通过colKeys的二维数组，转置得到。这样就对应单元格横向结构\n//    */\n//   private convertColKeys: string[][];\n\n//   /**\n//    * 对应dataset中的rowAttrs，行表头对应的维度名\n//    */\n//   rows: string[];\n//   /**\n//    * 对应dataset中的colAttrs，列表头对应的维度名\n//    */\n//   columns: string[];\n//   /**\n//    * rowAttrs和指标显示的结合，如果指标显示在行表头，这里会比rowAttrs多一个值\n//    */\n//   private rowShowAttrs: string[];\n//   /**\n//    * rowAttrs和指标显示的结合，如果指标显示在列表头，这里会比colAttrs多一个值\n//    */\n//   private colShowAttrs: string[];\n//   /**\n//    * 对应dataset中的tree，body每一个单元格对应的计算结果\n//    */\n//   tree: any;\n\n//   dataset: Dataset;\n//   dataConfig: IDataConfig;\n\n//   _rowCount: number;\n//   _colCount: number;\n//   _bodyRowCount: number;\n\n//   // dimensions: IDimension[];\n//   cornerSetting: ICornerDefine;\n//   _table: PivotTable | PivotChart;\n\n//   /**层级维度结构显示形式 */\n//   rowHierarchyType?: 'grid' | 'tree';\n//   rowExpandLevel?: number;\n//   rowHierarchyIndent?: number;\n//   //#region pivotChart专有\n//   hasTwoIndicatorAxes: boolean;\n//   /** 图表spec中barWidth的收集 */\n//   _chartItemSpanSize: number;\n//   _chartPaddingInner: number;\n//   _chartPaddingOuter: number;\n//   _chartItemBandSize: number;\n//   _chartPadding?: number | number[];\n//   constructor(table: PivotTable | PivotChart, dataset: Dataset) {\n//     this._table = table;\n//     this._chartItemSpanSize = 0;\n//     this._chartItemBandSize = 0;\n//     this.rowHierarchyType = (table as PivotTable).options.rowHierarchyType;\n//     this.rowExpandLevel = (table as PivotTable).options.rowExpandLevel ?? 1;\n//     this.rowHierarchyIndent = (table as PivotTable).options.rowHierarchyIndent ?? 20;\n//     this.rowTree = table.options.rowTree;\n//     this.columnTree = table.options.columnTree;\n//     this.rowsDefine = table.options.rows ?? [];\n//     this.columnsDefine = table.options.columns ?? [];\n//     this.indicatorsDefine = table.options.indicators ?? [];\n//     this.indicatorTitle = table.options.indicatorTitle;\n//     this.dataset = dataset;\n//     this.dataConfig = dataset.dataConfig;\n//     this.indicatorKeys = dataset.indicatorKeys;\n//     this.indicatorsAsCol = table.options.indicatorsAsCol ?? true;\n//     this.hideIndicatorName = table.options.hideIndicatorName ?? false;\n//     this.showRowHeader = table.options.showRowHeader ?? true;\n//     this.showColumnHeader = table.options.showColumnHeader ?? true;\n//     this.rowHeaderTitle = table.options.rowHeaderTitle;\n//     this.columnHeaderTitle = table.options.columnHeaderTitle;\n//     // this.dimensions = [];\n//     this.cornerSetting = table.options.corner ?? { titleOnDimension: 'column' };\n\n//     this.columns = dataset.columns;\n//     this.rows = dataset.rows;\n//     this.rowKeysPath = dataset.rowKeysPath;\n//     this.colKeysPath = dataset.colKeysPath;\n\n//     this.tree = dataset.tree;\n\n//     if (!this.rowTree) {\n//       this.rowTree = dataset.rowHeaderTree;\n//       this.rowDimensionTree = new DimensionTree(\n//         (this.rowTree as IPivotLayoutHeadNode[]) ?? [],\n//         this.rowHierarchyType,\n//         this.rowExpandLevel\n//       );\n//       const _headerCellIds: any[] = [];\n//       this._addHeadersForTreeMode(\n//         this.rowKeysPath,\n//         0,\n//         this.rowDimensionTree.tree.children,\n//         [],\n//         this.rowDimensionTree.totalLevel,\n//         true,\n//         this.rowsDefine\n//       );\n//       this.rowKeysPath = transpose(this.rowKeysPath);\n//       this._headerObjectMap = this._headerObjects.reduce((o, e) => {\n//         o[e.id as number] = e;\n//         return o;\n//       }, {} as { [key: LayoutObjectId]: HeaderData });\n//     }\n//     this.initState();\n//     this.convertColKeys = transpose(this.colKeysPath);\n//   }\n//   /**\n//    * 初始化该类的计算变量\n//    */\n//   private initState() {\n//     if (this.indicatorsAsCol && !this.hideIndicatorName) {\n//       this._indicatorShowType = 'column';\n//     } else if (!this.indicatorsAsCol && !this.hideIndicatorName) {\n//       this._indicatorShowType = 'row';\n//     } else {\n//       this._indicatorShowType = 'none';\n//     }\n\n//     this.colShowAttrs =\n//       this._indicatorShowType === 'column' ? this.columns.concat(this.indicatorDimensionKey) : Array.from(this.columns);\n//     this.rowShowAttrs =\n//       this._indicatorShowType === 'row' ? this.rows.concat(this.indicatorDimensionKey) : Array.from(this.rows);\n\n//     this._bodyRowCount = this.rowKeysPath.length * (!this.indicatorsAsCol ? this.indicatorKeys.length : 1);\n//     this.initHeaderObjects();\n//     this.initIndicatorObjects();\n//     //#region 处理headerTitle\n//     if (this.rowHeaderTitle) {\n//       const cell_id = 'rowHeaderTitle';\n//       const title =\n//         typeof this.rowHeaderTitle.title === 'string'\n//           ? this.rowHeaderTitle.title\n//           : (this.rowsDefine.reduce((title: string, value) => {\n//               if (typeof value === 'string') {\n//                 return title;\n//               }\n//               return title + (title ? `/${value.title}` : `${value.title}`);\n//             }, '') as string);\n//       this._headerObjectMap[title] = {\n//         id: title,\n//         title,\n//         field: cell_id,\n//         headerType: this.rowHeaderTitle.headerType ?? 'text',\n//         style: this.rowHeaderTitle.headerStyle,\n//         define: <any>{\n//           // id:\n//         }\n//       };\n//       this._headerObjectMap[cell_id] = {\n//         id: cell_id,\n//         title: '',\n//         field: cell_id,\n//         headerType: this.cornerSetting.headerType ?? 'text',\n//         style: this.cornerSetting.headerStyle,\n//         define: <any>{\n//           // id:\n//         }\n//       };\n//       this._headerObjects.push(this._headerObjectMap[title]);\n//       this._headerObjects.push(this._headerObjectMap[cell_id]);\n//       this.rowShowAttrs.unshift(cell_id);\n//       this.rowKeysPath.forEach((rowKey, index) => {\n//         rowKey.unshift(title);\n//       });\n//     }\n//     if (this.columnHeaderTitle) {\n//       const cell_id = 'columnHeaderTitleCell';\n//       const title =\n//         typeof this.columnHeaderTitle.title === 'string'\n//           ? this.columnHeaderTitle.title\n//           : (this.columnsDefine.reduce((title: string, value) => {\n//               if (typeof value === 'string') {\n//                 return title;\n//               }\n//               return title + (title ? `/${value.title}` : `${value.title}`);\n//             }, '') as string);\n//       this._headerObjectMap[title] = {\n//         id: title,\n//         title,\n//         field: cell_id,\n//         headerType: this.columnHeaderTitle.headerType ?? 'text',\n//         style: this.columnHeaderTitle.headerStyle,\n//         define: <any>{\n//           // id:\n//         }\n//       };\n//       this._headerObjectMap[cell_id] = {\n//         id: cell_id,\n//         title: '',\n//         field: cell_id,\n//         headerType: this.cornerSetting.headerType ?? 'text',\n//         style: this.cornerSetting.headerStyle,\n//         define: <any>{\n//           // id:\n//         }\n//       };\n//       this._headerObjects.push(this._headerObjectMap[title]);\n//       this._headerObjects.push(this._headerObjectMap[cell_id]);\n//       this.colShowAttrs.unshift(cell_id);\n//       this.colKeysPath.forEach((columnKey, index) => {\n//         columnKey.unshift(title);\n//       });\n//     }\n\n//     if (this._table.isPivotChart()) {\n//       this.hasTwoIndicatorAxes = this._indicatorObjects.some(indicatorObject => {\n//         if (\n//           indicatorObject.chartSpec &&\n//           indicatorObject.chartSpec.series &&\n//           indicatorObject.chartSpec.series.length > 1\n//         ) {\n//           return true;\n//         }\n//         return false;\n//       });\n//       this._chartItemSpanSize = 0;\n//       this._chartItemBandSize = 0;\n//       // this._chartPadding ;\n//       this._indicatorObjects.find(indicatorObject => {\n//         if ((indicatorObject?.style as TextStyle)?.padding) {\n//           this._chartPadding = (indicatorObject.style as TextStyle).padding as number;\n//         }\n//         if (indicatorObject.chartSpec?.barWidth) {\n//           this._chartItemSpanSize = indicatorObject.chartSpec?.barWidth;\n//         }\n//         const bandAxisConfig = indicatorObject.chartSpec?.axes?.find((axis: any) => {\n//           return axis.type === 'band';\n//         });\n//         if (bandAxisConfig?.bandSize) {\n//           this._chartItemBandSize = bandAxisConfig?.bandSize;\n//           this._chartPaddingInner =\n//             (isArray(bandAxisConfig.paddingInner) ? bandAxisConfig.paddingInner[0] : bandAxisConfig.paddingInner) ?? 0;\n//           this._chartPaddingOuter =\n//             (isArray(bandAxisConfig.paddingOuter) ? bandAxisConfig.paddingOuter[0] : bandAxisConfig.paddingOuter) ?? 0;\n//         }\n//         if (this._chartItemSpanSize > 0) {\n//           return true;\n//         }\n//         indicatorObject.chartSpec.series?.find((seriesObject: any) => {\n//           if (seriesObject.barWidth) {\n//             this._chartItemSpanSize = seriesObject.barWidth;\n//           }\n//           if (this._chartItemSpanSize > 0) {\n//             return true;\n//           }\n//           return false;\n//         });\n//         // if (this._chartItemSpanSize > 0) {\n//         //   return true;\n//         // }\n//         return false;\n//       });\n\n//       if (this.indicatorsAsCol) {\n//         const cell_id = 'rowHeaderEmpty';\n//         this._headerObjectMap[cell_id] = {\n//           id: cell_id,\n//           title: '',\n//           field: cell_id,\n//           headerType: this.cornerSetting.headerType ?? 'text',\n//           style: this.cornerSetting.headerStyle,\n//           define: <any>{\n//             // id:\n//           }\n//         };\n//         this._headerObjects.push(this._headerObjectMap[cell_id]);\n//         this.rowShowAttrs.push(cell_id);\n\n//         // deal with sub indicator axis\n\n//         if (!this.hasTwoIndicatorAxes) {\n//           this.colShowAttrs.pop();\n//         }\n//       } else {\n//         const axisOption = ((this._table as PivotChart).pivotChartAxes as ITableAxisOption[]).find(axisOption => {\n//           return axisOption.orient === 'left';\n//         });\n//         if (axisOption?.visible === false) {\n//           this.rowShowAttrs.pop();\n//         }\n//       }\n//     }\n\n//     //#endregion\n//     this._colCount =\n//       (this.colKeysPath.length === 0 ? 1 : this.colKeysPath.length) *\n//         (this.indicatorsAsCol ? this.indicatorKeys.length : 1) +\n//       this.rowHeaderLevelCount +\n//       this.rightFrozenColCount;\n//     this._rowCount =\n//       (this.rowKeysPath.length === 0 ? 1 : this.rowKeysPath.length) *\n//         (!this.indicatorsAsCol ? this.indicatorKeys.length : 1) +\n//       this.columnHeaderLevelCount +\n//       this.bottomFrozenRowCount;\n//     this.setColumnWidths();\n//   }\n//   private setColumnWidths() {\n//     const returnWidths: WidthData[] = new Array(this.colCount).fill(undefined);\n//     if (this.showRowHeader) {\n//       if (this.rowHeaderTitle) {\n//         returnWidths[0] = {};\n//       }\n//       this.rowShowAttrs.forEach((objKey, index) => {\n//         const dimension = this.rowsDefine?.find(dimension =>\n//           typeof dimension === 'string' ? false : dimension.dimensionKey === objKey\n//         ) as IDimension;\n//         dimension &&\n//           (returnWidths[index + (this.rowHeaderTitle ? 1 : 0)] = {\n//             width: dimension.width,\n//             minWidth: dimension.minWidth,\n//             maxWidth: dimension.maxWidth\n//           });\n//       });\n//     }\n//     if (this.indicatorsAsCol) {\n//       for (let i = this.rowHeaderLevelCount; i < this.colCount; i++) {\n//         const cellDefine = this.getBody(i, this.columnHeaderLevelCount);\n//         returnWidths[i] = {\n//           width: cellDefine?.width,\n//           minWidth: cellDefine?.minWidth,\n//           maxWidth: cellDefine?.maxWidth\n//         };\n//       }\n//     } else {\n//       let width: string | number = 0;\n//       let maxWidth: string | number;\n//       let minWidth: string | number;\n//       let isAuto;\n//       this._indicatorObjects.forEach((obj, index) => {\n//         if (typeof obj.width === 'number') {\n//           width = Math.max(obj.width, <number>width);\n//         } else if (obj.width === 'auto') {\n//           isAuto = true;\n//         }\n//         if (typeof obj.minWidth === 'number') {\n//           minWidth = Math.max(obj.minWidth, <number>minWidth);\n//         }\n//         if (typeof obj.maxWidth === 'number') {\n//           maxWidth = Math.max(obj.maxWidth, <number>maxWidth);\n//         }\n//       });\n//       width = width > 0 ? width : isAuto ? 'auto' : undefined;\n//       returnWidths.fill(\n//         { width, minWidth, maxWidth },\n//         this.rowHeaderLevelCount,\n//         this.colCount - this.rightFrozenColCount\n//       );\n//     }\n//     this._columnWidths = returnWidths;\n//   }\n\n//   private _addHeadersForTreeMode(\n//     _headerCellIds: number[][] | string[][],\n//     row: number,\n//     header: IPivotLayoutHeadNode[],\n//     roots: number[],\n//     totalLevel: number,\n//     show: boolean,\n//     dimensions: (IDimension | string)[]\n//   ): HeaderData[] {\n//     function _newRow(row: number): number[] | string[] {\n//       const newRow: number[] | string[] = (_headerCellIds[row] = []);\n//       if (colIndex === 0) {\n//         return newRow;\n//       }\n//       const prev = _headerCellIds[row - 1];\n//       for (let col = 0; col < prev?.length; col++) {\n//         newRow[col] = prev[col];\n//       }\n//       return newRow;\n//     }\n//     const results: HeaderData[] = [];\n//     if (!_headerCellIds[row]) {\n//       _newRow(row);\n//     }\n//     header.forEach(hd => {\n//       const id = hd.id;\n//       // const dimensionInfo: IDimension =\n//       //   (this.rowsDefine?.find(dimension =>\n//       //     typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey\n//       //   ) as IDimension) ??\n//       //   (this.columnsDefine?.find(dimension =>\n//       //     typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey\n//       //   ) as IDimension);\n//       const dimensionInfo: IDimension = dimensions.find(dimension =>\n//         typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey\n//       ) as IDimension;\n\n//       const cell: HeaderData = {\n//         id,\n//         title: hd.value,\n//         field: hd.dimensionKey,\n//         //如果不是整棵树的叶子节点，都靠左显示\n//         style:\n//           hd.level + 1 === totalLevel || typeof dimensionInfo?.headerStyle === 'function'\n//             ? dimensionInfo?.headerStyle\n//             : Object.assign({}, dimensionInfo?.headerStyle, { textAlign: 'left' }),\n//         headerType: dimensionInfo?.headerType ?? 'text',\n//         headerIcon: dimensionInfo?.headerIcon,\n//         define: Object.assign(<any>hd, {\n//           linkJump: (dimensionInfo as ILinkDimension)?.linkJump,\n//           linkDetect: (dimensionInfo as ILinkDimension)?.linkDetect,\n//           templateLink: (dimensionInfo as ILinkDimension)?.templateLink,\n\n//           // image相关 to be fixed\n//           keepAspectRatio: (dimensionInfo as IImageDimension)?.keepAspectRatio ?? false,\n//           imageAutoSizing: (dimensionInfo as IImageDimension)?.imageAutoSizing,\n\n//           headerCustomRender: dimensionInfo?.headerCustomRender,\n//           headerCustomLayout: dimensionInfo?.headerCustomLayout,\n//           dragHeader: dimensionInfo?.dragHeader\n//         }), //这里不能新建对象，要用hd保持引用关系\n//         fieldFormat: dimensionInfo?.headerFormat,\n//         // iconPositionList:[]\n//         dropDownMenu: dimensionInfo?.dropDownMenu,\n//         pivotInfo: {\n//           value: hd.value,\n//           dimensionKey: hd.dimensionKey,\n//           isPivotCorner: false\n//           // customInfo: dimensionInfo?.customInfo\n//         },\n//         hierarchyLevel: hd.level,\n//         dimensionTotalLevel: totalLevel,\n//         hierarchyState: hd.level + 1 === totalLevel ? undefined : hd.hierarchyState,\n//         width: dimensionInfo?.width,\n//         minWidth: dimensionInfo?.minWidth,\n//         maxWidth: dimensionInfo?.maxWidth,\n//         parentCellId: roots[roots.length - 1]\n//       };\n\n//       results[id] = cell;\n//       // this._cellIdDiemnsionMap.set(id, {\n//       //   dimensionKey: hd.dimensionKey,\n//       //   value: hd.value\n//       // });\n//       this._headerObjects[id] = cell;\n//       _headerCellIds[row][colIndex] = id;\n//       for (let r = row - 1; r >= 0; r--) {\n//         _headerCellIds[r][colIndex] = roots[r];\n//       }\n//       if (hd.hierarchyState === HierarchyState.expand && (hd as IPivotLayoutHeadNode).children) {\n//         //row传值 colIndex++和_addHeaders有区别\n//         show && colIndex++;\n//         this._addHeadersForTreeMode(\n//           _headerCellIds,\n//           row,\n//           (hd as IPivotLayoutHeadNode).children ?? [],\n//           [...roots, id],\n//           totalLevel,\n//           show && hd.hierarchyState === HierarchyState.expand, //当前节点show 且当前节点状态为展开 则传给子节点为show：true\n//           dimensions\n//         ).forEach(c => results.push(c));\n//       } else {\n//         // columns.push([\"\"])//代码一个路径\n//         show && colIndex++;\n//         for (let r = row + 1; r < _headerCellIds.length; r++) {\n//           _headerCellIds[r][colIndex] = id;\n//         }\n//       }\n//     });\n//     return results;\n//   }\n//   get columnWidths(): WidthData[] {\n//     return this._columnWidths;\n//   }\n//   getColumnWidthDefined(col: number): WidthData {\n//     return this._columnWidths[col];\n//   }\n//   private getDimensionInfo(dimensionKey: string) {\n//     const dimensionInfo: IDimension =\n//       (this.rowsDefine?.find(dimension =>\n//         typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey\n//       ) as IDimension) ??\n//       (this.columnsDefine?.find(dimension =>\n//         typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey\n//       ) as IDimension);\n//     return dimensionInfo;\n//   }\n\n//   getIndicatorInfo(indicatorKey: string, indicatorValue = '') {\n//     const indicatorInfo = this.indicatorsDefine?.find(indicator => {\n//       if (typeof indicator === 'string') {\n//         return false;\n//       }\n//       if (indicatorKey) {\n//         return indicator.indicatorKey === indicatorKey;\n//       }\n//       if (indicatorValue) {\n//         return indicator.title === indicatorValue;\n//       }\n//       return false;\n//     }) as IIndicator;\n//     return indicatorInfo;\n//   }\n\n//   getColKeysPath() {\n//     return this.colKeysPath;\n//   }\n//   getRowKeysPath() {\n//     return this.rowKeysPath;\n//   }\n//   /**\n//    * 初始化_headerObjects\n//    */\n//   private initHeaderObjects() {\n//     /**行表头headerObject */\n//     // for (let i = 0, len = this.rowKeysPath.length; i <= len - 1; i++) {\n//     //   const rowKey = this.rowKeysPath[i];\n//     //   for (let j = 0, len2 = rowKey.length; j <= len2 - 1; j++) {\n//     //     if (!this._headerObjectMap[rowKey[j]]) {\n//     //       const ids = rowKey[j].split(this.dataset.stringJoinChar);\n//     //       const dimensionInfo = this.getDimensionInfo(this.rows[ids.length - 1]);\n//     //       this._headerObjectMap[rowKey[j]] = {\n//     //         id: rowKey[j],\n//     //         field: <string>dimensionInfo?.dimensionKey ?? this.rows[ids.length - 1],\n//     //         title: <string>ids[ids.length - 1],\n//     //         style: dimensionInfo?.headerStyle,\n//     //         define: {\n//     //           field: <string>dimensionInfo?.dimensionKey ?? this.rows[ids.length - 1],\n//     //           headerType: dimensionInfo?.headerType ?? 'text',\n//     //           cellType: 'text'\n//     //         }, //TODO 需要将define的用处 梳理清楚\n//     //         fieldFormat: dimensionInfo?.headerFormat,\n//     //         dropDownMenu: dimensionInfo?.dropDownMenu,\n//     //         headerType: dimensionInfo?.headerType ?? 'text',\n//     //         width: dimensionInfo?.width\n//     //       };\n//     //       this._headerObjects.push(this._headerObjectMap[rowKey[j]]);\n//     //     }\n//     //   }\n//     // }\n//     /**列表头headerObject */\n//     for (let i = 0, len = this.colKeysPath.length; i <= len - 1; i++) {\n//       const colKey = this.colKeysPath[i];\n//       for (let j = 0, len2 = colKey.length; j <= len2 - 1; j++) {\n//         if (!this._headerObjectMap[colKey[j]]) {\n//           const ids = colKey[j].split(this.dataset.stringJoinChar);\n//           const dimensionInfo = this.getDimensionInfo(this.columns[ids.length - 1]);\n//           this._headerObjectMap[colKey[j]] = {\n//             id: colKey[j],\n//             field: <string>dimensionInfo?.dimensionKey ?? this.columns[ids.length - 1],\n//             title: <string>ids[ids.length - 1],\n//             style: dimensionInfo?.headerStyle,\n//             define: {\n//               field: <string>dimensionInfo?.dimensionKey ?? this.columns[ids.length - 1],\n//               headerType: dimensionInfo?.headerType ?? 'text',\n//               cellType: 'text'\n//             },\n//             fieldFormat: dimensionInfo?.headerFormat,\n//             dropDownMenu: dimensionInfo?.dropDownMenu,\n//             headerType: dimensionInfo?.headerType ?? 'text',\n//             width: dimensionInfo?.width\n//           };\n//           this._headerObjects.push(this._headerObjectMap[colKey[j]]);\n//         }\n//       }\n//     }\n//     /**指标表头headerObject */\n//     // const indicatorDimensionInfo = this.getIndicatorInfo(this.indicatorDimensionKey);\n//     this.indicatorsDefine.forEach(indicator => {\n//       const indicatorKey = typeof indicator === 'string' ? indicator : indicator.indicatorKey;\n//       const indicatorInfo = typeof indicator === 'string' ? undefined : indicator;\n//       if (!this._headerObjectMap[indicatorKey]) {\n//         this._headerObjectMap[indicatorKey] = {\n//           id: indicatorKey,\n//           field: this.indicatorDimensionKey,\n//           title: indicatorInfo?.title ?? indicatorKey,\n//           style: indicatorInfo?.headerStyle, //?? indicatorDimensionInfo?.headerStyle,\n//           define: {\n//             field: this.indicatorDimensionKey,\n//             headerType: indicatorInfo?.headerType ?? 'text',\n//             cellType: 'text'\n//           },\n//           // fieldFormat: indicatorDimensionInfo?.headerFormat,\n//           dropDownMenu: indicatorInfo?.dropDownMenu,\n//           headerType: indicatorInfo?.headerType ?? 'text',\n//           width: indicatorInfo?.width\n//         };\n//         this._headerObjects.push(this._headerObjectMap[indicatorKey]);\n//       }\n//     });\n//     /**角表headerObject */\n//     let cornerAttrs;\n//     if (this.cornerSetting.titleOnDimension === 'column') {\n//       cornerAttrs = this.colShowAttrs;\n//     } else if (this.cornerSetting.titleOnDimension === 'row') {\n//       cornerAttrs = this.rowShowAttrs;\n//     }\n//     cornerAttrs?.forEach(cornerAttrStr => {\n//       if (!this._headerObjectMap[cornerAttrStr]) {\n//         const dimensionInfo = this.getDimensionInfo(cornerAttrStr);\n//         this._headerObjectMap[cornerAttrStr] = {\n//           id: cornerAttrStr,\n//           field: cornerAttrStr,\n//           title:\n//             cornerAttrStr === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo?.title ?? cornerAttrStr,\n//           style: this.cornerSetting?.headerStyle,\n//           define: {\n//             field: cornerAttrStr,\n//             headerType: this.cornerSetting?.headerType ?? 'text',\n//             cellType: 'text'\n//           },\n//           dropDownMenu: dimensionInfo?.dropDownMenu,\n//           headerType: this.cornerSetting?.headerType ?? 'text',\n//           width: dimensionInfo?.width\n//         };\n//         this._headerObjects.push(this._headerObjectMap[cornerAttrStr]);\n//       }\n//     });\n//   }\n//   /**\n//    * 初始化_indicatorObjects\n//    */\n//   private initIndicatorObjects() {\n//     // const indicatorDimensionInfo = this.dimensions?.find(\n//     //   (dimension) => dimension.dimensionKey === this.indicatorDimensionKey\n//     // );\n//     this.indicatorKeys.forEach(indicatorKey => {\n//       const indicatorInfo = this.indicatorsDefine?.find(indicator => {\n//         if (typeof indicator === 'string') {\n//           return false;\n//         }\n//         return indicator.indicatorKey === indicatorKey;\n//       }) as IIndicator;\n//       this._indicatorObjects.push({\n//         id: indicatorKey,\n//         indicatorKey: indicatorKey,\n//         field: indicatorKey,\n//         define: Object.assign(\n//           {\n//             field: indicatorKey,\n//             headerType: 'text',\n//             cellType: indicatorInfo?.cellType ?? (indicatorInfo as any)?.columnType ?? 'text'\n//           },\n//           indicatorInfo as any\n//         ),\n//         fieldFormat: indicatorInfo?.format,\n//         cellType: indicatorInfo?.cellType ?? (indicatorInfo as any)?.columnType ?? 'text',\n//         chartModule: indicatorInfo && ('chartModule' in indicatorInfo ? indicatorInfo?.chartModule : null),\n//         chartSpec: indicatorInfo && ('chartSpec' in indicatorInfo ? indicatorInfo?.chartSpec : null),\n//         sparklineSpec: indicatorInfo && ('sparklineSpec' in indicatorInfo ? indicatorInfo?.sparklineSpec : null),\n//         style: indicatorInfo?.style,\n//         icon: indicatorInfo?.icon,\n//         width: indicatorInfo?.width,\n//         minWidth: indicatorInfo?.minWidth,\n//         maxWidth: indicatorInfo?.maxWidth,\n//         disableColumnResize: indicatorInfo?.disableColumnResize\n//       });\n//     });\n//   }\n//   get showColumnHeader(): boolean {\n//     return this._showColumnHeader;\n//   }\n//   set showColumnHeader(_showColumnHeader: boolean) {\n//     this._showColumnHeader = _showColumnHeader;\n//   }\n//   get showRowHeader(): boolean {\n//     return this._showRowHeader;\n//   }\n//   set showRowHeader(_showRowHeader: boolean) {\n//     this._showRowHeader = _showRowHeader;\n//   }\n//   get columnHeaderTitle(): ITitleDefine {\n//     return this._columnHeaderTitle;\n//   }\n//   set columnHeaderTitle(_columnHeaderTitle: ITitleDefine) {\n//     this._columnHeaderTitle = _columnHeaderTitle;\n//   }\n//   get rowHeaderTitle(): ITitleDefine {\n//     return this._rowHeaderTitle;\n//   }\n//   set rowHeaderTitle(_rowHeaderTitle: ITitleDefine) {\n//     this._rowHeaderTitle = _rowHeaderTitle;\n//   }\n//   getCellLocation(col: number, row: number): CellLocation {\n//     if (this.isCornerHeader(col, row)) {\n//       return 'cornerHeader';\n//     } else if (this.isColumnHeader(col, row)) {\n//       return 'columnHeader';\n//     } else if (this.isRowHeader(col, row)) {\n//       return 'rowHeader';\n//     }\n//     return 'body';\n//   }\n\n//   isHeader(col: number, row: number): boolean {\n//     if (col < this.rowHeaderLevelCount) {\n//       return true;\n//     }\n//     if (row < this.columnHeaderLevelCount) {\n//       return true;\n//     }\n//     if (col >= this.colCount - this.rightFrozenColCount) {\n//       return true;\n//     }\n//     if (row >= this.rowCount - this.bottomFrozenRowCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isCornerHeader(col: number, row: number): boolean {\n//     if (col < this.rowHeaderLevelCount && row < this.columnHeaderLevelCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isColumnHeader(col: number, row: number): boolean {\n//     if (col >= this.rowHeaderLevelCount && row < this.columnHeaderLevelCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isRightFrozenColumn(col: number, row: number): boolean {\n//     if (\n//       col >= this.colCount - this.rightFrozenColCount &&\n//       row >= this.columnHeaderLevelCount &&\n//       row < this.rowCount - this.bottomFrozenRowCount\n//     ) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isBottomFrozenRow(col: number, row: number): boolean {\n//     if (\n//       col >= this.rowHeaderLevelCount &&\n//       row >= this.rowCount - this.bottomFrozenRowCount &&\n//       col < this.colCount - this.rightFrozenColCount\n//     ) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isLeftBottomCorner(col: number, row: number): boolean {\n//     if (col < this.rowHeaderLevelCount && row >= this.rowCount - this.bottomFrozenRowCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isRightTopCorner(col: number, row: number): boolean {\n//     if (col >= this.colCount - this.rightFrozenColCount && row < this.columnHeaderLevelCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   isRightBottomCorner(col: number, row: number): boolean {\n//     if (col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   /**\n//    * 是否为行表头，不包含角头\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   isRowHeader(col: number, row: number): boolean {\n//     if (col < this.rowHeaderLevelCount && row >= this.columnHeaderLevelCount) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   /**\n//    * 判读是否为指标名称单元格。非角头部分，行表头或者列表头显示的指标名\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   isColumnIndicatorHeader(col: number, row: number): boolean {\n//     if (\n//       this._indicatorShowType === 'column' &&\n//       row === this.columnHeaderLevelCount - 1 &&\n//       col >= this.rowHeaderLevelCount\n//     ) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   /**\n//    * 判读是否为指标名称单元格。非角头部分，行表头或者列表头显示的指标名\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   isRowIndicatorHeader(col: number, row: number): boolean {\n//     if (\n//       this._indicatorShowType === 'row' &&\n//       col === this.rowHeaderLevelCount - 1 &&\n//       row >= this.columnHeaderLevelCount\n//     ) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   /**\n//    * 判读是否为指标名称单元格。非角头部分，行表头或者列表头显示的指标名\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   isIndicatorHeader(col: number, row: number): boolean {\n//     return this.isColumnIndicatorHeader(col, row) || this.isRowIndicatorHeader(col, row);\n//   }\n\n//   getColumnHeaderRange(): CellRange {\n//     return {\n//       start: { col: this.rowHeaderLevelCount, row: 0 },\n//       end: { col: this.colCount - 1, row: this.columnHeaderLevelCount - 1 }\n//     };\n//   }\n//   getRowHeaderRange(): CellRange {\n//     return {\n//       start: { col: 0, row: this.columnHeaderLevelCount },\n//       end: { col: this.rowHeaderLevelCount - 1, row: this.rowCount - 1 }\n//     };\n//   }\n//   getCornerHeaderRange(): CellRange {\n//     return {\n//       start: { col: 0, row: 0 },\n//       end: { col: this.rowHeaderLevelCount - 1, row: this.columnHeaderLevelCount - 1 }\n//     };\n//   }\n//   getBodyRange(): CellRange {\n//     return {\n//       start: { col: this.rowHeaderLevelCount, row: this.columnHeaderLevelCount },\n//       end: { col: this.colCount - 1, row: this.rowCount - 1 }\n//     };\n//   }\n//   resetCellIds() {\n//     // for (let row = 0; row < this.columnHeaderLevelCount; row++) {}\n//   }\n//   get headerLevelCount(): number {\n//     return this.columnHeaderLevelCount;\n//   }\n//   get columnHeaderLevelCount(): number {\n//     const colLevelCount = this.colShowAttrs.length;\n//     if (this.showColumnHeader) {\n//       const count = !this.indicatorsAsCol\n//         ? colLevelCount\n//         : this.hideIndicatorName //设置隐藏表头，且表头最下面一级就是指标维度 则-1\n//         ? this.colShowAttrs[this.colShowAttrs.length - 1] === this.indicatorDimensionKey\n//           ? colLevelCount - 1\n//           : colLevelCount\n//         : colLevelCount;\n\n//       // if (this.indicatorsAsCol && this._table.isPivotChart()) {\n//       //   // 指标在列上，指标及其对应坐标轴显示在底部，下侧冻结行数为1；\n//       //   // 如果指标对应两个轴，则第二个轴显示在上部，columnHeaderLevelCount不变，否则columnHeader不显示指标，columnHeaderLevelCount - 1\n//       //   // count -= 1;\n//       // } else if (this._table.isPivotChart()) {\n//       //   // 指标在行上，维度对应坐标轴显示在底部，下侧冻结行数为1，上侧不变\n//       // }\n\n//       return count;\n//     }\n//     return !this.indicatorsAsCol ? 0 : this.hideIndicatorName ? 0 : 1;\n//   }\n//   get rowHeaderLevelCount(): number {\n//     const rowLevelCount = this.rowShowAttrs.length;\n//     if (this.showRowHeader) {\n//       if (this.rowHierarchyType === 'tree') {\n//         if (this.rowHeaderTitle) {\n//           return 2;\n//         }\n//         return 1;\n//       }\n//       const count = this.indicatorsAsCol\n//         ? rowLevelCount\n//         : this.hideIndicatorName //设置隐藏表头，且表头最下面一级就是指标维度 则-1\n//         ? this.rowShowAttrs[this.rowShowAttrs.length - 1] === this.indicatorDimensionKey\n//           ? rowLevelCount - 1\n//           : rowLevelCount\n//         : rowLevelCount;\n\n//       // if (this.indicatorsAsCol && this._table.isPivotChart()) {\n//       //   // 指标在列上，维度对应坐标轴显示在左侧，rowHeaderLevelCount + 1；\n//       //   count += 1;\n//       // } else if (this._table.isPivotChart()) {\n//       //   // 指标在行上，指标对应坐标轴显示在左侧指标单元格，rowHeaderLevelCount不变\n//       // }\n\n//       return count;\n//     }\n//     return this.indicatorsAsCol ? 0 : this.hideIndicatorName ? 0 : 1;\n//   }\n//   get colCount(): number {\n//     return this._colCount;\n//   }\n//   get rowCount(): number {\n//     return this._rowCount;\n//   }\n//   get bodyRowCount() {\n//     return this._bodyRowCount;\n//   }\n//   get bottomFrozenRowCount(): number {\n//     if (!this._table.isPivotChart()) {\n//       return 0;\n//     }\n//     const axisOption = ((this._table as PivotChart).pivotChartAxes as ITableAxisOption[]).find(axisOption => {\n//       return axisOption.orient === 'bottom';\n//     });\n//     if (axisOption?.visible === false) {\n//       return 0;\n//     }\n//     if (this.indicatorsAsCol) {\n//       // 指标在列上，指标及其对应坐标轴显示在底部，下侧冻结行数为1\n//       return 1;\n//     }\n//     return 1; // 指标在行上，维度对应坐标轴显示在底部，下侧冻结行数为1\n//   }\n//   get rightFrozenColCount(): number {\n//     if (!this._table.isPivotChart()) {\n//       return 0;\n//     }\n//     const axisOption = ((this._table as PivotChart).pivotChartAxes as ITableAxisOption[]).find(axisOption => {\n//       return axisOption.orient === 'right';\n//     });\n//     if (axisOption?.visible === false) {\n//       return 0;\n//     }\n\n//     if (this.indicatorsAsCol) {\n//       return 0; // 指标在列上，没有图表需要显示右轴\n//     } else if (this.hasTwoIndicatorAxes) {\n//       // 查找指标，判断是否有双轴情况，如果有，则右侧冻结列数为1\n//       return 1;\n//     }\n//     return 0;\n//   }\n//   get leftAxesCount(): number {\n//     if (!this._table.isPivotChart()) {\n//       return 0;\n//     }\n//     const axisOption = ((this._table as PivotChart).pivotChartAxes as ITableAxisOption[]).find(axisOption => {\n//       return axisOption.orient === 'left';\n//     });\n//     if (axisOption?.visible === false) {\n//       return 0;\n//     }\n//     if (this.indicatorsAsCol) {\n//       return 1; // 左侧维度轴\n//     }\n//     return 1; // 左侧主指标轴\n//   }\n//   get topAxesCount(): number {\n//     if (!this._table.isPivotChart()) {\n//       return 0;\n//     }\n//     const axisOption = ((this._table as PivotChart).pivotChartAxes as ITableAxisOption[]).find(axisOption => {\n//       return axisOption.orient === 'top';\n//     });\n//     if (axisOption?.visible === false) {\n//       return 0;\n//     }\n//     if (this.indicatorsAsCol && this.hasTwoIndicatorAxes) {\n//       return 1; // 顶部副指标\n//     }\n//     return 0; // 顶部无轴\n//   }\n//   get rightAxesCount(): number {\n//     return this.rightFrozenColCount;\n//   }\n//   get bottomAxesCount(): number {\n//     return this.bottomFrozenRowCount;\n//   }\n\n//   get headerObjects(): HeaderData[] {\n//     return this._headerObjects;\n//   }\n//   get columnObjects(): IndicatorData[] {\n//     return this._indicatorObjects;\n//   }\n//   /**\n//    * 其他layout文件这个函数返回的是id值，这里其实是返回的维度成员名\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   getCellId(col: number, row: number): LayoutObjectId {\n//     if (\n//       (col < this.rowHeaderLevelCount && row >= this.rowCount - this.bottomFrozenRowCount) ||\n//       (row < this.columnHeaderLevelCount && col >= this.colCount - this.rightFrozenColCount)\n//     ) {\n//       return 0;\n//     }\n//     if (row >= 0 && col >= 0) {\n//       if (this.isCornerHeader(col, row)) {\n//         if (this.cornerSetting.titleOnDimension === 'column') {\n//           return this.colShowAttrs[row];\n//         } else if (this.cornerSetting.titleOnDimension === 'row') {\n//           return this.rowShowAttrs[col];\n//         }\n//       } else if (this.isColumnHeader(col, row)) {\n//         if (row < this.columns.length + (this.columnHeaderTitle ? 1 : 0)) {\n//           return (\n//             this.convertColKeys[row]?.[\n//               this.indicatorsAsCol\n//                 ? Math.floor((col - this.rowHeaderLevelCount) / this.indicatorKeys.length)\n//                 : col - this.rowHeaderLevelCount\n//             ] ?? `colHeaderAxis-${col}-${row}`\n//           );\n//         }\n//         return this.indicatorKeys[(col - this.rowHeaderLevelCount) % this.indicatorKeys.length];\n//       } else if (this.isRowHeader(col, row)) {\n//         if (col < this.rows.length + (this.rowHeaderTitle ? 1 : 0)) {\n//           return (\n//             this.rowKeysPath[\n//               !this.indicatorsAsCol\n//                 ? Math.floor((row - this.columnHeaderLevelCount) / this.indicatorKeys.length)\n//                 : row - this.columnHeaderLevelCount\n//             ]?.[col] ?? `rowHeaderAxis-${col}-${row}`\n//           );\n//         }\n//         if (this.indicatorsAsCol && col === this.rowHeaderLevelCount - 1) {\n//           return `rowHeaderAxis-${col}-${row}`;\n//         }\n//         return this.indicatorKeys[(row - this.columnHeaderLevelCount) % this.indicatorKeys.length];\n//       } else if (this.isRightFrozenColumn(col, row)) {\n//         if (!this.indicatorsAsCol) {\n//           return this.indicatorKeys[(row - this.columnHeaderLevelCount) % this.indicatorKeys.length];\n//         }\n//         return this.rowKeysPath[row - this.columnHeaderLevelCount][this.rowHeaderLevelCount - 1];\n//       } else if (this.isBottomFrozenRow(col, row)) {\n//         if (this.indicatorsAsCol) {\n//           return this.indicatorKeys[(col - this.rowHeaderLevelCount) % this.indicatorKeys.length];\n//         }\n//         return this.convertColKeys[this.convertColKeys.length - 1]?.[\n//           Math.floor((col - this.rowHeaderLevelCount) / this.indicatorKeys.length)\n//         ];\n//       }\n//     }\n//     return 0;\n//   }\n//   /**\n//    * 获取单元格所代表的指标名称\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   getIndicatorKey(col: number, row: number) {\n//     if (this.isHeader(col, row)) {\n//       return '';\n//     }\n//     if (this.indicatorsAsCol) {\n//       const bodyCol = col - this.rowHeaderLevelCount;\n//       return this.indicatorKeys[bodyCol % this.indicatorKeys.length];\n//     }\n//     const bodyRow = row - this.columnHeaderLevelCount;\n//     return this.indicatorKeys[bodyRow % this.indicatorKeys.length];\n//   }\n//   getHeader(col: number, row: number): HeaderData {\n//     let id = this.getCellId(col, row) as string;\n//     if (id?.toString().startsWith('rowHeaderAxis')) {\n//       id = 'rowHeaderEmpty';\n//       // } else if (id.toString().startsWith('colHeaderAxis')) {\n//     }\n//     return this._headerObjectMap[id as number | string]! ?? EMPTY_HEADER;\n//   }\n//   getHeaderField(col: number, row: number) {\n//     const id = this.getCellId(col, row);\n//     return this._headerObjectMap[id as number]?.field || this.getBody(col, row)?.field;\n//   }\n//   getHeaderFieldKey(col: number, row: number): undefined {\n//     return undefined;\n//   }\n//   getHeaderCellAdressById(id: number): CellAddress | undefined {\n//     return undefined;\n//   }\n//   getHeaderCellAddressByField(field: string): CellAddress | undefined {\n//     throw new Error(`Method not implemented.${field}`);\n//   }\n//   // getBody(_col: number, _row: number): IndicatorData {\n//   //   // const dimensionInfo = this.dimensions?.find((dimension: IDimension) => {\n//   //   //   return dimension.indicators?.length! > 0;\n//   //   // });\n//   //   // if (this.indicatorsAsCol)\n//   //   //   return this.indicators[\n//   //   //     (_col - this.rowHeaderLevelCount) % (dimensionInfo?.indicators?.length ?? 0)\n//   //   //   ];\n//   //   // return this.indicators[\n//   //   //   (_row - this.columnHeaderLevelCount) % (dimensionInfo?.indicators?.length ?? 0)\n//   //   // ];\n//   //   // const dimensionInfo = this.dimensions?.[this.indicatorDimensionKey];\n//   //   let indicatorInfo;\n//   //   if (this.indicatorsAsCol) {\n//   //     indicatorInfo = this.getIndicatorInfo(\n//   //       this?.indicators?.[(_col - this.rowHeaderLevelCount) % (this.indicators?.length ?? 0)]\n//   //     );\n//   //   } else {\n//   //     indicatorInfo = this.getIndicatorInfo(\n//   //       this?.indicators?.[(_row - this.columnHeaderLevelCount) % (this.indicators?.length ?? 0)]\n//   //     );\n//   //   }\n//   //   return {\n//   //     id: 0,\n//   //     indicatorKey: this.indicators[(_col - this.rowHeaderLevelCount) % (this.indicators?.length ?? 0)],\n//   //     field: this.indicators[(_col - this.rowHeaderLevelCount) % (this.indicators?.length ?? 0)],\n//   //     cellType: indicatorInfo?.cellType ?? 'text',\n//   //     style: indicatorInfo?.style,\n//   //     define: {\n//   //       field: this.indicators[(_col - this.rowHeaderLevelCount) % (this.indicators?.length ?? 0)],\n//   //       headerType: 'text',\n//   //       cellType: indicatorInfo?.cellType ?? 'text'\n//   //     }\n//   //   };\n//   // }\n//   getBody(_col: number, _row: number): IndicatorData {\n//     // let indicatorData;\n//     //正常情况下 通过行号或者列号可以取到Indicator的配置信息 但如果指标在前维度在后的情况下（如风神：列配置【指标名称，地区】） indicators中的数量是和真正指标值一样数量\n//     // if (this.indicatorsAsCol) indicatorData = this.indicators[_col - this.rowHeaderLevelCount];\n//     // else indicatorData = this.indicators[_row - this.columnHeaderLevelCount];\n//     // if (indicatorData) return indicatorData;\n//     const paths = this.getCellHeaderPaths(_col, _row);\n//     if (this.indicatorsAsCol) {\n//       const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;\n//       return (\n//         this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey) ??\n//         this._indicatorObjects[0] ?? {\n//           id: '',\n//           field: undefined,\n//           indicatorKey: undefined,\n//           cellType: undefined,\n//           define: undefined\n//         }\n//       );\n//     }\n//     const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;\n//     return (\n//       this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey) ??\n//       this._indicatorObjects[0] ?? {\n//         id: '',\n//         field: undefined,\n//         indicatorKey: undefined,\n//         cellType: undefined,\n//         define: undefined\n//       }\n//     );\n//   }\n//   // getBodyLayoutRangeById(id: LayoutObjectId): CellRange {\n//   //   for (let col = 0; col < (this.colCount ?? 0); col++) {\n//   //     if (id === this.columnObjects[col].id) {\n//   //       return {\n//   //         start: { col, row: 0 },\n//   //         end: { col, row: 0 }\n//   //       };\n//   //     }\n//   //   }\n\n//   //   throw new Error(`can not found body layout @id=${id as number}`);\n//   // }\n//   /**\n//    * 这个结果直接影响合并单元格\n//    * 目前body部分 都按不合并\n//    * 指标名称isIndicator 不合并\n//    * 列表头部分，合并情况只考虑横向合并\n//    * 行表头部分，合并情况只考虑纵向合并\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   getCellRange(col: number, row: number): CellRange {\n//     const result: CellRange = { start: { col, row }, end: { col, row } };\n//     if (!this.isHeader(col, row) || col === -1 || row === -1 || this.isIndicatorHeader(col, row)) {\n//       return result;\n//     }\n\n//     if (this.isRightFrozenColumn(col, row) || this.isBottomFrozenRow(col, row)) {\n//       return result;\n//     }\n\n//     //in header\n//     const id = this.getCellId(col, row);\n//     for (let c = col - 1; c >= 0; c--) {\n//       if (id !== this.getCellId(c, row)) {\n//         break;\n//       }\n//       result.start.col = c;\n//     }\n//     for (let c = col + 1; c < (this.colCount ?? 0); c++) {\n//       if (id !== this.getCellId(c, row)) {\n//         break;\n//       }\n//       result.end.col = c;\n//     }\n//     for (let r = row - 1; r >= 0; r--) {\n//       if (id !== this.getCellId(col, r)) {\n//         break;\n//       }\n//       result.start.row = r;\n//     }\n//     for (let r = row + 1; r < (this.rowCount ?? 0); r++) {\n//       if (id !== this.getCellId(col, r)) {\n//         break;\n//       }\n//       result.end.row = r;\n//     }\n//     return result;\n//   }\n//   isCellRangeEqual(col: number, row: number, targetCol: number, targetRow: number): boolean {\n//     const range1 = this.getCellRange(col, row);\n//     const range2 = this.getCellRange(targetCol, targetRow);\n//     return (\n//       range1.start.col === range2.start.col &&\n//       range1.end.col === range2.end.col &&\n//       range1.start.row === range2.start.row &&\n//       range1.end.row === range2.end.row\n//     );\n//   }\n//   /**\n//    * 根据行号，得出body部分也就是数据部分 是第几条\n//    * @param row\n//    * @returns\n//    */\n//   getRecordIndexByCell(row: number): number {\n//     if (row < this.columnHeaderLevelCount) {\n//       return -1;\n//     }\n//     return this.indicatorsAsCol\n//       ? row - this.columnHeaderLevelCount\n//       : Math.floor((row - this.columnHeaderLevelCount) / this.indicatorKeys.length);\n//   }\n//   /**\n//    * 根据列号，得出body部分也就是数据部分 是第几条\n//    * @param col\n//    * @returns\n//    */\n//   getRecordIndexByCol(col: number): number {\n//     if (col < this.rowHeaderLevelCount) {\n//       return -1;\n//     }\n//     // return col - this.rowHeaderLevelCount;\n//     return !this.indicatorsAsCol\n//       ? col - this.rowHeaderLevelCount\n//       : Math.floor((col - this.rowHeaderLevelCount) / this.indicatorKeys.length);\n//   }\n//   getRecordStartRowByRecordIndex(index: number): number {\n//     return this.columnHeaderLevelCount + index;\n//   }\n\n//   // getCellRangeTranspose(): CellRange {\n//   //   return { start: { col: 0, row: 0 }, end: { col: 0, row: 0 } };\n//   // }\n//   /**\n//    * 计算一个单元格 行列维度信息\n//    * @param col\n//    * @param row\n//    * @returns\n//    */\n//   getCellHeaderPaths(col: number, row: number): IPivotTableCellHeaderPaths {\n//     const recordCol = this.getRecordIndexByCol(col);\n//     const recordRow = this.getRecordIndexByCell(row);\n//     let colPath;\n//     let rowPath;\n//     let colHeaderPaths: string[];\n//     let rowHeaderPaths: string[];\n//     if (recordCol >= 0) {\n//       colPath = this.colKeysPath[recordCol];\n//       colHeaderPaths = colPath?.[colPath.length - 1]?.split(this.dataset.stringJoinChar);\n//       if (colHeaderPaths && this.showColumnHeader && row < this.columns.length - 1) {\n//         colHeaderPaths = colHeaderPaths.slice(0, row + 1);\n//       } else if (!colHeaderPaths) {\n//         colHeaderPaths = [];\n//       }\n//     }\n//     if (recordRow >= 0) {\n//       rowPath = this.rowKeysPath[recordRow];\n//       rowHeaderPaths = rowPath?.[rowPath.length - 1]?.split(this.dataset.stringJoinChar);\n//       if (rowHeaderPaths && this.showRowHeader && col < this.rows.length - 1) {\n//         rowHeaderPaths = rowHeaderPaths.slice(0, col + 1);\n//       } else if (!rowHeaderPaths) {\n//         rowHeaderPaths = [];\n//       }\n//     }\n//     if (colHeaderPaths && this.indicatorsAsCol && col >= this.rowHeaderLevelCount) {\n//       colHeaderPaths.push(this.indicatorKeys[(col - this.rowHeaderLevelCount) % this.indicatorKeys.length]);\n//     } else if (rowHeaderPaths && row >= this.columnHeaderLevelCount) {\n//       rowHeaderPaths.push(this.indicatorKeys[(row - this.columnHeaderLevelCount) % this.indicatorKeys.length]);\n//     }\n//     return {\n//       colHeaderPaths:\n//         colHeaderPaths?.map((key: string, index: number) => {\n//           const indicatorObject = this._indicatorObjects.find(indicator => indicator.indicatorKey === key);\n//           return {\n//             dimensionKey: !indicatorObject ? this.colShowAttrs[index] : undefined,\n//             indicatorKey: indicatorObject ? key : undefined,\n//             value: !indicatorObject ? key : (indicatorObject.define.title as string)\n//           };\n//         }) ?? [],\n//       rowHeaderPaths:\n//         rowHeaderPaths?.map((key: string, index: number) => {\n//           const indicatorObject = this._indicatorObjects.find(indicator => indicator.indicatorKey === key);\n//           return {\n//             dimensionKey: !indicatorObject ? this.rowShowAttrs[index] : undefined,\n//             indicatorKey: indicatorObject ? key : undefined,\n//             value: !indicatorObject ? key : (indicatorObject.define.title as string)\n//           };\n//         }) ?? []\n//     };\n//   }\n//   /**\n//    * 通过dimensionPath获取到对应的表头地址col row, dimensionPath不要求必须按照表头层级顺序传递\n//    * @param dimensions\n//    * @returns\n//    */\n//   getCellAdressByHeaderPath(\n//     dimensionPaths:\n//       | {\n//           colHeaderPaths: IDimensionInfo[];\n//           rowHeaderPaths: IDimensionInfo[];\n//         }\n//       | IDimensionInfo[]\n//   ): CellAddress | undefined {\n//     let colHeaderPaths;\n//     let rowHeaderPaths;\n//     if (Array.isArray(dimensionPaths)) {\n//       if (dimensionPaths.length > this.rowShowAttrs.length + this.colShowAttrs.length) {\n//         //如果传入的path长度比行列维度层级多的话 无法匹配\n//         return undefined;\n//       }\n//       // 如果传入的是整体的path 按照行列维度区分开\n//       colHeaderPaths = dimensionPaths.filter(\n//         (path: IDimensionInfo) => this.colShowAttrs.indexOf(path.dimensionKey) >= 0\n//       );\n//       rowHeaderPaths = dimensionPaths.filter(\n//         (path: IDimensionInfo) => this.rowShowAttrs.indexOf(path.dimensionKey) >= 0\n//       );\n//     } else {\n//       colHeaderPaths = dimensionPaths.colHeaderPaths;\n//       rowHeaderPaths = dimensionPaths.rowHeaderPaths;\n//     }\n\n//     if (!Array.isArray(colHeaderPaths) && !Array.isArray(rowHeaderPaths)) {\n//       return undefined;\n//     }\n//     // 行列维度path根据key排序\n//     colHeaderPaths?.sort((a, b) => {\n//       return (\n//         this.colShowAttrs.indexOf(a.dimensionKey ?? this.indicatorDimensionKey) -\n//         this.colShowAttrs.indexOf(b.dimensionKey ?? this.indicatorDimensionKey)\n//       );\n//     });\n//     rowHeaderPaths?.sort((a, b) => {\n//       return (\n//         this.rowShowAttrs.indexOf(a.dimensionKey ?? this.indicatorDimensionKey) -\n//         this.rowShowAttrs.indexOf(b.dimensionKey ?? this.indicatorDimensionKey)\n//       );\n//     });\n//     let needLowestLevel = false; // needLowestLevel来标记是否需要 提供到最底层的维度层级信息\n//     // 如果行列维度都有值 说明是匹配body单元格 那这个时候 维度层级应该是满的\n//     if (colHeaderPaths?.length >= 1 && rowHeaderPaths?.length >= 1) {\n//       needLowestLevel = true;\n//     }\n//     //这里相当于默认了行列号为0\n//     let col = 0;\n//     let row = 0;\n//     let defaultCol;\n//     let defaultRow;\n//     let rowTree = this.rowTree;\n//     let columnTree = this.columnTree;\n//     let toFindIndicator;\n//     // 按照colHeaderPaths维度层级寻找到底层维度值节点\n//     if (colHeaderPaths) {\n//       for (let i = 0; i < colHeaderPaths.length; i++) {\n//         const colDimension = colHeaderPaths[i];\n//         if (colDimension.indicatorKey) {\n//           toFindIndicator = colDimension.indicatorKey;\n//           break;\n//         }\n//         for (let j = 0; j < columnTree.length; j++) {\n//           const dimension = columnTree[j];\n//           if (\n//             !isValid(colDimension.indicatorKey) &&\n//             dimension.dimensionKey === colDimension.dimensionKey &&\n//             dimension.value === colDimension.value\n//           ) {\n//             columnTree = dimension.children;\n//             if (!columnTree || columnTree.length === 0 || columnTree?.[0]?.indicatorKey) {\n//               col += j;\n//             }\n//             break;\n//           }\n//           col += dimension.children?.[0]?.indicatorKey ? 0 : dimension.children?.length ?? 0;\n//         }\n//       }\n//     }\n//     // 按照rowHeaderPaths维度层级寻找到底层维度值节点\n//     if (rowHeaderPaths) {\n//       for (let i = 0; i < rowHeaderPaths.length; i++) {\n//         const rowDimension = rowHeaderPaths[i];\n//         if (rowDimension.indicatorKey) {\n//           toFindIndicator = rowDimension.indicatorKey;\n//           break;\n//         }\n//         // 判断级别，找到distDimension\n//         // let isCol = false;\n//         for (let j = 0; j < rowTree.length; j++) {\n//           const dimension = rowTree[j];\n//           if (\n//             !isValid(rowDimension.indicatorKey) &&\n//             dimension.dimensionKey === rowDimension.dimensionKey &&\n//             dimension.value === rowDimension.value\n//           ) {\n//             rowTree = dimension.children;\n//             if (!rowTree || rowTree.length === 0 || rowTree?.[0]?.indicatorKey) {\n//               row += j;\n//             }\n//             break;\n//           }\n//           row += dimension.children?.[0]?.indicatorKey ? 0 : dimension.children?.length ?? 0;\n//         }\n//       }\n//     }\n//     col =\n//       (this.indicatorsAsCol ? col * this.indicatorKeys.length + this.indicatorKeys.indexOf(toFindIndicator) : col) +\n//       this.rowHeaderLevelCount;\n\n//     row =\n//       (!this.indicatorsAsCol ? row * this.indicatorKeys.length + this.indicatorKeys.indexOf(toFindIndicator) : row) +\n//       this.columnHeaderLevelCount;\n//     if (isValid(col) || isValid(row)) {\n//       return { col: col ?? defaultCol, row: row ?? defaultRow };\n//     }\n//     return undefined;\n//   }\n//   getHeaderDimension(col: number, row: number): IDimension | undefined {\n//     if (this.isHeader(col, row)) {\n//       const header = this.getHeader(col, row);\n//       const dimension =\n//         this.rowsDefine?.find(dimension => typeof dimension !== 'string' && dimension.dimensionKey === header.field) ??\n//         this.columnsDefine?.find(dimension => typeof dimension !== 'string' && dimension.dimensionKey === header.field);\n//       return dimension as IDimension;\n//     }\n//     return undefined;\n//   }\n//   updateDataset(dataset: Dataset) {\n//     this.dataset = dataset;\n//     this.dataConfig = dataset.dataConfig;\n//     this.rowKeysPath = dataset.rowKeysPath;\n//     this.colKeysPath = dataset.colKeysPath;\n//     this.tree = dataset.tree;\n//     this._indicatorObjects = [];\n//     this._headerObjects = [];\n//     this._headerObjectMap = {};\n//     this.initState();\n//     this.convertColKeys = transpose(this.colKeysPath);\n//   }\n\n//   // 为列宽计算专用，兼容列表 对齐pivot-header-layout文件\n//   isHeaderForColWidth(col: number, row: number): boolean {\n//     return this.isHeader(col, row);\n//   }\n//   getHeaderForColWidth(col: number, row: number): HeaderData {\n//     return this.getHeader(col, row);\n//   }\n\n//   // TODO: 补充Header Move\n\n//   setChartInstance(_col: number, _row: number, chartInstance: any) {\n//     const paths = this.getCellHeaderPaths(_col, _row);\n//     let indicatorObj;\n//     if (this.indicatorsAsCol) {\n//       const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;\n//       indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     } else {\n//       const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;\n//       indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     }\n//     indicatorObj && (indicatorObj.chartInstance = chartInstance);\n//   }\n\n//   getChartInstance(_col: number, _row: number) {\n//     const paths = this.getCellHeaderPaths(_col, _row);\n//     let indicatorObj;\n//     if (this.indicatorsAsCol) {\n//       const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;\n//       indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     } else {\n//       const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;\n//       indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     }\n//     return indicatorObj?.chartInstance;\n//   }\n\n//   //#region pivot chart 区别于 pivot table 的特有方法\n//   /** 将_selectedDataItemsInChart保存的数据状态同步到各个图表实例中 */\n//   _generateChartState() {\n//     const state = {\n//       vtable_selected: {\n//         filter: (datum: any) => {\n//           if ((this._table as PivotChart)._selectedDataItemsInChart.length >= 1) {\n//             const match = (this._table as PivotChart)._selectedDataItemsInChart.find(item => {\n//               for (const itemKey in item) {\n//                 if (item[itemKey] !== datum[itemKey]) {\n//                   return false;\n//                 }\n//               }\n//               return true;\n//             });\n//             return !!match;\n//           } else if ((this._table as PivotChart)._selectedDimensionInChart?.length) {\n//             // 判断维度点击\n//             const match = (this._table as PivotChart)._selectedDimensionInChart.every(item => {\n//               if (datum[item.key] !== item.value) {\n//                 return false;\n//               }\n//               return true;\n//             });\n//             return !!match;\n//           }\n//           return false;\n//         }\n//       },\n//       vtable_selected_reverse: {\n//         filter: (datum: any) => {\n//           if ((this._table as PivotChart)._selectedDataItemsInChart.length >= 1) {\n//             const match = (this._table as PivotChart)._selectedDataItemsInChart.find(item => {\n//               for (const itemKey in item) {\n//                 if (item[itemKey] !== datum[itemKey]) {\n//                   return false;\n//                 }\n//               }\n//               return true;\n//             });\n//             return !match;\n//           } else if ((this._table as PivotChart)._selectedDimensionInChart?.length) {\n//             // 判断维度点击\n//             const match = (this._table as PivotChart)._selectedDimensionInChart.every(item => {\n//               if (datum[item.key] !== item.value) {\n//                 return false;\n//               }\n//               return true;\n//             });\n//             return !match;\n//           }\n//           return false;\n//         }\n//       }\n//     };\n//     return state;\n//   }\n//   updateDataStateToChartInstance(activeChartInstance?: any): void {\n//     if (!activeChartInstance) {\n//       activeChartInstance = (this._table as PivotChart)._getActiveChartInstance();\n//     }\n//     const state = this._generateChartState();\n//     this._indicatorObjects.forEach((_indicatorObject: IndicatorData) => {\n//       const chartInstance = _indicatorObject.chartInstance;\n//       chartInstance.updateState(state);\n//     });\n//     activeChartInstance?.updateState(state);\n//   }\n//   updateDataStateToActiveChartInstance(activeChartInstance?: any): void {\n//     if (!activeChartInstance) {\n//       activeChartInstance = (this._table as PivotChart)._getActiveChartInstance();\n//     }\n//     const state = this._generateChartState();\n//     activeChartInstance?.updateState(state);\n//   }\n//   /** 获取某一图表列的最优宽度，计算逻辑是根据图表的xField的维度值个数 * barWidth */\n//   getOptimunWidthForChart(col: number) {\n//     const path = this.getCellHeaderPaths(col, this.columnHeaderLevelCount).colHeaderPaths;\n//     let collectedValues: any;\n//     for (const key in this.dataset.collectValuesBy) {\n//       if (this.dataset.collectValuesBy[key].type === 'xField' && !this.dataset.collectValuesBy[key].range) {\n//         collectedValues =\n//           this.dataset.collectedValues[key][\n//             path\n//               .map(pathObj => {\n//                 return pathObj.value;\n//               })\n//               .join(this.dataset.stringJoinChar)\n//           ];\n//         break;\n//       }\n//     }\n//     let width;\n//     if (this._chartItemBandSize) {\n//       // width = (collectedValues?.length ?? 0) * this._chartItemBandSize;\n//       width = scaleWholeRangeSize(\n//         collectedValues?.length ?? 0,\n//         this._chartItemBandSize,\n//         this._chartPaddingInner,\n//         this._chartPaddingOuter\n//       );\n//     } else {\n//       const barWidth = this._chartItemSpanSize || 25;\n//       width = (collectedValues?.length ?? 0) * (barWidth + barWidth / 3);\n//     }\n\n//     const padding = getQuadProps(this._chartPadding ?? (this._table.theme.bodyStyle.padding as number) ?? 0);\n//     return width + padding[1] + padding[3];\n//   }\n//   /** 获取某一图表列的最优高度，计算逻辑是根据图表的yField的维度值个数 * barWidth */\n//   getOptimunHeightForChart(row: number) {\n//     const path = this.getCellHeaderPaths(this.rowHeaderLevelCount, row).rowHeaderPaths;\n//     let collectedValues: any;\n//     for (const key in this.dataset.collectValuesBy) {\n//       if (this.dataset.collectValuesBy[key].type === 'yField' && !this.dataset.collectValuesBy[key].range) {\n//         collectedValues =\n//           this.dataset.collectedValues[key][\n//             path\n//               .map(pathObj => {\n//                 return pathObj.value;\n//               })\n//               .join(this.dataset.stringJoinChar)\n//           ];\n//         break;\n//       }\n//     }\n//     let height;\n//     if (this._chartItemBandSize) {\n//       // height = (collectedValues?.length ?? 0) * this._chartItemBandSize;\n//       height = scaleWholeRangeSize(\n//         collectedValues?.length ?? 0,\n//         this._chartItemBandSize,\n//         this._chartPaddingInner,\n//         this._chartPaddingOuter\n//       );\n//     } else {\n//       const barWidth = this._chartItemSpanSize || 25;\n//       height = (collectedValues?.length ?? 0) * (barWidth + barWidth / 3);\n//     }\n//     const padding = getQuadProps(this._chartPadding ?? (this._table.theme.bodyStyle.padding as number) ?? 0);\n//     return height + padding[0] + padding[2];\n//   }\n//   /**\n//    *  获取图表对应的指标值\n//    * */\n//   getIndicatorKeyInChartSpec(_col: number, _row: number) {\n//     // const paths = this.getCellHeaderPaths(_col, _row);\n//     // let indicatorObj;\n//     // if (this.indicatorsAsCol) {\n//     //   const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;\n//     //   indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     // } else {\n//     //   const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;\n//     //   indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     // }\n//     // const chartSpec = indicatorObj?.chartSpec;\n//     const chartSpec = this.getRawChartSpec(_col, _row);\n//     const indicatorKeys: string[] = [];\n//     if (chartSpec) {\n//       if (this.indicatorsAsCol === false) {\n//         if (chartSpec.series) {\n//           chartSpec.series.forEach((chartSeries: any) => {\n//             const yField = chartSeries.yField;\n//             indicatorKeys.push(yField);\n//           });\n//         } else {\n//           indicatorKeys.push(chartSpec.yField);\n//         }\n//       } else {\n//         if (chartSpec.series) {\n//           chartSpec.series.forEach((chartSeries: any) => {\n//             const xField = chartSeries.xField;\n//             indicatorKeys.push(xField);\n//           });\n//         } else {\n//           indicatorKeys.push(chartSpec.xField);\n//         }\n//       }\n//       return indicatorKeys;\n//     }\n//     return null;\n//   }\n\n//   /**\n//    *  获取图表对应的指标值\n//    * */\n//   getDimensionKeyInChartSpec(_col: number, _row: number) {\n//     // const paths = this.getCellHeaderPaths(_col, _row);\n//     // let indicatorObj;\n//     // if (this.indicatorsAsCol) {\n//     //   const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;\n//     //   indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     // } else {\n//     //   const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;\n//     //   indicatorObj = this._indicatorObjects.find(indicator => indicator.indicatorKey === indicatorKey);\n//     // }\n//     // const chartSpec = indicatorObj?.chartSpec;\n//     const chartSpec = this.getRawChartSpec(_col, _row);\n//     const dimensionKeys: string[] = [];\n//     if (chartSpec) {\n//       if (this.indicatorsAsCol === false) {\n//         dimensionKeys.push(chartSpec.xField ?? chartSpec?.series[0]?.xField);\n//       } else {\n//         dimensionKeys.push(chartSpec.yField ?? chartSpec?.series[0]?.yField);\n//       }\n//       return dimensionKeys;\n//     }\n//     return null;\n//   }\n\n//   getAxisConfigInPivotChart(col: number, row: number): any {\n//     return getAxisConfigInPivotChart(col, row, this);\n//   }\n//   getRawChartSpec(col: number, row: number): any {\n//     return getRawChartSpec(col, row, this);\n//   }\n//   getChartSpec(col: number, row: number): any {\n//     return getChartSpec(col, row, this);\n//   }\n//   getChartAxes(col: number, row: number): any {\n//     return getChartAxes(col, row, this);\n//   }\n//   getChartDataId(col: number, row: number): any {\n//     return getChartDataId(col, row, this);\n//   }\n//   isEmpty(col: number, row: number): boolean {\n//     if (!this._table.isPivotChart()) {\n//       return false;\n//     }\n//     if (col > this.colCount - this.rightFrozenColCount - 1 || row > this.rowCount - this.bottomFrozenRowCount - 1) {\n//       return true;\n//     }\n//     if (this.hasTwoIndicatorAxes && this.indicatorsAsCol && row === this.columnHeaderLevelCount - 1) {\n//       return true;\n//     }\n//     return false;\n//   }\n//   //#endregion\n//   release() {\n//     const activeChartInstance = (this._table as PivotChart)._getActiveChartInstance();\n//     activeChartInstance?.release();\n//     this._indicatorObjects.forEach(indicatorObject => {\n//       indicatorObject.chartInstance?.release();\n//     });\n//   }\n\n//   clearCellRangeMap() {\n//     // do nothing\n//   }\n// }\n\n// // FIXME: 等 vscale 暴露这两个方法后，删掉这两个方法\n\n// /** 计算 scale 的实际 range 长度 */\n// function scaleWholeRangeSize(count: number, bandwidth: number, paddingInner: number, paddingOuter: number) {\n//   if (paddingInner === 1) {\n//     paddingInner = 0; // 保护\n//     // FIXME: vscale 同样需要加保护，目前这里加了保护以后，在 paddingInner为 1 的情况还是会崩溃\n//   }\n//   const space = bandSpace(count, paddingInner, paddingOuter);\n//   const step = bandwidth / (1 - paddingInner);\n//   const wholeSize = space * step;\n//   return wholeSize;\n// }\n\n// function bandSpace(count: number, paddingInner: number, paddingOuter: number): number {\n//   let space;\n//   // count 等于 1 时需要特殊处理，否则 step 会超出 range 范围\n//   // 计算公式: step = paddingOuter * step * 2 + paddingInner * step + bandwidth\n//   if (count === 1) {\n//     space = count + paddingOuter * 2;\n//   } else {\n//     space = count - paddingInner + paddingOuter * 2;\n//   }\n//   return count ? (space > 0 ? space : 1) : 0;\n// }\n"]}