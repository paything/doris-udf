"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.checkHasChart = exports.getChartDataId = exports.getChartAxes = exports.getChartSpec = exports.isHasCartesianChartInline = exports.isCartesianChart = exports.checkHasCartesianChart = exports.isNoChartDataRenderNothing = exports.isShareChartSpec = exports.getRawChartSpec = void 0;

const vutils_1 = require("@visactor/vutils"), get_axis_config_1 = require("./get-axis-config"), vutils_extension_1 = require("@visactor/vutils-extension"), get_axis_attributes_1 = require("../../components/axis/get-axis-attributes"), tick_align_1 = require("./tick-align"), NO_AXISID_FRO_VTABLE = "NO_AXISID_FRO_VTABLE";

function getRawChartSpec(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    const chartSpec = null == indicatorObj ? void 0 : indicatorObj.chartSpec;
    if ("function" == typeof chartSpec) {
        return chartSpec({
            col: col,
            row: row,
            dataValue: layout._table.getCellOriginValue(col, row) || "",
            value: layout._table.getCellValue(col, row) || "",
            rect: layout._table.getCellRangeRelativeRect(layout._table.getCellRange(col, row)),
            table: layout._table
        });
    }
    return chartSpec;
}

function isShareChartSpec(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    return "function" != typeof (null == indicatorObj ? void 0 : indicatorObj.chartSpec);
}

function isNoChartDataRenderNothing(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    return null == indicatorObj ? void 0 : indicatorObj.noDataRenderNothing;
}

function checkHasCartesianChart(indicatorsDefine) {
    let isHasCartesianChart = !1;
    for (let i = 0; i < indicatorsDefine.length; i++) {
        const columnObj = indicatorsDefine[i];
        if (columnObj.chartSpec && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "pie" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
            isHasCartesianChart = !0;
            break;
        }
    }
    return isHasCartesianChart;
}

function isCartesianChart(col, row, layout) {
    let isHasCartesianChart = !0;
    const chartSpec = layout.getRawChartSpec(col, row);
    return chartSpec && "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type || (isHasCartesianChart = !1), 
    isHasCartesianChart;
}

function isHasCartesianChartInline(col, row, checkDirection, layout) {
    let isHasCartesianChart = !1;
    if (layout.indicatorsAsCol && "row" === checkDirection || !layout.indicatorsAsCol && "col" === checkDirection) for (let i = 0; i < layout.indicatorsDefine.length; i++) {
        const columnObj = layout.indicatorsDefine[i];
        if (columnObj.chartSpec && "pie" !== columnObj.chartSpec.type && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
            isHasCartesianChart = !0;
            break;
        }
    } else {
        const chartSpec = layout.getRawChartSpec(col, row);
        chartSpec ? "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type && (isHasCartesianChart = !0) : isHasCartesianChart = !1;
    }
    return isHasCartesianChart;
}

function getChartSpec(col, row, layout) {
    let chartSpec = layout.getRawChartSpec(col, row);
    return chartSpec ? layout._table.isPivotChart() ? (chartSpec = (0, vutils_extension_1.cloneDeepSpec)(chartSpec), 
    chartSpec.sortDataByAxis = !0, (0, vutils_1.isArray)(chartSpec.series) && chartSpec.series.forEach((serie => {
        serie.sortDataByAxis = !0;
    })), "gauge" !== chartSpec.type && "rose" !== chartSpec.type && "radar" !== chartSpec.type && (chartSpec.axes = layout.getChartAxes(col, row)), 
    chartSpec.padding = 0, chartSpec.dataZoom = [], chartSpec) : chartSpec : null;
}

function getChartAxes(col, row, layout) {
    var _a, _b, _c;
    const axes = [];
    if (layout.indicatorsAsCol) {
        const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), colPath = layout.getColKeysPath(col, row);
        indicatorKeys.forEach(((key, index) => {
            const {range: range, targetTicks: targetTicks, targetRange: targetRange, axisOption: axisOption} = (0, 
            get_axis_config_1.getAxisRangeAndTicks)(col, row, index, 0 === index ? "bottom" : "top", 0 === index ? "top" : "bottom", indicatorKeys, colPath, layout);
            (0, vutils_1.isNumber)(null == axisOption ? void 0 : axisOption.min) && (range.min = axisOption.min), 
            (0, vutils_1.isNumber)(null == axisOption ? void 0 : axisOption.max) && (range.max = axisOption.max), 
            hasSameAxis(axisOption, axes) || axes.push((0, vutils_1.merge)({
                range: range,
                label: {
                    style: {
                        fontSize: get_axis_attributes_1.DEFAULT_TEXT_FONT_SIZE
                    }
                }
            }, axisOption, {
                type: (null == axisOption ? void 0 : axisOption.type) || "linear",
                orient: 0 === index ? "bottom" : "top",
                label: {
                    visible: !1,
                    flush: !0
                },
                title: {
                    visible: !1
                },
                domainLine: {
                    visible: !1
                },
                seriesIndex: (null == axisOption ? void 0 : axisOption.seriesId) ? void 0 : index,
                tick: {
                    tickMode: (0, tick_align_1.getTickModeFunction)(targetTicks, targetRange, range, index)
                },
                sync: {
                    axisId: NO_AXISID_FRO_VTABLE
                }
            }));
        }));
        let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
        (0, vutils_1.isArray)(rowDimensionKey) && (rowDimensionKey = rowDimensionKey[0]);
        const data = layout.dataset.cacheCollectedValues[rowDimensionKey] || layout.dataset.collectedValues[rowDimensionKey] || [], rowPath = layout.getRowKeysPath(col, row), domain = data[null != rowPath ? rowPath : ""], {axisOption: axisOption, isPercent: isPercent, chartType: chartType} = (0, 
        get_axis_config_1.getAxisOption)(col, row, "left", layout);
        axes.push((0, vutils_1.merge)({
            domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
            range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
            label: {
                style: {
                    fontSize: get_axis_attributes_1.DEFAULT_TEXT_FONT_SIZE
                }
            }
        }, axisOption, {
            type: null !== (_a = null == axisOption ? void 0 : axisOption.type) && void 0 !== _a ? _a : "band",
            orient: "left",
            label: {
                visible: !1
            },
            domainLine: {
                visible: !1
            },
            tick: {
                visible: !1
            },
            subTick: {
                visible: !1
            },
            title: {
                visible: !1
            }
        }));
    } else {
        const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), rowPath = layout.getRowKeysPath(col, row);
        indicatorKeys.forEach(((key, index) => {
            const {range: range, targetTicks: targetTicks, targetRange: targetRange, axisOption: axisOption} = (0, 
            get_axis_config_1.getAxisRangeAndTicks)(col, row, index, 0 === index ? "left" : "right", 0 === index ? "right" : "left", indicatorKeys, rowPath, layout);
            (0, vutils_1.isNumber)(null == axisOption ? void 0 : axisOption.min) && (range.min = axisOption.min), 
            (0, vutils_1.isNumber)(null == axisOption ? void 0 : axisOption.max) && (range.max = axisOption.max), 
            hasSameAxis(axisOption, axes) || axes.push((0, vutils_1.merge)({
                range: range,
                label: {
                    style: {
                        fontSize: get_axis_attributes_1.DEFAULT_TEXT_FONT_SIZE
                    }
                }
            }, axisOption, {
                type: (null == axisOption ? void 0 : axisOption.type) || "linear",
                orient: 0 === index ? "left" : "right",
                label: {
                    visible: !1,
                    flush: !0
                },
                title: {
                    visible: !1
                },
                domainLine: {
                    visible: !1
                },
                seriesIndex: (null == axisOption ? void 0 : axisOption.seriesId) ? void 0 : index,
                tick: {
                    tickMode: (0, tick_align_1.getTickModeFunction)(targetTicks, targetRange, range, index)
                },
                sync: {
                    axisId: NO_AXISID_FRO_VTABLE
                }
            }));
        }));
        let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
        (0, vutils_1.isArray)(columnDimensionKey) && (columnDimensionKey = columnDimensionKey[0]);
        const data = layout.dataset.cacheCollectedValues[columnDimensionKey] || layout.dataset.collectedValues[columnDimensionKey] || [], colPath = layout.getColKeysPath(col, row), domain = null !== (_b = null == data ? void 0 : data[null != colPath ? colPath : ""]) && void 0 !== _b ? _b : [], {axisOption: axisOption, isPercent: isPercent, chartType: chartType} = (0, 
        get_axis_config_1.getAxisOption)(col, row, "bottom", layout);
        axes.push((0, vutils_1.merge)({
            domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
            range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
            label: {
                style: {
                    fontSize: get_axis_attributes_1.DEFAULT_TEXT_FONT_SIZE
                }
            }
        }, axisOption, {
            type: null !== (_c = null == axisOption ? void 0 : axisOption.type) && void 0 !== _c ? _c : "band",
            orient: "bottom",
            visible: !0,
            label: {
                visible: !1
            },
            domainLine: {
                visible: !1
            },
            tick: {
                visible: !1
            },
            subTick: {
                visible: !1
            },
            title: {
                visible: !1
            }
        }));
    }
    return axes;
}

function getChartDataId(col, row, layout) {
    var _a;
    const chartSpec = layout.getRawChartSpec(col, row);
    if (null == chartSpec ? void 0 : chartSpec.series) {
        const dataIdfield = {};
        return (null === (_a = chartSpec.data) || void 0 === _a ? void 0 : _a.id) && (dataIdfield[chartSpec.data.id] = void 0), 
        null == chartSpec || chartSpec.series.forEach((seriesSpec => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            if (!(null === (_a = seriesSpec.data) || void 0 === _a ? void 0 : _a.fromDataId)) if (null === (_b = seriesSpec.data) || void 0 === _b ? void 0 : _b.transforms) dataIdfield[null !== (_l = null !== (_j = null === (_h = seriesSpec.data) || void 0 === _h ? void 0 : _h.id) && void 0 !== _j ? _j : null === (_k = chartSpec.data) || void 0 === _k ? void 0 : _k.id) && void 0 !== _l ? _l : "data"] = void 0; else {
                const seriesField = "horizontal" === seriesSpec.direction ? seriesSpec.xField : seriesSpec.yField;
                dataIdfield[null !== (_f = null !== (_d = null === (_c = seriesSpec.data) || void 0 === _c ? void 0 : _c.id) && void 0 !== _d ? _d : null === (_e = chartSpec.data) || void 0 === _e ? void 0 : _e.id) && void 0 !== _f ? _f : "data"] = (null === (_g = seriesSpec.data) || void 0 === _g ? void 0 : _g.id) ? seriesField : void 0;
            }
        })), dataIdfield;
    }
    return chartSpec.data.id;
}

function checkHasChart(layout) {
    let isHasChart = !1;
    for (let i = 0; i < layout.columnObjects.length; i++) {
        if (layout.columnObjects[i].chartSpec) {
            isHasChart = !0;
            break;
        }
    }
    return isHasChart;
}

function hasSameAxis(axisOption, axes) {
    if (axisOption && (0, vutils_1.isArray)(axisOption.seriesId) && axisOption.seriesId.length > 0) {
        if (axes.filter((axis => !(axis.orient !== axisOption.orient || !axis.seriesId || axis.seriesId.length !== axisOption.seriesId.length || !axis.seriesId.every(((id, index) => id === axisOption.seriesId[index]))))).length > 0) return !0;
    }
    return !1;
}

exports.getRawChartSpec = getRawChartSpec, exports.isShareChartSpec = isShareChartSpec, 
exports.isNoChartDataRenderNothing = isNoChartDataRenderNothing, exports.checkHasCartesianChart = checkHasCartesianChart, 
exports.isCartesianChart = isCartesianChart, exports.isHasCartesianChartInline = isHasCartesianChartInline, 
exports.getChartSpec = getChartSpec, exports.getChartAxes = getChartAxes, exports.getChartDataId = getChartDataId, 
exports.checkHasChart = checkHasChart;
//# sourceMappingURL=get-chart-spec.js.map
