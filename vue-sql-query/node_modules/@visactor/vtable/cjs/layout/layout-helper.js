"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.deleteHideIndicatorNode = exports.supplementIndicatorNodesForCustomTree = exports.parseColKeyRowKeyForPivotTable = exports.hasAutoImageColumn = exports.checkHasTreeDefine = exports.checkHasAggregationOnBottom = exports.checkHasAggregationOnTop = exports.checkHasAggregation = void 0;

const vutils_1 = require("@visactor/vutils"), ts_types_1 = require("../ts-types"), tree_helper_1 = require("./tree-helper");

function checkHasAggregation(layoutMap) {
    const columnObjects = layoutMap.columnObjects;
    for (let i = 0; i < columnObjects.length; i++) {
        const column = columnObjects[i];
        if (null == column ? void 0 : column.aggregation) return !0;
    }
    return !1;
}

function checkHasAggregationOnTop(layoutMap) {
    const columnObjects = layoutMap.columnObjects;
    let count = 0;
    for (let i = 0; i < columnObjects.length; i++) {
        const column = columnObjects[i];
        (null == column ? void 0 : column.aggregation) && (Array.isArray(null == column ? void 0 : column.aggregation) ? count = Math.max(count, column.aggregation.filter((item => item.showOnTop)).length) : column.aggregation.showOnTop && (count = Math.max(count, 1)));
    }
    return count;
}

function checkHasAggregationOnBottom(layoutMap) {
    const columnObjects = layoutMap.columnObjects;
    let count = 0;
    for (let i = 0; i < columnObjects.length; i++) {
        const column = columnObjects[i];
        (null == column ? void 0 : column.aggregation) && (Array.isArray(null == column ? void 0 : column.aggregation) ? count = Math.max(count, column.aggregation.filter((item => !item.showOnTop)).length) : column.aggregation.showOnTop || (count = Math.max(count, 1)));
    }
    return count;
}

function checkHasTreeDefine(layoutMap) {
    if (layoutMap._table.options.groupBy) return !0;
    const {columns: columns} = layoutMap._table.options;
    if ((0, vutils_1.isArray)(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
        const column = columns[i];
        if (!(0, vutils_1.isString)(column) && column.tree) return !0;
    }
    return !1;
}

function hasAutoImageColumn(table) {
    const {columns: columns, rows: rows, indicators: indicators} = table.options;
    if (table.isPivotTable()) {
        if ((0, vutils_1.isArray)(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
            const column = columns[i];
            if (!(0, vutils_1.isString)(column) && (("image" === column.headerType || "video" === column.headerType || "function" == typeof column.headerType) && column.imageAutoSizing)) return !0;
        }
        if ((0, vutils_1.isArray)(rows) && rows.length > 0) for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            if (!(0, vutils_1.isString)(row) && (("image" === row.headerType || "video" === row.headerType || "function" == typeof row.headerType) && row.imageAutoSizing)) return !0;
        }
        if ((0, vutils_1.isArray)(indicators) && indicators.length > 0) for (let i = 0; i < indicators.length; i++) {
            const indicator = indicators[i];
            if (!(0, vutils_1.isString)(indicator) && (("image" === indicator.cellType || "video" === indicator.cellType || "function" == typeof indicator.cellType) && indicator.imageAutoSizing || ("image" === indicator.headerType || "video" === indicator.headerType || "function" == typeof indicator.headerType) && indicator.imageAutoSizing)) return !0;
        }
    } else if ((0, vutils_1.isArray)(columns) && columns.length > 0) for (let i = 0; i < columns.length; i++) {
        const column = columns[i];
        if (("image" === column.cellType || "video" === column.cellType || "function" == typeof column.cellType) && column.imageAutoSizing || ("image" === column.headerType || "video" === column.headerType || "function" == typeof column.headerType) && column.imageAutoSizing) return !0;
    }
    return !1;
}

function parseColKeyRowKeyForPivotTable(table, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    let columnDimensionTree, rowDimensionTree;
    options.columnTree && (!1 !== table.options.indicatorsAsCol && !1 !== table.options.supplementIndicatorNodes && (table.internalProps.columnTree = supplementIndicatorNodesForCustomTree(table.internalProps.columnTree, options.indicators)), 
    columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_a = table.internalProps.columnTree) && void 0 !== _a ? _a : [], table.layoutNodeId, table.options.columnHierarchyType, "grid" !== table.options.columnHierarchyType ? null !== (_b = table.options.columnExpandLevel) && void 0 !== _b ? _b : 1 : void 0)), 
    options.rowTree && (!1 === table.options.indicatorsAsCol && !1 !== table.options.supplementIndicatorNodes && (table.internalProps.rowTree = supplementIndicatorNodesForCustomTree(table.internalProps.rowTree, options.indicators)), 
    rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_c = table.internalProps.rowTree) && void 0 !== _c ? _c : [], table.layoutNodeId, table.options.rowHierarchyType, "grid" !== table.options.rowHierarchyType ? null !== (_d = table.options.rowExpandLevel) && void 0 !== _d ? _d : 1 : void 0));
    const rowKeys = (null === (_e = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _e ? void 0 : _e.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_g = null === (_f = options.rows) || void 0 === _f ? void 0 : _f.reduce(((keys, rowObj) => ("string" == typeof rowObj ? keys.push(rowObj) : keys.push(rowObj.dimensionKey), 
    keys)), [])) && void 0 !== _g ? _g : [], columnKeys = (null === (_h = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _h ? void 0 : _h.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_k = null === (_j = options.columns) || void 0 === _j ? void 0 : _j.reduce(((keys, columnObj) => ("string" == typeof columnObj ? keys.push(columnObj) : keys.push(columnObj.dimensionKey), 
    keys)), [])) && void 0 !== _k ? _k : [], indicatorKeys = null !== (_m = null === (_l = options.indicators) || void 0 === _l ? void 0 : _l.reduce(((keys, indicatorObj) => {
        var _a;
        return "string" == typeof indicatorObj ? keys.push(indicatorObj) : (keys.push(indicatorObj.indicatorKey), 
        (indicatorObj.chartSpec || indicatorObj.sparklineSpec) && ((null === (_a = table.internalProps.dataConfig) || void 0 === _a ? void 0 : _a.aggregationRules) ? table.internalProps.dataConfig.aggregationRules.find((aggregation => aggregation.indicatorKey === indicatorObj.indicatorKey)) || table.internalProps.dataConfig.aggregationRules.push({
            field: indicatorObj.indicatorKey,
            indicatorKey: indicatorObj.indicatorKey,
            aggregationType: ts_types_1.AggregationType.NONE
        }) : table.internalProps.dataConfig ? table.internalProps.dataConfig.aggregationRules = [ {
            field: indicatorObj.indicatorKey,
            indicatorKey: indicatorObj.indicatorKey,
            aggregationType: ts_types_1.AggregationType.NONE
        } ] : table.internalProps.dataConfig = {
            aggregationRules: [ {
                field: indicatorObj.indicatorKey,
                indicatorKey: indicatorObj.indicatorKey,
                aggregationType: ts_types_1.AggregationType.NONE
            } ]
        })), keys;
    }), [])) && void 0 !== _m ? _m : [];
    return "grid" !== options.rowHierarchyType && (null !== (_p = null === (_o = options.extensionRows) || void 0 === _o ? void 0 : _o.length) && void 0 !== _p ? _p : 0) >= 1 && (null === (_q = options.extensionRows) || void 0 === _q || _q.forEach((extensionRow => {
        const extension_rowKeys = [];
        extensionRow.rows.forEach((row => {
            "string" == typeof row ? extension_rowKeys.push(row) : extension_rowKeys.push(row.dimensionKey);
        })), rowKeys.push(...extension_rowKeys);
    }))), {
        rowKeys: rowKeys,
        columnKeys: columnKeys,
        indicatorKeys: indicatorKeys,
        columnDimensionTree: columnDimensionTree,
        rowDimensionTree: rowDimensionTree
    };
}

function supplementIndicatorNodesForCustomTree(customTree, indicators) {
    const checkNode = (nodes, isHasIndicator) => {
        nodes.forEach((node => {
            var _a;
            node.indicatorKey || isHasIndicator || (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && node.children ? node.children && Array.isArray(node.children) && checkNode(node.children, isHasIndicator || !!node.indicatorKey) : node.children = null == indicators ? void 0 : indicators.map((indicator => {
                var _a;
                return "string" == typeof indicator ? {
                    indicatorKey: indicator,
                    value: indicator
                } : {
                    indicatorKey: indicator.indicatorKey,
                    value: null !== (_a = indicator.title) && void 0 !== _a ? _a : indicator.indicatorKey
                };
            }));
        }));
    };
    return (null == customTree ? void 0 : customTree.length) ? checkNode(customTree, !1) : customTree = null == indicators ? void 0 : indicators.map((indicator => {
        var _a;
        return "string" == typeof indicator ? {
            indicatorKey: indicator,
            value: indicator
        } : {
            indicatorKey: indicator.indicatorKey,
            value: null !== (_a = indicator.title) && void 0 !== _a ? _a : indicator.indicatorKey
        };
    })), customTree;
}

function deleteHideIndicatorNode(treeNodeChildren, indicators, hasHideNode, table) {
    const hasHideSettingIndicators = [];
    for (let i = 0; i < (null == indicators ? void 0 : indicators.length); i++) {
        const indicator = indicators[i];
        (null == indicator ? void 0 : indicator.hide) && hasHideSettingIndicators.push(indicator);
    }
    (hasHideSettingIndicators.length || hasHideNode) && (0, tree_helper_1.deleteTreeHideNode)(treeNodeChildren, [], hasHideSettingIndicators, hasHideNode, table);
}

exports.checkHasAggregation = checkHasAggregation, exports.checkHasAggregationOnTop = checkHasAggregationOnTop, 
exports.checkHasAggregationOnBottom = checkHasAggregationOnBottom, exports.checkHasTreeDefine = checkHasTreeDefine, 
exports.hasAutoImageColumn = hasAutoImageColumn, exports.parseColKeyRowKeyForPivotTable = parseColKeyRowKeyForPivotTable, 
exports.supplementIndicatorNodesForCustomTree = supplementIndicatorNodesForCustomTree, 
exports.deleteHideIndicatorNode = deleteHideIndicatorNode;
//# sourceMappingURL=layout-helper.js.map