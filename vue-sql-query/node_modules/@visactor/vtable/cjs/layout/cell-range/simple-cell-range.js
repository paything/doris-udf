"use strict";

function getCellRange(col, row, layout) {
    var _a, _b, _c;
    if (-1 === col || -1 === row) return {
        start: {
            col: col,
            row: row
        },
        end: {
            col: col,
            row: row
        }
    };
    if (layout._cellRangeMap.has(`$${col}$${row}`)) return layout._cellRangeMap.get(`$${col}$${row}`);
    let cellRange = {
        start: {
            col: col,
            row: row
        },
        end: {
            col: col,
            row: row
        }
    };
    if (layout.transpose) cellRange = getCellRangeTranspose(col, row, layout); else if (layout.headerLevelCount <= row) {
        if (layout.headerLevelCount <= row && (null === (_b = null === (_a = layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount]) || void 0 === _a ? void 0 : _a.define) || void 0 === _b ? void 0 : _b.mergeCell)) {
            const value = layout._table.getCellValue(col, row);
            for (let r = row - 1; r >= layout.headerLevelCount; r--) {
                const last_Value = layout._table.getCellValue(col, r);
                if ("boolean" == typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell) {
                    if (value !== last_Value) break;
                } else if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, last_Value, {
                    source: {
                        col: col,
                        row: row
                    },
                    target: {
                        col: col,
                        row: r
                    },
                    table: layout._table
                })) break;
                cellRange.start.row = r;
            }
            for (let r = row + 1; r < layout.rowCount; r++) {
                const next_Value = layout._table.getCellValue(col, r);
                if ("boolean" == typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell) {
                    if (value !== next_Value) break;
                } else if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, next_Value, {
                    source: {
                        col: col,
                        row: row
                    },
                    target: {
                        col: col,
                        row: r
                    },
                    table: layout._table
                })) break;
                cellRange.end.row = r;
            }
        }
        getTreeTitleMerge(col, row, cellRange, layout);
    } else {
        const id = layout.getCellId(col, row);
        for (let c = col - 1; c >= 0 && id === layout.getCellId(c, row); c--) cellRange.start.col = c;
        for (let c = col + 1; c < (null !== (_c = layout.colCount) && void 0 !== _c ? _c : 0) && id === layout.getCellId(c, row); c++) cellRange.end.col = c;
        for (let r = row - 1; r >= 0 && id === layout.getCellId(col, r); r--) cellRange.start.row = r;
        for (let r = row + 1; r < layout.headerLevelCount && id === layout.getCellId(col, r); r++) cellRange.end.row = r;
    }
    return layout._cellRangeMap.set(`$${col}$${row}`, cellRange), cellRange;
}

function getTreeTitleMerge(col, row, cellRange, layout) {
    var _a;
    if ("tree" !== layout.rowHierarchyType) return;
    const cellRecord = layout._table.getCellRawRecord(col, row);
    (null === (_a = layout._table.internalProps.rowSeriesNumber) || void 0 === _a ? void 0 : _a.enableTreeCheckbox) ? (null == cellRecord ? void 0 : cellRecord.vtableMerge) && col >= layout.leftRowSeriesNumberColumnCount && (cellRange.start.col = layout.rowHeaderLevelCount + layout.leftRowSeriesNumberColumnCount, 
    cellRange.end.col = layout.colCount - 1, cellRange.start.row = cellRange.end.row = row) : (null == cellRecord ? void 0 : cellRecord.vtableMerge) && (cellRange.start.col = layout.rowHeaderLevelCount, 
    cellRange.end.col = layout.colCount - 1, cellRange.start.row = cellRange.end.row = row);
}

function getCellRangeTranspose(col, row, layout) {
    var _a, _b, _c, _d;
    const result = {
        start: {
            col: col,
            row: row
        },
        end: {
            col: col,
            row: row
        }
    };
    if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col || -1 === col && -1 === row) {
        if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col && (null === (_b = null === (_a = layout.columnObjects[row]) || void 0 === _a ? void 0 : _a.define) || void 0 === _b ? void 0 : _b.mergeCell)) {
            const value = layout._table.getCellValue(col, row);
            for (let c = col - 1; c >= layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount; c--) {
                const last_Value = layout._table.getCellValue(c, row);
                if ("boolean" == typeof layout.columnObjects[row].define.mergeCell) {
                    if (value !== last_Value) break;
                } else if (!layout.columnObjects[row].define.mergeCell(value, last_Value, {
                    source: {
                        col: col,
                        row: row
                    },
                    target: {
                        col: c,
                        row: row
                    },
                    table: layout._table
                })) break;
                result.start.col = c;
            }
            for (let c = col + 1; c < (null !== (_c = layout.colCount) && void 0 !== _c ? _c : 0); c++) {
                const next_Value = layout._table.getCellValue(c, row);
                if ("boolean" == typeof layout.columnObjects[row].define.mergeCell) {
                    if (value !== next_Value) break;
                } else if (!layout.columnObjects[row].define.mergeCell(value, next_Value, {
                    source: {
                        col: col,
                        row: row
                    },
                    target: {
                        col: c,
                        row: row
                    },
                    table: layout._table
                })) break;
                result.end.col = c;
            }
        }
        return result;
    }
    const id = layout.getCellId(col, row);
    for (let r = row - 1; r >= 0 && id === layout.getCellId(col, r); r--) result.start.row = r;
    for (let r = row + 1; r < (null !== (_d = layout.rowCount) && void 0 !== _d ? _d : 0) && id === layout.getCellId(col, r); r++) result.end.row = r;
    for (let c = col - 1; c >= 0 && id === layout.getCellId(c, row); c--) result.start.col = c;
    for (let c = col + 1; c < layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount && id === layout.getCellId(c, row); c++) result.end.col = c;
    return result;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getCellRangeTranspose = exports.getCellRange = void 0, exports.getCellRange = getCellRange, 
exports.getCellRangeTranspose = getCellRangeTranspose;
//# sourceMappingURL=simple-cell-range.js.map
