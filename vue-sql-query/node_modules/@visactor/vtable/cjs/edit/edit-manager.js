"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EditManager = void 0;

const TABLE_EVENT_TYPE_1 = require("../core/TABLE_EVENT_TYPE"), util_1 = require("../event/util"), helper_1 = require("../tools/helper"), vutils_1 = require("@visactor/vutils");

class EditManager {
    constructor(table) {
        this.isValidatingValue = !1, this.listenersId = [], this.table = table, this.bindEvent();
    }
    bindEvent() {
        const table = this.table, doubleClickEventId = table.on(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.DBLCLICK_CELL, (e => {
            var _a, _b, _c;
            const {editCellTrigger: editCellTrigger = "doubleclick"} = table.options;
            if (!editCellTrigger.includes("doubleclick")) return;
            const {col: col, row: row} = e, eventArgsSet = (0, util_1.getCellEventArgsSet)(e.federatedEvent), resizeCol = table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.targetCell);
            table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0 || (null === (_c = null === (_b = e.target) || void 0 === _b ? void 0 : _b.attribute) || void 0 === _c ? void 0 : _c.funcType) || (this.beginTriggerEditCellMode = "doubleclick", 
            this.startEditCell(col, row));
        })), clickEventId = table.on(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CLICK_CELL, (e => {
            var _a, _b;
            const {editCellTrigger: editCellTrigger = "doubleclick"} = table.options;
            if ("click" === editCellTrigger || Array.isArray(editCellTrigger) && editCellTrigger.includes("click")) {
                if (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.funcType) return;
                this.beginTriggerEditCellMode = "click";
                const {col: col, row: row} = e;
                this.startEditCell(col, row);
            }
        }));
        this.listenersId.push(doubleClickEventId, clickEventId);
    }
    startEditCell(col, row, value) {
        var _a, _b, _c, _d, _e;
        if (this.editingEditor) return;
        const editor = this.table.getEditor(col, row);
        if (editor) {
            if (null === (_b = null === (_a = this.table.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isAggregation) || void 0 === _b ? void 0 : _b.call(_a, col, row)) return;
            const record = this.table.getCellRawRecord(col, row);
            if (null == record ? void 0 : record.vtableMerge) return;
            this.editingEditor || (this.editCell = {
                col: col,
                row: row
            }), this.table._makeVisibleCell(col, row), this.editingEditor = editor;
            const dataValue = (0, vutils_1.isValid)(value) ? value : this.table.getCellOriginValue(col, row), rect = this.table.getCellRangeRelativeRect(this.table.getCellRange(col, row)), referencePosition = {
                rect: {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    height: rect.height
                }
            };
            col === this.table.colCount - 1 ? referencePosition.rect.width = rect.width - 1 : referencePosition.rect.width = rect.width + 1, 
            row === this.table.rowCount - 1 ? referencePosition.rect.height = rect.height - 1 : referencePosition.rect.height = rect.height + 1, 
            editor.beginEditing, null === (_c = editor.beginEditing) || void 0 === _c || _c.call(editor, this.table.getElement(), referencePosition, dataValue), 
            editor.bindSuccessCallback, null === (_d = editor.bindSuccessCallback) || void 0 === _d || _d.call(editor, (() => {
                this.completeEdit();
            })), null === (_e = editor.onStart) || void 0 === _e || _e.call(editor, {
                value: dataValue,
                endEdit: () => {
                    this.completeEdit();
                },
                referencePosition: referencePosition,
                container: this.table.getElement(),
                col: col,
                row: row,
                table: this.table
            });
        }
    }
    completeEdit(e) {
        var _a, _b;
        if (!this.editingEditor) return !0;
        if (this.isValidatingValue) return !1;
        const target = null == e ? void 0 : e.target, {editingEditor: editor} = this;
        if (target) if (editor.targetIsOnEditor) {
            if (editor.targetIsOnEditor(target)) return !1;
        } else if (!editor.isEditorElement || editor.isEditorElement(target)) return !1;
        if (this.editingEditor.getValue, this.editingEditor.validateValue) {
            this.isValidatingValue = !0;
            const newValue = this.editingEditor.getValue(), oldValue = this.table.getCellOriginValue(this.editCell.col, this.editCell.row), maybePromiseOrValue = null === (_b = (_a = this.editingEditor).validateValue) || void 0 === _b ? void 0 : _b.call(_a, newValue, oldValue, this.editCell, this.table);
            return (0, helper_1.isPromise)(maybePromiseOrValue) ? (this.isValidatingValue = !0, 
            new Promise(((resolve, reject) => {
                maybePromiseOrValue.then((result => {
                    dealWithValidateValue(result, this, oldValue, resolve);
                })).catch((err => {
                    this.isValidatingValue = !1, reject(err);
                }));
            }))) : dealWithValidateValue(maybePromiseOrValue, this, oldValue);
        }
        return this.doExit(), !0;
    }
    doExit() {
        var _a, _b, _c, _d, _e, _f;
        const changedValue = null === (_b = (_a = this.editingEditor).getValue) || void 0 === _b ? void 0 : _b.call(_a), range = this.table.getCellRange(this.editCell.col, this.editCell.row), changedValues = [];
        for (let row = range.start.row; row <= range.end.row; row++) {
            const rowChangedValues = [];
            for (let col = range.start.col; col <= range.end.col; col++) rowChangedValues.push(changedValue);
            changedValues.push(rowChangedValues);
        }
        this.table.changeCellValues(range.start.col, range.start.row, changedValues), this.editingEditor.exit, 
        null === (_d = (_c = this.editingEditor).exit) || void 0 === _d || _d.call(_c), 
        null === (_f = (_e = this.editingEditor).onEnd) || void 0 === _f || _f.call(_e), 
        this.editingEditor = null, this.isValidatingValue = !1, this.beginTriggerEditCellMode = null;
    }
    cancelEdit() {
        var _a, _b, _c, _d;
        this.editingEditor && (null === (_b = (_a = this.editingEditor).exit) || void 0 === _b || _b.call(_a), 
        null === (_d = (_c = this.editingEditor).onEnd) || void 0 === _d || _d.call(_c), 
        this.editingEditor = null);
    }
    release() {
        this.listenersId.forEach((id => {
            this.table.off(id);
        }));
    }
}

function dealWithValidateValue(validateValue, editManager, oldValue, resolve) {
    return editManager.isValidatingValue = !1, "validate-exit" === validateValue ? (editManager.doExit(), 
    null == resolve || resolve(!0), !0) : "invalidate-exit" === validateValue ? (editManager.editingEditor.setValue(oldValue), 
    editManager.doExit(), null == resolve || resolve(!0), !0) : "validate-not-exit" === validateValue || "invalidate-not-exit" === validateValue ? (null == resolve || resolve(!1), 
    !1) : !0 === validateValue ? (editManager.doExit(), null == resolve || resolve(!0), 
    !0) : (null == resolve || resolve(!1), !1);
}

//# sourceMappingURL=edit-manager.js.map
exports.EditManager = EditManager;