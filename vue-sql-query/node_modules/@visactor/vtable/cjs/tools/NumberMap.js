"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.NumberMap = void 0;

const vutils_1 = require("@visactor/vutils"), indexFirst = (arr, elm) => {
    let low = 0, high = arr.length - 1;
    for (;low <= high; ) {
        const i = Math.floor((low + high) / 2);
        if (arr[i] === elm) return i;
        arr[i] > elm ? high = i - 1 : low = i + 1;
    }
    return high < 0 ? 0 : high;
};

class NumberMap {
    constructor() {
        this._keys = [], this._vals = {}, this._sorted = !1;
    }
    count() {
        return this._keys.length;
    }
    values() {
        return this._vals;
    }
    valueArr() {
        return Object.values(this._vals);
    }
    adjustOrder(sourceIndex, targetIndex, moveCount) {
        const {_keys: keys} = this;
        if (this._sorted || (keys.sort(((a, b) => a < b ? -1 : a > b ? 1 : 0)), this._sorted = !0), 
        sourceIndex > targetIndex) {
            const sourceVals = [];
            for (let i = indexFirst(keys, sourceIndex + moveCount - 1); i >= 0; i--) {
                const key = keys[i];
                if (key >= sourceIndex) sourceVals.push(this.get(key)); else if (targetIndex <= key && key < sourceIndex) this.put(key + moveCount, this.get(key)); else if (key < targetIndex) break;
            }
            for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[moveCount - 1 - i]);
        }
        const {length: length} = keys;
        if (sourceIndex < targetIndex) {
            const sourceVals = [];
            for (let i = indexFirst(keys, sourceIndex); i < length; i++) {
                const key = keys[i];
                if (key >= sourceIndex && key < sourceIndex + moveCount) sourceVals.push(this.get(key)); else if (sourceIndex + moveCount <= key && key <= targetIndex) this.put(key - moveCount, this.get(key)); else if (key > targetIndex) break;
            }
            for (let i = 0; i < moveCount; i++) this.put(targetIndex + i, sourceVals[i]);
        }
    }
    exchangeOrder(sourceIndex, sourceCount, targetIndex, targetCount, insertIndex) {
        const {_keys: keys} = this;
        if (this._sorted || (keys.sort(((a, b) => a < b ? -1 : a > b ? 1 : 0)), this._sorted = !0), 
        sourceIndex > targetIndex) {
            const targetVals = [], sourceVals = [];
            for (let i = indexFirst(keys, targetIndex); i < indexFirst(keys, sourceIndex) + sourceCount; i++) {
                const key = keys[i];
                key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
            }
            for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
            for (let i = 0; i < targetVals.length; i++) this.put(insertIndex + sourceCount + i, targetVals[i]);
        } else {
            const targetVals = [], sourceVals = [];
            for (let i = indexFirst(keys, sourceIndex); i < indexFirst(keys, targetIndex) + targetCount; i++) {
                const key = keys[i];
                key >= sourceIndex && key < sourceIndex + sourceCount ? sourceVals.push(this.get(key)) : targetVals.push(this.get(key));
            }
            for (let i = 0; i < sourceCount; i++) this.put(insertIndex + i, sourceVals[i]);
            for (let i = 0; i < targetVals.length; i++) this.put(sourceIndex + i, targetVals[i]);
        }
    }
    del(key) {
        delete this._vals[key];
        const index = this._keys.indexOf(key);
        -1 !== index && this._keys.splice(index, 1);
    }
    put(key, value) {
        key in this._vals || (this._keys.push(key), this._sorted = !1), this._vals[key] = value;
    }
    get(key) {
        return this._vals[key];
    }
    has(key) {
        return (0, vutils_1.isValid)(this._vals[key]);
    }
    contain(value) {
        return Object.values(this._vals).indexOf(value) >= 0;
    }
    each(keyFrom, keyTo, fn) {
        const {_keys: keys} = this, {length: length} = keys;
        this._sorted || (keys.sort(((a, b) => a < b ? -1 : a > b ? 1 : 0)), this._sorted = !0);
        for (let i = indexFirst(keys, keyFrom); i < length; i++) {
            const key = keys[i];
            if (keyFrom <= key && key <= keyTo) {
                if (!1 === fn(this.get(key), key)) break;
            } else if (keyTo < key) return;
        }
    }
    clear() {
        this._keys.length = 0, this._vals = {}, this._sorted = !1;
    }
    getLastIndex() {
        return this._keys[this._keys.length - 1];
    }
    delLast() {
        const lastIndex = this.getLastIndex();
        this.del(lastIndex);
    }
    delAndReorder(index) {
        if (!this.has(index)) return;
        const lastIndex = this.getLastIndex();
        this.adjustOrder(index + 1, index, lastIndex - index), this.delLast();
    }
    addAndReorder(index, newValue) {
        if ((0, vutils_1.isValid)(newValue)) {
            const lastIndex = this.getLastIndex();
            this.adjustOrder(index, index + 1, lastIndex - index), this.put(index, newValue);
        }
    }
}

exports.NumberMap = NumberMap;
//# sourceMappingURL=NumberMap.js.map
