"use strict";

function diffCellAddress(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
    const columnHeaderStart = layout.columnHeaderLevelCount, addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
    for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
    for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
        const newCellAddr = {
            col: col,
            row: columnHeaderStart + i
        };
        addCellPositionsRowDirection.push(newCellAddr);
    }
    let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
    const updateCellPositionsRowDirection = [];
    for (parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress); parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), 
    parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), 
    updateCellPositionsRowDirection.push(parentCellAddress));
    return {
        addCellPositionsRowDirection: addCellPositionsRowDirection,
        removeCellPositionsRowDirection: removeCellPositionsRowDirection,
        updateCellPositionsRowDirection: updateCellPositionsRowDirection
    };
}

function diffCellAddressForGridTree(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
    const columnHeaderStart = layout.columnHeaderLevelCount, addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
    for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
    for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
        const newCellAddr = {
            col: col,
            row: columnHeaderStart + i
        };
        addCellPositionsRowDirection.push(newCellAddr);
    }
    let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
    const updateCellPositionsRowDirection = [];
    for (parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress); parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), 
    parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), 
    updateCellPositionsRowDirection.push(parentCellAddress));
    const addCellPositionsColumnDirection = [], removeCellPositionsColumnDirection = [];
    if ("grid-tree" === layout.rowHierarchyType && "column" === layout.cornerSetting.titleOnDimension && layout.rowHeaderLevelCount !== layout._cornerHeaderCellIds[0].length) if (layout.rowHeaderLevelCount > layout._cornerHeaderCellIds[0].length) for (let i = layout._cornerHeaderCellIds[0].length; i < layout.rowHeaderLevelCount; i++) addCellPositionsColumnDirection.push({
        col: i,
        row: row
    }); else for (let i = layout.rowHeaderLevelCount; i < layout._cornerHeaderCellIds[0].length; i++) removeCellPositionsColumnDirection.push({
        col: i,
        row: row
    });
    return {
        addCellPositionsRowDirection: addCellPositionsRowDirection,
        removeCellPositionsRowDirection: removeCellPositionsRowDirection,
        updateCellPositionsRowDirection: updateCellPositionsRowDirection,
        addCellPositionsColumnDirection: addCellPositionsColumnDirection,
        removeCellPositionsColumnDirection: removeCellPositionsColumnDirection
    };
}

function diffCellAddressForGridTreeOnColumn(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
    const rowHeaderStart = layout.rowHeaderLevelCount, addCellPositionsColumnDirection = [], removeCellPositionsColumnDirection = [];
    for (let i = 0; i < oldCellIds.length; i++) newCellIds.includes(oldCellIds[i]) || removeCellPositionsColumnDirection.push(oldRowHeaderCellPositons[i]);
    for (let i = 0; i < newCellIds.length; i++) if (!oldCellIds.includes(newCellIds[i])) {
        const newCellAddr = {
            col: rowHeaderStart + i,
            row: row
        };
        addCellPositionsColumnDirection.push(newCellAddr);
    }
    let parentId = layout.getParentCellId(col, row), parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
    const updateCellPositionsColumnDirection = [];
    for (parentCellAddress && updateCellPositionsColumnDirection.push(parentCellAddress); parentCellAddress && parentId; ) parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row), 
    parentId && (parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId), 
    updateCellPositionsColumnDirection.push(parentCellAddress));
    const addCellPositionsRowDirection = [], removeCellPositionsRowDirection = [];
    if ("grid-tree" === layout.columnHierarchyType && "row" === layout.cornerSetting.titleOnDimension && layout.columnHeaderLevelCount !== layout._cornerHeaderCellIds.length) if (layout.columnHeaderLevelCount > layout._cornerHeaderCellIds.length) for (let i = layout._cornerHeaderCellIds.length; i < layout.columnHeaderLevelCount; i++) addCellPositionsRowDirection.push({
        col: col,
        row: i
    }); else for (let i = layout.columnHeaderLevelCount; i < layout._cornerHeaderCellIds.length; i++) removeCellPositionsRowDirection.push({
        col: col,
        row: i
    });
    return {
        addCellPositionsColumnDirection: addCellPositionsColumnDirection,
        removeCellPositionsColumnDirection: removeCellPositionsColumnDirection,
        updateCellPositionsColumnDirection: updateCellPositionsColumnDirection,
        addCellPositionsRowDirection: addCellPositionsRowDirection,
        removeCellPositionsRowDirection: removeCellPositionsRowDirection
    };
}

function diffCellIndices(oldIndexedData, currentIndexedData) {
    const add = [], remove = [];
    for (let i = 0; i < oldIndexedData.length; i++) {
        let removed = !0;
        for (let j = 0; j < currentIndexedData.length; j++) if (checkIndex(oldIndexedData[i], currentIndexedData[j])) {
            removed = !1;
            break;
        }
        removed && remove.push(i);
    }
    for (let i = 0; i < currentIndexedData.length; i++) {
        let added = !0;
        for (let j = 0; j < oldIndexedData.length; j++) if (checkIndex(oldIndexedData[j], currentIndexedData[i])) {
            added = !1;
            break;
        }
        added && add.push(i);
    }
    return {
        add: add,
        remove: remove
    };
}

function checkIndex(oldIndex, newIndex) {
    if (typeof oldIndex != typeof newIndex) return !1;
    if ("number" == typeof oldIndex && "number" == typeof newIndex && oldIndex !== newIndex) return !1;
    if (oldIndex.length !== newIndex.length) return !1;
    for (let i = 0; i < oldIndex.length; i++) if (oldIndex[i] !== newIndex[i]) return !1;
    return !0;
}

function calculateArrayDiff(originalArray, targetArray, startIndex) {
    const add = [], remove = [], originalMap = new Map;
    for (let i = 0; i < originalArray.length; i++) {
        const element = originalArray[i], key = JSON.stringify(element);
        originalMap.has(key) ? originalMap.get(key).push(i) : originalMap.set(key, [ i ]);
    }
    for (let i = 0; i < targetArray.length; i++) {
        const element = targetArray[i], key = JSON.stringify(element);
        if (originalMap.has(key)) {
            const indices = originalMap.get(key);
            indices.shift(), 0 === indices.length && originalMap.delete(key);
        } else add.push(i + startIndex);
    }
    for (let i = 0; i < originalArray.length; i++) {
        const element = originalArray[i];
        targetArray.some((item => isEqual(item, element))) || remove.push(i + startIndex);
    }
    return {
        add: add,
        remove: remove
    };
}

function isEqual(arr1, arr2) {
    if (arr1 === arr2) return !0;
    if (arr1.length !== arr2.length) return !1;
    for (let i = 0; i < arr1.length; i++) if (arr1[i] !== arr2[i]) return !1;
    return !0;
}

function callUpdateRowOnScenegraph(result, recalculateColWidths, newFrozenRowCount, oldFrozenRowCount, scenegraph) {
    var _a, _b, _c;
    ((null === (_a = result.addCellPositionsRowDirection) || void 0 === _a ? void 0 : _a.length) || (null === (_b = result.removeCellPositionsRowDirection) || void 0 === _b ? void 0 : _b.length) || (null === (_c = result.updateCellPositionsRowDirection) || void 0 === _c ? void 0 : _c.length)) && scenegraph.updateRow(result.removeCellPositionsRowDirection, result.addCellPositionsRowDirection.map((item => (item.row += newFrozenRowCount - oldFrozenRowCount, 
    item))), result.updateCellPositionsRowDirection, recalculateColWidths);
}

function callUpdateColOnScenegraph(result, newFrozenColCount, oldFrozenColCount, scenegraph) {
    var _a, _b, _c;
    ((null === (_a = result.addCellPositionsColumnDirection) || void 0 === _a ? void 0 : _a.length) || (null === (_b = result.removeCellPositionsColumnDirection) || void 0 === _b ? void 0 : _b.length) || (null === (_c = result.updateCellPositionsColumnDirection) || void 0 === _c ? void 0 : _c.length)) && scenegraph.updateCol(result.removeCellPositionsColumnDirection, result.addCellPositionsColumnDirection.map((item => (item.col += newFrozenColCount - oldFrozenColCount, 
    item))), result.updateCellPositionsColumnDirection);
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.callUpdateColOnScenegraph = exports.callUpdateRowOnScenegraph = exports.calculateArrayDiff = exports.diffCellAddressForGridTreeOnColumn = exports.diffCellAddressForGridTree = exports.diffCellAddress = void 0, 
exports.diffCellAddress = diffCellAddress, exports.diffCellAddressForGridTree = diffCellAddressForGridTree, 
exports.diffCellAddressForGridTreeOnColumn = diffCellAddressForGridTreeOnColumn, 
exports.calculateArrayDiff = calculateArrayDiff, exports.callUpdateRowOnScenegraph = callUpdateRowOnScenegraph, 
exports.callUpdateColOnScenegraph = callUpdateColOnScenegraph;
//# sourceMappingURL=diff-cell.js.map
