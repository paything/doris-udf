"use strict";

function getCellMergeRange(cellGroup, scene) {
    if (!scene || !scene.proxy) return {
        colStart: 0,
        colEnd: 0,
        rowStart: 0,
        rowEnd: 0
    };
    const {mergeStartCol: mergeStartCol, mergeEndCol: mergeEndCol, mergeStartRow: mergeStartRow, mergeEndRow: mergeEndRow, col: col, row: row} = cellGroup;
    return {
        colStart: mergeStartCol,
        colEnd: mergeEndCol,
        rowStart: mergeStartRow,
        rowEnd: mergeEndRow
    };
}

function expendCellRange(cellRange, table) {
    const colStart = cellRange.start.col, colEnd = cellRange.end.col, rowStart = cellRange.start.row, rowEnd = cellRange.end.row;
    let newColStart = colStart, newColEnd = colEnd, newRowStart = rowStart, newRowEnd = rowEnd;
    for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
        const mergeRange = table.getCellRange(col, row);
        mergeRange && (newColStart = Math.min(newColStart, mergeRange.start.col), newColEnd = Math.max(newColEnd, mergeRange.end.col), 
        newRowStart = Math.min(newRowStart, mergeRange.start.row), newRowEnd = Math.max(newRowEnd, mergeRange.end.row));
    }
    return cellRange.start.col = newColStart, cellRange.end.col = newColEnd, cellRange.start.row = newRowStart, 
    cellRange.end.row = newRowEnd, cellRange;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.expendCellRange = exports.getCellMergeRange = void 0, exports.getCellMergeRange = getCellMergeRange, 
exports.expendCellRange = expendCellRange;
//# sourceMappingURL=merge-range.js.map
