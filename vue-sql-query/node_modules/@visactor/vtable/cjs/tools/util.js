"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.traverseObject = exports.isDivSelected = exports.deduplication = exports.isAllDigits = exports.toBoolean = exports.hashCode = exports.isArrEqual = exports.inBound = exports.getValueByPath = exports.defaultOrderFn = exports.isMobile = exports.validToString = exports.toFixed = exports.changeColor = exports.throttle2 = exports.throttle = exports.debounce = exports.transpose = exports.convertInternal = exports.ingoreNoneValueMerge = exports.merge = exports.isGlobal = exports.isDocument = exports.isError = exports.isNull = exports.isUndefined = exports.isDate = exports.isSymbol = exports.isBoolean = exports.isRegExp = exports.isNumber = exports.isString = exports.isArray = exports.isFunction = exports.isObject = exports.isIt = exports.judgeType = void 0;

const vutils_1 = require("@visactor/vutils"), judgeType = value => {
    switch (Object.prototype.toString.call(value)) {
      case "[object Object]":
        return "object";

      case "[object Function]":
        return "function";

      case "[object Array]":
        return "array";

      case "[object String]":
        return "string";

      case "[object Number]":
        return "number";

      case "[object RegExp]":
        return "regExp";

      case "[object Boolean]":
        return "boolean";

      case "[object Symbol]":
        return "symbol";

      case "[object Date]":
        return "date";

      case "[object Undefined]":
        return "undefined";

      case "[object Null]":
        return "null";

      case "[object Error]":
        return "error";

      case "[object HTMLDocument]":
        return "document";

      case "[object global]":
        return "global";

      default:
        return null;
    }
};

exports.judgeType = judgeType;

const isIt = (v, type) => (0, exports.judgeType)(v) === type;

exports.isIt = isIt;

const isObject = v => (0, exports.isIt)(v, "object");

exports.isObject = isObject;

const isFunction = v => (0, exports.isIt)(v, "function");

exports.isFunction = isFunction;

const isArray = v => (0, exports.isIt)(v, "array");

exports.isArray = isArray;

const isString = v => (0, exports.isIt)(v, "string");

exports.isString = isString;

const isNumber = v => (0, exports.isIt)(v, "number");

exports.isNumber = isNumber;

const isRegExp = v => (0, exports.isIt)(v, "regExp");

exports.isRegExp = isRegExp;

const isBoolean = v => (0, exports.isIt)(v, "boolean");

exports.isBoolean = isBoolean;

const isSymbol = v => (0, exports.isIt)(v, "symbol");

exports.isSymbol = isSymbol;

const isDate = v => (0, exports.isIt)(v, "date");

exports.isDate = isDate;

const isUndefined = v => (0, exports.isIt)(v, "undefined");

exports.isUndefined = isUndefined;

const isNull = v => (0, exports.isIt)(v, "null");

exports.isNull = isNull;

const isError = v => (0, exports.isIt)(v, "error");

exports.isError = isError;

const isDocument = v => (0, exports.isIt)(v, "document");

exports.isDocument = isDocument;

const isGlobal = v => (0, exports.isIt)(v, "global");

function merge(target, ...sources) {
    if (!sources.length) return target || {};
    const source = sources.shift();
    if ((0, exports.isObject)(target) && (0, exports.isObject)(source)) for (const key in source) (0, 
    exports.isObject)(source[key]) ? (target[key] || Object.assign(target, {
        [key]: {}
    }), (0, exports.isObject)(target[key]) || Object.assign(target, {
        [key]: source[key]
    }), merge(target[key], source[key])) : Object.assign(target, {
        [key]: source[key]
    });
    return merge(target, ...sources);
}

function ingoreNoneValueMerge(target, ...sources) {
    if (!sources.length) return target || {};
    const source = sources.shift();
    if ((0, exports.isObject)(target) && (0, exports.isObject)(source)) for (const key in source) (0, 
    exports.isObject)(source[key]) ? (target[key] || Object.assign(target, {
        [key]: {}
    }), (0, exports.isObject)(target[key]) || Object.assign(target, {
        [key]: source[key]
    }), ingoreNoneValueMerge(target[key], source[key])) : null !== source[key] && void 0 !== source[key] && Object.assign(target, {
        [key]: source[key]
    });
    return ingoreNoneValueMerge(target, ...sources);
}

function convertInternal(value) {
    return "function" == typeof value && (value = value()), (0, vutils_1.isValid)(value) ? `${value}` : "";
}

function transpose(matrix) {
    if ((null == matrix ? void 0 : matrix.length) <= 0) return matrix;
    const m = matrix.length, n = matrix[0].length, transposed = new Array(n);
    for (let i = 0; i < m; i++) for (let j = 0; j < n; j++) transposed[j] || (transposed[j] = new Array(m)), 
    transposed[j][i] = matrix[i][j];
    return transposed;
}

function debounce(fn, delay, immediate = !1) {
    let timer, result;
    return function(...args) {
        if (timer && clearTimeout(timer), immediate) {
            if (!timer) return result = fn.apply(this, args), result;
            timer = setTimeout((() => timer = 0), delay);
        } else timer = setTimeout((() => fn.apply(this, args)), delay);
    };
}

function throttle(func, delay) {
    let timer = null;
    return function(...args) {
        timer || (func.apply(this, args), timer = setTimeout((() => {
            timer = null;
        }), delay));
    };
}

function throttle2(func, delay) {
    let timer = null;
    return function(...args) {
        timer || (timer = setTimeout((() => {
            func.apply(this, args), timer = null;
        }), delay));
    };
}

function pad(num, totalChars) {
    for (num = `${num}`; num.length < totalChars; ) num = "0" + num;
    return num;
}

function changeColor(color, ratio, isDarker) {
    color = (color = color.replace(/^\s*|\s*$/, "")).replace(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i, "#$1$1$2$2$3$3");
    const difference = Math.round(256 * ratio) * (isDarker ? -1 : 1), rgb = color.match(new RegExp("^rgba?\\(\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\s*,\\s*(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])(?:\\s*,\\s*(0|1|0?\\.\\d+))?\\s*\\)$", "i")), alpha = rgb && (0, 
    vutils_1.isValid)(rgb[4]) ? rgb[4] : null, decimal = rgb ? [ rgb[1], rgb[2], rgb[3] ] : color.replace(/^#?([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])/i, (function() {
        return `${parseInt(arguments[1], 16)},${parseInt(arguments[2], 16)},${parseInt(arguments[3], 16)}`;
    })).split(/,/);
    return rgb ? `rgb${null !== alpha ? "a" : ""}(${Math[isDarker ? "max" : "min"](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? "max" : "min"](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? "max" : "min"](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255)}${null !== alpha ? `, ${alpha}` : ""})` : [ "#", pad(Math[isDarker ? "max" : "min"](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255).toString(16), 2), pad(Math[isDarker ? "max" : "min"](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255).toString(16), 2), pad(Math[isDarker ? "max" : "min"](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255).toString(16), 2) ].join("");
}

function toFixed(n, fixed = 0) {
    return parseFloat(n.toFixed(fixed));
}

function validToString(v) {
    return (0, exports.isString)(v) || (0, exports.isNumber)(v) || (0, exports.isBoolean)(v) ? v.toString() : "";
}

function isMobile() {
    return navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
}

function defaultOrderFn(v1, v2, order) {
    return "desc" !== order ? v1 === v2 ? 0 : v1 > v2 ? 1 : -1 : v1 === v2 ? 0 : v1 < v2 ? 1 : -1;
}

function getValueByPath(obj, paths) {
    let prop, res = obj;
    for (;(prop = paths.shift()) && (res = res[prop], res); ) ;
    return res;
}

function inBound({x: x, y: y}, {left: left, top: top, width: width, height: height}) {
    return x > left && x < left + width && y > top && y < top + height;
}

exports.isGlobal = isGlobal, exports.merge = merge, exports.ingoreNoneValueMerge = ingoreNoneValueMerge, 
exports.convertInternal = convertInternal, exports.transpose = transpose, exports.debounce = debounce, 
exports.throttle = throttle, exports.throttle2 = throttle2, exports.changeColor = changeColor, 
exports.toFixed = toFixed, exports.validToString = validToString, exports.isMobile = isMobile, 
exports.defaultOrderFn = defaultOrderFn, exports.getValueByPath = getValueByPath, 
exports.inBound = inBound;

const isArrEqual = (arr1, arr2) => arr1.length === arr2.length && arr1.every(((ele, index) => Object.is(ele, arr2[index])));

function hashCode(input) {
    const I64BIT_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-".split("");
    let hash = 5381, i = input.length - 1;
    for (;i > -1; i--) hash += (hash << 5) + input.charCodeAt(i);
    let value = 2147483647 & hash, retValue = "";
    do {
        retValue += I64BIT_TABLE[63 & value];
    } while (value >>= 6);
    return retValue;
}

function toBoolean(val) {
    if ("string" == typeof val) {
        if ("false" === val) return !1;
        if ("off" === val) return !1;
        if (/^0+$/.exec(val)) return !1;
    }
    return Boolean(val);
}

function isAllDigits(str) {
    return /^-?\d+(\.\d+)?$/.test(str);
}

function deduplication(array) {
    const result = [];
    for (let i = 0; i < array.length; i++) -1 === result.indexOf(array[i]) && result.push(array[i]);
    return result;
}

function isDivSelected(div) {
    const selection = window.getSelection();
    if (selection.rangeCount) {
        const range = selection.getRangeAt(0);
        return range.endOffset > range.startOffset && div.contains(range.commonAncestorContainer);
    }
    return !1;
}

function traverseObject(obj, childrenProperty, callback) {
    callback(obj), (null == obj ? void 0 : obj[childrenProperty]) && Array.isArray(null == obj ? void 0 : obj[childrenProperty]) && obj[childrenProperty].forEach((child => traverseObject(child, childrenProperty, callback)));
}

exports.isArrEqual = isArrEqual, exports.hashCode = hashCode, exports.toBoolean = toBoolean, 
exports.isAllDigits = isAllDigits, exports.deduplication = deduplication, exports.isDivSelected = isDivSelected, 
exports.traverseObject = traverseObject;
//# sourceMappingURL=util.js.map
