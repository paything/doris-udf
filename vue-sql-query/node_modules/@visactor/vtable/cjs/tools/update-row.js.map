{"version":3,"sources":["../src/tools/update-row.ts"],"names":[],"mappings":";;;AAiBA,SAAgB,iBAAiB,CAC/B,aAGC,EAED,GAAW,EACX,GAAW,EACX,KAAmB;IAEnB,MAAM,WAAW,GAAG,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IACnC,MAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,MAAM,WAAW,GAAG,EAAE,CAAC;IAEvB,MAAM,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,GAAG,aAAa,CAAC;IAChE,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC;IACrC,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;IACrC,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;IACvB,IAAI,SAAS,GAAG,QAAQ,CAAC;IAEzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAChD,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;QAE7C,IAAI,MAAM,GAAG,QAAQ,GAAG,CAAC,KAAK,QAAQ,EAAE;YAEtC,IAAI,OAAO,IAAI,QAAQ,IAAI,OAAO,IAAI,MAAM,EAAE;gBAC5C,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aAC1C;SACF;aAAM;YAEL,QAAQ,CAAC,IAAI,CAAC;gBACZ,GAAG;gBACH,GAAG,EAAE,OAAO;aACb,CAAC,CAAC;YACH,MAAM,EAAE,CAAC;SACV;KACF;IAED,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,QAAQ,EAAE,KAAK,CAAC,QAAQ,GAAG,CAAC,GAAG,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACjG,MAAM,UAAU,GAAG,SAAS,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnD,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,mBAAmB,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACjF,IAAI,OAAO,GAAG,QAAQ,IAAI,OAAO,GAAG,MAAM,EAAE;YAE1C,SAAS;SACV;aAAM,IAAI,OAAO,GAAG,SAAS,EAAE;YAE9B,WAAW,CAAC,IAAI,CAAC;gBACf,GAAG;gBACH,GAAG,EAAE,OAAO;aACb,CAAC,CAAC;YACH,SAAS,EAAE,CAAC;SACb;aAAM,IAAI,UAAU,EAAE;YAErB,WAAW,CAAC,IAAI,CAAC;gBACf,GAAG;gBACH,GAAG,EAAE,OAAO;aACb,CAAC,CAAC;YACH,SAAS,EAAE,CAAC;SACb;aAAM;YAEL,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;SAC1C;KACF;IAED,IAAI,SAAS,KAAK,QAAQ,EAAE;QAC1B,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,CAAC,IAAI,MAAM,EAAE,CAAC,EAAE,EAAE;YACxC,WAAW,CAAC,IAAI,CAAC;gBACf,GAAG;gBACH,GAAG,EAAE,CAAC;aACP,CAAC,CAAC;SACJ;KACF;IAED,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;IACzC,OAAO;QACL,WAAW;QACX,QAAQ;QACR,WAAW;KACZ,CAAC;AACJ,CAAC;AAhFD,8CAgFC","file":"update-row.js","sourcesContent":["import type { CellAddress } from '../ts-types';\nimport type { BaseTableAPI } from '../ts-types/base-table';\n\n/*\n * fix update row range logic:\n *\n * ADD:\n * 1. proxy not full => add\n * 2. proxy full\n *   2.1 row outside of proxy row range => skip\n *   2.2 row inside of proxy row range => update row to proxy rowEnd\n * REM:\n * 1. row before rowStart or after rowEnd => skip\n * 2. row after rowStart and before new rowEnd => update row to rowEnd\n * 3. rows after new rowEnd before old rowEnd => delete\n */\n\nexport function fixUpdateRowRange(\n  diffPositions: {\n    addCellPositions: CellAddress[];\n    removeCellPositions: CellAddress[];\n  },\n  // updateCells: CellAddress[], // default [{col,row}]\n  col: number,\n  row: number,\n  table: BaseTableAPI\n) {\n  const updateCells = [{ col, row }];\n  const addCells = [];\n  const removeCells = [];\n\n  const { addCellPositions, removeCellPositions } = diffPositions;\n  const proxy = table.scenegraph.proxy;\n  const { rowStart, rowLimit } = proxy;\n  let { rowEnd } = proxy;\n  let updateRow = Infinity;\n\n  for (let i = 0; i < addCellPositions.length; i++) {\n    const { row: cellRow } = addCellPositions[i];\n\n    if (rowEnd - rowStart + 1 === rowLimit) {\n      // current row cell is full\n      if (cellRow >= rowStart && cellRow <= rowEnd) {\n        updateRow = Math.min(updateRow, cellRow);\n      }\n    } else {\n      // row cell is not full\n      addCells.push({\n        col,\n        row: cellRow\n      });\n      rowEnd++;\n    }\n  }\n\n  const newRowEnd = Math.min(rowStart + rowLimit, table.rowCount - 1 - table.bottomFrozenRowCount);\n  const notFullRow = newRowEnd < rowStart + rowLimit;\n  for (let i = 0; i < removeCellPositions.length; i++) {\n    const { row: cellRow } = removeCellPositions[removeCellPositions.length - i - 1];\n    if (cellRow < rowStart || cellRow > rowEnd) {\n      // row before rowStart or after rowEnd => skip\n      continue;\n    } else if (cellRow > newRowEnd) {\n      // rows after new rowEnd before old rowEnd => delete\n      removeCells.push({\n        col,\n        row: cellRow\n      });\n      updateRow--;\n    } else if (notFullRow) {\n      // row range is not full\n      removeCells.push({\n        col,\n        row: cellRow\n      });\n      updateRow--;\n    } else {\n      // row after rowStart and before new rowEnd => update row to rowEnd\n      updateRow = Math.min(updateRow, cellRow);\n    }\n  }\n\n  if (updateRow !== Infinity) {\n    for (let i = updateRow; i <= rowEnd; i++) {\n      updateCells.push({\n        col,\n        row: i\n      });\n    }\n  }\n\n  table.scenegraph.proxy.refreshRowCount();\n  return {\n    updateCells,\n    addCells,\n    removeCells\n  };\n}\n"]}