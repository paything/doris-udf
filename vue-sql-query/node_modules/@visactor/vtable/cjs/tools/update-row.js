"use strict";

function fixUpdateRowRange(diffPositions, col, row, table) {
    const updateCells = [ {
        col: col,
        row: row
    } ], addCells = [], removeCells = [], {addCellPositions: addCellPositions, removeCellPositions: removeCellPositions} = diffPositions, proxy = table.scenegraph.proxy, {rowStart: rowStart, rowLimit: rowLimit} = proxy;
    let {rowEnd: rowEnd} = proxy, updateRow = 1 / 0;
    for (let i = 0; i < addCellPositions.length; i++) {
        const {row: cellRow} = addCellPositions[i];
        rowEnd - rowStart + 1 === rowLimit ? cellRow >= rowStart && cellRow <= rowEnd && (updateRow = Math.min(updateRow, cellRow)) : (addCells.push({
            col: col,
            row: cellRow
        }), rowEnd++);
    }
    const newRowEnd = Math.min(rowStart + rowLimit, table.rowCount - 1 - table.bottomFrozenRowCount), notFullRow = newRowEnd < rowStart + rowLimit;
    for (let i = 0; i < removeCellPositions.length; i++) {
        const {row: cellRow} = removeCellPositions[removeCellPositions.length - i - 1];
        cellRow < rowStart || cellRow > rowEnd || (cellRow > newRowEnd || notFullRow ? (removeCells.push({
            col: col,
            row: cellRow
        }), updateRow--) : updateRow = Math.min(updateRow, cellRow));
    }
    if (updateRow !== 1 / 0) for (let i = updateRow; i <= rowEnd; i++) updateCells.push({
        col: col,
        row: i
    });
    return table.scenegraph.proxy.refreshRowCount(), {
        updateCells: updateCells,
        addCells: addCells,
        removeCells: removeCells
    };
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.fixUpdateRowRange = void 0, exports.fixUpdateRowRange = fixUpdateRowRange;
//# sourceMappingURL=update-row.js.map
