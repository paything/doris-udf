"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
}, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTable = void 0;

const columnStyleContents = __importStar(require("../body-helper/style")), style_1 = require("./style"), style = __importStar(require("../tools/style")), ts_types_1 = require("../ts-types"), helper_1 = require("../tools/helper"), TABLE_EVENT_TYPE_1 = require("./TABLE_EVENT_TYPE"), EventHandler_1 = require("../event/EventHandler"), EventTarget_1 = require("../event/EventTarget"), NumberMap_1 = require("../tools/NumberMap"), Rect_1 = require("../tools/Rect"), util_1 = require("../tools/util"), themes_1 = __importDefault(require("../themes")), env_1 = require("../tools/env"), scenegraph_1 = require("../scenegraph/scenegraph"), state_1 = require("../state/state"), event_1 = require("../event/event"), body_helper_1 = require("../body-helper/body-helper"), header_helper_1 = require("../header-helper/header-helper"), vutils_1 = require("@visactor/vutils"), text_measure_1 = require("../scenegraph/utils/text-measure"), get_prop_1 = require("../scenegraph/utils/get-prop"), tableHelper_1 = require("./tableHelper"), FouseInput_1 = require("./FouseInput"), pixel_ratio_1 = require("../tools/pixel-ratio"), chart_render_helper_1 = require("../scenegraph/graphic/contributions/chart-render-helper"), row_height_map_1 = require("../layout/row-height-map"), row_series_number_helper_1 = require("./row-series-number-helper"), update_select_border_1 = require("../scenegraph/select/update-select-border"), react_custom_layout_1 = require("../components/react/react-custom-layout"), layout_helper_1 = require("../layout/layout-helper"), factory_1 = require("./factory"), get_cell_position_1 = require("./utils/get-cell-position"), style_helper_1 = require("./style-helper"), frozen_react_1 = require("../scenegraph/layout/frozen-react"), icons_1 = require("../icons"), animation_1 = require("./animation"), check_in_select_1 = require("../state/common/check-in-select"), is_cell_select_highlight_1 = require("../state/select/is-cell-select-highlight"), get_custom_merge_cell_func_1 = require("./utils/get-custom-merge-cell-func"), vrender_1 = require("./../vrender"), plugin_manager_1 = require("../plugins/plugin-manager"), {toBoxArray: toBoxArray} = helper_1.style, {isTouchEvent: isTouchEvent} = helper_1.event, rangeReg = /^\$(\d+)\$(\d+)$/;

(0, style_1.importStyle)();

class BaseTable extends EventTarget_1.EventTarget {
    static get EVENT_TYPE() {
        return TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE;
    }
    constructor(container, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        if (super(), this.showFrozenIcon = !0, this.version = "1.18.3", this.id = `VTable${Date.now()}`, 
        this.isReleased = !1, this._chartEventMap = {}, this.throttleInvalidate = (0, util_1.throttle2)(this.render.bind(this), 200), 
        "node" === env_1.Env.mode ? (options = container, container = null) : container instanceof HTMLElement || (options = container, 
        container = container.container ? container.container : null), !container && "node" !== options.mode && !options.canvas) throw new Error("vtable's container is undefined");
        this.pluginManager = new plugin_manager_1.PluginManager(this, options), this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.BEFORE_INIT, {
            options: options,
            container: container
        }), container = options.container && options.container instanceof HTMLElement ? options.container : container, 
        !1 === (null === (_a = options.customConfig) || void 0 === _a ? void 0 : _a.imageAnonymous) && (vrender_1.vglobal.isImageAnonymous = !1);
        const {frozenColCount: frozenColCount = 0, unfreezeAllOnExceedsMaxWidth: unfreezeAllOnExceedsMaxWidth, frozenRowCount: frozenRowCount, defaultRowHeight: defaultRowHeight = 40, defaultHeaderRowHeight: defaultHeaderRowHeight, defaultColWidth: defaultColWidth = 80, defaultHeaderColWidth: defaultHeaderColWidth, widthMode: widthMode = "standard", heightMode: heightMode = "standard", autoFillWidth: autoFillWidth = !1, autoFillHeight: autoFillHeight = !1, widthAdaptiveMode: widthAdaptiveMode = "only-body", heightAdaptiveMode: heightAdaptiveMode = "only-body", keyboardOptions: keyboardOptions, eventOptions: eventOptions, rowSeriesNumber: rowSeriesNumber, columnResizeMode: columnResizeMode, rowResizeMode: rowResizeMode = "none", resize: resize, dragHeaderMode: dragHeaderMode, dragOrder: dragOrder, showFrozenIcon: showFrozenIcon, allowFrozenColCount: allowFrozenColCount, padding: padding, hover: hover, menu: menu, select: click, customRender: customRender, pixelRatio: pixelRatio = pixel_ratio_1.defaultPixelRatio, renderChartAsync: renderChartAsync, renderChartAsyncBatchCount: renderChartAsyncBatchCount, mode: mode, modeParams: modeParams, canvasWidth: canvasWidth, canvasHeight: canvasHeight, overscrollBehavior: overscrollBehavior, limitMinWidth: limitMinWidth, limitMinHeight: limitMinHeight, clearDOM: clearDOM = !0} = options;
        this.container = container, this.options = options, this._widthMode = widthMode, 
        this._heightMode = heightMode, this._widthAdaptiveMode = widthAdaptiveMode, this._heightAdaptiveMode = heightAdaptiveMode, 
        this._autoFillWidth = autoFillWidth, this._autoFillHeight = autoFillHeight, this.customRender = customRender, 
        this.padding = {
            top: 0,
            right: 0,
            left: 0,
            bottom: 0
        }, padding && ("number" == typeof padding ? (this.padding.top = padding, this.padding.left = padding, 
        this.padding.bottom = padding, this.padding.right = padding) : (padding.top && (this.padding.top = padding.top), 
        padding.bottom && (this.padding.bottom = padding.bottom), padding.left && (this.padding.left = padding.left), 
        padding.right && (this.padding.right = padding.right))), ((0, vutils_1.isValid)(canvasHeight) || (0, 
        vutils_1.isValid)(canvasWidth)) && (this.canvasSizeSeted = !0), this.tableNoFrameWidth = 0, 
        this.tableNoFrameHeight = 0, this.canvasWidth = (0, vutils_1.isNumber)(canvasWidth) ? canvasWidth : void 0, 
        this.canvasHeight = (0, vutils_1.isNumber)(canvasHeight) ? canvasHeight : void 0, 
        this.columnWidthComputeMode = null !== (_b = options.columnWidthComputeMode) && void 0 !== _b ? _b : "normal";
        const internalProps = this.internalProps = {};
        void 0 !== showFrozenIcon && (this.showFrozenIcon = showFrozenIcon), "number" == typeof allowFrozenColCount && allowFrozenColCount <= 0 && (this.showFrozenIcon = !1), 
        this.options.canvas ? ("node" !== env_1.Env.mode && (internalProps.element = this.options.canvas.parentElement, 
        internalProps.element.style.position = "relative"), internalProps.focusControl = new FouseInput_1.FocusInput(this, internalProps.element), 
        internalProps.canvas = this.options.canvas, internalProps.context = internalProps.canvas.getContext("2d")) : "node" !== env_1.Env.mode && (internalProps.element = (0, 
        tableHelper_1.createRootElement)(this.padding), internalProps.focusControl = new FouseInput_1.FocusInput(this, internalProps.element), 
        internalProps.canvas = document.createElement("canvas"), internalProps.element.appendChild(internalProps.canvas), 
        internalProps.context = internalProps.canvas.getContext("2d"), (null === (_c = options.customConfig) || void 0 === _c ? void 0 : _c.createReactContainer) && (0, 
        frozen_react_1.createReactContainer)(this)), internalProps.handler = new EventHandler_1.EventHandler, 
        (0, vutils_1.isNumber)(this.options.resizeTime) && (internalProps.handler.resizeTime = this.options.resizeTime), 
        internalProps.pixelRatio = pixelRatio, internalProps.frozenColCount = frozenColCount, 
        internalProps.frozenRowCount = frozenRowCount, internalProps.unfreezeAllOnExceedsMaxWidth = null == unfreezeAllOnExceedsMaxWidth || unfreezeAllOnExceedsMaxWidth, 
        internalProps.defaultRowHeight = defaultRowHeight, internalProps.defaultHeaderRowHeight = null != defaultHeaderRowHeight ? defaultHeaderRowHeight : defaultRowHeight, 
        internalProps.defaultColWidth = defaultColWidth, internalProps.defaultHeaderColWidth = null != defaultHeaderColWidth ? defaultHeaderColWidth : defaultColWidth, 
        internalProps.keyboardOptions = keyboardOptions, internalProps.eventOptions = eventOptions, 
        internalProps.rowSeriesNumber = rowSeriesNumber, internalProps.columnResizeMode = null !== (_d = null == resize ? void 0 : resize.columnResizeMode) && void 0 !== _d ? _d : columnResizeMode, 
        internalProps.rowResizeMode = null !== (_e = null == resize ? void 0 : resize.rowResizeMode) && void 0 !== _e ? _e : rowResizeMode, 
        internalProps.dragHeaderMode = null !== (_g = null !== (_f = null == dragOrder ? void 0 : dragOrder.dragHeaderMode) && void 0 !== _f ? _f : dragHeaderMode) && void 0 !== _g ? _g : "none", 
        internalProps.renderChartAsync = renderChartAsync, (0, chart_render_helper_1.setBatchRenderChartCount)(renderChartAsyncBatchCount), 
        internalProps.overscrollBehavior = null != overscrollBehavior ? overscrollBehavior : "auto", 
        internalProps._rowHeightsMap = new row_height_map_1.NumberRangeMap(this), internalProps._rowRangeHeightsMap = new Map, 
        internalProps._colRangeWidthsMap = new Map, internalProps._widthResizedColMap = new Set, 
        internalProps._heightResizedRowMap = new Set, this.colWidthsMap = new NumberMap_1.NumberMap, 
        this.colContentWidthsMap = new NumberMap_1.NumberMap, this.colWidthsLimit = {};
        const that = this;
        if (internalProps.calcWidthContext = {
            _: internalProps,
            get full() {
                var _a;
                return "node" === env_1.Env.mode ? that.canvasWidth / (null != pixelRatio ? pixelRatio : 1) : this._.canvas.width / (null !== (_a = this._.context.pixelRatio) && void 0 !== _a ? _a : window.devicePixelRatio);
            }
        }, internalProps.cellTextOverflows = {}, internalProps.focusedTable = !1, internalProps.theme = themes_1.default.of(null !== (_h = options.theme) && void 0 !== _h ? _h : themes_1.default.DEFAULT), 
        internalProps.theme.isPivot = this.isPivotTable(), (0, icons_1.setIconColor)(internalProps.theme.functionalIconsStyle), 
        container ? (clearDOM && (container.innerHTML = ""), container.appendChild(internalProps.element), 
        this._updateSize()) : this._updateSize(), internalProps.bodyHelper = new body_helper_1.BodyHelper(this), 
        internalProps.headerHelper = new header_helper_1.HeaderHelper(this), internalProps.rowSeriesNumberHelper = new row_series_number_helper_1.RowSeriesNumberHelper(this), 
        internalProps.autoWrapText = options.autoWrapText, internalProps.enableLineBreak = options.enableLineBreak, 
        internalProps.allowFrozenColCount = null !== (_j = options.allowFrozenColCount) && void 0 !== _j ? _j : 0, 
        internalProps.limitMaxAutoWidth = null !== (_k = options.limitMaxAutoWidth) && void 0 !== _k ? _k : 450, 
        internalProps.limitMinWidth = null != limitMinWidth ? "number" == typeof limitMinWidth ? limitMinWidth : limitMinWidth ? 10 : 0 : 10, 
        internalProps.limitMinHeight = null != limitMinHeight ? "number" == typeof limitMinHeight ? limitMinHeight : limitMinHeight ? 10 : 0 : 10, 
        this.scenegraph = new scenegraph_1.Scenegraph(this), this.stateManager = new state_1.StateManager(this), 
        this.eventManager = new event_1.EventManager(this), this.animationManager = new animation_1.TableAnimationManager(this), 
        options.legends) {
            internalProps.legends = [];
            const createLegend = factory_1.Factory.getFunction("createLegend");
            if (Array.isArray(options.legends)) {
                for (let i = 0; i < options.legends.length; i++) internalProps.legends.push(createLegend(options.legends[i], this));
                this.scenegraph.tableGroup.setAttributes({
                    x: this.tableX,
                    y: this.tableY
                });
            } else internalProps.legends.push(createLegend(options.legends, this)), this.scenegraph.tableGroup.setAttributes({
                x: this.tableX,
                y: this.tableY
            });
        }
        if (internalProps.tooltip = Object.assign({
            parentElement: this.getElement(),
            renderMode: "html",
            isShowOverflowTextTooltip: !1,
            confine: !0,
            position: ts_types_1.Placement.bottom
        }, options.tooltip), "html" === internalProps.tooltip.renderMode) {
            const TooltipHandler = factory_1.Factory.getComponent("tooltipHandler");
            TooltipHandler && (internalProps.tooltipHandler = new TooltipHandler(this, internalProps.tooltip.confine));
        }
        if (internalProps.menu = Object.assign({
            renderMode: "html"
        }, options.menu), Array.isArray(null === (_l = options.menu) || void 0 === _l ? void 0 : _l.dropDownMenuHighlight) && this.setDropDownMenuHighlight(null === (_m = options.menu) || void 0 === _m ? void 0 : _m.dropDownMenuHighlight), 
        (Array.isArray(null === (_o = options.menu) || void 0 === _o ? void 0 : _o.defaultHeaderMenuItems) || "function" == typeof (null === (_p = options.menu) || void 0 === _p ? void 0 : _p.defaultHeaderMenuItems)) && (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems), 
        "html" === internalProps.menu.renderMode) {
            const MenuHandler = factory_1.Factory.getComponent("menuHandler");
            internalProps.menuHandler = new MenuHandler(this);
        }
        this.headerStyleCache = new Map, this.bodyStyleCache = new Map, this.bodyMergeTitleCache = new Map, 
        this.bodyBottomStyleCache = new Map, internalProps.stick = {
            changedCells: new Map
        }, internalProps.customMergeCell = (0, get_custom_merge_cell_func_1.getCustomMergeCellFunc)(options.customMergeCell);
        const CustomCellStylePlugin = factory_1.Factory.getComponent("customCellStylePlugin");
        CustomCellStylePlugin && (this.customCellStylePlugin = new CustomCellStylePlugin(this, null !== (_q = options.customCellStyle) && void 0 !== _q ? _q : [], null !== (_r = options.customCellStyleArrangement) && void 0 !== _r ? _r : [])), 
        this._adjustCanvasSizeByOption();
    }
    _adjustCanvasSizeByOption() {
        "auto" !== this.options.canvasHeight && "auto" !== this.options.canvasWidth || setTimeout((() => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
            let canvasWidth, canvasHeight;
            if ("auto" === this.options.canvasHeight) {
                let borderWidth = 0;
                if (null === (_a = this.theme.frameStyle) || void 0 === _a ? void 0 : _a.innerBorder) {
                    borderWidth += null !== (_d = toBoxArray(null !== (_c = null === (_b = this.internalProps.theme.frameStyle) || void 0 === _b ? void 0 : _b.shadowBlur) && void 0 !== _c ? _c : [ 0 ])[1]) && void 0 !== _d ? _d : 0;
                } else if (this.theme.frameStyle) {
                    const lineWidths = toBoxArray(null !== (_f = null === (_e = this.internalProps.theme.frameStyle) || void 0 === _e ? void 0 : _e.borderLineWidth) && void 0 !== _f ? _f : [ null ]), shadowWidths = toBoxArray(null !== (_h = null === (_g = this.internalProps.theme.frameStyle) || void 0 === _g ? void 0 : _g.shadowBlur) && void 0 !== _h ? _h : [ 0 ]);
                    borderWidth += (null !== (_j = lineWidths[0]) && void 0 !== _j ? _j : 0) + (null !== (_k = shadowWidths[0]) && void 0 !== _k ? _k : 0) + ((null !== (_l = lineWidths[2]) && void 0 !== _l ? _l : 0) + (null !== (_m = shadowWidths[2]) && void 0 !== _m ? _m : 0));
                }
                canvasHeight = Math.min(this.options.maxCanvasHeight ? this.options.maxCanvasHeight - borderWidth : 2e4, this.getAllRowsHeight()) + borderWidth;
            } else canvasHeight = this.canvasHeight;
            if ("auto" === this.options.canvasWidth) {
                let borderWidth = 0;
                if (null === (_o = this.theme.frameStyle) || void 0 === _o ? void 0 : _o.innerBorder) {
                    borderWidth += null !== (_r = toBoxArray(null !== (_q = null === (_p = this.internalProps.theme.frameStyle) || void 0 === _p ? void 0 : _p.shadowBlur) && void 0 !== _q ? _q : [ 0 ])[2]) && void 0 !== _r ? _r : 0;
                } else if (this.theme.frameStyle) {
                    const lineWidths = toBoxArray(null !== (_t = null === (_s = this.internalProps.theme.frameStyle) || void 0 === _s ? void 0 : _s.borderLineWidth) && void 0 !== _t ? _t : [ null ]), shadowWidths = toBoxArray(null !== (_v = null === (_u = this.internalProps.theme.frameStyle) || void 0 === _u ? void 0 : _u.shadowBlur) && void 0 !== _v ? _v : [ 0 ]);
                    borderWidth += (null !== (_w = lineWidths[1]) && void 0 !== _w ? _w : 0) + (null !== (_x = shadowWidths[1]) && void 0 !== _x ? _x : 0) + ((null !== (_y = lineWidths[3]) && void 0 !== _y ? _y : 0) + (null !== (_z = shadowWidths[3]) && void 0 !== _z ? _z : 0));
                }
                canvasWidth = Math.min(this.options.maxCanvasWidth ? this.options.maxCanvasWidth - borderWidth : 2e4, this.getAllColsWidth()) + borderWidth;
            } else canvasWidth = this.canvasWidth;
            this.setCanvasSize(canvasWidth, canvasHeight);
        }), 0);
    }
    getContainer() {
        return this.container;
    }
    getElement() {
        return this.internalProps.element;
    }
    get canvas() {
        return this.internalProps.canvas;
    }
    setCanvasSize(canvasWidth, canvasHeight) {
        this.canvasWidth = canvasWidth, this.canvasHeight = canvasHeight, this.options.canvasHeight = canvasHeight, 
        this.options.canvasWidth = canvasWidth, this.resize();
    }
    resize() {
        var _a;
        this._updateSize(), null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend => {
            null == legend || legend.resize();
        })), this.internalProps.title && this.internalProps.title.resize(), this.internalProps.emptyTip && this.internalProps.emptyTip.resize(), 
        this.scenegraph.resize();
    }
    get rowCount() {
        return this.internalProps.rowCount;
    }
    set rowCount(rowCount) {
        this.internalProps.rowCount = rowCount;
    }
    get colCount() {
        var _a;
        return null !== (_a = this.internalProps.colCount) && void 0 !== _a ? _a : 0;
    }
    set colCount(colCount) {
        this.internalProps.colCount = colCount;
    }
    get frozenColCount() {
        var _a, _b, _c, _d, _e;
        return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.frozenColCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.frozenColCount) && void 0 !== _e ? _e : 0;
    }
    set frozenColCount(frozenColCount) {
        frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount, 
        this.options.frozenColCount = frozenColCount;
        const maxFrozenWidth = this._getMaxFrozenWidth();
        if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) if (this.internalProps.unfreezeAllOnExceedsMaxWidth) this.internalProps.frozenColCount = 0; else {
            const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
            this.internalProps.frozenColCount = computedFrozenColCount;
        }
        this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
    }
    setFrozenColCount(frozenColCount) {
        frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount, 
        this.options.frozenColCount = frozenColCount;
        const maxFrozenWidth = this._getMaxFrozenWidth();
        if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) if (this.internalProps.unfreezeAllOnExceedsMaxWidth) this.internalProps.frozenColCount = 0; else {
            const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
            this.internalProps.frozenColCount = computedFrozenColCount;
        }
        this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
    }
    _setFrozenColCount(frozenColCount) {
        frozenColCount >= this.colCount && (frozenColCount = 0), this.internalProps.frozenColCount = frozenColCount;
    }
    _resetFrozenColCount() {
        this.options.frozenColCount && (this.tableNoFrameWidth - this.getColsWidth(0, this.options.frozenColCount - 1) <= 120 ? this._setFrozenColCount(0) : this.frozenColCount !== this.options.frozenColCount && this._setFrozenColCount(this.options.frozenColCount));
    }
    get frozenRowCount() {
        var _a, _b, _c, _d, _e;
        return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.frozenRowCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.frozenRowCount) && void 0 !== _e ? _e : 0;
    }
    set frozenRowCount(frozenRowCount) {
        this.internalProps.frozenRowCount = frozenRowCount, this.stateManager.setFrozenRow(this.internalProps.frozenRowCount);
    }
    get rightFrozenColCount() {
        var _a, _b, _c, _d, _e;
        return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.rightFrozenColCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.rightFrozenColCount) && void 0 !== _e ? _e : 0;
    }
    set rightFrozenColCount(rightFrozenColCount) {
        this.scenegraph.dealWidthRightFrozen(rightFrozenColCount);
    }
    get bottomFrozenRowCount() {
        var _a, _b, _c, _d, _e;
        return null !== (_e = null !== (_c = null === (_b = null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.layoutMap) || void 0 === _b ? void 0 : _b.bottomFrozenRowCount) && void 0 !== _c ? _c : null === (_d = this.internalProps) || void 0 === _d ? void 0 : _d.bottomFrozenRowCount) && void 0 !== _e ? _e : 0;
    }
    set bottomFrozenRowCount(bottomFrozenRowCount) {
        this.scenegraph.dealWidthBottomFrozen(bottomFrozenRowCount);
    }
    get defaultRowHeight() {
        return (0, vutils_1.isNumber)(this.internalProps.defaultRowHeight) ? this.internalProps.defaultRowHeight : 40;
    }
    set defaultRowHeight(defaultRowHeight) {
        this.internalProps.defaultRowHeight = defaultRowHeight, this.options.defaultRowHeight = defaultRowHeight;
    }
    get defaultHeaderRowHeight() {
        return this.internalProps.defaultHeaderRowHeight;
    }
    set defaultHeaderRowHeight(defaultHeaderRowHeight) {
        this.internalProps.defaultHeaderRowHeight = defaultHeaderRowHeight, this.options.defaultHeaderRowHeight = defaultHeaderRowHeight;
    }
    get defaultColWidth() {
        return this.internalProps.defaultColWidth;
    }
    set defaultColWidth(defaultColWidth) {
        this.internalProps.defaultColWidth = defaultColWidth, this.options.defaultColWidth = defaultColWidth;
    }
    get defaultHeaderColWidth() {
        return this.internalProps.defaultHeaderColWidth;
    }
    set defaultHeaderColWidth(defaultHeaderColWidth) {
        this.internalProps.defaultHeaderColWidth = defaultHeaderColWidth, this.options.defaultHeaderColWidth = defaultHeaderColWidth;
    }
    get colWidthsMap() {
        return this.internalProps._colWidthsMap;
    }
    set colWidthsMap(colWidthsMap) {
        this.internalProps._colWidthsMap = colWidthsMap;
    }
    get colContentWidthsMap() {
        return this.internalProps._colContentWidthsMap;
    }
    set colContentWidthsMap(colContentWidthsMap) {
        this.internalProps._colContentWidthsMap = colContentWidthsMap;
    }
    get _colRangeWidthsMap() {
        return this.internalProps._colRangeWidthsMap;
    }
    set _colRangeWidthsMap(_colRangeWidthsMap) {
        this.internalProps._colRangeWidthsMap = _colRangeWidthsMap;
    }
    get _rowRangeHeightsMap() {
        return this.internalProps._rowRangeHeightsMap;
    }
    set _rowRangeHeightsMap(_rowRangeHeightsMap) {
        this.internalProps._rowRangeHeightsMap = _rowRangeHeightsMap;
    }
    get rowHeightsMap() {
        return this.internalProps._rowHeightsMap;
    }
    set rowHeightsMap(rowHeightsMap) {
        this.internalProps._rowHeightsMap = rowHeightsMap;
    }
    get colWidthsLimit() {
        return this.internalProps._colWidthsLimit;
    }
    set colWidthsLimit(colWidthsLimit) {
        this.internalProps._colWidthsLimit = colWidthsLimit;
    }
    get keyboardOptions() {
        var _a;
        return null !== (_a = this.internalProps.keyboardOptions) && void 0 !== _a ? _a : null;
    }
    set keyboardOptions(keyboardOptions) {
        this.internalProps.keyboardOptions = null != keyboardOptions ? keyboardOptions : void 0;
    }
    get eventOptions() {
        var _a;
        return null !== (_a = this.internalProps.eventOptions) && void 0 !== _a ? _a : null;
    }
    set eventOptions(eventOptions) {
        this.internalProps.eventOptions = null != eventOptions ? eventOptions : void 0;
    }
    get widthMode() {
        return this._widthMode;
    }
    set widthMode(widthMode) {
        widthMode !== this._widthMode && (this._widthMode = widthMode, this.options.widthMode = widthMode);
    }
    get heightMode() {
        return this._heightMode;
    }
    set heightMode(heightMode) {
        heightMode !== this._heightMode && (this._heightMode = heightMode, this.options.heightMode = heightMode);
    }
    get autoFillWidth() {
        return this._autoFillWidth;
    }
    set autoFillWidth(autoFillWidth) {
        autoFillWidth !== this._autoFillWidth && (this._autoFillWidth = autoFillWidth);
    }
    get autoFillHeight() {
        return this._autoFillHeight;
    }
    set autoFillHeight(autoFillHeight) {
        autoFillHeight !== this._autoFillHeight && (this._autoFillHeight = autoFillHeight);
    }
    get widthAdaptiveMode() {
        return this._widthAdaptiveMode;
    }
    set widthAdaptiveMode(widthAdaptiveMode) {
        widthAdaptiveMode !== this._widthAdaptiveMode && (this._widthAdaptiveMode = widthAdaptiveMode);
    }
    get heightAdaptiveMode() {
        return this._heightAdaptiveMode;
    }
    set heightAdaptiveMode(heightAdaptiveMode) {
        heightAdaptiveMode !== this._heightAdaptiveMode && (this._heightAdaptiveMode = heightAdaptiveMode);
    }
    _colWidthDefineToPxWidth(width) {
        return "auto" === width ? 0 : (0, tableHelper_1._toPxWidth)(this, width);
    }
    _getMaxFrozenWidth() {
        var _a;
        const maxFrozenWidth = null !== (_a = this.options.maxFrozenWidth) && void 0 !== _a ? _a : "80%";
        return (0, tableHelper_1._toPxWidth)(this, maxFrozenWidth);
    }
    _getComputedFrozenColCount(frozenColCount) {
        const maxFrozenWidth = this._getMaxFrozenWidth();
        let computedfrozenColCount = frozenColCount;
        for (;this.getColsWidth(0, computedfrozenColCount - 1) > maxFrozenWidth && (computedfrozenColCount--, 
        !(computedfrozenColCount <= 0)); ) ;
        return computedfrozenColCount;
    }
    _getColWidthLimits(col) {
        const limit = this.colWidthsLimit[col];
        if (!limit) return null;
        const result = {};
        return limit.min && (result.min = (0, tableHelper_1._toPxWidth)(this, limit.min), 
        result.minDef = limit.min), limit.max && (result.max = (0, tableHelper_1._toPxWidth)(this, limit.max), 
        result.maxDef = limit.max), result;
    }
    _adjustColWidth(col, orgWidth) {
        const limits = this._getColWidthLimits(col);
        return Math.max((0, tableHelper_1._applyColWidthLimits)(limits, orgWidth), 0);
    }
    get pixelRatio() {
        return this.internalProps.pixelRatio;
    }
    setPixelRatio(pixelRatio) {
        var _a;
        if (pixelRatio !== (null === (_a = this.internalProps) || void 0 === _a ? void 0 : _a.pixelRatio)) {
            this.internalProps.pixelRatio = pixelRatio;
            const canvasWidth = this.canvasWidth;
            this.internalProps.calcWidthContext = {
                _: this.internalProps,
                get full() {
                    var _a;
                    return "node" === env_1.Env.mode ? canvasWidth / (null != pixelRatio ? pixelRatio : 1) : this._.canvas.width / (null !== (_a = this._.context.pixelRatio) && void 0 !== _a ? _a : window.devicePixelRatio);
                }
            }, this.scenegraph.setPixelRatio(pixelRatio);
        }
    }
    _updateSize() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
        const {padding: padding} = this;
        let widthP = 0, heightP = 0;
        if (this.tableX = 0, this.tableY = 0, this.options.canvas && this.options.viewBox) widthP = this.options.viewBox.x2 - this.options.viewBox.x1, 
        heightP = this.options.viewBox.y2 - this.options.viewBox.y1, (null === (_a = null == this ? void 0 : this.scenegraph) || void 0 === _a ? void 0 : _a.stage) && (this.options.viewBox ? this.scenegraph.stage.setViewBox(this.options.viewBox, !1) : this.scenegraph.stage.resize(widthP, heightP)); else if ("browser" === env_1.Env.mode) {
            const element = this.getElement();
            let widthWithoutPadding = 0, heightWithoutPadding = 0;
            const isDefWidth = (0, vutils_1.isValid)(this.canvasWidth), isDefHeight = (0, vutils_1.isValid)(this.canvasHeight);
            this.canvasSizeSeted && (isDefWidth && (widthWithoutPadding = this.canvasWidth), 
            isDefHeight && (heightWithoutPadding = this.canvasHeight));
            if ((!isDefWidth || !isDefHeight) && element.parentElement) {
                const computedStyle = element.parentElement.style || window.getComputedStyle(element.parentElement);
                isDefWidth || (widthWithoutPadding = element.parentElement.offsetWidth - (parseInt(computedStyle.paddingLeft, 10) || 0) - (parseInt(computedStyle.paddingRight, 10) || 0)), 
                isDefHeight || (heightWithoutPadding = element.parentElement.offsetHeight - parseInt(computedStyle.paddingTop || "0px", 10) - parseInt(computedStyle.paddingBottom || "0px", 20)), 
                widthWithoutPadding = (null != widthWithoutPadding ? widthWithoutPadding : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), 
                heightWithoutPadding = (null != heightWithoutPadding ? heightWithoutPadding : 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
            }
            element.style.width = widthWithoutPadding && widthWithoutPadding - padding.left - padding.right + "px" || "0px", 
            element.style.height = heightWithoutPadding && heightWithoutPadding - padding.top - padding.bottom + "px" || "0px";
            const {canvas: canvas} = this.internalProps;
            widthP = (null !== (_c = null === (_b = canvas.parentElement) || void 0 === _b ? void 0 : _b.offsetWidth) && void 0 !== _c ? _c : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), 
            heightP = (null !== (_e = null === (_d = canvas.parentElement) || void 0 === _d ? void 0 : _d.offsetHeight) && void 0 !== _e ? _e : 1) - (this.options.tableSizeAntiJitter ? 1 : 0), 
            (null === (_f = null == this ? void 0 : this.scenegraph) || void 0 === _f ? void 0 : _f.stage) ? (null === (_g = this.options) || void 0 === _g ? void 0 : _g.viewBox) && !(null === (_h = this.options) || void 0 === _h ? void 0 : _h.canvas) && this.scenegraph.stage.resize(widthP, heightP) : (canvas.style.width = "", 
            canvas.style.height = "", canvas.width = widthP, canvas.height = heightP, canvas.style.width = `${widthP}px`, 
            canvas.style.height = `${heightP}px`), (null === (_j = this.options) || void 0 === _j ? void 0 : _j.viewBox) && (widthP = this.options.viewBox.x2 - this.options.viewBox.x1, 
            heightP = this.options.viewBox.y2 - this.options.viewBox.y1), (null === (_k = null == this ? void 0 : this.scenegraph) || void 0 === _k ? void 0 : _k.stage) && (this.options.viewBox ? this.scenegraph.stage.setViewBox(this.options.viewBox, !1) : this.scenegraph.stage.resize(widthP, heightP));
        } else "node" === env_1.Env.mode && (widthP = this.canvasWidth - 1, heightP = this.canvasHeight - 1);
        const width = Math.floor(widthP - style.getVerticalScrollBarSize(this.getTheme().scrollStyle)), height = Math.floor(heightP - style.getHorizontalScrollBarSize(this.getTheme().scrollStyle));
        if (null === (_l = this.internalProps.theme) || void 0 === _l ? void 0 : _l.frameStyle) {
            const lineWidths = toBoxArray(null !== (_o = null === (_m = this.internalProps.theme.frameStyle) || void 0 === _m ? void 0 : _m.borderLineWidth) && void 0 !== _o ? _o : [ null ]), shadowWidths = toBoxArray(null !== (_q = null === (_p = this.internalProps.theme.frameStyle) || void 0 === _p ? void 0 : _p.shadowBlur) && void 0 !== _q ? _q : [ 0 ]);
            (null === (_r = this.theme.frameStyle) || void 0 === _r ? void 0 : _r.innerBorder) ? (this.tableX = 0, 
            this.tableY = 0, this.tableNoFrameWidth = width - (null !== (_s = shadowWidths[1]) && void 0 !== _s ? _s : 0), 
            this.tableNoFrameHeight = height - (null !== (_t = shadowWidths[2]) && void 0 !== _t ? _t : 0)) : (this.tableX = (null !== (_u = lineWidths[3]) && void 0 !== _u ? _u : 0) + (null !== (_v = shadowWidths[3]) && void 0 !== _v ? _v : 0), 
            this.tableY = (null !== (_w = lineWidths[0]) && void 0 !== _w ? _w : 0) + (null !== (_x = shadowWidths[0]) && void 0 !== _x ? _x : 0), 
            this.tableNoFrameWidth = width - ((null !== (_y = lineWidths[1]) && void 0 !== _y ? _y : 0) + (null !== (_z = shadowWidths[1]) && void 0 !== _z ? _z : 0)) - ((null !== (_0 = lineWidths[3]) && void 0 !== _0 ? _0 : 0) + (null !== (_1 = shadowWidths[3]) && void 0 !== _1 ? _1 : 0)), 
            this.tableNoFrameHeight = height - ((null !== (_2 = lineWidths[0]) && void 0 !== _2 ? _2 : 0) + (null !== (_3 = shadowWidths[0]) && void 0 !== _3 ? _3 : 0)) - ((null !== (_4 = lineWidths[2]) && void 0 !== _4 ? _4 : 0) + (null !== (_5 = shadowWidths[2]) && void 0 !== _5 ? _5 : 0)));
        }
        this._clearColRangeWidthsMap(), this._clearRowRangeHeightsMap();
    }
    updateViewBox(newViewBox) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const oldWidth = (null !== (_c = null === (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.viewBox) || void 0 === _b ? void 0 : _b.x2) && void 0 !== _c ? _c : 0) - (null !== (_f = null === (_e = null === (_d = this.options) || void 0 === _d ? void 0 : _d.viewBox) || void 0 === _e ? void 0 : _e.x1) && void 0 !== _f ? _f : 0), oldHeight = (null !== (_j = null === (_h = null === (_g = this.options) || void 0 === _g ? void 0 : _g.viewBox) || void 0 === _h ? void 0 : _h.y2) && void 0 !== _j ? _j : 0) - (null !== (_m = null === (_l = null === (_k = this.options) || void 0 === _k ? void 0 : _k.viewBox) || void 0 === _l ? void 0 : _l.y1) && void 0 !== _m ? _m : 0), newWidth = newViewBox.x2 - newViewBox.x1, newHeight = newViewBox.y2 - newViewBox.y1;
        this.options.viewBox = newViewBox, oldWidth !== newWidth || oldHeight !== newHeight ? this.resize() : this.scenegraph.stage.setViewBox(this.options.viewBox, !0);
    }
    setViewBoxTransform(a, b, c, d, e, f) {
        this.internalProps.modifiedViewBoxTransform = !0, this.scenegraph.stage.window.setViewBoxTransform(a, b, c, d, e, f);
    }
    get rowHierarchyType() {
        return this.dataSource.rowHierarchyType;
    }
    getColsWidth(startCol, endCol) {
        var _a;
        if (startCol > endCol) return 0;
        startCol = Math.max(startCol, 0), endCol = Math.min(endCol, (null !== (_a = this.colCount) && void 0 !== _a ? _a : 1 / 0) - 1);
        const cachedColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol}`);
        if (null != cachedColWidth) return cachedColWidth;
        const cachedLowerColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol - 1}`);
        if (null != cachedLowerColWidth) {
            const addWidth = cachedLowerColWidth + this.getColWidth(endCol);
            return startCol >= 0 && endCol >= 0 && !Number.isNaN(addWidth) && this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(addWidth)), 
            Math.round(addWidth);
        }
        let w = 0;
        for (let col = startCol; col <= endCol; col++) w += this.getColWidth(col);
        return startCol >= 0 && endCol >= 0 && this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(w)), 
        Math.round(w);
    }
    getRowHeight(row) {
        var _a;
        if ((0, vutils_1.isValid)(this.rowHeightsMap.get(row))) {
            if (null === (_a = this.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) {
                const height = this.rowHeightsMap.get(row);
                let heightRange;
                return heightRange = row < this.frozenRowCount ? this.rowHeightsMap.getSumInRange(0, row) : row >= this.rowCount - this.bottomFrozenRowCount ? this.rowHeightsMap.getSumInRange(row, this.rowCount - 1) : this.rowHeightsMap.getSumInRange(this.frozenRowCount, row), 
                heightRange = Number(heightRange.toFixed(2)), Number.isInteger(heightRange) ? Math.ceil(height) : Math.floor(height);
            }
            return this.rowHeightsMap.get(row);
        }
        const defaultHeight = this.getDefaultRowHeight(row);
        return (0, vutils_1.isNumber)(defaultHeight) ? defaultHeight : this.defaultRowHeight;
    }
    getDefaultColumnWidth(col) {
        var _a, _b;
        return this.isRowHeader(col, 0) || this.isCornerHeader(col, 0) ? Array.isArray(this.defaultHeaderColWidth) ? null !== (_a = this.defaultHeaderColWidth[col]) && void 0 !== _a ? _a : this.defaultColWidth : this.defaultHeaderColWidth : this.isRightFrozenColumn(col, this.columnHeaderLevelCount) && this.isPivotTable() ? Array.isArray(this.defaultHeaderColWidth) ? null !== (_b = this.defaultHeaderColWidth[this.rowHeaderLevelCount - this.rightFrozenColCount]) && void 0 !== _b ? _b : this.defaultColWidth : this.defaultHeaderColWidth : this.defaultColWidth;
    }
    getDefaultRowHeight(row) {
        var _a, _b;
        return this.isColumnHeader(0, row) || this.isCornerHeader(0, row) || this.isSeriesNumberInHeader(0, row) ? Array.isArray(this.defaultHeaderRowHeight) ? null !== (_a = this.defaultHeaderRowHeight[row]) && void 0 !== _a ? _a : this.internalProps.defaultRowHeight : this.defaultHeaderRowHeight : this.isBottomFrozenRow(row) ? Array.isArray(this.defaultHeaderRowHeight) ? null !== (_b = this.defaultHeaderRowHeight[this.columnHeaderLevelCount > 0 ? this.columnHeaderLevelCount - this.bottomFrozenRowCount : 0]) && void 0 !== _b ? _b : this.internalProps.defaultRowHeight : this.defaultHeaderRowHeight : this.internalProps.defaultRowHeight;
    }
    _setRowHeight(row, height, clearCache) {
        var _a;
        this.rowHeightsMap.put(row, (null === (_a = this.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? height : Math.round(height)), 
        clearCache && this._clearRowRangeHeightsMap(row);
    }
    setRowHeight(row, height) {
        this.scenegraph.setRowHeight(row, height), this.scenegraph.updateChartSizeForResizeRowHeight(row), 
        this.internalProps._heightResizedRowMap.add(row);
    }
    getRowsHeight(startRow, endRow) {
        var _a, _b;
        if (startRow > endRow || 0 === this.rowCount) return 0;
        startRow = Math.max(startRow, 0), endRow = Math.min(endRow, (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 1 / 0) - 1);
        let h = 0;
        const isDefaultRowHeightIsAuto = "auto" === this.options.defaultRowHeight;
        if ("standard" !== this.heightMode || this.options.customComputeRowHeight || this.autoFillHeight || !this.internalProps.layoutMap || this.hasAutoImageColumn() || isDefaultRowHeightIsAuto || 0 !== this.internalProps._heightResizedRowMap.size) {
            if (null === (_b = this.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) {
                const tempH = this.rowHeightsMap.getSumInRange(startRow, endRow);
                let heightRange;
                return heightRange = endRow < this.frozenRowCount ? this.rowHeightsMap.getSumInRange(0, endRow) : endRow >= this.rowCount - this.bottomFrozenRowCount ? this.rowHeightsMap.getSumInRange(endRow, this.rowCount - 1) : this.rowHeightsMap.getSumInRange(this.frozenRowCount, endRow), 
                heightRange = Number(heightRange.toFixed(2)), Number.isInteger(heightRange) ? Math.ceil(tempH) : Math.floor(tempH);
            }
            h = this.rowHeightsMap.getSumInRange(startRow, endRow);
        } else {
            for (let i = startRow; i < Math.min(endRow + 1, this.columnHeaderLevelCount); i++) h += this.getRowHeight(i);
            endRow >= this.columnHeaderLevelCount && (h += this.defaultRowHeight * (Math.min(endRow, this.rowCount - this.bottomFrozenRowCount - 1) - Math.max(this.columnHeaderLevelCount, startRow) + 1));
            for (let i = this.rowCount - this.bottomFrozenRowCount; i < endRow + 1; i++) h += this.getRowHeight(i);
        }
        return Math.round(h);
    }
    getColWidthDefined(col) {
        var _a;
        const {layoutMap: layoutMap} = this.internalProps;
        if ("autoWidth" === this.widthMode) return "auto";
        const {width: width} = null !== (_a = null == layoutMap ? void 0 : layoutMap.getColumnWidthDefined(col)) && void 0 !== _a ? _a : {};
        return "number" == typeof width && width <= 0 ? 0 : width || this.getDefaultColumnWidth(col);
    }
    getColWidthDefinedNumber(col) {
        const width = this.getColWidthDefined(col);
        return this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
    }
    isAutoRowHeight(row) {
        return "autoHeight" === this.heightMode || (!!this.options.customComputeRowHeight || (row >= 0 && row < this.columnHeaderLevelCount ? "auto" === this.getDefaultRowHeight(row) : "auto" === this.internalProps.defaultRowHeight));
    }
    getColWidth(col) {
        var _a;
        const width = null !== (_a = this.colWidthsMap.get(col)) && void 0 !== _a ? _a : this.getDefaultColumnWidth(col);
        return "adaptive" === this.widthMode && "number" == typeof width || this.transpose && "number" == typeof width ? this._colWidthDefineToPxWidth(width) : this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
    }
    _setColWidth(col, width, clearCache, skipCheckFrozen) {
        this.colWidthsMap.put(col, "number" == typeof width ? Math.round(width) : width), 
        clearCache && this._clearColRangeWidthsMap(col), skipCheckFrozen || this.stateManager.checkFrozen();
    }
    setColWidth(col, width) {
        this.scenegraph.setColWidth(col, width), this.scenegraph.updateChartSizeForResizeColWidth(col), 
        this.internalProps._widthResizedColMap.add(col);
    }
    _clearColRangeWidthsMap(col) {
        if ("number" != typeof col) this._colRangeWidthsMap.clear(); else {
            const keys = this._colRangeWidthsMap.keys();
            for (const key of keys) {
                const reg = rangeReg.exec(key);
                if (reg) {
                    const start = Number(reg[1]), end = Number(reg[2]);
                    col >= start && col <= end && this._colRangeWidthsMap.delete(key);
                }
            }
        }
    }
    _clearRowRangeHeightsMap(row) {
        this.rowHeightsMap.clearRange();
    }
    _getColContentWidth(col) {
        return Number(this.colContentWidthsMap.get(col));
    }
    _setColContentWidth(col, width) {
        this.colContentWidthsMap.put(col, width);
    }
    getAllRowsHeight() {
        if (this.internalProps.rowCount <= 0) return 0;
        return this.getRowsHeight(0, this.internalProps.rowCount - 1);
    }
    getAllColsWidth() {
        if (this.internalProps.colCount <= 0) return 0;
        return this.getColsWidth(0, this.internalProps.colCount - 1);
    }
    getColsWidths() {
        const maxCount = this.colCount, widths = [];
        for (let col = 0; col < maxCount; col++) widths.push(this.getColWidth(col));
        return widths;
    }
    getMaxColWidth(col) {
        var _a;
        const obj = this.colWidthsLimit[col];
        let max = null !== (_a = obj && obj.max) && void 0 !== _a ? _a : 1 / 0;
        return "string" == typeof max && (max = (0, tableHelper_1._toPxWidth)(this, max)), 
        max;
    }
    setMaxColWidth(col, maxwidth) {
        (this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {})).max = maxwidth;
    }
    getMinColWidth(col) {
        var _a;
        const obj = this.colWidthsLimit[col];
        let min = null !== (_a = obj && obj.min) && void 0 !== _a ? _a : 0;
        return "string" == typeof min && (min = (0, tableHelper_1._toPxWidth)(this, min)), 
        min;
    }
    setMinColWidth(col, minwidth) {
        (this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {})).min = minwidth;
    }
    getCellRect(col, row) {
        var _a, _b;
        const isFrozenCell = this.isFrozenCell(col, row);
        let absoluteLeft;
        const width = this.getColWidth(col);
        let absoluteTop;
        absoluteLeft = isFrozenCell && isFrozenCell.col && this.isRightFrozenColumn(col, row) ? this.getAllColsWidth() <= this.tableNoFrameWidth ? this.getColsWidth(0, col - 1) || 0 : this.tableNoFrameWidth - (null !== (_a = this.getColsWidth(col, this.colCount - 1)) && void 0 !== _a ? _a : 0) : this.getColsWidth(0, col - 1) || 0;
        const height = this.getRowHeight(row);
        return absoluteTop = isFrozenCell && isFrozenCell.row && this.isBottomFrozenRow(col, row) ? this.getAllRowsHeight() <= this.tableNoFrameHeight ? this.getRowsHeight(0, row - 1) : this.tableNoFrameHeight - (null !== (_b = this.getRowsHeight(row, this.rowCount - 1)) && void 0 !== _b ? _b : 0) : this.getRowsHeight(0, row - 1), 
        new Rect_1.Rect(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
    }
    getMergeCellRect(col, row) {
        const cellRange = this.getCellRange(col, row), absoluteLeft = this.getColsWidth(0, cellRange.start.col - 1) || 0, width = this.getColsWidth(cellRange.start.col, cellRange.end.col), absoluteTop = this.getRowsHeight(0, cellRange.start.row - 1) || 0, height = this.getRowsHeight(cellRange.start.row, cellRange.end.row);
        return new Rect_1.Rect(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
    }
    getCellRelativeRect(col, row) {
        const isFrozenCell = this.isFrozenCell(col, row);
        let relativeX = !0, relativeY = !0;
        (null == isFrozenCell ? void 0 : isFrozenCell.col) && (null == isFrozenCell ? void 0 : isFrozenCell.row) ? (relativeX = !1, 
        relativeY = !1) : (null == isFrozenCell ? void 0 : isFrozenCell.col) ? relativeX = !1 : (null == isFrozenCell ? void 0 : isFrozenCell.row) && (relativeY = !1);
        const cellRect = this.getCellRect(col, row);
        return this._toRelativeRect(cellRect, relativeX, relativeY);
    }
    getCellRangeRelativeRect(range) {
        if (range.start) {
            const isFrozenCell = this.isFrozenCell(range.start.col, range.start.row);
            let relativeX = !0, relativeY = !0;
            return (null == isFrozenCell ? void 0 : isFrozenCell.col) && (null == isFrozenCell ? void 0 : isFrozenCell.row) ? (relativeX = !1, 
            relativeY = !1) : (null == isFrozenCell ? void 0 : isFrozenCell.col) ? relativeX = !1 : (null == isFrozenCell ? void 0 : isFrozenCell.row) && (relativeY = !1), 
            this._toRelativeRect(this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row), relativeX, relativeY);
        }
        const cellRange = this.getCellRange(range.col, range.row), isFrozenCell = this.isFrozenCell(range.col, range.row);
        let relativeX = !0, relativeY = !0;
        return (null == isFrozenCell ? void 0 : isFrozenCell.col) && (null == isFrozenCell ? void 0 : isFrozenCell.row) ? (relativeX = !1, 
        relativeY = !1) : (null == isFrozenCell ? void 0 : isFrozenCell.col) ? relativeX = !1 : (null == isFrozenCell ? void 0 : isFrozenCell.row) && (relativeY = !1), 
        this._toRelativeRect(this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row), relativeX, relativeY);
    }
    getVisibleCellRangeRelativeRect(range) {
        let cellRange;
        return cellRange = range.start ? range : this.getCellRange(range.col, range.row), 
        this._getVisiableRect(this.getCellRangeRelativeRect(range), cellRange);
    }
    _getVisiableRect(relativeRectObj, cellRange) {
        const targetLeft = cellRange.start.col >= this.frozenColCount ? Math.max(relativeRectObj.left, this.frozenColCount >= 1 ? this.getColsWidth(0, this.frozenColCount - 1) : 0) : relativeRectObj.left, targetRight = Math.min(relativeRectObj.right, this.tableNoFrameWidth), rect = relativeRectObj.copy();
        rect.left = targetLeft, rect.right = targetRight;
        const targetTop = cellRange.start.row >= this.frozenRowCount ? Math.max(relativeRectObj.top, this.frozenRowCount >= 1 ? this.getRowsHeight(0, this.frozenRowCount - 1) : 0) : relativeRectObj.top, targetBottom = Math.min(relativeRectObj.bottom, this.tableNoFrameHeight);
        return rect.top = targetTop, rect.bottom = targetBottom, rect;
    }
    getCellsRect(startCol, startRow, endCol, endRow) {
        var _a, _b, _c, _d, _e, _f;
        let absoluteLeft = this.getColsWidth(0, startCol - 1) || 0, width = this.getColsWidth(startCol, endCol);
        const scrollLeft = this.scrollLeft, tableWidth = Math.min(this.tableNoFrameWidth, this.getAllColsWidth()), tableHeight = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
        this.isLeftFrozenColumn(startCol) && this.isRightFrozenColumn(endCol) ? width = this.tableNoFrameWidth - (null !== (_a = this.getColsWidth(startCol + 1, this.colCount - 1)) && void 0 !== _a ? _a : 0) - absoluteLeft : this.isLeftFrozenColumn(startCol) && !this.isLeftFrozenColumn(endCol) ? width = Math.max(width - scrollLeft, this.getColsWidth(startCol, this.frozenColCount - 1)) : !this.isRightFrozenColumn(startCol) && this.isRightFrozenColumn(endCol) ? (absoluteLeft = Math.min(absoluteLeft - scrollLeft, tableWidth - this.getRightFrozenColsWidth()), 
        width = tableWidth - (null !== (_b = this.getColsWidth(startCol + 1, this.colCount - 1)) && void 0 !== _b ? _b : 0) - absoluteLeft) : this.isRightFrozenColumn(startCol) && (absoluteLeft = tableWidth - (null !== (_c = this.getColsWidth(startCol, this.colCount - 1)) && void 0 !== _c ? _c : 0));
        let absoluteTop = this.getRowsHeight(0, startRow - 1), height = this.getRowsHeight(startRow, endRow);
        const scrollTop = this.scrollTop;
        return this.isTopFrozenRow(startRow) && this.isBottomFrozenRow(endRow) ? height = this.tableNoFrameHeight - (null !== (_d = this.getRowsHeight(startRow + 1, this.rowCount - 1)) && void 0 !== _d ? _d : 0) - absoluteTop : this.isTopFrozenRow(startRow) && !this.isTopFrozenRow(endRow) ? height = Math.max(height - scrollTop, this.getRowsHeight(startRow, this.frozenRowCount - 1)) : !this.isBottomFrozenRow(startRow) && this.isBottomFrozenRow(endRow) ? (absoluteTop = Math.min(absoluteTop - scrollTop, tableHeight - this.getBottomFrozenRowsHeight()), 
        height = tableHeight - (null !== (_e = this.getRowsHeight(startRow + 1, this.rowCount - 1)) && void 0 !== _e ? _e : 0) - absoluteTop) : this.isBottomFrozenRow(startRow) && (absoluteTop = tableHeight - (null !== (_f = this.getRowsHeight(startRow, this.rowCount - 1)) && void 0 !== _f ? _f : 0)), 
        new Rect_1.Rect(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
    }
    getCellsRectWidth(startCol, startRow, endCol, endRow) {
        const isFrozenStartCell = this.isFrozenCell(startCol, startRow), isFrozenEndCell = this.isFrozenCell(endCol, endRow);
        let width = this.getColsWidth(startCol, endCol);
        if (isFrozenStartCell && isFrozenStartCell.col) {
            const scrollLeft = this.scrollLeft;
            isFrozenEndCell && isFrozenEndCell.col || (width -= scrollLeft, width = Math.max(width, this.getColsWidth(startCol, this.frozenColCount - 1)));
        }
        return width;
    }
    getCellRangeRect(range) {
        if (range.start) return this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row);
        const cellRange = this.getCellRange(range.col, range.row);
        return this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
    }
    getCellRangeRectWidth(range) {
        if (range.start) return this.getCellsRectWidth(range.start.col, range.start.row, range.end.col, range.end.row);
        const cellRange = this.getCellRange(range.col, range.row);
        return this.getCellsRectWidth(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
    }
    isFrozenCell(col, row) {
        const isFrozenRow = this.isFrozenRow(row), isFrozenCol = this.isFrozenColumn(col);
        return isFrozenRow || isFrozenCol ? {
            row: isFrozenRow,
            col: isFrozenCol
        } : null;
    }
    getRowAt(absoluteY) {
        return (0, get_cell_position_1.getRowAt)(absoluteY, this);
    }
    getColAt(absoluteX) {
        return (0, get_cell_position_1.getColAt)(absoluteX, this);
    }
    getCellAt(absoluteX, absoluteY) {
        return (0, get_cell_position_1.getCellAt)(absoluteX, absoluteY, this);
    }
    getCellAtRelativePosition(relativeX, relativeY) {
        return (0, get_cell_position_1.getCellAtRelativePosition)(relativeX, relativeY, this);
    }
    _checkRowCol(col, row) {
        return col >= 0 && col < this.colCount && row >= 0 && row < this.rowCount;
    }
    _makeVisibleCell(col, row) {
        if (this._checkRowCol(col, row)) {
            const isFrozenCell = this.isFrozenCell(col, row);
            if (isFrozenCell && isFrozenCell.col && isFrozenCell.row) return;
            const rect = this.getCellRect(col, row), visibleRect = (0, tableHelper_1._getScrollableVisibleRect)(this);
            if (visibleRect.contains(rect)) return;
            isFrozenCell && isFrozenCell.col || this.getColsWidth(0, this.frozenColCount - 1) + rect.width > this.canvas.width || (rect.left < visibleRect.left ? this.scrollLeft -= visibleRect.left - rect.left : visibleRect.right < rect.right && (this.scrollLeft -= visibleRect.right - rect.right)), 
            isFrozenCell && isFrozenCell.row || this.getRowsHeight(0, this.frozenRowCount - 1) + rect.height > this.canvas.height || (rect.top < visibleRect.top ? this.scrollTop -= visibleRect.top - rect.top : visibleRect.bottom < rect.bottom && (this.scrollTop -= visibleRect.bottom - rect.bottom));
        }
    }
    render() {
        this.scenegraph.renderSceneGraph();
    }
    renderAsync() {
        return this.scenegraph.updateNextFrame(), new Promise(((resolve, reject) => {
            setTimeout((() => {
                resolve();
            }), 0);
        }));
    }
    _toRelativeRect(absoluteRect, relativeX = !0, relativeY = !0) {
        var _a, _b, _c, _d;
        const rect = absoluteRect.copy(), visibleRect = this.getVisibleRect();
        return rect.offsetLeft(this.tableX - (relativeX ? visibleRect.left : 0)), rect.offsetTop(this.tableY - (relativeY ? visibleRect.top : 0)), 
        rect.offsetLeft(null !== (_b = null === (_a = this.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0), 
        rect.offsetTop(null !== (_d = null === (_c = this.options.viewBox) || void 0 === _c ? void 0 : _c.y1) && void 0 !== _d ? _d : 0), 
        rect;
    }
    getVisibleRect() {
        const {scrollTop: scrollTop, scrollLeft: scrollLeft} = this, width = this.tableNoFrameWidth, height = this.tableNoFrameHeight;
        return new Rect_1.Rect(scrollLeft, scrollTop, width, height);
    }
    get visibleRowCount() {
        const {frozenRowCount: frozenRowCount} = this, visibleRect = this.getVisibleRect(), visibleTop = frozenRowCount > 0 ? visibleRect.top + this.getRowsHeight(0, frozenRowCount - 1) : visibleRect.top, initRow = this.getTargetRowAt(visibleTop);
        if (!initRow) return 0;
        const startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);
        let absoluteTop = this.getRowsHeight(0, startRow - 1), count = 0;
        const {rowCount: rowCount} = this;
        for (let row = startRow; row < rowCount; row++) {
            const bottom = absoluteTop + this.getRowHeight(row);
            if (visibleRect.bottom < bottom) break;
            count++, absoluteTop = bottom;
        }
        return count;
    }
    getBodyVisibleCellRange() {
        const {scrollTop: scrollTop, scrollLeft: scrollLeft} = this, frozenRowsHeight = this.getFrozenRowsHeight(), frozenColsWidth = this.getFrozenColsWidth(), bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight(), rightFrozenColsWidth = this.getRightFrozenColsWidth(), {row: rowStart} = this.getRowAt(scrollTop + frozenRowsHeight + 1), {col: colStart} = this.getColAt(scrollLeft + frozenColsWidth + 1), rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row : this.rowCount - 1, colEnd = this.getAllColsWidth() > this.tableNoFrameWidth ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col : this.colCount - 1;
        return colEnd < 0 || rowEnd < 0 ? null : {
            rowStart: rowStart,
            colStart: colStart,
            rowEnd: rowEnd,
            colEnd: colEnd
        };
    }
    getBodyVisibleRowRange() {
        const {scrollTop: scrollTop} = this, frozenRowsHeight = this.getFrozenRowsHeight(), bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight(), {row: rowStart} = this.getRowAt(scrollTop + frozenRowsHeight + 1), rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row : this.rowCount - 1;
        return rowEnd < 0 ? null : {
            rowStart: rowStart,
            rowEnd: rowEnd
        };
    }
    getBodyVisibleColRange() {
        const {scrollLeft: scrollLeft} = this, frozenColsWidth = this.getFrozenColsWidth(), rightFrozenColsWidth = this.getRightFrozenColsWidth(), {col: colStart} = this.getColAt(scrollLeft + frozenColsWidth + 1), colEnd = this.getAllColsWidth() > this.tableNoFrameWidth ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col : this.colCount - 1;
        return colEnd < 0 ? null : {
            colStart: colStart,
            colEnd: colEnd
        };
    }
    get visibleColCount() {
        const {frozenColCount: frozenColCount} = this, visibleRect = this.getVisibleRect(), visibleLeft = frozenColCount > 0 ? visibleRect.left + this.getColsWidth(0, frozenColCount - 1) : visibleRect.left, initCol = this.getTargetColAt(visibleLeft);
        if (!initCol) return 0;
        const startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);
        let absoluteLeft = this.getColsWidth(0, startCol - 1), count = 0;
        const {colCount: colCount} = this;
        for (let col = startCol; col < colCount; col++) {
            const right = absoluteLeft + this.getColWidth(col);
            if (visibleRect.right < right) break;
            count++, absoluteLeft = right;
        }
        return count;
    }
    get scrollTop() {
        return this.stateManager.scroll.verticalBarPos;
    }
    set scrollTop(scrollTop) {
        this.stateManager.setScrollTop(scrollTop);
    }
    get scrollLeft() {
        return this.stateManager.scroll.horizontalBarPos;
    }
    set scrollLeft(scrollLeft) {
        this.stateManager.setScrollLeft(scrollLeft);
    }
    getScrollLeft() {
        return this.scrollLeft;
    }
    getScrollTop() {
        return this.scrollTop;
    }
    setScrollLeft(num) {
        this.scrollLeft = Math.ceil(num);
    }
    setScrollTop(num) {
        this.scrollTop = Math.ceil(num);
    }
    getCellOverflowText(col, row) {
        return this.scenegraph.getCellOverflowText(col, row);
    }
    addReleaseObj(releaseObj) {
        if (!releaseObj || !releaseObj.release || "function" != typeof releaseObj.release) throw new Error("not releaseObj!");
        (this.internalProps.releaseList = this.internalProps.releaseList || []).push(releaseObj);
    }
    dispose() {
        this.release();
    }
    release() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const internalProps = this.internalProps;
        if (this.isReleased) return;
        null === (_b = null === (_a = internalProps.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), 
        null === (_d = null === (_c = internalProps.menuHandler) || void 0 === _c ? void 0 : _c.release) || void 0 === _d || _d.call(_c), 
        null === (_e = super.release) || void 0 === _e || _e.call(this), null === (_g = null === (_f = internalProps.handler) || void 0 === _f ? void 0 : _f.release) || void 0 === _g || _g.call(_f), 
        this.eventManager.release(), null === (_j = null === (_h = internalProps.focusControl) || void 0 === _h ? void 0 : _h.release) || void 0 === _j || _j.call(_h), 
        null === (_k = internalProps.legends) || void 0 === _k || _k.forEach((legend => {
            null == legend || legend.release();
        })), null === (_l = internalProps.title) || void 0 === _l || _l.release(), internalProps.title = null, 
        null === (_m = internalProps.emptyTip) || void 0 === _m || _m.release(), internalProps.emptyTip = null, 
        internalProps.layoutMap.release(), internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj => {
            var _a;
            return null === (_a = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a ? void 0 : _a.call(releaseObj);
        })), internalProps.releaseList = null), this.scenegraph.stage.release(), this.scenegraph.proxy.release(), 
        internalProps.focusControl.release();
        const {parentElement: parentElement} = internalProps.element;
        parentElement && !this.options.canvas && parentElement.removeChild(internalProps.element), 
        null === (_q = null === (_p = null === (_o = this.editorManager) || void 0 === _o ? void 0 : _o.editingEditor) || void 0 === _p ? void 0 : _p.onEnd) || void 0 === _q || _q.call(_p), 
        this.isReleased = !0, this.scenegraph = null, this.internalProps = null, null === (_r = this.reactCustomLayout) || void 0 === _r || _r.clearCache(), 
        this.pluginManager.release(), (0, chart_render_helper_1.clearChartRenderQueue)();
    }
    fireListeners(type, event) {
        return super.fireListeners(type, event);
    }
    updateOption(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        null === (_a = this.editorManager) || void 0 === _a || _a.cancelEdit(), this.options = options, 
        this._hasAutoImageColumn = void 0;
        const {frozenColCount: frozenColCount = 0, unfreezeAllOnExceedsMaxWidth: unfreezeAllOnExceedsMaxWidth, defaultRowHeight: defaultRowHeight = 40, defaultHeaderRowHeight: defaultHeaderRowHeight, defaultColWidth: defaultColWidth = 80, defaultHeaderColWidth: defaultHeaderColWidth = 80, keyboardOptions: keyboardOptions, eventOptions: eventOptions, rowSeriesNumber: rowSeriesNumber, columnResizeMode: columnResizeMode, rowResizeMode: rowResizeMode = "none", resize: resize, dragHeaderMode: dragHeaderMode, dragOrder: dragOrder, showFrozenIcon: showFrozenIcon, allowFrozenColCount: allowFrozenColCount, padding: padding, hover: hover, menu: menu, select: click, pixelRatio: pixelRatio, widthMode: widthMode, heightMode: heightMode, autoFillWidth: autoFillWidth, autoFillHeight: autoFillHeight, widthAdaptiveMode: widthAdaptiveMode, heightAdaptiveMode: heightAdaptiveMode, customRender: customRender, renderChartAsync: renderChartAsync, renderChartAsyncBatchCount: renderChartAsyncBatchCount, canvasWidth: canvasWidth, canvasHeight: canvasHeight, overscrollBehavior: overscrollBehavior, limitMinWidth: limitMinWidth, limitMinHeight: limitMinHeight} = options;
        pixelRatio && pixelRatio !== this.internalProps.pixelRatio && (this.internalProps.pixelRatio = pixelRatio), 
        padding && ("number" == typeof padding ? (this.padding.top = padding, this.padding.left = padding, 
        this.padding.bottom = padding, this.padding.right = padding) : (padding.top && (this.padding.top = padding.top), 
        padding.bottom && (this.padding.bottom = padding.bottom), padding.left && (this.padding.left = padding.left), 
        padding.right && (this.padding.right = padding.right))), this.showFrozenIcon = "boolean" != typeof showFrozenIcon || showFrozenIcon, 
        "number" == typeof allowFrozenColCount && allowFrozenColCount <= 0 && (this.showFrozenIcon = !1), 
        this.widthMode = null != widthMode ? widthMode : "standard", this.heightMode = null != heightMode ? heightMode : "standard", 
        this._widthAdaptiveMode = null != widthAdaptiveMode ? widthAdaptiveMode : "only-body", 
        this._heightAdaptiveMode = null != heightAdaptiveMode ? heightAdaptiveMode : "only-body", 
        this.autoFillWidth = null != autoFillWidth && autoFillWidth, this.autoFillHeight = null != autoFillHeight && autoFillHeight, 
        this.customRender = customRender, this.canvasWidth = (0, vutils_1.isNumber)(canvasWidth) ? canvasWidth : void 0, 
        this.canvasHeight = (0, vutils_1.isNumber)(canvasHeight) ? canvasHeight : void 0;
        const internalProps = this.internalProps;
        if ("node" === env_1.Env.mode || options.canvas || (0, tableHelper_1.updateRootElementPadding)(internalProps.element, this.padding), 
        this.columnWidthComputeMode = null !== (_b = options.columnWidthComputeMode) && void 0 !== _b ? _b : "normal", 
        internalProps.frozenColCount = frozenColCount, internalProps.unfreezeAllOnExceedsMaxWidth = null == unfreezeAllOnExceedsMaxWidth || unfreezeAllOnExceedsMaxWidth, 
        internalProps.defaultRowHeight = defaultRowHeight, internalProps.defaultHeaderRowHeight = null != defaultHeaderRowHeight ? defaultHeaderRowHeight : defaultRowHeight, 
        internalProps.defaultColWidth = defaultColWidth, internalProps.defaultHeaderColWidth = null != defaultHeaderColWidth ? defaultHeaderColWidth : defaultColWidth, 
        internalProps.keyboardOptions = keyboardOptions, internalProps.eventOptions = eventOptions, 
        internalProps.rowSeriesNumber = rowSeriesNumber, internalProps.columnResizeMode = null !== (_c = null == resize ? void 0 : resize.columnResizeMode) && void 0 !== _c ? _c : columnResizeMode, 
        internalProps.rowResizeMode = null !== (_d = null == resize ? void 0 : resize.rowResizeMode) && void 0 !== _d ? _d : rowResizeMode, 
        internalProps.dragHeaderMode = null !== (_f = null !== (_e = null == dragOrder ? void 0 : dragOrder.dragHeaderMode) && void 0 !== _e ? _e : dragHeaderMode) && void 0 !== _f ? _f : "none", 
        internalProps.renderChartAsync = renderChartAsync, (0, chart_render_helper_1.setBatchRenderChartCount)(renderChartAsyncBatchCount), 
        internalProps.overscrollBehavior = null != overscrollBehavior ? overscrollBehavior : "auto", 
        internalProps.cellTextOverflows = {}, internalProps._rowHeightsMap = new row_height_map_1.NumberRangeMap(this), 
        internalProps._rowRangeHeightsMap = new Map, internalProps._colRangeWidthsMap = new Map, 
        internalProps._widthResizedColMap = new Set, internalProps._heightResizedRowMap = new Set, 
        this.colWidthsMap = new NumberMap_1.NumberMap, this.colContentWidthsMap = new NumberMap_1.NumberMap, 
        this.colWidthsLimit = {}, internalProps.stick.changedCells.clear(), internalProps.theme = themes_1.default.of(null !== (_g = options.theme) && void 0 !== _g ? _g : themes_1.default.DEFAULT), 
        internalProps.theme.isPivot = this.isPivotTable(), (0, icons_1.setIconColor)(internalProps.theme.functionalIconsStyle), 
        this.scenegraph.updateStageBackground(), internalProps.autoWrapText = options.autoWrapText, 
        internalProps.enableLineBreak = options.enableLineBreak, internalProps.allowFrozenColCount = null !== (_h = options.allowFrozenColCount) && void 0 !== _h ? _h : 0, 
        internalProps.limitMaxAutoWidth = null !== (_j = options.limitMaxAutoWidth) && void 0 !== _j ? _j : 450, 
        internalProps.limitMinWidth = null != limitMinWidth ? "number" == typeof limitMinWidth ? limitMinWidth : limitMinWidth ? 10 : 0 : 10, 
        internalProps.limitMinHeight = null != limitMinHeight ? "number" == typeof limitMinHeight ? limitMinHeight : limitMinHeight ? 10 : 0 : 10, 
        null === (_k = internalProps.legends) || void 0 === _k || _k.forEach((legend => {
            null == legend || legend.release();
        })), null === (_l = internalProps.title) || void 0 === _l || _l.release(), internalProps.title = null, 
        null === (_m = internalProps.emptyTip) || void 0 === _m || _m.release(), internalProps.emptyTip = null, 
        internalProps.layoutMap.release(), (0, chart_render_helper_1.clearChartRenderQueue)(), 
        this.scenegraph.clearCells(), this.scenegraph.updateComponent(), this.stateManager.updateOptionSetState(), 
        this._updateSize(), this.eventManager.updateEventBinder(), options.legends) {
            internalProps.legends = [];
            const createLegend = factory_1.Factory.getFunction("createLegend");
            if (Array.isArray(options.legends)) {
                for (let i = 0; i < options.legends.length; i++) internalProps.legends.push(createLegend(options.legends[i], this));
                this.scenegraph.tableGroup.setAttributes({
                    x: this.tableX,
                    y: this.tableY
                });
            } else internalProps.legends.push(createLegend(options.legends, this)), this.scenegraph.tableGroup.setAttributes({
                x: this.tableX,
                y: this.tableY
            });
        }
        if (internalProps.tooltip = Object.assign({
            parentElement: this.getElement(),
            renderMode: "html",
            isShowOverflowTextTooltip: !1,
            confine: !0,
            position: ts_types_1.Placement.bottom
        }, options.tooltip), "html" === internalProps.tooltip.renderMode && !internalProps.tooltipHandler) {
            const TooltipHandler = factory_1.Factory.getComponent("tooltipHandler");
            internalProps.tooltipHandler = new TooltipHandler(this, internalProps.tooltip.confine);
        }
        if (internalProps.menu = Object.assign({
            renderMode: "html"
        }, options.menu), Array.isArray(null === (_o = options.menu) || void 0 === _o ? void 0 : _o.dropDownMenuHighlight) && this.setDropDownMenuHighlight(null === (_p = options.menu) || void 0 === _p ? void 0 : _p.dropDownMenuHighlight), 
        (Array.isArray(null === (_q = options.menu) || void 0 === _q ? void 0 : _q.defaultHeaderMenuItems) || "function" == typeof (null === (_r = options.menu) || void 0 === _r ? void 0 : _r.defaultHeaderMenuItems)) && (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems), 
        "html" === internalProps.menu.renderMode && !internalProps.menuHandler) {
            const MenuHandler = factory_1.Factory.getComponent("menuHandler");
            internalProps.menuHandler = new MenuHandler(this);
        }
        this.clearCellStyleCache(), this.clearColWidthCache(), this.clearRowHeightCache(), 
        internalProps.customMergeCell = (0, get_custom_merge_cell_func_1.getCustomMergeCellFunc)(options.customMergeCell), 
        null === (_s = this.customCellStylePlugin) || void 0 === _s || _s.updateCustomCell(null !== (_t = options.customCellStyle) && void 0 !== _t ? _t : [], null !== (_u = options.customCellStyleArrangement) && void 0 !== _u ? _u : []), 
        this._adjustCanvasSizeByOption();
    }
    renderWithRecreateCells() {
        this.internalProps.stick.changedCells.clear();
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, this.scenegraph.clearCells(), 
        this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), 
        this.render();
    }
    getFrozenRowsHeight() {
        return this.getRowsHeight(0, this.frozenRowCount - 1);
    }
    getFrozenColsWidth() {
        return this.getColsWidth(0, this.frozenColCount - 1);
    }
    getBottomFrozenRowsHeight() {
        if (this.bottomFrozenRowCount > 0) {
            let height = 0;
            for (let row = this.rowCount - this.bottomFrozenRowCount; row <= this.rowCount - 1; row++) height += this.getRowHeight(row);
            return height;
        }
        return 0;
    }
    getRightFrozenColsWidth() {
        if (this.rightFrozenColCount > 0) {
            let width = 0;
            for (let col = this.colCount - this.rightFrozenColCount; col <= this.colCount - 1; col++) width += this.getColWidth(col);
            return width;
        }
        return 0;
    }
    getDrawRange() {
        const width = Math.min(this.tableNoFrameWidth, this.getAllColsWidth()), height = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
        return new Rect_1.Rect(this.tableX, this.tableY, width, height);
    }
    _getMouseAbstractPoint(evt) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let e;
        if (!evt) return {
            inTable: !1,
            x: void 0,
            y: void 0
        };
        e = isTouchEvent(evt) ? evt.changedTouches[0] : evt;
        const clientX = e.clientX || e.pageX + window.scrollX, clientY = e.clientY || e.pageY + window.scrollY, rect = this.internalProps.canvas.getBoundingClientRect();
        let inTable = !0;
        rect.right <= clientX && (inTable = !1), rect.bottom <= clientY && (inTable = !1);
        const currentWidth = rect.width, widthRatio = currentWidth / ((90 === this.rotateDegree ? this.canvas.offsetHeight : this.canvas.offsetWidth) || currentWidth), currentHeight = rect.height, heightRatio = currentHeight / ((90 === this.rotateDegree ? this.canvas.offsetWidth : this.canvas.offsetHeight) || currentHeight), rotateTablePlugin = this.pluginManager.getPluginByName("Rotate Table");
        if (rotateTablePlugin && 90 === this.rotateDegree) {
            const point = {
                x: clientX / widthRatio - (null !== (_b = null === (_a = this.options.viewBox) || void 0 === _a ? void 0 : _a.x1) && void 0 !== _b ? _b : 0),
                y: clientY / heightRatio - (null !== (_d = null === (_c = this.options.viewBox) || void 0 === _c ? void 0 : _c.y1) && void 0 !== _d ? _d : 0),
                inTable: inTable
            };
            return rotateTablePlugin.matrix.transformPoint(point, point), point;
        }
        const point = {
            x: (clientX - rect.left) / widthRatio - (null !== (_f = null === (_e = this.options.viewBox) || void 0 === _e ? void 0 : _e.x1) && void 0 !== _f ? _f : 0),
            y: (clientY - rect.top) / heightRatio - (null !== (_h = null === (_g = this.options.viewBox) || void 0 === _g ? void 0 : _g.y1) && void 0 !== _h ? _h : 0),
            inTable: inTable
        };
        if (this.internalProps.modifiedViewBoxTransform && this.scenegraph.stage.window.getViewBoxTransform()) {
            return this.scenegraph.stage.window.getViewBoxTransform().transformPoint(point, point), 
            point;
        }
        return point;
    }
    getTheme() {
        return this.internalProps.theme;
    }
    getTargetColAt(absoluteX) {
        return (0, get_cell_position_1.getTargetColAt)(absoluteX, this);
    }
    getTargetRowAt(absoluteY) {
        const targetRow = (0, get_cell_position_1.getTargetRowAt)(absoluteY, this);
        return targetRow && (targetRow.row = Math.min(targetRow.row, this.rowCount - 1)), 
        targetRow;
    }
    getTargetColAtConsiderRightFrozen(absoluteX, isConsider) {
        return (0, get_cell_position_1.getTargetColAtConsiderRightFrozen)(absoluteX, isConsider, this);
    }
    getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider) {
        return (0, get_cell_position_1.getTargetRowAtConsiderBottomFrozen)(absoluteY, isConsider, this);
    }
    clearSelected() {
        this.stateManager.updateSelectPos(-1, -1);
    }
    selectCell(col, row, isShift, isCtrl, makeSelectCellVisible, skipBodyMerge = !1) {
        var _a, _b, _c;
        const isHasSelected = !!(null === (_a = this.stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
        this.stateManager.updateSelectPos(col, row, isShift, isCtrl, !1, null === (_c = null != makeSelectCellVisible ? makeSelectCellVisible : null === (_b = this.options.select) || void 0 === _b ? void 0 : _b.makeSelectCellVisible) || void 0 === _c || _c, skipBodyMerge), 
        this.stateManager.endSelectCells(!0, isHasSelected);
    }
    selectCells(cellRanges) {
        const {scrollLeft: scrollLeft, scrollTop: scrollTop} = this;
        cellRanges.forEach(((cellRange, index) => {
            var _a, _b, _c, _d, _e, _f;
            cellRange.start.col === cellRange.end.col && cellRange.start.row === cellRange.end.row ? this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, !1, index >= 1, !1, null === (_b = null === (_a = this.options.select) || void 0 === _a ? void 0 : _a.makeSelectCellVisible) || void 0 === _b || _b, !0) : (this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, !1, index >= 1, !1, null === (_d = null === (_c = this.options.select) || void 0 === _c ? void 0 : _c.makeSelectCellVisible) || void 0 === _d || _d, !0), 
            this.stateManager.updateInteractionState(ts_types_1.InteractionState.grabing), this.stateManager.updateSelectPos(cellRange.end.col, cellRange.end.row, !1, index >= 1, !1, null === (_f = null === (_e = this.options.select) || void 0 === _e ? void 0 : _e.makeSelectCellVisible) || void 0 === _f || _f, !0)), 
            this.stateManager.endSelectCells(!1, !1), this.stateManager.updateInteractionState(ts_types_1.InteractionState.default);
        })), this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft);
    }
    get recordsCount() {
        var _a;
        return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
    }
    get allowFrozenColCount() {
        return this.internalProps.allowFrozenColCount;
    }
    get rowHeaderLevelCount() {
        return this.internalProps.layoutMap.rowHeaderLevelCount;
    }
    get columnHeaderLevelCount() {
        return this.internalProps.layoutMap.columnHeaderLevelCount;
    }
    get records() {
        return this.internalProps.records;
    }
    get dataSource() {
        return this.internalProps.dataSource;
    }
    set dataSource(dataSource) {
        this.scenegraph.clearCells(), (0, tableHelper_1._setDataSource)(this, dataSource), 
        this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render();
    }
    get autoWrapText() {
        return this.internalProps.autoWrapText;
    }
    set autoWrapText(autoWrapText) {
        this.internalProps.autoWrapText = autoWrapText, this.options.autoWrapText = autoWrapText;
    }
    get enableLineBreak() {
        return this.internalProps.enableLineBreak;
    }
    set enableLineBreak(enableLineBreak) {
        this.internalProps.enableLineBreak = enableLineBreak, this.options.enableLineBreak = enableLineBreak;
    }
    updateAutoWrapText(autoWrapText) {
        this.internalProps.autoWrapText !== autoWrapText && (this.internalProps.autoWrapText = autoWrapText, 
        this.options.autoWrapText = autoWrapText, this.scenegraph.clearCells(), this.clearCellStyleCache(), 
        this.scenegraph.createSceneGraph(), this.render());
    }
    get theme() {
        return this.internalProps.theme;
    }
    set theme(theme) {
        this.internalProps.theme = themes_1.default.of(null != theme ? theme : themes_1.default.DEFAULT), 
        this.internalProps.theme.isPivot = this.isPivotTable(), this.options.theme = theme, 
        (0, icons_1.setIconColor)(this.internalProps.theme.functionalIconsStyle);
    }
    updateTheme(theme) {
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        this.internalProps.theme = themes_1.default.of(null != theme ? theme : themes_1.default.DEFAULT), 
        this.internalProps.theme.isPivot = this.isPivotTable(), (0, icons_1.setIconColor)(this.internalProps.theme.functionalIconsStyle), 
        this.options.theme = theme, this.scenegraph.updateComponent(), this.scenegraph.updateStageBackground(), 
        this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), 
        this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.render();
    }
    getBodyField(col, row) {
        return this.internalProps.layoutMap.getBody(col, row).field;
    }
    getBodyColumnDefine(col, row) {
        const body = this.internalProps.layoutMap.getBody(col, row);
        return null == body ? void 0 : body.define;
    }
    getBodyColumnType(col, row) {
        var _a, _b;
        const cellType = null !== (_b = null === (_a = this.internalProps.layoutMap.getBody(col, row)) || void 0 === _a ? void 0 : _a.cellType) && void 0 !== _b ? _b : "text";
        return (0, get_prop_1.getProp)("cellType", {
            cellType: cellType
        }, col, row, this);
    }
    getCellType(col, row) {
        let cellType;
        return this.isSeriesNumberInHeader(col, row) ? this.internalProps.layoutMap.getSeriesNumberHeader(col, row).cellType : (cellType = this.isHeader(col, row) ? this.internalProps.layoutMap.getHeader(col, row).headerType : this.internalProps.layoutMap.getBody(col, row).cellType, 
        (0, get_prop_1.getProp)("cellType", {
            cellType: cellType
        }, col, row, this));
    }
    getHeaderField(col, row) {
        return this.internalProps.layoutMap.getHeaderField(col, row);
    }
    getHeaderDefine(col, row) {
        const hd = this.internalProps.layoutMap.getHeader(col, row);
        return null == hd ? void 0 : hd.define;
    }
    getCellLocation(col, row) {
        return this.internalProps.layoutMap.getCellLocation(col, row);
    }
    getCellHeaderPaths(col, row) {
        return this.internalProps.layoutMap.getCellHeaderPaths(col, row);
    }
    getHeadersDefine(col, row) {
        const headers = [];
        for (;;) {
            const header = this.getHeaderDefine(col, row);
            if (!header || !header.field && !header.columns) break;
            headers.push(header), row++;
        }
        return headers;
    }
    _getHeaderLayoutMap(col, row) {
        return this.internalProps.layoutMap.getHeader(col, row);
    }
    _getBodyLayoutMap(col, row) {
        return this.internalProps.layoutMap.getBody(col, row);
    }
    getContext() {
        return this.internalProps.context;
    }
    getRecordByCell(col, row) {
        if (!this.internalProps.layoutMap.isHeader(col, row)) return this.getCellOriginRecord(col, row);
    }
    getRecordByRowCol(col, row) {
        return this.getRecordByCell(col, row);
    }
    getRecordStartRowByRecordIndex(index) {
        return this.internalProps.layoutMap.getRecordStartRowByRecordIndex(index);
    }
    _getHeaderCellBySortState(sortState) {
        const {layoutMap: layoutMap} = this.internalProps, hd = layoutMap.headerObjects.find((col => col && col.field === sortState.field));
        if (hd) {
            return layoutMap.getHeaderCellAdressById(hd.id);
        }
    }
    getCellRange(col, row) {
        var _a;
        if (this.internalProps.customMergeCell) {
            const customMerge = this.internalProps.customMergeCell(col, row, this);
            if (customMerge && customMerge.range && ((0, vutils_1.isValid)(customMerge.text) || customMerge.customLayout || customMerge.customRender)) {
                return {
                    start: {
                        col: Math.max(customMerge.range.start.col, 0),
                        row: Math.max(customMerge.range.start.row, 0)
                    },
                    end: {
                        col: Math.min(customMerge.range.end.col, this.colCount - 1),
                        row: Math.min(customMerge.range.end.row, this.rowCount - 1)
                    },
                    isCustom: !0
                };
            }
        }
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.getCellRange(col, row);
    }
    hasCustomMerge() {
        return !!this.internalProps.customMergeCell;
    }
    getCustomMerge(col, row) {
        if (this.internalProps.customMergeCell) {
            const customMerge = this.internalProps.customMergeCell(col, row, this);
            if (customMerge && customMerge.range && ((0, vutils_1.isValid)(customMerge.text) || customMerge.customLayout || this.customRender)) {
                if (customMerge.style) {
                    const styleClass = this.internalProps.bodyHelper.getStyleClass("text"), style = customMerge.style, fullStyle = columnStyleContents.of(style, this.theme.bodyStyle, {
                        col: col,
                        row: row,
                        table: this,
                        value: customMerge.text,
                        dataValue: this.getCellOriginValue(col, row),
                        cellHeaderPaths: this.getCellHeaderPaths(col, row)
                    }, styleClass, this.options.autoWrapText, this.theme);
                    customMerge.style = fullStyle;
                }
                return customMerge.range = {
                    start: {
                        col: Math.max(customMerge.range.start.col, 0),
                        row: Math.max(customMerge.range.start.row, 0)
                    },
                    end: {
                        col: Math.min(customMerge.range.end.col, this.colCount - 1),
                        row: Math.min(customMerge.range.end.row, this.rowCount - 1)
                    },
                    isCustom: !0
                }, customMerge;
            }
        }
    }
    isCellRangeEqual(col, row, targetCol, targetRow) {
        return this.internalProps.layoutMap.isCellRangeEqual(col, row, targetCol, targetRow);
    }
    _getLayoutCellId(col, row) {
        return this.internalProps.layoutMap.getCellId(col, row);
    }
    getHeaderDescription(col, row) {
        var _a;
        const field = this._getHeaderLayoutMap(col, row), fieldDef = null == field ? void 0 : field.define, description = null !== (_a = null == fieldDef ? void 0 : fieldDef.description) && void 0 !== _a ? _a : null == field ? void 0 : field.description;
        if ("function" == typeof description) {
            return description({
                col: col,
                row: row,
                value: this.getCellValue(col, row),
                dataValue: this.getCellOriginValue(col, row)
            });
        }
        return description;
    }
    setDropDownMenuHighlight(cells) {
        this.stateManager.setDropDownMenuHighlight(cells);
    }
    _dropDownMenuIsHighlight(colNow, rowNow, index) {
        return this.stateManager.dropDownMenuIsHighlight(colNow, rowNow, index);
    }
    isSeriesNumberInBody(col, row) {
        return this.internalProps.layoutMap && this.internalProps.layoutMap.isSeriesNumberInBody(col, row);
    }
    isSeriesNumberInHeader(col, row) {
        return this.internalProps.layoutMap && this.internalProps.layoutMap.isSeriesNumberInHeader(col, row);
    }
    isHeader(col, row) {
        return this.internalProps.layoutMap && this.internalProps.layoutMap.isHeader(col, row);
    }
    isColumnHeader(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isColumnHeader(col, row);
    }
    isRowHeader(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isRowHeader(col, row);
    }
    isCornerHeader(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isCornerHeader(col, row);
    }
    isFrozenColumn(col, row) {
        return this.isLeftFrozenColumn(col, row) || this.isRightFrozenColumn(col, row);
    }
    isLeftFrozenColumn(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isFrozenColumn(col, row);
    }
    isRightFrozenColumn(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isRightFrozenColumn(col, row);
    }
    isFrozenRow(col, row) {
        return this.isTopFrozenRow(col, row) || this.isBottomFrozenRow(col, row);
    }
    isTopFrozenRow(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isFrozenRow(col, row);
    }
    isBottomFrozenRow(col, row) {
        var _a;
        return null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.isBottomFrozenRow(col, row);
    }
    getCellInfo(col, row) {
        if (col >= 0 && row >= 0) {
            const colDef = this.isHeader(col, row) ? this.getHeaderDefine(col, row) : this.getBodyColumnDefine(col, row);
            return {
                col: col,
                row: row,
                field: this.getHeaderField(col, row),
                cellHeaderPaths: this.internalProps.layoutMap.getCellHeaderPaths(col, row),
                title: null == colDef ? void 0 : colDef.title,
                cellType: this.getCellType(col, row),
                originData: this.getCellOriginRecord(col, row),
                cellRange: this.getCellRangeRelativeRect({
                    col: col,
                    row: row
                }),
                value: this.getCellValue(col, row),
                dataValue: this.getCellOriginValue(col, row),
                cellLocation: this.getCellLocation(col, row),
                scaleRatio: this.canvas.getBoundingClientRect().width / this.canvas.offsetWidth
            };
        }
    }
    _hasField(field, col, row) {
        var _a;
        if (null === field) return !1;
        if (this.internalProps.layoutMap.isHeader(col, row)) return !1;
        const index = this.getRecordShowIndexByCell(col, row);
        return null === (_a = this.internalProps.dataSource) || void 0 === _a ? void 0 : _a.hasField(index, field);
    }
    _getCellStyle(col, row) {
        return (0, style_helper_1.getCellStyle)(col, row, this);
    }
    clearCellStyleCache() {
        this.headerStyleCache.clear(), this.bodyStyleCache.clear(), this.bodyMergeTitleCache.clear(), 
        this.bodyBottomStyleCache.clear();
    }
    clearRowHeightCache() {
        this.internalProps._rowHeightsMap.clear(), this._clearRowRangeHeightsMap();
    }
    clearColWidthCache() {
        this.internalProps._colWidthsMap.clear(), this._clearColRangeWidthsMap();
    }
    _canResizeColumn(col, row) {
        if (!(col >= 0 && row >= 0)) return !1;
        if (this.isCellRangeEqual(col, row, col + 1, row)) return !1;
        if ("none" === this.internalProps.columnResizeMode) return !1;
        if ("header" === this.internalProps.columnResizeMode) {
            if (!this.isHeader(col, row)) return !1;
        } else if ("body" === this.internalProps.columnResizeMode && this.isHeader(col, row)) return !1;
        const limit = this.colWidthsLimit[col];
        return !(limit && limit.min && limit.max) || limit.max !== limit.min;
    }
    _canResizeRow(col, row) {
        if (!(col >= 0 && row >= 0)) return !1;
        if (this.isCellRangeEqual(col, row, col, row + 1)) return !1;
        if ("none" === this.internalProps.rowResizeMode) return !1;
        if ("header" === this.internalProps.rowResizeMode) {
            if (!this.isHeader(col, row)) return !1;
        } else if ("body" === this.internalProps.rowResizeMode && this.isHeader(col, row)) return !1;
        return !0;
    }
    _canDragHeaderPosition(col, row) {
        var _a;
        if (this.isHeader(col, row) && (this.stateManager.isSelected(col, row) || "body" === (null === (_a = this.options.select) || void 0 === _a ? void 0 : _a.headerSelectMode) && (0, 
        check_in_select_1.checkCellInSelect)(col, row, [ this.getCellRange(this.stateManager.select.cellPos.col, this.stateManager.select.cellPos.row) ]) || (0, 
        is_cell_select_highlight_1.isCellDisableSelect)(this, col, row))) {
            if ("disabled" === this.internalProps.frozenColDragHeaderMode && this.isFrozenColumn(col)) return !1;
            if (this.stateManager.isSelected(col, row)) {
                const selectRange = this.stateManager.select.ranges[0];
                if (this.isColumnHeader(col, row)) {
                    if (selectRange.end.row !== this.rowCount - 1) return !1;
                } else {
                    if (!this.isRowHeader(col, row)) return !1;
                    if (selectRange.end.col !== this.colCount - 1) return !1;
                }
            }
            const define = this.getHeaderDefine(col, row);
            if (!define) return !1;
            if (void 0 === define.dragHeader) {
                if ("all" === this.internalProps.dragHeaderMode) return !0;
                if ("column" === this.internalProps.dragHeaderMode) {
                    if (this.isColumnHeader(col, row)) return !0;
                } else if ("row" === this.internalProps.dragHeaderMode && this.isRowHeader(col, row)) return !0;
                return !1;
            }
            return define.dragHeader;
        }
        return !1;
    }
    getCellIcons(col, row) {
        var _a, _b, _c;
        let icons;
        if (this.isHeader(col, row)) icons = this.internalProps.headerHelper.getIcons(col, row); else if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
            if (!this.options.groupBy || !(null === (_a = this.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge)) {
                (null === (_c = null === (_b = this.internalProps.layoutMap.getSeriesNumberBody(col, row)) || void 0 === _b ? void 0 : _b.define) || void 0 === _c ? void 0 : _c.dragOrder) && (icons = this.internalProps.rowSeriesNumberHelper.getIcons(col, row));
            }
            const cellValue = this.getCellValue(col, row), dataValue = this.getCellOriginValue(col, row), ctx = this.internalProps.context, cellIcon = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
            (null == icons ? void 0 : icons.length) > 0 ? icons = icons.concat(cellIcon) : (null == cellIcon ? void 0 : cellIcon.length) > 0 && (icons = cellIcon);
        } else {
            const cellValue = this.getCellValue(col, row), dataValue = this.getCellOriginValue(col, row), ctx = this.internalProps.context;
            icons = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
        }
        return icons;
    }
    showDropDownMenu(col, row, dropDownMenuOptions) {
        let menuType = "dropdown-menu";
        dropDownMenuOptions && (menuType = Array.isArray(dropDownMenuOptions.content) ? "dropdown-menu" : "container"), 
        "html" === this.internalProps.menu.renderMode && (this.stateManager.menu.isShow = !0, 
        this.internalProps.menuHandler._bindToCell(col, row, menuType, dropDownMenuOptions));
    }
    showTooltip(col, row, tooltipOptions) {
        "html" === this.internalProps.tooltip.renderMode && this.internalProps.tooltipHandler._bindToCell(col, row, tooltipOptions);
    }
    getCellStyle(col, row) {
        const actStyle = this._getCellStyle(col, row), theme = (0, tableHelper_1.getStyleTheme)(actStyle, this, col, row, get_prop_1.getProp).theme, {autoWrapText: autoWrapText, lineClamp: lineClamp, textOverflow: textOverflow} = actStyle;
        return {
            textAlign: theme.text.textAlign,
            textBaseline: theme.text.textBaseline,
            bgColor: (0, vutils_1.isBoolean)(theme.group.fill) ? (0, get_prop_1.getProp)("bgColor", actStyle, col, row, this) : theme.group.fill,
            color: (0, vutils_1.isBoolean)(theme.text.fill) ? (0, get_prop_1.getProp)("color", actStyle, col, row, this) : theme.text.fill,
            strokeColor: (0, vutils_1.isBoolean)(theme.text.stroke) ? (0, get_prop_1.getProp)("strokeColor", actStyle, col, row, this) : theme.text.stroke,
            fontFamily: theme.text.fontFamily,
            fontSize: theme.text.fontSize,
            fontWeight: theme.text.fontWeight,
            fontVariant: theme.text.fontVariant,
            fontStyle: theme.text.fontStyle,
            lineHeight: theme.text.lineHeight,
            autoWrapText: null != autoWrapText && autoWrapText,
            lineClamp: null != lineClamp ? lineClamp : "auto",
            textOverflow: textOverflow,
            borderColor: (0, vutils_1.isBoolean)(theme.group.stroke) ? (0, get_prop_1.getProp)("borderColor", actStyle, col, row, this) : theme.group.stroke,
            borderLineWidth: theme.group.lineWidth,
            borderLineDash: theme.group.lineDash,
            underline: !!theme.text.underline,
            underlineDash: theme.text.underlineDash,
            underlineOffset: theme.text.underlineOffset,
            lineThrough: !!theme.text.lineThrough,
            padding: theme._vtable.padding,
            underlineWidth: theme.text.underline,
            lineThroughLineWidth: theme.text.lineThrough,
            _strokeArrayWidth: theme.group.strokeArrayWidth,
            _strokeArrayColor: theme.group.strokeArrayColor,
            _linkColor: (0, get_prop_1.getProp)("linkColor", actStyle, col, row, this)
        };
    }
    getAllBodyCells(colMaxCount, rowMaxCount) {
        const start_col = this.rowHeaderLevelCount, start_row = this.columnHeaderLevelCount, end_col = this.colCount - 1, end_row = this.rowCount - 1;
        return Array(Math.min(null != rowMaxCount ? rowMaxCount : 2e3, end_row - start_row + 1, this.rowCount)).fill(0).map(((_, i) => Array(Math.min(null != colMaxCount ? colMaxCount : 2e3, end_col - start_col + 1, this.colCount)).fill(0).map(((_, j) => this.getCellInfo(j + start_col, i + start_row)))));
    }
    getAllCells(colMaxCount, rowMaxCount) {
        const start_col = 0, start_row = 0, end_col = this.colCount - 1, end_row = this.rowCount - 1;
        return Array(Math.min(null != rowMaxCount ? rowMaxCount : 2e3, end_row - start_row + 1, this.rowCount)).fill(0).map(((_, i) => Array(Math.min(null != colMaxCount ? colMaxCount : 2e3, end_col - start_col + 1, this.colCount)).fill(0).map(((_, j) => this.getCellInfo(j + start_col, i + start_row)))));
    }
    getAllColumnHeaderCells() {
        const start_col = this.rowHeaderLevelCount, start_row = 0, end_col = this.colCount - 1, end_row = this.columnHeaderLevelCount - 1;
        return Array(end_row - start_row + 1).fill(0).map(((_, i) => Array(end_col - start_col + 1).fill(0).map(((_, j) => this.getCellInfo(j + start_col, i + start_row)))));
    }
    getAllRowHeaderCells() {
        const start_col = 0, start_row = this.columnHeaderLevelCount, end_col = this.rowHeaderLevelCount - 1, end_row = this.rowCount - 1;
        return Array(end_row - start_row + 1).fill(0).map(((_, i) => Array(end_col - start_col + 1).fill(0).map(((_, j) => this.getCellInfo(j + start_col, i + start_row)))));
    }
    getCopyValue() {
        var _a, _b, _c;
        if ((null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0) {
            const ranges = this.stateManager.select.ranges;
            let minCol = Math.min(ranges[0].start.col, ranges[0].end.col), maxCol = Math.max(ranges[0].start.col, ranges[0].end.col), minRow = Math.min(ranges[0].start.row, ranges[0].end.row), maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
            ranges.forEach((a => {
                minCol = Math.min(minCol, a.start.col, a.end.col), maxCol = Math.max(maxCol, a.start.col, a.end.col), 
                minRow = Math.min(minRow, a.start.row, a.end.row), maxRow = Math.max(maxRow, a.start.row, a.end.row);
            }));
            const isExistDataInRow = r => {
                let isExist = !1;
                return ranges.forEach((range => {
                    const minRow = Math.min(range.start.row, range.end.row), maxRow = Math.max(range.start.row, range.end.row);
                    minRow <= r && maxRow >= r && (isExist = !0);
                })), isExist;
            }, isExistDataInCol = c => {
                let isExist = !1;
                return ranges.forEach((range => {
                    const minCol = Math.min(range.start.col, range.end.col), maxCol = Math.max(range.start.col, range.end.col);
                    minCol <= c && maxCol >= c && (isExist = !0);
                })), isExist;
            }, getRangeExistDataInCell = (c, r) => {
                let isExistRange;
                return ranges.forEach((range => {
                    const minRow = Math.min(range.start.row, range.end.row), maxRow = Math.max(range.start.row, range.end.row), minCol = Math.min(range.start.col, range.end.col), maxCol = Math.max(range.start.col, range.end.col);
                    minCol <= c && maxCol >= c && minRow <= r && maxRow >= r && (isExistRange = range);
                })), isExistRange;
            }, getCopyCellValue = (col, row, range) => {
                const cellRange = this.getCellRange(col, row);
                let copyStartCol = cellRange.start.col, copyStartRow = cellRange.start.row;
                if (range) {
                    const rangeMinCol = Math.min(range.start.col, range.end.col), rangeMinRow = Math.min(range.start.row, range.end.row);
                    copyStartCol = Math.max(rangeMinCol, cellRange.start.col), copyStartRow = Math.max(rangeMinRow, cellRange.start.row);
                }
                if (copyStartCol !== col || copyStartRow !== row) return "";
                return this.getCellValue(col, row);
            };
            let copyValue = "";
            for (let r = minRow; r <= maxRow; r++) {
                if (isExistDataInRow(r)) {
                    for (let c = minCol; c <= maxCol; c++) {
                        if (isExistDataInCol(c)) {
                            const range = getRangeExistDataInCell(c, r);
                            if (range) {
                                const copyCellValue = getCopyCellValue(c, r, range);
                                if ("undefined" != typeof Promise && copyCellValue instanceof Promise) ; else {
                                    const strCellValue = (0, vutils_1.isValid)(copyCellValue) ? `${copyCellValue}` : "";
                                    /^\[object .*\]$/.exec(strCellValue) || (copyValue += strCellValue);
                                }
                                (c < range.end.col || c < maxCol) && (copyValue += "\t");
                            } else copyValue += "\t";
                        }
                    }
                    r < maxRow && (copyValue += "\r\n");
                }
            }
            return (null === (_c = this.options) || void 0 === _c ? void 0 : _c.formatCopyValue) && (copyValue = this.options.formatCopyValue(copyValue)), 
            copyValue;
        }
        return "";
    }
    getSelectedCellInfos() {
        var _a;
        if (!(null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges)) return null;
        const ranges = this.stateManager.select.ranges;
        if (!ranges.length) return [];
        let minCol = Math.min(ranges[0].start.col, ranges[0].end.col), maxCol = Math.max(ranges[0].start.col, ranges[0].end.col), minRow = Math.min(ranges[0].start.row, ranges[0].end.row), maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
        ranges.forEach((a => {
            minCol = Math.min(minCol, a.start.col, a.end.col), maxCol = Math.max(maxCol, a.start.col, a.end.col), 
            minRow = Math.min(minRow, a.start.row, a.end.row), maxRow = Math.max(maxRow, a.start.row, a.end.row);
        }));
        const isExistDataInRow = r => {
            let isExist = !1;
            return ranges.forEach((range => {
                const minRow = Math.min(range.start.row, range.end.row), maxRow = Math.max(range.start.row, range.end.row);
                minRow <= r && maxRow >= r && (isExist = !0);
            })), isExist;
        }, isExistDataInCol = c => {
            let isExist = !1;
            return ranges.forEach((range => {
                const minCol = Math.min(range.start.col, range.end.col), maxCol = Math.max(range.start.col, range.end.col);
                minCol <= c && maxCol >= c && (isExist = !0);
            })), isExist;
        }, getRangeExistDataInCell = (c, r) => {
            let isExistRange;
            return ranges.forEach((range => {
                const minRow = Math.min(range.start.row, range.end.row), maxRow = Math.max(range.start.row, range.end.row), minCol = Math.min(range.start.col, range.end.col), maxCol = Math.max(range.start.col, range.end.col);
                minCol <= c && maxCol >= c && minRow <= r && maxRow >= r && (isExistRange = range);
            })), isExistRange;
        }, cellInfoArray = [];
        for (let r = minRow; r <= maxRow; r++) {
            if (isExistDataInRow(r)) {
                const cellInfoRow = [];
                for (let c = minCol; c <= maxCol; c++) {
                    if (isExistDataInCol(c)) {
                        if (getRangeExistDataInCell(c, r)) {
                            const cellInfo = this.getCellInfo(c, r);
                            cellInfoRow.push(cellInfo);
                        }
                    }
                }
                cellInfoArray.push(cellInfoRow);
            }
        }
        return cellInfoArray;
    }
    getSelectedCellRanges() {
        const ranges = this.stateManager.select.ranges;
        return ranges.length ? (0, vutils_1.cloneDeep)(ranges) : [];
    }
    measureText(text, font) {
        return text_measure_1.textMeasure.measureText(text, font);
    }
    measureTextBounds(attribute) {
        return (0, text_measure_1.measureTextBounds)(attribute);
    }
    getCustomRender(col, row) {
        let customRender;
        if ("body" !== this.getCellLocation(col, row)) {
            const define = this.getHeaderDefine(col, row);
            customRender = null == define ? void 0 : define.headerCustomRender;
        } else {
            const define = this.getBodyColumnDefine(col, row);
            customRender = (null == define ? void 0 : define.customRender) || this.customRender;
        }
        return customRender;
    }
    getCustomLayout(col, row) {
        let customLayout;
        if ("body" !== this.getCellLocation(col, row)) {
            const define = this.getHeaderDefine(col, row);
            customLayout = null == define ? void 0 : define.headerCustomLayout;
        } else {
            const define = this.getBodyColumnDefine(col, row);
            customLayout = null == define ? void 0 : define.customLayout;
        }
        return customLayout;
    }
    hasAutoImageColumn() {
        return void 0 === this._hasAutoImageColumn && (this._hasAutoImageColumn = (0, layout_helper_1.hasAutoImageColumn)(this)), 
        this._hasAutoImageColumn;
    }
    _getActiveChartInstance() {
        var _a, _b, _c, _d, _e, _f;
        const cellGroup = this.scenegraph.getCell(null === (_b = null === (_a = this.stateManager.hover) || void 0 === _a ? void 0 : _a.cellPos) || void 0 === _b ? void 0 : _b.col, null === (_d = null === (_c = this.stateManager.hover) || void 0 === _c ? void 0 : _c.cellPos) || void 0 === _d ? void 0 : _d.row);
        return "chart" === (null === (_f = null === (_e = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.type) ? cellGroup.getChildren()[0].activeChartInstance : null;
    }
    cellIsInVisualView(col, row) {
        var _a, _b, _c, _d;
        const drawRange = this.getDrawRange(), rect = this.getCellRelativeRect(col, row);
        if (col < this.frozenColCount && row < this.frozenRowCount) return !0;
        let colHeaderRangeRect, rowHeaderRangeRect, bottomFrozenRangeRect, rightFrozenRangeRect;
        if (this.frozenRowCount >= 1 && (colHeaderRangeRect = this.getCellRangeRelativeRect({
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: this.colCount - 1,
                row: this.frozenRowCount - 1
            }
        })), this.frozenColCount >= 1 && (rowHeaderRangeRect = this.getCellRangeRelativeRect({
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: this.frozenColCount - 1,
                row: this.rowCount - 1
            }
        })), this.bottomFrozenRowCount >= 1 && (bottomFrozenRangeRect = this.getCellRangeRelativeRect({
            start: {
                col: 0,
                row: this.rowCount - this.bottomFrozenRowCount
            },
            end: {
                col: this.colCount - 1,
                row: this.rowCount - 1
            }
        })), this.rightFrozenColCount >= 1 && (rightFrozenRangeRect = this.getCellRangeRelativeRect({
            start: {
                col: this.colCount - this.rightFrozenColCount,
                row: 0
            },
            end: {
                col: this.colCount - 1,
                row: this.rowCount - 1
            }
        })), rect.top >= drawRange.top && rect.bottom <= drawRange.bottom && rect.left >= drawRange.left && rect.right <= drawRange.right) {
            if (this.isFrozenCell(col, row)) return !0;
            if (rect.top >= (null !== (_a = null == colHeaderRangeRect ? void 0 : colHeaderRangeRect.bottom) && void 0 !== _a ? _a : rect.top) && rect.left >= (null !== (_b = null == rowHeaderRangeRect ? void 0 : rowHeaderRangeRect.right) && void 0 !== _b ? _b : rect.left) && rect.bottom <= (null !== (_c = null == bottomFrozenRangeRect ? void 0 : bottomFrozenRangeRect.top) && void 0 !== _c ? _c : rect.bottom) && rect.right <= (null !== (_d = null == rightFrozenRangeRect ? void 0 : rightFrozenRangeRect.left) && void 0 !== _d ? _d : rect.right)) return !0;
        }
        return !1;
    }
    getCustomMergeValue(col, row) {
        if (this.internalProps.customMergeCell) {
            const customMerge = this.getCustomMerge(col, row);
            if (customMerge) {
                const {text: text} = customMerge;
                return text;
            }
        }
    }
    exportImg() {
        return this.scenegraph.stage.toCanvas().toDataURL();
    }
    exportCellImg(col, row, options) {
        var _a, _b, _c, _d;
        const isInView = this.cellIsInVisualView(col, row), {scrollTop: scrollTop, scrollLeft: scrollLeft} = this;
        isInView || this.scrollToCell({
            col: col,
            row: row
        });
        const cellRect = this.getCellRelativeRect(col, row);
        (null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 && (0, 
        update_select_border_1.hideCellSelectBorder)(this.scenegraph);
        const {col: hoverCol, row: hoverRow} = this.stateManager.hover.cellPos;
        let oldFill, oldStroke;
        if (this.stateManager.updateHoverPos(-1, -1), this.scenegraph.component.hideVerticalScrollBar(), 
        this.scenegraph.component.hideHorizontalScrollBar(), this.scenegraph.tableGroup.border.setAttribute("visible", !1), 
        null == options ? void 0 : options.disableBackground) {
            const cellGroup = this.scenegraph.getCell(col, row);
            oldFill = cellGroup.attribute.fill, cellGroup.setAttribute("fill", "transparent");
        }
        if (null == options ? void 0 : options.disableBorder) {
            const cellGroup = this.scenegraph.getCell(col, row);
            oldStroke = cellGroup.attribute.stroke, cellGroup.setAttribute("stroke", !1);
        }
        this.scenegraph.renderSceneGraph();
        let sizeOffset = 0;
        "bottom-right" === this.theme.cellBorderClipDirection && (sizeOffset = 1);
        const c = this.scenegraph.stage.toCanvas(!1, (new vutils_1.AABBBounds).set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX - sizeOffset, cellRect.bottom + this.tableY - sizeOffset));
        if (isInView || (this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft)), 
        this.scenegraph.tableGroup.border.setAttribute("visible", !0), oldFill) {
            this.scenegraph.getCell(col, row).setAttribute("fill", oldFill);
        }
        if (oldStroke) {
            this.scenegraph.getCell(col, row).setAttribute("stroke", oldStroke);
        }
        return (null === (_d = null === (_c = this.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length) > 0 && (0, 
        update_select_border_1.restoreCellSelectBorder)(this.scenegraph), this.stateManager.updateHoverPos(hoverCol, hoverRow), 
        this.scenegraph.updateNextFrame(), c.toDataURL();
    }
    exportCellRangeImg(cellRange) {
        var _a, _b, _c, _d;
        const {scrollTop: scrollTop, scrollLeft: scrollLeft} = this, minCol = Math.min(cellRange.start.col, cellRange.end.col), minRow = Math.min(cellRange.start.row, cellRange.end.row), maxCol = Math.max(cellRange.start.col, cellRange.end.col), maxRow = Math.max(cellRange.start.row, cellRange.end.row), isInView = this.cellIsInVisualView(minCol, minRow), isMaxCellInView = this.cellIsInVisualView(maxCol, maxRow);
        isInView && isMaxCellInView || this.scrollToCell({
            col: minCol,
            row: minRow
        });
        const cellRect = this.getCellRangeRelativeRect({
            start: {
                col: minCol,
                row: minRow
            },
            end: {
                col: maxCol,
                row: maxRow
            }
        });
        (null === (_b = null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 && (0, 
        update_select_border_1.hideCellSelectBorder)(this.scenegraph);
        const {col: hoverCol, row: hoverRow} = this.stateManager.hover.cellPos;
        this.stateManager.updateHoverPos(-1, -1), this.scenegraph.component.hideVerticalScrollBar(), 
        this.scenegraph.component.hideHorizontalScrollBar(), this.scenegraph.renderSceneGraph();
        const base64Image = this.scenegraph.stage.toCanvas(!1, (new vutils_1.AABBBounds).set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX, cellRect.bottom + this.tableY)).toDataURL();
        return isInView && isMaxCellInView || (this.setScrollTop(scrollTop), this.setScrollLeft(scrollLeft)), 
        (null === (_d = null === (_c = this.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length) > 0 && (0, 
        update_select_border_1.restoreCellSelectBorder)(this.scenegraph), this.stateManager.updateHoverPos(hoverCol, hoverRow), 
        base64Image;
    }
    exportCanvas() {
        return this.scenegraph.stage.toCanvas();
    }
    getImageBuffer(type = "image/png") {
        if ("node" !== this.options.mode) return;
        this.render();
        const stage = this.scenegraph.stage;
        if (stage) {
            const contentWidth = this.tableX + this.getAllColsWidth(), contentHeight = this.tableY + this.getAllRowsHeight();
            if (contentWidth >= this.canvasWidth && contentHeight >= this.canvasHeight) {
                stage.render();
                return stage.window.getImageBuffer(type);
            }
            return this.scenegraph.stage.toCanvas(!1, (new vutils_1.AABBBounds).set(0, 0, Math.min(this.canvasWidth, contentWidth), Math.min(this.canvasHeight, contentHeight))).toBuffer(type);
        }
        return null;
    }
    getBodyIndexByTableIndex(col, row) {
        return {
            col: col - this.rowHeaderLevelCount - this.leftRowSeriesNumberCount,
            row: row - this.columnHeaderLevelCount
        };
    }
    getTableIndexByBodyIndex(col, row) {
        return {
            col: col + this.rowHeaderLevelCount + this.leftRowSeriesNumberCount,
            row: row + this.columnHeaderLevelCount
        };
    }
    onVChartEvent(type, query, callback) {
        this._chartEventMap[type] || (this._chartEventMap[type] = []), "function" == typeof query ? this._chartEventMap[type].push({
            callback: query
        }) : this._chartEventMap[type].push({
            callback: callback,
            query: query
        });
    }
    offVChartEvent(type, callback) {
        this._chartEventMap[type] && (this._chartEventMap[type] = callback ? this._chartEventMap[type].filter((e => e.callback !== callback)) : []);
    }
    _bindChartEvent(activeChartInstance) {
        if (activeChartInstance) for (const key in this._chartEventMap) (this._chartEventMap[key] || []).forEach((e => {
            e.query ? activeChartInstance.on(key, e.query, e.callback) : activeChartInstance.on(key, e.callback);
        }));
    }
    changeRecordOrder(source, target) {}
    hasCustomCellStyle(customStyleId) {
        var _a;
        return null === (_a = this.customCellStylePlugin) || void 0 === _a ? void 0 : _a.hasCustomCellStyle(customStyleId);
    }
    registerCustomCellStyle(customStyleId, customStyle) {
        var _a;
        null === (_a = this.customCellStylePlugin) || void 0 === _a || _a.registerCustomCellStyle(customStyleId, customStyle);
    }
    arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate) {
        var _a;
        null === (_a = this.customCellStylePlugin) || void 0 === _a || _a.arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate);
    }
    isSeriesNumber(col, row) {
        return this.internalProps.layoutMap.isSeriesNumber(col, row);
    }
    isHasSeriesNumber() {
        var _a;
        return (null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.leftRowSeriesNumberColumnCount) > 0;
    }
    get leftRowSeriesNumberCount() {
        var _a, _b;
        return null !== (_b = null === (_a = this.internalProps.layoutMap) || void 0 === _a ? void 0 : _a.leftRowSeriesNumberColumnCount) && void 0 !== _b ? _b : 0;
    }
    setMinMaxLimitWidth(setWidth = !1) {
        var _a, _b;
        const internalProps = this.internalProps;
        for (let col = 0; col < internalProps.layoutMap.columnWidths.length; col++) {
            if (this.internalProps._widthResizedColMap.has(col)) continue;
            const {width: width, minWidth: minWidth, maxWidth: maxWidth} = null !== (_b = null === (_a = internalProps.layoutMap.columnWidths) || void 0 === _a ? void 0 : _a[col]) && void 0 !== _b ? _b : {};
            setWidth && width && ("string" == typeof width && "auto" !== width || "number" == typeof width && width > 0) && this._setColWidth(col, width), 
            minWidth && ("number" == typeof minWidth && minWidth > 0 || "string" == typeof minWidth) && this.setMinColWidth(col, minWidth), 
            maxWidth && ("number" == typeof maxWidth && maxWidth > 0 || "string" == typeof maxWidth) && this.setMaxColWidth(col, maxWidth);
        }
    }
    setSortedIndexMap(field, filedMap) {
        var _a;
        null === (_a = this.dataSource) || void 0 === _a || _a.setSortedIndexMap(field, filedMap);
    }
    checkReactCustomLayout() {
        this.reactCustomLayout || (this.reactCustomLayout = new react_custom_layout_1.ReactCustomLayout(this));
    }
    get bodyDomContainer() {
        return this.internalProps.bodyDomContainer;
    }
    get headerDomContainer() {
        return this.internalProps.headerDomContainer;
    }
    get frozenBodyDomContainer() {
        return this.internalProps.frozenBodyDomContainer;
    }
    get frozenHeaderDomContainer() {
        return this.internalProps.frozenHeaderDomContainer;
    }
    get rightFrozenBodyDomContainer() {
        return this.internalProps.rightFrozenBodyDomContainer;
    }
    get rightFrozenHeaderDomContainer() {
        return this.internalProps.rightFrozenHeaderDomContainer;
    }
    get frozenBottomDomContainer() {
        return this.internalProps.frozenBottomDomContainer;
    }
    get bottomDomContainer() {
        return this.internalProps.bottomDomContainer;
    }
    get rightFrozenBottomDomContainer() {
        return this.internalProps.rightFrozenBottomDomContainer;
    }
    showMoverLine(col, row) {
        this.scenegraph.component.showMoveCol(col, row, 0), this.scenegraph.renderSceneGraph();
    }
    hideMoverLine(col, row) {
        this.scenegraph.component.hideMoveCol(), this.scenegraph.renderSceneGraph();
    }
    disableScroll() {
        this.eventManager.disableScroll();
    }
    enableScroll() {
        this.eventManager.enableScroll();
    }
    getGroupTitleLevel(col, row) {}
    scrollToRow(row, animationOption) {
        animationOption ? this.animationManager.scrollTo({
            row: row
        }, animationOption) : this.scrollToCell({
            row: row
        });
    }
    scrollToCol(col, animationOption) {
        animationOption ? this.animationManager.scrollTo({
            col: col
        }, animationOption) : this.scrollToCell({
            col: col
        });
    }
    scrollToCell(cellAddr, animationOption) {
        if (animationOption) return void this.animationManager.scrollTo(cellAddr, animationOption);
        const drawRange = this.getDrawRange();
        if ((0, vutils_1.isValid)(cellAddr.col) && cellAddr.col >= this.frozenColCount) {
            const frozenWidth = this.getFrozenColsWidth(), left = this.getColsWidth(0, cellAddr.col - 1);
            this.scrollLeft = Math.min(left - frozenWidth, this.getAllColsWidth() - drawRange.width);
        }
        if ((0, vutils_1.isValid)(cellAddr.row) && cellAddr.row >= this.frozenRowCount) {
            const frozenHeight = this.getFrozenRowsHeight(), top = this.getRowsHeight(0, cellAddr.row - 1);
            this.scrollTop = Math.min(top - frozenHeight, this.getAllRowsHeight() - drawRange.height);
        }
        this.render();
    }
    checkHasColumnAutoWidth() {
        return (0, tableHelper_1.checkHasColumnAutoWidth)(this);
    }
}

exports.BaseTable = BaseTable;
//# sourceMappingURL=BaseTable.js.map