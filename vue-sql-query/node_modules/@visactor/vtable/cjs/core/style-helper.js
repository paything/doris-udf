"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getCellStyle = void 0;

const get_axis_config_1 = require("../layout/chart-helper/get-axis-config"), vutils_1 = require("@visactor/vutils"), headerStyleContents = __importStar(require("../header-helper/style")), columnStyleContents = __importStar(require("../body-helper/style")), custom_cell_style_1 = require("../plugins/custom-cell-style"), EMPTY_STYLE = {};

function getCellStyle(col, row, table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const customCellStyle = null === (_a = table.customCellStylePlugin) || void 0 === _a ? void 0 : _a.getCustomCellStyle(col, row), {layoutMap: layoutMap} = table.internalProps;
    if (layoutMap.isHeader(col, row)) {
        let cacheKey;
        if (!table.isPivotTable() || table.isBottomFrozenRow(row) || table.isRightFrozenColumn(col)) cacheKey = `${col}-${row}`; else {
            const define = table.getHeaderDefine(col, row), isCorner = table.isCornerHeader(col, row);
            cacheKey = (null == define ? void 0 : define.dimensionKey) ? isCorner ? `dim-cor-${define.dimensionKey}` : `dim-${define.dimensionKey}` : (null == define ? void 0 : define.indicatorKey) ? `ind-${define.indicatorKey}` : `${col}-${row}`;
        }
        let cacheStyle = table.headerStyleCache.get(cacheKey);
        if (cacheStyle) return customCellStyle ? (0, custom_cell_style_1.mergeStyle)(cacheStyle, customCellStyle) : cacheStyle;
        const hd = layoutMap.getHeader(col, row);
        let paddingForAxis;
        if (table.isPivotChart() && (0, get_axis_config_1.isTopOrBottomAxis)(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
            paddingForAxis = null !== (_c = null === (_b = layoutMap.getBody(col, table.rowHeaderLevelCount).style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : table.theme.bodyStyle.padding;
        } else if (table.isPivotChart() && (0, get_axis_config_1.isLeftOrRightAxis)(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
            paddingForAxis = null !== (_e = null === (_d = layoutMap.getBody(table.columnHeaderLevelCount, row).style) || void 0 === _d ? void 0 : _d.padding) && void 0 !== _e ? _e : table.theme.bodyStyle.padding;
        }
        if ((!hd || hd.isEmpty) && (layoutMap.isLeftBottomCorner(col, row) || layoutMap.isRightBottomCorner(col, row) || layoutMap.isCornerHeader(col, row) || layoutMap.isRightTopCorner(col, row))) return EMPTY_STYLE;
        const styleClass = table.internalProps.headerHelper.getStyleClass((null == hd ? void 0 : hd.headerType) || "text");
        if (layoutMap.isBottomFrozenRow(col, row) && table.theme.bottomFrozenStyle) cacheStyle = headerStyleContents.of(paddingForAxis ? {
            padding: paddingForAxis
        } : {}, table.theme.bottomFrozenStyle, {
            col: col,
            row: row,
            table: table,
            value: table.getCellValue(col, row),
            dataValue: table.getCellOriginValue(col, row),
            cellHeaderPaths: table.getCellHeaderPaths(col, row)
        }, styleClass, table.options.autoWrapText, table.theme); else if (layoutMap.isRightFrozenColumn(col, row) && table.theme.rightFrozenStyle) cacheStyle = headerStyleContents.of(paddingForAxis ? {
            padding: paddingForAxis
        } : {}, table.theme.rightFrozenStyle, {
            col: col,
            row: row,
            table: table,
            value: table.getCellValue(col, row),
            dataValue: table.getCellOriginValue(col, row),
            cellHeaderPaths: table.getCellHeaderPaths(col, row)
        }, styleClass, table.options.autoWrapText, table.theme); else {
            const style = (null == hd ? void 0 : hd.style) || {};
            paddingForAxis && (style.padding = paddingForAxis), cacheStyle = headerStyleContents.of(style, layoutMap.isColumnHeader(col, row) || layoutMap.isBottomFrozenRow(col, row) ? table.theme.headerStyle : layoutMap.isRowHeader(col, row) || layoutMap.isRightFrozenColumn(col, row) ? table.theme.rowHeaderStyle : table.theme.cornerHeaderStyle, {
                col: col,
                row: row,
                table: table,
                value: table.getCellValue(col, row),
                dataValue: table.getCellOriginValue(col, row),
                cellHeaderPaths: table.getCellHeaderPaths(col, row)
            }, styleClass, table.options.autoWrapText, table.theme);
        }
        return table.headerStyleCache.set(cacheKey, cacheStyle), customCellStyle ? (0, custom_cell_style_1.mergeStyle)(cacheStyle, customCellStyle) : cacheStyle;
    }
    let bgColorFunc, cacheKey;
    (null === (_g = null === (_f = table.internalProps) || void 0 === _f ? void 0 : _f.dataConfig) || void 0 === _g ? void 0 : _g.mappingRules) && !table.isHeader(col, row) && (null === (_k = null === (_j = null === (_h = table.internalProps) || void 0 === _h ? void 0 : _h.dataConfig) || void 0 === _j ? void 0 : _j.mappingRules) || void 0 === _k || _k.forEach(((mappingRule, i) => {
        mappingRule.bgColor && table.internalProps.layoutMap.getIndicatorKey(col, row) === mappingRule.bgColor.indicatorKey && (bgColorFunc = mappingRule.bgColor.mapping);
    })));
    const cellType = table.getCellType(col, row), rawRecord = table.getCellOriginRecord(col, row);
    let cacheStyle;
    if (cacheKey = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? "merge-title" : table.isSeriesNumberInBody(col, row) ? `${col}-series-` + cellType : table.isListTable() && !table.transpose || table.isPivotTable() && table.internalProps.layoutMap.indicatorsAsCol ? col + cellType : row + cellType, 
    cacheStyle = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? table.bodyMergeTitleCache.get(cacheKey) : layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.get(cacheKey) : table.bodyStyleCache.get(cacheKey), 
    cacheStyle) return customCellStyle ? (0, custom_cell_style_1.mergeStyle)(cacheStyle, customCellStyle) : cacheStyle;
    const column = layoutMap.getBody(col, row), styleClass = table.internalProps.bodyHelper.getStyleClass(table.getCellType(col, row)), style = null == column ? void 0 : column.style;
    return cacheStyle = columnStyleContents.of(style, (null == rawRecord ? void 0 : rawRecord.vtableMerge) && table.theme.groupTitleStyle ? table.theme.groupTitleStyle : layoutMap.isBottomFrozenRow(row) && table.theme.bottomFrozenStyle ? table.theme.bottomFrozenStyle : layoutMap.isRightFrozenColumn(col) && table.theme.rightFrozenStyle ? table.theme.rightFrozenStyle : table.theme.bodyStyle, {
        col: col,
        row: row,
        table: table,
        value: table.getCellValue(col, row),
        dataValue: table.getCellOriginValue(col, row),
        cellHeaderPaths: table.getCellHeaderPaths(col, row)
    }, styleClass, table.options.autoWrapText, table.theme), bgColorFunc && (cacheStyle = (0, 
    custom_cell_style_1.mergeStyle)(cacheStyle, {
        bgColor: bgColorFunc
    })), (0, vutils_1.isFunction)(style) || (layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.set(cacheKey, cacheStyle) : table.bodyStyleCache.set(cacheKey, cacheStyle)), 
    customCellStyle ? (0, custom_cell_style_1.mergeStyle)(cacheStyle, customCellStyle) : cacheStyle;
}

exports.getCellStyle = getCellStyle;
//# sourceMappingURL=style-helper.js.map