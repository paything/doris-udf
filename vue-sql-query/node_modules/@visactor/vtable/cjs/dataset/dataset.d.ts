import type { FilterRules, IPivotTableDataConfig, SortRule, AggregationRules, SortRules, DerivedFieldRules, Totals, MappingRules, IHeaderTreeDefine, CollectValueBy, CollectedValue, IIndicator, IPivotChartDataConfig, CalculateddFieldRules, SortType } from '../ts-types';
import type { Aggregator, IAggregator } from '../ts-types/dataset/aggregation';
export declare class Dataset {
    dataConfig?: IPivotTableDataConfig | IPivotChartDataConfig;
    records?: any[] | Record<string, any[]>;
    filteredRecords?: any[] | Record<string, any[]>;
    tree: Record<string, Record<string, Aggregator[]>>;
    changedTree: Record<string, Record<string, any[]>>;
    private colFlatKeys;
    private rowFlatKeys;
    colKeys: string[][];
    rowKeys: string[][];
    colKeys_normal: string[][];
    rowKeys_normal: string[][];
    rowOrder: string;
    colOrder: string;
    sorted: boolean;
    sortRules?: SortRules;
    filterRules?: FilterRules;
    aggregationRules?: AggregationRules;
    derivedFieldRules?: DerivedFieldRules;
    mappingRules?: MappingRules;
    calculatedFieldRules?: CalculateddFieldRules;
    calculatedFiledKeys?: string[];
    calculatedFieldDependIndicatorKeys?: string[];
    totals?: Totals;
    indicatorStatistics: {
        max: Aggregator;
        min: Aggregator;
        total: Aggregator;
    }[];
    stringJoinChar: string;
    private rowsIsTotal;
    private colsIsTotal;
    private colGrandTotalLabel;
    private colSubTotalLabel;
    private rowGrandTotalLabel;
    private rowSubTotalLabel;
    private needSplitPositiveAndNegative?;
    collectValuesBy?: Record<string, CollectValueBy>;
    collectedValues: Record<string, Record<string, CollectedValue>>;
    cacheCollectedValues: Record<string, Record<string, CollectedValue>>;
    rows: string[];
    rowsHasValue: boolean[];
    columns: string[];
    columnsHasValue: boolean[];
    indicatorKeys: string[];
    indicatorKeysIncludeCalculatedFieldDependIndicatorKeys: string[];
    customRowTree?: IHeaderTreeDefine[];
    customColTree?: IHeaderTreeDefine[];
    customRowTreeDimensionPaths: {
        dimensionKey?: string | number;
        value: string;
        indicatorKey?: string | number;
        isVirtual?: boolean;
        childKeys?: (string | number)[];
    }[][];
    customColTreeDimensionPaths: {
        dimensionKey?: string | number;
        value: string;
        indicatorKey?: string | number;
        isVirtual?: boolean;
    }[][];
    colHeaderTree: any[];
    rowHeaderTree: any[];
    rowHierarchyType: 'grid' | 'tree' | 'grid-tree';
    columnHierarchyType: 'grid' | 'grid-tree';
    indicators?: (string | IIndicator)[];
    indicatorsAsCol: boolean;
    totalRecordsTree: Record<string, Record<string, Aggregator[]>>;
    hasExtensionRowTree?: boolean;
    parseCustomTreeToMatchRecords?: boolean;
    constructor(dataConfig: IPivotTableDataConfig | IPivotChartDataConfig | undefined, rows: string[], columns: string[], indicatorKeys: string[], indicators: (string | IIndicator)[] | undefined, indicatorsAsCol: boolean, records: any[] | Record<string, any[]> | undefined, rowHierarchyType?: 'grid' | 'tree' | 'grid-tree', columnHierarchyType?: 'grid' | 'grid-tree', customColTree?: IHeaderTreeDefine[], customRowTree?: IHeaderTreeDefine[], needSplitPositiveAndNegative?: boolean, hasExtensionRowTree?: boolean, parseCustomTreeToMatchRecords?: boolean);
    setRecords(records: any[] | Record<string, any[]>): void;
    registerAggregator(type: string, aggregator: any): void;
    registerAggregators(): void;
    private processCollectedValuesWithSumBy;
    private processCollectedValuesWithSortBy;
    private generateCollectedValuesSortRule;
    private processRecords;
    private filterRecord;
    private processRecord;
    updateSortRules(sortRules: SortRules): void;
    updateFilterRules(filterRules: FilterRules, isResetTree?: boolean): void;
    private getAggregatorRule;
    getAggregator(rowKey: string[] | string, colKey: string[] | string, indicator: string, considerChangedValue?: boolean, indicatorPosition?: {
        position: 'col' | 'row';
        index?: number;
    }): IAggregator;
    sortKeys(): void;
    arrSort(fieldArr: string[], isRow: boolean): (a: string[], b: string[]) => any;
    getSort(sortRule: SortRule, isSortRow: boolean): (a: string[], b: string[], sortType?: SortType) => number;
    totalStatistics(): void;
    private ArrToTree1;
    private ArrToTree;
    private cacheDeminsionCollectedValues;
    changeTreeNodeValue(rowKey: string[] | string, colKey: string[] | string, indicator: string, newValue: string | number): void;
    changeRecordFieldValue(fieldName: string, oldValue: string | number, value: string | number): void;
    _rowTreeHasChanged(): void;
    changeDataConfig(dataConfig: {
        rows: string[];
        columns: string[];
    }): void;
    addRecords(records: any[]): void;
    private customTreeToDimensionPathArr;
    private getFieldMatchColDimensionPaths;
    private getFieldMatchRowDimensionPaths;
}
