import type { FilterRules, IPivotTableDataConfig, SortRule, AggregationRules, SortRules, DerivedFieldRules, Totals, MappingRules, IHeaderTreeDefine } from '../ts-types';
import { SortType } from '../ts-types';
import type { Aggregator } from '../ts-types/dataset/aggregation';
export declare class DatasetForPivotTable {
    dataConfig: IPivotTableDataConfig;
    records: any[];
    tree: Record<string, Record<string, Aggregator[]>>;
    private colFlatKeys;
    private rowFlatKeys;
    colKeys: string[][];
    rowKeys: string[][];
    rowKeysPath: string[][];
    colKeysPath: string[][];
    rowOrder: string;
    colOrder: string;
    sorted: boolean;
    sortRules: SortRules;
    filterRules: FilterRules;
    aggregationRules: AggregationRules;
    derivedFieldRules: DerivedFieldRules;
    mappingRules: MappingRules;
    totals: Totals;
    indicatorStatistics: {
        max: Aggregator;
        min: Aggregator;
        total: Aggregator;
    }[];
    aggregators: {
        [key: string]: {
            new (dimension: string | string[], formatFun?: any, isRecord?: boolean): Aggregator;
        };
    };
    stringJoinChar: string;
    private rowsIsTotal;
    private colsIsTotal;
    private colGrandTotalLabel;
    private colSubTotalLabel;
    private rowGrandTotalLabel;
    private rowSubTotalLabel;
    rows: string[];
    columns: string[];
    indicatorKeys: string[];
    constructor(dataConfig: IPivotTableDataConfig, rows: string[], columns: string[], indicators: string[], records: any[], customColTree?: IHeaderTreeDefine[], customRowTree?: IHeaderTreeDefine[]);
    registerAggregator(type: string, aggregator: any): void;
    registerAggregators(): void;
    setRecords(records: any[]): void;
    processRecords(): void;
    filterRecord(record: any): boolean;
    processRecord(record: any): void;
    updateSortRules(sortRules: SortRules): void;
    private getAggregatorRule;
    getAggregator(rowKey: string[] | string, colKey: string[] | string, indicator: string): Aggregator;
    sortKeys(): void;
    arrSort(fieldArr: string[], isRow: boolean): (a: string[], b: string[]) => number;
    getSort(sortRule: SortRule, isSortRow: boolean): (a: string[], b: string[], sortType?: SortType) => number;
    totalStatistics(): void;
    private ArrToTree;
    private TreeToArr;
    private TreeToArr2;
}
