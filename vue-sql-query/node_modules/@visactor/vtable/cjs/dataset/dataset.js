"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Dataset = void 0;

const vutils_1 = require("@visactor/vutils"), ts_types_1 = require("../ts-types"), aggregation_1 = require("../ts-types/dataset/aggregation"), global_1 = require("../tools/global"), join_1 = require("../tools/join");

class Dataset {
    constructor(dataConfig, rows, columns, indicatorKeys, indicators, indicatorsAsCol, records, rowHierarchyType, columnHierarchyType, customColTree, customRowTree, needSplitPositiveAndNegative, hasExtensionRowTree, parseCustomTreeToMatchRecords) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13;
        this.tree = {}, this.changedTree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, 
        this.colKeys = [], this.rowKeys = [], this.colKeys_normal = [], this.rowKeys_normal = [], 
        this.rowOrder = "key_a_to_z", this.colOrder = "key_a_to_z", this.sorted = !1, this.indicatorStatistics = [], 
        this.stringJoinChar = String.fromCharCode(0), this.rowsIsTotal = [], this.colsIsTotal = [], 
        this.collectedValues = {}, this.cacheCollectedValues = {}, this.totalRecordsTree = {}, 
        this.registerAggregators(), this.dataConfig = dataConfig, this.filterRules = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.filterRules, 
        this.rowHierarchyType = null != rowHierarchyType ? rowHierarchyType : "grid", this.columnHierarchyType = null != columnHierarchyType ? columnHierarchyType : "grid", 
        this.sortRules = null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.sortRules, 
        this.aggregationRules = null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.aggregationRules, 
        this.derivedFieldRules = null === (_d = this.dataConfig) || void 0 === _d ? void 0 : _d.derivedFieldRules, 
        this.mappingRules = null === (_e = this.dataConfig) || void 0 === _e ? void 0 : _e.mappingRules, 
        this.calculatedFieldRules = null === (_f = this.dataConfig) || void 0 === _f ? void 0 : _f.calculatedFieldRules, 
        this.calculatedFiledKeys = null !== (_h = null === (_g = this.calculatedFieldRules) || void 0 === _g ? void 0 : _g.map((rule => rule.key))) && void 0 !== _h ? _h : [], 
        this.calculatedFieldDependIndicatorKeys = null !== (_k = null === (_j = this.calculatedFieldRules) || void 0 === _j ? void 0 : _j.reduce(((arr, rule) => {
            for (let i = 0; i < rule.dependIndicatorKeys.length; i++) -1 === arr.indexOf(rule.dependIndicatorKeys[i]) && arr.push(rule.dependIndicatorKeys[i]);
            return arr;
        }), [])) && void 0 !== _k ? _k : [], this.totals = null === (_l = this.dataConfig) || void 0 === _l ? void 0 : _l.totals, 
        this.rows = rows, this.columns = columns, this.indicatorKeys = indicatorKeys, this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys = [ ...indicatorKeys ];
        for (let m = 0; m < this.calculatedFieldDependIndicatorKeys.length; m++) -1 === this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.indexOf(this.calculatedFieldDependIndicatorKeys[m]) && this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.push(this.calculatedFieldDependIndicatorKeys[m]);
        if (this.indicatorsAsCol = indicatorsAsCol, this.indicators = indicators, this.customColTree = customColTree, 
        this.customRowTree = customRowTree, this.hasExtensionRowTree = hasExtensionRowTree, 
        this.parseCustomTreeToMatchRecords = parseCustomTreeToMatchRecords, this.parseCustomTreeToMatchRecords && (this.customColTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customColTree, "col"), 
        this.hasExtensionRowTree || (this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, "row"))), 
        this.colGrandTotalLabel = null !== (_p = null === (_o = null === (_m = this.totals) || void 0 === _m ? void 0 : _m.column) || void 0 === _o ? void 0 : _o.grandTotalLabel) && void 0 !== _p ? _p : "总计", 
        this.colSubTotalLabel = null !== (_s = null === (_r = null === (_q = this.totals) || void 0 === _q ? void 0 : _q.column) || void 0 === _r ? void 0 : _r.subTotalLabel) && void 0 !== _s ? _s : "小计", 
        this.rowGrandTotalLabel = null !== (_v = null === (_u = null === (_t = this.totals) || void 0 === _t ? void 0 : _t.row) || void 0 === _u ? void 0 : _u.grandTotalLabel) && void 0 !== _v ? _v : "总计", 
        this.rowSubTotalLabel = null !== (_y = null === (_x = null === (_w = this.totals) || void 0 === _w ? void 0 : _w.row) || void 0 === _x ? void 0 : _x.subTotalLabel) && void 0 !== _y ? _y : "小计", 
        this.collectValuesBy = null === (_z = this.dataConfig) || void 0 === _z ? void 0 : _z.collectValuesBy, 
        this.needSplitPositiveAndNegative = null != needSplitPositiveAndNegative && needSplitPositiveAndNegative, 
        this.rowsIsTotal = new Array(null !== (_1 = null === (_0 = this.rows) || void 0 === _0 ? void 0 : _0.length) && void 0 !== _1 ? _1 : 0).fill(!1), 
        this.colsIsTotal = new Array(null !== (_3 = null === (_2 = this.columns) || void 0 === _2 ? void 0 : _2.length) && void 0 !== _3 ? _3 : 0).fill(!1), 
        (null === (_4 = this.totals) || void 0 === _4 ? void 0 : _4.row) && !1 !== this.totals.row.showSubTotals && this.totals.row.subTotalsDimensions) for (let i = 0, len = null !== (_8 = null === (_7 = null === (_6 = null === (_5 = this.totals) || void 0 === _5 ? void 0 : _5.row) || void 0 === _6 ? void 0 : _6.subTotalsDimensions) || void 0 === _7 ? void 0 : _7.length) && void 0 !== _8 ? _8 : 0; i < len; i++) {
            const dimension = this.totals.row.subTotalsDimensions[i], dimensionIndex = this.rows.indexOf(dimension);
            this.rowsIsTotal[dimensionIndex] = !0;
        }
        if ((null === (_9 = this.totals) || void 0 === _9 ? void 0 : _9.column) && !1 !== this.totals.column.showSubTotals && this.totals.column.subTotalsDimensions) for (let i = 0, len = null !== (_13 = null === (_12 = null === (_11 = null === (_10 = this.totals) || void 0 === _10 ? void 0 : _10.column) || void 0 === _11 ? void 0 : _11.subTotalsDimensions) || void 0 === _12 ? void 0 : _12.length) && void 0 !== _13 ? _13 : 0; i < len; i++) {
            const dimension = this.totals.column.subTotalsDimensions[i], dimensionIndex = this.columns.indexOf(dimension);
            this.colsIsTotal[dimensionIndex] = !0;
        }
        this.setRecords(records);
    }
    setRecords(records) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        if (this.records = records, this.collectedValues = {}, this.cacheCollectedValues = {}, 
        this.totalRecordsTree = {}, this.tree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, 
        this.colKeys = [], this.rowKeys = [], this.rowsHasValue = [], this.columnsHasValue = [], 
        this.sorted = !1, records) {
            this.records = records;
            "undefined" != typeof window && window.performance.now();
            this.processRecords(), this.processCollectedValuesWithSumBy(), this.generateCollectedValuesSortRule(), 
            this.processCollectedValuesWithSortBy();
            "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
            this.totalStatistics();
            "undefined" != typeof window && window.performance.now();
            this.rowKeys_normal = this.rowKeys.slice(), this.colKeys_normal = this.colKeys.slice();
            "undefined" != typeof window && window.performance.now();
            this.sortKeys();
            "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
            this.customRowTree ? this.rowHeaderTree = this.customRowTree : "tree" === this.rowHierarchyType ? this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter(((key, index) => this.rowsHasValue[index])), this.indicatorsAsCol ? void 0 : this.indicators, (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, null !== (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.showGrandTotalsOnTop) && void 0 !== _e && _e) : this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter(((key, index) => this.rowsHasValue[index])), this.indicatorsAsCol ? void 0 : this.indicators, this.rowsIsTotal, (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, this.rowSubTotalLabel, null !== (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.showGrandTotalsOnTop) && void 0 !== _k && _k, null !== (_o = null === (_m = null === (_l = this.totals) || void 0 === _l ? void 0 : _l.row) || void 0 === _m ? void 0 : _m.showSubTotalsOnTop) && void 0 !== _o && _o), 
            this.customColTree ? this.colHeaderTree = this.customColTree : this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter(((key, index) => this.columnsHasValue[index])), this.indicatorsAsCol ? this.indicators : void 0, this.colsIsTotal, (null === (_q = null === (_p = this.totals) || void 0 === _p ? void 0 : _p.column) || void 0 === _q ? void 0 : _q.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length, this.colGrandTotalLabel, this.colSubTotalLabel, null !== (_t = null === (_s = null === (_r = this.totals) || void 0 === _r ? void 0 : _r.column) || void 0 === _s ? void 0 : _s.showGrandTotalsOnLeft) && void 0 !== _t && _t, null !== (_w = null === (_v = null === (_u = this.totals) || void 0 === _u ? void 0 : _u.column) || void 0 === _v ? void 0 : _v.showSubTotalsOnLeft) && void 0 !== _w && _w);
            "undefined" != typeof window && window.performance.now();
            (null === (_x = this.dataConfig) || void 0 === _x ? void 0 : _x.isPivotChart) && this.cacheDeminsionCollectedValues();
        }
    }
    registerAggregator(type, aggregator) {
        aggregation_1.registeredAggregators[type] = aggregator;
    }
    registerAggregators() {
        this.registerAggregator(ts_types_1.AggregationType.RECORD, aggregation_1.RecordAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.SUM, aggregation_1.SumAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.COUNT, aggregation_1.CountAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.MAX, aggregation_1.MaxAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.MIN, aggregation_1.MinAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.AVG, aggregation_1.AvgAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.NONE, aggregation_1.NoneAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.RECALCULATE, aggregation_1.RecalculateAggregator), 
        this.registerAggregator(ts_types_1.AggregationType.CUSTOM, aggregation_1.CustomAggregator);
    }
    processCollectedValuesWithSumBy() {
        var _a, _b, _c, _d, _e, _f;
        for (const field in this.collectedValues) if (null === (_b = null === (_a = this.collectValuesBy) || void 0 === _a ? void 0 : _a[field]) || void 0 === _b ? void 0 : _b.sumBy) for (const byKeys in this.collectedValues[field]) {
            let max;
            "sum" === (null === (_c = this.collectValuesBy[field]) || void 0 === _c ? void 0 : _c.extendRange) ? (max = Object.values(this.collectedValues[field][byKeys]).reduce(((acc, cur) => acc + cur.value()), 0), 
            max += Math.round(max / 20)) : (max = Object.values(this.collectedValues[field][byKeys]).reduce(((acc, cur) => cur.value() > acc ? cur.value() : acc), Number.MIN_SAFE_INTEGER), 
            "max" === (null === (_d = this.collectValuesBy[field]) || void 0 === _d ? void 0 : _d.extendRange) ? max += Math.round(max / 20) : "number" == typeof (null === (_e = this.collectValuesBy[field]) || void 0 === _e ? void 0 : _e.extendRange) && (max = Math.max(max, null === (_f = this.collectValuesBy[field]) || void 0 === _f ? void 0 : _f.extendRange)));
            const min = Object.values(this.collectedValues[field][byKeys]).reduce(((acc, cur) => cur.value() < acc ? cur.value() : acc), Number.MAX_SAFE_INTEGER);
            let positiveMax, negativeMin;
            this.needSplitPositiveAndNegative && (positiveMax = Object.values(this.collectedValues[field][byKeys]).reduce(((acc, cur) => cur.positiveValue() > acc ? cur.positiveValue() : acc), Number.MIN_SAFE_INTEGER), 
            negativeMin = Object.values(this.collectedValues[field][byKeys]).reduce(((acc, cur) => cur.negativeValue() < acc ? cur.negativeValue() : acc), Number.MAX_SAFE_INTEGER)), 
            this.collectedValues[field][byKeys] = {}, this.collectedValues[field][byKeys].max = max, 
            this.collectedValues[field][byKeys].min = min, this.needSplitPositiveAndNegative && (this.collectedValues[field][byKeys].positiveMax = positiveMax, 
            this.collectedValues[field][byKeys].negativeMin = negativeMin);
        }
    }
    processCollectedValuesWithSortBy() {
        var _a, _b;
        const that = this;
        for (const field in this.collectedValues) if (null === (_b = null === (_a = this.collectValuesBy) || void 0 === _a ? void 0 : _a[field]) || void 0 === _b ? void 0 : _b.sortBy) for (const byKeys in this.collectedValues[field]) this.collectedValues[field][byKeys] = this.collectedValues[field][byKeys].sort(((a, b) => {
            var _a, _b, _c, _d;
            return (null !== (_b = null === (_a = that.collectValuesBy[field].sortBy) || void 0 === _a ? void 0 : _a.indexOf(a)) && void 0 !== _b ? _b : -1) - (null !== (_d = null === (_c = that.collectValuesBy[field].sortBy) || void 0 === _c ? void 0 : _c.indexOf(b)) && void 0 !== _d ? _d : -1);
        }));
    }
    generateCollectedValuesSortRule() {
        for (const field in this.collectedValues) if (this.collectValuesBy && this.collectValuesBy[field] && !this.collectValuesBy[field].sortBy) {
            let sortByRule = [];
            for (const byKeys in this.collectedValues[field]) Array.isArray(this.collectedValues[field][byKeys]) && (sortByRule.push(...this.collectedValues[field][byKeys]), 
            sortByRule = Array.from(new Set(sortByRule)));
            sortByRule.length > 0 && (this.collectValuesBy[field].sortBy = sortByRule);
        }
    }
    processRecords() {
        var _a, _b;
        let isNeedFilter = !1;
        if ((null !== (_b = null === (_a = this.filterRules) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0) >= 1 && (isNeedFilter = !0), 
        Array.isArray(this.records)) {
            this.filteredRecords || (this.filteredRecords = []);
            for (let i = 0, len = this.records.length; i < len; i++) {
                const record = this.records[i];
                isNeedFilter && !this.filterRecord(record) || (this.filteredRecords.push(record), 
                this.processRecord(record));
            }
        } else {
            this.filteredRecords || (this.filteredRecords = {});
            for (const key in this.records) for (let i = 0, len = this.records[key].length; i < len; i++) {
                const record = this.records[key][i];
                isNeedFilter && !this.filterRecord(record) || (this.filteredRecords[key] || (this.filteredRecords[key] = []), 
                this.filteredRecords[key].push(record), this.processRecord(record, key));
            }
        }
        this.rowFlatKeys = {}, this.colFlatKeys = {};
    }
    filterRecord(record) {
        var _a, _b;
        let isReserved = !0;
        if (this.filterRules) for (let i = 0; i < this.filterRules.length; i++) {
            const filterRule = this.filterRules[i];
            if (filterRule.filterKey) {
                const filterValue = record[filterRule.filterKey];
                if (-1 === (null === (_a = filterRule.filteredValues) || void 0 === _a ? void 0 : _a.indexOf(filterValue))) {
                    isReserved = !1;
                    break;
                }
            } else if (!(null === (_b = filterRule.filterFunc) || void 0 === _b ? void 0 : _b.call(filterRule, record))) {
                isReserved = !1;
                break;
            }
        }
        return isReserved;
    }
    processRecord(record, assignedIndicatorKey) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41;
        null === (_a = this.derivedFieldRules) || void 0 === _a || _a.forEach(((derivedFieldRule, i) => {
            derivedFieldRule.fieldName && derivedFieldRule.derivedFunc && (record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record));
        }));
        for (const field in this.collectValuesBy) if ((0, vutils_1.isValid)(record[field])) {
            this.collectedValues[field] || (this.collectedValues[field] = {});
            const collectKeys = this.collectValuesBy[field].by.map((byField => record[byField])).join(this.stringJoinChar);
            if (this.collectedValues[field][collectKeys] || (this.collectValuesBy[field].sumBy ? this.collectedValues[field][collectKeys] = {} : this.collectValuesBy[field].range ? this.collectedValues[field][collectKeys] = {
                min: Number.MAX_SAFE_INTEGER,
                max: Number.MIN_SAFE_INTEGER
            } : this.collectedValues[field][collectKeys] = []), this.collectValuesBy[field].sumBy) {
                const sumByKeys = null === (_b = this.collectValuesBy[field].sumBy) || void 0 === _b ? void 0 : _b.map((byField => record[byField])).join(this.stringJoinChar);
                this.collectedValues[field][collectKeys][sumByKeys] || (this.collectedValues[field][collectKeys][sumByKeys] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.SUM]({
                    key: field,
                    field: field,
                    isRecord: void 0,
                    needSplitPositiveAndNegative: this.needSplitPositiveAndNegative
                })), this.collectedValues[field][collectKeys][sumByKeys].push(record);
            } else if (this.collectValuesBy[field].range) {
                const fieldRange = this.collectedValues[field][collectKeys], max = Math.max(record[field], fieldRange.max), min = Math.min(record[field], fieldRange.min);
                isNaN(max) || (fieldRange.max = max, fieldRange.min = min);
            } else {
                const fieldRange = this.collectedValues[field][collectKeys];
                -1 === fieldRange.indexOf(record[field]) && fieldRange.push(record[field]);
            }
        }
        let isToTalRecord = !1;
        const colKeys = [], rowKeys = [];
        if (!this.parseCustomTreeToMatchRecords || (null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.isPivotChart) || !(null === (_d = this.customRowTree) || void 0 === _d ? void 0 : _d.length) || assignedIndicatorKey || this.hasExtensionRowTree) {
            const rowKey = [];
            rowKeys.push({
                rowKey: rowKey,
                indicatorKey: assignedIndicatorKey
            });
            for (let l = 0, len1 = this.rows.length; l < len1; l++) {
                const rowAttr = this.rows[l];
                if (rowAttr in record) this.rowsHasValue[l] = !0, rowKey.push(record[rowAttr]); else if (rowAttr !== global_1.IndicatorDimensionKeyPlaceholder) {
                    if ((null === (_g = null === (_f = null === (_e = this.dataConfig) || void 0 === _e ? void 0 : _e.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) && 0 === l && !this.rows.find((rk => rk in record))) {
                        rowKey.push(this.rowGrandTotalLabel), isToTalRecord = !0;
                        break;
                    }
                    if ((null === (_k = null === (_j = null === (_h = this.dataConfig) || void 0 === _h ? void 0 : _h.totals) || void 0 === _j ? void 0 : _j.row) || void 0 === _k ? void 0 : _k.subTotalsDimensions) && (null === (_o = null === (_m = null === (_l = this.dataConfig) || void 0 === _l ? void 0 : _l.totals) || void 0 === _m ? void 0 : _m.row) || void 0 === _o ? void 0 : _o.subTotalsDimensions.indexOf(this.rows[l - 1])) >= 0) {
                        "tree" !== this.rowHierarchyType && rowKey.push(this.rowSubTotalLabel), isToTalRecord = !0;
                        break;
                    }
                }
            }
        } else {
            const rowTreePath = this.getFieldMatchRowDimensionPaths(record);
            if (rowTreePath.length > 0) for (let i = 0, len = rowTreePath.length; i < len; i++) {
                const rowPath = rowTreePath[i], rowKey = [];
                let indicatorKey;
                for (let j = 0, len1 = rowPath.length; j < len1; j++) (0, vutils_1.isValid)(rowPath[j].indicatorKey) ? indicatorKey = rowPath[j].indicatorKey : rowKey.push(rowPath[j].value);
                rowKeys.push({
                    rowKey: rowKey,
                    indicatorKey: indicatorKey
                });
            }
        }
        if (!this.parseCustomTreeToMatchRecords || (null === (_p = this.dataConfig) || void 0 === _p ? void 0 : _p.isPivotChart) || !(null === (_q = this.customColTree) || void 0 === _q ? void 0 : _q.length) || assignedIndicatorKey || this.hasExtensionRowTree) {
            const colKey = [];
            colKeys.push({
                colKey: colKey,
                indicatorKey: assignedIndicatorKey
            });
            for (let n = 0, len2 = this.columns.length; n < len2; n++) {
                const colAttr = this.columns[n];
                if (colAttr in record) this.columnsHasValue[n] = !0, colKey.push(record[colAttr]); else if (colAttr !== global_1.IndicatorDimensionKeyPlaceholder) {
                    if ((null === (_t = null === (_s = null === (_r = this.dataConfig) || void 0 === _r ? void 0 : _r.totals) || void 0 === _s ? void 0 : _s.column) || void 0 === _t ? void 0 : _t.showGrandTotals) && 0 === n && !this.columns.find((ck => ck in record))) {
                        colKey.push(this.colGrandTotalLabel), isToTalRecord = !0;
                        break;
                    }
                    if ((null === (_w = null === (_v = null === (_u = this.dataConfig) || void 0 === _u ? void 0 : _u.totals) || void 0 === _v ? void 0 : _v.column) || void 0 === _w ? void 0 : _w.subTotalsDimensions) && (null === (_z = null === (_y = null === (_x = this.dataConfig) || void 0 === _x ? void 0 : _x.totals) || void 0 === _y ? void 0 : _y.column) || void 0 === _z ? void 0 : _z.subTotalsDimensions.indexOf(this.columns[n - 1])) >= 0) {
                        colKey.push(this.colSubTotalLabel), isToTalRecord = !0;
                        break;
                    }
                }
            }
        } else {
            const colTreePath = this.getFieldMatchColDimensionPaths(record);
            if (colTreePath.length > 0) for (let i = 0, len = colTreePath.length; i < len; i++) {
                const colPath = colTreePath[i], colKey = [];
                let indicatorKey;
                for (let j = 0, len1 = colPath.length; j < len1; j++) (0, vutils_1.isValid)(colPath[j].indicatorKey) ? indicatorKey = colPath[j].indicatorKey : colKey.push(colPath[j].value);
                colKeys.push({
                    colKey: colKey,
                    indicatorKey: indicatorKey
                });
            }
        }
        for (let row_i = 0; row_i < rowKeys.length; row_i++) {
            const rowKey = rowKeys[row_i].rowKey;
            let assignedIndicatorKey_value;
            this.indicatorsAsCol || (assignedIndicatorKey_value = rowKeys[row_i].indicatorKey);
            for (let col_j = 0; col_j < colKeys.length; col_j++) {
                const colKey = colKeys[col_j].colKey;
                this.indicatorsAsCol && (assignedIndicatorKey_value = colKeys[col_j].indicatorKey);
                const flatRowKey = rowKey.join(this.stringJoinChar), flatColKey = colKey.join(this.stringJoinChar);
                if (isToTalRecord) {
                    this.totalRecordsTree[flatRowKey] || (this.totalRecordsTree[flatRowKey] = {}), this.totalRecordsTree[flatRowKey][flatColKey] || (this.totalRecordsTree[flatRowKey][flatColKey] = []);
                    const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                    for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                        const calculatedFieldRule = null === (_0 = this.calculatedFieldRules) || void 0 === _0 ? void 0 : _0.find((rule => rule.key === toComputeIndicatorKeys[i]));
                        (null === (_2 = null === (_1 = this.totalRecordsTree[flatRowKey]) || void 0 === _1 ? void 0 : _1[flatColKey]) || void 0 === _2 ? void 0 : _2[i]) || (this.totalRecordsTree[flatRowKey][flatColKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                            key: toComputeIndicatorKeys[i],
                            field: toComputeIndicatorKeys[i],
                            isRecord: !0,
                            formatFun: null === (_4 = null === (_3 = this.indicators) || void 0 === _3 ? void 0 : _3.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _4 ? void 0 : _4.format,
                            calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                            dependAggregators: this.totalRecordsTree[flatRowKey][flatColKey],
                            dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                        })), toComputeIndicatorKeys[i] in record && (null === (_6 = null === (_5 = this.totalRecordsTree[flatRowKey]) || void 0 === _5 ? void 0 : _5[flatColKey]) || void 0 === _6 || _6[i].push(record));
                    } else {
                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                        (null === (_8 = null === (_7 = this.totalRecordsTree[flatRowKey]) || void 0 === _7 ? void 0 : _7[flatColKey]) || void 0 === _8 ? void 0 : _8[i]) || (this.totalRecordsTree[flatRowKey][flatColKey][i] = new aggregation_1.registeredAggregators[null !== (_9 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _9 ? _9 : ts_types_1.AggregationType.SUM]({
                            key: toComputeIndicatorKeys[i],
                            field: null !== (_10 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _10 ? _10 : toComputeIndicatorKeys[i],
                            aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                            formatFun: null !== (_11 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _11 ? _11 : null === (_13 = null === (_12 = this.indicators) || void 0 === _12 ? void 0 : _12.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _13 ? void 0 : _13.format
                        })), toComputeIndicatorKeys[i] in record && (null === (_15 = null === (_14 = this.totalRecordsTree[flatRowKey]) || void 0 === _14 ? void 0 : _14[flatColKey]) || void 0 === _15 || _15[i].push(record));
                    }
                    return;
                }
                0 !== rowKey.length && (this.rowFlatKeys[flatRowKey] || (this.rowKeys.push(rowKey), 
                this.rowFlatKeys[flatRowKey] = 1)), 0 !== colKey.length && (this.colFlatKeys[flatColKey] || (this.colKeys.push(colKey), 
                this.colFlatKeys[flatColKey] = 1)), this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), 
                (null === (_16 = this.tree[flatRowKey]) || void 0 === _16 ? void 0 : _16[flatColKey]) || (this.tree[flatRowKey][flatColKey] = []);
                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                    const calculatedFieldRule = null === (_17 = this.calculatedFieldRules) || void 0 === _17 ? void 0 : _17.find((rule => rule.key === toComputeIndicatorKeys[i]));
                    (null === (_19 = null === (_18 = this.tree[flatRowKey]) || void 0 === _18 ? void 0 : _18[flatColKey]) || void 0 === _19 ? void 0 : _19[i]) || (this.tree[flatRowKey][flatColKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                        key: toComputeIndicatorKeys[i],
                        field: toComputeIndicatorKeys[i],
                        isRecord: !0,
                        formatFun: null === (_21 = null === (_20 = this.indicators) || void 0 === _20 ? void 0 : _20.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _21 ? void 0 : _21.format,
                        calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                        dependAggregators: this.tree[flatRowKey][flatColKey],
                        dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                    })), null === (_23 = null === (_22 = this.tree[flatRowKey]) || void 0 === _22 ? void 0 : _22[flatColKey]) || void 0 === _23 || _23[i].push(record);
                } else {
                    const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                    let needAddToAggregator = !1;
                    if (assignedIndicatorKey_value) assignedIndicatorKey === assignedIndicatorKey_value ? toComputeIndicatorKeys[i] === assignedIndicatorKey_value && (needAddToAggregator = !0) : toComputeIndicatorKeys[i] === assignedIndicatorKey_value && toComputeIndicatorKeys[i] in record && (needAddToAggregator = !0); else if (null == aggRule ? void 0 : aggRule.field) if ("string" == typeof (null == aggRule ? void 0 : aggRule.field)) (null == aggRule ? void 0 : aggRule.field) in record && (needAddToAggregator = !0); else {
                        (null == aggRule ? void 0 : aggRule.field.find((field => field in record))) && (needAddToAggregator = !0);
                    } else toComputeIndicatorKeys[i] in record && (needAddToAggregator = !0);
                    !(null === (_25 = null === (_24 = this.tree[flatRowKey]) || void 0 === _24 ? void 0 : _24[flatColKey]) || void 0 === _25 ? void 0 : _25[i]) && needAddToAggregator && (this.tree[flatRowKey][flatColKey][i] = new aggregation_1.registeredAggregators[null !== (_26 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _26 ? _26 : ts_types_1.AggregationType.SUM]({
                        key: toComputeIndicatorKeys[i],
                        field: null !== (_27 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _27 ? _27 : toComputeIndicatorKeys[i],
                        aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                        formatFun: null !== (_28 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _28 ? _28 : null === (_30 = null === (_29 = this.indicators) || void 0 === _29 ? void 0 : _29.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _30 ? void 0 : _30.format
                    })), needAddToAggregator && (null === (_32 = null === (_31 = this.tree[flatRowKey]) || void 0 === _31 ? void 0 : _31[flatColKey]) || void 0 === _32 || _32[i].push(record));
                }
                if (this.mappingRules) for (let i = 0; i < this.indicatorKeys.length; i++) {
                    if (!this.indicatorStatistics[i]) {
                        const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                        this.indicatorStatistics[i] = {
                            max: new aggregation_1.registeredAggregators[ts_types_1.AggregationType.MAX]({
                                key: this.indicatorKeys[i],
                                field: this.indicatorKeys[i]
                            }),
                            min: new aggregation_1.registeredAggregators[ts_types_1.AggregationType.MIN]({
                                key: this.indicatorKeys[i],
                                field: this.indicatorKeys[i]
                            }),
                            total: new aggregation_1.registeredAggregators[null !== (_33 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _33 ? _33 : ts_types_1.AggregationType.SUM]({
                                key: this.indicatorKeys[i],
                                field: null !== (_34 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _34 ? _34 : this.indicatorKeys[i],
                                aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                                formatFun: null !== (_35 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _35 ? _35 : null === (_37 = null === (_36 = this.indicators) || void 0 === _36 ? void 0 : _36.find((indicator => "string" != typeof indicator && indicator.indicatorKey === this.indicatorKeys[i]))) || void 0 === _37 ? void 0 : _37.format
                            })
                        };
                    }
                    this.indicatorStatistics[i].max.push(null === (_39 = null === (_38 = this.tree[flatRowKey]) || void 0 === _38 ? void 0 : _38[flatColKey]) || void 0 === _39 ? void 0 : _39[i].value()), 
                    this.indicatorStatistics[i].min.push(null === (_41 = null === (_40 = this.tree[flatRowKey]) || void 0 === _40 ? void 0 : _40[flatColKey]) || void 0 === _41 ? void 0 : _41[i].value()), 
                    this.indicatorStatistics[i].total.push(record);
                }
            }
        }
    }
    updateSortRules(sortRules) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        this.sorted = !1, this.sortRules = sortRules, this.sortKeys(), this.customRowTree || ("tree" === this.rowHierarchyType ? this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter(((key, index) => this.rowsHasValue[index])), this.indicatorsAsCol ? void 0 : this.indicators, (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, null !== (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.showGrandTotalsOnTop) && void 0 !== _e && _e) : this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter(((key, index) => this.rowsHasValue[index])), this.indicatorsAsCol ? void 0 : this.indicators, this.rowsIsTotal, (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showGrandTotals) || this.indicatorsAsCol && 0 === this.rows.length, this.rowGrandTotalLabel, this.rowSubTotalLabel, null !== (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.showGrandTotalsOnTop) && void 0 !== _k && _k, null !== (_o = null === (_m = null === (_l = this.totals) || void 0 === _l ? void 0 : _l.row) || void 0 === _m ? void 0 : _m.showSubTotalsOnTop) && void 0 !== _o && _o)), 
        this.customColTree || (this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter(((key, index) => this.columnsHasValue[index])), this.indicatorsAsCol ? this.indicators : void 0, this.colsIsTotal, (null === (_q = null === (_p = this.totals) || void 0 === _p ? void 0 : _p.column) || void 0 === _q ? void 0 : _q.showGrandTotals) || !this.indicatorsAsCol && 0 === this.columns.length, this.colGrandTotalLabel, this.colSubTotalLabel, null !== (_t = null === (_s = null === (_r = this.totals) || void 0 === _r ? void 0 : _r.column) || void 0 === _s ? void 0 : _s.showGrandTotalsOnLeft) && void 0 !== _t && _t, null !== (_w = null === (_v = null === (_u = this.totals) || void 0 === _u ? void 0 : _u.column) || void 0 === _v ? void 0 : _v.showSubTotalsOnLeft) && void 0 !== _w && _w));
    }
    updateFilterRules(filterRules, isResetTree = !1) {
        var _a, _b;
        if (this.filterRules = filterRules, this.filteredRecords = void 0, isResetTree) this.tree = {}; else for (const treeRowKey in this.tree) for (const treeColKey in this.tree[treeRowKey]) for (let i = 0; i < this.tree[treeRowKey][treeColKey].length; i++) null === (_a = this.tree[treeRowKey][treeColKey][i]) || void 0 === _a || _a.reset();
        this.collectedValues = {}, this.processRecords(), this.processCollectedValuesWithSumBy(), 
        this.processCollectedValuesWithSortBy(), this.totalStatistics(), (null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.isPivotChart) && this.cacheDeminsionCollectedValues();
    }
    getAggregatorRule(indicatorKey) {
        var _a;
        return null === (_a = this.aggregationRules) || void 0 === _a ? void 0 : _a.find(((value, index) => indicatorKey === value.indicatorKey));
    }
    getAggregator(rowKey = [], colKey = [], indicator, considerChangedValue = !0, indicatorPosition) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const indicatorIndex = this.indicatorKeys.indexOf(indicator);
        let flatRowKey, flatColKey;
        "string" == typeof rowKey ? flatRowKey = rowKey : (indicatorPosition && "row" !== indicatorPosition.position || rowKey.map(((key, i) => {
            key !== indicator || (0, vutils_1.isValid)(null == indicatorPosition ? void 0 : indicatorPosition.index) && i !== indicatorPosition.index || rowKey.splice(i, 1);
        })), rowKey.length < this.rows.length && "grid-tree" === this.rowHierarchyType && (rowKey[0] === this.rowGrandTotalLabel || (null === (_b = null === (_a = this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.subTotalsDimensions) && (null === (_e = null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) >= 1 && rowKey[rowKey.length - 1] !== this.rowSubTotalLabel && rowKey.push(this.rowSubTotalLabel)), 
        flatRowKey = (0, join_1.join)(rowKey, this.stringJoinChar)), "string" == typeof colKey ? flatColKey = colKey : (indicatorPosition && "col" !== indicatorPosition.position || colKey.map(((key, i) => {
            key !== indicator || (0, vutils_1.isValid)(null == indicatorPosition ? void 0 : indicatorPosition.index) && i !== indicatorPosition.index || colKey.splice(i, 1);
        })), colKey.length < this.columns.length && "grid-tree" === this.columnHierarchyType && (colKey[0] === this.colGrandTotalLabel || (null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.column) || void 0 === _g ? void 0 : _g.subTotalsDimensions) && (null === (_k = null === (_j = null === (_h = this.totals) || void 0 === _h ? void 0 : _h.column) || void 0 === _j ? void 0 : _j.subTotalsDimensions) || void 0 === _k ? void 0 : _k.length) >= 1 && colKey[colKey.length - 1] !== this.colSubTotalLabel && colKey.push(this.colSubTotalLabel)), 
        flatColKey = (0, join_1.join)(colKey, this.stringJoinChar));
        const agg = null === (_m = null === (_l = this.tree[flatRowKey]) || void 0 === _l ? void 0 : _l[flatColKey]) || void 0 === _m ? void 0 : _m[indicatorIndex];
        if (considerChangedValue && (0, vutils_1.isValid)(null === (_p = null === (_o = this.changedTree[flatRowKey]) || void 0 === _o ? void 0 : _o[flatColKey]) || void 0 === _p ? void 0 : _p[indicatorIndex])) {
            const changeValue = this.changedTree[flatRowKey][flatColKey][indicatorIndex];
            return agg ? {
                value: () => changeValue,
                formatValue: agg.formatValue,
                formatFun: agg.formatFun,
                records: agg.records,
                recalculate() {},
                push() {},
                deleteRecord() {},
                updateRecord() {},
                clearCacheValue() {},
                reset() {}
            } : {
                records: [],
                value: () => changeValue,
                push() {},
                deleteRecord() {},
                updateRecord() {},
                recalculate() {},
                formatValue: () => changeValue,
                clearCacheValue() {},
                reset() {}
            };
        }
        return agg || {
            records: [],
            push() {},
            deleteRecord() {},
            updateRecord() {},
            recalculate() {},
            value: () => null,
            clearCacheValue() {},
            reset() {}
        };
    }
    sortKeys() {
        this.colKeys = this.colKeys_normal.slice(), this.rowKeys = this.rowKeys_normal.slice();
        if (!this.sorted) {
            this.sorted = !0, this.rowKeys.sort(this.arrSort(this.rows, !0));
            const sortfun = this.arrSort(this.columns, !1);
            this.colKeys.sort(sortfun);
        }
    }
    arrSort(fieldArr, isRow) {
        let field;
        const that = this, sortersArr = function(_this) {
            const results = [];
            for (let l = 0, len1 = fieldArr.length; l < len1; l++) {
                field = fieldArr[l];
                let isHasSortRule = !1;
                if (that.sortRules) for (let m = 0, len2 = that.sortRules.length; m < len2; m++) that.sortRules[m].sortField === field && (isHasSortRule = !0, 
                results.push({
                    field: field,
                    fieldIndex: l,
                    sortRule: that.sortRules[m],
                    func: that.getSort(that.sortRules[m], isRow)
                }));
            }
            return results;
        }.call(this);
        return function(a, b) {
            var _a, _b, _c, _d;
            let comparison, sorter;
            for (let i = 0; i < sortersArr.length; i++) {
                if (sorter = sortersArr[i], null === (_a = sorter.sortRule) || void 0 === _a ? void 0 : _a.sortByIndicator) {
                    let aChanged = a, bChanged = b;
                    sorter.fieldIndex < fieldArr.length - 1 && (aChanged = a.slice(0, sorter.fieldIndex + 1), 
                    "grid" === that.rowHierarchyType && isRow ? aChanged.push(that.rowSubTotalLabel) : isRow || aChanged.push(that.colSubTotalLabel), 
                    bChanged = b.slice(0, sorter.fieldIndex + 1), "grid" === that.rowHierarchyType && isRow ? bChanged.push(that.rowSubTotalLabel) : isRow || bChanged.push(that.colSubTotalLabel)), 
                    comparison = sorter.func(aChanged, bChanged, null === (_b = sorter.sortRule) || void 0 === _b ? void 0 : _b.sortType);
                } else comparison = null === (_c = sorter.func) || void 0 === _c ? void 0 : _c.call(sorter, a[sorter.fieldIndex], b[sorter.fieldIndex], null === (_d = sorter.sortRule) || void 0 === _d ? void 0 : _d.sortType);
                if (0 !== comparison) return comparison;
            }
            return 0;
        };
    }
    getSort(sortRule, isSortRow) {
        const that = this;
        return sortRule.sortByIndicator ? (a, b, sortType) => {
            const getValue = function(rowKey, colKey) {
                return "grid" === that.rowHierarchyType && rowKey.length < that.rows.length && rowKey[rowKey.length - 1] !== that.rowSubTotalLabel && rowKey[rowKey.length - 1] !== that.rowGrandTotalLabel && rowKey.push(that.rowSubTotalLabel), 
                colKey.length < that.columns.length && colKey[colKey.length - 1] !== that.colSubTotalLabel && colKey[colKey.length - 1] !== that.colGrandTotalLabel && colKey.push(that.colSubTotalLabel), 
                that.getAggregator(rowKey, colKey, sortRule.sortByIndicator).value();
            };
            return isSortRow ? sortRule.sortFunc ? sortRule.sortFunc(getValue(a, sortRule.query), getValue(b, sortRule.query), a, b, sortType) : (0, 
            aggregation_1.naturalSort)(getValue(a, sortRule.query), getValue(b, sortRule.query), sortType) : sortRule.sortFunc ? sortRule.sortFunc(getValue(sortRule.query, a), getValue(sortRule.query, b), a, b, sortType) : (0, 
            aggregation_1.naturalSort)(getValue(sortRule.query, a), getValue(sortRule.query, b), sortType);
        } : sortRule.sortBy ? (0, aggregation_1.sortBy)(sortRule.sortBy) : sortRule.sortFunc ? sortRule.sortFunc : sortRule.sortType ? aggregation_1.typeSort : aggregation_1.naturalSort;
    }
    totalStatistics() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const that = this, colCompute = (flatRowKey, flatColKey) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25;
            if (null === (_b = null === (_a = this.totalRecordsTree) || void 0 === _a ? void 0 : _a[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) return this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), 
            void (this.tree[flatRowKey][flatColKey] = null === (_d = null === (_c = this.totalRecordsTree) || void 0 === _c ? void 0 : _c[flatRowKey]) || void 0 === _d ? void 0 : _d[flatColKey]);
            const colKey = flatColKey.split(this.stringJoinChar);
            if ((null === (_f = null === (_e = that.totals) || void 0 === _e ? void 0 : _e.column) || void 0 === _f ? void 0 : _f.subTotalsDimensions) && (null === (_j = null === (_h = null === (_g = that.totals) || void 0 === _g ? void 0 : _g.column) || void 0 === _h ? void 0 : _h.subTotalsDimensions) || void 0 === _j ? void 0 : _j.length) > 0 && !1 !== that.totals.column.showSubTotals) for (let i = 0, len = null === (_m = null === (_l = null === (_k = that.totals) || void 0 === _k ? void 0 : _k.column) || void 0 === _l ? void 0 : _l.subTotalsDimensions) || void 0 === _m ? void 0 : _m.length; i < len; i++) {
                const dimension = that.totals.column.subTotalsDimensions[i], dimensionIndex = that.columns.indexOf(dimension);
                if (dimensionIndex >= 0) {
                    const colTotalKey = colKey.slice(0, dimensionIndex + 1);
                    colTotalKey.push(that.colSubTotalLabel);
                    const flatColTotalKey = colTotalKey.join(this.stringJoinChar);
                    if (null === (_p = null === (_o = this.totalRecordsTree) || void 0 === _o ? void 0 : _o[flatRowKey]) || void 0 === _p ? void 0 : _p[flatColTotalKey]) return void (this.tree[flatRowKey][flatColTotalKey] = null === (_r = null === (_q = this.totalRecordsTree) || void 0 === _q ? void 0 : _q[flatRowKey]) || void 0 === _r ? void 0 : _r[flatColTotalKey]);
                    this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
                    const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                    for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                        const calculatedFieldRule = null === (_s = this.calculatedFieldRules) || void 0 === _s ? void 0 : _s.find((rule => rule.key === toComputeIndicatorKeys[i]));
                        (null === (_u = null === (_t = this.tree[flatRowKey]) || void 0 === _t ? void 0 : _t[flatColTotalKey]) || void 0 === _u ? void 0 : _u[i]) || (this.tree[flatRowKey][flatColTotalKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                            key: toComputeIndicatorKeys[i],
                            field: toComputeIndicatorKeys[i],
                            isRecord: !0,
                            formatFun: null === (_w = null === (_v = this.indicators) || void 0 === _v ? void 0 : _v.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _w ? void 0 : _w.format,
                            calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                            dependAggregators: this.tree[flatRowKey][flatColTotalKey],
                            dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                        })), flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_y = null === (_x = that.tree[flatRowKey]) || void 0 === _x ? void 0 : _x[flatColKey]) || void 0 === _y ? void 0 : _y[i]);
                    } else {
                        if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                            this.tree[flatRowKey][flatColTotalKey][i] = new aggregation_1.registeredAggregators[null !== (_z = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _z ? _z : ts_types_1.AggregationType.SUM]({
                                key: toComputeIndicatorKeys[i],
                                field: null !== (_0 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _0 ? _0 : toComputeIndicatorKeys[i],
                                aggregationFun: null == aggRule ? void 0 : aggRule.aggregationFun,
                                formatFun: null !== (_1 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _1 ? _1 : null === (_3 = null === (_2 = this.indicators) || void 0 === _2 ? void 0 : _2.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _3 ? void 0 : _3.format
                            });
                        }
                        flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_5 = null === (_4 = that.tree[flatRowKey]) || void 0 === _4 ? void 0 : _4[flatColKey]) || void 0 === _5 ? void 0 : _5[i]);
                    }
                }
            }
            if ((null === (_7 = null === (_6 = that.totals) || void 0 === _6 ? void 0 : _6.column) || void 0 === _7 ? void 0 : _7.showGrandTotals) || 0 === this.rows.length) {
                const flatColTotalKey = that.colGrandTotalLabel;
                if (null === (_9 = null === (_8 = this.totalRecordsTree) || void 0 === _8 ? void 0 : _8[flatRowKey]) || void 0 === _9 ? void 0 : _9[flatColTotalKey]) return void (this.tree[flatRowKey][flatColTotalKey] = null === (_11 = null === (_10 = this.totalRecordsTree) || void 0 === _10 ? void 0 : _10[flatRowKey]) || void 0 === _11 ? void 0 : _11[flatColTotalKey]);
                this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                for (let i = 0; i < toComputeIndicatorKeys.length; i++) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                    const calculatedFieldRule = null === (_12 = this.calculatedFieldRules) || void 0 === _12 ? void 0 : _12.find((rule => rule.key === toComputeIndicatorKeys[i]));
                    (null === (_14 = null === (_13 = this.tree[flatRowKey]) || void 0 === _13 ? void 0 : _13[flatColTotalKey]) || void 0 === _14 ? void 0 : _14[i]) || (this.tree[flatRowKey][flatColTotalKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                        key: toComputeIndicatorKeys[i],
                        field: toComputeIndicatorKeys[i],
                        isRecord: !0,
                        formatFun: null === (_16 = null === (_15 = this.indicators) || void 0 === _15 ? void 0 : _15.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _16 ? void 0 : _16.format,
                        calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                        dependAggregators: this.tree[flatRowKey][flatColTotalKey],
                        dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                    })), flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_18 = null === (_17 = that.tree[flatRowKey]) || void 0 === _17 ? void 0 : _17[flatColKey]) || void 0 === _18 ? void 0 : _18[i]);
                } else {
                    if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                        this.tree[flatRowKey][flatColTotalKey][i] = new aggregation_1.registeredAggregators[null !== (_19 = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _19 ? _19 : ts_types_1.AggregationType.SUM]({
                            key: toComputeIndicatorKeys[i],
                            field: null !== (_20 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _20 ? _20 : toComputeIndicatorKeys[i],
                            formatFun: null !== (_21 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _21 ? _21 : null === (_23 = null === (_22 = this.indicators) || void 0 === _22 ? void 0 : _22.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _23 ? void 0 : _23.format
                        });
                    }
                    flatColTotalKey !== flatColKey && this.tree[flatRowKey][flatColTotalKey][i].push(null === (_25 = null === (_24 = that.tree[flatRowKey]) || void 0 === _24 ? void 0 : _24[flatColKey]) || void 0 === _25 ? void 0 : _25[i]);
                }
            }
        };
        if ((null === (_b = null === (_a = null == that ? void 0 : that.totals) || void 0 === _a ? void 0 : _a.column) || void 0 === _b ? void 0 : _b.subTotalsDimensions) && (null === (_e = null === (_d = null === (_c = null == that ? void 0 : that.totals) || void 0 === _c ? void 0 : _c.column) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) >= 1 || (null === (_g = null === (_f = null == that ? void 0 : that.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.subTotalsDimensions) && (null === (_k = null === (_j = null === (_h = null == that ? void 0 : that.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.subTotalsDimensions) || void 0 === _k ? void 0 : _k.length) >= 1 || (null === (_m = null === (_l = null == that ? void 0 : that.totals) || void 0 === _l ? void 0 : _l.column) || void 0 === _m ? void 0 : _m.showGrandTotals) || (null === (_p = null === (_o = null == that ? void 0 : that.totals) || void 0 === _o ? void 0 : _o.row) || void 0 === _p ? void 0 : _p.showGrandTotals)) {
            const rowTotalKeys = [];
            Object.keys(that.tree).forEach((flatRowKey => {
                const rowKey = flatRowKey.split(this.stringJoinChar);
                Object.keys(that.tree[flatRowKey]).forEach((flatColKey => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
                    if ((null === (_b = null === (_a = that.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.subTotalsDimensions) && (null === (_e = null === (_d = null === (_c = that.totals) || void 0 === _c ? void 0 : _c.row) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) > 0 && !1 !== that.totals.row.showSubTotals) for (let i = 0, len = null === (_h = null === (_g = null === (_f = that.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.subTotalsDimensions) || void 0 === _h ? void 0 : _h.length; i < len; i++) {
                        const dimension = that.totals.row.subTotalsDimensions[i], dimensionIndex = that.rows.indexOf(dimension);
                        if (dimensionIndex >= 0 && dimensionIndex < that.rows.length - 1) {
                            const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                            "tree" !== this.rowHierarchyType && rowTotalKey.push(that.rowSubTotalLabel);
                            const flatRowTotalKey = rowTotalKey.join(this.stringJoinChar);
                            this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), 
                            this.tree[flatRowTotalKey][flatColKey] || (this.tree[flatRowTotalKey][flatColKey] = []);
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                    const calculatedFieldRule = null === (_j = this.calculatedFieldRules) || void 0 === _j ? void 0 : _j.find((rule => rule.key === toComputeIndicatorKeys[i]));
                                    this.tree[flatRowTotalKey][flatColKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                                        key: toComputeIndicatorKeys[i],
                                        field: toComputeIndicatorKeys[i],
                                        isRecord: !0,
                                        formatFun: null === (_l = null === (_k = this.indicators) || void 0 === _k ? void 0 : _k.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _l ? void 0 : _l.format,
                                        calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                                        dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                                        dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                                    });
                                } else {
                                    const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                    this.tree[flatRowTotalKey][flatColKey][i] = new aggregation_1.registeredAggregators[null !== (_m = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _m ? _m : ts_types_1.AggregationType.SUM]({
                                        key: toComputeIndicatorKeys[i],
                                        field: null !== (_o = null == aggRule ? void 0 : aggRule.field) && void 0 !== _o ? _o : toComputeIndicatorKeys[i],
                                        formatFun: null !== (_p = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _p ? _p : null === (_r = null === (_q = this.indicators) || void 0 === _q ? void 0 : _q.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _r ? void 0 : _r.format
                                    });
                                }
                                flatRowTotalKey !== flatRowKey && this.tree[flatRowTotalKey][flatColKey][i].push(null === (_t = null === (_s = that.tree[flatRowKey]) || void 0 === _s ? void 0 : _s[flatColKey]) || void 0 === _t ? void 0 : _t[i]);
                            }
                        }
                    }
                    if ((null === (_v = null === (_u = that.totals) || void 0 === _u ? void 0 : _u.row) || void 0 === _v ? void 0 : _v.showGrandTotals) || 0 === this.columns.length) {
                        const flatRowTotalKey = that.rowGrandTotalLabel;
                        this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), 
                        this.tree[flatRowTotalKey][flatColKey] || (this.tree[flatRowTotalKey][flatColKey] = []);
                        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                        for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                            if (!this.tree[flatRowTotalKey][flatColKey][i]) if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                const calculatedFieldRule = null === (_w = this.calculatedFieldRules) || void 0 === _w ? void 0 : _w.find((rule => rule.key === toComputeIndicatorKeys[i]));
                                this.tree[flatRowTotalKey][flatColKey][i] = new aggregation_1.registeredAggregators[ts_types_1.AggregationType.RECALCULATE]({
                                    key: toComputeIndicatorKeys[i],
                                    field: toComputeIndicatorKeys[i],
                                    isRecord: !0,
                                    formatFun: null === (_y = null === (_x = this.indicators) || void 0 === _x ? void 0 : _x.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _y ? void 0 : _y.format,
                                    calculateFun: null == calculatedFieldRule ? void 0 : calculatedFieldRule.calculateFun,
                                    dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                                    dependIndicatorKeys: null == calculatedFieldRule ? void 0 : calculatedFieldRule.dependIndicatorKeys
                                });
                            } else {
                                const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                this.tree[flatRowTotalKey][flatColKey][i] = new aggregation_1.registeredAggregators[null !== (_z = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _z ? _z : ts_types_1.AggregationType.SUM]({
                                    key: toComputeIndicatorKeys[i],
                                    field: null !== (_0 = null == aggRule ? void 0 : aggRule.field) && void 0 !== _0 ? _0 : toComputeIndicatorKeys[i],
                                    formatFun: null !== (_1 = null == aggRule ? void 0 : aggRule.formatFun) && void 0 !== _1 ? _1 : null === (_3 = null === (_2 = this.indicators) || void 0 === _2 ? void 0 : _2.find((indicator => "string" != typeof indicator && indicator.indicatorKey === toComputeIndicatorKeys[i]))) || void 0 === _3 ? void 0 : _3.format
                                });
                            }
                            flatRowTotalKey !== flatRowKey && this.tree[flatRowTotalKey][flatColKey][i].push(null === (_5 = null === (_4 = that.tree[flatRowKey]) || void 0 === _4 ? void 0 : _4[flatColKey]) || void 0 === _5 ? void 0 : _5[i]);
                        }
                    }
                    colCompute(flatRowKey, flatColKey);
                }));
            })), rowTotalKeys.forEach((flatRowKey => {
                Object.keys(that.tree[flatRowKey]).forEach((flatColKey => {
                    colCompute(flatRowKey, flatColKey);
                }));
            }));
        }
        for (const flatRowKey in that.totalRecordsTree) for (const flatColKey in that.totalRecordsTree[flatRowKey]) colCompute(flatRowKey, flatColKey);
    }
    ArrToTree1(arr, rows, indicators, isGrandTotal, grandTotalLabel, showGrandTotalsOnTop) {
        const result = [], concatStr = this.stringJoinChar, map = new Map;
        function addList(list, isGrandTotal) {
            const path = [];
            let node;
            list.forEach(((value, index) => {
                var _a;
                path.push(value);
                const flatKey = path.join(concatStr);
                let item = map.get(flatKey);
                item || (item = {
                    value: value,
                    dimensionKey: rows[index],
                    children: index === list.length - 1 && (null !== (_a = null == indicators ? void 0 : indicators.length) && void 0 !== _a ? _a : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator => "string" == typeof indicator ? {
                        indicatorKey: indicator,
                        value: indicator
                    } : {
                        indicatorKey: indicator.indicatorKey,
                        value: indicator.title
                    })) : []
                }, map.set(flatKey, item), node ? node.children.push(item) : showGrandTotalsOnTop && isGrandTotal ? result.unshift(item) : result.push(item)), 
                node = item;
            }));
        }
        return arr.forEach((item => addList(item, !1))), isGrandTotal && addList([ grandTotalLabel ], isGrandTotal), 
        result;
    }
    ArrToTree(arr, rows, indicators, subTotalFlags, isGrandTotal, grandTotalLabel, subTotalLabel, showGrandTotalsOnTop, showSubTotalsOnTop) {
        var _a;
        let result = [];
        const concatStr = this.stringJoinChar, map = new Map;
        if ((null == arr ? void 0 : arr.length) ? arr.forEach((item => function(list) {
            const path = [];
            let node;
            list.forEach(((value, index) => {
                var _a, _b, _c, _d;
                path.push(value);
                const flatKey = path.join(concatStr);
                let item = map.get(flatKey);
                if (!item) {
                    if (item = {
                        value: value,
                        dimensionKey: rows[index],
                        children: index === list.length - 1 && (null !== (_a = null == indicators ? void 0 : indicators.length) && void 0 !== _a ? _a : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator => "string" == typeof indicator ? {
                            indicatorKey: indicator,
                            value: indicator
                        } : {
                            indicatorKey: indicator.indicatorKey,
                            value: indicator.title
                        })) : []
                    }, subTotalFlags[index]) {
                        let curChild = null !== (_b = item.children) && void 0 !== _b ? _b : [];
                        const totalChild = {
                            value: subTotalLabel,
                            dimensionKey: rows[index + 1],
                            levelSpan: subTotalFlags.length - index - 1,
                            children: (null !== (_c = null == indicators ? void 0 : indicators.length) && void 0 !== _c ? _c : 0) >= 1 ? null == indicators ? void 0 : indicators.map((indicator => "string" == typeof indicator ? {
                                indicatorKey: indicator,
                                value: indicator
                            } : {
                                indicatorKey: indicator.indicatorKey,
                                value: indicator.title
                            })) : [],
                            role: "sub-total"
                        };
                        curChild.push(totalChild), curChild = null !== (_d = totalChild.children) && void 0 !== _d ? _d : [];
                    }
                    map.set(flatKey, item), node ? subTotalFlags[index - 1] && !showSubTotalsOnTop ? node.children.splice(node.children.length - 1, 0, item) : node.children.push(item) : result.push(item);
                }
                node = item;
            }));
        }(item))) : indicators && (result = null == indicators ? void 0 : indicators.map((indicator => {
            var _a;
            return "string" == typeof indicator ? {
                indicatorKey: indicator,
                value: indicator
            } : {
                indicatorKey: indicator.indicatorKey,
                value: null !== (_a = indicator.title) && void 0 !== _a ? _a : indicator.indicatorKey
            };
        }))), isGrandTotal && (null == arr ? void 0 : arr.length)) {
            const node = {
                value: grandTotalLabel,
                dimensionKey: rows[0],
                levelSpan: subTotalFlags.length,
                children: null !== (_a = null == indicators ? void 0 : indicators.map((indicator => "string" == typeof indicator ? {
                    indicatorKey: indicator,
                    value: indicator
                } : {
                    indicatorKey: indicator.indicatorKey,
                    value: indicator.title
                }))) && void 0 !== _a ? _a : [],
                role: "grand-total"
            };
            showGrandTotalsOnTop ? result.unshift(node) : result.push(node);
        }
        return result;
    }
    cacheDeminsionCollectedValues() {
        for (const key in this.collectValuesBy) "xField" !== this.collectValuesBy[key].type && "yField" !== this.collectValuesBy[key].type || (this.dataConfig.dimensionSortArray ? this.cacheCollectedValues[key] = arraySortByAnotherArray(this.collectedValues[key], this.dataConfig.dimensionSortArray) : this.cacheCollectedValues[key] = this.collectedValues[key]);
    }
    changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
        var _a, _b, _c;
        const indicatorIndex = this.indicatorKeys.indexOf(indicator);
        let flatRowKey, flatColKey;
        flatRowKey = "string" == typeof rowKey ? rowKey : rowKey.join(this.stringJoinChar), 
        flatColKey = "string" == typeof colKey ? colKey : colKey.join(this.stringJoinChar), 
        (null === (_a = this.changedTree[flatRowKey]) || void 0 === _a ? void 0 : _a[flatColKey]) ? this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue : this.changedTree[flatRowKey] ? (this.changedTree[flatRowKey][flatColKey] = [], 
        this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue) : (this.changedTree[flatRowKey] = {}, 
        this.changedTree[flatRowKey][flatColKey] = [], this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue);
        const cellAggregator = null === (_c = null === (_b = this.tree[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) || void 0 === _c ? void 0 : _c[indicatorIndex];
        1 === (null == cellAggregator ? void 0 : cellAggregator.records.length) && (cellAggregator.records[0][this.indicatorKeys[indicatorIndex]] = newValue);
    }
    changeRecordFieldValue(fieldName, oldValue, value) {
        let isIndicatorName = !1;
        for (let i = 0; i < this.indicatorKeys.length; i++) this.indicatorKeys[i] === fieldName && (isIndicatorName = !0);
        if (!isIndicatorName) {
            if (Array.isArray(this.records)) for (let i = 0, len = this.records.length; i < len; i++) {
                const record = this.records[i];
                record[fieldName] === oldValue && (record[fieldName] = value);
            } else for (const key in this.records) for (let i = 0, len = this.records[key].length; i < len; i++) {
                const record = this.records[key][i];
                record[fieldName] === oldValue && (record[fieldName] = value);
            }
            this.rowFlatKeys = {}, this.colFlatKeys = {}, this.tree = {}, this.processRecords();
        }
    }
    _rowTreeHasChanged() {
        this.hasExtensionRowTree || (this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, "row"));
    }
    changeDataConfig(dataConfig) {
        this.rows = dataConfig.rows, this.columns = dataConfig.columns;
    }
    addRecords(records) {
        for (let i = 0, len = records.length; i < len; i++) {
            const record = records[i];
            this.processRecord(record);
        }
        Array.isArray(this.records) && this.records.push(records);
    }
    customTreeToDimensionPathArr(tree, type) {
        const result = [], that = this;
        function getPath(node, arr) {
            var _a, _b, _c;
            node.virtual || ((null === (_a = arr[arr.length - 1]) || void 0 === _a ? void 0 : _a.childKeys) && node.dimensionKey && -1 === arr[arr.length - 1].childKeys.indexOf(node.dimensionKey) && node.dimensionKey !== arr[arr.length - 1].dimensionKey && arr[arr.length - 1].childKeys.push(node.dimensionKey), 
            arr.push({
                dimensionKey: (0, vutils_1.isValid)(node.indicatorKey) ? void 0 : node.dimensionKey,
                value: node.value,
                indicatorKey: node.indicatorKey,
                virtual: node.virtual
            })), (null === (_b = node.children) || void 0 === _b ? void 0 : _b.length) > 0 ? ("tree" === that.rowHierarchyType && "row" === type && (arr[arr.length - 1].childKeys = [], 
            result.push([ ...arr ])), null === (_c = node.children) || void 0 === _c || _c.forEach((childItem => getPath(childItem, [ ...arr ])))) : result.push(arr);
        }
        return null == tree || tree.forEach((treeNode => getPath(treeNode, []))), result;
    }
    getFieldMatchColDimensionPaths(record) {
        var _a, _b;
        const fieldMatchDimensionPaths = [];
        for (let i = 0; i < (null !== (_b = null === (_a = this.customColTreeDimensionPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0); i++) {
            const dimensionPath = this.customColTreeDimensionPaths[i];
            let isMatch = !0;
            for (let j = 0; j < dimensionPath.length; j++) {
                const dimension = dimensionPath[j];
                if (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value || dimension.indicatorKey && void 0 === record[dimension.indicatorKey]) {
                    isMatch = !1;
                    break;
                }
            }
            isMatch && fieldMatchDimensionPaths.push(dimensionPath);
        }
        return fieldMatchDimensionPaths;
    }
    getFieldMatchRowDimensionPaths(record) {
        var _a, _b;
        const fieldMatchDimensionPaths = [];
        for (let i = 0; i < (null !== (_b = null === (_a = this.customRowTreeDimensionPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0); i++) {
            const dimensionPath = this.customRowTreeDimensionPaths[i];
            let isMatch = !0;
            for (let j = 0; j < dimensionPath.length; j++) {
                const dimension = dimensionPath[j];
                if (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value || dimension.indicatorKey && void 0 === record[dimension.indicatorKey]) {
                    isMatch = !1;
                    break;
                }
                if (dimension.childKeys && j === dimensionPath.length - 1 && dimension.childKeys.length > 0 && dimension.childKeys.find((key => (0, 
                vutils_1.isValid)(record[key])))) {
                    isMatch = !1;
                    break;
                }
            }
            isMatch && (this.indicatorsAsCol || "tree" !== this.rowHierarchyType || dimensionPath.find((path => path.indicatorKey)) || (isMatch = !1)), 
            isMatch && fieldMatchDimensionPaths.push(dimensionPath);
        }
        return fieldMatchDimensionPaths;
    }
}

function arraySortByAnotherArray(array, sortArray) {
    return array.sort(((a, b) => {
        const aIndex = sortArray.indexOf(a), bIndex = sortArray.indexOf(b);
        return aIndex < bIndex ? -1 : aIndex > bIndex ? 1 : 0;
    }));
}

//# sourceMappingURL=dataset.js.map
exports.Dataset = Dataset;