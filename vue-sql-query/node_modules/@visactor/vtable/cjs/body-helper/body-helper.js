"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BodyHelper = void 0;

const ts_types_1 = require("../ts-types"), registerIcons = __importStar(require("../icons")), Style_1 = require("./style/Style"), MultilineTextStyle_1 = require("./style/MultilineTextStyle"), ProgressBarStyle_1 = require("./style/ProgressBarStyle"), ImageStyle_1 = require("./style/ImageStyle"), icons = __importStar(require("../tools/icons")), helper_1 = require("../tools/helper"), CheckboxStyle_1 = require("./style/CheckboxStyle"), RadioStyle_1 = require("./style/RadioStyle"), vutils_1 = require("@visactor/vutils"), SwitchStyle_1 = require("./style/SwitchStyle"), ButtonStyle_1 = require("./style/ButtonStyle");

class BodyHelper {
    constructor(_table) {
        this._table = _table;
        const regedIcons = registerIcons.get();
        this.expandIcon = regedIcons[ts_types_1.InternalIconName.expandIconName], this.collapseIcon = regedIcons[ts_types_1.InternalIconName.collapseIconName];
    }
    getIcons(col, row, cellValue, dataValue, context) {
        const iconArr = [], hierarchyIcon = this.getHierarchyIcon(col, row);
        hierarchyIcon && iconArr.push(hierarchyIcon);
        const {icon: iconDefine} = this._table.getBodyColumnDefine(col, row);
        if (iconDefine) {
            let iconResults;
            if ("function" == typeof iconDefine) {
                iconResults = iconDefine({
                    col: col,
                    row: row,
                    value: cellValue,
                    dataValue: dataValue,
                    table: this._table
                });
            } else iconResults = iconDefine;
            const regedIcons = registerIcons.get(), addIcon = columnIcon => {
                let icon;
                icon = "string" == typeof columnIcon ? regedIcons[columnIcon] : columnIcon, icon && iconArr.push(icon);
            };
            Array.isArray(iconResults) ? iconResults.forEach(((columnIcon, index) => {
                addIcon(columnIcon);
            })) : addIcon(iconResults);
        }
        return context && iconArr.forEach(((i, index) => {
            (i.content || i.src) && (iconArr[index] = this.getCellIconFromRecordValue(i, col, row));
        })), iconArr;
    }
    getStyleClass(cellType) {
        switch (cellType) {
          case "text":
          case "link":
            return MultilineTextStyle_1.TextStyle;

          case "image":
          case "video":
            return ImageStyle_1.ImageStyle;

          case "chart":
          case "sparkline":
            return Style_1.Style;

          case "progressbar":
            return ProgressBarStyle_1.ProgressBarStyle;

          case "checkbox":
            return CheckboxStyle_1.CheckboxStyle;

          case "radio":
            return RadioStyle_1.RadioStyle;

          case "switch":
            return SwitchStyle_1.SwitchStyle;

          case "button":
            return ButtonStyle_1.ButtonStyle;
        }
        return MultilineTextStyle_1.TextStyle;
    }
    getCellIconFromRecordValue(icon, col, row) {
        if (Array.isArray(icon)) return icon.map((i => this.getCellIconFromRecordValue(i, col, row)));
        if (!helper_1.obj.isObject(icon) || "function" == typeof icon) return this._table.getFieldData(icon, col, row);
        const retIcon = {}, iconOpt = icon;
        return icons.iconPropKeys.forEach((k => {
            var _a, _b;
            if (void 0 !== iconOpt[k]) {
                const f = this._table.getFieldData(iconOpt[k], col, row);
                (0, vutils_1.isValid)(f) ? retIcon[k] = f : (null === (_b = (_a = this._table)._hasField) || void 0 === _b ? void 0 : _b.call(_a, iconOpt[k], col, row)) || (retIcon[k] = iconOpt[k]);
            }
        })), retIcon;
    }
    getHierarchyIcon(col, row) {
        const hierarchyState = this._table.getHierarchyState(col, row);
        return hierarchyState === ts_types_1.HierarchyState.expand ? this.expandIcon : hierarchyState === ts_types_1.HierarchyState.collapse ? this.collapseIcon : void 0;
    }
    getHierarchyIconWidth() {
        var _a, _b;
        return this.expandIcon.width + (null !== (_a = this.expandIcon.marginLeft) && void 0 !== _a ? _a : 0) + (null !== (_b = this.expandIcon.marginRight) && void 0 !== _b ? _b : 0);
    }
}

exports.BodyHelper = BodyHelper;
//# sourceMappingURL=body-helper.js.map