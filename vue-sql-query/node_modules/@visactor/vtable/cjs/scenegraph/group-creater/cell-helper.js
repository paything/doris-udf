"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getCustomCellMergeCustom = exports.resizeCellGroup = exports.dealWithMergeCellSizeForShadow = exports.dealWithMergeCellSize = exports.updateCell = exports.createCell = void 0;

const global_1 = require("../../tools/global"), custom_1 = require("../component/custom"), get_prop_1 = require("../utils/get-prop"), tableHelper_1 = require("../../core/tableHelper"), helper_1 = require("../../tools/helper"), deal_promise_data_1 = require("../utils/deal-promise-data"), factory_1 = require("../../core/factory"), get_hierarchy_offset_1 = require("../utils/get-hierarchy-offset"), padding_1 = require("../utils/padding"), text_icon_layout_1 = require("../utils/text-icon-layout"), vutils_1 = require("@visactor/vutils"), break_string_1 = require("../utils/break-string"), invert_highlight_1 = require("../../plugins/invert-highlight"), cell_border_stroke_width_1 = require("../utils/cell-border-stroke-width");

function createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult) {
    var _a, _b;
    let cellGroup, isAsync = !1;
    if ((0, helper_1.isPromise)(value)) {
        if ("cell" !== table.scenegraph.highPerformanceGetCell(col, row).role) return cellGroup;
        value = table.getCellValue(col, row), isAsync = !0;
    }
    if ("text" === type || "link" === type || customResult) {
        if ("link" === type) {
            const cellValue = value, cellOriginValue = table.getCellOriginValue(col, row), headerStyle = table._getCellStyle(col, row);
            "link" === type && ("templateLink" in define && define.templateLink || !("linkDetect" in define) || !(0, 
            helper_1.getOrApply)(define.linkDetect, {
                col: col,
                row: row,
                table: table,
                value: cellValue,
                dataValue: cellOriginValue,
                cellHeaderPaths: void 0
            }) || global_1.regUrl.test(cellValue)) && (cellTheme ? (cellTheme.text.fill = (0, 
            get_prop_1.getProp)("linkColor", headerStyle, col, row, table), cellTheme.group.cursor = "pointer") : cellTheme = {
                text: {
                    fill: (0, get_prop_1.getProp)("linkColor", headerStyle, col, row, table)
                },
                group: {
                    cursor: "pointer"
                }
            });
        }
        const {customElementsGroup: customElementsGroup, renderDefault: renderDefault} = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult);
        cellGroup = factory_1.Factory.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range, isAsync);
        const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
        if (axisConfig) {
            const axis = new (factory_1.Factory.getComponent("axis"))(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, null !== (_a = axisConfig.__vtablePadding) && void 0 !== _a ? _a : padding, table);
            cellGroup.clear(), cellGroup.appendChild(axis.component), axis.overlap();
        } else table.internalProps.layoutMap.isEmpty(col, row) ? (cellGroup.setAttributes({
            fill: !1,
            stroke: !1
        }), cellGroup.clear()) : table.internalProps.layoutMap.isAxisCell(col, row) && cellGroup.clear();
    } else if ("image" === type) {
        cellGroup = factory_1.Factory.getFunction("createImageCellGroup")(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync);
    } else if ("video" === type) {
        cellGroup = factory_1.Factory.getFunction("createVideoCellGroup")(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync);
    } else if ("chart" === type) {
        const chartInstance = table.internalProps.layoutMap.getChartInstance(col, row);
        cellGroup = factory_1.Factory.getFunction("createChartCellGroup")(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, value, define.chartModule, table.internalProps.layoutMap.getChartSpec(col, row), chartInstance, null !== (_b = table.internalProps.layoutMap.getChartDataId(col, row)) && void 0 !== _b ? _b : "data", table, cellTheme, table.internalProps.layoutMap.isShareChartSpec(col, row), isAsync, table.internalProps.layoutMap.isNoChartDataRenderNothing(col, row));
    } else if ("progressbar" === type) {
        const {customElementsGroup: customElementsGroup, renderDefault: renderDefault} = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult), style = table._getCellStyle(col, row), dataValue = table.getCellOriginValue(col, row);
        cellGroup = factory_1.Factory.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, !1, customElementsGroup, renderDefault, cellTheme, range, isAsync);
        const progressBarGroup = factory_1.Factory.getFunction("createProgressBarCell")(define, style, colWidth, value, dataValue, col, row, padding, table, range);
        cellGroup.firstChild ? cellGroup.insertBefore(progressBarGroup, cellGroup.firstChild) : cellGroup.appendChild(progressBarGroup);
    } else if ("sparkline" === type) {
        cellGroup = factory_1.Factory.getFunction("createSparkLineCellGroup")(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, table, cellTheme, isAsync);
    } else if ("checkbox" === type) {
        const isAggregation = "isAggregation" in table.internalProps.layoutMap && table.internalProps.layoutMap.isAggregation(col, row), isSeriesNumber = table.internalProps.layoutMap.isSeriesNumber(col, row);
        if (isAggregation && isSeriesNumber) {
            cellGroup = factory_1.Factory.getFunction("createTextCellGroup")(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, !1, void 0, !0, cellTheme, range, isAsync);
        } else {
            cellGroup = factory_1.Factory.getFunction("createCheckboxCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
        }
    } else if ("radio" === type) {
        cellGroup = factory_1.Factory.getFunction("createRadioCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellTheme, define, range);
    } else if ("switch" === type) {
        cellGroup = factory_1.Factory.getFunction("createSwitchCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
    } else if ("button" === type) {
        cellGroup = factory_1.Factory.getFunction("createButtonCellGroup")(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
    }
    return cellGroup.onBeforeAttributeUpdate = invert_highlight_1.onBeforeAttributeUpdateForInvertHighlight, 
    cellGroup;
}

function _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult) {
    let customElementsGroup, renderDefault = !0;
    if (customResult) customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault; else if ((null == range ? void 0 : range.isCustom) && !table.isCornerHeader(col, row)) ; else {
        let customRender, customLayout;
        if ("body" !== table.getCellLocation(col, row) ? (customRender = null == define ? void 0 : define.headerCustomRender, 
        customLayout = null == define ? void 0 : define.headerCustomLayout) : (customRender = (null == define ? void 0 : define.customRender) || table.customRender, 
        customLayout = null == define ? void 0 : define.customLayout), customLayout || customRender) {
            const customResult = (0, custom_1.dealWithCustom)(customLayout, customRender, col, row, cellWidth, cellHeight, !1, table.isAutoRowHeight(row), padding, range, table);
            customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault;
        }
    }
    return {
        customElementsGroup: customElementsGroup,
        renderDefault: renderDefault
    };
}

function updateCell(col, row, table, addNew, isShadow, forceFastUpdate) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const oldCellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0);
    if ("cell" !== oldCellGroup.role && !addNew) return;
    const cellLocation = table.getCellLocation(col, row);
    let isMerge, range, customStyle, customResult, value = table.getCellValue(col, row), isCustomMerge = !1;
    if (table.internalProps.customMergeCell) {
        const customMerge = table.getCustomMerge(col, row);
        if (customMerge) {
            const {range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout: customLayout, customRender: customRender} = customMerge;
            range = customMergeRange, isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row, 
            value = customMergeText, customStyle = customMergeStyle, (customLayout || customRender) && (customResult = (0, 
            custom_1.dealWithCustom)(customLayout, customRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), !1, table.isAutoRowHeight(row), [ 0, 0, 0, 0 ], range, table)), 
            isCustomMerge = !0;
        }
    }
    let colForDefine = col, rowForDefine = row;
    range && (colForDefine = range.start.col, rowForDefine = range.start.row);
    const define = "body" !== cellLocation ? table.getHeaderDefine(colForDefine, rowForDefine) : table.getBodyColumnDefine(colForDefine, rowForDefine);
    let mayHaveIcon = "body" !== cellLocation || ((null == define ? void 0 : define.dragOrder) || !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree));
    range || !table.internalProps.enableTreeNodeMerge && "body" === cellLocation && !(null == define ? void 0 : define.mergeCell) || (range = table.getCellRange(col, row), 
    isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row);
    let isVtableMerge = !1;
    if (table.internalProps.enableTreeNodeMerge && isMerge) {
        const rawRecord = table.getCellRawRecord(range.start.col, range.start.row), {vtableMergeName: vtableMergeName, vtableMerge: vtableMerge} = null != rawRecord ? rawRecord : {};
        isVtableMerge = vtableMerge, vtableMerge && (mayHaveIcon = !0, table.options.groupTitleCustomLayout && (customResult = (0, 
        custom_1.dealWithCustom)(table.options.groupTitleCustomLayout, void 0, range.start.col, range.start.row, table.getColsWidth(range.start.col, range.end.col), table.getRowsHeight(range.start.row, range.end.row), !1, table.isAutoRowHeight(row), [ 0, 0, 0, 0 ], range, table)), 
        table.options.groupTitleFieldFormat ? value = table.options.groupTitleFieldFormat(rawRecord, col, row, table) : vtableMergeName && (value = vtableMergeName));
    }
    const cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, cellTheme = (0, 
    tableHelper_1.getStyleTheme)(cellStyle, table, isMerge ? range.start.col : col, isMerge ? range.start.row : row, get_prop_1.getProp).theme;
    if (cellTheme.group.cornerRadius = (0, tableHelper_1.getCellCornerRadius)(col, row, table), 
    !addNew && !isMerge && !((null == define ? void 0 : define.customLayout) || (null == define ? void 0 : define.customRender) || (null == define ? void 0 : define.headerCustomLayout) || (null == define ? void 0 : define.headerCustomRender)) && (forceFastUpdate || canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table))) {
        const cellWidth = table.getColWidth(col), cellHeight = table.getRowHeight(row), strokeArrayWidth = (0, 
        cell_border_stroke_width_1.getCellBorderStrokeWidth)(col, row, cellTheme, table);
        oldCellGroup.setAttributes({
            width: cellWidth,
            height: cellHeight,
            lineWidth: null !== (_c = null === (_b = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _b ? void 0 : _b.lineWidth) && void 0 !== _c ? _c : void 0,
            fill: null !== (_e = null === (_d = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _d ? void 0 : _d.fill) && void 0 !== _e ? _e : void 0,
            stroke: null !== (_g = null === (_f = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _f ? void 0 : _f.stroke) && void 0 !== _g ? _g : void 0,
            strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
            strokeArrayColor: null !== (_j = null === (_h = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _h ? void 0 : _h.strokeArrayColor) && void 0 !== _j ? _j : void 0,
            cursor: null !== (_l = null === (_k = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _k ? void 0 : _k.cursor) && void 0 !== _l ? _l : void 0,
            cornerRadius: null !== (_o = null === (_m = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _m ? void 0 : _m.cornerRadius) && void 0 !== _o ? _o : 0,
            lineDash: null !== (_q = null === (_p = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _p ? void 0 : _p.lineDash) && void 0 !== _q ? _q : void 0,
            y: table.scenegraph.getCellGroupY(row)
        }), oldCellGroup.forEachChildren((child => {
            child.setAttributes({
                dx: 0,
                dy: 0
            });
        }));
        const textMark = oldCellGroup.getChildByName("text");
        if (forceFastUpdate && textMark) {
            const attribute = {
                textBaseline: "top"
            };
            textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
        } else if (textMark) {
            const text = table.getCellValue(col, row), {text: textArr, moreThanMaxCharacters: moreThanMaxCharacters} = (0, 
            break_string_1.breakString)(text, table), hierarchyOffset = (0, get_hierarchy_offset_1.getHierarchyOffset)(col, row, table), lineClamp = cellStyle.lineClamp, padding = null !== (_r = (0, 
            padding_1.getQuadProps)((0, get_prop_1.getProp)("padding", cellStyle, col, row, table))) && void 0 !== _r ? _r : [ 0, 0, 0, 0 ], textAlign = cellTheme.text.textAlign;
            let x = 0;
            x = "center" === textAlign ? padding[3] + (cellWidth - (padding[1] + padding[3])) / 2 : "right" === textAlign ? padding[3] + cellWidth - (padding[1] + padding[3]) : padding[3];
            const attribute = {
                text: 1 !== textArr.length || autoWrapText ? textArr : textArr[0],
                moreThanMaxCharacters: moreThanMaxCharacters,
                maxLineWidth: cellWidth - (padding[1] + padding[3] + hierarchyOffset),
                textBaseline: "top",
                autoWrapText: autoWrapText,
                lineClamp: lineClamp,
                wordBreak: "break-word",
                heightLimit: cellHeight - Math.floor(padding[0] + padding[2]),
                pickable: !1,
                dx: "left" === textAlign ? hierarchyOffset : 0,
                x: x
            };
            if (textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute), 
            textMark.attribute.text) {
                const textBaseline = cellTheme.text.textBaseline, height = cellHeight - (padding[0] + padding[2]);
                let y = 0;
                y = "middle" === textBaseline ? padding[0] + (height - textMark.AABBBounds.height()) / 2 : "bottom" === textBaseline ? padding[0] + height - textMark.AABBBounds.height() : padding[0], 
                textMark.setAttributes({
                    y: y
                });
            }
        }
        return oldCellGroup;
    }
    if (!addNew && "empty" === oldCellGroup.role) return;
    const type = isVtableMerge || isCustomMerge ? "text" : table.isHeader(col, row) ? null !== (_s = table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _s ? _s : "text" : null !== (_t = table.getBodyColumnType(col, row)) && void 0 !== _t ? _t : "text", padding = cellTheme._vtable.padding, textAlign = cellTheme.text.textAlign, textBaseline = cellTheme.text.textBaseline;
    let newCellGroup, cellWidth, cellHeight;
    if (range ? (cellWidth = table.getColsWidth(range.start.col, range.end.col), cellHeight = table.getRowsHeight(range.start.row, range.end.row)) : (cellWidth = table.getColWidth(col), 
    cellHeight = table.getRowHeight(row)), (0, helper_1.isPromise)(value) ? (oldCellGroup.removeAllChild(), 
    (0, deal_promise_data_1.dealPromiseData)(value, table, callUpdateCellContentForPromiseValue.bind(null, {
        type: type,
        value: value,
        define: define,
        table: table,
        col: col,
        row: row,
        cellWidth: cellWidth,
        cellHeight: cellHeight,
        oldCellGroup: oldCellGroup,
        padding: padding,
        textAlign: textAlign,
        textBaseline: textBaseline,
        mayHaveIcon: mayHaveIcon,
        addNew: addNew,
        range: range,
        customResult: customResult,
        customStyle: customStyle
    }))) : newCellGroup = updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult), 
    isMerge) {
        const {width: contentWidth} = newCellGroup.attribute, {height: contentHeight} = newCellGroup.attribute;
        newCellGroup.contentWidth = contentWidth, newCellGroup.contentHeight = contentHeight, 
        isShadow ? dealWithMergeCellSizeForShadow(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table, newCellGroup) : dealWithMergeCellSize(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table);
    }
    return newCellGroup;
}

function updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult) {
    var _a, _b;
    if ((0, helper_1.isPromise)(value) && (value = table.getCellValue(col, row)), !addNew && (oldCellGroup.row !== row || oldCellGroup.col !== col)) return null;
    if (!addNew && oldCellGroup.parent && table.reactCustomLayout) {
        const reactGroup = oldCellGroup.getChildByName("custom-container");
        if (reactGroup) {
            const {col: col, row: row} = reactGroup;
            (0, vutils_1.isNumber)(col) && (0, vutils_1.isNumber)(row) && table.reactCustomLayout.removeCustomCell(col, row);
        }
    }
    const newCellGroup = createCell(type, value, define, table, col, row, table.getColWidth(col), cellWidth, cellHeight, addNew ? table.scenegraph.getColGroup(col) : oldCellGroup.parent, addNew ? 0 : table.scenegraph.getCellGroupY(row), padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult);
    return !addNew && oldCellGroup.parent && (oldCellGroup.parent.insertAfter(newCellGroup, oldCellGroup), 
    oldCellGroup.parent.removeChild(oldCellGroup), (null === (_a = table.scenegraph) || void 0 === _a ? void 0 : _a.proxy.cellCache.get(col)) && (null === (_b = table.scenegraph) || void 0 === _b || _b.proxy.cellCache.set(col, newCellGroup))), 
    newCellGroup;
}

function canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table) {
    var _a;
    const cellType = table.getBodyColumnType(col, row), autoRowHeight = table.isAutoRowHeight(row), value = table.getCellValue(col, row);
    return !(table.isHeader(col, row) || "cell" !== oldCellGroup.role || "text" !== cellType || autoWrapText || autoRowHeight || mayHaveIcon || "text" !== (null === (_a = oldCellGroup.firstChild) || void 0 === _a ? void 0 : _a.type) || (0, 
    helper_1.isPromise)(value));
}

function callUpdateCellContentForPromiseValue(updateCellArgs) {
    const {type: type, value: value, define: define, table: table, col: col, row: row, cellWidth: cellWidth, cellHeight: cellHeight, oldCellGroup: oldCellGroup, padding: padding, textAlign: textAlign, textBaseline: textBaseline, mayHaveIcon: mayHaveIcon, addNew: addNew, range: range, customResult: customResult, customStyle: customStyle} = updateCellArgs, cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row), cellTheme = (0, 
    tableHelper_1.getStyleTheme)(cellStyle, table, range ? range.start.col : col, range ? range.start.row : row, get_prop_1.getProp).theme;
    cellTheme.group.cornerRadius = (0, tableHelper_1.getCellCornerRadius)(col, row, table), 
    updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult);
}

function dealWithMergeCellSize(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table) {
    for (let col = range.start.col; col <= range.end.col; col++) for (let row = range.start.row; row <= range.end.row; row++) {
        const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0);
        if ("cell" !== cellGroup.role) continue;
        range.start.row !== range.end.row && cellGroup.contentHeight !== cellHeight && (0, 
        text_icon_layout_1.updateCellContentHeight)(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table), 
        range.start.col !== range.end.col && cellGroup.contentWidth !== cellWidth && (0, 
        text_icon_layout_1.updateCellContentWidth)(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph), 
        cellGroup.contentWidth = cellWidth, cellGroup.contentHeight = cellHeight;
        const rangeHeight = table.getRowHeight(row);
        resizeCellGroup(cellGroup, table.getColWidth(col), rangeHeight, range, table);
    }
}

function dealWithMergeCellSizeForShadow(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellGroup) {
    const {col: col, row: row} = cellGroup;
    range.start.row !== range.end.row && cellGroup.contentHeight !== cellHeight && (0, 
    text_icon_layout_1.updateCellContentHeight)(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table), 
    range.start.col !== range.end.col && cellGroup.contentWidth !== cellWidth && (0, 
    text_icon_layout_1.updateCellContentWidth)(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph), 
    cellGroup.contentWidth = cellWidth, cellGroup.contentHeight = cellHeight;
    const rangeHeight = table.getRowHeight(row);
    resizeCellGroup(cellGroup, table.getColWidth(col), rangeHeight, range, table);
}

function resizeCellGroup(cellGroup, rangeWidth, rangeHeight, range, table) {
    var _a, _b;
    const {col: col, row: row} = cellGroup, dx = -table.getColsWidth(range.start.col, col - 1);
    let dy = 0;
    if (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) for (let i = range.start.row; i <= row - 1; i++) dy -= table.getRowHeight(i); else dy = -table.getRowsHeight(range.start.row, row - 1);
    cellGroup.forEachChildren((child => {
        var _a, _b, _c, _d, _e, _f;
        "number" == typeof child._dx ? (child.skipMergeUpdate = !0, child.setAttributes({
            dx: (null !== (_a = child._dx) && void 0 !== _a ? _a : 0) + dx
        }), child.skipMergeUpdate = !1) : (child.skipMergeUpdate = !0, child._dx = null !== (_b = child.attribute.dx) && void 0 !== _b ? _b : 0, 
        child.setAttributes({
            dx: (null !== (_c = child.attribute.dx) && void 0 !== _c ? _c : 0) + dx
        }), child.skipMergeUpdate = !1), "number" == typeof child._dy ? (child.skipMergeUpdate = !0, 
        child.setAttributes({
            dy: (null !== (_d = child._dy) && void 0 !== _d ? _d : 0) + dy
        }), child.skipMergeUpdate = !1) : (child._dy = null !== (_e = child.attribute.dy) && void 0 !== _e ? _e : 0, 
        child.skipMergeUpdate = !0, child.setAttributes({
            dy: (null !== (_f = child.attribute.dy) && void 0 !== _f ? _f : 0) + dy
        }), child.skipMergeUpdate = !1);
    }));
    const lineWidth = null !== (_b = cellGroup.attribute.strokeArrayWidth) && void 0 !== _b ? _b : cellGroup.attribute.lineWidth, isLineWidthArray = (0, 
    vutils_1.isArray)(lineWidth), newLineWidth = [ 0, 0, 0, 0 ];
    col === range.start.col && (newLineWidth[3] = isLineWidthArray ? lineWidth[3] : lineWidth), 
    row === range.start.row && (newLineWidth[0] = isLineWidthArray ? lineWidth[0] : lineWidth), 
    col === range.end.col && (newLineWidth[1] = isLineWidthArray ? lineWidth[1] : lineWidth), 
    row === range.end.row && (newLineWidth[2] = isLineWidthArray ? lineWidth[2] : lineWidth);
    const widthChange = rangeWidth !== cellGroup.attribute.width, heightChange = rangeHeight !== cellGroup.attribute.height;
    return cellGroup.skipMergeUpdate = !0, cellGroup.setAttributes({
        width: rangeWidth,
        height: rangeHeight,
        strokeArrayWidth: newLineWidth
    }), cellGroup.skipMergeUpdate = !1, cellGroup.mergeStartCol = range.start.col, cellGroup.mergeStartRow = range.start.row, 
    cellGroup.mergeEndCol = range.end.col, cellGroup.mergeEndRow = range.end.row, {
        widthChange: widthChange,
        heightChange: heightChange
    };
}

function getCustomCellMergeCustom(col, row, cellGroup, table) {
    if (table.internalProps.customMergeCell) {
        const customMerge = table.getCustomMerge(col, row);
        if (customMerge) {
            const {range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout: customMergeLayout, customRender: customMergeRender} = customMerge;
            if (customMergeLayout || customMergeRender) {
                const customElementsGroup = (0, custom_1.dealWithCustom)(customMergeLayout, customMergeRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), !1, table.isAutoRowHeight(row), [ 0, 0, 0, 0 ], customMergeRange, table).elementsGroup;
                cellGroup.childrenCount > 0 && customElementsGroup ? cellGroup.insertBefore(customElementsGroup, cellGroup.firstChild) : customElementsGroup && cellGroup.appendChild(customElementsGroup);
                const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col), {width: contentWidth} = cellGroup.attribute, {height: contentHeight} = cellGroup.attribute;
                return cellGroup.contentWidth = contentWidth, cellGroup.contentHeight = contentHeight, 
                resizeCellGroup(cellGroup, rangeWidth, rangeHeight, customMergeRange, table), customMergeRange;
            }
        }
    }
}

exports.createCell = createCell, exports.updateCell = updateCell, exports.dealWithMergeCellSize = dealWithMergeCellSize, 
exports.dealWithMergeCellSizeForShadow = dealWithMergeCellSizeForShadow, exports.resizeCellGroup = resizeCellGroup, 
exports.getCustomCellMergeCustom = getCustomCellMergeCustom;
//# sourceMappingURL=cell-helper.js.map
