"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.sortVertical = void 0;

const compute_row_height_1 = require("../../../layout/compute-row-height"), dynamic_set_y_1 = require("./dynamic-set-y"), update_auto_row_1 = require("./update-auto-row");

function sortVertical(proxy) {
    var _a;
    return __awaiter(this, void 0, void 0, (function*() {
        let syncTopRow, syncBottomRow;
        proxy.table.scenegraph.bodyGroup.forEachChildren(((colGroup, index) => {
            "group" === colGroup.type && (colGroup.needUpdate = !0, null == colGroup || colGroup.forEachChildren((cellGroup => {
                cellGroup.needUpdate = !0;
            })));
        })), proxy.table.isAutoRowHeight(proxy.rowStart) ? (syncTopRow = proxy.rowStart, 
        syncBottomRow = proxy.rowEnd) : (syncTopRow = Math.max(proxy.bodyTopRow, proxy.screenTopRow - 1 * proxy.screenRowCount), 
        syncBottomRow = Math.min(proxy.bodyBottomRow, proxy.screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1));
        const oldBodyHeight = proxy.table.getAllRowsHeight();
        (0, compute_row_height_1.computeRowsHeight)(proxy.table, syncTopRow, syncBottomRow);
        const newBodyHeight = proxy.table.getAllRowsHeight();
        oldBodyHeight !== newBodyHeight && proxy.table.scenegraph.updateContainerHeight(proxy.table.frozenRowCount, newBodyHeight - oldBodyHeight);
        for (let col = 0; col < (null !== (_a = proxy.table.frozenColCount) && void 0 !== _a ? _a : 0); col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        (0, dynamic_set_y_1.updateRowContent)(syncTopRow, syncBottomRow, proxy), proxy.table.isAutoRowHeight(syncTopRow) && (0, 
        update_auto_row_1.updateAutoRow)(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), 
        proxy.rowUpdatePos = proxy.rowStart, proxy.rowUpdateDirection = proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", 
        proxy.table.scenegraph.updateNextFrame(), proxy.table.isAutoRowHeight(proxy.rowStart) || (yield proxy.progress());
    }));
}

exports.sortVertical = sortVertical;
//# sourceMappingURL=sort-vertical.js.map
