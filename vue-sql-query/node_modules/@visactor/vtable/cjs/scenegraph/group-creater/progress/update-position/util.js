"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getNextGroup = exports.getPrevGroup = exports.getLastChild = exports.getFirstChild = exports.checkFirstColMerge = exports.checkFirstRowMerge = void 0;

const get_cell_merge_1 = require("../../../utils/get-cell-merge"), cell_helper_1 = require("../../cell-helper");

function checkFirstRowMerge(row, proxy) {
    for (let col = 0; col < proxy.table.colCount; col++) {
        if (col >= proxy.table.rowHeaderLevelCount && col < proxy.colStart || col > proxy.colEnd && col < proxy.table.colCount - proxy.table.rightFrozenColCount) continue;
        const range = (0, get_cell_merge_1.getCellMergeInfo)(proxy.table, col, row);
        if (range && clearHadMergedRow(range.start.row, range.end.row, col, proxy), range && range.start.row !== row && "cell" !== proxy.highPerformanceGetCell(range.start.col, range.start.row, !0).role) {
            const oldCellGroup = proxy.highPerformanceGetCell(col, row, !0), newCellGroup = (0, 
            cell_helper_1.updateCell)(range.start.col, range.start.row, proxy.table, !0);
            newCellGroup.col = col, newCellGroup.row = row, newCellGroup.setAttribute("y", proxy.table.getRowsHeight(proxy.table.frozenRowCount, range.start.row - 1)), 
            oldCellGroup.parent.insertAfter(newCellGroup, oldCellGroup), oldCellGroup.parent.removeChild(oldCellGroup), 
            oldCellGroup.needUpdate = !1, newCellGroup.needUpdate = !1, proxy.cellCache.get(col) && proxy.cellCache.set(col, newCellGroup);
        }
    }
}

function checkFirstColMerge(col, proxy) {
    for (let row = 0; row < proxy.table.rowCount; row++) {
        if (row >= proxy.table.frozenRowCount && row < proxy.rowStart || row > proxy.rowEnd && row < proxy.table.rowCount - proxy.table.bottomFrozenRowCount) continue;
        const range = (0, get_cell_merge_1.getCellMergeInfo)(proxy.table, col, row);
        if (range && clearHadMergedColumn(range.start.col, range.end.col, row, proxy), range && range.start.col !== col && "cell" !== proxy.highPerformanceGetCell(range.start.col, range.start.row, !0).role) {
            const oldCellGroup = proxy.highPerformanceGetCell(col, row, !0), newCellGroup = (0, 
            cell_helper_1.updateCell)(range.start.col, range.start.row, proxy.table, !0);
            newCellGroup.col = col, newCellGroup.row = row, newCellGroup.setAttribute("x", proxy.table.getColsWidth(proxy.table.rowHeaderLevelCount, range.start.col - 1) - oldCellGroup.parent.attribute.x), 
            newCellGroup.setAttributes({
                x: proxy.table.getColsWidth(proxy.table.rowHeaderLevelCount, range.start.col - 1) - oldCellGroup.parent.attribute.x,
                y: proxy.table.getRowsHeight(0, range.start.row - 1) - oldCellGroup.parent.attribute.y
            }), oldCellGroup.parent.insertAfter(newCellGroup, oldCellGroup), oldCellGroup.parent.removeChild(oldCellGroup), 
            oldCellGroup.needUpdate = !1, newCellGroup.needUpdate = !1, proxy.cellCache.get(col) && proxy.cellCache.set(col, newCellGroup);
        }
    }
}

function clearHadMergedRow(rowStart, rowEnd, col, proxy) {
    for (let row = rowStart; row <= rowEnd; row++) {
        const cellGroup = proxy.highPerformanceGetCell(col, row, !0);
        "shadow-cell" !== cellGroup.role && "empty" !== cellGroup.role && cellGroup.row !== rowStart && (cellGroup.role = "shadow-cell", 
        cellGroup.setAttributes({
            width: 0,
            height: proxy.table.getRowHeight(cellGroup.row),
            y: proxy.table.getRowsHeight(proxy.table.frozenRowCount, cellGroup.row - 1),
            x: 0
        }), cellGroup.clear());
    }
}

function clearHadMergedColumn(colStart, colEnd, row, proxy) {
    for (let col = colStart; col <= colEnd; col++) {
        const cellGroup = proxy.highPerformanceGetCell(col, row, !0);
        "shadow-cell" !== cellGroup.role && "empty" !== cellGroup.role && cellGroup.col !== colStart && (cellGroup.role = "shadow-cell", 
        cellGroup.setAttributes({
            width: 0,
            height: proxy.table.getRowHeight(cellGroup.row),
            y: proxy.table.getRowsHeight(0, cellGroup.row - 1),
            x: 0
        }), cellGroup.clear());
    }
}

function checkHasColMerge(colStart, colEnd, row, proxy) {
    for (let col = colStart; col <= colEnd; col++) if ("shadow-cell" !== proxy.highPerformanceGetCell(col, row, !0).role && "empty" !== proxy.highPerformanceGetCell(col, row, !0).role) return !0;
    return !1;
}

function getFirstChild(containerGroup) {
    let child = containerGroup.firstChild;
    for (;child && "group" !== child.type; ) child = child._next;
    return child;
}

function getLastChild(containerGroup) {
    let child = containerGroup.lastChild;
    for (;child && "group" !== child.type; ) child = child._prev;
    return child;
}

function getPrevGroup(group) {
    let child = group._prev;
    for (;child && "group" !== child.type; ) child = child._prev;
    return child;
}

function getNextGroup(group) {
    let child = group._next;
    for (;child && "group" !== child.type; ) child = child._next;
    return child;
}

exports.checkFirstRowMerge = checkFirstRowMerge, exports.checkFirstColMerge = checkFirstColMerge, 
exports.getFirstChild = getFirstChild, exports.getLastChild = getLastChild, exports.getPrevGroup = getPrevGroup, 
exports.getNextGroup = getNextGroup;
//# sourceMappingURL=util.js.map
