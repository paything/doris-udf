"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.sortHorizontal = void 0;

const compute_col_width_1 = require("../../../layout/compute-col-width"), dynamic_set_x_1 = require("./dynamic-set-x");

function sortHorizontal(proxy) {
    return __awaiter(this, void 0, void 0, (function*() {
        proxy.table.scenegraph.bodyGroup.forEachChildren(((colGroup, index) => {
            "group" === colGroup.type && (colGroup.needUpdate = !0, null == colGroup || colGroup.forEachChildren((cellGroup => {
                cellGroup.needUpdate = !0;
            })));
        }));
        const syncLeftCol = Math.max(proxy.bodyLeftCol, proxy.screenLeftCol - 1 * proxy.screenColCount), syncRightCol = Math.min(proxy.bodyRightCol, proxy.screenLeftCol + 2 * proxy.screenColCount);
        (0, compute_col_width_1.computeColsWidth)(proxy.table, syncLeftCol, syncRightCol);
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        (0, dynamic_set_x_1.updateColContent)(syncLeftCol, syncRightCol, proxy), proxy.colUpdatePos = proxy.colStart, 
        proxy.colUpdateDirection = proxy.colEnd > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left", 
        proxy.table.scenegraph.updateNextFrame(), yield proxy.progress();
    }));
}

exports.sortHorizontal = sortHorizontal;
//# sourceMappingURL=sort-horizontal.js.map
