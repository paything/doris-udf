"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.updateAutoColumn = void 0;

const util_1 = require("./util");

function updateAutoColumn(colStart, colEnd, table, direction = "left") {
    for (let col = colStart; col <= colEnd; col++) {
        const bodyColGroup = table.scenegraph.getColGroup(col);
        bodyColGroup && moveColumnGroup(bodyColGroup, table, direction);
        const columnHeaderColGroup = table.scenegraph.getColGroup(col, !0);
        columnHeaderColGroup && moveColumnGroup(columnHeaderColGroup, table, direction);
        const bottomColGroup = table.scenegraph.getColGroupInBottom(col);
        bottomColGroup && moveColumnGroup(bottomColGroup, table, direction);
    }
    const totalActualBodyColumnCount = Math.min(table.scenegraph.proxy.colLimit, table.scenegraph.proxy.bodyRightCol - table.scenegraph.proxy.bodyLeftCol + 1), totalBodyWidth = table.getColsWidth(table.frozenColCount, table.frozenColCount + totalActualBodyColumnCount), totalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
    table.scenegraph.proxy.xLimitLeft = totalBodyWidth / 2, table.scenegraph.proxy.xLimitRight = totalWidth - totalBodyWidth / 2;
}

function moveColumnGroup(colGroup, table, direction = "left") {
    if ("left" === direction) {
        let x;
        const prevCellGroup = (0, util_1.getPrevGroup)(colGroup);
        x = prevCellGroup ? prevCellGroup.attribute.x + table.getColWidth(colGroup._prev.col) : table.getColsWidth(table.frozenColCount, colGroup.col - 1), 
        colGroup.setAttribute("x", x);
    } else {
        let x;
        const nextCellGroup = (0, util_1.getNextGroup)(colGroup);
        x = nextCellGroup ? nextCellGroup.attribute.x - table.getColWidth(colGroup.col) : table.getColsWidth(table.frozenColCount, colGroup.col - 1), 
        colGroup.setAttribute("x", x);
    }
}

exports.updateAutoColumn = updateAutoColumn;
//# sourceMappingURL=update-auto-column.js.map
