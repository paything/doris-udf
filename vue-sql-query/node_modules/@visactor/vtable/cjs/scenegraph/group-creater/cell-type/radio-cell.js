"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createRadioCellGroup = void 0;

const group_1 = require("../../graphic/group"), vutils_1 = require("@visactor/vutils"), vrender_1 = require("./../../../vrender"), get_hierarchy_offset_1 = require("../../utils/get-hierarchy-offset"), helper_1 = require("../../../tools/helper"), get_prop_1 = require("../../utils/get-prop"), cell_border_stroke_width_1 = require("../../utils/cell-border-stroke-width");

function createRadioCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, table, cellTheme, define, range) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (!cellGroup) {
        const strokeArrayWidth = (0, cell_border_stroke_width_1.getCellBorderStrokeWidth)(col, row, cellTheme, table);
        (cellGroup = new group_1.Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup);
    }
    const {width: radioWidth, height: radioHeight} = createRadio(col, row, colWidth, width, height, padding, cellTheme, define, cellGroup, range, table);
    return width -= padding[1] + padding[3], height -= padding[0] + padding[2], cellGroup.forEachChildren((radioComponent => {
        "center" === textAlign ? radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x + (width - radioWidth) / 2) : "right" === textAlign ? radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x + width - radioWidth) : radioComponent.setAttribute("x", padding[3] + radioComponent.attribute.x), 
        "middle" === textBaseline ? radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y + (height - radioHeight) / 2) : "bottom" === textBaseline ? radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y + height - radioHeight) : radioComponent.setAttribute("y", padding[0] + radioComponent.attribute.y);
    })), cellGroup;
}

function createRadio(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, cellGroup, range, table) {
    var _a, _b, _c, _d;
    const style = table._getCellStyle(col, row);
    let size = (0, get_prop_1.getProp)("size", style, col, row, table), innerRadius = (0, 
    get_prop_1.getProp)("innerRadius", style, col, row, table), outerRadius = (0, get_prop_1.getProp)("outerRadius", style, col, row, table);
    const spaceBetweenTextAndIcon = (0, get_prop_1.getProp)("spaceBetweenTextAndIcon", style, col, row, table), spaceBetweenRadio = (0, 
    get_prop_1.getProp)("spaceBetweenRadio", style, col, row, table), defaultFill = (0, 
    get_prop_1.getProp)("defaultFill", style, col, row, table), defaultStroke = (0, 
    get_prop_1.getProp)("defaultStroke", style, col, row, table), disableFill = (0, 
    get_prop_1.getProp)("disableFill", style, col, row, table), checkedFill = (0, get_prop_1.getProp)("checkedFill", style, col, row, table), checkedStroke = (0, 
    get_prop_1.getProp)("checkedStroke", style, col, row, table), disableCheckedFill = (0, 
    get_prop_1.getProp)("disableCheckedFill", style, col, row, table), disableCheckedStroke = (0, 
    get_prop_1.getProp)("disableCheckedStroke", style, col, row, table);
    (0, vutils_1.isNumber)(outerRadius) ? size = 2 * outerRadius : outerRadius = Math.round(size / 2), 
    (!(0, vutils_1.isNumber)(innerRadius) || innerRadius < 0) && (innerRadius = Math.round(outerRadius / 7 * 3));
    const value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row), hierarchyOffset = (0, 
    get_hierarchy_offset_1.getHierarchyOffset)(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, {lineClamp: lineClamp} = cellStyle, autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
        maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
        textAlign: "left",
        textBaseline: "top",
        autoWrapText: autoWrapText,
        lineClamp: lineClamp,
        wordBreak: "break-word",
        heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
        pickable: !1,
        dx: hierarchyOffset
    }, radioAttributes = {
        x: 0,
        y: 0,
        text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
        circle: {
            innerRadius: innerRadius,
            outerRadius: outerRadius
        },
        spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
    };
    defaultFill && (radioAttributes.circle.fill = defaultFill), defaultStroke && (radioAttributes.circle.stroke = defaultStroke), 
    disableFill && (radioAttributes.circle.disableFill = disableFill), checkedFill && (radioAttributes.circle.checkedFill = checkedFill), 
    checkedStroke && (radioAttributes.circle.checkedStroke = checkedStroke), disableCheckedFill && (radioAttributes.circle.disableCheckedFill = disableCheckedFill), 
    disableCheckedStroke && (radioAttributes.circle.disableCheckedStroke = disableCheckedStroke);
    let width = 0, height = 0;
    const direction = null !== (_b = define.radioDirectionInCell) && void 0 !== _b ? _b : "vertical";
    if ((0, vutils_1.isArray)(value)) value.forEach(((item, index) => {
        var _a, _b;
        const radioComponent = createSingleRadio(item, dataValue, index, col, row, define, autoWrapText, radioAttributes, table);
        radioComponent && cellGroup.appendChild(radioComponent), radioComponent.id = `radio-${null !== (_a = null == range ? void 0 : range.start.col) && void 0 !== _a ? _a : col}-${null !== (_b = null == range ? void 0 : range.start.row) && void 0 !== _b ? _b : row}-${index}`, 
        radioComponent.render();
        const bounds = radioComponent.AABBBounds;
        "vertical" === direction ? (radioComponent.setAttribute("y", height), height += bounds.height() + (index !== value.length - 1 ? spaceBetweenRadio : 0), 
        width = Math.max(width, bounds.width())) : "horizontal" === direction && (radioComponent.setAttribute("x", width), 
        width += bounds.width() + (index !== value.length - 1 ? spaceBetweenRadio : 0), 
        height = Math.max(height, bounds.height()));
    })); else {
        const radioComponent = createSingleRadio(value, dataValue, void 0, col, row, define, autoWrapText, radioAttributes, table);
        radioComponent && cellGroup.appendChild(radioComponent), radioComponent.id = `radio-${null !== (_c = null == range ? void 0 : range.start.col) && void 0 !== _c ? _c : col}-${null !== (_d = null == range ? void 0 : range.start.row) && void 0 !== _d ? _d : row}`, 
        radioComponent.render();
        const bounds = radioComponent.AABBBounds;
        width = bounds.width(), height = bounds.height();
    }
    return {
        width: width,
        height: height
    };
}

function createSingleRadio(value, dataValue, indexInCell, col, row, define, autoWrapText, cellRadioAttributes, table) {
    const isChecked = getChecked(value, dataValue, indexInCell, col, row, define, table), isDisabled = getDisable(value, dataValue, col, row, define, table), text = (0, 
    vutils_1.isObject)(value) ? value.text : (0, vutils_1.isBoolean)(value) ? "" : null != value ? value : "", radioAttributes = (0, 
    vutils_1.merge)({}, cellRadioAttributes, {
        checked: isChecked,
        disabled: isDisabled,
        text: {
            text: 1 === text.length ? text[0] : text,
            whiteSpace: 1 !== text.length || autoWrapText ? "normal" : "no-wrap"
        },
        boundsPadding: 0
    }), radio = new vrender_1.Radio(radioAttributes);
    return radio.name = "radio", radio;
}

function getChecked(value, dataValue, indexInCell, col, row, define, table) {
    var _a, _b;
    const radioType = null !== (_a = define.radioCheckType) && void 0 !== _a ? _a : "column";
    let isChecked, globalChecked;
    return (0, vutils_1.isObject)(value) ? isChecked = value.checked : "boolean" == typeof value && (isChecked = value), 
    isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, isChecked), 
    null != isChecked && "function" != typeof isChecked || (globalChecked = (0, helper_1.getOrApply)(define.checked, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, globalChecked)), 
    null !== (_b = null != isChecked ? isChecked : globalChecked) && void 0 !== _b && _b;
}

function getDisable(value, dataValue, col, row, define, table) {
    var _a;
    let isDisabled;
    (0, vutils_1.isObject)(value) && (isDisabled = value.disable);
    const globalDisable = (0, helper_1.getOrApply)(define.disable, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    });
    return null !== (_a = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _a && _a;
}

exports.createRadioCellGroup = createRadioCellGroup;
//# sourceMappingURL=radio-cell.js.map
