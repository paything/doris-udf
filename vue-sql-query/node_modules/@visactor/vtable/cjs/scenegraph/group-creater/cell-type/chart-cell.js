"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createChartCellGroup = void 0;

const group_1 = require("../../graphic/group"), chart_1 = require("../../graphic/chart"), registerChartTypes = __importStar(require("../../../chartModule")), get_prop_1 = require("../../utils/get-prop"), vutils_1 = require("@visactor/vutils"), cell_border_stroke_width_1 = require("../../utils/cell-border-stroke-width");

function createChartCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, dataValue, chartModule, chartSpec, chartInstance, dataId, table, cellTheme, isShareChartSpec, isAsync, isNoChartDataRenderNothing) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const ClassType = registerChartTypes.get()[chartModule], headerStyle = table._getCellStyle(col, row), functionalPadding = (0, 
    get_prop_1.getFunctionalProp)("padding", headerStyle, col, row, table);
    if ((0, vutils_1.isValid)(functionalPadding) && (padding = functionalPadding), !cellGroup) {
        const strokeArrayWidth = (0, cell_border_stroke_width_1.getCellBorderStrokeWidth)(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new group_1.Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    if (cellGroup.AABBBounds.width(), isNoChartDataRenderNothing && Array.isArray(table.getCellValue(col, row)) || !isNoChartDataRenderNothing) {
        const chartGroup = new chart_1.Chart(isShareChartSpec, {
            stroke: !1,
            x: padding[3],
            y: padding[0],
            canvas: null !== (_0 = table.canvas) && void 0 !== _0 ? _0 : table.scenegraph.stage.window.getContext().canvas,
            mode: table.options.mode,
            modeParams: table.options.modeParams,
            spec: table.options.specTransformInCell ? table.options.specTransformInCell(chartSpec, col, row) : chartSpec,
            ClassType: ClassType,
            width: width - padding[3] - padding[1],
            height: height - padding[2] - padding[0],
            chartInstance: chartInstance,
            dataId: dataId,
            data: table.getCellValue(col, row) || [],
            cellPadding: padding,
            dpr: table.internalProps.pixelRatio,
            axes: table.isPivotChart() ? table.internalProps.layoutMap.getChartAxes(col, row) : [],
            tableChartOption: table.options.chartOption,
            col: col,
            row: row
        });
        cellGroup.appendChild(chartGroup), table.internalProps.layoutMap.setChartInstance(col, row, chartGroup.chartInstance);
    }
    return cellGroup;
}

exports.createChartCellGroup = createChartCellGroup;
//# sourceMappingURL=chart-cell.js.map
