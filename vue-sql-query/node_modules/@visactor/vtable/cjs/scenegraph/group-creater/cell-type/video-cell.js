"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createVideoCellGroup = void 0;

const vrender_1 = require("./../../../vrender"), icons = __importStar(require("../../../icons")), group_1 = require("../../graphic/group"), keep_aspect_ratio_1 = require("../../utils/keep-aspect-ratio"), icon_1 = require("../../graphic/icon"), cell_pos_1 = require("../../utils/cell-pos"), image_cell_1 = require("./image-cell"), get_prop_1 = require("../../utils/get-prop"), vutils_1 = require("@visactor/vutils"), cell_border_stroke_width_1 = require("../../utils/cell-border-stroke-width"), padding_1 = require("../../utils/padding"), text_icon_layout_1 = require("../../utils/text-icon-layout"), regedIcons = icons.get();

function createVideoCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
    const headerStyle = table._getCellStyle(col, row), functionalPadding = (0, get_prop_1.getFunctionalProp)("padding", headerStyle, col, row, table);
    (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.imageMargin) ? padding = (0, 
    padding_1.getQuadProps)(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.imageMargin) : (0, 
    vutils_1.isValid)(functionalPadding) && (padding = functionalPadding), (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textAlign) && (textAlign = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textAlign), 
    (null === (_e = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _e ? void 0 : _e.textBaseline) && (textBaseline = null === (_f = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _f ? void 0 : _f.textBaseline);
    const strokeArrayWidth = (0, cell_border_stroke_width_1.getCellBorderStrokeWidth)(col, row, cellTheme, table);
    let cellGroup, cellIcons;
    if (isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0), 
    cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth) && void 0 !== _h ? _h : void 0,
        fill: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.fill) && void 0 !== _k ? _k : void 0,
        stroke: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.stroke) && void 0 !== _m ? _m : void 0,
        strokeArrayWidth: strokeArrayWidth,
        strokeArrayColor: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.strokeArrayColor) && void 0 !== _p ? _p : void 0,
        cursor: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.cursor) && void 0 !== _r ? _r : void 0,
        lineDash: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineDash) && void 0 !== _t ? _t : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    })), cellGroup && "cell" === cellGroup.role || (cellGroup = new group_1.Group({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.lineWidth) && void 0 !== _v ? _v : void 0,
        fill: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.fill) && void 0 !== _x ? _x : void 0,
        stroke: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.stroke) && void 0 !== _z ? _z : void 0,
        strokeArrayWidth: strokeArrayWidth,
        strokeArrayColor: null !== (_1 = null === (_0 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _0 ? void 0 : _0.strokeArrayColor) && void 0 !== _1 ? _1 : void 0,
        cursor: null !== (_3 = null === (_2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _2 ? void 0 : _2.cursor) && void 0 !== _3 ? _3 : void 0,
        lineDash: null !== (_5 = null === (_4 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _4 ? void 0 : _4.lineDash) && void 0 !== _5 ? _5 : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), 
    mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), cellIcons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(cellIcons) && 0 !== cellIcons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = (0, 
        text_icon_layout_1.dealWithIconLayout)(cellIcons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        })), cellGroup._cellLeftIconWidth = cellLeftIconWidth, cellGroup._cellRightIconWidth = cellRightIconWidth;
    }
    const value = table.getCellValue(col, row), video = document.createElement("video");
    video.addEventListener("loadeddata", (() => {
        imageAutoSizing && (0, image_cell_1._adjustWidthHeight)(col, row, video.videoWidth, video.videoHeight, table.scenegraph, padding, cellGroup);
        const {width: cellWidth, height: cellHeight, isMerge: isMerge} = (0, image_cell_1.getCellRange)(cellGroup, table);
        if (keepAspectRatio) {
            const {width: videoWidth, height: videoHeight} = (0, keep_aspect_ratio_1.calcKeepAspectRatioSize)(video.videoWidth, video.videoHeight, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]), pos = (0, 
            cell_pos_1.calcStartPosition)(0, 0, cellWidth, cellHeight, videoWidth, videoHeight, textAlign, textBaseline, padding);
            image.setAttributes({
                width: videoWidth,
                height: videoHeight,
                x: pos.x,
                y: pos.y,
                dx: 0
            });
        } else image.setAttributes({
            x: padding[3],
            y: padding[0],
            width: cellWidth - padding[1] - padding[3],
            height: cellHeight - padding[2] - padding[0],
            dy: 0
        });
        isMerge && (0, image_cell_1.updateImageDxDy)(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
        const {width: width, height: height} = (0, image_cell_1.getCellRange)(cellGroup, table), iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2), anchorX = 0 + (width > image.attribute.width ? image.attribute.x - 0 + image.attribute.width / 2 : width / 2), anchorY = 0 + (height > image.attribute.height ? image.attribute.y - 0 + image.attribute.height / 2 : height / 2), imageGraphic = cellGroup.getChildByName("image", !0), {dx: dx, dy: dy} = imageGraphic.attribute, playIcon = new icon_1.Icon({
            x: anchorX - iconSize / 2,
            y: anchorY - iconSize / 2,
            width: iconSize,
            height: iconSize,
            image: regedIcons.play.svg,
            cursor: regedIcons.play.cursor,
            dx: dx,
            dy: dy
        });
        playIcon.name = "play-icon", cellGroup.appendChild(playIcon), table.scenegraph.updateNextFrame();
    })), video.onerror = () => {
        image.image = regedIcons.damage_pic.svg;
    }, video.src = value, video.setAttribute("preload", "auto");
    const image = (0, vrender_1.createImage)({
        x: padding[3],
        y: padding[0],
        width: width - padding[1] - padding[3],
        height: height - padding[2] - padding[0],
        image: video,
        cursor: "pointer"
    });
    return image.name = "image", image.keepAspectRatio = keepAspectRatio, image.textAlign = textAlign, 
    image.textBaseline = textBaseline, cellGroup.appendChild(image), cellGroup;
}

exports.createVideoCellGroup = createVideoCellGroup;
//# sourceMappingURL=video-cell.js.map
