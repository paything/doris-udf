"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createSwitchCellGroup = void 0;

const vrender_1 = require("./../../../vrender"), group_1 = require("../../graphic/group"), cell_border_stroke_width_1 = require("../../utils/cell-border-stroke-width"), get_prop_1 = require("../../utils/get-prop"), vutils_1 = require("@visactor/vutils"), helper_1 = require("../../../tools/helper"), get_hierarchy_offset_1 = require("../../utils/get-hierarchy-offset"), text_icon_layout_1 = require("../../utils/text-icon-layout");

function createSwitchCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (!cellGroup) {
        const strokeArrayWidth = (0, cell_border_stroke_width_1.getCellBorderStrokeWidth)(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new group_1.Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    let icons;
    if (mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), icons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(icons) && 0 !== icons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = (0, 
        text_icon_layout_1.dealWithIconLayout)(icons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        }));
    }
    const switchComponent = createSwitch(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
    return switchComponent && cellGroup.appendChild(switchComponent), switchComponent.render(), 
    width -= padding[1] + padding[3] + iconWidth, height -= padding[0] + padding[2], 
    "center" === textAlign ? switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - switchComponent.AABBBounds.width()) / 2) : "right" === textAlign ? switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - switchComponent.AABBBounds.width()) : switchComponent.setAttribute("x", padding[3] + cellLeftIconWidth), 
    "middle" === textBaseline ? switchComponent.setAttribute("y", padding[0] + (height - switchComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? switchComponent.setAttribute("y", padding[0] + height - switchComponent.AABBBounds.height()) : switchComponent.setAttribute("y", padding[0]), 
    cellGroup;
}

function createSwitch(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
    var _a, _b, _c, _d;
    const style = table._getCellStyle(col, row), spaceBetweenTextAndCircle = (0, get_prop_1.getProp)("spaceBetweenTextAndCircle", style, col, row, table), circleRadius = (0, 
    get_prop_1.getProp)("circleRadius", style, col, row, table), boxWidth = (0, get_prop_1.getProp)("boxWidth", style, col, row, table), boxHeight = (0, 
    get_prop_1.getProp)("boxHeight", style, col, row, table), checkedFill = (0, get_prop_1.getProp)("checkedFill", style, col, row, table), uncheckedFill = (0, 
    get_prop_1.getProp)("uncheckedFill", style, col, row, table), disableCheckedFill = (0, 
    get_prop_1.getProp)("disableCheckedFill", style, col, row, table), disableUncheckedFill = (0, 
    get_prop_1.getProp)("disableUncheckedFill", style, col, row, table), circleFill = (0, 
    get_prop_1.getProp)("circleFill", style, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row);
    let isChecked, isDisabled, text = null !== (_a = value) && void 0 !== _a ? _a : "";
    (0, vutils_1.isObject)(value) ? (isChecked = value.checked, isDisabled = value.disable, 
    text = null !== (_b = value.text) && void 0 !== _b ? _b : "") : "boolean" == typeof value && (isChecked = value, 
    text = ""), isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
    const hierarchyOffset = (0, get_hierarchy_offset_1.getHierarchyOffset)(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_c = cellStyle.autoWrapText) && void 0 !== _c ? _c : table.internalProps.autoWrapText, {lineClamp: lineClamp} = cellStyle, {checked: checked, disable: disable, uncheckedText: uncheckedText, checkedText: checkedText} = define;
    if (null == isChecked || "function" == typeof isChecked) {
        const globalChecked = (0, helper_1.getOrApply)(checked, {
            col: col,
            row: row,
            table: table,
            context: null,
            value: value,
            dataValue: dataValue
        });
        isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
    }
    const globalDisable = (0, helper_1.getOrApply)(disable, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), checkedTextString = (0, helper_1.getOrApply)(checkedText, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), uncheckedTextString = (0, helper_1.getOrApply)(uncheckedText, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
        text: 1 === text.length ? text[0] : text,
        maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - 2 * circleRadius - spaceBetweenTextAndCircle,
        textAlign: "left",
        textBaseline: "top",
        autoWrapText: autoWrapText,
        lineClamp: lineClamp,
        wordBreak: "break-word",
        heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
        pickable: !1,
        dx: hierarchyOffset,
        whiteSpace: 1 !== text.length || autoWrapText ? "normal" : "no-wrap",
        checkedText: checkedTextString,
        uncheckedText: uncheckedTextString
    }, switchAttributes = {
        x: 0,
        y: 0,
        text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
        circle: {
            radius: circleRadius
        },
        box: {
            width: boxWidth,
            height: boxHeight
        },
        spaceBetweenTextAndCircle: spaceBetweenTextAndCircle,
        disabled: null !== (_d = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _d && _d
    };
    switchAttributes.checked = isChecked, uncheckedFill && (switchAttributes.box.uncheckedFill = uncheckedFill), 
    disableUncheckedFill && (switchAttributes.box.disableUncheckedFill = disableUncheckedFill), 
    checkedFill && (switchAttributes.box.checkedFill = checkedFill), disableCheckedFill && (switchAttributes.box.disableCheckedFill = disableCheckedFill), 
    circleFill && (switchAttributes.circle.fill = circleFill);
    const switchComponent = new vrender_1.Switch(switchAttributes);
    return switchComponent.name = "switch", switchComponent;
}

exports.createSwitchCellGroup = createSwitchCellGroup;
//# sourceMappingURL=switch-cell.js.map
