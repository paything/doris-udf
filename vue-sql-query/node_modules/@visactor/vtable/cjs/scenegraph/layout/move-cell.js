"use strict";

function moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, table) {
    const scene = table.scenegraph;
    for (let col = updateColStart; col <= updateColEnd; col++) {
        const columnWidth = table.getColWidth(col), columnHeaderGroup = table.scenegraph.getColGroup(col, !0), columnGroup = table.scenegraph.getColGroup(col), columnBottomGroup = table.scenegraph.getColGroupInBottom(col), columnLeftBottomGroup = table.scenegraph.getColGroupInLeftBottomCorner(col), columnRightBottomGroup = table.scenegraph.getColGroupInRightBottomCorner(col);
        columnHeaderGroup && (columnHeaderGroup.setAttribute("width", columnWidth), columnHeaderGroup.forEachChildren((child => {
            child.setAttribute("width", columnWidth);
        }))), columnGroup && (columnGroup.setAttribute("width", columnWidth), columnGroup.forEachChildren((child => {
            child.setAttribute("width", columnWidth);
        }))), columnBottomGroup && (columnBottomGroup.setAttribute("width", columnWidth), 
        columnBottomGroup.forEachChildren((child => {
            child.setAttribute("width", columnWidth);
        }))), columnRightBottomGroup && (columnRightBottomGroup.setAttribute("width", columnWidth), 
        columnRightBottomGroup.forEachChildren((child => {
            child.setAttribute("width", columnWidth);
        }))), columnLeftBottomGroup && (columnLeftBottomGroup.setAttribute("width", columnWidth), 
        columnLeftBottomGroup.forEachChildren((child => {
            child.setAttribute("width", columnWidth);
        })));
    }
    if (scene.updateContainer(), "column" === moveType) for (let col = updateColStart; col <= updateColEnd; col++) {
        const columnGroup = table.scenegraph.getColGroup(col);
        null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
        for (let row = 0; row <= table.frozenRowCount - 1; row++) scene.updateCellContent(col, row);
        for (let row = scene.bodyRowStart; row <= scene.bodyRowEnd; row++) scene.updateCellContent(col, row);
        for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) scene.updateCellContent(col, row);
    } else {
        for (let col = 0; col <= table.frozenColCount - 1; col++) {
            const columnGroup = table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
        }
        for (let col = scene.bodyColStart; col <= scene.bodyColEnd; col++) {
            const columnGroup = table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
        }
        for (let col = table.colCount - table.rightFrozenColCount; col <= table.colCount - 1; col++) {
            const columnGroup = table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = updateRowStart; row <= updateRowEnd; row++) scene.updateCellContent(col, row);
        }
    }
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.moveHeaderPosition = void 0, exports.moveHeaderPosition = moveHeaderPosition;
//# sourceMappingURL=move-cell.js.map
