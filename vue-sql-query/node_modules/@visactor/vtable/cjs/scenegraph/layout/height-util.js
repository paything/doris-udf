"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.computeButtonCellHeight = exports.computeSwitchCellHeight = exports.computeSingleRadioCellHeight = exports.computeRadioCellHeight = exports.computeCheckboxCellHeight = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../../tools/util"), get_prop_1 = require("../utils/get-prop"), vrender_1 = require("./../../vrender"), utilCheckBoxMark = new vrender_1.CheckBox({}), utilRadioMark = new vrender_1.Radio({}), utilButtonMark = new vrender_1.Tag({});

function computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = (0, vutils_1.isObject)(cellValue) ? cellValue.text : cellValue, lines = (0, 
    util_1.validToString)(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = (0, 
    get_prop_1.getProp)("size", actStyle, col, row, table);
    let maxHeight = 0;
    if (autoWrapText) {
        const spaceBetweenTextAndIcon = (0, get_prop_1.getProp)("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - size - spaceBetweenTextAndIcon;
        utilCheckBoxMark.setAttributes({
            text: {
                maxLineWidth: maxLineWidth,
                text: lines,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            icon: {
                width: Math.floor(size / 1.4),
                height: Math.floor(size / 1.4)
            },
            box: {
                width: size,
                height: size
            },
            spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
        }), utilCheckBoxMark.render(), maxHeight = utilCheckBoxMark.AABBBounds.height();
    } else maxHeight = Math.max(size, lines.length * lineHeight);
    return maxHeight;
}

function computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    var _a;
    if ((0, vutils_1.isArray)(cellValue)) {
        let maxHeight = 0;
        const define = table.getBodyColumnDefine(col, row), spaceBetweenRadio = (0, get_prop_1.getProp)("spaceBetweenRadio", actStyle, col, row, table), radioDirectionInCell = null !== (_a = null == define ? void 0 : define.radioDirectionInCell) && void 0 !== _a ? _a : "vertical";
        return "vertical" === radioDirectionInCell ? cellValue.forEach(((singleValue, index) => {
            const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
            maxHeight += height, index !== cellValue.length - 1 && (maxHeight += spaceBetweenRadio);
        })) : "horizontal" === radioDirectionInCell && cellValue.forEach((singleValue => {
            const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
            maxHeight = Math.max(height, maxHeight);
        })), maxHeight;
    }
    return computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
}

function computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = (0, vutils_1.isObject)(cellValue) ? cellValue.text : cellValue, lines = (0, 
    util_1.validToString)(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = (0, 
    get_prop_1.getProp)("size", actStyle, col, row, table);
    let outerRadius = (0, get_prop_1.getProp)("outerRadius", actStyle, col, row, table);
    const circleSize = (0, vutils_1.isNumber)(outerRadius) ? 2 * outerRadius : size;
    let maxHeight = 0;
    if (autoWrapText) {
        const spaceBetweenTextAndIcon = (0, get_prop_1.getProp)("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - circleSize - spaceBetweenTextAndIcon;
        (0, vutils_1.isNumber)(outerRadius) || (outerRadius = Math.round(size / 2)), utilRadioMark.setAttributes({
            text: {
                maxLineWidth: maxLineWidth,
                text: lines,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            circle: {
                outerRadius: outerRadius
            },
            spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
        }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
    } else maxHeight = Math.max(size, lines.length * lineHeight);
    return maxHeight;
}

function computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    return (0, get_prop_1.getProp)("boxWidth", actStyle, col, row, table);
}

function computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = (0, vutils_1.isObject)(cellValue) ? cellValue.text : cellValue, lines = (0, 
    util_1.validToString)(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), buttonPadding = (0, 
    get_prop_1.getProp)("buttonPadding", actStyle, col, row, table), buttonLineWidth = (0, 
    get_prop_1.getProp)("buttonLineWidth", actStyle, col, row, table);
    let maxHeight = 0;
    if (autoWrapText) {
        const maxLineWidth = cellWidth - (padding[1] + padding[3]);
        utilButtonMark.setAttributes({
            text: lines,
            textStyle: {
                maxLineWidth: maxLineWidth,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            padding: buttonPadding,
            panel: {
                visible: !0,
                fill: "red",
                stroke: "red",
                lineWidth: buttonLineWidth
            }
        }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
    } else maxHeight = lines.length * lineHeight + 2 * buttonPadding;
    return maxHeight;
}

exports.computeCheckboxCellHeight = computeCheckboxCellHeight, exports.computeRadioCellHeight = computeRadioCellHeight, 
exports.computeSingleRadioCellHeight = computeSingleRadioCellHeight, exports.computeSwitchCellHeight = computeSwitchCellHeight, 
exports.computeButtonCellHeight = computeButtonCellHeight;
//# sourceMappingURL=height-util.js.map
