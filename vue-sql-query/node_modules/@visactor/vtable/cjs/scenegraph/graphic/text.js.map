{"version":3,"sources":["../src/scenegraph/graphic/text.ts"],"names":[],"mappings":";;;AACA,2CAAmD;AAA1C,mGAAA,IAAI,OAAY","file":"text.js","sourcesContent":["export type { ITextGraphicAttribute, IWrapTextGraphicAttribute } from './../../vrender';\nexport { Text as WrapText } from './../../vrender';\n// import { getTheme, graphicUtil, Text, CanvasTextLayout, textDrawOffsetX, textLayoutOffsetY } from '@src/vrender';\n// import type { Bounds } from '@visactor/vutils';\n// import { textMeasure } from '../utils/measure-text';\n\n/* WrapText功能/dist/core/contributions/textMeasure/layout\n * 1. 按照宽度限制自动折行或显示省略号\n * 2. 高度限制控制显示内容及省略号\n */\n\n// const WRAP_TEXT_UPDATE_TAG_KEY = ['heightLimit', 'lineClamp', 'autoWrapText'];\n\n// export interface IWrapTextGraphicAttribute extends ITextGraphicAttribute {\n//   // widthLimit: number;\n//   heightLimit?: number;\n//   lineClamp?: number;\n//   autoWrapText?: boolean;\n// }\n// export class WrapText extends Text {\n//   declare attribute: IWrapTextGraphicAttribute;\n\n//   // eslint-disable-next-line no-useless-constructor\n//   constructor(params: IWrapTextGraphicAttribute) {\n//     super(params);\n//   }\n\n//   /**\n//    * 计算单行文字的bounds，可以缓存长度以及截取的文字\n//    * @param text\n//    */\n//   updateSingallineAABBBounds(text: number | string) {\n//     const textTheme = getTheme(this).text;\n//     // const textMeasure = graphicUtil.textMeasure;\n//     let width: number;\n//     let str: string;\n//     const attribute = this.attribute;\n//     const {\n//       maxLineWidth = textTheme.maxLineWidth,\n//       ellipsis = textTheme.ellipsis,\n//       textAlign = textTheme.textAlign,\n//       textBaseline = textTheme.textBaseline,\n//       fontSize = textTheme.fontSize,\n//       fontFamily = textTheme.fontFamily,\n//       fontWeight = textTheme.fontWeight,\n//       stroke = textTheme.stroke,\n//       lineHeight = attribute.lineHeight ?? attribute.fontSize ?? textTheme.fontSize,\n//       lineWidth = textTheme.lineWidth\n//     } = attribute;\n\n//     if (!this.shouldUpdateShape() && this.cache) {\n//       width = this.cache.clipedWidth;\n//       const dx = textDrawOffsetX(textAlign, width);\n//       const dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);\n//       this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight);\n//       if (stroke) {\n//         this._AABBBounds.expand(lineWidth / 2);\n//       }\n//       return this._AABBBounds;\n//     }\n\n//     if (Number.isFinite(maxLineWidth)) {\n//       if (ellipsis) {\n//         const strEllipsis = (ellipsis === true ? textTheme.ellipsis : ellipsis) as string;\n//         const data = textMeasure.clipTextWithSuffix(\n//           text.toString(),\n//           { fontSize, fontFamily },\n//           maxLineWidth,\n//           strEllipsis\n//         );\n//         str = data.str;\n//         width = data.width;\n//       } else {\n//         const data = textMeasure.clipText(text.toString(), { fontSize, fontFamily }, maxLineWidth);\n//         str = data.str;\n//         width = data.width;\n//       }\n//       this.cache.clipedText = str;\n//       this.cache.clipedWidth = width;\n//       // todo 计算原本的宽度\n//     } else {\n//       width = textMeasure.measureTextWidth(text.toString(), { fontSize, fontFamily, fontWeight });\n//       this.cache.clipedText = text.toString();\n//       this.cache.clipedWidth = width;\n//     }\n//     this.clearUpdateShapeTag();\n\n//     const dx = textDrawOffsetX(textAlign, width);\n//     const dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);\n//     this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight);\n\n//     if (stroke) {\n//       this._AABBBounds.expand(lineWidth / 2);\n//     }\n\n//     return this._AABBBounds;\n//   }\n\n//   /**\n//    * 计算多行文字的bounds，缓存每行文字的布局位置\n//    * 自动折行params.text是数组，因此只重新updateMultilineAABBBounds\n//    * @param text\n//    */\n//   updateMultilineAABBBounds(text: (number | string)[]) {\n//     const textTheme = getTheme(this).text;\n//     const {\n//       fontFamily = textTheme.fontFamily,\n//       textAlign = textTheme.textAlign,\n//       fontWeight = textTheme.fontWeight,\n//       textBaseline = textTheme.textBaseline,\n//       fontSize = textTheme.fontSize,\n//       lineHeight = this.attribute.lineHeight ?? this.attribute.fontSize ?? textTheme.fontSize,\n//       ellipsis = textTheme.ellipsis,\n//       maxLineWidth,\n//       stroke = textTheme.stroke,\n//       lineWidth = textTheme.lineWidth,\n//       // widthLimit,\n//       heightLimit = -1,\n//       lineClamp = (textTheme as any).lineClamp,\n//       autoWrapText = (textTheme as any).autoWrapText\n//     } = this.attribute;\n\n//     if (!this.shouldUpdateShape() && this.cache?.layoutData) {\n//       const bbox = this.cache.layoutData.bbox;\n//       this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);\n//       if (stroke) {\n//         this._AABBBounds.expand(lineWidth / 2);\n//       }\n//       return this._AABBBounds;\n//     }\n\n//     // const textMeasure = graphicUtil.textMeasure;\n//     const layoutObj = new CanvasTextLayout(fontFamily, { fontSize, fontFamily }, textMeasure as any) as any;\n\n//     // layoutObj内逻辑\n//     const lines = text.map(l => l.toString()) as string[];\n//     const linesLayout: LayoutItemType[] = [];\n//     const bboxWH: [number, number] = [0, 0];\n\n//     let lineCountLimit = Infinity;\n//     if (heightLimit > 0) {\n//       lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1);\n//     }\n//     if (lineClamp) {\n//       // 处理行数限制\n//       lineCountLimit = Math.min(lineCountLimit, lineClamp);\n//     }\n\n//     if (!autoWrapText) {\n//       // 使用所有行中最长的作为lineWidth\n//       let lineWidth = 0;\n//       for (let i = 0, len = lines.length; i < len; i++) {\n//         // 判断是否超过高度限制\n//         if (i < lineCountLimit) {\n//           // 当前行为最后一行\n//           const clip = layoutObj.textMeasure.clipTextWithSuffix(\n//             lines[i],\n//             layoutObj.textOptions,\n//             maxLineWidth,\n//             ellipsis\n//           );\n//           linesLayout.push({\n//             str: clip.str,\n//             width: clip.width\n//           });\n//           lineWidth = Math.max(lineWidth, clip.width);\n//         }\n//       }\n//       bboxWH[0] = lineWidth;\n//     } else if (typeof maxLineWidth === 'number' && maxLineWidth !== Infinity) {\n//       // widthLimit > 0\n//       if (maxLineWidth > 0) {\n//         for (let i = 0; i < lines.length; i++) {\n//           const str = lines[i] as string;\n//           // // 测量当前行宽度\n//           // width = Math.min(\n//           //   layoutObj.textMeasure.measureTextWidth(str, layoutObj.textOptions),\n//           //   maxLineWidth\n//           // );\n\n//           // 判断是否超过高度限制\n//           if (i === lineCountLimit - 1) {\n//             // 当前行为最后一行\n//             const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis);\n//             linesLayout.push({\n//               str: clip.str,\n//               width: clip.width\n//             });\n//             break; // 不处理后续行\n//           }\n\n//           // 测量截断位置\n//           const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth);\n//           if (str !== '' && clip.str === '') {\n//             // 宽度限制不足一个字符，至少截取一个字符\n//             clip.str = str.substring(0, 1);\n//             clip.width = textMeasure.measureTextWidth(clip.str, { fontSize, fontFamily, fontWeight });\n//           }\n\n//           linesLayout.push({\n//             str: clip.str,\n//             width: clip.width\n//           });\n//           if (clip.str.length === str.length) {\n//             // 不需要截断\n//           } else {\n//             const newStr = str.substring(clip.str.length);\n//             lines.splice(i + 1, 0, newStr);\n//           }\n//         }\n//       }\n//       // bboxWH[0] = maxLineWidth;\n//       let maxWidth = 0;\n//       linesLayout.forEach(layout => {\n//         maxWidth = Math.max(maxWidth, layout.width);\n//       });\n//       bboxWH[0] = maxWidth;\n//     } else {\n//       // 使用所有行中最长的作为lineWidth\n//       let lineWidth = 0;\n//       let width: number;\n//       let text: string;\n//       for (let i = 0, len = lines.length; i < len; i++) {\n//         // 判断是否超过高度限制\n//         if (i === lineCountLimit - 1) {\n//           // 当前行为最后一行\n//           const clip = layoutObj.textMeasure.clipTextWithSuffix(\n//             lines[i],\n//             layoutObj.textOptions,\n//             maxLineWidth,\n//             ellipsis\n//           );\n//           linesLayout.push({\n//             str: clip.str,\n//             width: clip.width\n//           });\n//           lineWidth = Math.max(lineWidth, clip.width);\n//           break; // 不处理后续行\n//         }\n\n//         text = lines[i] as string;\n//         width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions);\n//         lineWidth = Math.max(lineWidth, width);\n//         linesLayout.push({ str: text, width });\n//       }\n//       bboxWH[0] = lineWidth;\n//     }\n//     bboxWH[1] = linesLayout.length * lineHeight;\n\n//     const bbox = {\n//       xOffset: 0,\n//       yOffset: 0,\n//       width: bboxWH[0],\n//       height: bboxWH[1]\n//     };\n\n//     layoutObj.LayoutBBox(bbox, textAlign, textBaseline as any);\n\n//     const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline as any, lineHeight);\n\n//     // const layoutData = layoutObj.GetLayoutByLines(\n//     //   text,\n//     //   textAlign,\n//     //   textBaseline as any,\n//     //   lineHeight,\n//     //   ellipsis === true ? (DefaultTextAttribute.ellipsis as string) : ellipsis || undefined,\n//     //   maxLineWidth\n//     // );\n//     // const { bbox } = layoutData;\n//     this.cache.layoutData = layoutData;\n//     this.clearUpdateShapeTag();\n//     this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);\n\n//     if (stroke) {\n//       this._AABBBounds.expand(lineWidth / 2);\n//     }\n\n//     return this._AABBBounds;\n//   }\n\n//   needUpdateTags(keys: string[]): boolean {\n//     for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n//       const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];\n//       if (keys.indexOf(attrKey) !== -1) {\n//         return true;\n//       }\n//     }\n//     return super.needUpdateTags(keys);\n//   }\n//   needUpdateTag(key: string): boolean {\n//     for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n//       const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];\n//       if (key === attrKey) {\n//         return true;\n//       }\n//     }\n//     return super.needUpdateTag(key);\n//   }\n// }\n"]}