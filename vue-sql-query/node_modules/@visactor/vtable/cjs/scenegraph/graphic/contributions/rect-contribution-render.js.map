{"version":3,"sources":["../src/scenegraph/graphic/contributions/rect-contribution-render.ts"],"names":[],"mappings":"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","file":"rect-contribution-render.js","sourcesContent":["import type {\n  IRect,\n  IContext2d,\n  IRectGraphicAttribute,\n  IMarkAttribute,\n  IGraphicAttribute,\n  IThemeAttribute,\n  IRectRenderContribution,\n  IGroup,\n  IGroupGraphicAttribute,\n  IDrawContext,\n  ICustomPath2D\n} from './../../../vrender';\nimport { BaseRenderContributionTime, injectable } from './../../../vrender';\nimport { getWidthInfo, renderStroke } from './group-contribution-render';\nimport type { BaseTableAPI } from '../../../ts-types/base-table';\nimport type { vec2, vec4 } from '@visactor/vutils';\nimport { abs, arrayEqual, halfPi, isArray, isNumber, pi } from '@visactor/vutils';\nimport { createRectPath } from './../../../vrender';\n\n@injectable()\nexport class SplitRectBeforeRenderContribution implements IRectRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.beforeFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    rect: IRect,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    rectAttribute: Required<IRectGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    doFillOrStroke?: { doFill: boolean; doStroke: boolean }\n  ) {\n    // const { stroke = rectAttribute.stroke } = group.attribute as any;\n\n    // if (Array.isArray(stroke)) {\n    //   doFillOrStroke.doStroke = false;\n    // }\n\n    const {\n      stroke = rectAttribute.stroke,\n      strokeArrayWidth = (rectAttribute as any).strokeArrayWidth,\n      strokeArrayColor = (rectAttribute as any).strokeArrayColor\n    } = rect.attribute as any;\n\n    if (stroke && (Array.isArray(stroke) || Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor))) {\n      doFillOrStroke.doStroke = false;\n    }\n  }\n}\n\n@injectable()\nexport class SplitRectAfterRenderContribution implements IRectRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    rect: IRect,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    rectAttribute: Required<IRectGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    // const {\n    //   width = rectAttribute.width,\n    //   height = rectAttribute.height,\n    //   stroke = rectAttribute.stroke\n    // } = group.attribute as any;\n\n    // if (!Array.isArray(stroke)) {\n    //   return;\n    // }\n\n    // context.setStrokeStyle(group, group.attribute, x, y, rectAttribute);\n    // // 单独处理每条边界，目前不考虑圆角\n    // context.beginPath();\n    // context.moveTo(x, y);\n    // // top\n    // if (stroke[0]) {\n    //   context.lineTo(x + width, y);\n    // } else {\n    //   context.moveTo(x + width, y);\n    // }\n    // // right\n    // if (stroke[1]) {\n    //   context.lineTo(x + width, y + height);\n    // } else {\n    //   context.moveTo(x + width, y + height);\n    // }\n    // // bottom\n    // if (stroke[2]) {\n    //   context.lineTo(x, y + height);\n    // } else {\n    //   context.moveTo(x, y + height);\n    // }\n    // // left\n    // if (stroke[3]) {\n    //   // 没有close path是，起点和终点不连续，需要调整y保证不出现缺口\n    //   const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;\n    //   context.lineTo(x, adjustY);\n    // } else {\n    //   context.moveTo(x, y);\n    // }\n\n    // context.stroke();\n\n    const {\n      width = rectAttribute.width,\n      height = rectAttribute.height,\n      // 基础border\n      stroke = rectAttribute.stroke,\n      strokeArrayColor = (rectAttribute as any).strokeArrayColor,\n      strokeArrayWidth = (rectAttribute as any).strokeArrayWidth,\n\n      lineWidth = rectAttribute.lineWidth,\n      strokeColor = rectAttribute.stroke,\n\n      cornerRadius = rectAttribute.cornerRadius\n      // // select & hover border\n      // highlightStroke = (rectAttribute as any).highlightStroke,\n      // highlightStrokeArrayColor = (rectAttribute as any).highlightStrokeArrayColor,\n      // highlightStrokeArrayWidth = (rectAttribute as any).highlightStrokeArrayWidth,\n      // highlightStrokeArrayPart = (rectAttribute as any).highlightStrokeArrayPart,\n    } = rect.attribute as any;\n\n    if (!stroke || (!Array.isArray(strokeArrayWidth) && lineWidth === 0)) {\n      return;\n    }\n\n    if (Array.isArray(stroke) || Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth)) {\n      // let dx = 0;\n      // let dy = 0;\n      const deltaWidth = 0;\n      const deltaHeight = 0;\n      if (\n        rect.name !== 'border-rect' && // border-rect not need offset\n        rect.name !== 'table-border-rect' && // table-border-rect not need offset\n        ((typeof lineWidth === 'number' && lineWidth & 1) ||\n          (Array.isArray(strokeArrayWidth) && strokeArrayWidth.some(width => width & 1)))\n      ) {\n        // const table = (rect.stage as any).table as BaseTableAPI;\n        // const bottomRight = table.theme.cellBorderClipDirection === 'bottom-right';\n        // if (bottomRight) {\n        //   x = Math.floor(x) - 0.5;\n        //   y = Math.floor(y) - 0.5;\n        //   deltaWidth = 0.5;\n        //   deltaHeight = 0.5;\n        // } else {\n        x = Math.floor(x) + 0.5;\n        y = Math.floor(y) + 0.5;\n        // }\n      }\n\n      // 带不同stroke边框\n      if (!(cornerRadius === 0 || (isArray(cornerRadius) && (<number[]>cornerRadius).every(num => num === 0)))) {\n        // let lastStrokeI = 0;\n        // let lastStroke: any;\n        context.beginPath();\n        // debugger;\n        createRectPath(\n          context,\n          x,\n          y,\n          width,\n          height,\n          cornerRadius,\n          true,\n          new Array(4).fill(0).map((_, i) => (x1: number, y1: number, x2: number, y2: number) => {\n            renderStrokeWithCornerRadius(\n              i,\n              x1,\n              y1,\n              x2,\n              y2,\n              rect,\n              context,\n              x,\n              y,\n              rectAttribute,\n              stroke,\n              strokeArrayWidth || lineWidth,\n              strokeArrayColor || strokeColor,\n              Math.ceil(width + deltaWidth),\n              Math.ceil(height + deltaHeight)\n            );\n          })\n        );\n\n        context.stroke();\n      } else {\n        renderStroke(\n          rect as IGroup,\n          context,\n          x,\n          y,\n          rectAttribute,\n          stroke,\n          strokeArrayWidth || lineWidth,\n          strokeArrayColor || strokeColor,\n          rect.name !== 'table-border-rect' ? Math.ceil(width + deltaWidth) : width + deltaWidth,\n          rect.name !== 'table-border-rect' ? Math.ceil(height + deltaHeight) : height + deltaHeight\n        );\n      }\n    }\n  }\n}\n\nexport function renderStrokeWithCornerRadius(\n  i: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  rect: IRect,\n  context: IContext2d,\n  x: number,\n  y: number,\n  rectAttribute: Required<IRectGraphicAttribute>,\n  stroke: any,\n  strokeArrayWidth: any,\n  strokeArrayColor: any,\n  width: number,\n  height: number\n) {\n  const group = rect;\n  const groupAttribute = rectAttribute;\n\n  // if (stroke[i]) {\n  //   if (!(lastStrokeI === i - 1 && stroke[i] === lastStroke)) {\n  //     context.setStrokeStyle(rect, { ...rect.attribute, stroke: stroke[i] }, x, y, rectAttribute);\n  //     context.beginPath();\n  //     context.moveTo(x1, y1);\n  //     lastStroke = stroke[i];\n  //   }\n  //   lastStrokeI = i;\n  //   context.lineTo(x2, y2);\n  //   context.stroke();\n  //   if (i === 3) {\n  //     context.beginPath();\n  //   }\n  // }\n\n  const widthInfo = getWidthInfo(strokeArrayWidth);\n  const isWidthNumber = !Array.isArray(strokeArrayWidth);\n  const isStrokeTrue = !Array.isArray(stroke);\n  const isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;\n  context.stroke(); // stroke last corner with last stroke style\n\n  context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute);\n  const { lineDash = groupAttribute.lineDash } = group.attribute as any;\n  // const lineDash = context.getLineDash();\n  let isDash = false;\n  if (lineDash.length && lineDash.some((dash: number[] | null) => Array.isArray(dash))) {\n    isDash = true;\n  }\n\n  // 单独处理每条边界，目前不考虑圆角\n  context.beginPath(); // clean path\n  context.moveTo(x, y);\n\n  const strokeTop = (isStrokeTrue || stroke[0]) && (isWidthNumber || strokeArrayWidth[0]);\n  const strokeRight = (isStrokeTrue || stroke[1]) && (isWidthNumber || strokeArrayWidth[1]);\n  const strokeBottom = (isStrokeTrue || stroke[2]) && (isWidthNumber || strokeArrayWidth[2]);\n  const strokeLeft = (isStrokeTrue || stroke[3]) && (isWidthNumber || strokeArrayWidth[3]);\n\n  // top\n  if (strokeTop && i === 0) {\n    // context.lineTo(x + width, y);\n    const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;\n    const deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;\n\n    // context.moveTo(x - deltaLeft, y);\n    // context.lineTo(x + width + deltaRight, y);\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    if (isSplitDraw || isDash) {\n      if (strokeArrayColor && strokeArrayColor[0]) {\n        context.strokeStyle = strokeArrayColor[0];\n      } else if (strokeArrayColor && !strokeArrayColor[0]) {\n        context.strokeStyle = 'transparent';\n      }\n      if (!isWidthNumber) {\n        context.lineWidth = strokeArrayWidth[0];\n      }\n      context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;\n      if (isDash) {\n        context.setLineDash(lineDash[0] ?? []);\n      }\n      context.stroke();\n      context.beginPath();\n      // context.moveTo(x + width, y);\n    }\n  } else if (i === 0) {\n    context.moveTo(x + width, y);\n  }\n  // right\n  if (strokeRight && i === 1) {\n    // context.lineTo(x + width, y + height);\n    const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;\n    const deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;\n\n    // context.moveTo(x + width, y - deltaTop);\n    // context.lineTo(x + width, y + height + deltaBottom);\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    if (isSplitDraw || isDash) {\n      if (strokeArrayColor && strokeArrayColor[1]) {\n        context.strokeStyle = strokeArrayColor[1];\n      } else if (strokeArrayColor && !strokeArrayColor[1]) {\n        context.strokeStyle = 'transparent';\n      }\n      if (!isWidthNumber) {\n        context.lineWidth = strokeArrayWidth[1];\n      }\n      context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;\n      if (isDash) {\n        context.setLineDash(lineDash[1] ?? []);\n      }\n      context.stroke();\n      context.beginPath();\n      context.moveTo(x + width, y + height);\n    }\n  } else if (i === 1) {\n    context.moveTo(x + width, y + height);\n  }\n  // bottom\n  if (strokeBottom && i === 2) {\n    // context.lineTo(x, y + height);\n    const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;\n    const deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;\n\n    // context.moveTo(x - deltaLeft, y + height);\n    // context.lineTo(x + width + deltaRight, y + height);\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    if (isSplitDraw || isDash) {\n      if (strokeArrayColor && strokeArrayColor[2]) {\n        context.strokeStyle = strokeArrayColor[2];\n      } else if (strokeArrayColor && !strokeArrayColor[2]) {\n        context.strokeStyle = 'transparent';\n      }\n      if (!isWidthNumber) {\n        context.lineWidth = strokeArrayWidth[2];\n      }\n      context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;\n      if (isDash) {\n        context.setLineDash(lineDash[2] ?? []);\n      }\n      context.stroke();\n      context.beginPath();\n      context.moveTo(x, y + height);\n    }\n  } else if (i === 2) {\n    context.moveTo(x, y + height);\n  }\n  // left\n  if (strokeLeft && i === 3) {\n    // context.lineTo(x, y);\n    const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;\n    const deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;\n\n    // context.moveTo(x, y - deltaTop);\n    // context.lineTo(x, y + height + deltaBottom);\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    if (isSplitDraw || isDash) {\n      if (strokeArrayColor && strokeArrayColor[3]) {\n        context.strokeStyle = strokeArrayColor[3];\n      } else if (strokeArrayColor && !strokeArrayColor[3]) {\n        context.strokeStyle = 'transparent';\n      }\n      if (!isWidthNumber) {\n        context.lineWidth = strokeArrayWidth[3];\n      }\n      context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;\n      if (isDash) {\n        context.setLineDash(lineDash[3] ?? []);\n      }\n      context.stroke();\n      context.beginPath();\n      context.moveTo(x, y);\n    }\n  } else if (i === 3) {\n    context.moveTo(x, y);\n  }\n  context.closePath();\n\n  if (!isSplitDraw && !isDash) {\n    // context.strokeStyle = strokeArrayColor;\n    if (!isWidthNumber && widthInfo.width) {\n      context.lineWidth = widthInfo.width;\n    }\n    context.stroke();\n  }\n  context.lineDashOffset = 0;\n  // context.lineCap = oldLineCap;\n  context.setLineDash([]);\n\n  context.beginPath(); // clean path\n}\n\ntype IEdgeCb = (x1: number, y1: number, x2: number, y2: number) => void;\n"]}