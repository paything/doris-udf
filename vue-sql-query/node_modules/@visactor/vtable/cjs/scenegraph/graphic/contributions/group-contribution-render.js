"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ClipBodyGroupBeforeRenderContribution = exports.AdjustColorGroupAfterRenderContribution = exports.AdjustColorGroupBeforeRenderContribution = exports.AdjustPosGroupAfterRenderContribution = exports.AdjustPosGroupBeforeRenderContribution = exports.DashGroupAfterRenderContribution = exports.DashGroupBeforeRenderContribution = exports.renderStroke = exports.getWidthInfo = exports.SplitGroupAfterRenderContribution = exports.SplitGroupBeforeRenderContribution = void 0;

const vrender_1 = require("./../../../vrender"), is_cell_hover_1 = require("../../../state/hover/is-cell-hover"), get_cell_merge_1 = require("../../utils/get-cell-merge"), ts_types_1 = require("../../../ts-types"), vutils_1 = require("@visactor/vutils"), is_cell_select_highlight_1 = require("../../../state/select/is-cell-select-highlight"), rect_contribution_render_1 = require("./rect-contribution-render");

let SplitGroupBeforeRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        const {stroke: stroke = groupAttribute.stroke, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor} = group.attribute;
        stroke && (Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor)) && (doFillOrStroke.doStroke = !1);
    }
};

SplitGroupBeforeRenderContribution = __decorate([ (0, vrender_1.injectable)() ], SplitGroupBeforeRenderContribution), 
exports.SplitGroupBeforeRenderContribution = SplitGroupBeforeRenderContribution;

let SplitGroupAfterRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        var _a, _b;
        const {stroke: stroke = groupAttribute.stroke, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth: lineWidth = groupAttribute.lineWidth, strokeColor: strokeColor = groupAttribute.stroke, cornerRadius: cornerRadius = groupAttribute.cornerRadius} = group.attribute;
        let widthForStroke, heightForStroke, {width: width = groupAttribute.width, height: height = groupAttribute.height} = group.attribute;
        if (stroke && (Array.isArray(strokeArrayWidth) || 0 !== lineWidth) && (Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth))) {
            if ("number" == typeof lineWidth && 1 & lineWidth || Array.isArray(strokeArrayWidth) && strokeArrayWidth.some((width => 1 & width))) {
                const table = group.stage.table;
                if (!table) return;
                const bottomRight = "bottom-right" === (null === (_a = null == table ? void 0 : table.theme) || void 0 === _a ? void 0 : _a.cellBorderClipDirection);
                if (bottomRight) {
                    if (x = Math.floor(x) - .5, y = Math.floor(y) - .5, "cell" === group.role) {
                        const col = group.col, row = group.row;
                        0 === col && (x += 1), 0 === row && (y += 1);
                    }
                } else x = Math.floor(x) + .5, y = Math.floor(y) + .5;
                (null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) && (width = Math.round(width), 
                height = Math.round(height));
                const {width: widthFroDraw, height: heightFroDraw} = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
                widthForStroke = widthFroDraw, heightForStroke = heightFroDraw;
            } else widthForStroke = Math.ceil(width), heightForStroke = Math.ceil(height);
            0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? renderStroke(group, context, x, y, groupAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke) : (context.beginPath(), 
            (0, vrender_1.createRectPath)(context, x, y, widthForStroke, heightForStroke, cornerRadius, !0, new Array(4).fill(0).map(((_, i) => (x1, y1, x2, y2) => {
                (0, rect_contribution_render_1.renderStrokeWithCornerRadius)(i, x1, y1, x2, y2, group, context, x, y, groupAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke);
            }))), context.stroke());
        }
    }
};

function getWidthInfo(widthArray) {
    if (!Array.isArray(widthArray)) return {
        isSplitDraw: !1,
        width: widthArray
    };
    let temp;
    for (let i = 0; i < widthArray.length; i++) {
        const width = widthArray[i];
        if (width) if (temp) {
            if (width !== temp) return {
                isSplitDraw: !0
            };
        } else temp = width;
    }
    return {
        isSplitDraw: !1,
        width: temp
    };
}

function renderStroke(group, context, x, y, groupAttribute, stroke, strokeArrayWidth, strokeArrayColor, width, height, isHighlight, part) {
    var _a, _b, _c, _d;
    const widthInfo = getWidthInfo(strokeArrayWidth), isWidthNumber = !Array.isArray(strokeArrayWidth), isStrokeTrue = !Array.isArray(stroke), isPart = Array.isArray(part), isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;
    context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
    const {lineDash: lineDash = groupAttribute.lineDash} = group.attribute;
    let isDash = !1;
    lineDash.length && lineDash.some((dash => Array.isArray(dash))) && (isDash = !0), 
    context.beginPath(), context.moveTo(x, y);
    const strokeTop = (isStrokeTrue || stroke[0]) && (isWidthNumber || strokeArrayWidth[0]), strokeRight = (isStrokeTrue || stroke[1]) && (isWidthNumber || strokeArrayWidth[1]), strokeBottom = (isStrokeTrue || stroke[2]) && (isWidthNumber || strokeArrayWidth[2]), strokeLeft = (isStrokeTrue || stroke[3]) && (isWidthNumber || strokeArrayWidth[3]);
    if (strokeTop) {
        const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2, deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
        isPart && Array.isArray(part[0]) ? (context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[0][0], y), 
        context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[0][1] - part[0][0]), y), 
        context.moveTo(x + width + deltaRight, y)) : (context.moveTo(x - deltaLeft, y), 
        context.lineTo(x + width + deltaRight, y)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[0] ? context.strokeStyle = strokeArrayColor[0] : strokeArrayColor && !strokeArrayColor[0] && (context.strokeStyle = "transparent"), 
        isWidthNumber || (context.lineWidth = strokeArrayWidth[0]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, 
        isDash && context.setLineDash(null !== (_a = lineDash[0]) && void 0 !== _a ? _a : []), 
        context.stroke(), context.beginPath(), context.moveTo(x + width, y));
    } else context.moveTo(x + width, y);
    if (strokeRight) {
        const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2, deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
        isPart && Array.isArray(part[1]) ? (context.moveTo(x + width, y - deltaTop + height * part[1][0]), 
        context.lineTo(x + width, y - deltaTop + (height + deltaTop + deltaBottom) * (part[1][1] - part[1][0])), 
        context.moveTo(x + width, y + height + deltaBottom)) : (context.moveTo(x + width, y - deltaTop), 
        context.lineTo(x + width, y + height + deltaBottom)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[1] ? context.strokeStyle = strokeArrayColor[1] : strokeArrayColor && !strokeArrayColor[1] && (context.strokeStyle = "transparent"), 
        isWidthNumber || (context.lineWidth = strokeArrayWidth[1]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, 
        isDash && context.setLineDash(null !== (_b = lineDash[1]) && void 0 !== _b ? _b : []), 
        context.stroke(), context.beginPath(), context.moveTo(x + width, y + height));
    } else context.moveTo(x + width, y + height);
    if (strokeBottom) {
        const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2, deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
        isPart && Array.isArray(part[2]) ? (context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[2][0], y + height), 
        context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[2][1] - part[2][0]), y + height), 
        context.moveTo(x - deltaLeft, y + height)) : (context.moveTo(x - deltaLeft, y + height), 
        context.lineTo(x + width + deltaRight, y + height)), (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[2] ? context.strokeStyle = strokeArrayColor[2] : strokeArrayColor && !strokeArrayColor[2] && (context.strokeStyle = "transparent"), 
        isWidthNumber || (context.lineWidth = strokeArrayWidth[2]), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, 
        isDash && context.setLineDash(null !== (_c = lineDash[2]) && void 0 !== _c ? _c : []), 
        context.stroke(), context.beginPath(), context.moveTo(x, y + height));
    } else context.moveTo(x, y + height);
    if (strokeLeft) {
        const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2, deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
        isPart && Array.isArray(part[3]) ? (context.moveTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * part[3][0]), 
        context.lineTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * (part[3][1] - part[3][0])), 
        context.moveTo(x, y - deltaTop)) : (context.moveTo(x, y - deltaTop), context.lineTo(x, y + height + deltaBottom)), 
        (isSplitDraw || isDash) && (strokeArrayColor && strokeArrayColor[3] ? context.strokeStyle = strokeArrayColor[3] : strokeArrayColor && !strokeArrayColor[3] && (context.strokeStyle = "transparent"), 
        isWidthNumber || (context.lineWidth = strokeArrayWidth[3]), context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, 
        isDash && context.setLineDash(null !== (_d = lineDash[3]) && void 0 !== _d ? _d : []), 
        context.stroke(), context.beginPath(), context.moveTo(x, y));
    } else context.moveTo(x, y);
    isSplitDraw || isDash || (!isWidthNumber && widthInfo.width && (context.lineWidth = widthInfo.width), 
    context.stroke()), context.lineDashOffset = 0, context.setLineDash([]);
}

SplitGroupAfterRenderContribution = __decorate([ (0, vrender_1.injectable)() ], SplitGroupAfterRenderContribution), 
exports.SplitGroupAfterRenderContribution = SplitGroupAfterRenderContribution, exports.getWidthInfo = getWidthInfo, 
exports.renderStroke = renderStroke;

let DashGroupBeforeRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        var _a;
        const {lineDash: lineDash = groupAttribute.lineDash, stroke: stroke = groupAttribute.stroke, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth} = group.attribute;
        stroke && Array.isArray(lineDash) && lineDash.length && (null === (_a = lineDash[0]) || void 0 === _a ? void 0 : _a.length) && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && (doFillOrStroke.doStroke = !1);
    }
};

DashGroupBeforeRenderContribution = __decorate([ (0, vrender_1.injectable)() ], DashGroupBeforeRenderContribution), 
exports.DashGroupBeforeRenderContribution = DashGroupBeforeRenderContribution;

let DashGroupAfterRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e, _f;
        const {lineDash: lineDash = groupAttribute.lineDash, stroke: stroke = groupAttribute.stroke, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth: lineWidth = groupAttribute.lineWidth} = group.attribute;
        if (!stroke || !(Array.isArray(lineDash) && lineDash.length && (null === (_a = lineDash[0]) || void 0 === _a ? void 0 : _a.length)) || Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth)) return;
        const table = group.stage.table;
        if (!table) return;
        const splitLineDash = (0, vutils_1.isArray)(lineDash[0]) ? getQuadLineDash(lineDash) : [ lineDash, lineDash, lineDash, lineDash ];
        let widthForStroke, heightForStroke, {width: width = groupAttribute.width, height: height = groupAttribute.height} = group.attribute;
        if ((null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b._disableColumnAndRowSizeRound) ? (width = Math.round(width), 
        height = Math.round(height)) : (width = Math.ceil(width), height = Math.ceil(height)), 
        1 & lineWidth) {
            const bottomRight = "bottom-right" === table.theme.cellBorderClipDirection, deltaWidth = 0, deltaHeight = 0;
            if (bottomRight) {
                if (x = Math.floor(x) - .5, y = Math.floor(y) - .5, "cell" === group.role) {
                    0 === group.col && (x += 1), 0 === group.row && (y += 1);
                }
            } else x = Math.floor(x) + .5, y = Math.floor(y) + .5;
            const {width: widthFroDraw, height: heightFroDraw} = getCellSizeForDraw(group, Math.ceil(width + deltaWidth), Math.ceil(height + deltaHeight), bottomRight);
            widthForStroke = widthFroDraw, heightForStroke = heightFroDraw;
        } else widthForStroke = Math.ceil(width), heightForStroke = Math.ceil(height);
        context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.beginPath(), 
        context.moveTo(x, y), context.lineTo(x + widthForStroke, y), context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, 
        context.setLineDash(null !== (_c = splitLineDash[0]) && void 0 !== _c ? _c : []), 
        context.stroke(), context.beginPath(), context.moveTo(x + widthForStroke, y), context.lineTo(x + widthForStroke, y + heightForStroke), 
        context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, context.setLineDash(null !== (_d = splitLineDash[1]) && void 0 !== _d ? _d : []), 
        context.stroke(), context.beginPath(), context.moveTo(x, y + heightForStroke), context.lineTo(x + widthForStroke, y + heightForStroke), 
        context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a, context.setLineDash(null !== (_e = splitLineDash[2]) && void 0 !== _e ? _e : []), 
        context.stroke(), context.beginPath(), context.moveTo(x, y), context.lineTo(x, y + heightForStroke), 
        context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d, context.setLineDash(null !== (_f = splitLineDash[3]) && void 0 !== _f ? _f : []), 
        context.stroke(), context.lineDashOffset = 0, context.setLineDash([]);
    }
};

DashGroupAfterRenderContribution = __decorate([ (0, vrender_1.injectable)() ], DashGroupAfterRenderContribution), 
exports.DashGroupAfterRenderContribution = DashGroupAfterRenderContribution;

let AdjustPosGroupBeforeRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        const {lineWidth: lineWidth = groupAttribute.lineWidth, stroke: stroke = groupAttribute.stroke, lineDash: lineDash = groupAttribute.lineDash, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos: notAdjustPos} = group.attribute;
        !0 !== notAdjustPos && stroke && Array.isArray(lineDash) && !lineDash.length && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && 1 & lineWidth && (doFillOrStroke.doStroke = !1);
    }
};

AdjustPosGroupBeforeRenderContribution = __decorate([ (0, vrender_1.injectable)() ], AdjustPosGroupBeforeRenderContribution), 
exports.AdjustPosGroupBeforeRenderContribution = AdjustPosGroupBeforeRenderContribution;

let AdjustPosGroupAfterRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        var _a, _b;
        const {lineWidth: lineWidth = groupAttribute.lineWidth, stroke: stroke = groupAttribute.stroke, lineDash: lineDash = groupAttribute.lineDash, strokeArrayWidth: strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor: strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos: notAdjustPos, cornerRadius: cornerRadius = groupAttribute.cornerRadius} = group.attribute;
        let {width: width = groupAttribute.width, height: height = groupAttribute.height} = group.attribute;
        if (!0 !== notAdjustPos && stroke && Array.isArray(lineDash) && !lineDash.length && !Array.isArray(strokeArrayColor) && !Array.isArray(strokeArrayWidth) && 1 & lineWidth) {
            const table = group.stage.table;
            if (!table) return;
            (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) && (width = Math.round(width), 
            height = Math.round(height)), context.beginPath();
            const bottomRight = "bottom-right" === (null === (_b = null == table ? void 0 : table.theme) || void 0 === _b ? void 0 : _b.cellBorderClipDirection), deltaWidth = 0, deltaHeight = 0;
            if (bottomRight) {
                if (x = Math.floor(x) - .5, y = Math.floor(y) - .5, "cell" === group.role) {
                    0 === group.col && (x += 1), 0 === group.row && (y += 1);
                }
            } else x = Math.floor(x) + .5, y = Math.floor(y) + .5;
            const {width: widthFroDraw, height: heightFroDraw} = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
            cornerRadius ? (0, vrender_1.createRectPath)(context, x, y, widthFroDraw + deltaWidth, heightFroDraw + deltaHeight, cornerRadius) : context.rect(x, y, widthFroDraw, heightFroDraw), 
            context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.stroke();
        }
    }
};

AdjustPosGroupAfterRenderContribution = __decorate([ (0, vrender_1.injectable)() ], AdjustPosGroupAfterRenderContribution), 
exports.AdjustPosGroupAfterRenderContribution = AdjustPosGroupAfterRenderContribution;

let AdjustColorGroupBeforeRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        if ("cell" === group.role) {
            const table = group.stage.table;
            if (table) {
                const selectColor = (0, is_cell_select_highlight_1.getCellSelectColor)(group, table);
                if (selectColor) group.attribute._vtableHightLightFill = selectColor; else if (table.stateManager.interactionState !== ts_types_1.InteractionState.scrolling) {
                    const hoverColor = (0, is_cell_hover_1.getCellHoverColor)(group, table);
                    hoverColor && (group.attribute._vtableHightLightFill = hoverColor);
                }
            }
        }
    }
};

AdjustColorGroupBeforeRenderContribution = __decorate([ (0, vrender_1.injectable)() ], AdjustColorGroupBeforeRenderContribution), 
exports.AdjustColorGroupBeforeRenderContribution = AdjustColorGroupBeforeRenderContribution;

let AdjustColorGroupAfterRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        if (group.attribute._vtableHightLightFill) if (fillCb) ; else if (fVisible) {
            const oldColor = group.attribute.fill;
            group.attribute.fill = group.attribute._vtableHightLightFill, context.setCommonStyle(group, group.attribute, x, y, groupAttribute), 
            context.fill(), group.attribute.fill = oldColor, group.attribute._vtableHightLightFill = void 0;
        }
    }
};

AdjustColorGroupAfterRenderContribution = __decorate([ (0, vrender_1.injectable)() ], AdjustColorGroupAfterRenderContribution), 
exports.AdjustColorGroupAfterRenderContribution = AdjustColorGroupAfterRenderContribution;

let ClipBodyGroupBeforeRenderContribution = class {
    constructor() {
        this.time = vrender_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, xOrigin, yOrigin, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        var _a, _b, _c, _d, _e, _f;
        const table = group.stage.table;
        if (table) if ("body" === group.role) {
            drawClipRect(context, -(null !== (_a = group.attribute.x) && void 0 !== _a ? _a : 0) + table.getFrozenColsWidth(), -(null !== (_b = group.attribute.y) && void 0 !== _b ? _b : 0) + table.getFrozenRowsHeight(), group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
        } else if ("row-header" === group.role) {
            drawClipRect(context, 0, -(null !== (_c = group.attribute.y) && void 0 !== _c ? _c : 0) + table.getFrozenRowsHeight(), table.getFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
        } else if ("col-header" === group.role) {
            drawClipRect(context, -(null !== (_d = group.attribute.x) && void 0 !== _d ? _d : 0) + table.getFrozenColsWidth(), 0, group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), table.getFrozenRowsHeight());
        } else if ("right-frozen" === group.role) {
            drawClipRect(context, 0, -(null !== (_e = group.attribute.y) && void 0 !== _e ? _e : 0) + table.getFrozenRowsHeight(), table.getRightFrozenColsWidth(), group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight());
        } else if ("bottom-frozen" === group.role) {
            drawClipRect(context, -(null !== (_f = group.attribute.x) && void 0 !== _f ? _f : 0) + table.getFrozenColsWidth(), 0, group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth(), table.getBottomFrozenRowsHeight());
        } else if ("corner-header" === group.role) {
            drawClipRect(context, 0, 0, table.getFrozenColsWidth(), table.getFrozenRowsHeight());
        } else if ("corner-right-top-header" === group.role) {
            drawClipRect(context, 0, 0, table.getRightFrozenColsWidth(), table.getFrozenRowsHeight());
        } else if ("corner-right-bottom-header" === group.role) {
            drawClipRect(context, 0, 0, table.getRightFrozenColsWidth(), table.getBottomFrozenRowsHeight());
        } else if ("corner-left-bottom-header" === group.role) {
            drawClipRect(context, 0, 0, table.getFrozenColsWidth(), table.getBottomFrozenRowsHeight());
        }
    }
};

ClipBodyGroupBeforeRenderContribution = __decorate([ (0, vrender_1.injectable)() ], ClipBodyGroupBeforeRenderContribution), 
exports.ClipBodyGroupBeforeRenderContribution = ClipBodyGroupBeforeRenderContribution;

const precision = Math.pow(2, 24);

function drawClipRect(context, x, y, width, height) {
    context.beginPath();
    const matrix = context.applyedMatrix;
    Math.abs(matrix.f) > precision || Math.abs(matrix.g) > precision ? context.rect(x - precision, y - precision, width + 2 * precision, height + 2 * precision) : context.rect(x, y, width, height);
}

function getCellSizeForDraw(group, width, height, bottomRight) {
    const table = group.stage.table;
    if (!table) return {
        width: width,
        height: height
    };
    if ("cell" === group.role) {
        let col = group.col, row = group.row;
        const mergeInfo = (0, get_cell_merge_1.getCellMergeInfo)(table, col, row);
        mergeInfo && (col = mergeInfo.end.col, row = mergeInfo.end.row), col !== table.colCount - 1 || bottomRight ? (col === table.frozenColCount - 1 && table.scrollLeft && !bottomRight || 0 === col && bottomRight) && (width -= 1) : width -= 1, 
        row !== table.rowCount - 1 || bottomRight ? (row === table.frozenRowCount - 1 && table.scrollTop && !bottomRight || 0 === row && bottomRight) && (height -= 1) : height -= 1;
    } else "corner-frozen" === group.role && (table.scrollLeft && !bottomRight && (width -= 1), 
    table.scrollTop && !bottomRight && (height -= 1));
    return {
        width: width,
        height: height
    };
}

function getQuadLineDash(lineDash) {
    return 1 === lineDash.length ? [ lineDash[0], lineDash[0], lineDash[0], lineDash[0] ] : 2 === lineDash.length ? [ lineDash[0], lineDash[1], lineDash[0], lineDash[1] ] : lineDash;
}
//# sourceMappingURL=group-contribution-render.js.map
