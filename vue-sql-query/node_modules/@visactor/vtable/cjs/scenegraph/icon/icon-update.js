"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.resetResidentHoverIcon = exports.residentHoverIcon = exports.updateCellRangeIcon = exports.updateCellGroupIcon = exports.updateHierarchyIcon = exports.updateFrozenIcon = exports.updateSortIcon = exports.updateIcon = exports.setIconNormalStyle = exports.setIconHoverStyle = exports.getIconByXY = exports.showClickIcon = exports.hideClickIcon = exports.showHoverIcon = exports.hideHoverIcon = void 0;

const vutils_1 = require("@visactor/vutils"), ts_types_1 = require("../../ts-types"), vrender_1 = require("./../../vrender"), text_icon_layout_1 = require("../utils/text-icon-layout"), merge_range_1 = require("../../tools/merge-range"), util_1 = require("../../tools/util");

function hideHoverIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "mouseenter_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 0);
        const iconBack = icon.parent.getChildByName("icon-back");
        iconBack && iconBack.setAttribute("visible", !1);
    }), scene), scene.updateNextFrame());
}

function showHoverIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "mouseenter_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 1);
    }), scene), scene.updateNextFrame());
}

function hideClickIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "click_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 0);
    }), scene), scene.updateNextFrame());
}

function showClickIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "click_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 1);
    }), scene), scene.updateNextFrame());
}

function getIconByXY(col, row, x, y, scene) {
    let pickMark;
    return scene.getCell(col, row).forEachChildren((mark => {
        mark.role && mark.role.startsWith("icon") && mark.containsPoint(x, y, vrender_1.IContainPointMode.GLOBAL) && (pickMark = mark);
    })), pickMark;
}

function setIconHoverStyle(baseIcon, col, row, cellGroup, scene) {
    var _a, _b;
    if ((baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon => icon.name === baseIcon.name), (icon => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (icon.attribute.backgroundColor) {
            let iconBack = icon.parent.getChildByName("icon-back");
            iconBack ? iconBack.setAttributes({
                x: (null !== (_a = icon.attribute.x) && void 0 !== _a ? _a : 0) + (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                y: (null !== (_b = icon.attribute.y) && void 0 !== _b ? _b : 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                dx: null !== (_c = icon.attribute.dx) && void 0 !== _c ? _c : 0,
                dy: null !== (_d = icon.attribute.dy) && void 0 !== _d ? _d : 0,
                width: icon.backgroundWidth,
                height: icon.backgroundHeight,
                fill: icon.attribute.backgroundColor,
                cornerRadius: 5,
                visible: !0
            }) : (iconBack = (0, vrender_1.createRect)({
                x: (null !== (_e = icon.attribute.x) && void 0 !== _e ? _e : 0) + (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                y: (null !== (_f = icon.attribute.y) && void 0 !== _f ? _f : 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                dx: null !== (_g = icon.attribute.dx) && void 0 !== _g ? _g : 0,
                dy: null !== (_h = icon.attribute.dy) && void 0 !== _h ? _h : 0,
                width: icon.backgroundWidth,
                height: icon.backgroundHeight,
                fill: icon.attribute.backgroundColor,
                cornerRadius: 5,
                pickable: !1,
                visible: !0
            }), iconBack.name = "icon-back"), icon.parent.insertBefore(iconBack, icon);
        }
        icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.hoverImage && (icon.image = icon.attribute.hoverImage);
    }), scene), baseIcon.tooltip) {
        const {x1: left, x2: right, y1: top, y2: bottom} = baseIcon.globalAABBBounds, tooltipOptions = {
            content: baseIcon.tooltip.title,
            referencePosition: {
                rect: {
                    left: left,
                    right: right,
                    top: top,
                    bottom: bottom,
                    width: baseIcon.globalAABBBounds.width(),
                    height: baseIcon.globalAABBBounds.height()
                },
                placement: baseIcon.tooltip.placement
            },
            disappearDelay: baseIcon.tooltip.disappearDelay,
            style: Object.assign({}, null === (_a = scene.table.internalProps.theme) || void 0 === _a ? void 0 : _a.tooltipStyle, null === (_b = baseIcon.tooltip) || void 0 === _b ? void 0 : _b.style)
        };
        scene.table.internalProps.tooltipHandler.isBinded(tooltipOptions) || scene.table.showTooltip(col, row, tooltipOptions);
    }
}

function setIconNormalStyle(baseIcon, col, row, scene) {
    (baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon => icon.name === baseIcon.name), (icon => {
        const iconBack = icon.parent.getChildByName("icon-back");
        iconBack && iconBack.setAttribute("visible", !1), icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.originImage && (icon.image = icon.attribute.originImage);
    }), scene);
}

function updateIcon(baseIcon, iconConfig, col, row, scene) {
    const iconName = baseIcon.name;
    updateCellRangeIcon(col, row, (icon => icon.name === iconName), (icon => {
        (0, text_icon_layout_1.dealWithIcon)(iconConfig, icon), icon.name = iconConfig.name;
    }), scene), scene.updateNextFrame();
}

function resetSortIcon(oldSortCol, oldSortRow, iconConfig, scene) {
    const oldSortCell = scene.getCell(oldSortCol, oldSortRow);
    if ((0, vutils_1.isValid)(oldSortCell.mergeStartCol) && (0, vutils_1.isValid)(oldSortCell.mergeStartRow) && (0, 
    vutils_1.isValid)(oldSortCell.mergeEndCol) && (0, vutils_1.isValid)(oldSortCell.mergeEndRow)) for (let col = oldSortCell.mergeStartCol; col <= oldSortCell.mergeEndCol; col++) for (let row = oldSortCell.mergeStartRow; row <= oldSortCell.mergeEndRow; row++) {
        let oldIconMark;
        scene.getCell(col, row).forEachChildren((mark => "sort" === mark.attribute.funcType && (oldIconMark = mark, 
        !0))), oldIconMark && ((0, text_icon_layout_1.dealWithIcon)(iconConfig, oldIconMark), 
        oldIconMark.name = iconConfig.name);
    } else {
        let oldIconMark;
        (0, util_1.traverseObject)(oldSortCell, "children", (mark => "sort" === mark.attribute.funcType && (oldIconMark = mark, 
        !0))), oldIconMark && ((0, text_icon_layout_1.dealWithIcon)(iconConfig, oldIconMark), 
        oldIconMark.name = iconConfig.name);
    }
}

function checkSameCell(col1, row1, col2, row2, table) {
    const range1 = table.getCellRange(col1, row1), range2 = table.getCellRange(col2, row2);
    return range1.start.col === range2.start.col && range1.start.row === range2.start.row && range1.end.col === range2.end.col && range1.end.row === range2.end.row;
}

function updateSortIcon(options) {
    const {col: col, row: row, iconMark: iconMark, order: order, oldSortCol: oldSortCol, oldSortRow: oldSortRow, oldIconMark: oldIconMark, scene: scene} = options, icon = scene.table.internalProps.headerHelper.getSortIcon(order, scene.table, col, row);
    if (iconMark && updateIcon(iconMark, icon, col, row, scene), !checkSameCell(col, row, oldSortCol, oldSortRow, scene.table)) {
        const oldIcon = scene.table.internalProps.headerHelper.getSortIcon("normal", scene.table, oldSortCol, oldSortRow);
        oldIconMark ? updateIcon(oldIconMark, oldIcon, oldSortCol, oldSortRow, scene) : resetSortIcon(oldSortCol, oldSortRow, oldIcon, scene);
    }
}

function updateFrozenIcon(scene) {
    for (let col = 0; col < scene.table.colCount; col++) for (let row = 0; row < scene.table.columnHeaderLevelCount; row++) updateCellRangeIcon(col, row, (icon => "frozen" === icon.attribute.funcType), (icon => {
        const iconConfig = scene.table.internalProps.headerHelper.getFrozenIcon(col, row);
        (0, text_icon_layout_1.dealWithIcon)(iconConfig, icon), icon.name = iconConfig.name;
    }), scene);
}

function updateHierarchyIcon(col, row, scene) {
    let iconConfig;
    iconConfig = scene.table.isHeader(col, row) ? scene.table.internalProps.headerHelper.getHierarchyIcon(col, row) : scene.table.internalProps.bodyHelper.getHierarchyIcon(col, row), 
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === ts_types_1.IconFuncTypeEnum.collapse || icon.attribute.funcType === ts_types_1.IconFuncTypeEnum.expand), (icon => {
        (0, text_icon_layout_1.dealWithIcon)(iconConfig, icon), icon.name = iconConfig.name;
    }), scene);
}

function updateCellGroupIcon(cellGroup, filter, dealer) {
    cellGroup && "empty" !== cellGroup.role && cellGroup.forEachChildren((child => {
        "group" === child.type ? updateCellGroupIcon(child, filter, dealer) : filter(child) && dealer(child);
    }));
}

function updateCellRangeIcon(col, row, filter, dealer, scene) {
    const cellGroup = scene.getCell(col, row);
    if ("cell" === cellGroup.role && (0, vutils_1.isValid)(cellGroup.mergeStartCol) && (0, 
    vutils_1.isValid)(cellGroup.mergeStartRow) && (0, vutils_1.isValid)(cellGroup.mergeEndCol) && (0, 
    vutils_1.isValid)(cellGroup.mergeEndRow)) {
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = (0, 
        merge_range_1.getCellMergeRange)(cellGroup, scene);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) updateCellGroupIcon(scene.highPerformanceGetCell(col, row), filter, dealer);
    } else updateCellGroupIcon(cellGroup, filter, dealer);
}

function residentHoverIcon(col, row, scene) {
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === ts_types_1.IconFuncTypeEnum.dropDown), (icon => {
        icon.oldVisibleTime = icon.attribute.visibleTime, icon.setAttribute("visibleTime", "always"), 
        icon.setAttribute("opacity", 1);
    }), scene);
}

function resetResidentHoverIcon(col, row, scene) {
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === ts_types_1.IconFuncTypeEnum.dropDown), (icon => {
        icon.oldVisibleTime && icon.setAttribute("visibleTime", icon.oldVisibleTime), icon.setAttribute("opacity", "always" === icon.attribute.visibleTime ? 1 : 0);
    }), scene);
}

exports.hideHoverIcon = hideHoverIcon, exports.showHoverIcon = showHoverIcon, exports.hideClickIcon = hideClickIcon, 
exports.showClickIcon = showClickIcon, exports.getIconByXY = getIconByXY, exports.setIconHoverStyle = setIconHoverStyle, 
exports.setIconNormalStyle = setIconNormalStyle, exports.updateIcon = updateIcon, 
exports.updateSortIcon = updateSortIcon, exports.updateFrozenIcon = updateFrozenIcon, 
exports.updateHierarchyIcon = updateHierarchyIcon, exports.updateCellGroupIcon = updateCellGroupIcon, 
exports.updateCellRangeIcon = updateCellRangeIcon, exports.residentHoverIcon = residentHoverIcon, 
exports.resetResidentHoverIcon = resetResidentHoverIcon;
//# sourceMappingURL=icon-update.js.map
