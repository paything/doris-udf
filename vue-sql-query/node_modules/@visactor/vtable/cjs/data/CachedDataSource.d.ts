import { type FieldData, type FieldDef, type IListTableDataConfig, type IPagination, type MaybePromiseOrUndefined } from '../ts-types';
import type { BaseTableAPI } from '../ts-types/base-table';
import type { ColumnsDefine } from '../ts-types/list-table/layout-map/api';
import type { DataSourceParam } from './DataSource';
import { DataSource } from './DataSource';
export declare class CachedDataSource extends DataSource {
    private _recordCache;
    private _fieldCache;
    groupAggregator: any;
    private _isGrouped;
    static get EVENT_TYPE(): typeof DataSource.EVENT_TYPE;
    static ofArray(array: any[], dataConfig?: IListTableDataConfig, pagination?: IPagination, columns?: ColumnsDefine, rowHierarchyType?: 'grid' | 'tree', hierarchyExpandLevel?: number): CachedDataSource;
    constructor(opt?: DataSourceParam, dataConfig?: IListTableDataConfig, pagination?: IPagination, columns?: ColumnsDefine, rowHierarchyType?: 'grid' | 'tree', hierarchyExpandLevel?: number);
    protected getOriginalRecord(index: number | number[]): MaybePromiseOrUndefined;
    protected getRawRecord(index: number | number[]): MaybePromiseOrUndefined;
    protected getOriginalField<F extends FieldDef>(index: number, field: F, col?: number, row?: number, table?: BaseTableAPI): FieldData;
    clearCache(): void;
    protected fieldPromiseCallBack<F extends FieldDef>(index: number, field: F, value: MaybePromiseOrUndefined): void;
    protected recordPromiseCallBack(index: number, record: MaybePromiseOrUndefined): void;
    get records(): any[];
    release(): void;
    _generateFieldAggragations(): void;
    processRecords(records: any[]): any;
    getGroupLength(): number;
    updateGroup(): void;
    getOriginRecordIndexForGroup(recordIndex: number | number[]): number;
    addRecordsForGroup(recordArr: any[], recordIndex?: number | number[]): void;
    deleteRecordsForGroup(recordIndexs: (number | number[])[]): void;
    updateRecordsForGroup(records: any[], recordIndexs: (number | number[])[]): void;
    addRecordsForTree(recordArr: any[], recordIndex?: number | number[]): void;
    deleteRecordsForTree(recordIndexs: (number | number[])[]): void;
    updateRecordsForTree(records: any[], recordIndexs: (number | number[])[]): void;
    adjustBeforeChangedRecordsMap(insertIndex: number | number[], insertCount: number, type?: 'add' | 'delete'): void;
    cacheBeforeChangedRecord(dataIndex: number | number[], table?: BaseTableAPI): void;
    getGroupSeriesNumber(showIndex: number): number;
}
